The needle/haystack thing is kind of annoying, but I think it's even consistent. If I remember correctly, array functions have it one way, and strong functions are the other.
I think using PHP_EOL and . for concatenation makes the code clearer but it's a personal preference.
That's fair. Sorry, I'm not trying to derail this subreddit, obviously I'm not a huge PHP fan but I like to keep up to date with it. The minute it's better than other languages for my uses, I'll likely come back. I'm not blindly following, just trying to stay ahead of the tech curve.
yes, passing multiple arguments is faster because echo just prints them one by one, whereas using the '.' operator it creates a new string in the memory (for each concatenation) and only prints it then
Ditch the concatenation and use only commata for max performance: echo "Line 1 foo bar blah", PHP_EOL, "Line 2 bar foo blah", PHP_EOL, "Line 3 blah bar foo", PHP_EOL; Concatenation requires the Zend Engine to allocate additional memory in order to glue the value of the PHP_EOL constant to the prepended string value. When using commata instead, no copying/allocation is necessary as echo will simply dump the given values into the output stream.
The purpose is largely legibility. As I say, I avoid using echo *ever* in production code, because there are much better ways of accomplishing output. But, when one must use echo, it can be pretty.
I am confused... why exactly would you have to "install" CakePHP?
 $output = array('Line 1 foo bar blah', 'Line 2 bar foo blah', 'Line 3 blah bar foo'); echo implode("\n", $output);
It's amazing how you managed to make use of not only arrays, but also the implode function. Illegible, *and* insane! :)
Would you trust everything you read on some random stranger's CV?
The needle/haystack complaint is just nit picky and Phil correctly points out that that is a worthless argument. Sure php has flaws, but the needle/haystack issue is a minor annoyance at worst and has never caused me to pull my hair out or lose sleep...
I sure hope that you aren't using this for performance reasons... A valid reason to use this syntax would be operator precedence: echo 'X: ', 1 + 2; // works echo 'X: ' . 1 + 2; // doesn't work 
I almost used vprintf $output = array('Line 1 foo bar blah', 'Line 2 bar foo blah', 'Line 3 blah bar foo'); vprintf('%s\n%s\n%s\n', $output);
I'm not using it at all. There are better ways of producing output than echo. :) However, in cases where I must use echo (consistency in legacy projects), I suppose I could use this for stylistic reasons.
Unfortunately, I'm not fantastic at math. 
Sorry, I didn't look at who posted the content, thus I naturally assumed the typical "You should use single quoted strings because they are faster than doubled quoted ones".
The files get placed on the server and the server/app is configured accordingly. Once everything checks out, it's installed. That is pretty common terminology for getting frameworks up and running - Documentation almost always include an 'installation' section. See: [Symfony](http://www.symfony-project.org/installation), [Fuel](http://docs.fuelphp.com/installation/instructions.html), and even [Cake](http://book.cakephp.org/2.0/en/installation.html).
Nothing to apologise for imo. As far as I'm concerned this was nothing but civil conversation.
Well the nice thing about programming experience is that it usually leaves behind proof of their past work, so you can see the product, and usually some code samples.
Same reason you "install" other frameworks, or even Drupal / Wordpress etc.
&gt; how about building something maintainable and elegant long term That's what frameworks are for. FuelPHP, that Phil works on, is an elegant framework that just *loves* well structured code and applications.
I don't know who you mix with, but it does not sound like the kind of people I work with.
I've written enterprise-level software in PHP, Python, Ruby, Javascript w/ Node, and Perl. Python, Ruby, and Javascript are all great languages and I really enjoy using them (I'm not going to bring up Perl, as I have nothing nice to say). I would encourage any programmer to go learn themselves some Python. I ABSOLUTELY love those languages. Lots of fun to work with. But, and this is just my own personal experience, but out of all of those projects coded in all of those languages, PHP stands out in my mind as having been the simplest, most effortless language to use. It's really easy to write shitty PHP and it takes a concerted effort on the part of the developer or an engineering team to adhere to consistency standards; but once you're past that stage, PHP is powerful enough to take care of most jobs while being loose enough that you won't rip your hair out.
Critics of PHP as a language make a lot of bluster about how horrible it is to work with, but the primary reason that those backwards-compatibility-breaking fixes aren't made is that the problems aren't actually doing anything more than being annoying. They're not security flaws; they're mild annoyances. The problems that one could fix in PHP when forking it are not major enough that *anyone* would move to that fork.
The author points out my biggest pet peeve: the inconsistent needle/haystack ordering. He also mentions the str_* vs str* vs *_str vs *str thing. He's absolutely right that the PHP people *could* fix this all and have so far put it very low on the priority list. The fact is that I have little faith that they will. When they DO go fully OO primitives, what's to stop them from mixing up the argument orders again? What's to stop them from bungling something else fairly basic like their controversial decision to use \ as a namespace separator recently? Have they learned their lesson? I use PHP because it's where they money is right now. That's doesn't make it a good language.
What can you make with PHP? * Websites * Command line programs (in a single executable) * GUI Programs (again in an executable) * Cross Platform programs * Shell/CMD scripts * Make Android and iPhone apps It's a very flexible language and can do a lot without too much training. No language is perfect, but PHP really isn't that bad. For some tasks PHP is better, and for some, other languages.
Thoughts on [Presta](http://www.prestashop.com/)?
Well... actually... there is no install... it's just that they are using that word so that newbies (which we weren't talking about in this post) can figure out how to get started. If any developer worked for me and referred to using Cake as "installing" it... I would fire him/her on the spot.
Not really... those apps have installers... Cake does not have an installer. You merely copy the files to your project and start developing...
Personally i would love the beginning of a new working relationship being based on distrust, that is just plain excellent... If you have serious developers they wil be able to asses the skills of another developer with ease, ask them about coding paradigms, languages, platforms they've used, wheter or not they like using frameworks and/ or design patterns and if not how their files are normally organised, also about standards they've generated with PHP (eg. HTML, XML, RSS, JSON, etc.). You can even go as far as asking what parts of PHP they like and/ or dislike compared to other languages on their CV. The answers should give you a fair idea of their programming skill level without the need to give them a time consuming assignment.
&gt;The first candidate to receive the exercise selected CakePHP and complained that it took him 6 hours to install it before he gave up. *Framework experience isn't required* Seriously? You don't require any framework experience and yet you think the candidates are going to be able to do this in 4 hours? Even if they could.. would they? I would personally think it was a scam and that somebody was trying to get me to code for free. I wouldn't apply.. I could discuss the implementation with you in about 5 minutes, go over how I'd do it, what problems I'd expect to face etc..
If you have a programming question that takes more than 20 LOC or 5 minutes to answer, you're wasting people's time.
There's https://code.google.com/p/phpreboot/, but it doesn't fix any of the shit that bugs me.
Even in this economy I'd tell you to go fuck yourself... with all due respect.
http://book.cakephp.org/2.0/en/installation.html CakePHP is fast and easy to install. A development installation is the fastest method to setup Cake. This example will help you install a CakePHP application. http://book.cakephp.org/2.0/en/installation/advanced-installation.html I guess I'll just say that the creators of CakePHP refer to this as "installation".
No worries, everyone but this guy is wrong and its just a concession for newbies because Cake, Symfony, Fuel etc. all target newbies obviously.
I'd fire any asshole pretentious enough to indicate using an accepted term merits firing someone.
I think it really depends on how good a job you're giving. If you're a great company to work at with lots of benefits, and the pay is significantly above average, then sure, you need people who have that kind of experience where this should be second nature. I could probably write something like that in about 4 hours using just PDO, as long as it didn't have to do proper human testing. The real question is whether it's a waste of time. Really, if they can show you some cool projects they've worked on, that should be enough. Have them show you their code, and let them walk one of your devs through some of the more interesting points, and that should be quite sufficient.
How many times do you have to do this optimization to shave 1 second off of run time? Alternately, if you are worried about memory, how many instances to use 1MB more memory.
How many times do you have to do this optimization to shave 1 second off of run time? Alternately, if you are worried about memory, how many instances to use 1MB more memory.
Yes, way too much. You will never get a good developer that way because a good developer has too many offers to be coding 4-8 hours for free for you.
I started with PHPEd actually, then netbeans, then phpstorm. In that time I'd moved to a Mac as well. I think phpstorm is a lot easier to deal with. I find myself actually using many of the features. One benefit to PHPEd though us that it's a native windows app, and not java-based. So it can have a speed advantage. But not so important unless you're on ancient hardware.
With the enormous memory footprint of PHP arrays, using them as argument passing for every single call site in your application seems ridiculous. And if you're not going to do it as a convention, you probably shouldn't do it at all.
I think you're probably making too much out of that. As arguments, they'll fall out of scope fairly rapidly leaving the memory to be reused. If I were making arrays containing thousands of elements you might have a point. However this is fairly minimal.
What the fuck are you talking about? PHP has the most extensive frameworks of the three languages you've mention and has had the forefront for probably the last 3 years.
But all of them won't fall out of scope until the entire stack has been cleared. So, if you're in a reasonably complex set of stack frames, say 30 deep, you could as many as 30 2-3 dimensional arrays allocated unnecessarily. At ~150 bytes per array element, that's 9kB of entirely wasted stack space. Once you double that for your default array, you're at 18kB. And that's just overhead, not even counting the weight of your parameter values themselves! It's not an insignificant amount of memory.
I would at least have the framework installed and ready to go. Perhaps a a series of smaller tasks would be more flexible.
If you're making a GUI or mobile app in PHP you deserve to be beaten with a stick. Yes, it's possible, yes, it's supported, but no. Just no.
Honestly anyone complaining about the needle/haystack problem is just being a dick. It's *really* not an issue at all. Haven't you ever heard of an IDE with code completion? I use Eclipse, and when I forget the order of arguments I simply press CTRL+Space and BAM, there they are - complete with a description of the function and example usage. So please, stop jumping on the RoR/Django bandwagon and stfu already.
Ubuntu server, just because it's also my desktop distro of choice.
Anyone using Ubuntu as a webserver actually, lol.
Have you tried [Virtuemart](http://virtuemart.net/)? I've used 1.x but never got into 2.x
If it's on a server hosting a popular website, every little bit helps. If it's not, it's good practice if it doesn't have some other detrimental effect, such as reducing readability.
&gt; Anyone who has used PHP for a while knows that it has its ugly parts. Recently I've seen a whole swathe of PHP-bashing articles and that would be fine if they were they are making a valid point, but some of it has just been - as I tweeted recently - "absolute drivel". What's the problem with this paragraph? It's fine English. EDIT: changed the quote so that my point would still stand.
&gt; The author points out my biggest pet peeve: the inconsistent needle/haystack ordering. He also mentions the str_\* vs str\* vs _str vs \*str thing. He's absolutely right that the PHP people *could* fix this all and have so far put it very low on the priority list. How are they going to fix needle/haystack ordering at this stage of the game? Kajillions of lines of code are using the existing argument order. Changing the order would introduce subtle bugs almost impossible to reliably find. The only opportunity for fixing this would be as part of adding a more OOP syntax to strings and arrays.
If it's a matter of typing a comma instead of a period, you can just do it going forward and know that you're getting that tiny bit of extra performance absolutely free. No reason to fret about it.
I find it hard to abide the way RHEL is typically several years behind on feature updates. It makes it very difficult to use software for any contemporary technology.
What are these "much better ways of accomplishing output" that you keep going on about?
&gt; When they DO go fully OO primitives, what's to stop them from mixing up the argument orders again? PHP was a different project when those functions were added to the language. It was, quite literally, hacked together to make Personal Home Pages. Now it's used by millions of developers and it's no longer one developer's decision to build an API. &gt; What's to stop them from bungling something else fairly basic like their controversial decision to use \ as a namespace separator recently? It may have been controversial but they do have limited characters available. Unlike C++ or Java (where PHP gets much of it's OO syntax from) identifiers for classes and namespaces are unknowable at compile time so that necessitates a new character(s). I ranted against the backslash when it came out but after using it for a while now I'm actually ok with it. 
Right now I'm deciding if I should learn ruby on rails, or python / django. What are your thoughts?
I don't get how this can be *anyone's* biggest issue with PHP. If you don't have code hinting in your development environment *and* you can't remember, write a tiny library/helper that rewrites the string functions into a version you prefer with consistent naming and parameter order.
If they have a CS degree, it's a completely valid approach.
I feel like this would be a better way to approach it. Anyone can learn how to code given time, what I'd be interested in is how they work their way through the planning process. Adding stuff and hacking it in as you need it may work fine for something like a simple forum, but this can have some bad consequences with more complex systems.
 int stripos ( string $haystack , string $needle ) mixed str_replace ( mixed $needle , mixed $newneedle , mixed $haystack ) string strstr ( string $haystack , mixed $needle ) 
There's some truth to that. I still don't think it would amount to enough to be worried about though.
I don't think I'd put up with that kind of aptitude test outside of some highly selective organization that plans on paying me a lot of money. My concern is that you're weeding out qualified candidates with such a test. I've just recently started my first full-time programming job working with Magento (built upon Zend Framework) and though I've been coding for quite some time on my own accord and in a previous part-time gig, this has been my first experience with an MVC framework and object-oriented programming within PHP. The first few days I had barely a clue what the fuck I was looking at--though to be fair Magento is an undeniable _mess_ of code--but within a week or two I managed to build a full-fledged extension: new models, views, and controllers; overloading core classes; database interaction; integrating with other parts of the framework. Utilizing pretty much all of the fundamental features you get with a typical framework. If you're willing to accept entry-level or junior candidates, even those without framework experience, I think it's unrealistic to expect them to complete such this in the timeframe you've described. And most people who *could* complete it wouldn't want to. &gt;I was very clear that applicants should not feel rushed to return the exercise, and do not intend to take time-to-respond into consideration. This doesn't matter. You could tell me that if I take more than 6 hours I will get a 30-minute intermission and a complimentary handjob from a Jayne Mansfield impersonator before continuing. I would still feel like I was under the gun, and probably not take as much time to think about my solutions as I normally would. &gt;Off the cuff, I see four models with 3 to 5 properties each, two controllers, three views, and a Google search on password hashing. It might be better to just flat out ask the candidate for a quick design and see if his/her answers are similar, or at least on the right track. I've never been on the other side of an interview but I always enjoyed those kinds of open-ended questions because you can demonstrate what you know and account for what you don't know. A few weeks ago I'd have to tell you that, "well, from what I know of the MVC architecture, I'd need models for the relevant objects, probably one each for users, subforums, threads and posts. The controllers would have to handle user requests and get the ball rolling when logging in or posting new threads, for example. Also, blah blah, et cetera, so on . . ." I'd never be able to actually make the forum then and there for you but I damn well could convince you that I still have potential to do it. And if I couldn't, then at least I didn't have to take a fucking test for 5+ hours. So I'd recommend just asking a lot of questions. "You've added code to the website and now it's broken to shit. What do you do to fix it?" - "Good" answers: - I was using Git so I can revert the latest commit and start over; checkout a previous commit; get a diff between the last working commit and the current one and check line by line for problems. - Turn on error reporting. - Check server logs. - Consult a rubber ducky. "Bad" answers: - HURRRRRRRRRRRRRRRRRRRRRRRRR - DUrrrrrrrrrrrrrrrrrrrrrr "What would you need to design and create a basic bulletin board, and how would you go about implementing your ideas?" - "Good" answers: - I could use a framework to accelerate the development process as it would likely have components for safe and secure database interaction, authentication, templating. - Whatever - Other bullshit "Bad" answers: - I'm sorry I wasn't listening - where is the bathroomlol
It's not too much in terms of difficulty. The skills required to pull that off are pretty straightforward. However, it's way more of a time sink than I'd be willing to put into applying for a job and I'd think that any company requesting such a project as a "test" simply didn't respect my time. 
I meant from the perspective of Reddit users, in production situations. Their site shows what features it adds, but how many people are using these features, and how stable are they?
+1 for Django. Most of the stuff I get to do is with PHP, and I've tried a couple of PHP frameworks (ZF and CI) too. I haven't gone too deep on using ZF but the feeling I have is that it's ages away from Django. Sure... you can probably do the same app with both frameworks, but Django saves you SO MUCH TIME. Building the admin is seriously trivial, and CRUD operations are at least half the code...just take a look at [Django models](https://docs.djangoproject.com/en/dev/topics/db/models/)!!! You want a foreign key... you use the god damned ForeignKey field! ZendFramework, [on the other hand](http://framework.zend.com/manual/en/zend.db.table.relationships.html)...
&gt; abandoning all the array_* and str[_]* functions in favour of proper methods attached to primitives this is on the roadmap, but there are plenty of classes on github that will do this for you. You may have to call something like: $s = new String('hello'); $s-&gt;toUpper()-&gt;filter(array('a','l'))-&gt;length(); &gt; abandoning the error suppression operator (@) agreed, but this has never caused me an issue, so it feels a little pedantic. &gt; using exceptions instead of error reporting I tend to use this: http://php.net/manual/en/class.errorexception.php
&gt; The author points out my biggest pet peeve: the inconsistent needle/haystack ordering It is ridiculous that they set it up this way, but it's not *really* a problem
Well, if I were to test it and find out for example that it would take 1 million instances to make a difference of half a second, thats pointless, and not a "tiny bit of extra performance".
&lt;?= is the same as &lt;?php echo
I really agree with you. I much prefer to have all the html in template file and then include the file. Even small stuff like &lt;span&gt;hello&lt;/span&gt; I will put in a file (actually I have a template file for &lt;span&gt; tags with an echo in the middle)
If you have a Mercedes, that uses 12 liters of gas on 100 km, and right next to that you have a newer Mercedes that uses only 7 liters. What do you think made the difference when both engines have the same cubic capacity? It's the accumulation of tiny tweaks. Oh, that may not matter at all if you think of yourself just a amateur PHP developer who's code runs on some shared webspace or just a few servers. But if you're a professional, i beginns with the so called "good practice" and ends with profiling and measuring. And what happens if your code runs on more than 10000 servers? When your code is used by thousand co-workers and many more developers in other companies? When your code powers multiple products with a userbase of more than 200 Million? Right, not the scenario an amateur PHP developer thinks about, but well, if you are a professional, these are the things you think about, because throwing hardware at every problem could easily mean doubling your costs, reducing your revenue. And if you can save cpu cycles for free ... stuff adds up and usually makes a big difference in the big picture.
If you really want to optimize, write a program in C or assembler, optimize that, and call that from PHP. Otherwise just accept that PHP is an interpreter that is itself written in C, and in pure PHP regardless of what you do, you are already pretty far removed from the actual machine as it is. Write good PHP code and that doesn't require micro-tinkering, and don't waste time on useless stuff.
Right but what I'm saying is it's only valid to check if they know theoretical CS stuff, not if they can program worth a damn. I've seen CS majors about to graduate who when told to use javascript to display a random color, can't do it in 15 minutes. The only requirements were that you somehow display the color (as a background, border, text color, whatever) and that they can't do a specific search query like "how to display a random color in javascript". Some people just haven't programmed enough and don't know how to apply their knowledge, but more importantly how to break down a problem into smaller solvable pieces if you weren't shown exactly how to do something in class.
shopify.com Honestly, running a site locally isn't worth the hassle and security concerns, which if nothing else it makes you a target.
I appreciate the work that went into this article, but does anyone else feel like it read like a 12th grade report?
If I understand you correctly, I'm sure you could do the same in Drupal in about the same time. 
Just because you can, doesn't mean you should.
Nothing against simple html dom parser but you should take a look at php built in support for [DOM](http://www.php.net/manual/en/book.dom.php) I have used SHDP in the past and have found that since php does support DOM it's faster (not implying simpler here) to use the functions that php offers instead of using something in php that recreates all of the dom functions.
Depending on the process, the overhead of creating a new process might take longer than doing it in PHP
Really, it's just the easiest to point out side effect of a deeper issue. It wasn't designed... at all. Pieces were stolen from Perl list (Perl doesn't need a keyword for it, it's just parens, but it's a VERY common Perl technique), split, etc. Parts were stolen from C (mysql_real_escape_string, strstr, strpos, etc.) They took the argument list and ordering from whatever language they stole it from. Absolutely no effort was made to make any of this consistent. An an example, there are currently 14 XML parsing packages according to php.net. Some are likely related, but they're all given equal weight on the XML page. There is no indication about which one should be the standard go-to for xml parsing. This should be one of PHPs strengths putting so much in the core. Also, maybe I'm the only oddball that doesn't want to dedicate 10% of my CPU to autocomplete.
[/r/lolphp](/r/lolphp) material?
Yep, I'd agree with this in general as well. Once you get to the point where anything like this could matter even if in theory only, its highly questionable that you would continue to use PHP at that point.
https://stripe.com/ never used it but a friend referred it to me
I'd say Python/Django as Python is more useful for a ton of other things like GUI applications etc. Python is a pretty good all around language and it forces you to follow coding constructs that will benefit you in all other programming languages.
I wouldn't work for anyone (or take a contract) that wanted me to use one of these bloatware frameworks. I am a senior level php developer who earns his living building large scale applications end to end - for the last 11 years self employed. There is a reason why people bash PHP... and it's because of dumbass developers who write shitty code, use shitty frameworks that are overkill for 99% of the projects they are used in and refer to copying and pasting files into a project as "installation".
I can refer to my penis as big... that doesn't mean it's big.
Yeah, for heavily relational work, Django is awesome. But make sure to inspect your SQL statements as the ORM can come up with some retarded statements.
is there a PHP framework where you can actually define your models as easily as in Django, and create the tables out of them? (without the inconvenience of having to set up Doctrine)
Sorry in advance but I have to be *that guy* who's always so fucking pedantic. When you use commas instead of periods you're not actually concatenating the string in PHP, rather you're sending multiple arguments to the echo language construct and PHP then internally concatenates in C. This is where the very minor performance difference comes from. You can verify this by checking the manual entry: http://dk2.php.net/echo and seeing it's signature: void echo ( string $arg1 [, string $... ] )
Edited to reflect pedantry. I was aware of this, but it was not the focus of the post.
Good practices involved being practical. On average, optimizing these echos will improve your performance by less than 1/100th of a second. This is not a savings. Also, being a snarky dick doesn't help.
Well, [KohanaPHP](http://kohanaframework.org/) is quite close to the Django model of framework. Here is an example of a model defenition: http://kohanaframework.org/3.2/guide/orm/examples/simple#model Obviously it's not as clear as Django, but there's really no good way to clearly define it in PHP. This is about as good as it gets.
my god... I've been spoiling myself with Django... you set the regex every time?
Yeah, Whereas in django this is defined by the model.field. You could however subclass this field and change anything you need. Kohana isn't as far along as Django, but seems to be following the design pretty close. I'd recommend PHP devs to keep an eye on it or help developing it.
I'm checking some guy's github kohana cms project's models... maybe they [made it easier now](https://github.com/lamberski/kohana-cms/blob/master/classes/model/cms/lang.php)?
He's faked the field implimentation to make it more like Django I think.
smart guy. Well thanks for the info
Given some of the developers that I've seen, getting a CS degree still didn't save them from being crappy developers. Their code and their logic was all over the place.
Nothing at all. Good point.
Write an entire server in C if you're so inclined :) I think the bottleneck on nearly every web service ever has been the database, and optimizing your code a *bunch* is just a waste of your time since, if you ever need to scale your php side, you can just throw machines at it (whereas adding features to extremely optimized code can be a bitch).
I occasionally use a comma when I would otherwise "concatenate an expression", so rather than echo 'x = ' . (1 + 2) . ' !'; echo 'x =', 1 + 2, ' !'; which can be more readable when you have a complex expression. Though this is generally only in small test scripts and so on: there isnt much call to use IO generally.
So, I wanted to weigh in on this as I believe that I was actually present at the origin of this "myth". To get a little more in-depth on this, you need to look more in to the internals of the code. This can be done using [VLD — Vulcan Logic Disassembler](http://pecl.php.net/vld) by [Derick Rethans](http://derickrethans.nl/projects.html#vld). We will use VLD to examine the internal opcodes for these two simple lines of code: &lt;?php echo "Hello " . "World" . PHP_EOL; and &lt;?php echo "Hello ", "World", PHP_EOL; Then we run them with VLD: php -dvld.active=1 &lt;file&gt; For the first we get: Finding entry points Branch analysis from position: 0 Return found filename: /Users/davey/src/echo.php function name: (null) number of ops: 5 compiled vars: none line # * op fetch ext return operands --------------------------------------------------------------------------------- 2 0 &gt; EXT_STMT 1 CONCAT ~0 'Hello+', 'World' 2 CONCAT ~1 ~0, '%0A' 3 ECHO ~1 3 4 &gt; RETURN 1 branch: # 0; line: 2- 3; sop: 0; eop: 4 path #1: 0, In this case you see two CONCAT operands, which each create a temporary variable, this can be determined by the "return" column. You can see that the first one creates temp var *~0*, then the second concats *~0* with the EOL, and creates *~1*, then finally *~1* is echoed. So we create two temporary variables. The second line of code looks like this: Finding entry points Branch analysis from position: 0 Return found filename: /Users/davey/src/echo2.php function name: (null) number of ops: 5 compiled vars: none line # * op fetch ext return operands --------------------------------------------------------------------------------- 2 0 &gt; EXT_STMT 1 ECHO 'Hello+' 2 ECHO 'World' 3 ECHO '%0A' 3 4 &gt; RETURN 1 branch: # 0; line: 2- 3; sop: 0; eop: 4 path #1: 0, In this case, we see three separate ECHO operands (the same number of opcodes) but zero temporary variables — the creation, assignment and garbage collection of these temporary vars is where the *overhead* comes in. It's minuscule, but it's there, and completely pointless going after for a performance win.
I was joking, however nobody seemed to notice the sarcasm. I agree, a CS degree doesn't help your code quality. It just means when you're faced with some crazy statistical analysis or sort algorithm, you'll know the right way to do it.
No worries. I can't believe I just made these type of posts on PHP and didn't get my ass down voted to oblivion.
I started with PHP because,... that's what the guy who introduced me to programming knew, and I stuck with it because it's easier to get a job... but it's really hard to argue that PHP &gt; Python. And Django is the best framework I've seen so far. ZF is really extensive, and maybe it has more developers behind it (hell, it has Zend behind it!), but Django makes more sense to me, because Python makes more sense to me. There's room for both languages in the world...I think it's pretty clear neither of us is bashing
Guess what those installers do. They copy files! Amazing!
If you ask someone to do an entire day's work you should pay them a day's wages. Why should they eat the cost of your hiring process?
I am accustomed to being paid for trial work.
The typical installer does much more than copy files... please don't insult my intelligence.
I think that doing a custom php extension might be a good compromise here, as you could easily slot that in with the rest of your php code and not have to make a system() call to run it. That is, if your highly CPU intensive task needs to be web exposed.
Amen. Scaling a well written php application isn't particularly difficult for the first order of magnitude, though it seems that for the second order you'll face considerable challenges. That's true across any language, though.
Seconded about Magento. It's what I work almost exclusively in when dealing with ecommerce. It's very powerful and very extensible but like you said it's resource heavy and it also has a steep learning curve and some horrible documentation. Although a ZF background helps as well. Loved when a client wanted to know if he would be able to host Magento on his 1and1 shared account...
guys, please use [printf](http://www.php.net/manual/en/function.printf.php) THIS is readable: `printf("x = %d !", 1 + 2);`
Yes, i use printf and sprintf and vsprintf as well (I know c\\++ too!), but we're talking about echo and when it might be reasonable to use a comma. I was merely providing a situation in which it would make some sense to use a comma whereas the assumption was that it is merely an aesthetic or pseudo-performance choice ... it does, in fact, have a grammatical use.
I often need to sanitize several million fields in one go (importing large numbers of database rows whose many fields may contain HTML of untrusted origin and possibly invalid markup, so DOM-based solutions are out), and I've not found a good solution yet. HTMLPurifier would take literally weeks to plough through this lot, and I need it done in a few seconds. Is there a PHP extension for HTML sanitizing, along the lines of HTML purifier or HTMLawed, but without the massive speed penalty? Or perhaps some other binary (like tidy, or something in some other language) that could be called efficiently? It's such a common requirement (and should be more so), that it would be nice to see it in PHP core. I'm currently using an old pear filter that uses a sax3 parser with tag and attribute whitelisting, and though it's much faster than the two big names, it's nowhere near as good, and it's still not fast enough.
If you run fopen on php://output and fwrite to that you dont run into the same problem as you do when you try to echo massive chunks of data.
I meant to mention one that could have a future: wibble by Pádraic Brady: https://github.com/padraic/wibble I did give that a go, but it seemed to have real trouble with invalid markup, either failing completely or removing nearly all of the doc.
OP is correct, but consider this * Using commas with echo is like passing argument to a function, common sense tells it has to be faster than using dots/periods which actually concatenates a string and then passes it as a single argument to echo. * That tiny number matters when you have a data center just running the same instance of code on different boxes to give you that 99.99% ( four nines) uptime on your beloved webpage. * Last, but as pointed already here, if you are bothered about performance you will write your own PHP compiler/interpreter or a daemon which converts your PHP code into more optimised code. What I feel is, dots/periods or commas is a personal choice, I find commas more readable when I am "sprinkling" variables in a HTML string. 
You don't really need to rename variables, but if you insist, you could loop and use [variable-variables](http://php.net/manual/en/language.variables.variable.php). line 35: foreach($table as $field =&gt; $value) { $$field = $value; } This will set $product_id = $table['product_id'] and $product_status = $table['product_status'], etc on line 61: foreach($_POST as $key =&gt; $value) { if(isset($value) { $$key = $value; } else { $$key = null; } } same idea as above.
Debian + latest php/mysql from dotdeb.org
I simply do this echo '&lt;html&gt; &lt;head&gt; &lt;title&gt;Title!&lt;title&gt; &lt;/head&gt; &lt;body&gt; Hello World! &lt;/body&gt; &lt;/html&gt;'; Readable and properly formatted. Nothing new or fancy. **EDIT:** Good if you are "sprinkling" variables in html. Thanks [Brillegeit](http://www.reddit.com/user/Brillegeit)
debian-stable is a good balance, the usual updates you are applying are security patches.
are you using apaceh w/mod_php or another server? did you flip the enabled flag on? are you running with apc_stat=0 or 1?
Also, are you trying to use it as an opcode cache or to cache user/script data via the apc_ functions?
Wanted to nag you but it seems you will not be interested in any Indian consultant even if they were better than your current team. 
I am using Apache w/mod_php, apc.stat=off and enabled=on
I am using it for a wordpress blog, I dont think that wp uses apc_xx functions, so its opcode cahce.
&gt; and that would fine &gt; if they were they are All in all the article was well-written. That first paragraph was just not well-written.
&gt;common sense tells it has to be faster Common sense is the enemy of optimization. Optimization is not about guessing where your application spends most of your time, its about knowing. &gt;That tiny number matters when you have a data center just running the same instance of code on different boxes to give you that 99.99% I really don't see how this is true. Every additional box you add would just make it more irrelevant.
And what problem is that?
Very interesting information. I'm going to tuck this away for later use - I was not aware such a tool existed. Needs moar upvotes imo.
&gt;we would need 50x the loops for the difference to amount to one second Or 50 page loads... Your post is centered around some page as if only one person will ever use it. I've never heard it being useful for decreasing memory, but it is useful - and you've proven it, contradictory to your conclusion - for decreasing CPU usage. Maybe you only work on small websites, but there are _plenty_ that get 50 or more connections at any given moment... If you get 50 connections per second, then this is an improvement you would _need_. But even not in that extreme case, have you seen page load drop offs? You don't ever even want to risk reaching a 1 second daily in page loading time. Half a second is bad enough in losing views. I think the issue here is it has relevance in the "real world" and no relevance on personal applications or small-world programs. Further, you're acting like using , instead of . is costing anyone anything. It's a great habit to get into that hurts nothing and helps in large-scale applications, which should be the end-goal of any PHP developer. If you don't, you're just being a hard-ass who doesn't like change. Why not micro-optimize? , is too far away from the . key?
While this definitely shouldn't be at the top of the list (or on the list at all) of things to "go after for a performance win," it should still be used as a programming habit so that you don't have/want to go after it later anyway.
You can take comfort in knowing that grasping arrays and loops isn't difficult and since your code example is so bad you'll be a 5-10x more efficient coder with that simple a-ha moment.
that's right but imo it's never ok to use echo :) unless you don't have interpolation and even then you can still use printf. people should learn Python just to get an idea of how to make the code pretty, then you could apply those principles anywhere else.
I'm saying go ahead and use it if you want to. If you think it makes code cleaner or easier to read then by all means. Arguing that there is a significant performance difference though is absurd. As I stated, I was unable to even produce a performance difference on the budget VPS - some other factor was weighing in and nullifying the difference essentially. &gt;It quickly became obvious that the results were too volatile to have much meaning. If you have a page that does FIVE HUNDRED THOUSAND concatenations in echo statements, you've got MUCH bigger issues. In fact, I'd say that as the number of concatenations goes up, the chances also go up that the concatenation is being preformed elsewhere and not in an echo statement. Also, note that 50x page load would be for my local environment. From the results I got on a VPS, you'd have to load the page nearly 1,000 times. Its almost like a technological form of bikeshedding. People who don't properly profile their code and want to "optimize" it pour a lot of time into things like this not realizing its every bit as irrelevant as what color the bike shed is next to a nuclear reactor. Why not micro-optimize? The answer is simple - people spend way to much fucking time optimizing things that don't need optimized and forget about that database query that is taking 3 seconds to run and bringing the site to its knees. It has nothing to do about not liking change and everything to do with pointing out that perpetuating things like this are **not helpful**
As someone who has worked on a site with 50 requests (to php) per second then no, we would never have bothered with this. There were far, far better ways to spend our time, for instance caching better and more. Besides, you're confusing scaling with performance. Whether or not you can handle 50 requests per second has nothing to do with the performance of a single page load. The single page load determines how many requests per second you can handle per server. If your application can scale it doesn't matter how fast it is as you can just throw more servers at it and keep load time low. If your application cannot scale then you've got bigger problems than concatenation.
&gt;people spend way to much fucking time optimizing It takes no more time to , than .. My point was never to go back and "fix" your .'s to make them ,'s. It was to use , to begin with, when typing the code.
echo shits itself when you give it too much data.
Why C or assembler?! Use HipHop instead: https://github.com/facebook/hiphop-php/wiki/
&gt; Each component would take 5 minutes to get the pieces in place. *If* you know a particular framework extremely well already, and have implemented a fair number of projects in it. If you're someone looking for a job, and every shop wants you to code a custom application for them worth possibly an entire day's of hours, do you think you'd have the time of day?
&gt; Yeah, I'm going to be storing millions(if not billions) of data points. Then why not just use something closer to metal, such as C. PHP is designed primarily for web development, not manipulating custom binary formats.
Yeah, seeing something with a cache, even a static file cache hit ~3k requests per second, it just changes the context of this entirely.
&gt; hhvm is intended to be a replacement for deploying statically compiled HipHop-based binaries to production. Upon its initial release, hhvm provides an overall relative performance increase of 60%. Misleading wording. The 60% increase is over vanilla php, but the paragraph and context would have the reader presume it's over HipHop.
Yeah I know, but PHP is my strongest language. I ended up using the (b) method above. 114M data points in a 29MB file it pretty nice.
Ah, my apologies. It's really hard to tell in text, particularly given all of the trolls and idiots out there. I stay well clear of comments threads in places that discuss economics for fear that my head would explode from the concentrated stupid.
Why?
I've been coding in PHP for years now, and I've written systems that entire divisions' internal web applications run on, but I don't know frameworks. Mainly because I've created my own over the years, which I am trying to get to the point where I can open source it. If you ask me to do something like this, and a company has before, I'm going to laugh and say thanks but no thanks. Ask if the person has coding examples, ask them about the theory behind the design, why they've made certain design decisions, but don't waste their time with stuff like this. I mean really, yes it shows they can do that, but if they're above being able to do that, you're just wasting their time, and if I really don't need a new job, I'm not going to waste mine. In the end, you are prolly turning away more people than you need. You can break this programming assignment down into questions that are trying to tackle what you want to know about the person, and doing it live on a whiteboard where you can directly ask questions is so much better for getting to feel someone out rather than this.
I had a similar test for my current position, but that was for a mid-level position at a respected company. I think we've got a quicker, easier test for junior positions.
&gt; &gt; That tiny number matters when you have a data center just running the same instance of code on different boxes to give you that 99.99% &gt; I really don't see how this is true. Every additional box you add would just make it more irrelevant. I think the point he's trying to make is that the small difference, when multiplied by hundreds of machines, could end up with you using an entire machine more than necessary.
My company are writing custom extensions in C++ to interface with code that's already in C++, and would be measurably slower if re-written in PHP
because you see the entire template string as it'll look without mentally interpolating the variables in place. for mjburgess' example I have to figure out how the string will look like after the dots/commas do their job, with printf you see the *result* first and the interpolation later.
Exactly how much is "massive chunks of data"? I don't think I've ever seen a problem with echo'ing too much data.
I understand this, but I feel you can generally get a better feel for something like that by molding your questions in a certain way rather than forcing someone to take a 2 or 4 hour long test, during which you're not interacting with them. If you're saying the programming itself isn't very complicated, then shouldn't you be more interested in interpersonal / communication skills? Wanting to talk to them rather than just letting them code away for a while? I know how the old me used to function, I wanted to create everything myself (take for instance why I have my own framework). Had you asked me the question 5 years ago, what sorts of libraries do you use? I would have said my own for PHP and JS, now... only one I use that's my own is PHP. If you had asked me why, I would have said because it's easier (right there showing I didn't want to learn other ways), now, if you asked me, I'd tell you it's because I've tried other systems but I feel their approach is wrong for PHP frameworks, and can't find anything much better than jQuery. It's often been my experience that if you understand the principles well enough to explain them to someone, you can always do the work, and you can do it in any language. I do suppose however, this test depends on what you are looking for. I read your comment as you are giving it to everyone, from the beginners (who will have trouble) to the advanced guys (who will find it trivial). When I interviewed for a company, it was to be a lead web dev there (I'm currently a lead web dev at a leading internet company), they asked me to write an application that required a table in the db and consuming a feed from twitter. That's incredibly simple, and I felt that if they weren't even going to ask me architecture questions, but just wanted me to code, obviously I wasn't going to have any input in the design. So, my response is perhaps best tailored for senior developers. I can see the merits of throwing this at someone young, but just realize that when you're recruiting... it's you recruiting, not necessarily the people looking for work. You want the people that an employed but looking for a new problem to tackle, a higher mountain to climb, and those people probably won't waste their time with a 4 hour test, just so you can then vet them some more. You run the risk of alienating, and this missing out on, some good candidates.
so what you're really looking for is someone that's proficient at Google and not someone that can really program...
Having been on the other side of the interview many times now, that's exactly what I do. I like to get to know the person, and you want to see how comfortable they are thinking about things in a different way. You want to challenge them, but not scare them off.
Then it works.
So ... because u like it like that? Sorry bud, but that's not a reason.
APC caches two things, compiled PHP scripts and variables. Variables need to be configured, since you are using Wordpress you can use W3 Total cache to setup a variable cached, but all PHP scripts will already be compiled and cached automatically by APC. If you are seeing only the APC files in the admin, move the admin script to the same location as the rest of your PHP files. The problem here is apache is probably creating multiple caches for multiple threads (which is waste), so a container or bucket is being setup for each instance. I could be wrong here though... I've had amazing success with nginx/php-fpm/xcache.
Before and after I installed APC I used the Apache benchmarking tool [ab](http://httpd.apache.org/docs/2.2/programs/ab.html) to check whether it was actually working. This should definitely show you improvements in the number of handled requests.
Y U NO USE HEREDOC? echo &lt;&lt;&lt;TEXT Line 1 foo bar blah Line 2 bar foo blah Line 3 blah bar foo\n TEXT; Obviously this is often only suitable for direct output and HTML in particular. But it's way too often ignored as feasible alternative.
All of those things are more work than necessary (namely 0). Anything that increases the amount of work that has to be done, or raises the barrier to entry, in a programming language needs to be justified. And you don't have to waste any of that time anywhere but in PHP.
[This](http://en.wikipedia.org/wiki/Stockholm_syndrome) might interest you. It doesn't bother you because you're used to it; coming from another language with an even slightly sane SDK, PHP is an incredible annoyance and pain to work with. It's not just about parameter order, but inconsistent naming scheme, inconsistent use of OO/procedural/quasi-functional APIs, odd behavior that's not defined anywhere, behavioral differences across platforms/SAPIs, etc. etc. There probably is no end to the list of PHP's criticisms; there's no shortage of lists of what's wrong with PHP, you should be able to find a dozen in about 4 seconds. You can be a PHP apologist all you want and I'm not going to fault you for it; I've been there myself. But it is still apologizing for PHP when you have to compensate for an **objectively bad** part of PHP with another tool. The amount of time you spend learning that tool, configuring the tool, etc. is all wasted - and that's not to mention the amount of time and energy wasted looking up functions because the PHP standard library is such a mess. Sure, it only take 30 seconds to look up a function, but 10 developers doing that 10 times each per day wastes almost a man-hour of time (also, there's no shortage of literature about the hard-to-calculate cost of developer interruption - and having to stop writing code to refer to the manual because you can't remember parameter order is an interruption). So, what I mean to say is, don't take criticisms (especially criticisms that are irrefutable) so personally. Your experiences and opinions are not representative of everyone that writes PHP - you may be perfectly okay with a tiny annoyance here and there, but a lot of people aren't. The fact that I have to waste a shitload of time looking up parameter order when I write PHP means it's that much harder to get in the zone, which means it's that much harder to produce quality code. Does it make me a dick that I don't want to waste my time on mindless trivialities that are only necessary because the PHP "designers" decided to NOT design anything? And your random, unrelated jab at RoR and Django is cute, because I refer you again to my link at the beginning of the rant. Use RoR or Django for 6 weeks and let me know if you're still singing the same tune about how great PHP is.
That's not creating a new process.
Extract the apc.php file from the official apc release archive, copy it to the root of your httpdocs folder, then execute it from a browser. It will show you what is currently being cached, the fragmentation ratio and other important variables. You can then adjust memory usage and exclude less popular and very large files from the cache to increase performance. You mentioned that you're running Wordpress. If so, download the W3 Total Cache plugin and install it. If you have installed APC successfully, "Opcode Cache" will appear as an option in the cache configuration drop-downs. Are you running apache as FCGI or as a module?
&gt; Sure, it only take 30 seconds to look up a function, but 10 developers doing that 10 times each per day wastes almost a man-hour of time (also, there's no shortage of literature about the hard-to-calculate cost of developer interruption - and having to stop writing code to refer to the manual because you can't remember parameter order is an interruption). So you're telling me when you develop with Ruby, or Python, etc, that you memorize every single function or API call associated with that language, and never have to look up a reference? I find that a little hard to believe &gt; And your random, unrelated jab at RoR and Django is cute, because I refer you again to my link at the beginning of the rant. Use RoR or Django for 6 weeks and let me know if you're still singing the same tune about how great PHP is. Hardly random or unrelated. The RoR/Django community pretty much loathes anything PHP. Most of these blog articles saying how terrible PHP is comes from Ruby or Python developers. And for the record, I have tried RoR and Django, and a handful of other frameworks in those languages. It's cool, it's fun. Sure. But it's still unmatched in the mobility, deploy-ability, and ease of use when it comes to PHP. Sorry, that's how it is. PHP is a language that has been optimized for serving websites. Ruby and Python are not.
It will also be very rare to have a site doing 50pv/s with a 100k echo loop on it..
Upvoted for apc.php which is absolutely the way to check on this.
For servers I use Debian stable. I've done a decent amount w/ CentOs and just find Debian easier to manage, especially package management and updates.
no it's not because I like it, it's because it's BETTER. but you'll never see it unless you take your head out of your bubble, if you keep thinking about "optimizing strings" then sorry for you.
`$_SERVER['HTTP_REFERER']`
Hey, is this mitzip aka David Mitchel aka the guy who was my roommate at the University of Texas @ Dallas?
And rewrite/check all your code to make sure it plays nicely.
I know it has something to do with that but could you provide more info? Maybe the full php code? I am not too familiar with writing php. Thanks.
This is common practice in adult... you can even do it with htaccess
You don't make any sense, I think you just want to attack something. You want to see if they can break down problems, but you give them a problem that can't really be broken down? You know they haven't even graduated from college yet, but you expect them to be experienced developers? Besides that, you misinterpreted what owwmyeyes said in the first place. Somehow "data structures, algorithms, and give them __real life problems__" got turned into, "ask them CS questions". As if that shit isn't knowledge all developers should have. 
And yet, clearly there is a need for PHP optimization. Not everyone writes 10 page websites that get 3 hits per month...
Is there a resource that outlines the behavior differences between php and hphp? Shouldn't it be 100% compatible (minus the removed features such as eval)
 &lt;?php // Checks if user is from google if (stripos($_SERVER['HTTP_REFERER'], 'google.com') !== false) { header('Location: url1.php'); } // Checks if user is from your site, replace with your domain preferably elseif (stripos($_SERVER['HTTP_REFERER'], 'yourdomain.com') !== false) { header('Location: url2.php'); } // Redirect to another page by default else { header('Location: url3.php'); } [stripos](http://php.net/stripos) is a function similiar to Java's [String.indexOf](http://docs.oracle.com/javase/6/docs/api/java/lang/String.html#indexOf). It returns the starting position of the first occurance of a string contained inside of another string, case in-sensitive in this case (because domain names are case in-sensitive).
 var_dump($_SERVER['HTTP_REFERER']); Put that in your bounce script and check the values you get when you access it from various other pages. That'll teach you how to use the value and you won't need to depend on people for your code.
Yikes. Just seems like way too much busy work. The most I've ever asked my candidates to do at home was a simple Scrabble cheater: given a dictionary of words, list all the words you can create from the letters the user typed in. I tend to like quick problems like this that gives the applicant multiple possible solutions. I don't even care what language they use because in the end, I'm just trying to judge how smart someone is. Many of these people have 5 or 6 interviews lined up and probably won't have the time to spend on a task such as yours. And if I'm looking for a PHP dev, I won't disqualify someone just because they have used Java or C# for the past 6 years. If they're smart and willing, they'll pick up PHP no problem. Good luck.
About breaking the javascript problem into more discrete pieces… * modifying dom elemnts * generating random numbers/letters * looking up css properties I also said students just about to graduate not being able to do a simple problem. I don't recall saying they need to be experienced developers. Just show basic competence in the ability to figure out problems. You're right—him saying real life problems probably completely covers what I was saying, I originally read it with a less sensical interpretation. It is knowledge that is good for developers to know, but I don't believe it is paramount, especially in web development. I don't intent to disparage the positive effects of having in-depth knowledge of data structures and algorithms, but it's pretty dependent of your domain. I can't tell you about ever having to use a linked list for serving a web page. I know a good developer who I was shocked to find out he didn't know big-O notation. But you know what? It never really mattered because the time it takes to do the processes necessary to generate a page pale in comparison to the time it takes to hit the database. All that said, I want to be clear that caring about those things can be very important for web, I just think it is less common. Speed/implementation are very important for web frameworks, and ORMS, and many other things, but not modifying a shopping cart to add feature X. Feel free to respond, I'll read it and be grateful for the response but I think I'm done, I've said my peace and don't feel the need for a prolonged argument.
An array is a data structure. So is an associative array. Data Structures don't automatically mean in-depth knowledge of a red-black tree, or a heap, etc. arrays, lists, stacks, and queues are all data structures. Any developer who doesn't have an understanding of every single data structure I just described is in over their head. There is a minimum of competency required, and it isn't "CS-y" to expect it. And I'm the guy that argues a CS degree isn't necessary to be a successful software developer, but software dev is a profession, and there is knowledge you're expected to have. As for your breaking it down, I'm going to call bullshit on that. That's not really what people mean when they talk about breaking problems down into smaller pieces. What you just described is an algorithm, and while that is technically breaking the problem down, it isn't what is generally meant. 
Well I have tried this and apc.php shows only file in cache, apc.php. And yes, W3T shows opcode as an option. But I dont see anything in cache when I check apc.php. 
Let me use this, may be this is what I am missing.
&gt; The site is currently being "re-done" in CakePHP by a group of Indians I found on Odesk. This has to be a troll...
Probably not, if it's not showing in the apc.php it's probably not being cached ... But you do realize that pages aren't cached until they are loaded, right? So if you go to apc straight after a restart that's all that will be there. Once you load another page, it should get cached.
Well, thats what my problem has been. I have another box that came configured with APC and I can even all my files cached in APC. But in this particular installation I dont see anything. I have restarted the box and done everything possible explained on php.net and some other tutorials. 
Just to comment on your idea it generally isn't a good idea to redirect based on referrer. If your concern is that you don't want search engines to crawl certain data, then it's much easier to create a [robots.txt](http://www.robotstxt.org/orig.html) file. Any well behaved crawler will honor it. Additionally, it's very easy to spoof the referrer so that it reads whatever the person's client wants it to read. The client is also under no obligation to provide a referrer. 
I've found in the past that 'off' and 'on' don't always work, 1 and 0 seem to be more consistant
I'm fairly certain that most vanilla PHP behaviors are covered (outside of eval() and namespacing and a couple of other functions), but the headache comes with supporting the various extensions and libraries that people commonly use with PHP, such as GD2 and ImageMagick, PDO, Memcache, phpredis, etc.
Probably far off the scope of the solution the poster needs, but: http://somedomain.com/?icanjustwriteyourdomain.comhereandyourtestwillgrantmeaccess Alternative solutions? Regex or perhaps exploding by '/' and match the domain against the substring of the third index with strlen of the domain.
Yeah, you're right, that was way more douchey than rewording someone's post and leaving a "FTFY" call sign. jackass. If X is more performant than Y, then you fucking do X unless you have a valid reason to do Y. Said valid reason may be readability, algorithmic, what have you, but you need to have an actual reason for not choosing X. And __that__ is a much more sane approach to optimizing than the stupid shit you proposed. If you're optimizing after your shit is done, you're doing it too fucking late. Knowing what operations are faster than others and basing your decisions on that knowledge is not a ridiculous thing to do, despite what you, and jackasses like you, want to claim.
I'm with you 100%. printf()/vprintf() is far superior, especially since it allows you to do some sanity checks on your data as well. It's not that relevant to this discussion though.
I would spend 15 minutes designing it in my head and discover potential issues a proper application would have to account for, then spend 10 minutes writing pseudocode and PHPDoc class/method headers and the last five minutes of the half hour writing down my choices and reasons for the design. The rest is just code, framework code even. You can find that stuff on github if you collect it or something. :)
 ?&gt; &lt;html&gt; &lt;/html&gt;
Ah well...when am sprinkling variables in HTML, nice catch though. :-)
I never use short tags any more, as a lot of my stuff is distributed out so it just makes it harder for some of the people I give it too, I always use the long version now, and prefer using it.
It was just a basic solution to show what we can do with it. I won't write the script for the OP but this is a way to check the referer. Of course, I would use a proper [URL parser](http://php.net/manual/en/function.parse-url.php).
Or, more effectively: preg_match('/[^.]+\.[^.]+$/', $_SERVER['HTTP_REFERER'], $match); switch(strtolower($match[0])) { case 'google.com': header('Location: url1.php'); break; case 'yourdomain.com': header('Location: url2.php'); break; default: header('Location: url3.php'); } I'm assuming the downvote was because of the strtolower typo. Fixed :V
I know it's actually not straight php and depending on the size of the site, might be over the top, but I would use mod_rewrite to do it. Then you get the benefit of not going through using threads for processing PHP (it's more efficient). http://httpd.apache.org/docs/2.0/misc/rewriteguide.html
yup. if a potential employer wanted me to do this i would install phpbb, give him the bird and go find another opportunity.
i am glad i don't work for you
If, for example, you are going to not redirect in some other case, and show a page of content, it is important to put die(); after your header redirects, otherwise the content will still attempt to be displayed.
Correct.
I never said it was? My comment was in the wrong thread
Why would that make a difference? I've never used Twig, but Smarty converts everything to native PHP and includes it IIRC.
You truncated my statement and by doing so took it out of context. My point (as I believe should be abundantly clear) is that in this case, its a non issue and has no impact under any conceivable circumstances. Its literally people waging a tech holy war over nothing. I'm saying use whatever you want, it doesn't matter. Until someone can demonstrate to me that it does matter, thats how I'm going to see it.
Really? Everything I've ever written is property of my employee at the time that I wrote it, and I'm not at all free to disclose parts of the source code to it.
&gt;by doing so took it out of context. No, I did absolutely no such thing. You stated that people spend too much time optimizing, and I stated that it takes absolutely no more time to optimize. How is that taking anything out of context whatsoever? If it doesn't take _any_ time to optimize, how can it take _too much_ time?
Honestly, you're dead wrong here. Sure, it's ok when you have 2 items you're interpolating, but once you get past 3 or so, printf get's really ugly because once you're passing too many arguments.
You guys are going down the rabbit hole ;-)
that's bullshit. and also [vprintf](http://www.php.net/manual/en/function.vprintf.php) allows you to pass an array, in other languages is even possible to assign names to the placeholders for clarity.
No, it's called respecting the contract I signed when I was employed. aka being a professional.
There are lots of Indian contractors on Odesk...
I feel as though communication is key, and it is much easier to communicate with a native English speaker.
besides, in SEO, redirecting crawlers is highly penalized.
I've never charged for code, I build own projects and gift code to good people.
Exactly.
what the fuck are you talking about?? did you sign a contract that forbids you from USING FUNCTIONS WITH THREE OR MORE PARAMETERS??? I don't get it, please explain.
printf("%d/%d/%d - %d:%d:%d: %s (%f) Done", $date[2],$date[0],$date[1],$time[0],$time[1],$time[2],$message,$done); It just gets ugly. I've seen examples in production code with over 20 arguments to printf, it's very error prone.
Seen that before, deemed it interesting, but still utterly confused as to what it's actually for. Now the more realistic example JSON shines some light on it. So it appears not to be just dependency tracking, but an actual resolver and bit repository management. The website makes it sound like it might be that mythical PEAR channel aggregator that I heard musings about before. Not sure if / how I'd use it, or if it depends or relates to PEAR2, but it's a big step up from the fugly XML. Like the pretty CLI interface. But a manpage or docs would be cooler.
I know. Outsourcing software programming is broken once again.
What version of PHP is the server running? If it's PHP 5.1 or greater, you should be fine.
i don't know, its general product like the vbulltin, customer download and use
again that's bullshit, this: printf("%d/%d/%d - %d:%d:%d: %s (%f) Done", $date[2],$date[0],$date[1],$time[0],$time[1],$time[2],$message,$done); is WAY better than: echo $date[2] . "/" . $date[0] . "/" . $date[1] . " - " . $time[0] . ":" . $time[1] . ":" . $time[2] . ": " . $message . " (" . $done . ") Done"; you're being obnoxious, the advantages are obvious (and I'm not even mentioning the safe type conversion or the modifiers that printf allows).
Try [JpGraph](http://jpgraph.net/)- I just installed it on a project for work, and it's working like a dream. 
[Gnuplot](http://www.gnuplot.info/) on hand and with some math you'll be serving magic.
Should your server not have PDO available (unlikely), then there is xpdo.org or upgradephp with an userland PDO emulation for super outdated PHP 5.0 or slightly more outdated PHP 4.x servers. Though might mean some rewrite overhead in utilizing (new constructor, and global instead of class constants).
You probably want 3 tables, then use a JOIN to merge the results. I suggest you read some docs about [database normalization](http://en.wikipedia.org/wiki/Database_normalization) before you progress too far though.
5.1 is the minimum i would worry about personally as its the minimum version available by default in the CentOS/RHEL 5.x distros. RHEL/CentOS 5.0 came out in 2007. Its unlikely you'll run into many older installations still running.
Thanks for the suggestion. Unless I am understanding how the GPL license works, would I be able to use this library for a commercial project, especially when I don't have the right to give up the rights?
Thanks for the suggestion. This is the type of thing that I am looking for. I am going to hold off until after the weekend to return to this to see whether any other suggestions turn up as well.
I'm not going to do your job.
[pChart](http://pchart.net) might be the way to go, I've use it several times and it's really awesome and convenient ( caching and stuff like that ).
my advice is to use it
Here, [this might help](http://nelm.io/blog/2011/12/composer-part-1-what-why/) a bit. Basically, it's to promote code reuse from other libraries in a way that's less heavy-handed than PEAR (where everything is installed globally) and far more easy to get on board with (ever set up PEAR channel server? No? Don't.). It's similar to bundler for Ruby or npm for nodejs.
You should have one table for all images. No association between image and category. Then have a table for categories. This should include all data that will identify the category. Then a third table to associate an image to a category. In this way, there can be a hierarchy of categories, you can add / subtract categories with ease, you can disassociate images from categories without losing ANY data intrinsic to the image itself, etc. Additionally, this would allow you to integrate *one* system for all of your site's images. For creating thumbnails, you're going to want to cache your images. with a little htaccess magic, and php, that should be no problem. See [my gist](https://gist.github.com/1515799) for the thumbnailer I use (warning- it's an old version, I don't have the new version here, but it should still work for you after some modifications- ie making the cache directory and removing the config file require). You can also include it as a library for resizing images. If you like geometry / math, it's pretty fun to look at how GD does image resizing. I hope this helps!
Thanks! Discovered that part 2 via Google, completely missed both on phpdeveloper news. That clears a few things up. The actual discovery protocol or packaging scheme is still undocumented, but at least allows to assess whether it's useful and to which projects or deployments.
 &lt;?php echo phpversion()?&gt;
What's interesting in all of this is that I haven't seen one mention of testing yet. Give a candidate a set of phpunit tests and say "make them pass". They'll know when they're done, you'll know if it works, and you can be sure they know how to work with a testing framework. 
IANAL, but here's my understanding, which I'm pretty sure is correct. Since gnuplot is a command-line program, and you're simply driving the gnuplot binary via the command line (via PHP's system() or exec() or backticks), you're in the clear. Since you're not modifying or linking to gnuplot in your program, you can simply distribute gnuplot (under the GPL) along with your product (under whatever license you want). The only obligation you'll need to meet is that you must make the gnuplot source available to anyone you distribute binaries to. That said, if your product is aimed at modern unix/linux only, you can probably get away with just instructing users to install gnuplot as a prerequisite to run your software. On CentOS, they just need to 'yum install gnuplot', for example. TL;DR: your program can drive gnuplot via the command-line interface without becoming infected by the GPL
I hate writing documentation as much as anyone, but I've found that by doing it Incrementally as you develop your code works best. It can break your development "flow", but it makes you think through code decisions as they happen. And the best writer for your own code is yourself. An editor never hurts though ;)
HUGE HINT THAT IS NOT EMPHASIZED ENOUGH IN THE MANUAL EXAMPLES: You must run http://www.php.net/manual/en/pdostatement.closecursor.php between changing queries/query parameters. Else PHP will crash with "zend_mm_heap corruption" and your pages will just error 500 or be blank. It also can do that if you have a mismatch in number of prepared statement variables and values.
You don't actually need echo there. Phpinfo will output without it.
Try [PHPThumb](https://github.com/masterexploder/PHPThumb) for thumbnailing.
They used phpversion, though, which just returns a string. Not relevant to the OP's question either way. :P
wtf, my eyes told me phpinfo was in that comment. My bad. I am a bad redditor when I'm on my phone. Thanks for the correction.
http://www.codediesel.com/php/6-excellent-charting-libraries-for-php/ I can't recommend any though - still researching it.
If you've got the password being echoed into sudo, then you've practically already given Apache full root privileges: if the Apache user gets compromised, they password could simply be lifted right out of the file. Take a look at this [sample sudoers file](http://www.gratisoft.us/sudo/sample.sudoers). You can make it so the Apache user can execute only certain commands with specific arguments without ever needing to pass or even store a password.
This is a great talk, I think the idea is to pay enough so that money is ''off the table'' and they are not worried about it.
Password is prompted for on each operation and therefor is only held in memory. I hope there is a better solution than the one provided.
I was using jpgraph, i dished out for highcharts though (javascript/jquery)
In your example, you have `echo password` which means you intend to store the password in cleartext in at least one file readable by the Apache user even if it's only read once. If the Apache user has access to the password, whoever has access to that Apache user has access to the password and therefore access to your machine.
There really isn't a way to do it securely. You may want to look in to http://www.suphp.org/ but keep in mind that even if you don't have your root password in the script itself, all you have to do is make one little fuckup that someone could take advantage of, and your system could be compromised.
twas for brevity but you were right to point this out.
oh what the fuck dude! this couldn't be any more retarded :( first of all, you didn't understand terremoto's idea; you *can* set up sudo so it doesn't ask you for a password but you must be real careful with that because it's quite tricky not to allow privilege escalation with it (I did it once, and I'm not a security expert so imagine). in any case if I were you I would have a bit more decoupled solution, I would have PHP/Apache without any special permission and have them communicate with a daemon that runs the commands (and can only do that), that way you can control the access and you're sure it won't run anyhting else because you won't pass the actual command, you'll just pass the username and the daemon will know what to do with it.
The safest way to do this is to create a setuid root program which php calls. However, you can't do this with a shell script. Here's an example of doing it in C: http://blog.bigsmoke.us/2011/02/02/executing-system-commands-from-php-with-suid-executable They also give an alternative, which is to use sudo. If you do that, and allow it to ONLY run the one script, it's reasonably safeish. A setuid program feels a lot better to me though. Don't give php any broad access to sudo. Let it run one script through it if you do it. Don't let it run the useradd program either, have it call a php or shell script which verifies the parameters and calls useradd. 
If you don't want to read the sudoers manual to properly limit arguments, this should do what you want in a _relatively_ secure manner: In /usr/local/bin/, create an executable file named "apache_useradd" that contains the following: #!/bin/bash useradd -g "$1" -p "$2" "$3" Execute "visudo" and append this line: apache ALL = NOPASSWD: /usr/local/bin/apache_useradd You can then run `exec("/usr/local/bin/apache_useradd $g $p $user");` without prompting for a password or storing credentials anywhere.
I think a daemon's overkill. I responded with a [simpler solution](http://www.reddit.com/r/PHP/comments/nopja/running_shell_commands_as_root_from_php_securely/c3ar048).
_I'm the one_ being obnoxius? The big difference between the two is that printf removes the data from the usage site, and that removal is at greater and greater distance as the number of arguments goes up.
you're right, upvote!
Yes, [it can be done securely](http://www.reddit.com/r/PHP/comments/nopja/running_shell_commands_as_root_from_php_securely/c3ar048) without too much hassle if you're on a *nix box.
I actually just started using this for a project and by and large I've been very happy. Not only is it good for dependency and version management, but it also automates autoloading. Picture this: you realize you need to use a third-party library. If it's on Packagist, all you have to do is add a line to your composer.json, run php composer.phar update, and start using it. Namespace registration is handled for you. The only issue I have is that it's still very new. Things are changing almost daily, and documentation is really thin. It's probably not quite ready for primetime yet. That said, the guys working on it are top notch, contributors to the Symfony framework, so you know it's going to be a great tool to use. It's already helped me out quite a bit. 
Oh, whoops, just realized I somehow replied to entirely the wrong thread here. I (thouhgt) I was responding to a post in another thread about showing work from a previous employer. 
Not sure if this is the best way to do this, but I finally set a password for the root user (ubuntu system), added www-data to /etc/sudoers using visudo, and then issue the following command in php exec("echo $rootpassword | sudo -S useradd $user"); sudoers looks like this: www-data ALL=(ALL:ALL) ALL Defaults:www-data targetpw Defaults:www-data !requiretty This is fairly secure I think, right?
but that's exactly the point here! you want to see how the output will look like and with printf you just check the first argument, with string concatenation you have to read the whole thing and the tiny string pieces that go in between are a pain to deal with; in your example the 4th and 5th are ":" but the next one has also a space. you're forced to mentally put all the pieces together to figure out the output and THAT'S WHY printf is better, this is not an opinion it's a fact and if you deny it it's just because you can't accept being wrong. (plus explicit type conversions and formatting modifiers, but even without those it's a clear win) and also notice we're talking about variables here, it's not like you'll know $date[2] or $time[0] real values just by looking to this line...
Might be wrong on this one; however, this would show your root password in ps, top, etc. if it was run when your command was running. Small chance; however, probably not ideal on a shared system. (IANA Security Expert)
seriously? after this many comments?? so what's your opinion on printf vs string concatenation then?
No, that's still just as unsecure. For that sake of your users and the integrity of your system, _please_ just follow [my suggestion](http://www.reddit.com/r/PHP/comments/nopja/running_shell_commands_as_root_from_php_securely/c3ar048) with apache_useradd and sudo. It doesn't require you to ever use a password.
create a group that has sudo privs to whatever commands you need to run, and ONLY those commands, add the apache group to this group. Do NOT use root.
Seriously? There's a whole section that talks about it. It's only necessary if you don't fetch all the rows in a result set. If you're querying for more rows than you need, you're probably doing it wrong.
I understand. I am an Indian and even I have had my own share of communication problems with fellow Indians. Anyway, hope you have found right talent. I am just soliciting for some consulting work and have had no luck yet. 
is xpdo.org, is a php class for just like pdo?
I would consider running your web program as root a can of worms. You can put the lid on, but it's going to come off at some point. I would recommend creating some sort of "action queue" that you then run from a cron job (as root). You can interface this through SQL, files or DBus. Just make sure that the interface of the action queue is clearly specified and validate all input before putting anything in there. This at least puts some level of separation between your web user and root, in case someone is able to gain access to it.
You probably won't find this type of "help". Frankly put people scratch their own itch. If someone is using something that is open source with little to no documentation, by the time they understand it well enough to document it, that itch is gone for them. Same with this situation. You scratched an itch in writing it, but don't care about documenting it so why should someone else. Don't tell me that you can write code but you can't write basic documentation. Just admit that its tedious and boring to do so. Finally, with as many different projects / frameworks / libraries that are out there, why should someone take an interest in yours specifically. I'm not even certain what your project does, or why you did it. It appears to be some caching method, but there are plenty of different caching mechanisms. Not only that, browsers and web servers manage this to some extent already. Even if your caching mechanism works well, is simple, and doesn't cause development problems, does it save enough space over the currently implemented technologies? You should consider that this is an opportunity for improvement. If you lack the ability to even pitch something so that people are interested / they understand it, that has implications that goes beyond "I can't write good documentation".
I'm going to guess that you want to use PHP APC because your blog feels slow or sluggish. At the end of the day, this almost does not matter with most websites. The reason for this is because you should be using a static page cache. At that point, php is not executed and the database is never touched when an anonymous visitor hits the page. http://wordpress.org/extend/plugins/wp-super-cache/
10,983 readers versus 526 readers Most people also do not read the side bar.
yeah, setuid is the way to go, I think
I don't have a problem with people posting questions here as long as they're good questions so we can all learn from the answers.
btw, he still needs proper validation of the arguments otherwise I could call it with `$(rm -rf /; echo "username")` as a parameter and it'll run as root.
most of the questions are dumb or have been asked multiple times before. usually they are both.
There is no secure way to execute commands as root from PHP running as CGI/mod_php. There is a reason for this. Running any web facing (or public facing, for that matter) service as Root is the number one way in which you could be compromised, to the point where you have to patch Apache before it will allow you to run as root. You have 2 options (in my mind anyway). 1) Develop a small daemon, which runs as root and executes the commands as given by the PHP script, but is only accessible to the local machine. It is only bound to the loopback interface so no external services can access it. 2) Create a job queue (using something like RabbitMQ or Beanstalkd) and have your consumer processes run as root.
A) for ($i = 0, $len = strlen($str); $i &lt; $len; $i++) B) for (list($i, $len) = array(0, strlen($str)); $i &lt; $len; $i++) There is no micro-optimisation here. One understands what PHP can parse and the other doesn't.
Good point, hence the heavy emphasis on "relatively." In perl, I sanitize anything I'm going to be passing as shell parameters. In Python, you can use the subprocess module to pass script parameters as an array that won't be interpreted by the shell e.g. `subprocess.Popen(["useradd","-g",arg1, ... ])`. Is there an equivalent in PHP? ` escapeshellarg` or `escapeshellcmd` might do the trick.
this. while there is DRY - i can appreciate it - i've yet to be able (even with dry) to use a full framework faster. i respect OOP but you need to know the low level - functional/procedural before. and don't ever mention a blog/cms &amp; php or they assume you are not serious (employer or employee). Ask your employee candidate to write some cli async jobs, some simple financial apps (CC input stages, simple transactional OLTP, some reporting). Throw a few different DB sources at them. i'd bet you'd weed out the killer in less than an hour (they'd leave). asking for 4 hours is far too much unless you are going to give them an offer right then 
That's an extension atop it. But there's also a link to said PHP4 emulation. 
The way you're going about it, putting the root password in a PHP script, is probably the worst. What I would do is write a C program that invoked useradd, and made sure it wasn't able to create new root users. Then I would let this program be run from sudo using NOPASSWD so that the password didn't have to be stored anywhere. 
Chicken and egg problem. People won't post questions and answers if there's a small number of subscribers. The number of subscribers won't grow if there's only a small trickle of questions and answers. That said, as a mod of the subreddit in question, I am all for it :D What I want to encourage is that r/PHPHelp be a purely positive helping forum. r/PHP tends to generate a LOT of negativity and downvotes just to slightly controversial opinions, not purely wrong or outdated information. I believe that achieving that sort of environment would be make it a worthy subreddit as an alternative to here for PHP newbies.
Good job. I wish more places did something like this. Would you mind posting it here (or on pastebin or gist or someplace) to give people an idea of the complexity of that first-pass filter?
I'm mixed on this. I've been in some situations where people could talk a good game, and then when you saw their code, it was night and day. Everyone's got their own version of "efficient" and "clean" and "lightweight" and such. And all this assumes (as you point out) that you need some good devs on the team to do the judging. I've been in situations where the devs interviewing me should not have been interviewing anyone - they were not qualified to be asking the questions they were asking (punching above their weight, looking for me to say one particular word/phrase they wanted to hear, rather than an actual answer). Real example - "how do you prevent SQL injection in PHP?". Me: Prepared statements with/without PDO are most comprehensive approach. Them: PDO? Me: Umm... Them: Let me rephrase this - if you wanted to add some slashes to data before putting it in a database, what's the name of the function you'd use? I assume they thought they were being clever by rephrasing the question as patronizing as humanly possible. Until you see code - code samples, previous projects, etc - it's hard to judge whether their use of the phrases/ideas used are the same as yours. Many people can talk a good game. Heck - *I* can talk a good game, and I'd probably be able to bluff my way in to some positions I'm not qualified for, but I'd expect someone to want to see some evidence of previous accomplishments in techX before hiring me as a full-time dev in techX. 
"So you're telling me when you develop with Ruby, or Python, etc, that you memorize every single function or API call associated with that language, and never have to look up a reference? I find that a little hard to believe" There's a wide diff between "never" (which no one hits) and "all the time" (which I still see with many PHP devs, including myself). If instead of 10x per day, that was reduced to 6, on a team of 6-8 people, the savings can add up. The rebuttal may be that waiting for your server process to start/stop X times per day would eat up that savings, and that might be right. But... the OP never said anything about Ruby/Python devs *never* having to look up reference stuff. But naming and parameter order being consistent can help. Lastly, the "BAM" on the ctrl-space trick - doesn't help if you're in the middle of writing an argument list. *IF* you ctrl-space before starting the argument list, it seems to work, but not if you're already in the middle of writing one. Extremely annoying.
Some of that might be a bit much for a junior level developer. The tests that I used in the past were fairly straight forward. I don't want to see if they know how to use a bloatware framework that I couldn't deliver to a customer in good faith... Here are some examples of what I have done in the past: I have my own basic MVC Like framework for the purpose of testing and I ask them to create some basic app with it that contains user authentication and ACL. This weeds out idiots pretty quick. Before I did the above, I used to give them a simple task like building a ratings class - that shows a 5 star rating that supported half star intervals from single star images (full star, half star, disabled star) - to test whether or not they could make an algorithm or at least sensible code to handle this without a huge if/else mess. You would be surprised at the holy mess that some developers would give me back.
Beyond WP, I will say. I used wp-super-cache and W3Total Cache. I wanted to explore APC for most of my other projects as well.
Done this with a cron job. Apache writes a file, cron runs a root owned script and deletes the file. Details are up to you. 
&gt; Lastly, the "BAM" on the ctrl-space trick - doesn't help if you're in the middle of writing an argument list. IF you ctrl-space before starting the argument list, it seems to work, but not if you're already in the middle of writing one. Extremely annoying. True, but all you need to do (in Eclipse anyway) is hover over the function and you can see the arguments. Honestly if you find yourself doing this an extraordinary amount of times per day, then I don't know what to tell you. I hardly ever need to go to the PHP manual, my IDE tells me everything I need to know. At the end of the day, I don't think 20 seconds spent referencing functions is really a valid argument. If 20 seconds means that much to you, learn to type faster I guess.
Why did you even respond..? Good job stating most of the obvious.. However some of your thoughts couldn't be further from reality. You should be part of FOX or CNN you seem to be good fabricating things out of thin air.. Fact, I do care about documenting it, that's why i posted this.. Fact, You claim I have the ability, but just to fat and lazy to do it.. Fact, You've never talked to me, You've never taken any interest in my past, So how can you make these accusations? Is it because you're pulling from your own past and inserting it into mine? Fact, Your comments about caching systems tell me that you think to much inside the box to understand the concept. TL;DR you feel i am too lazy to care about my own code, and that it pry has no real advantages past what already exists.
Er, isn't this a case of what the optimiser does rather than a question of the fundamental structure of iteration?
There is no optimization that happens in PHP.
It's not a large enough community to warrant two separate subreddits
I would agree that this is *not* a micro-optimization. Either clearly understands how iteration works and will get the job done (ignoring syntax issues), but one makes the calculation every time the loop hits. Always been a pet peeve of mine. I used to calculate this outside of the loop until I learned that the scope of the variable created in a loop takes care of this.
This is the correct solution for most cases. Your corn job can perform its own independent validation of input to ensure there's nothing suspicious and then run the needed commands. Just design the interface around the idea that the needed action will be happening a synchronously and poll for a completion status.
thanks for the suggestions! i was thinking a little heavier on sql theory (Sp's,views,triggers) and less weight on the php side
Read about the difference between $var++ and ++$var instead (or at least in C/C++ it's a difference).
I'm not completely sure what point you're trying to make and to which comment/article this is a retort.
And please log every time this is run, and regularly check the logs. Best option is to have the system SMS/email you every time a user is created, so you can shut down any suspicious accounts immediately.
Given that PHP doesn't have block scope, I can only assume you're talking C/C++?
Isn't that what stackoverflow is for? That's my go to for questions.
Poorly worded / inaccurate on my part I guess. The value of the variable in this example is not available outside of the loop. I don't do "serious" php development, and have too many languages / conventions floating around in my head.
Set up a queue of some sort (MySQL is not optimal, but will work) and a daemon running as root that polls the database for operations to be performed and runs them. Do not simply pass through commands, but instead operations and let the daemon put the commands together (to prevent the possibility of running arbitrary commands with access to the MySQL user). You could also create a TCP server and queue the commands that way. For instance, in your frontend: mysql_query("INSERT INTO `jobs_adduser` (`username`, `password`, `group`)". "VALUES ('foo', 'bar1234', 'users')"); Then have a script running in the backend as root (look into the pcntl extension and pcntl_fork for an easy way to daemonize it) that queries for new jobs periodically and runs the commands. For instance: if (pcntl_fork()!=0) die(); for (;;) { $jobs_result = mysql_query("SELECT * FROM `jobs_adduser`"); while ($job_data = mysql_fetch_object($jobs_result)) { exec('useradd -g '.escapeshellarg($job_data-&gt;group). ' -p '.escapeshellarg($job_data-&gt;password). ' '.escapeshellarg($job_data-&gt;username)); mysql_query("DELETE FROM `jobs_adduser` WHERE `Id`='". mysql_real_escape_string($job_data-&gt;id)."' LIMIT 1"); } sleep(5); } This way your password is never present in any script or in memory. The daemon already has the privileges it needs. That code itself has not been tested at all, but the concept is in use in some internal apps.
Most of the excellent programmers will have jobs. Those that don't will probably have several options (unless you're in a very small market) for where to work. When it comes down to applying to the place that wants you to spend a bunch of your own time on their application, or some other company... They'll go with some other company. The only people who are going to consider your application are those that are desperate for jobs... You're unintentionally watering down your applicant pool to only those that have trouble finding jobs.
I agree it's not a micro optimization - It is two separate sequences of statements that evaluate to the same result assuming $str does not change length. You cannot safely optimize A to B unless you know the statements in he loop. Even if you are trying to change it as a micro optimization, unless $str is very long it won't have much of an effect. php strings are stored as (data, length) tuples. The strlen function just retrieves the length value from the tuple.
Oh, is this the ugly PHP contest? A) for (list($i, $len) = array(0, strlen($str)); $i &lt; $len; $i++) B) for ($len=${($i=-$n='strlen')?:$$n=$n}($str); $i &lt; $len; $i++) One understands variable variables and the other doesn't.
There's no traffic in /r/phphelp, hence, no point in posting there. There's little enough traffic here. I totally don't see the purpose of having two separate subreddits.
you cant
Avoid OSC if you can. Lots of spaghetti code. I maintain a cre loaded install that took 8 months to update and patch to something sane and slightly maintainable.
For C strings, strlen() has to count to find the end of the string, so it operates in linear time. (A) calls strlen() each time the check happens, so the algorithm becomes quadratic. If the length of the string is constant, then there is no need to repeatedly call strlen(); the information has already been computed once so (B) saves it in the variable "$len". The algorithm becomes linear again. Unfortunately, the author is a C/C++ programmer and assumes that PHP string functions are just passthrough to the C libraries. In PHP, the string data type contains the length of the string, so it would seem that strlen() is a constant time operation. &gt; The string in PHP is implemented as an array of bytes and an integer indicating the length of the buffer. [(PHP Manual)](http://www.php.net/manual/en/language.types.string.php)
Correct.. so what's his point of it not being "micro-optmization"? B is more efficient than A.
Not quite. B is only more efficient than A in the sense that there is probably a higher constant time for calling the strlen() function (if it is a function in PHP) associated with creating a stack frame. 
Because neither group have discovered Stack Overflow?
Um, isn't that the definition of "micro optimisation"?
You really should explain something like this. Instead of making it a pissing contest, make it educational. As is, it just looks like, "Look at what I know that you don't! Take my word for it." How is this not micro-optimizing?
No idea why anyone uses reddit for questions period, there's alway better places for the information. I just assume they don't know any better and down vote them.
Well then surely the check gets called every loop then…
It depends on what scale you're defining micro. You could mean micro, as in savings ms' of time, or micro, as in changing single lines code of code, or micro as in your tweaking one sql query. Depending on how whoever is having the pissing contest wants to definition what he calls what, this could be micro optimisation or not. In Big-O notation, there is no optimisation. In constant overhead measurements, this might be an optimisation. Depends on how you want to call it.
Surely a (length, data) tuple makes much more sense.
They're arguing about what's *inside* the check. In C, you'd have a O(n) check thanks to strlen() taking O(n). In PHP, because of a string's data structure, strlen() takes O(1).
Then you misunderstand my intent, but thank you for the suggestion anyways. I am considering this as a potential solution.
Luckily, this isn't the case. I am tasked with installing the feature myself, so I won't have to have their users install anything themselves.
Micro optimisation has absolutely nothing to do with lines of code, under any definition I've heard. It's all about how much actual optimisation you do. Usually it's used to signify changes that are not worth doing in usual circumstances.
So, it's still not really anything to do with how iteration works then?
Then you're absolutely fine. You won't be "distributing" gnuplot at all, only using it.
It's got everything to do with iteration, since here the iteration provides an O(n) multiplier.
&gt; Micro optimisation has absolutely nothing to do with lines of code I said changing particular lines, I was't referring to the practice of reducing them.
agreed, and entirely unsurprisingly, OP hasn't responded in this post.
These are examples - there are thousands of components or needs to be solved, I bet you have a few of your own. For example: XMP metadata is a standard for describing things like pdfs or photos. It describes the make/model/etc of camera, geolocation, etc. An example use - geocoding the photos and writing it back into the image, when a camera doesn't have geo capabilities. SPDY - it's a new protocol from google, which is like but not the same as HTTP. It could enable much faster HTTP style requests for anything which uses the internet. ical - Be able to both parse a calendar and write to it - thousands of uses. Any application which deals with an Event could benefit from such a thing. My broad point is developing a *framework* is a complete waste of time - it's been done before, it will be done again, and you don't actually learn anything much you can re-use. Developing a component solves a real world problem, and teaches you at the same time.
Tried Pirium, or pearhub? Both offer good solutions to getting your content our there via PEAR. 75 channels and counting :)
Interestingly enough, we PEAR folks gave it a shot with the pear channel aggregation. Not many folks actually seems to want to work with us :( Our resulting effort is http://pyr.us/ - an index of the packages out there.
Image_Graph is an old standin that does simple charts to a reasonable level.
a bit late, hyves has lost the battle with facebook.
Yes, but that's not relevant to discussion of two alternate forms over which the iteration is held constant… Look, my point here is that I don't understand what the OP is trying to say; do you know or not?
In a language with a simple data structure for a string (namely, one where the string's length is not stored), the two different forms of iteration would not both be O(n); A would be O(n^2). Programmers previously coming from such languages might be tempted to make this micro-optimization in PHP; however because of PHP stores strings differently (namely, it stores their length), the extra contributing O(n) factor in strlen() disappears, and so both A and B return to O(n).
Yes, so holding the knowledge of the different (O(n) and O(1)) forms of strlen() constant, I cannot see an interpretation of how iteration works that would make me interpret A and B differently. Hence the comment "One understands how iteration works and the other doesn't." is still not explained. Do you know what the meaning is?
That's actually cool. Little did I know that there are so many PEAR channels already. It might make sense just as link list, btw. Maybe a bit more prominently. That being said, I'm now very much entertaining the idea to implement **apt-get** for simpler php packages, especially for the more standardized repository scheme and unification/parallelism with system installations. (Though I'm not ruling out to piggyback a pear channel later on; as its easier nowadays, just a bit bloaty.) 
One list, as requested - http://pear.php.net/channels/
Here's what I use: https://vx.valex.com.au/tests/season/ There are no wrong answers - we're more interested in method, thinking, etc. The size of the above test is more that adequate we find - you can fly through it or get stuck for ages, just not seeing the problem, but either way I suggest putting in no more than an hour's effort and giving us a bit of an explanation of how far you got.
Sigh, this hasnt been true for a long time. 
I have a feeling he meant to say "One understands how php's strlen works, and the other doesn't." But he thought 'iteration' made him sound cooler to the crowd.
I'd say 5.3 to be really certain. It is possible to get it going in 5.1 &amp;amp; 5.2 as you say but I think you have to enable it manually as an extension which involves some convoluted process which you may need to be able to edit the php.ini (can't remember) which might not be possible on shared hosting.
Yeah and the code base is 1000s of files to include in your project. What is it even doing?
cheers - this might just come in handy
Why do you think Google sucks?
&gt;So, what did I gain from these “optimizations”, apart from unreadable code? Nothing. Even now, when this site attracts approximately fourty million pageviews every month (at the time I wrote this code it was faaar less), even now this micro-optimization won’t make any difference. 40 million page views, micro-optimizations pointless. I like this guy.
I think his singleton rant would have concluded a lot better if he gave an example of using a factory pattern which would solve both of his issues (singleton forces single-configuration, binding code to 'Database' class name)
I was interested in this as well...would you mind expanding on it?
The way I understand it is as follows: A factory will typically use polymorphic classes to return a functionally identical object that isn't tied to a specific class name or database type. For example a common implementation of a database connection factory would take a DSN and use it to instantiate a specific adapter. For example: "mysql://user:pass@127.0.0.1/mydb" could be used to create a Db_MySql object which would follow a specific interface. The calling class doesn't need to know this - it just needs to know how to use the interface. In fact it specifically shouldn't know this or you risk breaking the law of Demeter and coupling code to the underlying implementation thus rendering the whole exercise redundant. The only class that knows what each adapter is called is the Factory so it's trivial if they ever need to change. New objects can be created with alternative DSNs or a single one can be stored in a registry if you still feel you want to limit the script to a single connection. The thing with it is you're not limited to a single instance - but you can decide to have one if you want.
I like what I see for pChart, but the biggest downside is that it's GPL, which hurts my ability to use it for this project (which is not GPL).
I have taken lots of tests for job interviews, and it depends on what the job is for. If this is a good job, it is not a waste of your candidates' time to take the test. If you are trying to attract candidates that already have a good job, you had better be offering them something unique or a great salary. If you are trying to attract people who are desperate enough to spend lots of their free time completing a task - then the harder it is the better. What I usually do is ask a developer to submit some source code for something they have worked on recently. That will generally give you the same idea of their ability as a simple test.
Looking more into it, it seems to be about what I am looking for, but I will continue looking for one that looks nicer for comparison.
There's no reason to need an object instance for queries in the first place. You can specify which server you are talking about by a label. It's rare to need to connect to multiple databases in the first place but when you do it's usually one more. Not 10 more.
edit: just realized that OP is the author. Please don't take the below as a personal attack, I'm just really tired of seeing posts like this. --- Oh look, another PHP blog post telling me all the things I shouldn't be doing without being informative about good alternatives. ###Point One: Singletons Only reviews one (albeit common) use case for singletons and a specific scenario where it fails. Doesn't provide a cleaner alternative for that specific scenario, but tells you a hack that also sucks. ###Point Two : Tight Coupling &gt; Whenever you are writing Foo::bar() in your code you are tightly coupling your code to the Foo class. This makes extending Foos functionality impossible and thus makes your code hard to reuse and hard to test. Statements like this make me think the author doesn't know about Late Static Binding. I'm honestly not sure what his point was with Tight Coupling. Is he suggesting that you should always use dependency injection and class interfaces, just in case you need to pass a variation of an object? That's a lot of extra work and overhead for something you might never actually need. If the need arrises to use different types of Windows and Doors, you change the object to support multiple types of windows and doors. ###Point 3: Untestability &gt; Whenever you don’t write unit tests because you “don’t have time” the real cause probably is that your code is bad. Or it's because you really don't have time because the customer's budget doesn't afford it. Once again he offers no examples, not even of bad code, much less code that makes testing easy. The rest of the points I agree with, but the first three left such a bad taste in my mouth that I wanted to punch the author. 
&gt; Only reviews one (albeit common) use case for singletons and a specific scenario where it fails. Doesn't provide a cleaner alternative for that specific scenario, but tells you a hack that also sucks. Yes, I admit that the article focuses on what not to do, not on what to do instead. My suggestion of an alternative would be Dependency Injection. (By the way, the hack mentioned is obviously another example of what not to do. I in no way want to suggest that people use that!) &gt; Statements like this make me think the author doesn't know about Late Static Binding. How is LSB related? You would still need to replace the hardcoded classname in all your code. LSB only affects calls within the class itself. &gt; Is he suggesting that you should always use dependency injection and class interfaces, just in case you need to pass a variation of an object? Yes, I am (at least the DI part; using interfaces is less important). If you do unit testing that need is usually there from the start because you need to pass mock objects. Sure, the "change later" approach might work too, but my personal experience is that if you say "I'll clean up the API later" that later will never come (even if you need it), because the change would already be too hard. &gt; Or it's because you really don't have time because the customer's budget doesn't afford it. Well, as I already mentioned in the article: If your code is good, it's not too hard to test it. There are actually development patterns like TDD (Test Driven Development) which make writing tests the main driving factor of development. I have never heard anyone say that TDD is slower (more the contrary), so "time" isn't a good argument in my opinion. &gt; Once again he offers no examples, not even of bad code, much less code that makes testing easy. The examples are the same as with tight coupling. &gt; but the first three left such a bad taste in my mouth that I wanted to punch the author. Ouch. Don't take the post too personal, please! €dit: Oh, by the way, if you are interested in more detailed analysis of Singleton, have a look at this link collection: http://stackoverflow.com/a/1300730/385378. Those are from the Google Testing Blog, you might consider that a more credible source.
`new` considered harmful? I tend to think that usually `abstraction` is actually more harmful. Yes, its possible to solve any programming problem with a few layers of abstraction, but...
http://nikic.github.com/aboutMe.html &gt;Currently I only have one notable project, a PHP parser written in PHP. Also I am contributing to the English and German documentation. ಠ_ಠ
The article was written by a 17 year old programmer that is trying to act like he's got 20 years PHP experience... I doubt he's even worked with factories before, let alone singletons..
&gt;It's purpose is to simplify static code analysis and manipulation. Could be complete bullshit. Though i will say its not as absurd as it sounds.. maybe. LOL. Good find though.
If you've never made a bulletin board-like webapp before, it's gonna take more than 4 hours, even if you're familiar with the Framework. People who can set this up in given timeframe have either done this before, or are seasoned veterans who tons and tons of experience. People who've never done it will feel rushed, even if you tell them not to. Nothing you say or do will change it. If they look like they're taking it cool, they're not. It's all a lie, I guarantee it. If they're telling you they're fine, they can handle it, they're bluffing. I guarantee it. Asking this from a recent grad is not fair in the slightest. Grads come to companies to mature. It's like asking some kid who just got his drivers license to drive a Formula 1 car. And if he can't, he's never driving in this town again. If you want a good programmer, find a motivated one. Why not ask them if they have their own websites, projects, experiments, or random stuff they've written over the years. If they have any that, it's shows motivation and interest in programming as a whole. I've read a couple of your comments, I've got to ask, what does your ad say? Whether it's on-line or in the paper, what does it say? Your requirements seem very specific and it would more than likely be a good idea to specify them very clearly.
I use TDD and follow similar guidelines listed in this article, and I will admit that at first I thought we wasted a lot of time on writing "useless" test code. But the improvement to my code quality and stability by writing testable code is incredibly worth the minor effort. Once I got into the habit of writing testable code, I would argue that my development time is shorter than it would have been without tests. I am able to make radical changes with minor effort due to the encapsulation and cohesion afforded by testable code, as well as be extremely confident I've not broken any other functionality. I would recommend TDD to anyone who lives in fear of code changes. The first test is incredibly hard to write, and takes a lot of effort. But the payoff in the end is definitely worth it.
There probably isn't an active subreddit dedicated to illustrator. Just searching "illustrator tutorial" on youtube should get you started. After that, search it on google. http://www.pixel2life.com/ is a great site for graphics tutorials. PHPBB forum theming is not a simple topic by any means. You have to be knowledgable in HTML, CSS and PHP, afaik. Probably know how to manipulate some XML while you're at it. As such, I don't think there will be anyone willing to give you 1 on 1 help for free at all. There are people in the world who get paid to do this infact. "Help me out" has to be one of the most generic phrases ever on a programming discussion board such as here. It will not earn you any favours. Ask specific questions instead. "Where do I get started?" is not acceptable either. Use google for that.
Hey, friend. I rarely give advice to strangers, but here goes. Although you very well could be a top-notch php guru, the way you communicate your knowledge makes you look like a major douche. I mean, you are stuck steady on the notion that Cake is not "installable", yet most people consider the download, VHOST and DB configuration needed for the framework to finally be able to serve a webpage, as an "Installation procedure". This "procedure" is needed by every framework I have touched, and I assume by most others I have not touched *yet*. It is obvious you are probably a freelancer because in a team environnment this behavior would make you look like a know-it-all that is unable to accept opinions that differ from yours. This would not be tolerated long in most places. If you ever feel the need to rally people to your opinions, please consider giving respect and great thought before trying to discredit people with a different point of view than yours. No matter how much you believe you are "in the right", most of the time it is much more constructive to accept and integrate the other people's point of view in your response. It feels weird at first, like you are bowing down to something you feel is wrong, but believe me, most people have a much easier time accepting a new idea if they have the impression it is not imposed on them. Me included. Good-luck friend &amp; happy new year to you. PS: In case you wonder, I did not downvote any of your comments. I only downvote spam and off-topics. 
&gt; a PHP parser written in PHP ... eval()? 
Good job! Exactly what I've been looking for :)
I changed the page to say "one notable open-source project" and "PHP documentation" so that it's more clear ;) The site I am referring to in the article by the way is not in my possession anymore (it changed owners approximately a month ago). I didn't link it on that page because it is not the kind of site that I would like to be associated with later ;)
No, friend. Allow me to politely disagree. The culprit would probably be a combination of non-optimal sql and missing indexes. I assure you without a doubt that PHP is much slower to process data than any decent RDBM application. 
This. Finally a sensible answer in this thread.
Yes, kinda. You are mixing the creation of object graph with application logic. Additionally it cause same effect as static classes - you are binding your code to specific class names. Basically what this means is that you should relegate the creation of elements to specific objects ( builders and factories ) and something like a *bootstrap* where your application components together. This video might explain it a bit better: [The Clean Code Talks - Don't Look For Things!](http://www.youtube.com/watch?v=RlfLCWKxHJ0) *[37:57]*
I know. You solve a few problems, and create some new problems. Many times you solve the problems that never occurred in a first place.
What you would do is parse the referrer URL for example Google: https://www.google.com/#sclient=psy-ab&amp;hl=en&amp;source=hp&amp;q=flashlight&amp;pbx=1&amp;oq=flashlight&amp;aq=f&amp;aqi=g4&amp;aql=&amp;gs_sm=e&amp;gs_upl=2713l4967l0l5091l10l5l0l4l4l0l256l927l0.4.1l8l0&amp;bav=on.2,or.r_gc.r_pw.r_cp.,cf.osb&amp;fp=4b3c420078196b39&amp;biw=1920&amp;bih=898 If you isolate q= then you have the keyword the person searched on the search engine for, I assume every search engine is different.
When you click a link your browser sends the URL of the referring page to the page you're visiting in the HTTP headers. So what you would do is look at the refer and parse the url, something like this (untested): $refer_url = parse_url($_SERVER['HTTP_REFERER']); $refer_query = explode("&amp;",$refer_url['query']); $term = NULL; foreach($refer_query as $query) { $query = explode("=",$query); if($query[0]=="q") $term = $query[1]; //Works for Google, Ask and Bing } The search keyword should be in the $term variable. 
Why do you need code samples to pass to the developer? Do you not tell your developer what you want the system to *do*? Or does he already understand that but could not be bothered to work out how to do it?
Thanks, this looks like it would be exactly right.
Thank you!
Well, I guess I should have said as a front end designer, I like to wrap my head around and educate myself first before some of the discussions I have with them. Some of our web projects start out as marketing and front end user designs, but there's always back end complexities that I like to figure out on my own from other communities than my co workers. 
I have been the team leader in almost every situation for the last 15 years... so I have never had this problem because we didn't use shitty frameworks that weren't created in-house. There are more things to consider than just "which framework do we use" when you are making business decisions. We tried using a couple of these frameworks (Zend and Cake) at one of the jobs that I held where I was not the team leader... and guess what happened... it couldn't scale properly and was too heavy. In addition, whenever we updated the framework to the newest version it usually broke the application. So we ended up writing our own. That was an important lesson. When you choose to utilize third party code ion your application, you choose to give up the ability to have input and tie your business to that third party and it's vision. The framework that I use for all major projects was completely developed in-house. I am intimate with every aspect of the framework... and it is fast and scalable. Sure... it doesn't support every bell and whistle... but why would I include code that supports bells and whistles that I will never utilize for the project I am working on? I prefer to keep it simple. I don't refer to using a framework as "installation" because it really isn't. Whenever you begin with a framework it is the application skeleton... If someone wants to refer to that as "installation"... then it makes me think that they don't understand the development cycle.
So , if someone tells you that you are *doing it wrong* and that you should research recommended practices of object oriented programming, then he **most definitely** must be young, arrogant and stupid. Because there is not way that you could be not the expert you think you are. .. this obviously is leaving aside fact that php is only 16 years old.
&gt; Or it's because you really don't have time because the customer's budget doesn't afford it. If you don't have the time to do it right, when will you have the time to do it over?
You sound like an excellent front end designer to work with.
Can you still do this? Didn't Googles move to SSL search put an end to this? Or is that something else?
Yeah, I've found the biggest hurdle working with web design is how differently designers and developers think. I find myself lucky that even as more of an artist I understand code and even know enough PHP and JS to get myself into a little trouble. But yeah, communication is key. :)
The latter of your statement I would say is simply not true.
Micro-optimizations like the one showed in the example, yeah. Plus i would say that he just skipped a step to make sure the optimization was useful. Benchmarking is key to optimization (and micro too), reading that X is better than Y and then doing it is bad practice, use a tool like XHProf, run a dev or staging (or even production as a last step) environment, simulate traffic and look at the profiling results. Then you'll know if it's worth it, if not you have lost 30min. Plus sometimes just trust your guts, in this case, if this is the only line in your whole codebase where you did this optimization, and it was only executed on a few cases, you should know the optimization is gonna have no effect. I have seen optimization like this one being efficient, when they run on every hit, in a loop, at traffic close (and much higher) to OPs and higher, so never dismiss this kind of thing because someone said so, use your brain and knowledge of your own code before making something of it.
Bear in mind that this will eventually (years?) stop working: http://www.seroundtable.com/google-ssl-drops-query-data-14188.html
I've def been to sites recently that have shown either my terms highlighted or product related to my keyphrases. I bet they would want to stop it though if they could, it goes against their SEO best practice guidelines.
My response is kind of a tongue in check response to thoughts like using commas / sending multiple arguments to an echo statement over using periods / concatenation. I just had a post on this and was unable to show any reasonable real world circumstance where it would make a difference, and yet people argue for it because its "faster" and thus a good micro-optimization.
Agreed on that. 
If he's 17 and still in school, that means he's got no experience. It means he's never worked on a real project. He's never seen real-world problems, just theoretical stuff. Experience is what matters. When you've seen first hand WHY method a is bad, and method b is better, you can lecture others about it. This reminds me of all the CSS purists who insist that you should resort to an infinite number of CSS hacks (possibly even use javascript) instead of using a table for presentation... which is not only impractical, it's stupid. When you're working for a 500 million dollar business and they want you to do the job right, they don't give a shit about how pretty the code is, they want it to work properly and be cost effective. Try telling your CTO, "sure, the site runs 50% slower, but at least we're following best practices..."
Excellent series: http://www.youtube.com/watch?v=iCUV3iv9xOs The channel is is on: http://www.youtube.com/user/thenewboston The video creator: http://www.youtube.com/user/phpacademy
My 2c: install it, and experiment! Think of a small app or tool you could use (example: process a form submitted from a webpage and write the data the user entered to a file, or email, or database or even just the screen) - then go ahead and make it. Nothing like hands-on, in my view.
php.net should be your main resource :)
Best of luck on the exam! I took mine in October and passed first time. Know you array functions inside and out, they get you hard on that. Also dont just look at a block of code and assume the answer! I noticed a lot of the times they really try to trick you, they will give you a block of code that is say 20 lines long. When the answer is actually on line 2, and function in the block has no real use. Also, something that totally caught me off guard were header() functions. Know output buffering, know how sessions are passed and when they are started. Basically learn what the heck actually happens before any html is even processed. Finally if you don't already know, learn how to answer multiple choice by process of elimination. By this I mean, if A &amp; C are very similar answers the chances of B &amp; D being correct is really low, so you eliminate them giving you a 50% chance guess. Let me know if you have any other questions! Hopefully I'll be able to help!
There's never enough money to do it right the first time but always enough to do it twice. 
I agree, that it would be nice to have Google Chart Tools as separate downloadable library, but I can live with this limitation when the application clients are connected to internet. Reliability of Google Charts has been really great. Why do you need to send data to Google? You don't need to do that to draw charts (assuming you are using js-charts). But I agree flot is decent alternative, but it's quite restricted too.
Agreed, watching series and youtube videos does not let you experiment and learn. You will forget most of the stuff anyway.
 &gt;2011 &gt;still using tables for layout I seriously hope you guys don't still do this.
Ever have your boss tell you IE6 support is required? You must work for a small company. Ever design an HTML email? Yeah, if you think you can get away with designing websites without tables, you're either crazy, or have the luxury of not supporting all users. January of this year IE6 was still around 5% of the internet.... when the CEO's wife calls IT whining that she can't use the website, you try telling them "sorry, we don't support IE6".
Another great article. Thanks a bunch.
Please! Stop! ;)
Echo will merrily churn out whatever you send it, as long as you have the ram to handle it.
I seem to see you everywhere. And it's always quality stuff. Keep up the good work.
If this actually works, it means PHP isn't actually using a *hash* table and instead just using a *table*. I've written hashtables in C before and never was I able to get such simple collisions (during testing I would do collision tests for hours and would get less than 100 collisions while using a 32bit hash). Using a simple hash function like Dan Bernstein's djb2 hash function, you would easily avoid this.... PHP's devs are retarded if they don't actually use a hash method before inserting the keys into the symbol table......
That code and [this article](http://arstechnica.com/business/news/2011/12/huge-portions-of-web-vulnerable-to-hashing-denial-of-service-attack.ars) make me quite nervous
Try the [SplFixedArray](http://php.net/manual/en/class.splfixedarray.php) implementation from PHP 5.3.0. Set the number of elements to a hard limit of 2^16. I'll see if I can run it. $array = new SplFixedArray($size); for ($key = 0; $key &lt; $size; $key++) { $array[$key] = 0; } //Spl $array = array(); for ($key = 0; $key; $key++) { $array[$key] = 0; } //regular Weird: &gt; Inserting 65536 Spl elements took 0.0139479637146 seconds &gt; Inserting 65536 regular elements took 0.0032939910888672 seconds All I did was change the For loops to the standard format. Why does my test not line up with the OP's? Perhaps we should consider a map instead of an array... Edit: Misinterpreted what was going on here. Here are my results with the OP's code: &gt; Inserting 65536 evil elements (65536 times) took 38.454787969589 seconds &gt; Inserting 65536 good elements (65536 times) took 0.010733842849731 seconds $array = array(); $iterations = 0; for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) { $array["hi".$key."hello"] = 0; $iterations++; } &gt; Inserting 65536 evil string-keyed elements (65536 times) took 0.026134967803955 seconds Looks like when PHP interprets an integer-based array it has to recreate the dynamic array whenever it grows in size. This usually means creating a new array that's 1/2 bigger than the original and copying all elements to the new array. Each array position in between the inserted elements is defaulted to NULL. A string-based hashmap doesn't seem to have this problem. I couldn't do any further testing with SplFixedArray because I couldn't set the memory limit to 32GB. The code would have been: $array = new SplFixedArray(($size - 1) * $size); $iterations = 0; for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) { $array[$key] = 0; $iterations++; }
The bucket where a numeric index ends up depends on it's value (nIndex = h &amp; ht-&gt;nTableMask; in zend_hash_index_update_or_next_insert in zend_hash.c). String keys are hashed via zend_inline_hash_func (in zend_hash.h).
Why aren't they hashing the numeric keys? That's dumb (for exactly the reason cited by the OP). The speed loss from a simple hash method is made up by having an even distribution in the hash table... a hash table's biggest weakness is clumped up keys since it needs to find an empty slot. The only way to get decent distribution is through hashing...
Because they likely did not anticipate this issue to be a vulnerability. As seen from the article, the distribution function works fine for the assumed "normal case" indices.
Yeah, as soon as I saw that link on the /r/webdev homepage, I came back here looking for this article. Seems like, from an outside perspective, if the $_REQUEST/$_GET/$_POST superglobal is vulnerable to this same attack, you could fairly easily just assemble the exact same array remotely and post it to any page at all. Depending on how PHP assembles those arrays, it could even have twice the effect, once for $_POST/$_GET and again for $_REQUEST. The only real deterrent that I could see to this might be the "max_post_size" setting in PHP, but a lot of times you have to set that rather high for file uploads, and even 1MB of empty array definitions would be enough to potentially kill a server for at least a few minutes. Scary.
See http://www.nruns.com/_downloads/advisory28122011.pdf : "An attacker with a Gigabit connection can keep about 10.000 i7 cores busy" They calculated this assuming PHP uses the DJBX33A hash.
sure. The biggest reason is consistency. If I install apache from ports or a package, its config is always in /usr/local/etc/apache/. Second biggest reason is the ports collection. makes building custom builds of software very easy. If you have optimizations or customizations in your global make.conf, they are honored every time you build something from ports. third, is probably security. While not as great as openBSD, Free offers a very reasonable level of security by default. If you're unsure what a particular directory is for, you can always "man hier." I'm only scratching the surface, any my train of thought isn't very coherent at this hour. Hopefully, this helps - but let me know if you have any questions.
I don't think hashing alone would be enough - as an attacker could simply pre-generate a bunch of colliding hashes using the same open-source algorithm used by the software. The simplest way I can think of to get around this is having the hashing randomised so that it wasn't practically possible to predetermine which key values would or wouldn't cause collisions - i.e on one request 0 and 16384 would collide (as they do now), whilst on another they would miss.
The [docs](http://php.net/manual/en/function.imagecopyresampled.php) say: "If the source and destination coordinates and width and heights differ, appropriate stretching or shrinking of the image fragment will be performed." Edit: ...so to guess, I'd say you need to supply the width and height to the function.
For everyone living in fear of this attack (which is actually quite serious because anyone can take a PHP server or even server network down using a very simple script), PHP 5.3.9 and PHP 5.4.0 will include a protection for this (a max_input_vars ini option defaulting to 1000). See http://svn.php.net/viewvc?view=revision&amp;revision=321003 (a similar commit was applied to 5.3 too).
Complete newbie here as well, no experience whatsoever. I'm starting by working my way though http://www.homeandlearn.co.uk/php/php.html So I downloaded WAMP and now I am looking for a decent editor (since I know I forget brackets, semi-columns and shit like that. And get frustrated easily). Then thought "hm...Reddit might have a php-subreddit" now distracted. 
I just tested this on my machine and I get 65536 as expected.
SplFixedArray internally doesn't use a hash table, but a real array, that's why it won't work there. Also the hash function for strings is very different from the one for integers. Doing hash collisions using string keys is possible too, but you would need to use other, special strings ;)
Agreed. I was very surprised to learn that the OP is only 17. 
\&gt;testing hash map clashing \&gt;uses a flat array and completely different keys wat. &gt;Looks like when PHP interprets an integer-based array it has to recreate the dynamic array whenever it grows in size. A string-based hashmap doesn't seem to have this problem. And you still don't get it. **Read the article!**
http://www.nruns.com/_downloads/advisory28122011.pdf working link
I just tried sending *pow(2, 16)* number of keys as post request to my server and it kept it busy (php process at 99%) for 25 seconds. Increasing number of keys to *pow(2, 17)* seems to trigger out of memory error.
Don't do that then.
I can't stress how many stupid things they do in those tutorials. The most brutal of which is the user authentication system where they seem to think that using htmlspecialchars() on incoming username/password data is a good idea. It will teach you enough to get going, but it will also teach you some insanely terrible habits.
Any good tutorials out there? Or is the only way to learn the hard way of failing/ doing a masters in Php? By the way, what you said on htmlspecialchars() sounded like somebody tries to explain me quantumphysics at a [7]
Thanks. My comment was one of testing and realization. I came to the same conclusion but it was late last night and I was tired of playing around with it.
Make a file, that runs phpinfo(); Look for the "apc" section. Should indicate enabled.
Been there, done that, I mentioned this in one reply. APC is enabled. I really don't know what actually is happening :(
You grow systems organically, this don't have enough time to do X so you won't have enough time to do Y, is ignoring a lot of things. It's more like, I don't want to take the time to do Y, so I'll do X. At a later date, if it turns out I really need Y, I'll make the time to do Y. We see this on the very site we're posting on. Reddit is a lot more stable and performant now than it has been in the past.
Let me repeat your question so that I can verify that we're on the same page... You run a query and display the information gathered in an HTML table... In each &lt;td&gt; you display one element of the data that you retrieved from the database. You then wish to link that information off to another page, however, you need to submit the linked data (the data that you pulled from the database) to the linked page. If that is the case, just add it as a get variable (depending on the length). So, to copy your example, do this: &lt;td width="25%"&gt;&lt;a href="pubprofile.php?info=&lt;?php echo urlencode($row[1]); ?&gt;"&gt; &lt;/a&gt;&lt;/td&gt; On pubprofile.php you can access the variable that you send by saying echo $_GET['info']; Is that what you were looking for? 
&gt;as an attacker could simply pre-generate a bunch of colliding hashes using the same open-source algorithm used by the software. You know, given the various available ways to take down a web server, I *seriously* doubt a hacker would waste time calculating 65,000 hash collisions (i doubt you can find that many collisions with a reasonable hash function).. not to mention, this is not a useful hack, since the amount of data you'd have to submit to the server would be ridiculous... 
Thank you very much! This is what I was thinking I had to do but I didn't know how to execute it.
I suspected so too, but I hoped there might be something cool about PHP I didn't know.
So point the guy/gal to something more useful.
I appreciate this response the most. This page is filled with bullshit nonsense like "Are you serious?" and "you're doing everything wrong", and much of that bullshit has been upvoted more than your much, much more worthy reply. Your response is to teach someone by example -- that's the very best teaching there is. Too bad I can only upvote you once. Kudos to you. You're the real deal.
If I were your lawyer, I'd try to put a shitty case together so you'd lose.
Read a book!
It would be better to just pass a unique identifier to the second page (like row primary id, or whatever you index on) . And then pull out all info that you need from the database, using that identifier. This saves "bouncing" a ton of data off the clients browser. (a row from a database encoded vs a single integer) 
It would be ultimately best to use something like memcache (depending on the size of the information and the frequency of identical requests). Too many calls to the database can be disastrous (read: reddit.com)
That's of course assuming that he's got a site with millions of impressions. Judging by his code and the fact he's posting here.. The bottleneck will be the php code way before the database. 
It doesn't take million of impressions to turn the db into the bottleneck... Just a few slow queries can grind everything down to a halt. I do agree though -- based on his snippet of code memcache probably wouldn't be the best solution, HOWEVER, it is good to be aware of all solutions.
okay, well any suggestions on a good book?
A agree, memcache.. But that's way down the line. Gotta crawl before you walk, gotta walk before you run. 
You should also have the loop between the table tags. So it only loops to create the TR rows. That way you have a single table showing multiple rows, instead of multiple tables with a single row. You'll get there :) 
I wonder how far down the line you would introduce something like memcache. Ultimately it is like the simplest concept of a database which in turn makes it complicated. Key value pair is nothing new nor difficult. Never did take a PHP class in Uni. When did you jump into concepts like factory patterns and memcache?
Me personally, I got into that as/when I needed it. It was quite late in my career though. Even now I don't need memcache, but I use it to aid my development because I hit a bottleneck that only throwing more hardware at would fix. Building a dedicated memcache machine for caching output was cheaper than expanding my database cluster. 
 $ man ffmpeg
Whenever you're calling an external program with arguments, [escapeshellarg](http://www.php.net/manual/en/function.escapeshellarg.php) is your friend. There's no real reason to use PHP to encode something other than user-uploaded content, and even you're hyper-careful about the source and destination filenames, just run it through *escapeshellarg*. 
I admit that the ORM functionality is pretty limited, but it does a lot more than just build queries. For instance, with a statement like this: $users = $db-&gt;from('user')-&gt;where('id &lt;', 100)-&gt;many('first100', 600); It would build a query to select the first 100 users, execute it, and cache the results as 'first100' for 600 seconds. 
I started with [Head First PHP &amp; MySQL](http://www.amazon.com/Head-First-MySQL-Lynn-Beighley/dp/0596006306) when I started years ago. Two books I loved the most though were [Beginning PHP and MySQL From Novice to Professional](http://www.amazon.com/Beginning-PHP-MySQL-Novice-Professional/dp/1430231149) and [PHP Solutions Dynamic Web Design Made Easy](http://www.amazon.com/PHP-Solutions-Dynamic-Design-Made/dp/1430232498). Later this book helped me immensely [PHP Objects, Patterns, and Practice](http://www.amazon.com/Objects-Patterns-Practice-Experts-Source/dp/143022925X). Ultimately, php.net is your bible and you can learn everything from there alone. Post on forums and ask for help. Try something and stick with it, don't jump around creating dozens of projects but stick with one and expand it. Also [this](http://us.php.net/manual/en/about.prototypes.php) 
Exec("ffmpeg $_POST[args] $_POST[file]");
we use JpGraph too at work and I don't care for it that much. We had an older version of the paid license one and I was the one tasked with the upgrade. The newer one "tried" to implement theming but didn't work quite right (things had to be defined in a certain order or else they wouldn't apply right) and the Theme class wasn't properly namespaced (or at least name-munged) and caused some collisions with other poorly-written code. I found later working with pChart was MUCH BETTER though the API's naming/casing conventions are irksome.
Not sure if joke or serious... Always escape vars before shelling out
This right here. Download WAMP (or MAMP, if you use a Mac) and have at it. Follow some simple tutorials (create a variable, echo that variable) and the rest comes naturally. The fundamentals are important, though. Jumping into advanced PHP scripts early-on is going to be a headache. 
apt-get install php5-ffmpeg http://ffmpeg-php.sourceforge.net/doc/api/
Of course I'm joking.
I looked into this a long time ago and found it to be extremely outdated.
Not to be a negative nancy, but I've tried to do video encoding of user uploaded videos with ffmpeg before and it's extraordinarily difficult to get right. Several of the flags that you pass into ffmpeg vary depending on the input video, so you need to inspect the video and dynamically build the flag string that you pass into ffmpeg. There are a million and one different video+audio codec combinations, so it's almost impossible to get perfect every time. On top of that, you need to obviously have a queue/worker system in-place so that you can encode videos in the background- doing it inside of your apache or php-fpm request is "the wrong way to do it". Your best bet is to (almost always) go with something like [ZenCoder](http://zencoder.com/), which is what we use at Twitpic.
For those familiar with Ruby, Composer == Bundler and Packagist == RubyGems.org (not the RubyGems software, though). At least, that's the idea.
But someone will use your exact code because it "just works" ;)
I just literally just [blogged](http://stevecorona.com/post/15009341388/why-modern-programmers-hate-php) about why we need something like this in the PHP community. PEAR is awful.
Amazing book for beginners: [Build Your Own Database Driven Web Site, 4th Edition](http://www.sitepoint.com/books/phpmysql4/) Then, when you're ready to move into more advanced things like object oriented PHP: [PHP Master: Write Cutting-edge Code](http://www.sitepoint.com/books/phppro1/)
$row isn't a function, it's an array.
It's POST, right? You can't even see it, it's that secure! What could go wrong ;)
And why you might care: A talk covering (in part) the history of this commit from 28C3: http://www.youtube.com/watch?v=R2Cq3CLI6H8 (28c3: Effective Denial of Service attacks against web application platforms)
Just a tip: Its *probably not* powered by PHP Whilst on topic: This is actually a very interesting concept. I logged the traffic and the upload/download rate is almost simultaneous - as if it's a true direct p2p connection
That is a huge hack to solve a very serious problem. it doesn't solve the problem, it just mitigates it for most page loads. However, finding a page to circumvent this is likely possible on many of the sites that would be targeted with a DoS attack. take, for example, POSTing a json encoded string with more than 1000 variables to a page that will then json_decode the string. You have just defeated the max_input_vars setting by using one input var.
There's nothing wrong, in theory, with the client just being optimistic about it's authentication status. Nothing counts until it sends a result to the server. It sounds like you're doing a bunch of AJAX stuff. So if some XHR happens, and the server no longer knows who the client is, it should send back some response that says "you need to authenticate" (some might say the status should be either 401 or 403, but 200 could be okay too as long as the payload successfully informs the client that they're persona non grata). The key is then to have the client-side code handle that kind of exception in a sane sort of way. Maybe it displays some kind of modal authentication interface. Once the user re-authenticates, a smart client will then retry whatever action the user was trying to perform. TL;DR: It's not the client's job to know when it's session expires. It can just believe it's valid until the server says it's not, at which point the client should do something sensible.
Please reread my second paragraph, since that's not my use case at all (relevant bits bolded for your pleasure): &gt; My rationale is to make the site as stateless as possible from the server's perspective, which helps with everything from caching to scaling to multiple app servers. **Trivial UI elements which depend on user state (login/logoff, registration, account link, etc.) shouldn't need to be served statefully.** If the client could tell (presumably by a cookie) whether it was a registered user, it could deal with these client-side. Otherwise **there are at least two versions of every single page being served.** At the moment, this is for the sole purpose of keeping HTML content user-agnostic. I'm shooting to be able to cache entire pages for all users, eg. with Varnish or Squid. Doing caching at this level looks really simple if you can get things stateless enough. No putzing around with memcached/redis/key-value-store-of-the-day. Although this does involve Javascript, I'd like to try to keep AJAX to a minimum because it can't be cached as easily as plain HTML. I'm fine with issuing *actions* via AJAX as you suggest, but not transferring content that way. I like how you suggest handling the stateful side of things, though.
http://www.phpu.cc/index.php/Main_Page 
I know what is going to follow: People again proclaiming what a shitty language PHP is and how bad this "fix" is and bla bla bla. Well, please see it from the perspective of the people working on PHP for once: PHP isn't just some small website that you can easily change. If PHP changes something it usually has quite significant and often unanticipated consequences (remember that little is_a BC break?) One of the things PHP can't do for example is just change its hash function in a maintenance release. `zend_hash_func` is exposed through `ZEND_API` and changing its signature would break binary compatibility (i.e. break peoples extensions, making it impossible for them to easily upgrade and thus leaving them unprotected.) But even apart from the ABI break doing such a radical change could also have many more unexpected problems. It would require serious consideration and testing. The max_input_vars fix on the other hand does fix the main and immediate problem and can be refined in later releases to use an entirely different hash function. For example I saw a discussion on #php.pecl yesterday about introducing cuckoon hashing.
 select series, group_concat(date) from footable group by series; untested, may need quoting or fiddling, but i think this is generally the way you want to go.
It may be simpler to create a combined date field, populate it for non-unique records based on series, and then when you are pulling the data in just pull unique records (again based on series) and use the combined date if it's not empty, else use the date. If you do it with PHP you'll need to check the uniqueness of the record which could be a pain to scale. If you add a trigger when a new item is added to the table to check if it needs a combined date you don't need to worry about new records missing combined dates too. If you are sticking with 20-30 records and don't plan on it growing and really want to do it in PHP instead of on the data side you could store the series &amp; dates in a list as they are pulled and check each record as it's pulled whether it already exists in the stored series lists, if you have a match grab the date from the new record and the date from the series &amp; dates list and make a combined date.
If [these guys](http://learncodethehardway.com/) released a PHP book, I'd be complete.
mmm...I like [Rob Allen's dev notes](http://akrabat.com/) (he also has a pretty good book called Zend Framework in action, which of course is very ZF oriented, but that's not a bad thing if you're looking to learn some good practices). Also, [PHP 5 Objects, Patterns and Practices](http://www.amazon.co.uk/PHP-5-Objects-Patterns-Practice/dp/1590593804) is a pretty cool read. 
up voted for mentioning patterns &amp; practices :-)
Slight modification to the previous poster's SQL: SELECT series, GROUP_CONCAT(date SEPERATOR " / ") as date FROM [the table name] GROUP BY series if you think you might have multiple duplicate dates you could also add the DISTINCT keyword to the GROUP_CONTACT like this: GROUP_CONCAT(DISTINCT date SEPERATOR " / ") as date
&gt; http://phpadvent.org They have 24 articles every year for the last few years. Some of them are really, really good in my opinion. Topics vary, but the overall theme is "You're a semi-competent PHP developer and you want to learn some more stuff, here's a tip". Worth browsing. &gt; http://pooteeweet.org/blog/1932 Just one random blog post I happen to remember right now that made one good point about exceptions well. &gt; http://www.sitepoint.com/mysql-mistakes-php-developers/ "Top 10 MySQL Mistakes Made By PHP Developers". Seems like it's at exactly the level you're after judging by your remarks about MySQL. &gt; http://php.net/manual/en/book.spl.php The SPL has a good set of tools to be aware of when writing new code. Some of it is a bit esoteric, but a lot of the iterators in there can come in handy from time to time. [\Countable](http://www.php.net/manual/en/class.countable.php) is a good example of another common one. Edit: &gt; http://www.php.net/manual/en/class.iterator.php Whenever I'm using some API that requires me to call next() and current() myself in order to iterate over a set encapsulated in some object, I wish the developers had used \Iterator.
One of my current customers is on CentOS 4.x, with no plans to upgrade. In addition to PHP 4.x still on the box, there are a ton of things that would be too much of a pain to move over to CentOS 6 (or 5). I expect to see this box running for at least another 3-5 years.
A results set might need to call info from another table (thus another query). One example from today was a query with a seldom-used foreign key (no FK constraint, since this was a MyISAM table). So while I'm iterating over the rows, if I see that the FK field is set then I perform another query to get the remaining data. I see something like this all the time, and though I don't currently use PDO, I am glad that the GP made me aware of this issue.
http://www.phpu.cc/
The actual changeset, not just the docs for it: http://svn.php.net/viewvc?view=revision&amp;revision=321038
One more recommendation for Patterns and Practices. Great Book!
Try this: function binSearch($sorted_haystack, $needle) { $l = 0; $r = count($sorted_haystack); while($l &lt; $r) { if($needle == $sorted_haystack[$i = ($r + $l) &gt;&gt; 1]) return $i; if($sorted_haystack[$i] &gt; $needle) $r = $i; else $l = $i + 1; } return false; } 
You might want to return, say, a 301, 304, or 401 with a custom message.
can you go into more detail regarding why the function signature of `zend_hash_func` has to change if the hash function body is replaced?
Well, thanks to my good friend Clint Priest, the RFC I wrote in 2009 for a [C# style property get/set syntax in PHP](https://wiki.php.net/rfc/propertygetsetsyntax) is finally getting an implementation. My hopes for 2012, is is to see some form of my original proposal to make its way into the PHP core. :)
you can do that with just header("HTTP/1.1 500 I fucked up.");
I'm not really sure how you want to make the function randomized without breaking the signature. Could you elaborate how that would look like?
In 2011 I wrote a [PHP WebSocket server library](https://github.com/cboden/Ratchet). In 2012 I plan to add the following features to the library: * Session support * A pub/sub + RPC protocol * A PHP WebSocket client * Possible Nginx integration to manage connections (instead of pure PHP socket server) * Complete RFC6455 support
Notice the note right there on the page you linked to: &gt;Note: &gt; &gt;The HTTP status header line will always be the first sent to the client, regardless of the actual header() call being the first or not. The status may be overridden by calling header() with a new status line at any time unless the HTTP headers have already been sent. 
I struggled with trying to learn a framework or write one from scratch &amp; got nowhere with an important project that I've been wanting to write for work. Just started messong with Zend &amp; the pieces all of a sudden are just falling into place. Now I'm finally making progress into the actual coding little by little.
Think of it as shorthand or two headers in one function http://www.php.net/manual/en/function.header.php#96934
Achievements ------------ * Got a jerb doing *just* development, rather than a mix of IT shit and a little development * Getting my feet wet with MVC architecture (via Magento/ZF1) * Somehow managed to write a full Magento extension within three weeks of working with it. Felt good to go from clueless to somewhat productive in such a short time span. Goals ----- * Learn some proper object-oriented **design**. All I learned at university was a vocabulary list, i.e. "this is what [polymorphism|inheritance|UML] looks like." What I need is: a better knowledge and command of design patterns; how to turn ideas into actual classes; best practices and pitfalls. Basically I just need to start reading my copies of _Design Patterns_ and *PHP: Objects, Patterns and Practice*. * Finish up a [stupidly verbose Git-Basecamp utility](https://github.com/cgdangelo/GitBchq) that I just started writing * Write a couple more Magento extensions so I can keep learning stuffs * Lots of SCM-related goals in the office: * Get my fellow developers using Git * Figure out some sort of workflow that doesn't hamstring development * For myself, get used to collaborative development, and learn the parts of Git I haven't worked with much * Start contributing to open source projects more, just not sure how to get started * Maybe start blogging about my development experiences \**shrug*\*
So if I'm understanding correctly, it would be used to specify, for example, a content-length header and set a status of 200 OK in a single call. So the 3rd parameter lets you specify the status in addition to setting another header, but if you don't specify a header, then the status is not set. So they're mutually exclusive things that can be conveniently set with a single call. Does that sound about right?
Ah, I think I see where you're coming from now. The response is pretty much the same, though. If the browser is allowed to sit long enough, eventually the session will time out, and the client will still be sitting in a logged-in state until it hears otherwise. It might hear otherwise when the user takes some action (like navigation). I suppose you could engineer some kind of heartbeat where the client makes some kind of "whoami" XHR every so often and reacts on change. Though if you're doing that, the session will probably never time out anyway (unless you make sure it does). I still feel like I'm missing something about your problem. If you're doing full-page loads, the server can answer the 'whoami' question by setting a cookie (assuming you're being strict about not varying the response body at all between users). If the session times out, the client doesn't need to care until it tries to actually do something. 
Yeah, sounds like you understand it. Another example might be sending a Location header and the status code all in one step for doing a 301/302 type redirect.
alright, thanks :)
I'm working with this as a starting point, but I keep getting MySQL errors. The query: &gt; select \`series\`, GROUP_CONCAT(DISTINCT \`date\` SEPARATOR ' / ') as \`date\` from \`songs_db\` group by \`series\`; gives me the error: &gt; \#1064 - You have an error in your SQL syntax. Check the manual that corresponds to your MySQL server version for the right syntax to use near '( DISTINCT \`date\` SEPARATOR ' / ' ) as \`date\` from \`songs_db\` g Yes, the error message truncates at the g in *group by*. I've tried every variant of quote marks I can think of, always get the same result. Have I missed something? I should specify that the database table in question is MySQL 4.0. If this is a 5.x specific method (the mysql docs site seems to indicate this should work on 4.x), I can easily dump the tables and put them in a 5.x database. **EDIT**: I decided to copy my table to a MySQL 5.0 database and try the same. Now the Query works as expected but my date field is now returning **[BLOB - ## Bytes]**. More reading needed. I'm getting there... :)
Ah that is awesome. I hope the implementation is added to the PHP core as soon as possible.
I downvoted you for using Webmin. I think I might actually create another reddit account just so I can downvote you once more. Fuck Webmin.
I guess I'm not sure I see the bug. I'm pretty new to programming so I haven't fully grasped the concept of everything.
Ah, yes, you're right. I didn't read the code carefully enough.
The original passes unit tests and edge cases. Not sure how this fixes it. Elaborate?
I really enjoy MySQL for it's data modeling tools. Being able to setup all the tables, and setup the foreign key relationships and then synchronize your database with any changes you make is very nice. It's also cool because you can put your model file under source control!
I hope you were just playing around. When developing applications you should not trust user input blindly. The $_GET is full of user inputs. [Sanitise user input.](http://imgs.xkcd.com/comics/exploits_of_a_mom.png). 2ndly, try to use a single return in your function instead of using echo. Though this is a not a hard and fast rule but try to stick to it. And now a suggestion, take it a step ahead and let the user pass parameters to your function so that it can have Sun or Mon as first day and other enhancements. 
Many servers will only allow access from localhost.
Usually you are better off not using them anyway, so not a big loss. And I bet you do remember them when you have a real use case like bitmasks. 
Preferably your specific host. Otherwise you'd best be running fail2ban on the server. Of course, if you can't add phpMyAdmin, it's unlikely you'll be able to change user permissions *or* set up fail2ban. That bit flew right over my head in my first comment.
Nope. POST would be wrong, check rfc2616. Also, refreshing a page that you got via POST is equally possible, this problem should be handled with a redirect. I actually like the elegance of the year change -solution in this code. Instead of making the rendering code checking for the border case (if next_month &gt; 12 then year++;month=1;endif) you can just render the link very simply (calendar?y=year&amp;m=month&amp;a=next) never mind the current date! 
SQL injection is scary.
That's very good for your first script. I'm a bit of a PHP noob but I can follow it :)
Best way to learn about it is to try hack your own code there are examples across the web
Thanks. I tried being neat with comments and what not.
 // YELLING COMMENTS ARE FUN
I wouldn't ask them to use a framework. Instead ask them to write something from scratch. It will not take a good PHP developer long to work out how to use a framework. I think asking them to write a login form would be good enough - Make sure they sanitise their input and do everything else correctly. See how they hash their passwords and look at the quality of their HTML and CSS. It might also be worth asking them to do another simple exercise to test their ability with object oriented PHP. Come up with something simple that has a few classes, and some inheritance. 
Jerb! ! One of my favs. 
using tables? seriously?
A day-based calendar could be considered tabular data. Nothing wrong with tables there. The way they are used here is however pretty horrendous. 
In my opinion, having an entertaining personal project that covers lots of ground makes it much easier to get through large work. I've found that roguelikes offer a shocking number of easy, fun metaphors for concepts from Design Patterns.
There are some really great suggestions in this thread, phpmyadmin and mysql workbench are probably the most commonly used. However, none of these will improve your skillset as thoroughly as really learning to use mysql from the command line. A deep understanding of how all the pieces fit is far more worthwhile for your development as a programmer than sticking to a purely WYSIWYG visual implementations. It'll also keep you from making some of the very elementary mistakes that can bring a server to its knees quickly. Here's a decent site to get started; perhaps some other redditors have a few others? http://www.mysqltutorial.org/
navicat is great and its as fast as the database will go
I do still like PHP, and use it regularly - but i wish I'd switched over to using Python for all of my cron scripts years ago, as it's always a kludge in PHP, no matter how you slice it; in Python, it Just Works.
You're absolutely correct. You're GETTING data, you're not putting (POSTING) it in this example. &gt;As a rule, GET requests should be for read-only queries; they should not change the state of the server and its data. For creation, updating, and deleting data, use POST requests
To be honest, the paid edition is totally worth it too. It's a great piece of kit and the devs are very responsive to feedback.
In MySQL Workbench to get the spreadsheet like look you're looking for that generates sql use the edit command.
I will never understand why people subscribe to subreddits about topics that they dislike.
Two of my friends are developers, and whenever one of us builds something, it gets passed on to the other two with instructions to "break this."
Check out Chive. It's like PHPMyAdmin, but isn't ugly or outdated and supports triggers. http://www.chive-project.com/
Most servers will also allow you to specify remote hosts that are able to access it. You can enter the IP of the connection you're using and it will be fairly safe to work with.
I take it you haven't used it in awhile? It's not ugly or out of date - http://demo.phpmyadmin.net/master-config/. I love Chive's syntax highlighting, but I still found PMA to be more robust overall.
This is the program for Mac, but on Windows systems the program HeidiSQL is pretty nice.
Ya know .. ZF would be the last place where one should go for good practices. As for the "PHP5 Objects" book , yeah , that one is pretty good. 
Sessions are tied to the cookies anyway. Look up "PHPSESSID".
Also you will likely have to open up a hole for your local IP address in the hosting firewall. If there *isn't* firewall blocking direct MySQL access to the Internet by default, then get one on fast.
I think that article might have been under a different context because the two statements are functionally equivalent and will produce the same $i for any $l and $r.
I do not dislike PHP, but I am tired of it. I keep subscribed to keep up with PHP progress that can help me get the job done in a more professional way.
For a month overview, a column per day of the week and a row per week would work. It really seems to be the most semantically fitting element. What's your alternative? An ordered list? A load of divs?
Thanks for the advice. :) I've been going around GitHub/websites lately and checking out issue trackers to see if there's anything I can contribute.
Hrm... I'd started an RFC for something similar around the same time - wish I'd finished mine and actually had some comments. I was going to suggest opting for something more basic, like... look up is a getFoo() method existed and call it, otherwise do normal behaviour. Or, potentially compile each declared property in to get/set methods in bytecode, and always invoke a get/set method on get/set accesses, but use user-land defined ones if they existed. Would have liked to stay away from extra keyword of "property" if possible. That said, I'm glad to see something like this happening in some fashion - congrats.
Absolutely. But that's just a data entry tool. The underlying principles behind relational databases and spreadsheets are quite different, and if you start off treating them as sorta similar because the tool you're using for data entry has 'rows' and 'columns' too it's not going to go well. I dread to think what a third normal form spreadsheet might look like :)
What disrto do you use? Have you tried running it under wine?
ISPConfig builds with an earlier version too. :( 
My goal is what it has been for the last two years; get my framework to a point of where I'm proud of open sourcing it.
The single achievement worth mentioning is that PHP is still making me enough money. Same plan for 2012.
Well, if you make it randomized you would need to pass the random parameter into the hash function, wouldn't you? Thus you would need to break the hash function. More realistically you would probably fetch the random parameter from some global resource, but that would (in my eyes) require to pass TSRMLS into the function (for ensuring thread-safety). Alternarively one could manually aquire the TS context through TSRMLS_FETCH, but that is a really slow operation if I remember correctly (thus making already normal HT accesses slow like hell). That's why I would think that you can't make the function randomized without breaking ABI BC. But I'm no expert on the topic either, I could well be wrong. Only saying that just proclaiming this to be a bad dirty hack is inadequate, as changing the hash function is harder than it sounds.
bool imagecopyresampled ( resource $dst_image , resource $src_image , int $dst_x , int $dst_y , int $src_x , int $src_y , int $dst_w , int $dst_h , int $src_w , int $src_h ) You can supply desired dimensions difficulty is cropping desired part. Maybe grab top left corner or simply a centered rectangle
This is a great idea, and a great RFC. I hope it gets implemented to work the same way as in C# (your initial proposal, I think). But even the more exotic syntax will help. Is there a way to support that RFC ?
Easily solvable with some special character limitations.
That was my 2011 resolution. I succeeded! After learning how to do it, I really enjoyed writing them. Good luck to you!
The new skin is prettier but I find it less clear and useable, so I switched back to the old skin. A common fate in web design.
No noticeable benefits. There's no harm in doing it the other way. I just figured hey if we can kill two birds with one stone then why not.
&gt;So then I followed these instructions using custom values The page you linked to explicitly states that the method does not work on Wordpress 3.x.
Template pages are special files that are theme-specific. If the option is disappearing for you, then clearly Sight doesn't have any template pages. But they're easy to make. [Here's some info](http://codex.wordpress.org/Pages#Creating_Your_Own_Page_Templates) about how to do so. Essentially, find "page.php" in the Sight theme files, make a copy of it (save it as something like "no-sidebar.php"), and then insert the following at the top: &lt;?php /* Template Name: No Sidebar */ ?&gt; You can then edit the new file -- look for something saying get_sidebar() and take it out. Once that's done, go back and edit your page, and in the editor you should see the option for "Templates", and one of them should be "No Sidebar". Select it, and enjoy! *Edit:* Just as a note, the get_sidebar() function may be called in the footer. If this is the case, you'll need to open up footer.php, copy and paste the whole thing, and then go back to no-sidebar.php and paste it in, in place of get_footer(). Then you can take out get_sidebar() from the pasted code.
&gt; I know this is not PHP related, I'm gonna stop you right there. If you have a problem with a business partner, seek a lawyer not an internet discussion forum.
In the future, might I recommend checking out [WPQuestions](http://wpquestions.com/) instead of cluttering up this subreddit? This really isn't the place for this.
I'm going to be brutally honest here. The best thing you can do is to find someone who's an expert to mentor you. At this point, you're not going to get a lot out of going to school for this sort of thing, so the best you can do is apprentice 'till you are good enough to make it. Have them look at the site you created and tear apart your code. If this is an actual e-commerce site that accepts payments, and it's your first project, I'd be very, *very*, **very** concerned about security issues. This is lawsuit territory. I can assure you that a single project is not even vaguely enough experience to allow you to do this professionally. PHP gives you a thousand ways to hang yourself - It'll take years of learning the ins and outs, or you'll just make really bad sites that will make everyone hate you who has to clean up the mess. And stop using CodeIgniter - you're not doing yourself any favors there. Try something like Symfony, Zend, or Cake. Spend a bunch of time learning Wordpress, Drupal, and Joomla (tweaking themes and creating plugins) and you can probably do a decent turn of business working with a designer to make one-off business card sites.
 $statement = $db-&gt;prepare("SELECT DISTINCT ? FROM inventory"); $statement-&gt;execute(array($filter)); This isn't going to do what you think it does. Let's *assume* that `$filter` is a scalar value. Let's say it's the string `foo`. The resulting SQL built from this statement\* will look like: SELECT DISTINCT 'foo' FROM inventory Pay attention to those quotes. What will be returned by that statement? If you said "distinct values in the `foo` column", you're wrong. In SQL, things inside single quotes are *values*. Values aren't *identifiers*, like column names, table names, schema/database names, etc. The query will return a result set with one row and one column, containing the string `foo`. In the SQL you've built, it looks like you're trying to provide a dynamically generated list of *columns*. You pretty much have no choice but to either build the SQL by hand, or use a tool that does it for you. If you do it by hand, you can keep yourself safe by *selecting from a whitelist* of column names. Let's say that the user has provided a list of columns to choose from, and submitted it as `$_POST['cols']`: $whitelist = array( 'name', 'sku', 'shelf' ); $columns = array(); foreach($_POST['cols'] as $col) if(in_array($col, $whitelist)) $columns[] = $col; $sql = 'SELECT DISTINCT ' . join(', ', $columns) . ' FROM inventory'; This provides effective validation of user input. Only values that are in your predefined whitelist will get through to the SQL. It's also quite possible that I've completely misinterpreted what you're trying to do, in which case we'd need more information to provide a better answer. For example, what's *really* inside of `$filter` and how is it generated? \*: Depending on how you're working with PDO, it will either send *real* prepared statements to the database, in which case it doesn't build SQL, or it will *emulate* the prepare by building SQL and sending it off. The latter is the default. If real prepares are being used, the quotes won't actually exist in the SQL the server executes. It will instead do magic and properly bind the passed values where the placeholders exist. It's very possible, depending on the SQL dialect being used, that you might end up with a *wacky* error instead of a one-row record set containing `'foo'`.
You cannot build dynamic SQL with prepared statement parameters -- the ? in the query can only be used in places where *values* would accepted. In this case, you're trying to use it to make a list of fields and you can't do that -- that's altering the statement itself. If you want to avoid SQL injection, just make sure that $filter isn't directly user supplied data. 
sort of "awesome" because that's actually what I figured I had to do, and yes, I have a list (its just called "$filters") that is the same as your whitelist... so this is my new code: &gt;$filters = array("manufacturer", "category", "color", "size", "art", "matte"); foreach($filters as $filter): ?&gt; &lt;div id="&lt;?php echo $filter; ?&gt;"&gt; &lt;?php $statement = $db-&gt;prepare("SELECT DISTINCT $filter FROM inventory"); $statement-&gt;execute(array($filter)); while ($result = $statement-&gt;fetchObject()): echo $result-&gt;$filter."&lt;br&gt;"; endwhile; ?&gt; &lt;/div&gt; &lt;?php endforeach; ?&gt; Thanks again for the help and explanation!
Generally these checks are performed by looking for a magic byte, and aren't very reliable anyway. Mostly you just want to ensure that files don't get named something the server would consider executable.
Run the software once, take down every PHP site?
Why are you escaping strings if you're inserting them through a prepared statement? They're protected anyway. Firstly, do a select to find which urls are already present. Then do an insert to insert all unique urls. That's two queries, instead of 'however many urls you have' queries.
Im new on prepared statements (: Thought I would need to escape strings too. I don't know how to do that, (select, then insert) since I insert around 200 records with all differents URL's. 
What are you using var_url for? Why not just base it off of your primary auto_increment key on the table (which I generously assume you have) ? If it's something a user is using as a unique reference to a thing, it will always be unique and easily looked-up. Just create a salt somewhere and show the result to the user: $salt = 'My secret string'; print md5($salt.$record-&gt;id); Then to look it up later: $query = 'select * from tablename where md5(CONCAT('.$salt.', id)) = '.$_GET['var_url']; (Only with statement preparation and all those goodies instead.) 
Protip: Use a framework like Symfony and you can introspect on the model to see what fields are available, rather than hardcoding them in your PHP. (And it also gets the raw SQL statements out of your PHP which is also generally a good thing.) Wow, downvotes. What the hell, guys?
&gt; The first select returns all the URL which are repeated, true? Correct. Just remove them from the array of urls you have in php. Insert the remaining. Actually, I might have missed a simple feature; you might be able to use `NOT IN` instead. Will get you exactly what you want. I was just showing you the syntax of the two statement's you'll likely want to use.
Oh, "NOT IN" is actually what I need. ~~Still, I wonder If "INSERT INGORE.." will be better, since it's only a single query.~~ Nevermind. Thanks for the fast answers!
Thanks, I just was wondering that.
Thanks, but I'm not really interested on how many times it repeats.
`INSERT IGNORE` might be a good solution also, depending exactly what you want behaviour to be. http://stackoverflow.com/questions/548541/insert-ignore-vs-insert-on-duplicate-key-update
&gt; but INSERT IGNORE would be considered a "fragile" piece of code under these circumstances. Why?
It's all good, although you don't need to actually keep tabs on it, but it's still a single query and you don't need to worry about conflicts or rows moving on you.
The difference will come when dealing with very large numbers (specifically when `$l + $r` is greater than `PHP_INT_MAX`)... (PHP_INT_MAX + 1) &gt;&gt; 1 // -1073741824 for 32 bit system vs (PHP_INT_MAX &amp; 1) + ((PHP_INT_MAX ^ 1) &gt;&gt; 1) // 1073741824 Notice the sign change. Note that this will only occur when `$r + $l` is greater than `PHP_INT_MAX`... Which in this case, is impractical. But worth noting none the less...
Okay, thanks. I didn't even know about that subred, and like I said, I thought I was having a php issue. I appreciate the heads up though.
Don't use wordpress. Unless you know PHP well, odds are you are going to install some addon that is going to make your site run like shit and open a security risk to your site. 
You should look into how the addons for wordpress works; it is a linear hooking mechanism that causes each module to load at every php execution. 
You've got it - that's not PHP using the memory, it's MySQL. PHP just has a client connection to the MySQL server. There are a hundred ways to performance tune MySQL to use less memory, I can think of a dozen settings in my.ini that you can change to limit the usage: * key_buffer_size * query_cache_size * query_cache_limit * table_cache * max_connections * tmp_table_size * innodb_buffer_pool_size But you might just be better off adding a LIMIT statement to all your SELECTs, if you don't really know what you're doing. Here there be dragons.
What he said. Paginate. Also be careful with views, they don't include indexing in MySQL so they are not a good choice for production.
I appreciate your honesty. 
I'll use this one in production
Thanks a bunch for this! I'm starting a new job doing PHP in 2 weeks and need to refresh myself on PHP after not working with it too much over the past 2 years. This looks to be a good start.
Yes to punk code!
(Continuing the band/music analogy): If you need a cymbal, you need a cymbal and I sure as hell trust Zildjian to build me one then to try and make my own. (Leaving the band/music analogy): Does that mean you should go grab a framework with thousands and thousands of things you don't need? Not really. Does it mean you should dismiss frameworks that have thousands of things you don't need? Not necessarily. He says he starts with a microframework and then tacks libraries on as he requires them. That's great and all but now you're left with a collection of disparate libraries scattered around your application. How is that better than simply using a framework? edit: Forgot to mention that of course, depending on the application you're building, you'll need to adjust your plans accordingly.
I was using the views for example (just to create a filled table) - we do not use views in production or anywhere else.
I would argue CodeIgniter is a bit bulkier than I am talking about, but I suppose you might be correct. I haven't looked into Laravel, looks like I may need to.
I was thinking server, because all the settings he/she listed were for the server.
Wait... If we use that analogy we should go with the Peart solution as he is arguably one of the best drummers _in the world_. Part of what makes him the bees knees is the ability to leverage his kit to sound awesome. 
ditto, my friend, ditto
Wow... holy crap that framework looks almost exactly like one I created for my own use... crazy. Thanks for sharing
`mysql_real_escape_string()` is completely unrelated to HTML escaping. One blocks SQL injection attacks, the other blocks XSS attacks. Of course you should block both attacks, as well as many other kinds of attacks. But no single solution will block all forms of attack for you. Here we're only talking about XSS. By the way, if you really want to block SQL injection, learn to use PDO and prepared statements. They'll make your life so much easier, compared to manually escaping each string.
&gt; I like building small things This really explains everything that needs to be said about this post. ~~Whoever wrote this has obviously never worked with large systems that require architecture and organization and support for a lot of different things. He also apparently doesn't understand the need for having large frameworks that all conform to a particular specification.~~ Apparently the guy that wrote this is a well known developer (I've never heard of him before and didn't bother to research the background of a blogger, because I never do that, because that's insane) and I'm getting a lot of fire for attacking him here. Oops, sorry. Either way, I stand by my criticisms of what he has to say and I am curious how he arrived at these conclusions if he has, indeed, worked with giant codebases. I've worked regularly with codebases that have stretched into the thousands of classes, both open source and not, with and without a framework, and it seems reasonably self-evident to me that by the time you start needing 3rd party libraries in PHP, you're large enough that a full stack framework is probably your best option. I feel like I shouldn't have to explain why this post is complete nonsense for people who write serious software. I will, gladly, if I need to, but this just screams amateur to me... once you solve problems that need a framework, you understand why frameworks are needed. There's no real cost to having a huge framework (like there would be in javascript, for instance, because of page loading times), so why the focus on "micro"? Microframeworks do several things that large frameworks do not, all of them bad: * They encourage people to reinvent wheels because they do not include X functionality. * They encourage people to focus on size/simplicity rather than robustness, security or stability. * They encourage people to grow a large set of disparate and unmatching libraries in their projects. * They encourage people to needlessly criticize large projects simply for being large, rather than trying to foster an understanding of good software engineering - something that's pretty lacking in the PHP community. And what advantages do they offer? Simpler API documentation to read? How lazy are you that that matters? &gt; I want to play shitty power chords in a punk rock band that plays shows in a VFW lodge with no stage, and leaves you so fucking pumped that you go out and form your own band. That’s the coder I want to be. And those people are shitty musicians and you've headed down a path to being a shitty coder. Congratulations? EDIT: Disagree? Downvote and move on. Stay classy reddit, heaven forbid you actually have a conversation!
A framework is a tool. If you don't need it, why use it? I use Symfony2, it have a strong community and they are trying to use all the power from PHP. If you limit yourself to just *keep it simple*, you will end up with a lot of small files difficult to maintain. Why build up a login? pagination? routes? etc. over and over. You can get that and more out of the box from every framework. That is a time saving. And remember: APC and MemCache are your friends, use them. 
I can't iterate over how everything you just said demonstrates a total lack of understanding about the purpose of the OP's writing, let alone the idea that you need to select what tools are needed to do the job. Nothing is black and white. That is clearly obvious from the what was said. &gt;They encourage people to reinvent wheels because they do not include X functionality. Then you don't use it. You use something that addresses your needs. &gt;They encourage people to focus on size/simplicity rather than robustness, security or stability. If I roll my own mini-framework for a project, I don't have to worry about others' bugs 30 levels down the class chain opening my application to crashes, unintended functionality, or security risks. Rolling one's own miniframework demonstrates a confidence in one's skills that good developers have and are not afraid to rely on. As for scalability, I've never seen a large library or framework outperform code written *specifically* to attack the task at hand. Ever. &gt; They encourage people to needlessly criticize large projects simply for being large, rather than trying to foster an understanding of good software engineering I didn't see any criticism. I saw some comparisons. Oh, and *now* you mention developers who know about quality software engineering. I didn't see that earlier when you were implying that any code that is self-written is automatically poor and inadequate.
I want a framework that is build as a PHP extension with all of the required core components like routing, some ORM, all the basics. That would be killer.
I was using SQLyog... I like it but I started using http://www.heidisql.com/ because of the nags you get in SQLyog
&gt; Whoever wrote this has obviously never worked with large systems that require architecture and organization and support for a lot of different things. He also apparently doesn't understand the need for having large frameworks that all conform to a particular specification. &gt; you've headed down a path to being a shitty coder. Congratulations? [I don't think this guy sounds like as much of a blithering retard as you make out](http://careers.stackoverflow.com/funkatron) 
I was going to reply to this, but it seems that you're more interested in personally attacking me than responding to what I said. I have no idea who Funkatron is and I don't think it should matter, what he said is absurd and is not a good way to carry out development. If you want to act childish and insult me all the way, go right ahead, but don't expect a response.
I don't think a global randomized resource needs to be part of the threadsafe resource manager, because it wouldn't be mutable. Even something like a timestamp used as a seeding value for the hashing function would be sufficiently "random" enough to prevent this sort of attack (unless your attacker was precise enough with his attack, which is unlikely if you use even millisecond precision). And because the hashing function has to behave deterministically, whatever random seeding value is used for the hashing function has to be immutable, so it's threadsafe by virtue of its immutability.
Hey fuck you guys, This is a decent way to manage sidebars. Tell me another way for newbies, whoever downvoted ?
Kohana? It offers some ORM stuff but doesn't require you to run any anything in the command line like Symfony.
I just wrote this, but I haven't tested it. Set the input filename, width, height and output type at the top and run. Theoretically it should automagically detect the input type (JPEG, GIF and PNG are currently supported) and create the required image according to the type and dimensions you specified. The output is made to the browser rather than a file (easy to change) with default quality settings. It does whatever error checking might be required. Remember that NOTHING else can be outputted before this script is run, otherwise the output image will be corrupt. It might even help to set error_reporting to 0 for this script, and reenable afterwards. Anyway, onto the script: ------- // Set the parameters $filename = '/home/xyz/xyz.jpg'; $width = 300; $height = 100; $outtype = 'jpg'; // Valid values are 'jpg' (which is the default), 'gif' or 'png' // Check if the file exists and is readable if (is_file ($filename)) { // Get the original dimensions of the input file $info = getimagesize ($filename); if ($info !== false) { // Store the original width, height and type of the image $width_orig = $info[0]; $height_orig = $info[1]; $imgtype = $info[2]; // Retrieve the file if ($imgtype == IMAGETYPE_GIF) { $in = imagecreatefromgif ($filename); } else if ($imgtype == IMAGETYPE_JPEG) { $in = imagecreatefromjpeg ($filename); } else if ($imgtype == IMAGETYPE_PNG) { $in = imagecreatefrompng ($filename); } else { $in = false; } // Create a new image with the required dimensions $out = imagecreatetruecolor ($width, $height); // Check to see that everything has been created successfully if ($in !== false &amp;&amp; $out !== false) { // Attempt to resize the image if (imagecopyresampled ($out, $in, 0, 0, 0, 0, $width, $height, $width_orig, $height_orig)) { // Output the header if ($outtype == 'gif') { header ('Content-type: image/gif'); imagegif ($out); } else if ($outtype == 'png') { header ('Content-type: image/png'); imagepng ($out); } else { header ('Content-type: image/jpeg'); imagejpeg ($out); } // Kill the script to prevent further output exit (); } else { // Place any error reporting/etc here for when the file cannot be read } } else { // Place any error reporting/etc here for when the file cannot be read } } else { // Place any error reporting/etc here for when the file cannot be read } } else { // Place any error reporting/etc here for when the file cannot be read } 
That would be so handy. A more current (5.3+ only?) phpclasses.org or PEAR without the burocracy... No, we prob need to look at more of the Node world and others for their package systems. Packagist seems like it has potential here. Interestingly, with so many mini packages, NPM has started to show some strain in distinguishing quality among them all. I guess the problem of ensuring 3rd party code quality just hasn't been solved at scale yet...
&gt; I think you might be paying a little too much attention to the mention of micro-frameworks. Ed is not saying that everyone should be making their own framework, he's not even saying that people should be reinventing wheels. That wasn't very clear, especially when he starts attacking things based on ridiculous lines-of-code metrics. I'm not sure how else to interpret that other than saying that micro is better? &gt; Why is it so important for libraries to match as long as they are well documented and easy to use? The problem here is two fold, I think. The first, and most important, reason is that it means there's actually a higher overhead to learning and adopting new libraries than there is framework components. If, for example, I decide that I want to add forms to my web application that's already built with Zend Framework, I can just pull in Zend\_Form and I have a reasonable expectation of how things are going to be named, laid out, interoperate, etc. simply because they're part of the same full-stack framework. On the other hand, using separate libraries for everything means I have to learn all of the things that come with a macro-framework every time I introduce a new library. This is a lot less of a problem in JS because JS libraries do a whole lot less than PHP libraries do. If I've got 4 ways to access data (say a database, a persistent cache like cassandra, a distributed temporary cache like memcached and a search application like Solr), I'd like to know that the libraries I use conform to a particular style of coding and architecture. The same goes for (de)serializing data, talking to various services, etc. The biggest advantage to macro-frameworks is the coding standard that they enforce, at least in terms of developer overhead, because it means that a lot of mental boilerplate (naming conventions, argument ordering conventions, etc. etc.) is eliminated. The other reason I think it's a bad thing is because it forces a visual and logical disjunction in sections of your code. Hypothetically speaking, in that same scenario where I need to talk to four different data providers, the Solr library I use could expect sub-classes and interface conformation and be a very static library, while the memcached library might only be functions in C-style (like much of the PHP API), and the cassandra library might expect callback functions and be in a very functional style! Now, in my project, I have to support three entirely different paradigms of programming to achieve the same effect as if I had just gone to a one-stop-shop (supposing a one-stop-shop existed for whatever hypothetical here). This is a *terrible* state of affairs if you expect your code to be consistent throughout your project - you've literally made it impossible without wrapping everything you use inside of conformance containers. I know this is currently the state of affairs in the PHP SDK itself, but that doesn't justify it or mean that anyone should be happy with it as the status quo, especially not if there are viable alternatives (and I realize that there aren't always). The only way to avoid these two things, as far as I'm aware, is to standardize around a core set of ideas and behaviors and stick to them. If all libraries did this, there'd be no interoperability or mismatch impedence between them, but there wouldn't be any creativity happening either. I don't think it's a problem that can be solved without consolidating libraries into collections of libraries that are designed to work well together and conform to the same specifications. That is to say, frameworks solve this problem by their very existence and it's the only satisfactory solution that I'm aware of. I'm not sure I agree that the JS community and the PHP community are comparable, at least not as far as micro-frameworks go. JS solves a significantly smaller problem set than PHP does and is responsible for a whole lot less, at least on the client side. I've heard that the node.js community has problems with there being a glut of libraries and no clear way to delineate which one is preferable to another - a problem eliminated by hitching your cart to a framework horse. You don't have to evaluate four different ACL libraries when your framework provides one! I'm only speaking from hearsay, though, as I absolutely detest javascript (primarily due to its scoping rules, eugh) and will only write it under duress, so it's unlikely I'll ever hitch my cart to the node.js horse. The other thing, too, that I think the JS community has that the PHP community doesn't is a significant benefit to micro-izing their frameworks. I've not seen a convincing argument that it offers any benefit specifically in PHP, other than a bunch of hand-waving about performance (and by the time the size of your PHP runtime performance matters, you've sold a whole pile of other extremely difficult problems that haven't even been brought up here because for the 99.9999% of web applications in PHP, the runtime performance most assuredly is irrelevant) and vague arguments against complexity. I'm not sure how big the performance hit is for using something like ZF over something like Lithium, but I know that it doesn't matter; if that mattered, I wouldn't be using PHP, but something that executed faster - probably JRuby. I don't prescribe to the PHP cargo cult; PHP is a tool that solves a very specific set of problems and performance-constrained applications is not one of them. And finally, I think that it can't happen at all in PHP until the community standardizes around some kind of distribution and dependency management software. Most, if not all, of the other language communities have (Ruby has gems, Java has maven, Perl has CPAN, etc. etc.) and PHP, for whatever reason, only has a string of valiant but unsuccessful attempts, like PEAR. I know that Packagist has made a lot of noise lately and I'm hoping that the community standardizes around it. One of the criticisms that the OP had in his post was the difficulty in dependency tracking and upgrading from PHP version to PHP version; this isn't a problem with software design or architecture, it's a problem with the community and the platform and a good, standard build tool and dependency manager will do wonders to alleviate it. I will leave you with this idea: one of the OP's closing points mentions that he wants code that's easier to read. Without a standard, well-defined way of writing code, how easy can you really make it to read?
&gt; but at least gives the guidelines for snapping on additional libraries? There are plenty that have steps and code dedicated to doing such things. See [cakephp](http://book.cakephp.org/2.0/en/core-utility-libraries/app.html#loading-vendor-files) for example. The major problem is that libraries come in all shapes and sizes. Some are procedural, some are purely OO, some have a mix; some expect other things to be there, some fuck around in the global context, some are completely namespaced. So it's not a trivial feature to provide by any means.
&gt; Then there's the rest of us who think good programmers say away from bloated and complex software and prefer to write very elegant solutions to problems. And then there's the other rest of us, who think that a good artist can make a beautiful painting, whether he's using a large canvas or small. The size of the canvas (framework) doesn't necessarily imply anything about the quality of the work he can produce with it. A naive artist will think that he can produce a simpler, more elegant painting with a smaller canvas. *Large canvases are for painters!* That would be why he is naive.
When someone who has a history of writing successful software says something absurd, it's time to revisit your assumptions.
Please, Please, Please stop using the word robust. Robust means strong, unlikely to break, or difficult to break. A piece of steal is pretty damn robust. A tank is robust. A framework on the other hand, especially one which is very feature rich is extremely prevalent to security and unforeseen problems making it less robust. Robust usually means simple, few moving parts, less likely to break. You confuse size for robust, i can assure you size does not mean robust. A Kalashnikov is robust because of it's simple design and use of a good design. Frameworks can be robust because they are well designed. A building can be robust because it's design is such that it can handle many failure points that prevent it from collapsing which make it robust under extreme conditions. Large does not mean robust, it can often times mean the opposite. Zend might be robust because it is designed such that it can handle many different points of failure and also that the points of failure have been documented in many bug fixes, so the codebase became robust through the process of stress testing. Light frameworks might not be robust because of their lack of enterprise testing which means they might not be tested under nearly as extreme a load. But please, size does not mean robust. The only other definition i can imagine you might consider is these large frameworks are robust because they are fat, like a really fat woman looks robust. [robust](http://mw1.merriam-webster.com/dictionary/robust) [5]
You said a bunch of stuff after "This really explains everything that needs to be said about this post.". You should have stopped there. That really did explain everything that needed to be said about that post.
I didn't say that large and robust were synonymous. Please read what I said again, I even provided a citation.
It's cargo cult mentality and it dominates a lot of communities, but it's especially prevalent (for some reason that I've spent a lot of time pondering to no avail) in web development circles, at least in my experience. I've worked with several developers who will completely change their entire ideology and approach to development because $hero told them to. I know they will, because I've seen them do it! I've always felt that the ideas should be argued on their merits, not the merits of whomever is presenting the idea. A great idea from Stalin is still a great idea and a terrible idea from Gandhi is still a terrible idea, regardless of where they originated or from whom they're presented.
Mostly still up to date: [Unofficial Kohana 3 Wiki](http://kerkness.ca/kowiki/doku.php)
Wow... the documentation really is lacking there. http://kohanaframework.org/3.2/guide/userguide/markdown is a bit of a lol. Claims it's HMVC... has absolutely no information on implementing it. -_- Cake plugins are dead simple, well documented, and pretty ubiquitous in comparison. That said, this article from 2010 might get you started. http://techportal.ibuildings.com/2010/02/22/scaling-web-applications-with-hmvc/
Someone needs to learn what an appeal to authority is.
You should try asking around on the forum. Also, there's a good explanation of HMVC here, using Kohana: http://techportal.ibuildings.com/2010/02/22/scaling-web-applications-with-hmvc/
Although it's not a microframework, CodeIgniter is very light, you only load what you need. Just for it's security, routing and pseudo-activerecord syntax it's worth using even on very simple sites. And templating, caching, etc if and when you need it. You can integrate Zend libraries in to it at will.
There's a tool for ever job, I agree some projects or companies "need" something like Zend or Symfony for their enterprise projects. Whether or not you'd want to work on a project with 1000's of classes is something else all together. I can feed a family with the salary I've been getting paid to make relatively simple sites (where the challenge is managing the client rather than writing the code) and it's a shame that the only PHP that's taken seriously are monsters like Drupal, Cake and Zend, while things like CI, YII all these funky micro-frameworks are better tools for those jobs.
I use primarily Symfony2 and Zend Framework and if anything I would like a blend of the two rather than some mystical lightweight framework.
&gt; and those who have experience succeeding should be heeded No. Those who have experienced success should be considered, just like those who have experienced failure should be considered. They should even be considered on equal merit. The only factor that success really impacts is the reach of your statements, how many people are likely to spend time considering your statement.
You dont need to apologize. 
If you want to scale I don't think you will load 200 files on each request because you will use APC anyway. About the YamlFileLoader, Symfony2 got an external security audit, I wish more project could do that.
This post makes you (and by association your framework) look bad regardless of the validity of your points.
Avoid? Seriously though, in the spring/summer I let myself be put in a position where I was working 75 hours a week ended up with a preliminary diagnosis of stage 2 hypertension (I'm 31, stopped smoking two years ago and don't drink) so I decided enough was enough and did the following :- * Told the boss straight out that salaried does not equal never working less than a 75 hour week - result: I now never work more than 50 hours and aim for low 40's. * Stopped the boss imposing unrealistic deadlines. * Made the boss aware exactly how much it would cost to replace me * Pushed decision making back onto the boss (instead of just picking up the slack even when it was outside my remit (email is your friend for when the boss gets temporary amnesia about agreeing to something)) * Started getting away from the computer completely * Started eating better * Protected my sleep and downtime. Oh and the hypertension? completely gone my BP is now exactly in the middle of the normal range for someone my age. EDIT: The way to do this is to just sit down with your boss and make him aware of the issues and if he is generally a good boss (mine is) he will work with you to fix the issues, if he doesn't well then you have to decide whether you are willing to continue. 
using a system like composer+packagist also means you can choose and there can be real "competition" and many alternatives with different focus. sometimes i need a simple solution, sometimes i need a complete and extensive one. PSR-0 is the key and I realy hope to see more specifications 
I wanna be the beatboxer, then
The process continues I'm getting back into regular exercise (used to be a gym rat years ago). In the end I sat down with the gf and we decided that a nicer standard of living wasn't worth me dropping dead in my 40's (in the end it never got that far anyway). 
My thoughts on the subject: http://blog.ircmaxell.com/2012/01/microphp-fallacy.html
I find I don't write as much code at home anymore. Programming is great, but vary your off-time activities so you're not doing it all the time. If you're gainfully employed in a good programming job, you've probably got enough money to find an interesting hobby that gets you away from it from time to time.
Compare Zend Framework and Slim Framework starter guide. Which one is simpler. Sometimes there are autonomous services that are small, exposing a web api. I find Slim is the best framework here 1. For the ease in developing a Rest API. 2. I was able to use mustache for templating very easily. Imaging integrating a templating engine with Zend Framework. 3. I need very simple functionality in this autonomous service, very unlikely that I would need another library with this. It just lists some resources in json format, and passes some POST/PUT requests to a command handler which in turn calls a Domain service. Again the domain service is very simple too and will not need integrating with lots of libraries. Welcome to the world of SOA and distributed systems. 1000s of files of code doesn't have to be coupled together into one monolithic codebase. Now the Application that uses this service, it uses Zend Framework. Because that's where I want to use complex logic to make the UI more user friendly and "robust", using pagination, cool forms and what not.
Did you often find yourself in uber amounts of rage? What were you working on?
lol, touche.
I'm not sure where you're getting stuck: 1. The router initiates the request to a controller, whose job is to simply manage the request, not do any actual lifting 2. The action that is called can then request another action (and so on) 3. Each action sets a response (or not). Don't echo or return anything in this actions 4. Each time an action initiates a request that ends in another action, it's basically as if your browser were initiating that request with that sub-action 5. Your initial action request finally returns output to the browser If you're stuck somewhere, join us on Freenode #kohana
 Reminiscent of this one from a few years ago, from the 'godfather': http://toys.lerdorf.com/archives/38-The-no-framework-PHP-MVC-framework.html Bottom line: if the client has a working solution and is paying their bills the rest, unfortunately, is horse shit. When you can't plan for tomorrow and only code for today, as is the norm as experienced by myself over 12 years, then it really is pretty insignificant what your codebase looks like. Framework or no framework, you'll end up with a ball of sh*t in most cases and as long as the appliance still works for the person paying the bills - it simply doesn't matter. Sad, but most definitely true in my experience. Money talks. 
Server side javascript (node.js) is another good option. The event programming model it uses is totally different to most of what you do with PHP and it helps your client-side javascript skills as well which is great.
I'm not sure why you got downvoted, nothing you said is outlandish. When people say simple, they really mean as simple as it can be. Obviously complex problems tend to have complex solutions, although not always.
 Keep learning new stuff. Play with a new framework, experiment with some [design patterns](http://en.wikipedia.org/wiki/Software_design_pattern), or even try a whole new technology (node.js and Amazon Web Services are two very relavent ones today). If your current job doesn't let you do these things easily, it's time to find a new job. 
I make time to work on stuff that's not necessarily high priority to the business, but is nonetheless interesting/educational to me, and still is an improvement to the product/infrastructure/code base. 
I ended up quitting a well paying salary due to (in part) what I considered unreasonable expectations on my time (it was taking a major toll on my personal life). I started my own firm and am currently contracting hourly, which is nice when crunch time occurs. I'm making less, but I'm a lot happier. Working better is not the same as working harder.
Does facebook use php in all of there services!? You know, just to be consistent. For that matter, what big enterprise uses the same technology for all of their applications?
He said "revisit your assumptions", not "your assumptions are wrong".
The fact is just that there's a place for both. It's not all or nothing here, but this community reacts so often like it is. - When you build small things, smaller tools work better (taking a power drill to a pair of glasses would clearly suck... :) - A framework should have in its goals to require less code on the part of the developer. That's no a micro-optimization for the framework, it's a consideration of how the developer will use your framework. Reading the ZF2 "quick start" guide made me throw up in my mouth. I understand they're creating something that will satisfy every possible configuration and be as abstract as possible for that reason, but it leads to dealing with a lot of ugliness as a developer using it, and the abstractions have gone overboard. DI can be really simple (`$foo = new Foo (new Bar)`), but the level of configuration involved in starting with ZF is anything but "quick" in their examples. Using the full sf2 framework feels the same way. - Simple, readable code we can clearly all agree on. But we're not all going to agree on what that means. I personally think a lot of popular frameworks are over-architected and lead to too much boilerplate code for developers. I don't think Laravel or Slim and the like match up in features, but for smaller projects they certainly offer enough, and have some good ideas on conciseness that are refreshing in the PHP world these days. I'm more a fan of satisfying 80% of use-cases cleanly, than 100% with that much extra crap involved. There's no fallacy in the MicroPHP movement. We just want things to look nicer for us, like what people are doing in Ruby, Python, CoffeeScript, etc. There's clearly a movement that's larger than just PHP towards concise code, and PHP and its most popular frameworks have been moving in the opposite direction. That's the source of discord here, plain and simple.
Ya, it did change a bit through each update, but it wasn't a huge deal. Just check the deprecated warnings and update accordingly. The thing I liked about it was since it's Javascript, I was familiar with the language conventions and syntax so I was free to focus more on the asynchronous programming aspect rather than learning the basics of a new language.
Yea we all centralize. I don't understand though why you need to make the call using $this-&gt; when self:: would suffice. Creating unnecessary object instances wastes memory and generally clutters up code more by forcing you to have to pass object references anytime you need to use a function which could be called statically.
They're the same thing.
Sound like a bad company for you, you can growth as software developer in that environment. Quit!
He did start with "With that said, I have to disagree with the article rather vehemently." and I wanted to add my $0.02 to a few of his points :) I think the original "MicroPHP Manifesto" could have been clearer about assumptions, but that just because something doesn't explicitly state every assumption doesn't make it fallacious. That's all I was driving at. It was deliberately terse in its "manifesto" list, but the intent was clear enough to an experienced developer.
Why would you think you might be "downvoted to hell" for a completely reasonable suggestion that you then backed up with a well thought out reason?
I think this was a good point well made. People seem really touchy about the subject though. Not sure why - I feel like a lot of people find big frameworks frustrating and give up on them too quickly before they see what they're really good at.
It's a bug in the code that no one's fixed because honestly it's quite funny. But no, that's not what's actually supposed to be shown.
I understand, no worries. Don't bother going to other websites - the information is usually going to be incorrect/not best practices/out of date - read through the official docs, ask in the IRC channel. The core devs are almost always online and from the months I've been there, always happy to help out. If you come into the channel we'll even get on you to move away from the default shipped structure and try to get you guys on a true MVVM structure, particularly using KOstache!
Learn a new piece of technology.
I currently use Kohana in production, and I've used Cake, Symphony, and CodeIgniter in the past. Kohana is by far my favorite. It's much lighter than the others and very flexible.. and I personally find it really intuitive. I agree that the documentation isn't that great, but just read the entire documentation library, and then look through the Kohana code if you still have questions; it's definitely a learning experience.
&gt;try learning a language other than PHP This isn't just good advice, it's *required* if you want to excel as a programmer. Not that you have to give up PHP, but more tools in the toolbox is never a bad thing.
&gt; I want less code, not more I want to *write* less code...
http://www.php.net/manual/en/intro.yaf.php
you are just lazy ;).
Check out [Silex](http://silex.sensiolabs.org/) for a micro framework that is built upon Symfony2 components.
The developer has just released the first 'stable' version (it's been very usable right from alpha). And I thought I'd try and get him some recognition. It's certainly well deserved! Phake is designed as a replacement for PHPUnit's built-in mock objects. They are SO much nicer to work with. I've been using this at work for a while now, and I could never go back to the default mocking system.
Most programmers seem really touchy whenever you suggest their method may not be ideal but that they're just using it because they think it's ideal. I walk away from solving a lot of problems thinking "there's no way that was ideal, but without having to learn x,y,z it's best for the time constraint." For being problem solvers programmers really are a bunch of stubborn bastards. I've ended up completely ditching a couple of months of worth of code because a project changed focus mid-development and it made us start over at the base design of what the web app had to accomplish. We scrapped the framework, all of the customization, all of the code built on it, and just started over fresh. And now a full year since v.1 I thank the stars I pushed for that, otherwise we'd still be in there trying to hack stuff onto a micro framework that couldn't support what has turned into a major business critical webapp instead of easily being able to add on functions and systems as needed. I love your bit about using the language as just a syntax. Programmers that don't solve the problem logically and then in the language seem to always struggle with what should be otherwise simple ideas. I had a professor in college who would start the class often by saying "I saw in your emails that a lot of you are having trouble getting your programs working. They don't work because you didn't solve the problem first, you tried to fit the problem into what you know how to program. You need to put the logic into a program. The program is just the last step in solving the problem, the implementation." And then would hold up a pen and say "Start here." He was a crap professor, but I have found that to be one of the truest things I learned.
I'm not sure I agree with the specific examples in the "MicroPHP Manifesto" (which is [here](http://funkatron.com/posts/the-microphp-manifesto.html) by the way), but I do think many programmers have a habit of over-using OO programming and even creating tons of functions when they aren't necessary. If your script only executes a piece of code once, turning that code into a separate function or an object method just adds unneeded complexity. For example, I just spent a couple hours extracting the actual nuts and bolts working code out of a portion of the Amazon Web Services API scripts. It was a disastrous mess of unnecessary abstraction of every single little bit of code. After you trace through a maze a dozen scripts, about that many classes, and probably 50 to 100 methods, it turns out the actual code to perform the same purpose can be written in about 20 lines of concise simple code. Finally after hours of work, it's finally obvious how the code actually works, and it's far easier to maintain and faster to execute than the obfuscated mess that someone created in an attempt to conform to their idea of good programming. There are situations where classes and functions make sense and help with code re-use, organization, etc. But as with all good things, there is an extreme where it does more harm than good.
I think where he differs is in the last paragraph.
People just really don't want to be told they're using the wrong tool for the job - whether that advice is sound, or not.
If you read the entire thread you'd see he's actually saying "your assumptions are wrong". He's basically saying that when you revisit your assumptions you'll see that they're wrong, because $famous_person said so.
Your story about your professor and the pen is exactly like mine, and so true. My high school comp sci teacher made us do almost all our work on paper, or together on the chalk board. All tests were hand-written (pseudocode was allowed). We did have assignments on the computers of course, but paper came first. You had to demonstrate you could reason your way through the problem. I've kept that lesson to this day and while I can transfer to thinking directly with the computer, I also keep a notebook everywhere I go so I can work on things even if I don't have a computer nearby :)
Sorry, but this is totally unnecessary. You can cast a stdClass to arrays and vice-versa &lt;?php echo '&lt;pre&gt;'; $init = new stdClass; // Add some test data $init-&gt;foo = "Test data"; $init-&gt;bar = new stdClass; $init-&gt;bar-&gt;baaz = "Testing"; $init-&gt;bar-&gt;fooz = new stdClass; $init-&gt;bar-&gt;fooz-&gt;baz = "Testing again"; $init-&gt;foox = "Just test"; $init = (array)$init; print_r($init); $init = (object)$init; print_r($init);
My problem with micro frameworks that I've run into is that a lot of them are making you do more work. I.e. You have to create all the routes and/or you have to include main framework code in each page. On another note, I have problems with newer frameworks. ORMs being one issue and the other one is the use of PHP 5.3's namespacing. A good file structure and autoloader has proven itself (to me at least) to be a lot better than name spacing. 
Why not give the user a dropdown instead?
Why has no one replied to this?? To be fair, most people don't need to worry about it. That includes myself. My pages get built in less than 300ms, and run off a single server. I guess nothing I have made has been popular enough. But when you're running 1000s of servers, a 20% improvement in execution could mean 200 servers are not needed! I've had it running in an Ubuntu virtual box, just to play about with and here are a few notes on my experience: Make sure you have plenty of RAM, I only managed to get it working when I assigned my virtual machine 2GB. The instructions provided for even the latest edition of Ubuntu do not work, or they didn't for me. You have to patch some libraries before you build HipHop, but the versions they specified don't seen to accept the patches... Keep trying different versions until it patches and then try compiling again. It produces a single binary, as well as some additional resources which seemed to break the instance when deleted. It also has a built in HTTP server, but I'm not sure how comfortable I would feel running this public facing. Maybe Facebook have a separate layer that forwards the requests back to the executables built in server. If you have the time I suggest you have a play. It produces some fairly interesting C++ files... which really shows what PHP has to do to handle peoples loosely typed code. Have fun :)
Came here to say this. Learn Ruby/Rails, or Python. You'll have lots of fun and pick up a useful new skill.
There is so much wrong with this I don't know where to start.
Can you cite something to back up this claim? I've never heard of this argument before. Literally *everything* I've read about factories is that they are interface-driven.
You should probably have a user_types table and have a user_type_id in your user table. This is the correct way to handle saving values that may change frequently
This is a much better answer than the two above it. If someone inputs 20 URLs then you gotta search for them in the database which seems like a lot of overhead, even with an index (plus the query itself will be very long).
If you're just tinkering/learning, and not doing anything "real" with it, then just don't update. Code still works, after all.
I was really hoping that this was a framework that made fun of other frameworks. I am dissapoint.
Look into role based acl. 
I've come across this issue so many times. I've used relations for types in my DB, and experienced the pains that come with it. I also used mysql enums in the main table, and saw the obvious issues with managing change on this. Finally I settled on the solution similar to Sothatshowyou just mentioned. I think using class constants is the way to go. It means your not bloating your DB with a bunch of data fixtures. You can store it as an integer in your DB (nice and light), you can control it at the code level, and adding new values is a snitch. something along the lines of... class User { const TYPE_ACTIVE = 1; const TYPE_DISABLED = 2; const TYPE_DELETED = 3; public static $typeData = array( self::TYPE_ACTIVE =&gt; 'Active', self::TYPE_DISABLED =&gt; 'Disabled', self::TYPE_DELETED =&gt; 'Deleted' ); } then you can access the 'string' value by using the message array in your views... echo User::typeData[$myId]; And just using the constant values when constructing your user objects $user-&gt;setType(User::TYPE_ACTIVE); 
Ugh, I hate github links. Why not link to the documentation introduction? [Introduction to Phake](http://phake.digitalsandwich.com/docs/html/preface.html)
You were yelled at not because it is simply taboo, but because it is a bad idea to use it. With the known non-safety of the various escape functions, everyone should stay away from the old mysql_ functions... PDO (and other DB abstractions) provide for a way to prepare statements, removing any chance of error on your part and avoiding SQL injection completely.
Send the start time in a variable via PHP. Then, depending on where you need to calculate the difference, javascript can work to calculate at the time of submit click or on the server when the server side php runs. You would just pass the start time value in a hidden (or not) control.
How can I do that? Can you show me in code? This is my first time doing PHP, it's for school work and I'm stuck at this one.
I won't do your homework but I will tell you to check out php's date() function, php echo, as well as html inputs and forms. With php, you can "build" the html page with any value out of php. Then, as long as it is in an html form, it will submit back to your php server. You should be able to find numerous examples for this sort of thing on the Internet; Google is your friend! Sorry to be so vague but again I'm not comfortable doing someone's school work!
Thanks! I found it in a heartbeat at this site. [This is essentially what I was after](http://us.php.net/manual/en/langref.php) ...and now I feel really stupid about all the time I spent googling this...
 &lt;form method="get"&gt; &lt;input type="text" name="odgovor"/&gt; &lt;?php $outputed=time(); ?&gt; &lt;input type="submit" value="Ok" /&gt; Is this what you mean? How do i know when the form gets back?
Check out the nr 1 answer: http://stackoverflow.com/questions/61401/hidden-features-of-php/1024914 ;-)
if you just had a php file called like someform.php with this in: &lt;?php //if the form has been submitted if(!empty($_POST['submit'])){ //calcuate the time taken $timeTaken = time() - $_POST['created_ts']; //output it (obviously you could do whatever you want with the time echo "It took $timeTaken seconds to complete the form"; } ?&gt; &lt;form method="post" action="someform.php"&gt; &lt;input type="text" name="odgovor"/&gt; &lt;input type="hidden" name="created_ts" value="&lt;?php echo time();?&gt;" /&gt; &lt;input type="submit" value="Ok" name="submit"/&gt; &lt;/form&gt; It would echo the time elapsed between creation and submission each time someone submits the form.
You should learn it in PHP and then move to frameworks. 
That's because you're not thinking the OO way yet. * You wouldn't do object casting when changing the user type, you'd reload the object after saving it and overwrite the old instance entirely. * The model class is usually subclassed by whatever your model is. So AdminUser extends User, User extends YourORM. * Limit loading of models to a specific directory that contains models. Realistically, you should be organising your project folders anyway. Building a full-on ORM is a tall order, so if you want to save time I'd suggest having a look at [phpActiverecord](http://www.phpactiverecord.org/), [Propel](http://www.propelorm.org/), or [Doctrine](http://www.doctrine-project.org/). It will make this process a whole lot easier for you and make database interactions dead simple. A lot of people have mixed opinions about ORMs. However, if you're careful about what you allow it to do and take over manual control when it's necessary to optimise for performance, they can be used to great advantage.
google for the manual or API whenever you are using a new language or library.
I love small scripts as much as the next person, but I can't help but feel its cheating when you remove spacing to achieve that figure. $s="SELECT*FROM"; Apart from that, nice job 
I assumed getUserTypes() was going to do something with table metadata to parse through possible enum values in his proposed change. I meant for him to use tables as he is now. The "this" in my last sentence is totally ambiguous. Sorry! 
Yes, this is quite an abomination. However, it's always neat to see people push the limits of languages using codegolf. 1kb is less than most site cookies and close to 1,000 times smaller than total page size of so many sites that have almost 1mb of assets and JavaScript includes.
^This ... you will never truly understand it if you don't know how it works on the basic level. The frameworks are great and all but you will one day find your self in a jam that the framework cant help you with.
The sane answer is "make an abstract factory." function makeUserType($fromString) { switch ($fromString) { case 'soldier': return new userSoldier(... }} Or you could dive into language features, ORM libraries and other such over-complicated unnecessary answers.
That's people misremembering the advice other people gave. MySQL module is deprecated in favor of MySQLi (mysql improved.) There's nothing wrong with a native module - indeed, unless you're angling for backend portability, it's important that you do. Just use the current one. 
Yeah, that's not about MySQL vs PDO, that's about MySQL vs MySQLi. PDO does not significantly improve on MySQLi for safety in any way, strips quite a bit of important functionality, makes several important tools unavailable, and is ***dramatically*** slower. PDO is a good choice if you need backend portability and can't work in ANSI SQL. Under other circumstances it is not a good choice.
Sounds interesting. Do you has GitHubs?
Can I just take the time to say, I do NOT give a SHIT whether your script is 1kb, 2kb or 10kb, or 1mb. Thus I feel your need to advertise the script with such only speaks to the fact that it doesn't have anything else to say about itself. Lastly, why the heck are you still using mysql_ functions and strip_slashes ? 
I've learned quite a few ORMs, actually. None of them are simpler than a single switch. When you respond to other people's opinions by making up stories about what they do and do not know...
Then you should already know that an ORM makes these things dead simple.
Because using PHP PDO will likely result in more code for the script and, as is obvious, they're trying to reduce it as much as possible.
Sure, you'd use GMP if you were doing addition on extremely large numbers. Just like you'd use an ORM if you wanted to efficiently build something like this without reinventing the wheel.
That's... not how you do it. You shouldn't be building your query using string concatenation. That's a really bad idea. I don't know what to say beyond that.
&gt;I guess I aimed too high. Perhaps you should refer yourself to the reddiquette lesson you privately messaged me. Honestly, the GMP example was stupid to begin with, but I'll humor you. Yes, GMP is useful when dealing with really large numbers of unknown/extreme precision. You're right, you shouldn't use it all the time, particularly if you're doing several thousand operations - it can get rather slow. In those cases it might be better to use a logarithmic scale. I guess I aimed too high hoping you'd just realise this. You won't be doing several thousand calls to a database on a page load, so I fail to see what exactly it is that you're getting at. An ORM does greatly simplify *the whole process*, not just the little part he's doing. I'm sorry you don't agree with that, but I feel it would benefit him in a lot more areas than just the one.
You clearly don't understand the concept of prepared statements, so let's start off by explaining it to you. Prepared statements is a technique which is immune from SQL injection. It works by preparing a SQL string, marking out the places in the SQL query which you wish to inject data into, and is then sent to the DBMS and compiled. You then send the data which is bound to the "slots" you've marked out. Because the query is already compiled, you cannot do any SQL injections because there's no SQL query to inject into. Now, what is it you're trying to do?
I can't help it but associate this with the recent post on MicroPHP. This I think shows pretty well that small doesn't mean good. (I know this isn't what this is about at all, but still that's the first thing I though of.)
&gt;I don't really want to watch you intentionally fail to understand simple things. The irony. Well, have fun with the rest of your day. This conversation is going nowhere fast.
&gt; The irony. Irony is what most people think is called "sarcasm." It can't happen by accident. http://rhetoric.byu.edu/figures/i/irony.htm &gt; Well, have fun with the rest of your day You too.
Should you? Probably. Can you? Depends. If you have the time and the older site can run while being ignored during a complete rewrite then it can pay off for you in the long run. So do you both have the luxury of time and the luxury of a site you can ignore? You may also benefit from refactoring bits or specific code with the question "Can I make this new code work to improve future refactorings?" I've never moved a site to a new framework a piece at a time only as a complete rewrite so I'd think this would mean you'd still end up with a site that isn't run with Yii but is refactored to follow MVC and other design patterns. Of course, I don't know Yii and don't know how modular it is so there is still the chance you can still do this a part at a time and end up with a site running Yii. I believe [Symfony](http://www.symfony-project.org/) is very modular as is [Zend](http://framework.zend.com/). Since it's a hot button topic I would be remiss to not mention microframework options. Getting the 'C' worked in with [GluePHP](http://gluephp.com/) might clean up enough that it makes the rest of the site manageable or working with [Slim](http://www.slimframework.com/), [Limonade](http://www.limonade-php.net/) each offering slightly more than GluePHP. You don't need a framework for manageable code and my opinion would be to refactor bits of code or drop in replacements with modules/components from a major framework. If you're gung-ho about using a framework it's your site and you make the calls at the end of the day.
I only run a Linux server for myself, but I'm one of those crazy Gentoo users. Nothing like recompiling PHP to add PDO support for sqlite :)
Sometimes just seeing what direction a site is heading in, is enough to declare it "broke". If it is heading for the precipice and it does not yet have wings...
Disclaimer: I am not a PHP Pro. There's nothing wrong with just improving your native code, too. Clean up the mess a little bit and carry on. You might learn a lot in the process, and if you really apply yourself, you should end up with something cleaner, faster, possibly more scalable, and more familiar to you than a massive framework. Frameworks are really useful for rapid development and deployment. They *can* also be useful as foundations to port sites over to - Perhaps the routing system would make maintenance easier for you, or you really want Symfony 2's Bundles and Twig integration for specific functionality and easier view templating. But unless you have a very clear and specific reason for porting to a framework, I don't think it makes sense. I feel like the recent explosion in popularity of frameworks has distracted people a bit from focusing on writing plain old code. Kind of like jQuery distracted a lot of people from writing Javascript without jQuery. jQuery is rad, but not always essential at all. Depending on the size of your site - I've been using [Silex](http://silex.sensiolabs.org/) lately for fun, and I have to say, it's a pretty great microframework. It's very simple to implement it in an MVC architecture, and the backbone it provides to your application is actually very useful and extendable. Maybe that would be a good mix between sticking with native php and moving to a framework. Silex still leaves a lot of the coding up to you, and it utilizes the core components of Symfony 2 which are, in popular opinion, pretty solid, modern, and well built. Then again, if you expect your site to continue growing, it may make more sense to just jump to Symfony 2 (Or whichever framework. There must be 10 I can list off the top of my head that are generally awesome).
Well, just off the top of my head... * Creation of mocks is simplified, just need class name and arguments. * No need to decide up front which methods will be stubbed. * No need for special method to mock abstract classes. * Stubbing is also simplified, and can be done at any time. No need to know which methods you want to stub up front. * No more confusing failures when you've stubbed a method but forgot to include it in the list of stubbed methods. * You can be more DRY by creating a generic mock in your `setUp()` and customising it further in each test. * Stubbing and verification of method calls are separated. * Verify method calls without actually changing their behaviour. * Stub methods without actually requiring them to be called in order for the tests to pass. Useful if you're creating a generic mock for use in multiple tests. * It is possible to use an `identicalTo()` type argument matcher in your verifications. PHPUnit can't do this because it clones everything for some reason. I'm sure there's more, but I can't think of anything else right now, so I'll just finish with two equivalent mock setups: **PHPUnit** $mock = $this-&gt;getMock('class' , array('fooMethod', 'barMethod', 'bazMethod') , array('argument', 'argument') ); $mock -&gt;expects($this-&gt;once()) -&gt;method('fooMethod') -&gt;with('argument') -&gt;will($this-&gt;returnValue('result')) ; $mock -&gt;expects($this-&gt;once()) -&gt;method('barMethod') -&gt;with('argument') -&gt;will($this-&gt;returnValue('result')) ; $mock -&gt;expects($this-&gt;exactly(3)) -&gt;method('bazMethod') -&gt;with('argument') -&gt;will($this-&gt;returnValue('result')) ; // code under test goes here... **Phake** $mock = Phake::partialMock('class', 'argument', 'argument'); Phake::when($mock)-&gt;fooMethod('argument')-&gt;thenReturn('result'); Phake::when($mock)-&gt;barMethod('argument')-&gt;thenReturn('result'); Phake::when($mock)-&gt;bazMethod('argument')-&gt;thenReturn('result'); // code under test goes here... Phake::verify($mock)-&gt;fooMethod('argument'); Phake::verify($mock)-&gt;barMethod('argument'); Phake::verify($mock, Phake::times(3))-&gt;bazMethod('argument'); I think the above kinda speaks for itself, but really, in addition to all of this, I haven't found one single situation where I prefer PHPUnit's way over Phake's.
Yes, but how does the table look like?
thank you!
Bulletin board. These things are called bulletin boards. Forums are the ones with a tree structure, like reddit.
You mean the direction of being profitable? I hate it when websites do that.
Sorry, someone who is running a lucrative website is experienced, not inexperienced. inexperienced doesn't mean "disagrees with you".
I've read quite a few posts of using Zend Framework and moving your site over script by script. You could start out with just a light controller and slowly convert your whole site while live. 
I would. If I had a large list of features I want to build for a site that's poorly coded and which I'd likely have to do hacks and workaround to build those features in, I'd start again on a framework. Developers would also find it much easier to "pick up and go" with a framework where you've followed good code practices rather than code written by someone with little PHP knowledge. I've had great experiences with CodeIgniter as a framework, but obviously it's not the only one.
I dislike using frameworks, i feel like it's something extra to learn and work within that i don't want to do. i've written my largest project w/o a framework, and yes it was significantly more work, but i know all the code inside out. when i first wrote it there was no object oriented code, last year i did a full rewrite and implemented a full object oriented system. it's not running on pdo yet, because i was using a version of xampp for local development and that version had a PDO bug that prevented it from working. i've since upgraded but i haven't had a chance to rewrite that section and i'm fairly busy working on new stuff that i can't afford to go back and work on it now. to answer your question, i'm happy doing it my way, but if you're used to using frameworks or prefer the idea of having certain things done for you. then a framework is probably a good idea. i have used css frameworks and i find that having certain things pre-defined for me makes my job infinitely easier. so when trying to rapid develop a layout i will using a css framework.
I would love to get into Django/Python. Learning a new language, learning a framework from that language and then completely rewriting my site in it seems far too daunting. At least with a php framework I imagine I'll be able to port over a decent amount of code.
Is CodeIgniter more for 'simple' sites? Picture my site like pricegrabber.com (though far smaller obviously). Do you think you could build a scaled down version of pricegrabber in CodeIgniter?
Thank you for this.
What does your consumption look like (cpu/memory) when you run a tool like `htop`? How about IO using `bmon`? Forgive me if I'm wrong, but it doesn't sound like you are actually checking your resource consumption...
We've made the rounds on visualization packages, through amcharts, open flash charts, flot, jqplot, protovis, and finally settled on D3. However, I'd say you still need to worry about sending that much data to the browser - you're talking upwards of 250K datapoints there. It might make sense to do some fancy groupings and then allow the user to drill-down on zoom, rather than trying to squeeze in the whole thing at once.
Sadly no github yet. Haven't yet even gotten too far on mocking but I do have a working unit test framework with code coverage support. It does less than PHPUnit and PHPCodeCoverage but it's also a fraction of the size. 
I have to second this statement... You have really given us a slice of the information needed to solve this. How many active nginx threads are running when you are doing only 8 to 10 requests per second. What is the consumption of memory / cpu / io / context vs switches on the machine at this time. You have to take some considerations into account. If you have mysql, nginx, and php-fpm all running on this machine, with only 4gb of ram, your system breakdown most likely looks like the following. 1GB for basic system services, to keep that sucker running, you could maybe say 768MB, but anything less and you are swapping. 1GB for MySQL, it needs some memory, otherwise every request its going to disk. 1GB for nginx, depending on number of workers / threads you have running here and what its caching, this could be consumed in almost no time. Leaving you 1GB for php-fpm processes... and depending on how much ram each fpm spawn can consume, that could go rather quickly. Letting php consume 64mb because it may have to deal with a large dataset isn't unheard of, even higher than that can be found. Ultimately what I'm trying to get across is that you need to more finely investigate your server to find out why its going to a crawl. Use some graphing program like munin or cacti or ganglia or something else... You could use dstat to help troubleshoot as well, its very handy.
Sounds like a good start. As soon as I can move away from PHPUnit I'm doing so. It could certainly be done better, but the worst thing is the developer's "I don't understand why anyone would want this" attitude to feature requests. I'm over it. I was semi-serious about writing a testing framework also. I had the idea to write one where the tests are actually run in a separate process, so as to catch fatal errors and report them as failures, rather than just exiting like PHPUnit does.
varnish not going to solve your logged in user's problem. Maybe it's time to try module throttling, or start enabling profiling (e.g. xdebug) for a while to identify the culprit. nginx's $upstream_response_time would be useful in the logs if you can add another layer to get nginx to load balance. You can track down which pages are the ones taking the longest that way.
PHPUnit can spawn a separate process mode for tests (the @runInSeparateProcess annotation). You could run all tests in a separate process -- if you design it that way from the start, you might end up with something cleaner -- but there is a performance penalty for that. In my code base, fatal errors are so rare (and so critical) I don't mind the entire thing going down when one is encountered. I looked at many features of PHPUnit and decided they weren't really necessary. I'm also trying to avoid using things that PHP doesn't directly support, like annotations. I felt like PHPUnit borrows too many design ideas from JUnit and doesn't take advantage of PHP features. 
It's disgusting, and insecure. Everything I've come to expect. Aside from the complete lack of escaping, the use of extract() is beyond terrible. You just need an eval() and the unholy trinity will be complete.
Rewriting your code is top on this list of things Joel Spolsky thinks [you should never do](http://www.joelonsoftware.com/articles/fog0000000069.html). My recommendation is pick a framework and a find a way to slowly integrate it into the site you already have. If you attempt a complete rewrite you'll be at it forever, it's not rewarding, and your site will stagnate during the process. 
Can you please elaborate more on why should he/we stay away from ... codeigniter, i've been learning oop and CI at the same time and i think i'm making a huge progress.
I ran into similar problems using PHPFPM. I'd highly suggest running a trial of apache with mod_php for the drupal stuff. PHPFPM is still considered experimental for a reason, and it barfs without throwing errors sometimes. Your hardware is MORE than adequate for only 80k a day. How large are your datasets? Is the static content you are serving cached pages, or static files? EDIT: apparently phpfpm is no longer marked as experimental as of late November. I still wouldn't use it for a production site though. I've run into too many weird problems with it.
So this might get down voted because we are in /r/php and I'd like preface this with saying my paycheck comes from coding php. I wouldn't just hold yourself to php frameworks. Rails or Django might be a better fit. My reasoning is I also like MVC frameworks but I've found php's to be very frustrating. I think that is because as a language we, PHP, haven't really rallyed behind one framework. Of coarse this all depends on if you can easily switch to coding in python or ruby. But honestly once you know one programing language the others because a whole lot easier to learn.
Convert your format to RRDtool and use [Cacti](http://www.cacti.net/) It is designed exactly for this. It's also written in PHP.
If it's money making you need to think of this as a business not a website. Sure you know it is a mess but if that is working then you need to tread carefully. Definitely explore new technology, replace part of your site with the new stuff and once it is working OK migrate bit by bit over (if that's feasible) - it is very easy to cock things up doing a full replacement in one go. 
If you can remember where you found any of these and link to them, that would be great.
Try to create a stripped down version of your site in Django/whatever and see if it really is that much work to port it. When I port or rewrite something I am usually much faster done anyway.
I'm currently using CodeIgniter for an enterprise application and i would have to say that it's not really that great. I think that using something like Symphony and only use what you need would be much smarter since later when you do decide to scale out in a huge way you won't feel the need to re-invent many highly customized modules. Just my 2 cents. 
I've never seen so many security holes in 1kB.
creating code that endangers your server and database is an accomplishment.
And it has better double, triple click selection and rectangular block selection: http://wiki.netbeans.org/NewAndNoteworthyNB71#Double.2FTriple_Click_Selection_Improvements
go for it. Python is a great language to learn for beginners.
This is why implementation of this size don't use frameworks like drupal.
OK... Firstly, the mini-zuckerberg said he NEVER uses frameworks. To my mind, that makes his advice regarding frameworks relatively useless. Frameworks are great for certain things and I can't imagine why anyone would NEVER use them. If he doesn't use them, he's not aware of the benefits they provide. Secondly - if it's not broke don't fix it. DEFINITELY agree with this. Your site is working and making money.. why change it? Well.. you've given two good reasons: 1) At this point the site has become too complex for me to handle alone any more and there is a long list of things I want built for it 2) The backend is a mess. My files are still Dreamweaver templates. Undoubtedly, if you're thinking of bringing other coders into the project, this will be a much more painless process if your code is well laid out and easy to understand, rather than a bunch of spaghetti. The benefits of good programming practices multiply exponentially when working on a team, and even more so when bringing in contractors/freelancers. I work as a freelancer and some of the projects I have worked on end up costing a lot for simple changes because of all the spaghetti I have to unravel. A well laid out codebase means I can get straight to the actual work.. If you can avoid starting again from scratch, all the better - maybe refactor it piece by piece if that's at all possible?
For PHP we use Agavi: http://www.agavi.org/ It's a bit of a steep learning curve, but once you get it, you'll like the strict MVC appraoch and discover a lot of nice things. It forces you to do certain things (like validation) while giving you as a developer enough freedom to always handle things differently in case you really need to. The routing and output types related features are really powerful esp. if you need to migrate a site one part after another. I never had the feeling that I had to work against the framework. :-) A viable alternative is of course Symfony2 which is not surprising as both frameworks basically originated from the same project (Mojavi).
Yes but did those problems occur when you were using it while it was marked as experimental?
What is why? Do you know what is causing the problem? No? Then how can you say what people shouldn't be doing?
This isn't your problem but just to verify since you didn't list it, you should be sure to make sure your nginx has worker_processes set to 4 if you're running a 4 core system. I'd look into your database while this is happening, turn on slow query logs. If mysql is doing complicated queries it can back up very badly and php processes wanting to query the database will start queueing up, you'll fill your max children allotment and you'll get 50x errors. A huge help is to use nginx's (or other) reverse proxy/fast cgi cache if your website content allows. Most sites don't have a large number of users logged in at any point and the rest are being served up the same pages over and over. Caching even for a couple minutes can dramatically reduce the load on your servers. I'd be willing to bet that it is database related. I'll have to see if I still have those in my logs, but when stress testing one of my apps recently and started randomly seeing 50x errors, I vaguely remember getting that error, and it was just when I was testing against an unreasonable number of requests at a single time. Not sure the exact numbers, but it was several hundred concurrent connections. If the time it takes to complete a request takes longer than 100ms (at peak 10 users/second = 1000ms/10 = 100ms), you're going to slowly (or not) build up lagging PHP processes until it won't be accepting any more. That is why I say using caching, you'll be able to read a cached response and start serving it back to users in &lt;5ms.
http://us3.php.net/traits
I would convert it. Most of the coding you did in your site is the same for all the websites, so the framework will have it from scratch. It could be a step back at the beggining because you gonna invest time in rewriting code you alrady have working, but at the end its gonna be a huge step fordward. Your code will be cleaner, more maintainable and a lot more fun to work with it. It will help you in the SEO by giving the site the speed that I dont think you could get by yourself. I would recommend Synfony2 because is he only one based in PHP 5.3 providing the performance boost this version has. And many other importants things.
I don't see why you should not rewrite something, especially if it's a side project without any hard deadlines. I'd suggest to develop the new version while still making sure your old one runs fine (don't sacrifice maintenance of V1 for development of V2). Once you're comfortable that V2 is stable, replace it and feel proud of the work you did.
I wonder if they finally fixed the "foobar"" problem that I've had for over a year now (at this point I just automatically fix it and continue as Netbeans is far away the nicest PHP IDE I've used). edit: NOPE
Good old CodeIgniter has never let me down. Some clients have hosting companies who aren't yet on PHP 5.3 so it fits every bill and the community is large and very active. I've automated it by writing my own bash scripts, but if you want something with automation built in, Yii or Fuel seem best from my limited experience.
I agree with this as well. For example, every Zend Let's you cherry pick any component you would like to use in your system. Need a login? Check out Zend_Auth, Zend_Seasion, and Zend_Acl. Codeignighter also works in a similar fashion. If you do choose to integrate a framework I suggest you choose one that does let you use it's components outside of whatever that frameworks suggested application structure is. If you have any questions feel free to message me!
that's why we have versioning repos
You just gotta make sure you don't pull a digg v4.
Two cents are worth an upvote around here :/ Have mine.
We use CI/EE for most client projects these days.
I agree completely - there's no magic bullet solution. I'd also add Symfony has been my primary goto [sic] for most things these days, as I find Cake and Zend clunky by comparison. However, for a lot of projects, you don't have to work from scratch; using instead Joomla, Drupal, or Wordpress is usually a good place to begin, as there's often a plugin to do 80% of what you need already (better profit margins, there).
The "best" developers (from a company perspective) are the ones who can deliver quality code in a short amount of time. When you're talking basic BREAD interfaces using a Framework that has ORM, a templating engine, etc...Google is all you need (if you're proficient enough as a programmer). If you're a PHP developer who has never used a framework, then you probably just aren't the applicant this guy is looking for. 
Frameworks are intrinsically inefficient. You trade convenience for speed. Do you really think facebook would work on a "framework"?
I think you should probably be more upset about me using a goto. ;P
This makes perfect sense. I can simply pass an array of data and a resolution to a function and have it return the processed data for plotting. Thanks for the pointer.
My last big project was the rewriting of something old from scratch and all I can tell is that it's a pain and dangerous. Entropy is everywhere, everything need some attention from time to time. I loved the plant metaphor btw. Start giving it some attention, fixing bugs here and there and at some point you'll see what's needed. Maybe a framework for this part, maybe a switch to PDO to prevent some potential SQL injections, maybe hashing the passwords using bcrypt, … Going the “what we have is outdated let's redo everything” road is so much trouble that you won't catch me doing it again.
I'm talking about the model associations/relationships when I say automatic, also access to the database and stuff is something you don't even need to think about - just put in the credentials and it's all accessible in your model. In Zend you instantiate some class to get a DB connection, and I'm finding this code in every model as every model needs the db connection! (note I would personally make an abstract model to do this automagically, but alas this is an agency and it'd be a waste of time to rewrite all this code). It seems in Zend I can't even fart without having to write $fart = new Application_Fart(new Application_Fart_Adaptor_Gas($ingredients));. It's only been about 6 weeks with Zend, I need to give it more of a chance, do you know of any examples of a well-formed ZF app?
What we did at work was slowly transition. First added an orm then started using it. Then getting old code to use it. Then templates then added controllers. We kept building up until we had made everything part of a framework.
Add a comment to the relevant bug report :) http://netbeans.org/bugzilla/show_bug.cgi?id=206329
Umm... "By Ondrej Brejla on Aug 18, 2011"
the most useful think I found in moving fr 6.x to 7.x was that it finally understood the alternaive :/end syntax e.g. foreach($a as $b): endforeach; or if you're feeling a bit crazy switch(TRUE): case 1: break; endswitch;
Just because it's not marked "experimental" doesn't mean it is stable. And we're assuming he's using a release candidate version of php, which shouldn't be used in prod either. In the mainstream version it's still experimental.
Oh true, I misunderstood, I thought you were saying the latest PHP production PHP release had a non experimental version in it. I am still running apache/mod_php. Upvote for learning something.
Interesting reading this as a person who is planning to start looking for a new job shortly. I've got to say I agree and hope that interviewers I encoutner take the same approach. Somewhat related: How do you feel about people listing a github profile on their CV when applying for an interview? Do you think you would check it? If so what would you be looking for?
This doesn't belong in this subreddit.
I always like to ask, what are your top 3 activities. Here's why... I want programming to be on there, but then I want two things that have nothing to do with programming. I want people that are varied in their interests and able to being in different view points. I also don't want people that will sit in the corner and not socialize with the group. Meeting up at the corner pub for a drink is always a good way to hash out issues.
start here: http://geolite.maxmind.com/download/geoip/api/php/README
I gave your comments some thought and I would like to give you a better rebuttal to your points: First, just let me say that I liked CakePHP when I used it. I think there's some really great ideas in there and its painlessly easy to build a CakePHP app and the changes in CakePHP 2.0 seem to be a huge step forward, although I have admittedly not programmed a CakePHP 2.0 app yet. Assuredly, the Cake team is much smarter and more experienced programmers than I. While Cake's models allow you to include data validation and you should be making fat models/skinny controllers the concept of a Model in Cake is absolutely nothing like the Model I envision for SprayFire. Simply because the Model holds data validation and has some abstraction from a database doesn't mean the 2 are the same. In the context of accessing a database, CakePHP's Model is an object representing a singular table in that database. SprayFire's Model is an object that represents the entire database. A simple blog in Cake might have a Post, Comment and User Model. SprayFire would simply have a Blog Model. Instead of linking to and associating with other Models we let the DataMapper handle the task of figuring out the right query associations. Since I have not developed in CakePHP 2.0 yet I will reserve comment on the Response and Request objects.
Just going to mention [Paul Reinheimer's fork of XHProf](https://github.com/preinheimer/xhprof), which mostly improves on the web interface for viewing the results. But it's incredibly useful.
 New Features in PHP Debugger By Ondrej Brejla on Aug 18, 2011 &amp;#3232;\_&amp;#3232;
I once asked for a GitHub profile from a candidate who expressed several qualities that made him a suitable hire. When he sent me the link, all it contained were branches of existing projects, none of which had any commits after the branching. So in that case, it didn't help nor hinder his application, but it was definitely weird.
No problem, I wasn't entirely clear.
That's more related to how github works. You fork a repo and then do some changes in a branch and when it gets merged you can usually safely delete the branch. At least I do it this way.
Indeed, [7.1 is out though](http://blogs.oracle.com/netbeansphp/entry/netbeans_7_1_is_now)
There's a difference between creating publicly accessible code and coding as an academic exercise. People like you are the reason the programming community looks down on PHP.
Thanks.
I've worked on a very similar project to this. A large established site written in "spaghetti code" that was transitioned to a MVC framework. One of the major reasons for undertaking this was that the owner felt the exiting code base would make it difficult to ever sell the business, and I think he was right. I suppose a buyer would like to know they could put developers to work on adding new features without having to spend weeks fixing old crappy code. With this in mind something like Zend would be a great choice. It's well known, it's solid and it will work well with third parties, particularly Amazon for which is has lot of good libraries. It's more involved than CI but it's better suited to large projects.
Then you shouldn't be messing with clients budgets
&gt; SprayFire would simply have a Blog Model. Overall, not good. This is going against the principals of modular design. You're building a tightly coupled design there, and it's not going to bode well for extensibility. What are the advantages of separating each one? Well then, your users can extend functionality over other parts of the application, not only blog posts. Comments could also be made on images or file uploads, as well. If you're saying, "No, well those components will be separate inside the blog model..." well that's much more of a conceptual coupling than one reflected in code. However if you do want to do so, that's what [Cake plugins](http://book.cakephp.org/2.0/en/plugins.html) are for. They mostly just Cake's implementation of HMVC, which sounds like exactly what you are thinking of. A HMVC design doesn't simply have a flat layer of models interconnected, instead it's a nested structure of either models or an entire MVC stack underneath others. In such case, you could have a 'Blog' plugin with all models, relevant controllers and views underneath it, but abstracted from the main Cake MVC app. You also seem to have missed a step in Cake's model design: it's an abstraction over a datasource, not a database. A database just happens to be the most common implementation of a datasource. Others could be twitter, plain files, XML, a RSS feed, etc.
Second this. The webform module alone in drupal is a lifesaver. Put together a typical 8-10 field form with validation in minutes, including (if desired) limiting submissions per user per day/week/whatever, the ability to e-mail responses, or store them in the DB (with the ability to download a csv or xls) later, etc. Honestly, most typical small client sites can be done without writing a _single_ line of code, other than templates/css, which is big if you're trying to crank a site out in a day or two.
I think a big part of it also is PHP's execution model. Throwing away the world on every request is never going to be ideal for an MVC app, compared to something like Django or Rails where the overhead to start handling a request is basically a method call.
I use CodeIgniter and the Session class it comes with: http://codeigniter.com/user_guide/libraries/sessions.html
That's actually pretty similar to what I did to improve what we had before, except that I don't currently have any methods to add data to the session cookie itself. I'll probably do something similar in the future. Thanks for the link!
Check out [Imagick](http://www.php.net/manual/en/book.imagick.php).
I have rolled by own session implementation in one project because PHP's session mechanism locks the session for the entire script run and that causes multiple simultaneous requests to become serialized. This isn't a common problem for most people but it was for me on one project. Although depending on where people call session_start() this could be a bigger issue than most people are aware of. For another project, I have save everything directly to cookies (with some encryption) to avoid any disk access at all. This works well for very small session storage requirements. I even have PHP4 code that predates the existence of the $_SESSION superglobal -- so my own session code had a better API than registering and using global variables for sessions. 
Great article Anthony. In my opinion, you do exactly what should be done in interviews. It seems like too many interviewers (or articles about interviewing) are looking for a gimmick that will find the best candidates.
We used postgres database to store the data, and used the generate_series(start, stop, step interval) function to generate a list of times we want to get. Then join onto that to pull the values, and there's an index on the timestamp so it's fast.
Ah, I see what you mean. I've never encountered a site that actually ran into the issue of simultaneous attempts to write/access the actual file. I have not worked on a lot of high-traffic sites that use the native session mechanism, though.
Sorry, no experience with cpanel unfortunately. If you can find a way to install pear/pecl packages and also find a way to ssh into the machine to download and unpack the geoip .dat database files, you should be good to go. But again, YMMV as I have no experience with managing sites through a cpanel. gl!
At work we just send a random session ID in a cookie. If you want any actual data associated with the session, it goes in a session table in the DB. The only downside I've found is that you have to be careful to clear expired sessions from the table. In other words, what you do, but session data goes in the DB, not the cookies.
I have offered no lame excuses to anything. I point out options that are available. I am a TextMate fan and have no used code-completion since I was a teenager. I write code in PHP, Rails, NodeJS and whatever I need to at the time so there's no chance of me ever remembering everything, so I am never unhappy to quickly look at the documentation.
You can also look at Google's Chart API which might accomplish what you need in less code: http://code.google.com/apis/chart/ 
Is it just you that finds ZF different/difficult or have other people (especially your bosses) in the agency expressed concerns about using the framework? Have you been actually tasked with exploring alternatives to ZF or are you doing this of your own initiative? I've been doing the "agency thing" for over a decade, and I can give you this advice: If you're new there, it's probably a terrible idea to start trying to make or suggest those kinds of changes to established structures and processes at this stage. Make a good name for yourself by being productive and constructive using the existing tools and setups, and then you can start suggesting alternatives once you've been there a while and you have built up some credibility. Otherwise, you risk stepping on the toes of the other developers who have been there longer than you and know more about the internal processes and decisions than you (and may have good reasons and strong opinions for using ZF), and you also risk having management wondering why you're spending time trying to change things that (might) be working fine instead of spending time getting work done. Of course, if someone above you actually asked you to research alternatives, then I'd say do it collaboratively with the other developers. Test the waters of a few of the popular ones (make a blog or a small app to test it out) etc.. 
The bit about working with the dev team and poisonous personalities was spot on. I've built a diversified team from a single developer and with every new iteration the best interactions to gauge a candidate's viability are in off-the-cuff chats with the team outside of the closed-door interview.
Not really looking for a chart API, but it's interesting to note that Google's got this. Thanks.
I think he is giving his clients something they are very happy with.
So far, no, and we use this on a halfway busy site too. If you're really worried about performance, or find that the DB becomes a bottleneck, you could try using the session ID to refer to memcached data. Another thing that might affect performance is how you store session data. You could do up a dedicated column for each piece of data you store, or you could just serialize() something into a single column. You could even end up using multiple tables, though that'd probably be a symptom of bad code. As always, there's not much sense in optimizing until you do some actual profiling.
Twig is a popular substitute. 
hiring developers is very easy. the hard part is keeping devs especially the awesome ones.
Sorry to be a downer, but checkout [Monolog](https://github.com/Seldaek/monolog). It's a PHP5.3 (PSR-0) logger that's simple and abstract.
sure you can just put it in its own folder, like yoursite/blog or give it a subdomain.
I haven't tried executing it but I took a look at the code to figure out how it worked. There is some crazy stuff in there! Taking a closure, serializing the source code of it, passing that to a subprocess, and then unserializing and executing it is both insane and awesome. Is it pretty stable right now? What causes the detached child process of doom? I develop on Windows (but deploy to Linux) so I appreciate the time spent getting it to work in Windows. 
You can make a separate blog easily enough, but it won't have the look-and-feel of the shop. If you want to integrate WP (eg. display the product catalog inside a WP template, or display a blog post in the shop), you'll need a web developer.
Well, you'll need a *Wordpress* developer; people who work with PHP and people who work with Wordpress are less common of camps than you'd expect...
This is a profiler I created, which can profile you code without xdebug or manually adding a single line of profiling code...this is the trace it generates.. http://moduler.pagodabox.com/index.php/trace/lastTrace What do you think?
Uhm... what? WP is written in PHP, any dev worth their hourly should be able to knock out a theme, any WP dev must inherently know PHP. 
Keeping in line with the MicroPHP thinking, I wrote a new logging class today and would love to get some feedback on it in [another r/php thread](http://www.reddit.com/r/PHP/comments/o61x3/feedback_on_my_new_php_53_logging_class_that_uses/). It's 57 lines of code without comments, logs to a file by default, and uses closures to make it extensible.
No and here's why. * PHP itself is already a robust language and while learning the concepts presented in the more popular frameworks is good, you need to understand, from the ground up, why those concepts exist in the first place. * Frameworks are great but they are not the best answer to every situation. * Frameworks are akin to a fish. Give a man a Framework and he'll program for a specific framework. Teach a man to build a framework and he'll have the skills to code for any situation.
The problem with learning a language via a framework is it's difficult, if not impossible to understand what the framework is doing and why. Frameworks have a tendency to do a lot for you, which is good for the experienced programmer, but decidedly bad for the novice. Usually "from the ground up" sort of stuff is better. If you're a complete 100% novice, I'd suggest trying [Zend 101 php for the absolute beginner](http://devzone.zend.com/6/php-101-php-for-the-absolute-beginner/).
Nope. You won't be able to separate the framework from the language clearly enough to differentiate where problems lie; and where the framework ends and the language begins.
Maybe if you use a framework that let's you do a lot of work, yet allows you to separate the html from the php, it's not such a bad idea. 
anyone?
I agree with your first part, building a basic WP theme is actually rather trivial, and integrating dynamic "sidebar" support is incredibly easy for anyone comfortable with PHP, you'd be surprised in how little PHP is actually required to become a WP Theme designer. 
I understand what you're saying now, as in making the distinction between a WP developer and somebody who just designs themes.
Well among other things but yes :)
`$_session` is different to `$_SESSION`; only the latter is a super-global so that's the one you need to be using for this. Other than what I've said above, your code to save $motd is correct. Your first idea of retrieving the data from the session is correct. The latter will not work.
Ah thank you, you have been a super help, as for $_session and $_SESSION, sorry about that, my muck up, it's 3:40 am and my inclination towards case sensitivity is not up to par lol 
I recommend using Memcached. If you have the memcached plugin installed, configuring it to be your session store is very simple, just set edit your php.ini session.save_handler = memcache session.save_path="tcp://host:11211?persistent=1&amp;weight=1" You can do this to all your PHP web servers, and then distribute the load across easily, while retaining the session information. Works beautifully. :)
I think these are good changes. The class seems much cleaner now and implementing an array for the message should make it MUCH easier to implement custom handlers. I think this achieves 90% of the flexibility of the version I wrote in 500% less code so good job. Strategy is a cool pattern but doesn't really lend itself to brevity. Glad I could help!
And avoiding the global, just for this example, showing you can bind it to a var passed into the closure: &lt;?php require 'Analog.php'; $log = ''; class AnalogHandlerVar { public static function init (&amp;$log) { return function ($info) use (&amp;$log) { $log .= vsprintf (Analog::$format, $info); }; } } Analog::handler (AnalogHandlerVar::init ($log)); Analog::log ('foo'); Analog::log ('bar'); echo $log; ?&gt;
I used to work at an ad agency where the developers were expected to work a minimum of 60 hours a week. As time went on, more responsibility was put on me that should've been handled by other management and eventually I quit when it was regular that I'd be doing a 100 hour week every month or more. I now work for a large software company where the management better understands programmers and can manage expectations in a reasonable way. Unlike the ad agency, I'm no longer expected to be billable 8+ hours a day, but instead I get assigned a capacity of 60%: I'm expected to be in the code 60% of my time. I think this is the key difference. My job now takes into account the time that I need for meetings and R&amp;D, etc. It also helps to keep your day job fresh. Talk to your boss about setting up a personal development plan where you can dabble in the new and exciting. Any self-respecting tech company will grant you this time, as they will see it necessary to cultivate your skills; making you more useful. I'm able to get away and get out with a job that has me floating in the low-40's, 50 hours/wk range. Having time for yourself is critical to avoiding burn out. Pick up a simple hobby that doesn't involve computers. Photography is quite popular amongst developers because it exercises the right side of your brain and it gets you outdoors.
I think it's interesting to know the technical way sessions work. When a session is made in php with session_start(), the page sets a cookie on the visitors browser that gives them a unique indentifier to look up their cookie by. For example, I visit facebook.com, and it might set PHPSESS=ca7361fe4319ce213bbac3fe89820 or something else random and impossible to guess like that. Then, using that unique code php can restore the contents of $_SESSION for that specific person each time they revisit the site with the same cookie. The sessions themselves are stored on disk as a file which has data in it that looks similar to the output of a variable that has been ran through serialize(), but they can be stored on the database or in memcache with some tweaks as well if you want to get things complicated. Because the actual contents of the session are stored on the server, you can put things in the session like (user_is_authenticated = true) and trust that the user has not had the ability to manipulate the contents of that variable. Basically, they are secure. Generally, you put the session_start() code somewhere near the top of the script, around where you connect to your database.
You better get it up to par if you want to avoid annoying debugging setbacks...
Ex-lead dev for a fairly prominent agency here. Sorry about the long post, but I want to give you a whole answer... stick with me here. Our company went through a few different phases during my time there. When I joined, we were an agency that other agencies would go to for heavy-lifting development work (read: large/niche application development). We started out using CakePHP, but quickly adopted ZF because we found it more suitable for the work we were doing. When the economy started going south, we stopped getting the big boy custom projects and went to adopt WP and Drupal (with a dash of ExpressionEngine when a client demanded it, my god I hate that platform). I noticed three major changes due to this paradigm shift: 1. Our development time for websites actually went up, instead of down like we wanted. We could scaffold and get the projects to 90% much faster than custom development, but the last 10% would be a grind that usually blew out our hours. 2. Our clients began to complain about usability and quality. We started discovering more edge-case defects, etc. Many of the times it was because we were having to use unproven plugins from unknown developers or extending pre-existing modules. 3. The deployment processes. Oh the humanity! If your agency follows a development -&gt; staging -&gt; production deployment process like ours did, then you'll find that deploying Drupal and Wordpress is a total pain in the ass (Drupal far more so). We had to write migration tools that would manipulate database values just to get sites to run in each environment. Clients would use the staging environments to develop their content, then we would push to production once we were pleased with the aesthetics and usability. In a system like Drupal for example, their node-based architecture makes a process like that extremely difficult since EVERYTHING is a node. If the site has UGC, then you're not having a good day. It takes some pretty crazy migration tools to migrate back-and-forth between the envs. Pro-tip: Clients who are moderately experienced in web -- or larger than mom-and-pop shops -- are going to want a deployment process like the one I mentioned, so it's something to consider carefully. I'm not saying that WP and Drupal are bad, but they weren't a good fit for our agency or our clients. You need to evaluate what your agency holds at value and the type of work you get. One side effect of our framework-to-platform transition was also on-going maintenance. We basically had an unwanted segregation of our development team where some would work on the framework projects and then the rest on the platform projects. That introduced a difficult management problem of knowledge sharing. I probably didn't do a good enough job rotating our developers around projects and when our veterans (including myself) left the company, the agency was shell shocked by a massive loss in technical knowledge. Be wary of a situation like this coming down the line: It's extremely dangerous to an agency's bottom line and the satisfaction of your clients. Another caveat is that agencies don't typically pay developers well compared to a larger software company so you'll be at a disadvantage of finding _good_ developers. Typically you'll get script kiddies or college graduates and the like. That's not a bad thing, but you need to be careful adopting multiple frameworks because they don't always make the most sound technical decisions and in an agency culture, you rarely have time to go back and fix things in many cases because you'll be onto the next thing before you can blink. Having experienced developers is a key deciding factor to choosing framework vs. platform. If your team doesn't have the chops: Don't do frameworks. All that said, if were to do it all again (and it looks like I will be), I would do one of two things: 1. I would adopt a framework that has excellent support for modules and build a CMS framework on top of it that uses static configuration and static content models. A focus on easy deployments and an unobtrusive publishing workflow. If you're up for doing it the Symfony Way(tm), Symfony2 would be a very good choice. If you need a quick-and-dirty for generating leads and press, just do WP and stick to that. Avoid Drupal at all costs (imo). 2. I'd use Django or Rails. Both frameworks (and the languages they're developed with) are very well-suited for agencies, imo... better than PHP and the platforms it provides in some cases. There's always tradeoffs, of course... but they are valid options. Whatever you do, don't introduce a lot of different tools into your development environment or you and your colleagues will pay for it with long nights. If ZF is largely working for your team, I'd say stick with it and identify the points of weakness and address those. It sounds to me like you've got a couple things going on here that you would benefit from learning more about: 1. If automatic is what you're looking for, it's time to learn Zend_Tool and put it to better use. I tend to use Symfony's Console component as a CLI front for Zend_Tool. It works wonderfully for my current team. 2. Conventions? That's what standards and best practices documents are for. Pull your developers together and come up with some standards. This is how we will architect our modules, this is where you put business logic, and so-on. The sooner you can come to an agreement on things, the sooner things will look up. Also: Get a knowledge base set up. We used a wiki at my last agency, but I tend to prefer Google Docs. Don't just change something based on what you "feel" could be a better fit. That's not what a professional developer does: That's amateur hour. It sounds like your agency's biggest problem is that it needs a developer to step forward and introduce organization to your department. I'm not sure a change in technology is necessarily the best course of action at this time. It's not an easy chore you've taken on, so good luck!
Thanks everyone, i really appreciate the help!
Seeing the source would be nice...
Sessions are good. One thing I will point out though is some hosts clear the tmp folder (where sessions are stored by default) of files that have not been touched in x time. This can cause issues when your site has large forms that can take a while to fill out only to submit and be logged out. You can change the directory the sessions are stored in, but then you have to worry about clean up.
True, that would seem nice in theory but in practice most new programmers or tutorials don't get to the point where they can learn about the security ramifications of a certain method. Therefore most users, will copy and paste the code directly into their own application and place it on a live server without a second glance. I wish there was a way to teach new programmers to crawl but not fall down the stairs, walk without hitting walls, and run without tiring.
Well and that's the rub. You are always going to have people just grabbing code from the interwebs and slapping it in. I suppose I should have asked what your end goal is. I believe that the teaching method that I alluded to in my first post would yield a far better programmer, however, those that don't follow it with an instructor would (most likely) never grasp the full concept. I was self taught as well and naturally progressed. It's just a matter of time, curiosity and desire. 
I started PHP (hadn't programmed at all prior to this) with Symfony 1.4, I'll describe my experience a bit. The good: - Using framework functionality introduced me to concepts I wouldn't have otherwise thought of myself, and reverse engineering (For lack of a better term) by reviewing the source code and changing code for kicks taught me a hell of a lot. - Having a framework to set the bar for code quality and general practices got me off to a great start in that regard. I quickly learned to write code that fit in with the framework, and by extension of the framework being well written, my code was alright too. Well, easy to read and navigate. Certainly not saying I was quickly writing great solutions. That's still a while off. - It's motivating to have a lot of power without really knowing what the hell you're doing. - You can get really cool projects out the door pretty fast - Could also be listed under bad, but makes employers happy. - Documentation tends to be really solid, so problem solving within the framework tends to be easy. But when it's not... The bad: - Problems with the framework, or things the framework didn't accommodate, left me feeling absolutely lost. When you're playing around quality code, you have to believe that being bottom notch means you won't have a goddamned clue what to do when things aren't working. There's no easy way of understanding how to work with the code base, let alone how to write the code you need to add as well. And not to mention if the documentation doesn't help you... It gets rough. - I managed to learn to handle sessions entirely with $this-&gt;getUser()-&gt;getAttribute('foo') type crap within Symfony's controllers. I hate to admit it, but when I took on my first plain old php project without symfony... I actually had no clue how to use sessions. It was fast to learn, but yeah... It's kind of funny that you're often utilizing an extension of PHP, and there's an underlying functionality there that can be used on its own as well... But you aren't learning to use it. - You may become dependent on the framework for a lot of basic programming needs, like MVC architecture, and never really learn to build it yourself if you're not careful. You really need to learn as much as possible about the framework you're using... If you don't, that dependency makes you seriously limited. I know of a few people who throw a copy of massive frameworks onto servers for incredibly small sites - They just have no idea how to do things without them. - You're learning php - Just kidding
http://imgur.com/yJsrX
I won't be rolling my own solution for the job, I will likely have to use a framework, the question was focused around how I should be going about learning the language itself. Going by the responses I think I'm going to use bog standard PHP for a few weeks and then go on to learn a framework.
&gt;Sorry I didn't read your full post but that is assuming you have some programming experience and understand concepts like OOP. Yes, as far as OOP goes I went through that whole *"learning experience"* at the start of the degree and the only development I have done is using that paradigm.
How do you guys handle timeouts? That's an aggravating problem I have and no easy solution. Cookies, on the otherhand, don't have timeout problems, but have serious space restrictions. http://stackoverflow.com/questions/5381526/what-are-the-current-cookie-limits-in-modern-browsers With cookies, if you want to support most browsers, then don't exceed 20 cookies per domain, and don't exceed 4095 bytes per domain (i.e. total size of all cookies &lt;= 4095 bytes). These bytes also include the cookie name! I really want to get away from cookies altogether except for simple things like persistent cookies that automatically remember your username on a login form, or remember that you chose "Remember Me" on a login form and logs you in automatically. And something else I need is an arrangement that works on almost any shared hosting plan. Some of those hosting plans don't let you have sessions last past x minutes, period. So, if anyone has something like a class I can start using to handle the timeout issue with sessions, I'd really like to see it.
I think most tutorials get it wrong - they sacrifice all security in the name of simplicity, when usually there's a way to present the topic in a simple way anyway (or at least not teach worst practices). Let's take databases as an example. Tutorials do stuff like use the old mysql extension, when it would be about as difficult for the user to use sqlite with PDO (and you could even provide the database file for them). $db = new PDO("sqlite:example.sqlite"); $statement = $db-&gt;prepare("SELECT * FROM sayings WHERE name LIKE ?"); $prefix = $_GET["prefix"] . "%"; $statement-&gt;execute(array($prefix)); foreach ($statement as $row) { echo "$row[name] says $row[saying]&lt;br&gt;"; } I don't think that's any more complicated than most tutorials, and from there it's easy to transition into MySQL by simply changing the connection line. You've just taught them how to query a database without the risk of SQL injection without ever mentioning the words.
Can't you just do: //If both the video and mp3 do not exist if (!( file_exists($name.".flv")) &amp;&amp; !(file_exists($name.".mp3"))) { //Download it } else { //Either the video exists or the mp3 exists; either way, it doesn't need to be downloaded }
One of the main reasons why many people do not respect PHP is that there is loads of really bad PHP code. I largely blame this on tutorials that favor quick &amp; dirty solutions over good code. I think if PHP had more tutorials and books teaching clean and secure code, PHP would be a much more reputable and better language.
The people who are googling for tutorials probably aren't the sort of people who will sit down and read a book about the subject. They just want something that works quickly, not to learn fundamentals. If you say "go read a book" they'll go read someone else's tutorial that tells them to use register_globals.
Yeah, I guess I was speaking more of people that want to *learn* php versus *do something* with php, which I realize is a pretty big subset of people.
Yes, my ignorant clients who can do 5 million+ pageviews a day on their collection of WordPress sites are experiencing something we could call bliss.
The question was about *learning* PHP. No one is telling him not to use a framework, **just not to learn PHP using one**. And although downvoted to hell, I still maintain that writing a small framework will teach you a lot about the language.
They only need to be declared on one page and the variables will remain as keys in the $_SESSION superglobal across all pages on the webpage as long as those pages have session_start(); at the top of the page.
Variables in PHP aren't case sensitive.
You'll take a huge hit in performance as your site becomes more popular and you keep the session information around so long. Even if the session indices are hashed, you'll still have all that stale data floating around on your hard disk, and the garbage collector will take For Damn Ever to run when it does run.
Thanks to the feedback on here so far (esp. @warmans!), I've made some big changes to the class today: * Reduced it to using only a single closure * Cross-platform support in file logging * Better OOP structure * Fixed a couple bugs and cleaned up code * Now supports six different backends (file, mail, syslog, HTTP POST, MongoDB, and appending to a buffer variable) * More docs and examples * Submitted to packagist.org [here](http://packagist.org/packages/analog/analog) for composer.phar support I think this now fits very well in the MicroPHP camp ([cloc](http://cloc.sourceforge.net/) reports only 54 lines of actual code in the core!). Even the full source is only 163 lines, compared to [KLogger](https://github.com/katzgrau/KLogger) at 177 with only one backend, and [Monolog](https://github.com/Seldaek/monolog) at 1021 (albeit with a couple more backends). Big ups!
Would it be possible to convert the wav to mp3? I would suggest using one of the many Flash embedable mp3 players. http://www.webdesignbooth.com/10-easy-to-implement-flash-based-mp3-players-for-your-website/
http://kolber.github.com/audiojs/
1) conver to mp3, it will load faster 2) use html5 and JavaScript to play audio elements. Unless you are concerned about ancient browsers, in which case you're stuck with flash. 
What you could look into is making improvements or adding to something like (web|win)cachegrind. But whatever you learn is never wasted. 
We disagree because you think the world is made of fuzzy bunnies. It is okay to admit that something sucks, you just seem incapable of that.
Have you ever seen this one: http://particletree.com/features/php-quick-profiler/ Yours seems like something I'd use, if it's easy enough to use and was developed a bit further. 
useless to you, that's sure. But sometimes I fork repos just because I don't want to forgot about them. But I do have commits and even project of my own, so I get your point
My above comments still generally apply. Because, if your communication channel is JSON via HTTP -- the tutorial would be on "How can I get PHP to output JSON"... obviously you can find tutorials on this. More concretely -- lets say you wanted to build a Users SOA component at /users You might have /users/listall -- this component would query the database for all users and format that list into json and return it. Nearly any framework nonsense would make this component less straightforward. Now, you might use a JSON library, but probably not a full framework. Nothing is stopping you from using one, but it would be used just like it would be used anywhere else (but probably taking advantage of less features). You will find this pattern repeats, as long as you design your SOA platform well, keep your components small and fast, allow them to be cleanly cached (at the HTTP layer), in most of the middle and back end components, you will want to keep them framework free and super clean and easy to maintain. If you find libraries or frameworks that massively simplify development of a component, go forth and use them! But the great thing about SOA is just because your authorization component uses a framework doesn't mean that framework has to spread like a plague across your project. Simplicity and minimalism is how you maintain large projects. The complexity will creep in all by itself. 
I have done a few different things in the past, I found server side sessions to be one of the best options, as it produces such a low load on the server apposed to common methods of sql. one thing I have done before was to build a class for sessions and also set a cookie for user tracking and included a mysql interface to setting/getting variables. the idea was simple if I was getting/setting a veriable and it was not already in $_SESSION then I would query mysql to see if it was in the DB and act accordingly. This can be a good way to keep track of user data as they traverse the site, just don't go overboard, remember to always code in a way that your traffic can grow by at least 25x the current traffic and not kill your server :-) 
The purpose of "convoluted" code in many cases is to ensure orthogonality of components. You must be able to change parts of a system without affecting any related components. In order to do this everything must be connected together with factories and other patterns which will always lead to code that is harder to follow than had you just $something = new Thing I don't really know how this relates to having an n-tier system as you describe. I suspect the two things are correlated rather than cause one another. Though that being said whenever I've written back-end code for something like ExtJS (which I guess you could consider a tier in and of itself) it always gets pretty abstract. The reason for this is that you're trying to create abstractions that relate to things in another system (e.g. a Grid or Form) where the other system treats components differently than you think they should work at your end. For example ExtS will use slightly different methods to receive form data and grid data while in the PHP layer they can basically be exactly the same.
It needs to be in php? With HTML5 and canvas you can do a lot of cool things client side
Code Igniter gets old very quickly. Especially when you want to do really neat things. I would learn to work with Code Igniter w/ Doctrine, then i would transition from Code Igniter to Symphony. If you decide to learn a framework, symphony is one which can get you actual paying work. It would not be a huge transition from symphony to zend.
Who put the TL:DR tag in the response? I ask because if its robertmeta saying the question was too long, I guffaw! The response (though complete) is twice as long as the question!
One of the reasons I like xdebug, xhprof, and the like is that I don't have to add additional code to make them work. This is the main problem I have with userland code solutions. Xdebug does a lot more than just do variable dumps. It's a full on debugger. I'm not saying that you should quit development on your project - particularly if you find it useful. However, your project only really covers part of what xdebug does.
If you really want people to help you spot the bugs, provide code.
&gt;I'm not saying that you should quit development on your project -particularly if you find it useful Question is, do you think it might be useful ? Or in other words, if you can get a trace of an execution like this http://moduler.pagodabox.com/index.php/trace/lastTrace, with just one click,with out any extra extensions or configurations, will it make any difference to your development?
I do think it's well presented, but if you're asking if I personally would use it I'd have to say no. Not because you've done a bad job, but because I use tools which do that and more in an unobtrusive manner. As an afterthought: I might use something that presented information like that if it accepted cachegrind logs.
&gt;but because I use tools which do that and more in an unobtrusive manner. I am not aware of any tool except xdebug that can profile every function in your php script WITHOUT adding profiling code around them. would you mind sharing the tools you mentioned? The point of this profiler is that it can show as much data in that tracepage ( http://moduler.pagodabox.com/index.php/trace/lastTrace ) WITHOUT xdebug and WITHOUT adding extra profiling code to your functions. And to generate that trace, all you have to do is delete the last trace and take a URL in browser. Then the trace data will be collected and written to a file, which can then be viewed using the trace viewer page, http://moduler.pagodabox.com/index.php/trace/lastTrace And In that page you can click on function names to trace further function calls from that function 
Actually, I'm working mostly with canvas as an input medium. Basically I'm working on a sort of town-map creator for an rpg, and I'm testing out its viability. User plots down the bounds of the town, gates, towers, streets, etc. and they're saved as numerical values to the database. Ultimately I want to reproduce this dynamically using PHP. I know I could save out the image directly from the canvas, but I want to see if it's possible to get something of equal or greater quality on the serverside.
I'd suggest getting a standard ZF skeleton app set up first that has the majority of stuff you'd use on each client app, then freezing that. I'd started 'zfkit.com' as a project for a reusable zf starter kit with doctrine 1 integration. I've used it, but not kept it up to date. If I was to start it over again (or indeed, if someone wants to fork it and let me have updates), I'd use something else for the majority of DB stuff - probably redbean. Redbean's got the day to day simplicity to cover 90% of what people need for DB stuff. tl;dr - consider redbean with zf.
I think taking an existing framework and using it to build a small project (like the stereotypical blog demo) is a better approach if, like I said elsewhere, you take the time to dive into the framework code during development to understand HOW and WHY it works the way it does. I totally agree that _at some point_ every developer should write a framework, I don't think it's a good first project for learning a new language, even if you are an experienced developer. Start by learning from people with more experience than you, and then apply those learnings to your own code after. 
 $return = mail($to, $subject, $message); if(!$return) { // Email failed throw new Exception('Error Sending Mail'); } This will offload the task of sending the email to a program called sendmail (by default) on the server. PHP itself doesn't send the email unless you are using a PHP mail library. If the receiving mail server chooses to refuse the email (There are lots of rules mail servers use to filter real email from the spam noise. Some of the rules will just deny the email straight away.. no inbox, no spam folder, just delete), it will look like the mail sent successfully to PHP, but sendmail failed to send it. Check the [sendmail logs](http://www.google.co.uk/search?q=sendmail+logs) on your server to find out what is going on. 
Downvotes explainable by [the relevant XKCD](http://xkcd.com/323/) 
I would say keep concentrating on keeping things simple. That's more important than the rest. If you think something is too complicated for not enough gain, don't use it, and ignore the folks who think you should. Remember, they're completely ok with that level of complexity, even though you yourself know it isn't necessary to successfully complete projects.
No, it's because they don't like PHP. The reasons they give are created after the fact. Name any language that's decently popular, and I'll show you a language with "loads of really bad code".
&gt; a PHP developer could do wordpress no problem. Well... At work, our site is coded in PHP. We use Wordpress for our blogs. Fine. Someone once made a site for us in Wordpress; that is, the whole damn site was somehow done in Wordpress, not just the blog. I honestly have no idea how he did it, and it took me a while to figure out how to integrate it with our pre-existing Wordpress install - of course, it didn't help that we had to hack a bunch of the plugins to work on a multi-server multi-site setup. So, I have no experience developing a Wordpress theme or anything like that. I just know that people do crazy shit with it that I can't understand without knowing a lot about Wordpress's internals.
Most tutorials seem to teach SQL in the most simple terms, without mentioning how devastatingly insecure the example code is. While that works as a teaching tool, it's almost never designed to be be used seriously. This is only an issue when the code is dropped straight into a production environment- but it happens even more than you'd think. 
I'm sorry you don't like WordPress. But I've implemented WordPress sites for multiple Fortune 500 companies and they have been very happy with them. WordPress is very flexible. Right now I'm using it to set up a job recruitment site. Everything is running very smoothly. No reason to hate. It doesn't help you at all. If you think you can do better, do so! But don't have to be angry about it.
I once spent 6 hours trying to figure out why something wasn't being stored in my $_SESSION. I finally realized I wasn't including the file that had session_start() in it. So... You have to start a session but you don't have to destroy it.
I store everything as numbers and use function switch statements to break them apart. I find it's easier to ship numbers around than text. 
I can only really refer to my own experiences but when I started using PHP I learned how to create "pages" and could basically get by the mysql functions and some basic loops, variables etc. Then I started using CodeIgniter and started thinking more about creating an application rather than a set of pages. This was the turning point that led to me creating much higher quality code and really become interested in proper programming topics like OO design and patterns. So I guess I did need the underlying understanding of basic constructs but very quickly slipped into bad habits because there wasn't a structure in place to make sure I was doing things "properly". Don't underestimate how much you can learn from looking at well designed code. You still need to know the basics but learning via a framework puts you on the right path and gives you an incentive to learn about classes, abstract classes, static methods, interfaces etc. because you'll be seeing them in use.
I have added a function to find factorial of 10 so that you can generate a trace for it.. For this first delete the last trace by taking this link http://moduler.pagodabox.com/index.php/trace/delete_trace Take the link that executes the factorial function http://moduler.pagodabox.com/index.php/factorial/find_factorial Now you can see the trace of the execution at http://moduler.pagodabox.com/index.php/trace/lastTrace click on 'core::response' &gt; factorial::find_factorial &gt; factorial_model::find_factorial&gt; factorial_model::find_factorial....&gt;.... 
Lol. I know how to code. If you use WordPress properly you can do anything. It's not that complicated. Feel free to link to your work btw. 
Actually, I use the WordPress menu system, custom post types, and widgets. I also use hooks/filters and actions. I use WP properly when I develop in it. Compare the data models for WP and Joomla and tell me what you can't do in WP?
Sweet, thanks!
When I was a beginner I spent my time in PHP docs because all the tutorials were terrible. They are too dumbed down.
Once I wrapped my head around ExpressionEngine's plugin/module architecture, there's not much I'm unable to create with it. Totally separates content from code, and EE's template model is completely flexible. And it comes with full support for CodeIgniter, which EE itself is written in. This makes porting CI apps to EE relatively easy.
That would be interesting.
SSL checking is the job of the controller; the router shouldn't *ever* know about it, unless the controller tells it to. That is, as I said, business logic.
I think the dynaflex extension should cover you for this. http://typo3.org/documentation/document-library/extension-manuals/dynaflex/current/ 
Looks promising, gonna try this tomorrow. Thanks
&gt; I am not aware of any tool except xdebug Well, that's the point, there's xdebug.
It requires the xdebug extension. If you have a profiler the does not require any additional extension, and that can be used with just one click( i mean really simple to use), that makes profiling accessible to a lot more php programmers, who can write and debug code a bit more efficiently....or so I think ...which is why I made this..so far its been working great....
Set a remember me cookie and use it to regenerate the user session.
Thing is... any programmer worth their salt already has a test environment where they can easily enable XDebug, and anyone who doesn't probably doesn't see the value in profiling tools either. It's very easy to set one up on your development machine. You don't seriously develop on a shared server, do you?
That may be true...But let me tell my example...I work in fadora and I was able to install xdebug ..but was not able to install cachegrind due to some dependency issues...so even if you have xdebug installed, do you use it unless you have to debug some complex code? I mean you have to enable xdebug, either using get parameter or via configiration file( I know there is a firefox extension for this..any way)..open the generated files in cachegrind log viewer... Let me ask..can you opt to trace only user defined functions in xdebug? &gt;any programmer worth their salt already has a test environment where they can easily enable XDebug, and anyone who doesn't probably doesn't see the value in profiling tools either. may be this tool will help demonstrate the power of profiling and tracing to people who are new to programming and php and in turn make them use more powerfull debugging tools like xdebug and xhprof....But I think that is the problem here...every one who have replied to this are those who are already using xdebug or xhprof...so I think I am not reaching my target audience... 
I'm always uneasy when I see references in PHP. They look so out of place. Edit: Same issue is described here: http://schlueters.de/blog/archives/125-Do-not-use-PHP-references.html#c24412
I would also like to say that I appreciate your efforts in this project. Many developers for PHP are okay with slop and don't care about standards and want to stay lazy in their 5.2 ways.
&gt; Look man, I respect you having an opinion I will definitely use this next time I get in a dispute on Reddit :)
Have you tried [webgrind](http://code.google.com/p/webgrind/)? Nice alternative when you need something more portable.
It is definitely slower because the processing is done through PHP.
Usually it's the reverse that happens: ClassName-&gt;methodName($variableName); but you're free to do whatever you want. The only language that I know that enforces it is [golang](http://golang.org) where public methods begin with an upper-case letter and private methods with a lower-case letter.
Maybe look at the Proxy Pattern for some ideas on how to implement this sort of thing. Though if all the libraries you want to include use something like the PEAR standard it might be easier to just switch to that than try and proxy everything into your own standard. Even if they're not all the same you might find than 90% use PEAR and 10% use something else. The other option would be to just run something like CodeSniffer and go though it's report and fix everything in the classes. though this would make updating the changed classes more difficult.
typo3 is a configuration hell :-)
Keep your naming standards for your code and use 3rd party libraries as is. PHP is about this kind of incoherence, just take a look at PHP itself: * https://bugs.php.net/bug.php?id=37088 Writing [adapters](https://en.wikipedia.org/wiki/Adapter_pattern) for every libraries you are including will be a real pain in the backside to maintain. If you have nothing better to do of your time than nite-picking with naming standards, then do it ;-)
I seriously wouldn't suggest doing this. If you just don't like using inconsistent class constructors you could just implement a factory for third party classes. It wouldn't resolve method names but they're not case sensitive anyway so if you wanted to really complicate matters you could just call them in in camel-case as per your example. Generally speaking MOST people prefer class names to begin with a capital letter and methods to start lower case so I wouldn't break this standard unless you have a really compelling reason.
Thanks, just working on changing it over now. Hit a small snag and gotta jet off to a meeting til the afternoon. Ack, when all you wanna do is code some days... ;)
BTW try to forget about `include` and use a proper autoloader: [PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md). Check those slides: http://www.slideshare.net/weaverryan/a-php-christmas-miracle-3-frameworks-1-app
You are making a serious architectural mistake by doing so.
People who use Ubuntu as a server shouldn't call themselves admins.. just saying -.-
This is absolutely the way to go. I've frequently found that receiving servers discard mail for all sorts of sundry reasons, the most common being a failed reverse DNS lookup. If it's a single server or a few servers that are dropping mail, it's worth contacting those sites Admin to find out what's causing it, they might be able to help pinpoint the cause.
Why not just disable the php time limit for the page if you have to wait for the operation to complete? Or set the process to return without letting php wait around, and use long polling ajax to check for completion? This seems like a really backwards way to achieve the same ends.
I haven't had the time to download and test it, but off the top of my head I can think of some things: - Make the layout more tabular. If the list gets longer it'll be easier to spot the bottlenecks. - If you're using a table, perhaps it's possible to add _how often_ a function is called, and allow sorting on that column. In practice, shaving 0.1 sec off a function that gets called once is much less interesting than micro-optimizing a function that gets called a zillion times. - Fix layout quirks such as the "&amp;quot;" everywhere. - Format units without too much noise: "0.02 sec", "646 kb", etc. - Add line-numbers and function-names and Classnames, to facilitate backtracking the flow. 
Thanks. I have noticed some of those. I was hoping the thing, as it is,is exciting enough. Was probably wrong. &gt;Add line-numbers and function-names and Class names, to facilitate backtracking the flow I have included class names and function names. Can you please clarify? 
What should they call themselves then? Ubmins?
yea...thats what it was meant for. Sadly not many of those people are here..
Please be aware that your own internal coding standard is in opposition to multiple coding standards adopted by the PHP community. I'm not saying you need to change your code, but the fact that so many third party libraries do it differently (and generally consistently) should be a hint. A non-trivial chunk of the rest of the world uses `$lower_underscore` variables, `lowerCamelCase` methods and `UpperCamelCase` classes.
Yeah, my example wasn't the greatest and not really what I'm using. Just typed up the post on my laptop. As for the standards the rest of PHP users use, mind sharing the exact specifics, or a link? And yeah, some of the libraries I want to use have underscores and the like. Ugh.
How did it go?
yeah, because copy/paste programming was invented around the same time PHP was... No one would ever think to copy/paste the examples from MSDN, that would be outlandish. Your post is exactly the kind of stupid bullshit I was referring to. ZOMG, THE PHP DOCS ARE SOME OF THE BEST OUT THERE, BUT THE USER SUBMITTED SAMPLES CAN SOMETIMES HAVE EDGE CASES THAT AREN'T TAKEN CARE OF AND/OR BE FOR OLDER, LESS RELEVANT VERSIONS OF PHP. THEREFORE PHP SUCKS AS A LANGUAGE. Just say "My name is TylerEaves, and I don't like PHP.".
Here is what I have found... and I have a great amount of experience. First of all, services like Yahoo, AOL, MSN, Hotmail and many paid ISP email services almost automatically ban html emails. They won't even be delivered to spam a lot of the time. Solution: Send text emails without urls or anything else in them OR pay a service like TurboSMTP or iContact.
You could probably use ffmpeg/mencoder for this.