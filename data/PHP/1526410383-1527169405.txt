I don't think he's right. All the "problems" he talks about are all signs that PHP is a healthy growing language that people care about and argue about despite having different backgrounds and philosophies.
Oh okay, but I was thinking about: abstract class TypedCollection { public array $elements; public function __construct(array $elements) { $this-&gt;elements = $elements; } public function toList() { return $this-&gt;elements; } } class IntCollection extends TypedCollection { public function __construct(int ...$ints) { parent::__construct(...$ints); } } // This would still work function map(callable $f, TypedCollection $c) { return array_map($f, $c-&gt;toList()); }
So you think mutable classes are more politically correct? ;-)
Thought this works just for `iterable`. Good to know.
Why would you want to deploy credentials with code, the credentials are likely different for production/staging/local/whatever, or am I missing something? I can see the use of this, but not sure it's a .env replacement which has a very specific purpose and does it well.
WE DID IT REDDIT XDDDDDDDDDDDDDDD
Nope, never heard of Ruby prior, just remember when Ruby on Rails became a thing and looked in to it, but stuck with PHP as that was where the work was.
SlimPHP with Doctrine. (VM has 1 CPU + 4GB of RAM). And our apis only return JSON. Testing: PHPUnit, sometimes codeception Front-end: vue-cli project.
I've seen quite a few good backends there.
Of course Ben loves it. He‚Äôs been invested since at least pre-alpha. Without Magento they wouldn‚Äôt have a business (same goes for every Magento ‚Äúfirm‚Äù and ‚Äúspecialized‚Äù Magento hosting companies).
Username checks out
It‚Äôs like WordPress for ecommerce. You literally need someone certified in the POS to get anything done. At least with WP you can hack away even as a junior. Magento was a mess from the beginning (and I was introduced to it when it was in pre-alpha). 
Wait... you want to rewrite the LMS moodle? and do it "the right way"... ? That's ballsy as shit. 
1.\) Vagrant or Docker... I've never seen an unbearable perf issue when mounting disks. FYI, most of the time ive been using Vagrant. 2.\) If you want to keep it out of a VM, switch to MacPorts. It uses a sandboxed install in /opt as an entirely different tree. You can also switch between php \(or ruby, python, etc.\) version easily with `port select` . An most extensions are installable as ports instead of using PECL directly.
`$this-&gt;assertFalse(in_array(6, [1, 2, 3, 4, 5, 7, 8, 9, 10]));` Good call. I forgot the `$needle` argument in there. Thanks! I didn't test my test code. You're right, it's not a PHPUnit example, it's a Codeception assertion. They have a slightly different syntax but you get the idea. Are you sure you don't want to review my the first draft? Clearly you're good at finding my mistakes. 
People who also say it's a good framework, a little rough around the edges are also people who IMO smoke a lot of crack
Not a bad idea. I'm not nearly as good at server side Javascript as the normal client side. I'd love to read a book like that.
Send me your github name &amp; I‚Äôll add you as a collaborator. 
Yup it was a joke. I was using Codeception's syntax instead of PHPUnit. I'll consider using PHPUnit in my examples because it's more ubiquitous among PHP developers.
Yeah, sure. Why *wouldn't* I want to work for free because Reddit asked me to? ü§î
Really interesting, thanks for sharing.
Yes, it seems that the zero configuration is used. I see the difference is that **idiorm** is fully targeted by the SQL repository. Thanks for the link, did not know about this library =\)
2 benefits 1. You receive this book for free 2. I give credit to those who give feedback in the opening pages and of course on the corresponding site But if that doesn't interest you, no worries. Thanks for your time.
Is such a clause even legal in the EU?
Is it possible to have your list of good php applications ? Thanks !
Must agree with this, beautiful piece of software for both !
Oof I once had to build a custom product generator for v1 and had to rebuild it's customer database after a failed upgrade with a wonky race condition, sigh.
At least that excerpt conforms to PSR-2. Not every project does!
I spent a short time working with Laravel professionally after having been a Zend developer for the longest time. The facades pissed me off to no end. Convenient? Yes. Still felt disgusting to use and god fucking help you if you needed to debug an error with one of them. I still enjoyed using the framework, and it's definitely a more "fun" experience than Zend, but it still took a bit of adjustment haha.
Refactor Mantis ;) ^See you in the afterlife ;)
&gt;Yes, I‚Äôve got other things to do, too, but I‚Äôve also got time to read and post on Reddit. This almost caught my attention. But when I did look at the better\-mood project you pasted ... I quickly decided I rather read on Reddit instead. That project is beyond salvation.
While not directly related to your question, always check the dates on these sorts of tutorials. Just about anything older than a year or two should be viewed with suspicion. PHPUnit 3.7 is ancient. The presenter also rambles quite a bit. I'd be surprised if anyone not already familiar with PHPUnit could follow along.
Testing largely depends on the project. At work we do 100% unit test coverage for any of our application's domain. For side projects I only unit test the most critical things and have acceptance tests to cover the rest. Testing can also be really valuable if the project ever gets turned over to another developer. If that other developer knows there test that will fail when they break stuff it helps them a lot.
&gt; and treat their users with respect Their software is not fully free software that is running on proprietary microsoft. &gt; evolved into yet another gang of profit-seeking shareholders chasing eternal growth at all costs, fuck the users This is capitalism. This was bound to happen the moment they made deal with the devil (US$6 million in venture capital from Union Square Ventures and other investors). You can't survive very long if you don't satisfy investors. Not even Joel Spolsky. Although in this case, it's a much bigger whale that is in play here.
Because customers were waiting for composer's version stats to make a decision about spending money.
Naive question: Where would you *start*?
You very well could test just as you are, but phpunit can test your entire application, front to back, automatically. It will test it the same way every time and will do so much faster than you can. You can run these tests every time you make a change or have them run automatically whenever you git commit. You will always know if your code is running as expected. That is the point of unit tests. 
[RedBean](https://redbeanphp.com/index.php) is another example of this sort of thing. Been around for awhile but still active.
Thanks for the tip, I've always been in the habit of checking licensing. Luckily all of the libraries in use are licensed for commercial distribution. 
I know this library. It uses static methods everywhere...
&gt;No namespaces I believe they support all the way back to 5.2 because of old installs. &gt;Static Calls all over This is not necessarily a bad thing? &gt;Everything unnecessary prefixed with Phabricator Again, this goes back to supporting installs that run pre\-namespaced PHP. Yes, they could convert to namespaces but the entire dev team is two developers \(previously just one\). They have bigger fish to fry. [https://secure.phabricator.com/T7408](https://secure.phabricator.com/T7408) has their opinion\(s\) on dropping support for older PHP. &gt;Other two bullet points These are ... questionable and IMO, lead to overengineered code when you try to follow them too close. For example, Sylius has been mentioned a few times in this thread and is much further on the "overengineered" end of the spectrum. Some somewhat interesting things that exist in phabricator: * A futures implementation in PHP \([https://secure.phabricator.com/source/libphutil/browse/master/src/future/](https://secure.phabricator.com/source/libphutil/browse/master/src/future/)\) * CSP: [https://secure.phabricator.com/T4340](https://secure.phabricator.com/T4340) \(if you want to see how they implemented it over time\) * Take over POST requests so they can perform rate limiting BEFORE file upload requests are done \([https://secure.phabricator.com/D18702](https://secure.phabricator.com/D18702)\) * Their own DAO / query layer * Their own markdown implementation \(remarkup\) * etc It may not be perfectly "architected", but there is a ton of interesting implementations within libphutil / arcanist / phabricator.
Oooh! Interesting find! I will try this out. Thank you.
Great idea, I've send you a pm. 
That second one is going to keep me up at night... it‚Äôs terrifying 
What's more time consuming and accurate: a) writing an automated test once, that then automatically checks that the functionality works exactly as intended or, b) you manually going through and filling out the form every time, for every possible scenario. As the application grows you will have more and more things to test until it eventually gets to the point where the manual testing will consume huge amounts of time. You will forget, or not have time, to test for this or that scenario which will lead to unforeseen bugs. Take it from someone that once thought as you do; if your code survives and grows for any amount of time you will hate yourself for blowing off automated testing until you simply have no choice. Also, saying you don't see the need for tests in an interview will most likely be an automated rejection for any decent development team. 
I was told it was recently fixed? The slowness I mean.
A lot of good advice here about git and testing, however if you're not experienced it could take time to set this kind of thing up. How much experience do you have? Is this a contract or a full time position? Do you have a manager who can code? 
The version control is a folder called 'Backup' that has the current folder structure copy/pasted. There is no one at the company that is a web developer. I have a year experience of learning to program. Again, I do not have any professional experience. I mostly did laravel stuff. The codebase is php 5.4. This is a full-time position. Manager cannot code. 
Ah, I don't have any experience testing php code. But basically, you are suggesting I need to rewrite the codebase? That's going to be a tough pill to swallow for my manager. I'll research testing then. Thanks for the reply. 
Thank you for the reply. The first day I set up a local git repo. There are certanily no tests . . . which is something I have not any experience in myself. I'll look into tests. Do you have a link I might check out? The set up for the environment is the most awkward and wonky thing, though. There is the copy and pasted codebase pasted on my workstation in which I am expected to edit, push to a development server to make sure it works (yet the workstation doesn't have php installed so I never have immediate feedback), and then push to production. 
The standard testing framework is [https://phpunit.de/](https://phpunit.de/) \-\- it's well documented and relatively straightforward, although you'll need to use an older version \(maybe 4.0.x?\) to start with since you're way back on PHP 5.4. There are books; **Working Effectively with Legacy Code** has plenty of positive recommendations on amazon, although I haven't read it myself. Concentrate on getting a local environment set up so that you can make changes locally with confidence before you even push to the staging server. Don't try and "boil the ocean" \-\- small, incremental changes that you can do while you handle feature requests from the business side will make your life easier. If you turn around to your manager and say "I need six months to rewrite everything" you'll get laughed out of the room; it's easier to bargain for one extra day a week to make long\-term improvements.
Get a solid IDE. I prefer PhpStorm, but that‚Äôs my opinion. Also ensure you have the PHP xdebug extension enabled. Then start stepping through the codebase. This way you might better understand the codebase. There might actually be some order to it that isn‚Äôt immediately clear. 
&gt; Should I just set the session lifetime and cookie lifetime to the same values (like 7 days for example) and "be done with it" That's generally how it's supposed to be done: if "remember me" is checked you set the lifetime to a number of seconds since the epoch, otherwise set it to 0 for the session to expire when the browser closes. Make sure `session.cookie_lifetime` and `session.gc_maxlifetime` (the global max lifetimes) are properly set, and session_set_cookie_params() should be called with the client-specific lifetime before calling session_start(). session_set_cookie_params needs to be called upon every request so that lifetime "countdown" be reset whenever a "remember me" user accesses the site again. &gt; Because if I'm not mistaken, the cookie will be kept by the browser for those seven days and it will contain the session id. The server will also not remove the session id until the lifetime is up. Yes, the cookie and session id would be kept in the client's browser and your database for 7 days, which is fine. Just make sure you're using HTTPS and have `session.cookie_secure` enabled to make sure cookies are served securely, and also make sure you're regenerating the session id whenever you login or logout. Having these session IDs lying around can be potential security risks (like everything else stored in your database) if your database is compromised or if a particular client gets compromised by self-XSS, virus, or something; which is why some websites like Reddit have [account activity pages](https://www.reddit.com/account-activity) that show all active sessions for your account; and some websites send you an email whenever they detect a login. If you think your database might be compromised, you'd want to log off all affected users by deleting the relevant rows in your sessions table. &gt; Also, on a separate note, what function is used to generate the session id that is stored in the cookie and DB It's [session_create_id](https://secure.php.net/manual/en/function.session-create-id.php). There's also [session_regenerate_id](https://secure.php.net/manual/en/function.session-regenerate-id.php), it can do some extra stuff, but it's basically a shortcut for `session_id(session_create_id())`.
1. If it's working, don't touch it. 2. If it needs fixing or features added, rework it. 3. Check out the book "Refactoring" by Martin Fowler
I‚Äôd start with characterization tests. Let‚Äôs just figure out what this thing actually _does_ (vs. what it‚Äôs _supposed_ to do), and build an insurance policy around it so it will continue to work like it does now. Then I‚Äôd introduce a dependency injection container, preferably something PSR-11-compatible, so we don‚Äôt have to sweat over 
Time to find a new job. 
&gt;Sometimes it's a choice of Refacture vs write from scratch Refracture. Even better.
Some form of ancient black magic always helps. Either that or a nice whiskey.
There are major architectural issues. I'm actually going through the book, Modernizing Legacy Applications In PHP, which suggested the dependency injection method for global variables. Your comment makes sense in regards to passing the required objects. I'm just wondering, what is the end goal for structuring a class for multiple databases? Do you have examples, patterns, advice? 
Am anarchocapitalist, this is in fact not what I believe in at all. (tl;dr You'd have arbitration, but if a company tried to say "oh and you have to arbitrate with our buddy here" you tell them to fuck off and go to a judge who is equally beholden to both parties.) The U.S. government believes in collecting as much money and power for itself and doesn't give a shit what corporations do to its citizens.
https://github.com/sebastianbergmann/de-legacy-fy
That‚Äôs pretty awesome. Thank you. 
Yep! It's a great way to get to the point where you _can_ write good unit tests while still assuring yourself that you aren't breaking anything.
There‚Äôs some good stuff in here, but I‚Äôll tack on one more. Software that‚Äôs untested and in poor condition tends to have continuously changing behavior. A new feature causes an old one to behave differently. No one notices or cares until you make an unrelated change. Sadly, it‚Äôs still your fault because you stirred the tanks. To avoid getting in arguments about whether or not the software is behaving correctly, I like to use a BDD framework like [Behat](http://behat.org/en/latest/index.html). Behat is an implementation of [Cucumber](https://cucumber.io) that I‚Äôve used before. Both sites have some good general information about testing you might want to check out. The general idea is you write real software tests in plain English that your manager and other stakeholders can read. Once you write them (and before you go to the effort of writing the code behind the test) you take them to your manager and say ‚ÄúIs this right? Is this how the software is supposed to work?‚Äù. Once they say yes, you have an agreement that can help get you out of possible sticky situations (‚Äúit‚Äôs not supposed to work like that‚Äù). In my experience, it‚Äôs a hat toss as to whether BDD or the curl-style full page testing is a better first move (after source control). BDD takes more time to make work, but it can give you more room to refactor in situations where pixel-perfect refactor isn‚Äôt possible/necessary. 
Unit tests let you refactor confidently. When you refactor a class, unit tests will tell you if the class' methods still produce the same output from a given input. 
`unit testing` is foreign concepts in the PHP world until someone created library and `phpunit` are one of them see **wikipedia** describe clearer about [unit testing](https://en.m.wikipedia.org/wiki/Unit_testing)
Non-Mobile link: https://en.wikipedia.org/wiki/Unit_testing *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^182919
What is it supposed to do? 
Make a website, parse XML from wpf, CRUD from mysql, login, alerts, announcements etc.
Tests are everything! try to write tests where you can, they will come in handy when you want to refactor down the road.
Divide and conquer.
Start by extracting the simplest pieces of code you can and reorganizing them. If you find a number of functions related to XML parsing scattered throughout the codebase, for instance, move them to a "utility class" of static methods that can be autoloaded into those files. Classes of static methods are not great, but they're better than random parsing methods scattered around everywhere. Then, set up PHPUnit and write tests against the utility class, so that you can do a future refactor of the utility class and convert it to a real class. Do the same for the JavaScript. One piece at a time, identify the easiest-to-extract pieces of JS and move them into an actual JS file. Write your JS modularly as much as possible. Do the same for the inline CSS. These three steps are pretty straightforward but will make a big difference. You'll get a lot of the cruft out of the PHP files, but also the act of going through the code and working method-by-method or script-by-script over the course of a few weeks will help you build a clearer conceptual model of the application. Only when you have a clear conceptual model of the entire system can you decide how to approach a more architectural refactoring. Take it slow and start with the low-hanging fruit. Refactor only the pieces that can easily be moved, at first. Once you've done all of those, you can do another sweep of slightly more difficult pieces, and so on. Eventually, and progressively, you will have refactored all the low-level details and will be left with only high-level problems like the architecture itself. But at that point you'll have enough experience with the codebase that the bigger problems won't feel so daunting. How do you eat an elephant? One bite at a time. 
I like the way you're thinking. I will probably watch and try to help this project.
First off congrats on your first dev job! I can safely say I've been where you are now and it does get better with time, patience and practice. Just set the bar and expectations low and communicate that things are going to take some spin up time while you manage the existing technical debt. Getting Git and some testing in place are great ideas so far. You'll also want to make damn sure you have a safe place to test, develop, and break things without affecting users. Git should provide an easy undo button when things break, but no down time is always the best option. I would also check out /u/pmjones's book [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp) as it provides a pretty great step by step guide on how to attack a truly terrible code base and it single-handedly got me on track through my first two dev jobs working on legacy PHP projects. Beyond that, just keep at it, don't get too discouraged and find a new job if your boss is too much of a dick :P
is it a lot of tasks to do with? you can just use `composer require league/csv` and composer will setup a composer.json for you. then just use `\League\Csv\Reader` in your code. In ruby you need to require every single library you want to use. But in PHP, it's just done by autoload, you just need to require `vendor/autoload.php`
Can you run the project locally? Install xdebug and start stepping through it to see what it does. Take notes. Move the code piece by piece into functions and write tests for them. I highly recommend test driven Laravel by Adam Wathan. Even if the project is not in Laravel you will learn how to do proper testing.
&gt; &lt;?php &gt; if (&lt;script&gt;js here&lt;/script&gt;){} &gt; ?&gt; &gt; which I'm pretty sure doesn't even work No, it doesn't work. But it wouldn't even get past a syntax check, making me wonder what are we/you missing here. 
Maybe it's like nature. We should preserve it and marvel at its intricate details, inst **EDIT**: Sorry, I was writing the above when I was suddenly interrupted by multiple severe bouts of uncontrollable vomiting.
&gt; There is the copy and pasted codebase pasted on my workstation in which I am expected to edit, push to a development server to make sure it works (yet the workstation doesn't have php installed so I never have immediate feedback) IMO such setup is extremely counterproductive and is a big red flag. It's nearly as bad as coding blind. Talk to your manager about properly setting up your workstation. If it's not achievable for some reason, I'd get out of there the first chance I get.
Before touching a single line of code: create a development environment and some kind of version control. On this development environment you start splitting up logic and design. Leave the html/php mix alone until you have a testing suite or a debugger. 
Thanks I will give it a look
Can I just say I switched to Linux for development a few years ago and would never look back. /r/Linuxmasterrace
You need an IDE with xDebug support. With this problems described by you will be less painful. For example it doesn't matter what is the function name and if it is in completely different directory tree than function which call it: - with ctrl+click on function name you will open file containing this function on the line where it starts, so you can check what it does / modify... - if you are not sure what exactly function does (gazillion of if/elses, nested foreach which you don't know if they actually run and what does), then xDebug will help: just place the breakpoint on the top of the function, start debugger and run the site (you need a local copy): line by line you will see what happens, which ifs are true/false, what values gets coming up variables, how those values changes... I remember days when I was not familiar with IDE/xDebug and I call it now the dark ages. But every developer probably had such ages, maybe it is still you :)
plus, with IDE you will refactor poor code in seconds. Have you figured out that $f variable is actually representing file? Right click, choose refactor and change name from $f to $file: IDE will take care of changing this time in every place where it is used. 
You can use https://github.com/phpbrew/phpbrew
While your advice is well intended, there is close to zero chance that a new employee will receive a feature freeze. Additionally, as a cynical senior dev, I‚Äôd expect any ground up rewrite from a dev with a year of experience to have similar problems as the existing code base, except now it will be in ‚Äúfill in name here‚Äù framework. ;) 
Very well said, additionally, setup a dev env. With something like https://puphpet.com/ or homestead (if production server is Linux). Invest in a good IDE, I highly recommend PHPStorm. Start writing tests where able. m.
That's a very good question actually, and it cannot be answered by reciting some dogmas. In reality, in the modern applications there is always some "magic" to help you with this stuff. And the implementation of such magic takes considerable amounts of code. For example, when you call a model, a database connection is silently injected in it behind the scenes. There is a huge gap actually between a legacy PHP spaghetti and a modern MVC-structured application, and I am not sure if it possible to cover it with sane amount of time. 
&gt; the die-vardump is a hello-world level approach to debugging What is a better approach to debugging? (If you're not working in a framework so dump() or dd() isn't an option)
phpdbg and xdebug
My advice was to commit seppuku right in the middle of the office and spray your entrails on everyone
Is it a common case that both DB layers are required? If yes then your problems are bigger then you thought. Either way with proper DI that has some kind of cetralized and declarative nature it shouldn't hurt too much to inject two DB layers into the constructor. Actually it would be an anti pattern to marry two different kinds into one class. 
If I were you I'd simply continue with this design pattern. I guess it's known around the company and all in all, it's still reasonably sane. If I'd want to refactor this part of the application, I'd wait till I could refactor everything, and port it to new standards.
Few anti-points to some suggestions I've seen in this thread. I've been you a few times before and I write this as I would write to myself 10 years ago. Feel free to PM me if you have any questions. First and foremost, do not get sucked into the world of codebase negativity. You have an ugly baby, whatever, don't tell the world you feel that way. Don't tell the people at your next interview or php meetup that the last code you touched was a festering pile of junk, everyone feels that way, even on high end codebases. You'll end up saying "no, you don't understand, this is REALLY bad" and it's just a bad cycle that only people who aren't growing participate in. I'm not reading your original post in this way at all, you're not negative, I'm just warning you it's really easy to follow your online buddies down the rabbit hole of bragging/complaining too often when you get a warm response to negativity. It'll get better, I promise, I can tell you want to grow. If you try to rewrite it, it's going to be your baby forever, and you don't want that at your first gig. You'll get attached and your career won't grow as fast as you'd like. You also don't know just yet how to even structure a rewrite. If your company wants a rewrite, they need to make a much bigger investment than just one entry level guy. I doubt they want it or that you can justify costs of it. In 5 years, you'll look back and say "knowing what I know now, I could rewrite that thing in months" But if you pick it up today, it's going to take you 5 years. If you spin your wheels trying to write tests, you're going to be confused and frustrated. You've probably never seen or designed testable code, and forging your own way is very hard work. Not to mention the existing code base is probably NOT abstracted in a way you can write any useful tests. I highly advise against adding tests right now. Definitely do get it up on GitHub, don't trust your local git. Use git flow and start getting used to it, even if there's nobody to review your code. Submit a PR for every bug and feature, then self-review it the next day. Two good things of this: You sleep on it and you'll catch your own bugs the following day, and you have a log of how much work each feature took. Definitely do get it running on some current easy to manage infrastructure. You'll need to understand a good bit about devops, but not too much. You'll want to know what makes it run - apache/nginx configs, database params, where configuration lives in the files, and you'll want to make it easy as possible to spin up a new server. Maybe consider Heroku or AWS Elasticbeanstalk. If the database isn't too tightly coupled, I'd say get a fully managed database (RDS or similar) up and running ASAP. You need to be able to recover WHEN something goes wrong and you want easy to test separate environments. It's also good to be able to deploy a point in time copy of the codebase, in case you need to review how it "used to work." As far as moving forward? First step is create reusable code. You update one thing that has a parallel elsewhere? Create a brand new file, /code-reuse/some-functionality.php, and put all of the support code in there. Then reuse your code everywhere you can. And once you have a bunch of code in code-reuse, you can organize it properly and name it something proper like /lib/xml-parser or /lib/database-abstractions, but you won't be able to start off the bat with enough wisdom to decide how to structure and name your files. Let that come in time, embrace the uncertainty. Once you have code reuse and a naming system, THEN you can start writing SMALL tests for your code only. For testability, focus on writing "pure" functions where the input ALWAYS matches the output - not relying on databases, random numbers, or UI interaction to get your results. Things that aren't pure, don't focus on writing tests for them just yet. Also pay attention to security as soon as you can, make sure queries are escaped properly, make sure you're not using eval or trusting user inputs, there's checklists out there you can find. Finding these holes is a very valuable exercise, in 10 years when you're telling a junior dev who reports to you why his code is insecure, you get to come up with a story about how you would exploit his code, and without seeing all these shining examples of bad code, you wouldn't be able to do that in the future. I'd also start now on learning how to organize your work stream. Create a personal trello board of all your tasks and prioritize them, or create github issues, or a spreadsheet. Don't do post-it notes on your laptop or be that guy that just totally forgets and people have to ping him by email all the time. There's a lot you can read online about how to organize your projects, but take their advice and systems with a grain of salt, these authoritative bloggers on the topic are constantly changing their flows and nobody has a concrete system or answer that you should adopt. You're going to love this job man. Have fun with it. 
How much of the project is 'framework' code? Auth, Session Management, Database access, etc? What's left isn't usually much and it's often simpler to port the functional bits of the app to a modern framework. I'm currently doing this right now. I'm rebuilding a 6-8 year old system that has gone through massive changes over it's lifetime. It's a mishmash of good and bad, old and new, stuff that worked and stuff that doesn't. It's complicated with lots of hidden things happening. I approached it as if the current build was the specification of the new build and am taking the stuff that works and ditching/rewriting the stuff that doesn't. Meanwhile we have to keep the old system ticking over. It's not a quick process but this software is the bread and butter of the company and needs to be done right.
&gt; If you're not working in a framework so dump() or dd() isn't an option dump() and dd() is literally vardumpdie.
This is purely promotional. The article is void of content really.
Thanks I already have xdebug :)
It doesn't matter until it does. You obviously haven't yet reached the situation where your project is doomed because it has no automated test whatsoever and your whole product and QA team spends hour testing everytime you implement a tiny little extra feature to ensure you didn't break user registration.
Yes at first I thought it was just extra slow... but really it's not completing even after one hour. How can I breakpoint when I don't know when it's going to get stuck ? Is there a way like phpdbg when you exit phpunit to get the backtrace ? I'm only using xdebug in command line, not interactively with an IDE. Thanks for your feedback. It helps a lot.
**ORM / Query builder** I'd say before writing any tests you're probably gonna have to perform queries. And reading your post I assume that all queries are written in plain MySQL inside the codebase. I'd first get a decent ORM. If you're used to Laravel, you can install Eloquent \(Laravel's query builder\) standalone. composer require illuminate/database \^5.6. **Debugging HTML** Tests will come in handy but what I found working for myself working on such projects is to get a sense of which piece of HTML is generated from where. Therefore I wrote a function that I inserted at the top of every template file: /** * Outputs the name of the calling file. * * @return void */ public static function debugTemplateName() { // Only debug for devs. if (!app()-&gt;isDev()) { return; } $trace = debug_backtrace(); $calling_file = reset($trace); $filename = $calling_file['file']; $filename = '/' . str_replace(PATH, '', $filename); echo PHP_EOL . '&lt;!-- ' . $filename . ' --&gt;'; } Now when you inspect your HTML you can see exactly where each piece of HTML was generated. Obviously this works best if there is some kind of templating thing going on, but if there's not it will still show you useful information about where HTML was generated. **New structure** Before you start, think of a general new structure for the project, that you can convert it to over time. Let's say you'll have a *lib/* dir where you store your classes, an *assets/* dir for your assets, etc. **Don't try to do everything at once** Even with this new structure in mind, don't try to convert everything at once. Sometimes small things can be fixed quickly. Save the restructuring for the bigger tasks. You might have to fix only one line of code inside a Javascript function. Don't convert the whole library to a Webpack\-bundled whole yet. **Use GIT, write documentation** Write documentation. It will help you and future developers understand the shit that has been going on here. \-\-\- In the meanwhile it will indeed not hurt to write tests for new classes you write, but I wouldn't start with it as my main focus.
Put a breakpoint inside your bootstrap file. Or your test. Heck, put it in vedor/bin/phpunit on the first line and see where that takes you. Not sure how you use xdebug without an ide though. 
**Single responsibility principle** The single responsibility principle is a computer programming principle that states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. *** **Dependency injection** In software engineering, dependency injection is a technique whereby one object (or static method) supplies the dependencies of another object. A dependency is an object that can be used (a service). An injection is the passing of a dependency to a dependent object (a client) that would use it. The service is made part of the client's state. *** **Don't repeat yourself** In software engineering, don't repeat yourself (DRY) is a principle of software development aimed at reducing repetition of software patterns, replacing it with abstractions, or repetition of the same data, using data normalization to avoid redundancy. The DRY principle is stated as "Every piece of knowledge must have a single, unambiguous, authoritative representation within a system". The principle has been formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer. They apply it quite broadly to include "database schemas, test plans, the build system, even documentation". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Integration tests basically?
When you use your laptop for work only it's fine, but I can't switch to Linux for my personal laptop as well. It's too impractical for way too many things :/
Being the only developer there, OP must have the tools he or she needs available without question. 
Well I suppose that depends what you use your personal laptop for. I use Linux Mint and I can honestly say there is nothing I can do on my mac that I can't do just as easily on Mint. It runs chrome, spotify and PHPStorm natively as well things like docker and vagrant etc. It has all the video codecs built in so I can watch video without any problems. In the past the lack of Microsoft Office has always been a problem but I've recently switched to WPS office which is a chinese copy of Microsoft Office. It uses Microsoft file formats and is designed to look and behave like MS Office in every possible way. When I eventually get round to replacing my home mac I'm definately just going to get a powerful PC and run Mint on it.
Hey, WArslett, just a quick heads-up: **definately** is actually spelled **definitely**. You can remember it by **-ite- not ‚Äìate-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
&gt; Working Effectively with Legacy Code has plenty of positive recommendations on amazon, although I haven't read it myself. Read parts of it: it is awesome. First parts are about what the author consider legacy code: anything with no test. Then he gives methods to add tests to a codebase depending on how it looks like already, what you're trying to test and how to limit the chances to break things. Hence the "read parts": I know I'll come back to it the day I have to handle a codebase which is covered by things I have not needed before.
&gt; If you spin your wheels trying to write tests, you're going to be confused and frustrated. You've probably never seen or designed testable code, and forging your own way is very hard work. Not to mention the existing code base is probably NOT abstracted in a way you can write any useful tests. I highly advise against adding tests right now. You can add testing without touching any code. Start writing a test plan you execute by hand. Then you can try to automate it with things like codeception and a webdriver if your system is a website. Acceptance tests are a lot more useful than unit tests. They're slow but they're how you can start chipping at a codebase from outside. Also it forces you to learn the specs and document them as usually there are none outside the minds of some senior devs and managers.
&gt; 5. Pray
Agreed on that. I was picturing the poor guy trying to write tests based on the entire HTTP response for a whole php file at once, but this is also a good path. Maybe toss some analytics in there to prioritize what flows should have tests first. 
CodeLobster IDE works best for projects that use some framework: http://www.codelobsteride.com
Definitely this. I mostly agree /u/kavisiegel, but there is so much sanity-preserving testing you can do for a fairly small investment on a project like this. You are always going to have *some* form of testing, it might be completely manual to begin with, but those manual steps should be documented in a form that's repeatable. And for a large majority of those tasks, if you're writing them down, you may as well write them for a headless browser or as an HTTP request in a test suite. $I-&gt;amOnPage('/login'); $I-&gt;fillField('Username','Test User'); $I-&gt;fillField('Password','hunter2'); $I-&gt;click('Login'); $I-&gt;amOnPage('/dashboard'); $I-&gt;see('Test User's Account'); $I-&gt;seeCookie('authorised'); A test suite that checks really basic things like "does the landing page show this important information", "can a user log in", "can the correct users access or not access the admin panel" can be established in a couple of days and give you some level of confidence that a series of changes haven't broken something fundamental you've forgotten to test. &gt;Not to mention the existing code base is probably NOT abstracted in a way you can write any useful tests. If a site is usable, it is testable. You might not be able to write unit tests or framework level integration tests, but if it has an interface, you can test it.
Thanks, done :) https://github.com/pwm/tc/tree/master/src/Concrete
What size of project is it? Is it a website? Often it is easier to convert a small project to a new CMS/Framework instead of refactoring old code. What is the future plan for the project? If you have to add a lot of functionality it might be best to look at a CMS/Framework that solves most of them as well.
Symfony on docker without tuning takes 40s+ per request in the webprofile for DEV environment.
In your specific case you could try to resolve the dependencies with some kind of a "automatic fallback mechanism". Example pseudo code: use MongoDB\Client; use PDO; abstract class ApplicationRepository { protected $db; protected $dbMongo; public function __construct(PDO $db = null, Client $dbMongo = null) { if ($db === null) { // create the connection $this-&gt;db = new PDO(Settings::get('mysql.dsn'), Settings::get('mysql.username'), Settings::get('mysql.password')); } else { $this-&gt;db = $db; } if ($dbMongo === null) { // create the connection $this-&gt;dbMongo = new Client(Settings::get('mongo.dsn')); } else { $this-&gt;dbMongo = $dbMongo; } } } 
My last run in with php testing was much more combersome than that, I had no idea the ecosystem advanced that far. At that level of effort, test all the things. 
why are you not using contracts? also if you need to debug a facade, that just means there is a error in the framework itself...
sure, but do you actually use it for debugging or just for "pretty var_dump" :P 
Top 10 anime horror moments.
was some "how to recover your admin account" page. Not sure if it was on the docs itself or a forum-post. There's another one that works with SQL alone, if you have DB-Access but no ftp-access. 
I didn't say, fulfil every wish. I said ask the people who work with it about their opinion, because that's where you get insight that you can't get when you don't work with it. Of course, there will be things that are not possible to implement. But others might be quite simple and give a lot of added value. Imho, writing code while ignoring the people that are supposed to work with it is running blind. You might create software that does exactly what you want, but that does not necessarily coincide with what your customers want. And we all know, that the customer usually doesn't know what he wants, until he doesn't get exactly that. 
CMS Elements are a nice thing. Imho the difference is, that a framework will only include the parts you need, while a CMS gives you a jack-of-all-trades kind of software, that does everything, no matter whether you need it or not. Frameworks are basically only standardised methods of development, that allow you to require packages. So there are two main advantages from a developers point of view: focus on code, not forms and only including what you actually need. Frameworks, like CMSs come in small to large. Only that a framework will allow you to only include the parts that you need into your project, while a CMS will always give you a huge base-system that you extend with plugins. It's two different approaches to the same problem. 
I use it for the pretty var_dump, how else should I use it?
I've always wondered this myself. And I see it as a huge counter-argument that "you'd have to check every form every time for every possible scenario manually" ... Wasn't the point of AGILE and DRY to write more structured and **modular** code so that you'd write it once and, hopefully, wouldn't have to change again. Or if you have to change, you'll change just that one module. Also are we still talking Unit tests as return-types based on incoming arguments or unit tests as both feature and unit tests. Because the former is dealt with by using strict types in PHP 7. And as practice has taught me, I rather write some bullshit empty object than to return null. Checking for nulls everytime you need a function forces you to repeat so many conditional statements its not even funny. And in a large codebase I learned to just ... scimm through them and ignore them. 
Sometimes it may be better to rewrite things while maintaining them
My company ordered our website from some small company delivering websites using wordpress. Now we ditched them and I'm in charge of updating it. There is 10 500 files for a \~25 page website. For any minor update on the website design I have to look through a maze of sentimentalized layers of both default/custom/overridden functions and templates to find the exact spot containing the code to change. It's hell.
As someone with no professional experience, but a lot of unprofessional experience - the previous developer was probably just running WAMP or XAMPP on his local machine or even just using notepad to edit the files before testing them on a live server, and following the procedure that, any time a page is complete and working - it goes into the backup folder. I've worked like that, and worked with a lot of code like that. You'd be surprised how many apps are out there that have no classes and are essentially just one huge, super nested if statement. The first thing I do is separate out all the unnecessary stuff. Start with decluttering anything you can. Dump all the CSS out of the PHP files into a css file and just call the css classes where you need them. Literally just get everything separated and simplified as much as possible, even if that means you have to have e.g. "homepage.php" for your html and "homepage.code.php" for your PHP. Once that's done, you can get all the code properly indented and start going through it, commenting and refactoring any low hanging fruit. Perhaps the code is full of `if/else` blocks, that you can simplify into just `if` blocks. Then you can consider refactoring it as-is, or refactoring it by recreating it in a framework. It's not going to be clean, but you'll get a lot further along than learning how to write tests, and then creating tests for code you don't fully understand.
Great to hear that adoption of 7.x has been this good.
not knowing the full extent of the situation but having tackled similar situations. download the all the code running on live, assume this is the only source of truth, if code is badly organized this will often be the case. Place code into a git/svn repo Get code running on a local machine so you can test changes, this should be as close to live as possible. workout the best way to deploy new code and more importantly roll back in an emergency. There are various tools such as [https://deployer.org/](https://deployer.org/) that could be useful. Clean/Refactor the code as you go, this may mean just correctly indenting until you get a better idea of the structure or just splitting files into a more logical layout. The idea is to keep things working. Eventually once you feel more comfortable start moving into classes. You are the only dev, own the codebase, manage expectations of those above you by being honest about the task they have given you and good luck.
&gt; you tell them to fuck off and go to a judge who is equally beholden to both parties And how do you decide that? Do you have to go to a meta-judge to decide which judge is fair to go to? The only reasonable system would be to agree on a judge before a dispute comes into play, and that's exactly what forced arbitration is.
That's usually step one
That's a very bad idea, it will lead to creation of hundreds or thousands connections. For a fallback solution there should be his familiar global $database_connection.
in the same thought... next time when you try to use strlen() and not \strlen() and you get errors, does that mean your application has poor design ? lets trow all old PHP code in the garbage then ... 
This would be my action plan: 1. Get all the code into version control and start using git-flow 2. Get your development environment up and running (I Personally prefer Docker), get PhpStorm and try to get the debugger working 3. Set-up a testing/staging environment where you can test with production data 4. Set-up Continuous Integration with a way to rollback 5. Follow /u/ExpertVersion's advice 6. Start on a simple HTTP API / with a separated code base for your front-end code (something like Angular, Vue, React). You can embed the JS application into the old version of the application and start fresh on new features 
Good Lord! Can I ask what kind of setup that is running on? I'm using multiple containers to provide the services required by the app: * HTTP * PHP * Redis * Mailcatcher * RabbitMQ * Supervisor (PHP queue consumers) I still run MySQL on the local machine but that is becuase it is shared amongst multiple projects and easier to keep as a single process rather than spinning up multiple DB containers with seperate volumes etc... The app is running slower in docker (compared to the localhost) but I'm seeing an average of +2-4 sec per page load, no where near as bad as 40 sec :-(
the point of automated testing in general is that your tests are **repeatable**. The problem with the testing strategy you are describing is that you are only really testing the one feature that you have been working on and it doesn't ensure that no other functionality has been effected by the changes you have made. On a large scale application, you will normally have factored your functionality into reusable components to avoid repetition eg. components that connect to the database, components that render templates, components that process forms etc. and this means that work on one feature risks changing or breaking the behavior of other features. To test your changes properly you would not only need to test the functionality you have been working on but all the functionality you have every worked on in every scenario it is is designed to cater for. This means that you have to keep track of all the functionality and every test case that your application relies on. By implementing a suite of automated tests with each development, you only need to run your test suite and everything is tested in exactly the same way it was when you first implemented it. If you have made changes and have new tests that are passing, you are alerted if any previously passing test cases are now failing.
I'm somewhat interested but largely as a learning opportunity. I'm still getting to grips with "the right way" and a project like this would be fantastic for solidifying concepts in my mind and workflow
And you have a full synced symfony application inclusive vendor directory over simple docker volumes? (two-way-sync)? How many files do you have in /vendor ?
Basically there are two solutions: A) Step 1: Make sure your employer understands that the code is a hot mess and that the only way of getting it future-ready is to rewrite it. Make sure that they understand that a bad code-base can cost them a lot more than rewriting it. Step 2: Find out what the heck the mess you inherited is supposed to do and write a clean description of what it should do. Step 3: Develop a new system based on your findings. B) Quit and run as fast as you can. 
Perfekt! :)
tbf, if you know nothing about syntax and coding at all, phptherightway is overkill. Too much information, usually on a high level that require at least some insight into how programming works. I would not recommend anyone to start with this page, unless they have some fundamental understanding of how php works and are looking for ways to optimise how they code. 
Imho not the fastest way, but definitely the one where you gain the deepest understanding. When you try to fix a problem, your brain is usually a lot more welcoming to new information than otherwise. 
Good point (with the number of connections). What about using a static member variable for the connection?
What are you charged with doing with the code base? Did they bring you in to continue new development, or to fix underlying problems (performance, consistency, etc.)? How long til they expect you to have results? I think with new development you start to envision a more efficient way of handling the codebase and writing your projects that way. Then over time, as you have to fix something in the old codebase you retro the code, making it look like the newer code you have written. 
amen
Did you even read the book? The whole point is doing small manageable refactoring tasks so that isn‚Äôt necessary to freeze development. 
From reading between the lines of the original post, this code won't likely run on Heroku. I'm sure there's plenty of local file storage and uploading happening, which may be a real chore to push to rackspace instead.
https://youtu.be/65NrzJ_5j58
I doubt that is the real code (PDO construct is wrong), but if it is close, I would resolve the environment and load the configs based on that first. ie: # files /config /development mongo.php pdo.php /production mongo.php mysql.php define("DEVELOPMENT", true); define("PRODUCTION", false); $appEnv = function () { ## figure out environment based on constants until you can move to a better solution.... return $environment; } global $database_mysql, $database_mongo; $sql_connection_info = require '../config/'.$appEnv().'/mysql.php'; $database_mysql = new PDO($sql_connection_info, dbname="'.$sql_connection_info['database'].'"); $mongo_connection_info = require '../config/'.$appEnv().'/mongo.php'; $mongo_client = new MongoDB\Client($mongo_connection_info); $database_mongo = $mongo_client-&gt;selectDatabase($mongo_connection_info['database']); &gt;Now, our code is littered with references to global $database_mysql, $database_mongo;. It's in classes, controllers, and models. As someone else has mentioned, only a few classes need this. I would start by looking at your code and determine if the classes actually need both. Then slowly refactor if necessary. You can also refactor the classes by taking out DB code and putting them into mappers, so you are only passing these connections only to the mappers using DI.
https://github.com/BetterMood/better-mood/blob/master/install.php#L104 I mean, it's object oriented, so how hard can it be?
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [BetterMood/better-mood/.../**install.php#L104** (master ‚Üí dc71a8b)](https://github.com/BetterMood/better-mood/blob/dc71a8b50e27c621d50e8d3681f92a155d2c74de/install.php#L104) ---- 
Breaking the syntax of PHP has nothing to do with the application design. People will continue to write software that is not on academic level. So whats the purpose of braking count() ? it does not fix bad software architecture. People will just wrap few IFs and continue. Its the same will be with the root scope depreciation.... this will not fix any software architecture... it just makes changes PHP to the syntax.... It brings no value, just brings more code overhead and maintenance. My point of this rant was that we should not break the syntax of PHP, those functions work the same for decades and im sure that bad application design does not come from the functions like count() or uniquid() 
&gt; Or if you have to change, you'll change just that one self-contained module. Sure, but if you don't test it, how do you know you didn't just create an edge case that will break it in 3 out of 57 places it's used? You can either write a unit test that covers the edge case, or test it in all 57 places manually.
Thanks for the feed back! I will take a look at the book suggestion as well! 
I cannot run it locally. I need to get that set up. I don't understand how some folks code blind. The server is IIS which I have never worked with either. Things are interesting. 
It is 2/3 gig of text files, just code. 
You may want to try setting up a remote xdebug connection to step through locally the code running on the remote server. 
They already want features. This is my first coding job so a rewrite would take me months or more. Thanks for the advice everyone!
They want me to add features when possible. I have made it clear that it may take some time for me to get up to speed. 
Yeah that's kind of excessive... can we make it run every time I say "hmm" while staring at PHPStorm. That'd be more balanced.
I saw another comment earlier, but I‚Äôll stress it again, you will be tempted to rewrite everything at once in the beginning, DONT DO IT. Make sure it is in source control. Then work, first on just getting the code formatted, as you like to read it. While doing this, do your best to understand what is going on. Then start to create the framework you like, and start to approach it. 
[vivace/db](https://github.com/php-vivace/db) \- Simple ORM with flexible query builder, relations, iterators and aliases.
Imagine testing every form on your site, every time you add/change a feature, years down the road when you have thousands of features. Now imagine you have to fix a bug when a user types a special character you weren't expecting on one form. With unit tests, you can verify that the bug you've fixed: * Didn't break something else, and * Is fixed on every form ...by running a single command (e.g. `phpunit`).
Yikes, that's big! You are probably going to find a few things accounting for most of the bulk. If the code wasn't under source control, the previous developer probably made copies of files and edited those. That's going to mean a bunch of unused files laying around that are "backups" of files when they were edited. Another likely issue contributing to the bloat will be a bunch of copy pasta. Moving your code onto established libraries and extracting common functionality into standardized components will get rid of a lot of other extra code. Symfony components are great for this. Finally, you'll start to find that there are files in there that simply aren't even being used, despite not being "backup" copies. They're most likely old pages and features that stopped being a part of the application, but were never removed.
&gt; **EDIT** Others have mentioned it too but check out "Working Effectively with Legacy Code" in addition to Refactoring. I can summarize that book: 1. Identify a small section of code. 1. Add as many tests for it as you can without changing anything. 1. Refactor it just enough to be able to add more tests, if necessary. Repeat this process until you have confident test coverage. 1. Take a full refactoring axe to it, and then fix any problems the tests found. 1. Goto 1.
This guy is a tool, but he has a point.
Gitflow is overkill for web apps because you don't need to backport things to old release branches. What everyone *actually* uses is simplified gitflow, which is the general philosophy but with only master and PR branches.
Hey, SibLiant, just a quick heads-up: **peice** is actually spelled **piece**. You can remember it by **i before e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Yeah you can! https://blog.jetbrains.com/phpstorm/2017/07/autorun-phpunit-tests-in-phpstorm-2017-2/
I always knew PhpStorm is secretly reading my mind.
It _knows..._
Closed the tab at : "for PHP5."
I didn't mean size in terms of discspace but more the amount features / complexity level. But I can't image how many backups you have to make to get 2 or 3 GB of TEXT files... Does the project depend on multiple big Frameworks?
I guess you could just look at the speaker list and make an evaluation based off of that?
Just try to do the best you can while you search for a new job \(that's probably what the previous guy did\). Don't refactor. Don't touch parts you don't need. Focus on delivering what's asked. There's a big chance your employer never really cared about the code quality.
Supports only **php7.1** and older versions
And that is?
I wrote Serializard [https://github.com/thunderer/Serializard](https://github.com/thunderer/Serializard), a very extensible and completely framework agnostic library that basically does the object tree traversal in both directions. The only thing required is to register callback handlers for normalization and hydration of given class and it handles everything else for you, regardless of where instance of such class will be in the object graph. There are a few built\-in handlers that use reflection or public fields, just look at the README to understand how it work. It supports XML, JSON, YAML, and Array formats, but writing a new one is a matter of proxying calls to dependency which will handle it \(talking about TOML, NEON, etc.\). If you'd like to use it or have any other questions, please let me know \- I'll be totally happy to answer.
I can't find "simplified gitflow" as a specific thing like gitflow is. But yes, master and shortlived branches to make PRs. At my current gig we're using it for everything, including the mobile apps. The only concession on the apps, as they don't lend themselves to CD, are release tags. Release branches are only ever created off these tags if and when fixes need backporting as you say while the next release is still being worked on.
It is hard to come with a solution in this case. You could use a static class to get those connections in your classes. Or, if you have control of object creation, you could implement a Trait to set the database connection. Neither alternative is really good, but as an organizing action could work.
In my shop we use a ton of tools. We use cppcheck, sonarqube, fortify, coverity, findbugs/spotbugs, dependency check, flaw finder, and a few other tools I cannot recall. We have like 8 different projects and each uses an array of tools. 
We use a few in our pipeline. Most value you get out of `phpstan` or a similar static analyses tool
You have [PHP Serbia](https://conf2018.phpsrbija.rs/) at the end of May
There are a couple: - PHP Benelux is a very community driven conf and most people tend to go for the NightTrack - ScotlandPHP is another usergroup driven conf which is very affordable and has a very relaxed atmosphere - YorkshirePHP is new(-er) but has had an amazing line-up so far - DPC is huge and has a lot of "bang for buck" just because of the many tracks - PHPDay is another community driven conf and has amazing food. I would say most Community driven confs are very good. There are a bunch of Confs not orientated at PHP specifically which are worthwhile to go to. It's a long list, but I would say any revolving around DDD is worth going to (DDDx, Kandddinsky, DDD Europe) and BuildStuff or FosDem 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; Wasn't the point of AGILE and DRY to write more structured and modular code so that you'd write it once No. The point of Agile is that you embrace change. Or rather that change is inevitable. The point of DRY is to follow the S in SOLID. &gt; The things that usually break for me are usually not caught by tests. Meaning, when testing my mail sending functionality the test runs in test environment with dummy server that never sends shit .... the actual mail server goes down and I find out the next day when I notice that my log files have become increasingly large. For these you use integration tests, not unit tests &gt; Or the memcache server went belly up and from 10 queries per page per client the site does raw database hits for everything for every user. Again, integration tests or monitoring/trend tests. You seem to be confused what the purpose of unit tests are with monitoring. They have different goals and different use cases.
I prefer using php code analysis/checker plug-in (do not remember it's exact name, sorry) for phpstorm ide. It helps to avoid simple code errors and keep code cleaner with various advices. For production I use grandma with peometheus and it's alerting system. Alerts come to slack and vsts by webhook.
And then... *it follows...*
In addition to writing tests: make sure those tests only test the interface/are only very high level tests. Since you're taking an axe to the old code, the only thing you want to maintain is the interface of that code. Then hopefully you won't be changing 10 lines of testing for every 1 line of code written.
&gt; In ruby you need to require every single library you want to use. Yup, but you can "autoload" any directory yourself with one line of code: `Dir["app/services/*.rb"].each {|file| require file }` Then you don't even need an `use App\Services\Whatever` because it's already require'd. PHP needs another tool aka Composer to help fulfill the PSR-4 spec and create the autoloading/namespacing functionality. Ruby achieves the same goal, but you want pull off similar functionality with less support from outside tools. It's really hard to describe in just text, but I hope you get my gist.
Weirdly enough I actually would be interested in giving Moodle a good shot. I've sent you a reddit chat with some of my details :\)
Thanks. A lot of advice is using things I don‚Äôt understand which sucks. I‚Äôm a jr dev who was primary focused in front end with stuff like react and Angular. I haven‚Äôt written any tests or used any other php framework besides a quick dip into laravel. 
SymfonyCon will be in Lisbon in Q4 
Been to DPC 3 times and going again this year, it's great!
start reading: https://jtreminio.com/2012/07/xdebug-and-you-why-you-should-be-using-a-real-debugger/ thought you also should look into phpdbg: https://phpdbg.room11.org/getting-started.html 
Thank you. I checked it. Not a huge list but nice projects.
Could you elaborate what you mean by interfaces? Quite sure OPs code will have 0 of them, or if any - whit out much sense. Are you talking about UI (user interface) and end-to-end testing?
Rehash them using argon2i or bcrypt, update the login script and done.
Thanks alot I will look into this tomorrow, weird that no one in my company uses this
Hey, insert\_a\_funny\_name, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Like what requests the code make, what it puts in the DB, basically what all other parts of the system expect from that piece of code
Also, if they're actually plaintext, just store `password_hash($password, PASSWORD_DEFAULT)` in its place.
This comment might be outdated in some years. password_hash() will always try to apply the best algorithm the PHP makers agreed upon http://php.net/manual/en/function.password-hash.php You could finetune the "cost" so that on your machine, hashing one password costs less than a second but more than lets say 0.2
Web Summer Camp in Rovinj, Croatia is always great.
In addition to EditorConfig, [PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) is also a great tool to enforce coding standards
Force users to enter a new password. Consider all passwords stored in plain text as compromised.
How about adjusting your comment to include links?
This, and only this. On top of it, hash the shit out of the new passwords, though.
CodeClimate
https://github.com/phpstan/phpstan plus unit tests, api tests, phpdoc (and checking phpdoc errors)
It's been a while since I last used Atom, but try searching for the **PHP Integrator** plugins.
when you use a metric like coverage, you can test every unit (function, class method) to insure that it does what you expect it to do. i know, it sounds kinda stupid and useless at first. but imagine being able to know for sure that every unit does exactly what you expect it to do, with various inputs. can you say that about your code now? did you ever wonder what would happen in that *one* function if it received a null instead of a false? or if a customer entered an invalid address or something? you can dream up all these weird edge cases and test just that one function backwards and forwards. you could never do this by hand. maybe you could, but if you wanted to do it again at a later time, you'd need to write down or memorize that steps how to test it. that's basically what unit tests are. you write it down so a computer can run these tests for you very often the real magic is with a big project code base. write your tests. then a month later, you do some refactoring or add a new feature, run your tests again, and find out that some don't succeed any more. now you need exactly what area of code you need to look at this happens a lot more often than you think. i think of unit tests as "buttresses" that hold up the structure of your code. they keep it rock solid. really helps you sleep at night and feel confident before committing code
I didn't discuss how to identify which parts of the code to work on, but you're right - you want to focus on the nastiest bits (ie those that break the most often). If something is broken, it of course follows that OP should fix that first. What we're talking about is how to start paying down the technical debt so that future work is faster. Tests are *incredibly* useful when doing refactoring because they give you confidence in your changes. Otherwise you're likely to be constantly shipping bugs into production, which is going to make users unhappy and management wonder why they should let you keep doing refactoring.
This is the only secure solution. 
Because he's Asian.
- PHP-CS-Fixer - phpstan - phpmd - psalm
I have been using those PHPUnit helpers for years now, maybe they can be useful to others: https://github.com/mnapoli/phpunit-easymock
Definitely. Jack up the password length. Best way to force that.
Agree completely. Unit testing is probably out given the lack of abstraction in the code. Functional/integration testing is a little like doing brain surgery with a mallet instead of a scalpel, but at least you know when you broke something rather than finding out the next time you push changes to production.
Yeah. It uses your crypt() system call which is probably bcrypt for modern systems: https://dev.mysql.com/doc/refman/5.5/en/encryption-functions.html#function_encrypt
Are you sure you are required to do this through phpmyadmin? From my searching I don't see a way to automatically back up without a cron job or script or 3rd party tool.
All the things you claim aren't testable are in fact testable. You need to write your code with testability in mind. 
Right! That's exactly my problem! I need to know where to begin in writing a script like that! I have no idea. I am not required to use phpMyAdmin, but at this point it is too late to change - my project is due tomorrow at end of class.
GrumPHP comes to mind.
Look at this first: https://dev.mysql.com/doc/refman/8.0/en/mysqldump-sql-format.html Then look at Scheduled Tasks in Windows.
Neither phpMyAdmin nor PHP are a database. It looks like you've completely neglected your homework and are now hoping someone else will do it for you. If you're using MySql, you can use the mysqldump command to create a backup. You can use a scheduled task to run a powershell script or batch file to invoke mysqldump.
I agree and personally try to link any references people might wanna Google. But that's my lazyness gift to others :)
You can definitely use a MySQL dump with a cron task to periodically schedule it or a backup utility like backup manager on Linux OSes. There are several other possibilities, either on Windows or Linux systems.
Each AJAX call can be independently tested using the same mechanism. If nothing in either output changes, then I should sure hope the end result still works (and I'd be a little surprised if it didn't).
It absolutely wasn't.
&gt; Do I miss the bigger picture? Yes.
I bet you're a multimillionaire with a 14 inch penis too
PHPCS, PHPMD, PHPSTAN, PHPUnit Behat with self\-written Contexts, Continuous Integration\-Pipeline \(atm Codeship, maybe switching to CodeBuild by AWS\). For ReactJS\-Parts we use TSLint.
"To be done" is not a good idea. You should tell the users, similar to recent GitHub and Twitter notifications. Passwords which exist n clear text outside the short time in memory it needs for hashing could be anywhere.
I love the idea of doing PRs for yourself and reviewing the new day. Thanks for this!
Try installing php-ide package
It is. Although, I don't know what the appeal of PHPClasses is. [https://packagist.org/packages/nahidulhasan/html2pdf](https://packagist.org/packages/nahidulhasan/html2pdf)
Joy. 
&gt; It also seems to me very time consuming. Let's calculate the time difference using some rough numbers: - An automated unit test takes 5 minutes to write and 0.1 seconds to run. - A thorough manual test of that same code might take you 30 seconds to run. Ideally you should re-run your tests after making changes. **So if you plan on making 10 or more changes, the automated unit tests will be less time-consuming in the long run.** And what happens if you have 100 things needing to be tested? Would you rather spend 10 seconds letting your computer run the test or 50 minutes doing it yourself? (Remember that you're ideally testing after every feature addition/change) Also, your computer won't "forget" to run a test like you (a human) might.
I just did a quick google search but this seems like it would work https://mysqlbackupftp.com/mysql-blog/backup-phpmyadmin-automatically/
Implement the hash-based password system and set the existing passwords to an empty string. Any input will produce a fixed-length output via your new hashing algorithm, so any password attempt will cause a login failure because no hash will ever be "". This effectively locks everyone out of your login system. UPDATE `users` User SET User.password = "" WHERE 1 = 1; Post a message that indicates all users must complete a password reset, or send an email informing the user that they will need to do a password reset before their next login. If you don't want the same password to be used, you could implement a "password history" table to keep track of old passwords. Check for old passwords before allowing a new password. Upon changing the password, put the old password hash in those tables. INSERT INTO `password_history` (user_id, password, created) SELECT User.user_id, ENCRYPT(password), NOW() FROM `users` User; Ensure sufficient password lengths (at least 8 characters) to cut down on brute force ease. You can harden your password reset process to take advantage of strong cryptographic hashes as well. For my recovery systems, I generate a random string and mix in all kinds of information (timestamp, IP address, CPU cycles, time since boot, or other environment information, etc). Then I hash that information in a loop for one second. I deliberately use CPU time instead of a fixed number of iterations so that an attacker can't calculate an attack against the fixed number of iterations. Then, I email the resulting hash (hash *n*) to the user, hash for one more iteration, and then save the final hash (hash *n+1*) in a special table for recovery attempts. This ensures that you are not in possession of the secret (hash *n*) that will allow you to look up and complete the password recovery attempt. When the user shows up to recover a password, they present hash *n* and then I am able to quickly calculate hash *n+1*, look that up in the DB, and proceed with password recovery. Always invalidate password recoveries on login by deleting any outstanding recovery attempts when a successful login takes place. Here's a rough idea of how that might work... &lt;?php function create_password_recovery($email_address) { $user = getUserByEmail($email_address); $randomString = implode("", [ $_SERVER['SERVER_ADDR'], time(), $_SERVER['REQUEST_TIME'], $salt, // from somewhere else, maybe $_SERVER['HTTP_USER_AGENT'], $_SERVER['REMOTE_ADDR'], bin2hex(random_bytes(64)) ]); $startTime = time(); $hashResult = $randomString; while( time() - $startTime &lt; 1000 ) { $hashResult = hash("sha256", $hashResult); } // send the nth hash and do not store it! emailPasswordRecovery($user, $hashResult); // save the n+1th hash savePasswordRecovery($user, hash("sha256", $hashResult) ); } function process_password_recovery($hash_n) { // recalculate the n+1th hash and look up the recovery $hash_n_plus_one = hash("sha256", $hash_n); $recovery = getRecoveryByHash($hash_n_plus_one); // if the recovery row is found and valid, let them reset their password if( recoveryIsValid($recovery) ) { // render a recovery view } else { // render error or redirect to login } }
Yeah lots not fix any bugs and just add new things that sounds like a wonderful idea. Again they didn't break count() it works exactly the same now as did before. With the addition of a notice getting thrown when used incorrectly. If your app is broken in production because of a notice being thrown that is entirely on you and your poorly put together application. Languages evolve and change. Adapt your apps or stay on the previous version.
You're missing the currently ongoing wearedevelopers conference in vienna. Lots of great talks and 8000 developers. The biggest dev conference in europe.
Sonarqube is pretty good
Implement your hashing and change everyone‚Äôs password. Make the forgot password link prominent 
That's some awful naming, encrypting != hashing
On my side: - automated php-cs-fixer - CodeClimate - phpmetrics - my mates (if a mate review can be considered as a tool :D)
Nah, no way! You can't blame the author for injecting a little personality into a post about a database abstraction framework. I'll take humorous (even if it falls flat with some folks) over stuffy any day. 
Phpspec, codacy, RIPS
I can convince you that kotlin is your Lord and savior if you want? 
I doubt it, but you can try.
I like the look of phpstan but I can't seem to get it working for laravel. It doesn't seem to like facades I think. The docs say to use ide-helper but that doesn't seem to work. Still getting 900 errors that are not a part of my code base. Are you using a framework? Or is phpstan for vanilla php only?
Cheers OP, this actually sounds like the perfect blend between an ORM and SQL.
I'm using silex/symfony Surprised it has issues with laravel!
https://github.com/prettier/plugin-php/blob/master/README.md
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [prettier/plugin-php/.../**README.md** (master ‚Üí fa6fad1)](https://github.com/prettier/plugin-php/blob/fa6fad1f76b987649c2a49b00dadf181cc4090d7/README.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dz4610u.)
IIRC, phpclasses give away prices every month, including phpstorm subscriptions.
Try [https://github.com/JakubOnderka/PHP\-Parallel\-Lint](https://github.com/JakubOnderka/PHP-Parallel-Lint) instead of php \-l ...
I've no idea if cpanel includes the mobile, but mailparse.so needs compiling \(I've not seen it packaged anywhere yet\).
That‚Äôs some racist ass shit foo
Well, the code is either there or it's not. In node I see it like this: not bundling your node_modules in your node projects is fine for development, keeps your repo small and clean etc., but for deployment you're dependent on npm being up and the packages being uncompromised. It's the same with composer, so I tend to check the vendor dir into git and ship it with the rest of my code.
Well, yes, but to be honest there's a lot of people I don't know. Also, speakers are only half the story - how well the events are run is a big factor.
Have you tried [https://github.com/Weebly/phpstan-laravel](https://github.com/Weebly/phpstan-laravel)? I don't have any experience with it (or Laravel), but it might help..
&gt; So whats the purpose of braking count() ? FFS nobody broke `count()`! You've been told this over and over again. The only difference in how count works currently and how it worked pre 7.2 is that it now issues a warning to your logs. If you're treating warnings as fatal in production, that's your own stupidity. You're being given plenty of notice that in a future version of PHP we might _fix_ `count()`, and you might want to patch your shitty hacked together software that is doing something incorrectly in the first place.
Man, I just don't get this guy....
&gt; The downside of adding more tests is that they also cost time Which is why you should balance 90% unit tests 10% functional tests. We even have an optional functional test that we run per week instead of per push.
Isn't CodeClimate just a proprietary webservice to run PHPMD (when used for PHP projects, that is)?
Well done! I often say unit testing is like brushing teeth, you need to do it daily or your code will stink no matter what. Are you going to use Jenkins ? Travis ? Code review using pull request is really awesome. It prevented tons of crappy code and migration to go live.
It will probably be Jenkins based, but I'll wait with reviewing the options until I know I can actually get to implement it. Otherwise it's truly wasted time.
You'll take dick in the ass any day.
As long as this stuff will be count as "mastering", PHP will be viewed as inferior language. &gt; I‚Äôve lost count of the amount of times I‚Äôve seen double quotes when in reality single quotes would have been better instead. Dude, grow up. Find yourself other matters to worry about. 
Sorry for the late come back. That screenshot is basically what's not working for me lol. This is what's happening for me; &lt;?php namespace PHPSTORM_META; override( \Psr\Container\ContainerInterface::get(0), map(['' =&gt; '@']) ); override( \ACME\Database\Manager\EntityManagerInterface::get(0), map(['' =&gt; '@']) ); Comparing that with Atlas and it looks pretty much the same. Using it in an example yields this; $entityManager = $this-&gt;container-&gt;get(EntityManager::class); // entity manager is type hinted perfectly (container works with 1 argument) $invoice = $entityManager-&gt;get(Invoice::class, 2); // It does not recognize invoice since there's two arguments $invoice-&gt; // Sad days As i'm typing i get more and more interested in the problem as it clearly works for you, and I'm thinking it might be that I apply the meta override to an interface, but you're using an actual class (sounds stupid if it works with 1 vs 2 arguments, but hey i'm out of other options). I'm going to try applying the meta to the class and not the interface later today, and see if that makes a difference.
&gt; PHP‚Äôs string in double quotes actually let you inject variables into them to be able to produce a new string. This actually requires extra processing (nothing that will destroy your servers but if your entire application made use of double strings you could start to have a noticeable amount of time spent processing them) Have you got a source for this? Because from reading I've done this isn't true. Since I've asked for a source, [I'll provide one of my own](https://jonczyk.me/2016/10/23/phpyths-buster-great-string-performance-test/). As far as I can tell it's just one of those things that may have been true a decade or so ago, but no longer holds
he's right about the title. Do you call string concatenation master level technique? How do you call DI, TDD, DDD, etc? PHP Magic? And the part where you said that double quotes generate noticeable amount of processing time. That was great! Did you actually ever saw that or it's just some other magic? [https://jonczyk.me/2016/10/08/phpyths\-buster\-single\-quotes\-faster\-double\-quotes/](https://jonczyk.me/2016/10/08/phpyths-buster-single-quotes-faster-double-quotes/)[https://jonczyk.me/2016/10/23/phpyths\-buster\-great\-string\-performance\-test/](https://jonczyk.me/2016/10/23/phpyths-buster-great-string-performance-test/) &gt;Honestly you're the kind of developer that makes PHP seem inferior because you're simply a knuckle dragging idiot who feels threatened by an article. I don't think that he feels threatened by this "master level" article, he's just right.
Threatened? By this "Fisher-Price: my first String" article‚ÄΩ
&gt; _it's just one of those things that may have been true a decade or so ago, but no longer holds_ Also known as [Cargo cult programming](https://en.wikipedia.org/wiki/Cargo_cult_programming).
**Cargo cult programming** Cargo cult programming is a style of computer programming characterized by the ritual inclusion of code or program structures that serve no real purpose. Cargo cult programming is typically symptomatic of a programmer not understanding either a bug they were attempting to solve or the apparent solution (compare shotgun debugging, deep magic). The term cargo cult programmer may apply when an unskilled or novice computer programmer (or one inexperienced with the problem at hand) copies some program code from one place to another with little or no understanding of how it works or whether it is required in its new position. Cargo cult programming can also refer to the practice of applying a design pattern or coding style blindly without understanding the reasons behind that design principle. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
The source is a multitude of articles already published on the Net, sort of "25 things you didn't know about PHP". just google for php single quotes processing and see. I still question your approach though. From the other article, &gt; And the winner is‚Ä¶ not sprintf, for sure. There is no winner still. There are no real life circumstances where you will notice the difference. People tend to take such statements as "don't use sprintf" and it would be just stupid. A tool should be used if it's suitable/convenient, not it it's a billionth fraction of second faster. Such tests out of the blue are no go as well. Ok, you want to disprove a nasty rumor - that's fair. But who asked you to compare different ways to concatenate? Who cares whether sprintf is faster than dot concatenation? Why waste your time doing tests? Why waste my time reading the tests results? As long as string concatenation is not a bottleneck (and it will never be) its performance shouldn't e your concern. I apologise if my comment sounds harsh, it is not my intent. I am just passionate about the reasons why people do performance tests. A performance test should be always justified, caused by the results of profiling showing you a certain bottleneck. 
PHPCE 2018 is held in Prague this year: [http://2018.phpce.eu/en/](http://2018.phpce.eu/en/) CFP is still open till the end of June: [https://cfp.phpce.eu/](https://cfp.phpce.eu/)
Also, the source is a notion that "PHP have to process strings in double quotes and doesn't in single". Which seems legit for the unsuspecting user but makes no sense if you start thinking of it. Of course PHP have to parse any string, at least in order to find a closing delimiter. Actually PHP parses the whole script, and there is no way to magically jump at the end of the single quoted string at once. It will be parsed as well. Not to mention in the end everything will end up in bytecode, where are no quotes at all. In my opinion, such a reasoning is better than blunt tests that measure a billionth iterations of doing nothing. 
&gt; The source is a multitude of articles already published on the Net, sort of "25 things you didn't know about PHP". just google for php single quotes processing and see. I've always *heard* that it's faster to use single quotes, but that's kinda my point. I've never actually seen it backed up by benchmarks. &gt; Such tests out of the blue are no go as well. Ok, you want to disprove a nasty rumor - that's fair. But who asked you to compare different ways to concatenate? I agree, I'm not really sure why the author of that article decided to throw in other comparisons. Personally, I'm a fan of double quotes for their convenience, and I'm aware a lot of people are a fan of single quotes for their own reasons. But I don't really understand pushing performance as one of those reasons, when as far as I can see there's no gain to be had anyway. &gt; As long as string concatenation is not a bottleneck (and it will never be) its performance shouldn't be your concern. Definitely agree with this. Performance tests for micro-optimizations are often pointless when the performance of your application will most likely be dragged down by something more important. Which just makes the random comment on double/single quote performance in the OP article seem out of place anyway
If you have time, rebuilt it. It's better than updating it because you may use different techniques, different logic and in the end it may work/look much better than in the previous version.
I just did a search for PHP in /r/programming. Yup, no one ever actually says "here is why PHP is bad" just that it is, and no one uses it, and everyone knows it's bad, and you can't have a career in it.
At our company, we use the PhpStorm plugin \[**Php Inspections \(EA Extended\)**\]\([https://github.com/kalessil/phpinspectionsea](https://github.com/kalessil/phpinspectionsea)\). I can recommend it.
I haven't seen that. Thanks mate I'll give it a shot
Over here, we use [grumphp](https://github.com/phpro/grumphp) It's configured to run: - [PHP CS Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) - [PHPSpec](https://github.com/phpspec/phpspec) - [PHPStan](https://github.com/phpstan/phpstan) - [PHPParser](https://github.com/nikic/PHP-Parser) - [Infection](https://github.com/infection/infection)
Does YouTube even have an API that would allow for something like this? If not this is very difficult to do.
It'd almost certainly be easier just to store the relevant information on your own site and display it from there rather than harvesting it from YouTube.
Someone whipped this together for me like 5 years ago but I can‚Äôt find it anymore. Maybe things are different today. Thanks for replying. 
Maybe I'm wrong and it's simpler than I'm thinking but I've tried this before with sites like Amazon and it breaks constantly. Might speak more to my abilities though rather than the concept. Good luck in your quest.
Roger that. üëç
This is awesome. I've been releasing a lot of little side projects in Node lately because serverless is such a simple, cheap way to host them, but this makes me want to come back to PHP.
Just use https://github.com/CODESIGN2/func_phptest and roll how you want to without the opinionated frameworks. Lambda is a funny beast. Too closed to be useful. I'm holding off on serverless until OpenWhisk or OpenFaaS get some cloud providers offering auto-scaling solutions with them. Once that is generally available, everyone is going to use serverless, but I think less people will use Lambda or Azure FaaS. The only other concern I'd have is that existing serverless solutions make it pretty easy to re-use existing code in very efficient languages. If I'm understanding correctly, PHP could cost more than up-cycling existing C, C++, Java, or other systems languages (including Rust &amp; Golang). Perhaps it's finally a use for node though that doesn't help PHP much. Still great for some use cases including you only knowing PHP. I Enjoyed reading.
I appreciate the comprehensive nature of the FaaS summary, and will be giving your software a go as soon as I‚Äôm back on front of my computer. Good job!
Fully synced? Are you are referring to how the containers access the code? I use the volume tag in the docker-compose.yml file so syncing is handled by docker-compose. The vendor directory is inside the project root that is synced with the containers, it all comes in around 800MB. Changes that are saved in a file are available as soon as I reload a page so I haven't noticed any delays caused by syncing changes to the containers. Ah, but I'm not running with Xdebug on as standard. I only run with Xdebug when profiling or dealing with a particularly nasty bug... My Setup: MacOS High Sierra, MacBook Pro (Retina, 15-inch, Late 2013), 2GHz Core i7, 8GB DDR3.
Version 3.0 of php\-school/cli\-menu has just been released: [https://github.com/php\-school/cli\-menu](https://github.com/php-school/cli-menu) &amp;nbsp; The project featured here a short while ago and received a lot of positive feedback, a lot of work has happened since then so I thought I would link it again and show off some of the new features: &amp;nbsp; \* Inputs \(number, text, password\) for gathering and validating data from the user. Easy to create custom inputs as well \* Split Items \- display multiple items on one row of the menu \* Abstracted out IO so it can be used with streams other than STDIN/STDOUT \* Custom control mapping \- Now you can map any keypress to an action, eg pressing X will close the menu \* Added alt text to ascii art item to display when terminal is too narrow for ascii art \* Added CSS like borders \- each border can be configured with a different size. \* Added an option to auto centre menu in the terminal \* 255 colour support, with automatic and manual fallback to 8 colours \* Lots of optimisations, code cleanup and bug fixes \* Dropped 5.x and 7.0 support &amp;nbsp; There are more additions as well, check the change log for the complete breakdown. &amp;nbsp; There are a couple of BC breaks noted in [UPGRADING.md](https://UPGRADING.md) \- the one that will affect most people is the way sub menus are built, but it should be relatively simple to fix, there is an example in the upgrading guide. Also the \`CliMenuBuilder\` has moved namespace. &amp;nbsp; I would like to say thanks to u/Lynesth for they contributed a lot of the new features ! \- one of my favourites is the ability to use the menu to draw \- checkout the example at \`examples\\draw.php\` &amp;nbsp; Looking forward to the feedback, thanks!
[removed]
I once set up a performance playground for testing HTTP/2 stuff, I used a self-signed certificate and Aerys for testing, here's the repo, not sure if it helps: https://github.com/brendt/web-performance-playground
Cool. Will keep an eye on it!
&gt;&gt;&gt; And take any framework documentation with a pinch of salt, their objective is only to help people learn the framework. Leaving aside the health implications of adding salt to your diet, the above quote really sums up the article. It applies to Symfony as well as Laravel. Use the docs to get started then if you encounter things that don't feel right, change. 
Just get yourself some code in PHP. Most likely you'll be able to read it without a problem. So you already know PHP. HTML is not mandatory but it's better to have at least basic knowledge, but depends on particular tasks. Same for SQL 
Shouldn't be too hard to pick it up. A lot of things are very similar. I'll plug my book since it contains a tutorial that builds an application from scratch ([Professional PHP](https://patricklouys.com/professional-php/)). Code is on [Github](https://github.com/PatrickLouys/professional-php-sample-code) if you want to have a look and compare it to Java.
You don't need to know HTML to learn PHP, but it's extremely useful. PHP doesn't have the concept of multithreading integrated, but there are creative ways around it. Be careful with trying to write Java in PHP. There are differences between how you approach the same problem, and not only syntactically. 
I was about to comment on the same quote. I have a similar sentence in a current draft for a blogpost, but the example is from the Symfony documentation. Too often those documentations are taken as gospel by developers.
Excellent article, concise and straight to the point.
Fascinating and I look forward to seeing how this project evolves!
I had to take your comment apart a bit in order to fully understand it, and learned some stuff along the way. Thanks for the insight and the direction it lead me. [characterization tests explained](https://en.wikipedia.org/wiki/Characterization_test) [characterization tests implemented](https://michaelfeathers.silvrback.com/characterization-testing) [dependency injection explained](https://www.javaworld.com/article/2071914/excellent-explanation-of-dependency-injection--inversion-of-control-.html) [dependency injection implemented](https://coderoncode.com/dependency-injection/design-patterns/programming/php/development/2014/01/06/dependency-injection-php.html) [PSR-11](https://www.php-fig.org/psr/psr-11/meta/)
Sure. My point was to pick one. From a learning PHP standpoint I don't think it really matters which one. Although, honestly I'm still a fan of CI, although I tend to wait for technology to become fairly established before diving in, so I'm sure there are other awesome ones out there that I haven't considered. I've seen too many tools come and go too rapidly over the years and have grown a little conservative about learning something that I'll abandon in a year. I'm curious what you think are the best ones these days? Probably time for me to reevaluate.
I would replace those `GL_TRUE/GL_FALSE` with simple `TRUE/FALSE`. No need to adopt every weird type from OpenGL.
&gt; As far as I can tell it's just one of those things that may have been true a decade or so ago, but no longer holds Yup, not true since PHP 5.6-ish or so. Maybe earlier.
Symfony and Laravel are the leaders. If he comes from a Java background, I'd recommend op to check Symfony. Also, it's not that recent
&gt; A double quoted string is often a very misunderstood part of PHP. Ironic. &gt; This actually requires extra processing (nothing that will destroy your servers but if your entire application made use of double strings *you could start* to have a noticeable amount of time spent processing them). This was stated elsewhere in thread but people are like "is this true, I think it's kind of is not true, maybe it's not true", so I wanted to be more categorical: What OP says that double quote strings require more processing is absolutely false --- In fact, the opcodes generated for variable interpolation by double quoted strings (and HEREDOC) are executed slightly (very slightly!) faster than concatenating separate strings with dot, or any other method. Source of this claim by a kick-ass PHP core developer: https://nikic.github.io/2012/01/09/Disproving-the-Single-Quotes-Performance-Myth.html 
I use exakat : https://www.exakat.io/ (disclaimer : I also write it).
In the examples section where you direct people to clone; " git clone [git@github.com](mailto:git@github.com):php\-school/cli\-menu.git" doesn't work unless you have correct access to the repo. Should be "git clone [https://github.com/php\-school/cli\-menu.git](https://github.com/php-school/cli-menu.git)"
This doesn't apply to all but those kind of coders usually care more about flaunting their shiny new tools than the products they made out of those tools.
I can never tell how you should use it in a Symfony application. Should you just have one and pray that all the choices you make for it, like the date format work for every single class you serialize, or should you create one \(in a factory service?\) for every class / hierarchy you need? Not everything can be solved with groups.
A very good advise, btw
What folder are you running the analysis on? It should only be running on the source code that contains your codebase.
[https://github.com/xobotyi/emittr](https://github.com/xobotyi/emittr) emittr is a small dependency free 7.1\+ library that gives you events functionality. It wont bring asyncronious execution, but will let you the best way to separate your code.The main feature of emittr is global emitter with which you wull be able to assign event callbacks even if class weren't autoloaded yet. Main features: * Assign event callbacks even if class yet wasnt autoloaded or even declared * Static and non\-static variations of event emitter
You use both phpstan AND psalm? Are there benefits for both?
I feel that at the moment, the problem is that there's a big gap between simple PHP, and decent PHP. Now it's all frameworks, which add a LOT of extra stuff, which actually isn't too hard, but even for me it's sometimes too much to keep in mind at all times. I have no idea what direction you should start in. So I'd say to read and read and read and try and then determine for yourself what "hard" is. This might be a useless post but it's kind of the truth. 
If you need a class to be serialized differently you can create a custom normalizer and register it
Oh god yes. Don't get me started on the issues with images suddenly duplicating and filling up the entire hard drive, or the fact that Magento 2 still doesn't fully work off the shelf, and you have to customize it to make it work. And no migration paths that work well, horrible 3rd party support, terrible tech support, and it's just a big giant pile of not working shit. There are so many e-commerce solutions that are easier to work with. I still have bad dreams about trying to maintain a magento site.
Uhm, feel free to do it yourself if you like. No need for donations or credit. Except if you get a million, then I'd like half a million.
My current workflow on these types of things: Implement version control, dockerize the base server image, bring in Composer, composer in an ORM, build in a presentation abstraction controller architecture, then take the chunks of code and piece by piece digest them in the PAC. 
That's what people are told here, but I don't think there's any proof of it.
Honestly, it feels a little over\-engineered. It's not quickly apparent how to do the kind of deserialization I'm talking about.
There's a french version of this blog post: https://medium.com/@ScullWM/contribuer-%C3%A0-symfony-mon-exp%C3%A9rience-216902cc266c ;)
Man, Laravel haters really do abound. So lame
First coding job btw. Thanks for the advice though.
&gt;I got ‚ÄúStofed‚Äù That's an incredibly rude way to speak of your senior that stinks of contempt and disrespect. Maybe you should consider how little your contributions really mean when you next think of getting on your soapbox and start acting narcissistic.
Ah! Sorry! I see. Might start by popping into a single page script in the codebase and start abstracting the spaghetti into little functions on the page. This starts to organize it, and you can manually test functionality match with mostly copy pasta. Once you've got it slimmed to some functions and their calls, some echo statements with HTML or JS still in it, then look at those functions and consider abstracting them out into a class. At that point maybe make a folder for the script, and a lib folder in the root for the class(es). Grep for links to that script, and adjust the links so that it points to the script in the folder. You could start parsing out the javascript to it's own file, write semantic html, separate out the inline styling, etc and now you've got a module. Work in iterations through the single page scripts until you've got a bunch of modules. Now shit is at least organized in some basic structure, and will make future refactor a big step forward.
Is there a technical reason that you dropped PHP 7.0 support or is it due to lack of ability to support it?
I will investigate! Thanks for sharing
I didn't know Symfony had a serializer. Looks like it might be a start. Without digging in too much at this stage, do you know if it supports the kind of transformations discussed in the article?
You are misunderstanding how the Symfony autowiring works. More precisely, this sentence is false: "And that's kind of the problem, that in Symfony, both constructor and action injection uses magic that resolves dependencies automatically based on their type, rather than it being a clear static contract between two human sides who can make a better judgment about satisfying a dependency than "oh, it's of that type"." Autowiring does not rely on any magic, it does not inspect your types, it does not try to match "magically dependencies". Autowiring works with typehints and basic services ids. Let's take an example. Imagine you have the following classes: ``` class Mailer implement MailerInterface {} class RegistrationManager { public function __construct(MailerInterface $mailer) { // ... } } ``` You are assuming that because Mailer is implementing MailerInterface, then the autowiring is able to inject a Mailer instance in RegistrationManager. However, it works differently. A service is a link between an identifier and an instanciated object. In Symfony 2, these identifiers were arbitrary string. Starting with Symfony 3, it is possible and common to use the class name as a service string (instead of having a service called `mailer`, you have a service called `App\Mailer\Mailer`). This does not change how the container behaves, it just introduces a convention on how to name services. Autowiring is based on this: when a definition lacks an argument, it looks at its typehint and tries to find a service called *exactly* like the typehint. In the previous example, you would need to define a service called `App\Mailer\MailerInterface` linked to the `App\Mailer\Mailer` class for this to work. This **won't** work magically. In many cases though, the autoloading of all your app classes as private services let you not have to configure each service by hand. But it works exactly the same. THe Symfony autowiring is **determinist**, no magic invloved.
Most projects have so much internal politics and process that it's just not worth people trying to contribute a single patch. If you're looking to become a regular contributor, then I guess you're willing to jump through the hoops \(as OP did with the back and forth with core devs\) \- if you're just someone who's fixed a bug or added a feature for their own purposes, it's just not worth the effort. I once replied to a feature request on a major framework with my own slightly dirty implementation just to help the requester out. After getting a load of emails about the patch, I refactored it, added unit tests, and sent back a scanned \(!!\) copy of the project's CLA... then never heard anything back. I ended up having to support a dozen people using my patch by email for about 2 years.
Not sure really as that decision was made before I joined (you'll have to wait for /u/aydin_h to answer this) but I think the only thing currently making 7.0 fail would be nullable type and void return type.
That's precisely how I thought Symfony autowiring works, and all my points stand. You seem to have extrapolated some very different meaning from my words. You can't say "it doesn't inspect types, but works with typehints". The fact it inspects your argument typehints is precisely what I meant. Also "magic" doesn't mean "non-deterministic", I don't know where the subject of determinism came from. "Magic" means the code works through lack of, or through implicit intent. There's no explicit code wiring *instance X* to *argument Y*. Instead matching is done by qualifiers and type names. That's magic. And it leads to all the architectural problems I already listed, so I'd rather not repeat myself.
Emmet Git Package Control Git blame Personally I like Emmet when I am designing any page. You can [write *SUPER\-FAST* html with Emmet](http://acmeextension.com/write-super-fast-html-sublime-emmet). Try It once if you are a web developer and you will love it. Also use Git blame a lot as we work on a project where multiple developers do changes and some time we need to track the changes.
How does this differ from Google Cloud's App Engine (which supports PHP)? That's serverless, no?
Looks good. Can you listen multiple times to the same event? Docs state you can stop propagation but I don't see any example of this yet.
I know you're not experiencing the problem but they finally planned a fix for it scheduled next version, 18.2! They updated the issue yesterday evening.
Mostly because it's more fun to develop with newer versions of PHP, and yeah the active support finished.
No. Think of GAE as managed hosting on steroids. Even deploys are managed by Google, only initiated by you. Which can give you autoscaling and zero downtime deploys. FaaS is just a dumb CPU and memory without real local persistence. You build code for a limited lifecycle and expect on demand scaling for that code.
I will surly give u Some lol 
Really good code quality and tests. Good work!
This is sadly unusable due to the central/static design of the emitter, which makes this library extremely hard to integrate and later (if needed) to migrate away from.
Yes, sure.I'll improve docs this weekend. 1\) You can listen single event multiple times with same listener;2\) Listener receive event object as 1st parameter, which has payload, and method to stop or continue propagation;
How is this a fair comparison? It's clearly pro-Drupal and contains a lot of FUD!
Nothing is secure, but the speed at with patches are released is important, which is responsible for number like sucuri released. "**Sucuri reveals that 78 percent of the total number of hacked websites it investigated were WordPress sites, with Joomla in a distant second, taking up only 14 percent of the data sample. Further, six percent were no\-CMS websites, 5 percent were running Magento, and 2 percent were using Drupal.**"
Weak References FTW . 1. They're the only sane+reliable way to handle decoupled listener/observer structures 2. They're awesome when you want to avoid multiple mutable objects for some underlying resource (e.g. a database row) and don't want to use lots of memory.
That‚Äôs why here. Looking for a perspective from pro Wordpress people. 
Sylius is over-engineered right up to the point where you have to work with it and start to bend it to your will. It's a framework, not a shop engine you install and run with a few commands.
Renaming? Sure. Most flexible is writing own normalizer where you can put whatever logic you want. But I recommend JMS, which has this out of the box
Yeah man OSS is all about that seniority and hierarchy. How dare you unimportant peasant speak out against your superiors.
Probably the fact that a large majority of sites are running WordPress instead of Drupal? Percentage should be relative to the number of installations
All you pissant nobodies think you can just walk in and be somebody. Not only do you have no idea what it took for the people at the top to get where they are, you don't even care; you're so narcissistic it simply doesn't matter. You expect to just show up and be treated the same as the Gods of the industry without a single claim to fame to your name because you're an entitled little Redditor with a handful of upboats.
But Drupal it more complicated and harder to use. That's why it's enterprise ready. Everybody knows WordPress is only for blogs. It simply doesn't scale. Mind you that scaling Drupal most often jst means putting Varnish in front of it. You certainly can't do that with WordPress!
This is lolphp.
"my friend sent me this"
FaaS is an extreme micro-services architecture. If there is a bloated node app, it should probably be broken apart to use FaaS.
u/the_alias_of_andrea This is off-topic, because I don't know anything about this topic, but whenever I see your name on an RFC I always think of the quote where you claim to one day have just attempted compiling PHP and everything flowed from there. I wish I could understand PHP internals well enough to make improvements, but although your quote is inspirational, because it makes it seem so easy and approachable, it's obviously not true that it's that easy and doesn't tell the whole story. I'd really like to know what steps you took after that so I can have a more realistic expectation of what it takes to reach the level you're at now and decide whether I want to commit the time needed to follow in your footsteps.
To be honest, both drupal and wordpress have done a great job of almost single-handedly giving the PHP community a bad name. Claiming that Drupal is in any way secure is laughable.
 /** * @param null|string $eventName * * @return array */ private function _getListeners(?string $eventName = null) :array { return $this-&gt;listeners[$eventName] ?? []; } I suggest removing docblocks which don't contribute with anything that the code already tells you, both the parameter and return types are already in the code and are unnecessary in a docblock. 
More accurately, http://nikic.github.io/2012/07/27/How-to-add-new-syntactic-features-to-PHP.html was my introduction to internals. It would need updating for PHP7 though.
Sweet!
Weak References as in Java for getting Garbage-collected when needed? We are still talking about create the world, hand one request, destroy the world PHP?
Respect goes both ways. If someone Stofed me == 0 respect.
It's interesting because Fabien complained nobody wanted to contribute to Silex that's why he deprecated it. But look at how tough it is to get a single patch into any Senso project... You can't have it both ways.
I think it might be more accurate to say that getting your **first** patch into a Sensio project is difficult. There are quite a few hoops to jump through though it is all documented. Once you break the first barrier then it becomes a bit easier. And most of the core devs seem willing to work with you.
This might be useful. The README states: "One of the generally accepted security best practices is preventing the use of hard\-coded, plain\-text credentials of any kind." That's true if the credentials are kept under version control. But generally .env files are excluded from version control, so in most cases it would not be necessary to encrypt the contents. Or am I missing the point?
&gt; Most projects have so much internal politics and process that it's just not worth people trying to contribute a single patch. By that logic absolutely nobody would ever contribute to any major project...
What the fuck are you talking about? on one hand you have article that illustrates how tough it is to begin to push a single line of code into Sensio's code base, on the other we have Potancier complaining that like "nobody's here to help" with a project. You can't have it both ways.
You're not missing the point. Actually even if the .env file would be tracked by any version control system, it's designed for development purposes only. Your credentials for staging/prod shouldn't be in there.
Well, if the "single patch" you're referring to, is what's describe in the blog post. It was concerning the bootstrapping of Symfony project, in the application Kernel, building the DIC cache, with or without the dev mode activate, and manage differently emitted logs. Doesn't sound to me like a single or simple patch. Otherwise, I've made some "single patch" like this one (https://github.com/symfony/symfony/pull/24006), merged quickly.
I thought it was a clickbait but damn, this is the first time I have seen them...
Those are some funny use of php operators, will try to sneak one or two into my personal projects!
I'll echo that - there is a huge gap between between simple PHP and decent PHP. Many people can only write simple, terrible code and aren't aware that OOP/frameworks even exist, and the people who can write decent PHP probably would like the believe the others don't exist :)
Hats off... That's impressive. Please, don't give any ideas to our overlords who write C for PHP every day... some of them read here! 
&gt; Although, honestly I'm still a fan of CI, although I tend to wait for technology to become fairly established before diving in, Symfony has been around for 10 years. Is that long enough?
Better ideas for our overlords: give us generic types, dammit! Please? PHP types feel so limited compared to TypeScript.
What's going on with `b'string'` I thought the binary literal had to begin with `0b`
&gt; And can you really imagine the world without websites? Oh please, we have come really far. You don't need a cms to build a website. &gt; have handsome amounts of free plugins and modules to help extend functionality and are loyally uplifted by their respective communities. I read: have tons of security issues by allowing third party plugins and themes and not having enough "lock down" on the system as a whole to keep people safe from installing potentially malicious and poorly coded "extensions" &gt; Drupal is built upon rigorous coding standards with tools to ensure secure coding practices. I have looked at both pieces of source code and both are a cluster fuck of mess. One uses Symfony components and hacks around it and the other is matt's creation from when he was 18, that's now held together by "good code in some areas" and a whole hell of a mess in every other area. &gt; WordPress doesn't seem to have entered the security territory yet. They address issues just as fast as drupal. But yes both lack in security, their main flaw is allowing third party extensions and themes with out locking down core aspects of the system, god forbid I mention apple vs android. Android lets you do what ever you want (with some limitations) and apple is so locked down that its hard to (although not impossible to) introduce malicious code via third party apps. &gt; Which of the two is SEO friendly I have yet to meet one person, even those trained in it, that even knows what the hell they are talking about when it comes to SEO. Seems like a magical buzz word to me. This whole article reeked of misinformation and lack of understanding of how to properly code a secure,safe website, let alone cms. They went off on two CMS's that are the most popular with out really diving into the security flaws of both, the biggest ones I pointed out, along with the shotty code bases. 
"Oooo look what I found for the first time ever!!!"
`0b` is for binary integer literals, not strings. `b'string'` is a vestige of lost dreams. In PHP 6 all strings were Unicode. `b'string'` is a non-Unicode binary string. String functions would operate on the byte-level and note Unicode character-level for `b'string'`s.
With a database. Have a table to filters and a table to specify which filters are valid for various product types. create table productFilters ( id int( 11 ) PRIMARY KEY auto_increment, getName CHAR(32), tableColumn CHAR(32) ); create table productTypeFilters ( productTypeId int(11), productFilterId int(11) ); SELECT getName, tableColumn FROM productFilters INNER JOIN productTypeFilters ON productTypeId = ? and productFilterID = productFilters.id WHERE getName iN ( --SANITIZED INPUT-- ) 
Cool... can you point me to where this is documented.?
your co-workers will thank you.
https://wiki.php.net/rfc/binary_string_deprecation
You spelled shank wrong...
you absolute MADMAN
There's Sara's [http://pecl.php.ne/operator](http://pecl.php.ne/operator) \(and maybe somewhere is my even older operator overloading patch [https://www.mail\-archive.com/internals@lists.php.net/msg13134.html](https://www.mail-archive.com/internals@lists.php.net/msg13134.html) still floating around somewhere? \- I guess I lost it and it certainly won't apply anyways anymore\) and well such a thing should work \(while, we don't allow objects in, and don't allow `--`/\+\+ in\-/decrement operators on constants you'd have to put a few $ signs in it ..`.)```
Alright
/me bows I take that as a compliment, thanks
Released isn't the same as established. But I've already conceded that I should give it a shot.
Apparently the Reddit text box borks on pasting that; it seems to remove some '!'s. The box sides would be 5 high otheiwse. 
&gt; // Due to the way C++ operators work, we must use N*2+1 dashes between the I's to get a value of N: assert( I-I == 0 ); assert( I---I == 1 ); assert( I-----I == 2 ); assert( I-------I == 3 );
It's very impressive how well PRs are handled withing Symfony, reviewed and merged very quickly. Some of my experiences with other OS projects aren't very good (including Sensio Framework Extra Bundle) which took months. The worst is Drupal where a simple doc block change is still open after 1,5 years... :')
FIGHT ME!!! &gt; $a = $a +-0-+ 3; // Pew pew pew pew pew hahahaha
Not sure about Laravel but PR's to change the Symfony docs are very welcome and are usually merged quite fast.
&gt; Drupal is a one solution that fits all. I stopped there :D
For keeping them in my personal projects? :D
[I thought it was a joke...](https://3v4l.org/RcvSB)
Not being worth it doesn't stop people from doing it.
ideally your request is a "request" object. if it's not, the first step would be to create an object that parses the request. so on a request like www.shop.com/products/tshirt?color=red&amp;size=s you could ideally call $request-&gt;get() and that'll return an array like ['color' =&gt; 'red', 'size' =&gt; 's'] then when you fetch from the db, pass that request object to your dao / orm / activerecord whatever and do a join like the other comment here. $dao-&gt;getProducts($product, $request)
You can just write plain old PHP and viola.
The documentation is fine (describing how an ORM works with getters/setters). The problem is that developers use it as a blueprint for their own code.
For Symfony at least it would mean wrapping your helper class package into a bundle. Easy enough. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
And that should be the idea of the documentation imo. If thats not correct consider contributing to it to make it better.
Wonder if the reverse operators were introduced by Zend, being an Israeli company, and people being used to writing from right to left.
Have you seen [Ionizer](https://github.com/paragonie/ionizer) before? &lt;?php use ParagonIE\Ionizer\GeneralFilterContainer; use ParagonIE\Ionizer\Filter\WhiteList; $ic = new GeneralFilterContainer(); $ic-&gt;addFilter('color', new WhiteList('red', 'green', 'blue')); try { $clean = $ic($_GET); } catch (TypeError $ex) { // Handle this edge case }
Laravel's validation is pretty good: [https://laravel.com/docs/5.6/validation](https://laravel.com/docs/5.6/validation)
I like to call `--&gt;` the "goes towards" operator: while ($i --&gt; 0) { /* ... */ }
I think Twig and include are both valid solutions, and I use both. It is testable this way, as /u/mv303 mentioned, but the thing that I like about this is that it makes it pretty easy to compose larger templates from different, smaller, pieces using php's built-in templating and a single function. You can use it as part of a makeshift controller, passing template parts into template parts, etc; Though, /u/tleilax is right, it doesn't extract anything, which you'd probably want to do, in some fashion, to make that process cleaner. There are million ways to do anything, I just happen to like this one :)
/dev/null I kid, I kid ...
True. You'd have to access them using array keys, which would would add some clutter to your template. 
1) The API gives you a fraction of the information 2) The API gives you a fraction of the information only for a fraction of the available products.
I would suggest to keep two separate repo because it gets more easier to maintain. and even in future if laravel &amp; symfony road goes on different path then you still can use both if yo want. 
posting was: *** Send an email to team@stackoverflow.com with subject "opt out of arbitration" a link to your profile in the body For more information see the post here, https://meta.stackexchange.com/q/310061/157251 After you send it you should get an reply, Hello, Your request has been processed, and there's nothing else needed on your part. Let us know if you need anything else. Regards, Stack Overflow Team ***
It wont be too terribly difficult, just keep in mind separation of concerns. Write out your core library code, maybe split it into its own library if you need to. Then you can write service providers to interface with with the core code. You could call the libraries `mycompany/symfony\-whateverlibrary` and `mycompany/laravel\-whateverlibrary`
You don't know the half of it!
Your post is art. 
I will give it a shot. Makes sense! Thanks!
Really cool library! Maybe you could also support persistence in it so the state or events could be persisted and recalculated? 
Someone who bumps into Laravel docs and sees eloquent in routes and views will think it‚Äôs ok to do it because it‚Äôs in the docs of a framework they like and respect. But it‚Äôs a terrible idea.
If I‚Äôm correct the second bullet is exactly what Doctrine does. And also if I‚Äôm right this is why it‚Äôs easy to have memory issues on long-running jobs/workers/imports/...
It‚Äôs more than just the docs, it‚Äôs about supporting bad practices that eventually will cause harm. Laravel could easily only support scalar values in routes. Why couple the database with http layer?
Interesting. What are some real usage examples?
Yeah, in practice you need to organize your application to periodically forget all entities and then reset the relevant Doctrine bits so that they forget also.
Sure! üòÇ The documentation would only have one line: DO NOT USE THIS FEATURE 
I'm not sure I understand. So it's like PHP extension that allows you to draw objects?
&gt; Is it possible to architect a single composer package that will work in both Laravel and Symfony? Or do I have to make two separate versions? It‚Äôs basically a single helper class. Sure, I did the same for Nette and Symfony. It depends if they really use some framework code, or not. If so, just create container integration for both packages: - src/Adapter/Symfony/YourPackageNameBundle.php - src/Adapter/Laravel/YourPackageNameServiceProvider.php And that's it :) I'd like to see the package to give you better advise, not just guess. 
I use it pretty much everywhere where I need to be stateful. As I've said it in the "Why" part of the readme, as soon as an object has a status or state property I use a fsm. Real examples from my work includes defining workflows, wizards, import processes, pipelines, complex form processing, etc...
There's a typo in the last code example. On the 1st line `$this-&gt;app-&gt;extent` should be `$this-&gt;app-&gt;extend`.
It allows you to build graphical applications with windows, scrollbars, buttons, sliders, checkboxes, menus, etc.
This is copy-pasted from Jeffrey Way's SOLID Principles series on Laracasts. Same examples, same wording, it's a ripoff with some in-depth aspects removed. Don't you think it's nicer to credit the source? Just asking. :)
At this point even Robert Martin is sick of SOLID.
I see
cooool !! i hope this get developed more :) 
pointless examples which not demonstrates anything at all.
thanks for your feedback.
Thanks, yeah I‚Äôm going to end up with three packages. One for the core code, one to adapt it into Symfony and the third to adapt it into Laravel.
All the examples made sense in Jeffrey's videos, which are a great kickstart to SOLID. OP is just ripping off every tutorial possible and posting it on Reddit, without context or any added value whatsoever.
Absolutely not: [https://github.com/andlabs/libui](https://github.com/andlabs/libui)
So these are native apps right nothing like Electron or anything?
Laravel is just so much more elegant to write, this is opinion, obviously. Laravel requires a lot less configuration, and the performance is the same or better. The application we are rewriting doesn‚Äôt really take advantage of anything Symfony specific. The original application architect used Symfony but didn‚Äôt really know it that well or use it properly: Raw SQL in strings in controllers, commands instantiating static methods written in controllers via call_user_func_array, weird stuff. Clearly, that answers why we‚Äôre refactoring at all, vs why Laravel. Also, we use a lot of queues and command-line jobs, (scores of threads on scores of servers) to multi-thread our app - and Laravel has awesome built-in, elegant support for this. In addition to the above, several other in-house apps use Laravel, so we want to standardize on one framework. They‚Äôre both great PHP frameworks when used properly.
You should start posting __original__ content, instead of stealing other peoples work. You are a disgrace to the community.
Knp University for Symfony was an excellent learning resource for my team. 
Because that's a sensible thing for a server side scripting language to be doing?
That‚Äôs not the php ext?
Tell that to the very popular client side scripting language rocking about on the server these days.
Hahaha oh believe me, I do :) Of course the "but" is that Node actually makes a degree of sense. Keeping your process alive and in-memory and lightweight is a better thing for many purposes than having to create the world on every single request. It's let down by the insanity of its package management and dependencies, mind.
Because of \&gt; Note that switch/case does [loose comparison](https://secure.php.net/manual/en/types.comparisons.php#types.comparisions-loose). I rarely use \[\`switch\`\]\([https://secure.php.net/manual/en/control\-structures.switch.php](https://secure.php.net/manual/en/control-structures.switch.php)\) statements, and would not recommend to do so.
Hello, looks interesting. I'm just installing this and I have a noob question: how to install this on Ubuntu? Is there any already made package for the libui required dependency or do we need to compile the libui from source as well? Thanks.
 switch (true) { case (1 === $someVariable): doStuff(); break; } Interestingly, switch (true) doesn't work in C. Not 100% sure you could use this to enforce strict comparison instead: declare(strict_types=1); 
You can‚Äôt. 
This is crap. Switch is good as is and has it's own specific use case. It's much easier to remember "default" than "_". This is why we have all the readability issues in other languages, we have to remember what each underscore (or another fancy character someone thought was cool) means. Fuck that.
https://www.reddit.com/r/PHP/comments/8kd5pk/10_weird_operators_in_php/
I dont get it
The ext is not dead ... the upstream library is sparsely developed and recently underwent some changes that have broken the build with the latest version of libui. Making it compatible is on my list, and will happen on some weekend in the near future ... there is an open issue about it ...
Yeah. 
I said, pretty much. There has been how little movement in the UI in PHP in the last 10 years? It's not like UI development in PHP is suddenly going to become way better. Which is what some people will be thinking if they see something they think is new and "under development".
&gt; Interestingly, switch (true) doesn't work in C. `switch` in C requires the `case` conditions to be constant so they can be computed at compile-time. You can have `switch(true) { ... }` if all your cases are constant, but then the compiler will most likely optimize the `switch` away entirely and leave only the matching case.
What is your reasoning behind wanting to change from using switch to using match? It seems to me the differences are purely syntactical and arbitrary. Did I miss something in the documentation otherwise?
Congratulations. You've saved having to type a dozen characters and made code less readable and moved it further from the standards that other languages have.
It's all a joke.
There are no reverse operators. It's a creative play on whitespace and existing operators, for ex. the "reverse object operator" is a less than comparison with a minus. The "reverse array operator" is just a "less than or equals" comparison. It's all valid syntactically, but it's not what any of the article says. Except for "b" before strings. That's indeed literally syntax that does nothing, but that's for legacy reasons.
Breaking in each case is the most common action, so it should be made the default. I would use switch statements, but it takes more lines than an if statement.
When someone gets round to writing the patch and submitting the RFC. Hey! You're someone! When are you going to do it?
There are no reverse operators. It's a joke. It's syntactically valid, but combinations of different existing operators.
No. electron is just webkit in a window, readeing html and javascript. Electron executable weights 80Mo as minimum. This more meant to construct system application, it isn't a web viewer. It can be more compared to ncurse, or gtk. 
Shitty arguments by shitty people. Unfortunately for you, this is probably something I'm able to do. Give me some time to find the switch statement code in the 20k file source.
any screen shots ? 
php\-cli is another beast that a server language. Think unix and bash scripting. \-\-\&gt; #!/usr/bin/php ./myprog
There is some there, it just bind to the system look: [https://github.com/andlabs/libui#screenshots](https://github.com/andlabs/libui#screenshots)
I do just that. It's like the old saying "just because you can, doesn't mean you should"
Interesting. Thanks for the examples. I haven't used states that much yet. But I will keep it in mind.
It's for writing desktop applications using PHP.
Flyimg does exactly what those stack overflow answers are suggesting.
In theory, on-demand resizing should be easier to manage, but more expensive since storage is cheaper than processing power. I decided to resize images on upload for my latest project since that's what I am used to do, but I don't love the idea of maintaining a huge library of resized variants that is prone to change on a complex project. I am very interested in how much it costs nowadays to do on-demand resizing on, say, AWS Lambda and S3 (or what are some other approaches to do this).
Depends on your use case. If it's having exactly one image size then sure, do it on upload. If you want to provide any sort of authoring (cropping), then you'd want to keep the high-res original.
I highly recommend Cloudinary. It does image transforms on the fly, is fairly cheap. My company uses it for a large amount of images.
Got it. Thanks... I've successfully built the libui alpha 3.5 version from source like hinted in the Archlinux's libui\-git package and the UI extension v2.0.0. And it works. No matter the project state it's still informative to see something like this in action \\o/[https://giphy.com/gifs/jIZecsJEswnCiWhqfz](https://giphy.com/gifs/jIZecsJEswnCiWhqfz)
\&gt; UI without threads Oof ouch my hanging UI.
I still can't believe that in 2018 people are still using Wordpress in such numbers and that Wordpress, as far as I'm aware, hasn't really changed in the last 10 years since I got into web development, considering it's open source and has such influence I would have thought they would have done something to improve it significantly under the hood in a major version update. Also, that people shit on Joomla (fair enough) but have some kind of elitist cult mentality towards Drupal for the past 10 year, where "Joomla is too confusing for the end user" yet somehow "nodes" are supposedly more friendly than "content" and "I'll shove a few different callbacks and hooks here and see if any stick" is better than Joomla's attempt at MVC, even if it was designed 10 years ago and a bit clunky.
You seem to be equating "once only" with "on upload". They are not the same thing. Why not size it on demand and cache the result? You could also resize it in advance, separate from both upload and on demand. Sometimes you may need the user to crop and resize it on upload. It just depends on what you are trying to achieve. 
I did something REALLY stupid in my past. I have 2 different domains, same server, and instead of dealing with the cross document root saving I saved the images to the database in a blob field. I mean it worked... But God was it stupid. I did the resizing at request time (query string with id and it allowed for any resize dimensions and crop type) and I would cache the output of the resize but moving that database anywhere was nuts. Every image upload was in the database. It got massive quickly. 
I wrote something to do this on the fly years ago for a WordPress blog that was thumbnail image crazy - nice thing was - once the cached image was generated further requests didn't invoke PHP at all thru use of Nginx. https://github.com/magnetikonline/thummer
Nice. Good to see GUI frameworks getting another run in PHP - I do see a place for them.
I would agree that it depends on the scenario. WordPress creates a ton of image sizes by default, which is often overkill. As far as packages go, Laravel uses Intervention Image, which is great:[http://image.intervention.io/](http://image.intervention.io/)
Could also be a medical thing. It sucks look for a PHP job. hah.
hi-dilly-ho from Minnesota, neighbor-ino! 
$dr_beat-&gt;page();
I use Lambda to resize many millions of images per month into many different sizes. My Lambda bill is about $80.
I don't want to argue the toss about it. If you think PHP is not a good language for X, there probably isn't any convincing you ... but for those listening in on this conversation ... &gt; There has been how little movement in the UI in PHP in the last 10 years For most of the last 10 years PHP 5 has been king ... Asking PHP 5 to run a ui loop in whatever form was always a little too much: PHP 5 cannot do anything without allocating some memory, and then executing inefficient code all over that memory ... &gt; It's not like UI development in PHP is suddenly going to become way better In every corner of the PHP world, things have moved on in leaps and bounds as a result of PHP 7 and the changes that NG made to internals. PHP 7 is *fast* by any reasonable standard - not just fast compared to previous versions of PHP - as it a result it has *become* reasonable to ask it to do things like run a ui loop. That's the reason why I spent my time writing the ui extension. &gt; Which is what some people will be thinking if they see something they think is new and "under development". libui, the upstream library that the ui extension relies on, is, like most oss software, developed in the authors free time. When I first wrote the extension I opened some pull requests upstream and they sat there for many many months, I learned this was because the author doesn't actually have much free time and or had employment issues. These issues have recently resolved themselves and the upstream library is being developed quite intensely. libui is *alpha* software, that means it's likely to change and change rapidly and unpredictably, I believe there isn't even a guarantee that semver will be followed until alpha 4 (currently on 3.5) ... this effects the API in PHP obviously, it doesn't make much sense, having seen a flurry of activity upstream, to sit down straight away and write up all the changes, because they are liable to change. The ui extension *is* being actively developed, but there isn't a team of people behind it like there was gtk, there's just me ... and I'll get around to fixing the *alpha* software, when it's appropriate to do so ... It's easy to repeat the mantra "PHP is no good for X", and then ask the question "why don't you just use X?" ... however, answering the question "*Is* PHP internally suitable for X?" is much more complicated, it requires expertise, thought, and maybe testing ... I'm not trying to change anyone's mind, and have no interest in arguing about any of the points here ... take it or leave it, nobody is twisting your arm ...
&gt; In theory, on-demand resizing should be easier to manage Nice story.
I imagine him speeding off to offices, running inside with an official reflective uniform on and then fixing bad code in record time.
Why is McAffee telling me: "Woah, that download is dangerous! We found that there might be viruses, spyware, or other potentially unwanted programs in the file you are trying to download Filename: Plikli4.0.0.zip Domain: www.plikli.com" Can you upload the code to GitHub? 
&gt; next time when you try to use strlen() and not \strlen() and you get errors, does that mean your application has poor design ? No, because that's literally not something that can happen, because I'm not an idiot, so I'm not going to blindly upgrade a code base without any testing. ...you know, like you did.
&gt; So whats the purpose of braking count() ? Nobody broke `count()`. The only thing that was broken is your app, and *you* broke it by upgrading it blindly. Try and learn from your mistakes.
Meh... this seems really no different than PHP GTK, which I dabbled in and then came to the conclusion that PHP was really not designed as a language for this sort of thing. Just because you can, doesn't mean you should.
\&gt; If it's having exactly one image size then sure, do it on upload. I think this should read "If there are known image sizes". You can do it offline, if there are a lot of different image sizes in your application. I'd always suggest keeping the original, later you may want to add additional sizes and that'd be done best using the original image.
Need more info. What are you actually trying to do? Why do you need to use php You can make a static website about astrology with just html and maybe some css if you don't want people's eyes to bleed.
Yeah its for a client. I was gonna discuss it with them but i needed to do some research beforehand because client asked me for a approx cost of building it. 
PHP did 9/11
I don't want to sound unnecessarily critical here, but I think the way you're communicating this to us probably indicates that the project won't be successful with your client. The main reason for this is that, completely ignoring the dev required for a moment, the skill set of gathering the correct requirements from the client is the same skill set which would have allowed you to explain your idea better here. "I need to develop an astrology website," isn't how you'd ask this question. A better question would have been along the lines of: &gt;I'm a beginner PHP developer. I've taken on a project for a client which involves building a site about astrology. It needs to have the following functionality: &gt; &gt; &gt; &gt;\- User registration / login / account management &gt; &gt;\- There will be various types of data stored about astrological entities/mechanisms. **These \[will|will not\] have to be manageable via an admin interface by \[client\].*** Some examples of this data, as provided by my client, would include: \[examples*\] &gt; &gt;\- Based on the astrological data stored above, the application needs to carry out predictions. *Some examples of these predictions, as provided by my client, would include: \[examples\]* &gt; &gt; &gt; &gt;The project \[would|would not\] include any e\-commerce functionality. As a beginner, if I take this on using PHP, where would be the best place to start? I'm probably beating a dead horse at this point, but if you want the project to be successful, you need to get into the mindset of understanding the client's needs **long** before you're asking what language/framework/libraries to use. In addition, if you try to gather these requirements from the client, and he/she isn't able to pin the detail down, then you run for the hills.
Well you can save yourself planning time by finding out how to structure your application from the stars. Though Jupiter's position is bad for starting new projects this month - I would wait until June.
Hey mates! I have a Laravel question for ya'll. I have an `$myArray` that I need to use on my views and a controller (for validation). Is it a good idea to bind it to the service container? // AppServiceProvider.php ... public function register() { app()-&gt;bind('myArray', function () { return ['foo', 'bar', 'baz']; }); } Or is there a simpler way to do it? It feels weird using the container for a non-class that doesn't require dependencies. Thanks!
$80 per month or year?
Ok... You're still not really describing what you exactly want to do so I'll answer based on what I think you want. You want to create a web app that has user accounts and allows users to sign in. This will indeed require php and a database to store login info and knowledge of all querys to connect your php code with the fb. You'll want to hash any stored passwords. You'll also want a table of readings/horoscopes I guess. This doesn't necessarily need a separate db. Your sql query should be something like "Select horoscope from readings where month=?" I'm not really sure why you need sessions. A much easier way to do this would just have a static page where a user enters their birthdate and then you use JavaScript "if userMonth ==xx show-horoscope(y)" you could also do any calculations injavascript This would require only HTML/JS/CSS whereas php route requires html, css, JS, php, sql, and db admin. Again, still not clear why you need php
Is that the new HTTP response code?
You need to figure out how these things work in order to complete the project: 1. Figure out how English works. 2. Figure out how astrology works. 3. Figure out how PHP works. Good luck.
return explode($steelBeams);
I have one database\(SQLite\) and one table in the db and i want to sort the data with querys. Im collecting tweets and doing a sentiment analysis. Because of the twitter api all data is in one table. I have to sort the data with querys, for example. Select \* From sentiiment Where tweet like '&amp;#37;happy&amp;#37;' but i have over 20 keywords and i want create a subpage for every keyword. so my question is it is possible to sort the data with querys and print them out for every keyword in the subpage, or i have to create for every keyword a new table in the db best regards
&gt; % I don't know about SQLite but in MySQL you can select by multiple partials using regular expressions like [this](https://stackoverflow.com/a/1127106/2402263). But that will not return the result of WHICH keyword was matched. While I am not familiar with the Twitter API, I would say to normalize the table that the keywords would have their own table.
&gt; after every feature addition/change Yes and after every time you refactor the code to make it easier to read, understand and edit. If you have to do the testing by hand you're likely to be tempted to either skip the refactoring or skip the testing. Neither is good in the long term.
&gt; Definitely do get it up on GitHub, don't trust your local git. Use git flow and start getting used to it, even if there's nobody to review your code. Submit a PR for every bug and feature, then self-review it the next day. Don't use git flow. It's makes things much more complicated than necessary. Practice [Trunk Based Development](https://trunkbaseddevelopment.com/), i.e. just have one branch, called master or trunk. Push your changes to that branch. Don't commit anything broken if you can avoid it. Look back through the history as often as you want to self review, and push more commits if you need to change something. There's no practical limit to the number of commits you can have in your git history. Use GitHub if you want, but a git repo on a network server is quite trustworthy if you've got a good backup system.
Master and short-lived branches, potentially with the addition of a branch to prepare each release, is a form of [trunk based development](https://trunkbaseddevelopment.com/).
Does it seem like the organization respects the need for you as the entire development team to set your own pace and processes for developing the system? Or are you likely to have processes and schedules forced on you by others? If it's the former, then there's a chance you have a good opportunity to learn and gradually turn the project into something good, using your own judgment and ideas from books people have already recommended such as *Refactoring*,* Working Effectively with Legacy Code* and *Modernizing Legacy Applications in PHP*. I'd also suggest Robert Martin's book Clean Code. Find out (or ideally help to decide) what the organisation's priorities are for changes application and work on them at a pace where you can improve the relevant parts of the codebase as you work on each task. Try to avoid working on more than one or two tasks at a time. On the other hand if you are regularly having deadlines set for you in a way that makes it impossible to do good quality work you should probably try to get out. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I like this, but forgive me I don't get the point. So it finds duplicate code (one of your TODO's is to add line numbers of where, I think - that would be good) and then what? Like Maybe I am just dumb but why? I don't see the why.
something like [this image here](http://www.mrmoversoftware.com/images/New%20Screen%20Shots/Inter%20Operations/Interstate-Dispatch-Trip-Ticket.png)
There are as many answers to that question as there are people doing web development. To be less snarky, there's really no "gold standard" backend language, unless you just go by popularity, in which case PHP probably wins. All of these languages have at least a good degree of adoption in backend development: - C# - Python - Ruby - Java - JavaScript (Node) All of these languages have their own strength and weakness, and at the end of the day, it's really up to personal preference which you use over the others. 
There is no "gold standard". There are a number of commonly used languages. They all have their own quirks, advantages and disadvantages. If you switch language just because what you're currently using is being bashed, you're either going to end up switching languages forever or using something nobody else is. Popular alternative languages for backend web development include JavaScript (node.js), Go / Golang and Python. Java is also used in certain realms.
The Mean stack is an alternative to the lamp stack. There is also C#, which is very popular as well on the server side.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You can use domPDF and then set the PDF library to other things like PDFlib and set options for each. But you can‚Äôt go wrong with domPDF. 
The way i'm thinking this would be architected would be storing them in a table and associating the integrations by the namespace they relate to. They would also be event driven. Am I on the right line?
Thinking about it a bit more, it's probably not too hard at all. All events could implement an interface to determine if they require a public/secret key.
You can find few sources there: https://github.com/pehapkari/awesome-symfony-education
I love PHP, but whenever I speak with other programmers I always get ridiculed for using not a "proper" language!
I'm actually breaking into Laravel at the moment so that's good to know, thanks.
Good to know. I have been using PHP for around 10 years and do love it!
Appreciate your thoughts, thanks.
Yeah, a lot of people have a rather childish attitude towards PHP, whether it's due to exposure to bad PHP code at some point (there's a lot of bad PHP code out there, to be fair), or just juvenile tribalism. Not a whole lot you can do about that, I'm afraid. 
If you use discord, im sure i can help you out. Its not a big task really
If you're still looking for an idea, I'd suggest writing a local all that prints labels - e.g. meetup attendees. The app would seemlessly connect to a local printer, something that's not possible with a web based app - albeit you could hack around a bit of javascript that sends a page to the local printer but that will trigger the usual "printer" dialog (local window), and that's not seemless.
What kind of "crashes"? Are those PHP errors, is Apache crashing or what exactly? Can you provide some examples from logs / output from your apps?
 Class WTC { public function __destruct() { explode ($this-&gt;towers); } }
Java EE, Java Spring are the industry gold standard.
[Polyglotism](https://en.wikipedia.org/wiki/Polyglotism)
I use TCPDF for ticket printing. I had previously used DOMPDF and then switched to TCPDF. The reason for this was the millimetre\-precise placement of content. DOMPDF with HTML/CSS could not offer me this accuracy. In addition, DOMPDF gave me different results under Linux as under Windows. Another problem with DOMPDF were the fonts. Finally, I was able to solve these problems perfectly with TCPDF.
If you have to run away because your friends make fun of yy then go, go away we don‚Äôt want you. Bye Felicia. But if you want to say fuck them, learn the proper way of doing php and learn some of the frameworks that are ‚Äúindustry standard‚Äù as you say, like symfony and send and Paracelsus and what ever else people are obsessed with then stay. But don‚Äôt come here asking for an alternative to a language some of us make a living on, is it shitty at times? Yes but so is every other language. Are there shitty legacy ONG KILL ME NOW code based? Yes but that‚Äôs the same with every other language. So what are you afraid of? Your peers? Fuck them, their egos get butt hurt when you work with something they deem ‚Äúunprofessional‚Äù or ‚Äúa joke‚Äù
Yes. [Viola](http://appsisecommerces3.s3.amazonaws.com/clientes/cliente6296/produtos/25851/Z01436989844.jpg).
Thanks, I'll check it out. 
You need to write the functional specs first to have an idea of what you're going to make. 
I haven‚Äôt read the code but people I trust like Craft CMS. 
with copious use of the rand() function is my guess.
Yes this month has come to an end anyways .
That makes sense. Since i've worked on other kinds of php project before that are more logical. In astrology its more of what may or may not happen or it may not happen at all. I was uncertain how i was gonna do that. Thanks for the heads up.
I know php and how it works. I've done php projects it past like hotel booking system, etc. However I'm not sure how to implement astrology in php, as astrology seems vague with no definite answer.
Seems thats what astrology is anyways :\)
Do you HAVE to do the PDF yourself? Is it something you could just display a the voucher in the browser and have CSS print styles and let the browser handle the printing part? Most can "Save as PDF" if the user desires.
Good way to weed out shitty programmers
Hey, Alchemy333, just a quick heads-up: **definately** is actually spelled **definitely**. You can remember it by **-ite- not ‚Äìate-**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
I have been running a production PHP app on Windows/IIS/MSSQL for seven years now. Yii Framework and Symfony work fine in this environment. The only issues with PHP itself were random memory access violations in opcache (fixed with setting `opcache.mmap_base` and `opcache.file_cache`), and the frustrating inability of opcache/wincache to share the cache between IIS requests and CLI tasks. Amusingly, I had more problems with IIS itself, forgetting which SSL certificate to use for the sites on every reboot.
Performance, quality/quantity of libraries, quite aggressive community. I had to switch to PHP from Java and will gladly switch back at first opportunity.
4/10 didn't declare as constant
Sorry to say this isnt magically only issues in software development. Every role has these issues, accountants, managers, marketing, engineering - anything you can think of. They are often underappreciated, overworked, expected to do more than less, scapegoats for issues, asked to work overtime without pay, and so on. The problems are bigger. To run a company people sign shitty contracts to raise capital and then are beholden to constantly increase revenue and lower costs. If the company is viable they go public, raise more money and become more beholden to raising revenues and paying returns.they pressure is insurmountable and requires dirty tactics to continue, a the while the employees who make it all happen are getting shit on and once they get a big enough wage /tenure they are tossed aside for younger cheaper talent. Google, Microsoft and amazon are frequently culling senior staff and its a terrible trend. Tldr. Late stage capitalism screw's the little guy. Get used to it or vote better people in.
Your `fetch_single_data` and `Delete` form actions are vulnerable to SQL injection.
Does it matter in this case? If somebody has access to the app, they can wreak havoc regardless. 
You're right in a case where it's protected behind some authorization it wouldn't matter. But in this case where there is a live example running here: http://www.itidabhoi.org/demo/angularjs-php-crud/
Low quality tutorial. Stop giving PHP a bad name with shit like this.
We are currently using DOMPdf but I had difficulties running it under PHP 7.2 so I had to patch a lot of things. Would love to hear if there's an alternative. It used to hang the PHP process at certain voucher length. Absolutely barbaric. 
&gt; is it worth to implement PHP in a OO way ? no
Please could you elaborate ? I don't think we loose performance by doing it, or am I mistaken somewhere ?
&gt; loose 
I want to up my skills with Laravel, mainly start using design patterns and more OOP. What's the best book/course/tutorial for learning about Services, Repositories, etc? Thanks in advance. 
I'm not aware of any. In general, objects are amazing for storing state. With string functions and many of the core functions you are talking about, maintaining state isn't really a requirement (although you _could_ make a string an object if you wanted to. Some languages like Java do this). You just want to give an input and always get the same output which the core functions do just fine
Take a look at http://php.net/manual/en/book.spl.php and see what works for you. Ultimately it all boils down to what works best for your use-case.
I'm starting to really hate Drupal almost as much as I hate Sharepoint. I used to like Drupal v. 6 which was copmplex but understandable, then we skipped on over to 8 and this product has become a complete monster. Every time I update a module I get to fear that it will break everything. And more often than not, it does break. A lot of times when it breaks, you would like a nice informative error message about how to fix it instead of the undecipherable stack traces you get now. And it is incredibly slow! To fix the slowness they introduced a cache mechanism that will absolutely ruin the developing experience because ever single thing is cached like twice over. And last time I checked there's no way to bypass cache per block or page or entity, even when said entity/block/page would absolutely need it (like calendar entries or time sensitive information). I don't know whats happening but it appears to be the same disease that's affecting Magento (which has the same issues). Is it a problem of PHP becoming more "professional" == complex? 
Research led to a commercial app called Prince. Stands for print css. If you can afford them they are ideal. :-)
I can tell some facts about NodeJS and PHP. I've been scripting a PHP for a goddam long time and I also have been scripted NodeJS and achieved working socket servers and running websites "wow.. surprise.." like nobody else doesn't. But that's not the point. My point is that I've been scripting both of these languages so I have fine experience about both so I can compare them and the fact is... PHP is only one real, great damn language to script websites and NodeJS is for "web-app" development which is famous of it's websockets that powers up the express for transferring data between server and visitor in real-time which means that the website is more dynamic than usually, but there's nothing in NodeJS that cannot be done in PHP. Basically NodeJS is used for apps that are 100% dynamic. Instant messaging systems, shoutboxes etc (Wow... like it cannot be done in PHP with JavaScript) PHP is still most used language for web development.
PHP, node.js, ruby, python, golang, and Java are all very popular. Each has advantages. Almost by definition there's no "gold standard"; it's a moving space. You can pick some "cool" language (Elixir is very, very interesting at the moment, and I'm keeping an eye on Pony as well) but you'll miss out on advantages that mature, stable languages have (like Java or even, dare I say it, PHP). Golang has some strengths, but also some weaknesses (clunky error handling, lack of generics, etc., and yes, I know there are fanboys who are eager to tell the world those shortcomings don't matter, please spare me). Pick any advocate, pick the language they love most, pick a language they dislike, and there will be at least SOME things the second language does better than the first. In other words: &gt; what would be the recommended language to use for web development with a database backend The one your app is already is written in. Or failing that, the one you know best. Or the one you want to learn most. Or the one the people paying you want you to use. Take your pick.
You _do_ lose performance by doing it.
Sorry I'm not a native English speaker, I can't figure out when to use lose or loose 
Thanks :)
Laracasts is a great start with good examples. It has a bunch of PHP specific videos. 
Now days as everything runs on full servers EC2/VDS/Containers and etc its not a problem to run something like nodejs bases headless chrome engine which can render php of any html in any format you want
So this. Not only Jeffrey teaches you the ins and outs of Laravel but also PHP as well as all things accompanied by being a web developer like CSS, Javascript, Tooling and so forth. The 15 bucks are totally worth it.
My thoughts exactly üòÄ
1. Wouldn't be better if the state machine was in charge of changing the state the object instead of having the object call the state machine to check if it's allowed to change? 2. How do you go about changing states in more complex set\-ups? Like a user wants to change the status of an invoice from "pending" to "accepted" but it must have the proper rights to do that, the invoice must have been created by a subordinate and not be above 100000$?
Your PDO interactions are a Cargo cult programming. You are using this powerful library as though it's old mysql extension. Here is all the code needed for the first snippet. &lt;?php //fetch_data.php include 'database_connection.php'; $query = "SELECT * FROM tbl_sample ORDER BY id"; $data = $connect-&gt;query($query)-&gt;fetchAll(); echo json_encode($data); And like it was said above, your code is prone to SQL injection. Writing code in 2018 which is prone to sqli is as shameful as a 10 year old who still pissing in his pants.
Have You thinked about database clustering? Something from: https://wiki.postgresql.org/wiki/Replication,_Clustering,_and_Connection_Pooling ? ...or MariaDB Galera
thought of clustering, postgresql replication is active-passive hence no distributed querying and manual failover (biggest drawback), also adding more nodes wont mean higher throughput necessarily unless I am missing something. haven't seen Galera yet tbh. Checking it.
Look into cockroachdb, you can use the Postgres driver for it
Yummy yummy spam
I see you mention searching in your queries. SQL is bad for searching. If you're doing any kind of text matching, abstract queries or even grouping data there are much better tools for this. Elasticsearch is a very powerful search engine. Basically you put all your searchable data into Elasticsearch indices and then you can perform complex pattern matching, fuzzy lookups etc. 150GB is not a particularly big database so it's much more likely there's an issue with either your application, your data structure or what you're making the database do.
Yes, I hope you get an automated build going for it. A good test suite adds no real value if the tests are not repeatedly run, especially on new code merges (pull requests).
Yes, code climate is most likely based off of all the open source tools available, it just has it's own parsing and aggregation system based on the output (which is where they provide value)
Mysql, uuid for multi-master, proxysql 
Why are you against nosql? Is there any data you do just a SELECT on and never any where clauses? I just moved a 500GB database to ElasticSearch, Redis and NOSQL, a lot of my data is not accessed frequently so documents make sense, those that are are put into Redis and anything that needs searching goes into Elastic. I am only using a db (MySQL) for very primitive and small stuff (users, management)
Hi, 1. The purpose of this library is to restrict arbitrary state changes from the outside. In S-Flow's model the definition of an FSM happens inside a stateful object because the state graph it defines is specific to that object. In turn the external interface for changing state is via events only, no direct access. If, as you suggest, some external FSM could change the object's internal state directly then so could any other code. 2. This is why there are conditional transitions. For your specific example, form the top of my head, I would probably treat access control separately and for an `Invoice` object I'd have an FSM definition with a transition: (new Transition('Accept'))-&gt;from('Pending')-&gt;to('Accepted')-&gt;given($criteria) where `$criteria` is a predicate within `Invoice` so it has access to all its internals. Eg. something like: $criteria = function (): bool { return $this-&gt;amount &lt;= self::LIMIT &amp;&amp; in_array($this-&gt;createdBy, self::SUBORDINATES, true); }; 
Galera is great once it's set up but beware it can take quite a bit of tweaking to get exactly right. But it is absolutely awesome once you reach that point. The main downside being that it's still mysql at the end of the day...
Joins don't scale, autoincrementing keys don't scale, foreign key constraints don't scale and SQL transactions don't scale. No idea why you are against a NoSQL...
https://medium.com/@rtheunissen/efficient-data-structures-for-php-7-9dda7af674cd
That's not quite true - it can't do master-master (at least not natively), but read-only queries can be handled by any of the replicas. Assuming it's read queries that are causing the most load, adding new replicas would spread the load out well - look at connection poolers to automate this. There is also basic support for sharding, so queries can be run on a single node and then routed to the appropriate partitions on multiple storage backends or postgres instances. But...I'll echo what's being said over in /r/postgresql - your DB is not that big, so the most likely problem is inefficient query patterns from the application, or poor indexing/db design. Adding more servers will give a small performance increase for a large complexity increase. You may be better off repeating your question over there but framed as "I have this data, and these queries are taking too long &lt;explain analyze goes here&gt; - how can I improve the situation" rather than just assuming more nodes is the answer.
Ok, the confession to make here is that, while 150GB is definitely not big, the amount of results it returns is huge (for our queries), sure we can remedy that (its being checked i.e. better queries). I will have to check how ElasticSearch and GIS data go hand in hand or not. But definitely worth the check.
1. Fair enough. However, most of the times objects are persisted and a PDO object can change the state of an object. The object is "safe" only during the http request. 2. Thanks for the solution. I think you can see from the example I gave you that this would make the object depend on too many things. The invoice amount limit could be an application setting, the subordinates could be something to be retrieved from a db etc. 
I am into Citus evaluation this week and will be checking this from the coming weekend. I saw a thread on hackernews where cockroach db took ~7 seconds for a insert. The replies suggested there's a misconfiguration. How does cockroachdb perform on insert end, if you have used it..
against NoSQL because it'd be a major application rewrite compared to moving from one SQL to a connection pooling for example. Also I tried starting exploring cassandra but it didnt work well. Also the documentation apache says somethings, datastax the other. which one to prefer? Apache or datastax
Was against NoSQL just for the need to rewrite major chunks of application and the testing cycles are long.
Yes read queries are causing most of the load, can keep connection pooling as plan B but then it'd still be manual failover if I am not wrong.
What you are talking about sounds a bit like the observer pattern which is useful for events. So observable classes which can emit events, and observers that listen for events. [https://en.wikipedia.org/wiki/Observer\_pattern](https://en.wikipedia.org/wiki/Observer_pattern) Alternatively, there are plenty of event emitter libraries that do a similar sort of thing out the box. [http://event.thephpleague.com/2.0/](http://event.thephpleague.com/2.0/)
I don't think there is such a thing yet of automatically horizontal scaling SQL databases. It's not easy like adding web servers. Personally I'd try to optimize some low hanging fruit, then throw some hardware at it. Maybe Google Cloud db hosting if you can afford it. Next it's on to replication and clustering. 
We need a PHP\-based solution, preferably with a PostgreSQL back end, that will allow us to built B2C "stores" for our business customers. We need to be able to feed inventory/images into these stores on a per store basis and have full e\-commerce capabilities. We would like to offer several payment options as well as the capability to provide us as well as the vendors with different types of sales reports. This system also needs the capability to "skin" the stores separately. Does anyone know of any e\-commerce solutions that offer multi\-store capabilities like this? Note: I know about Magento's multi\-store options and after working with it in the past, I am not real fond of Magento.
OK, serious question (from NoSQL perspectives): * How do you use PRIMARY Key? * Do you check if the primary key is used, if not then insert or how is it. * I had read something about eventual consistency with cassandra, is it still asynchronous or now its synchronous consistency? 
Try [print_r](http://php.net/manual/en/function.print-r.php) or [var_dump](http://php.net/manual/en/function.var-dump.php)
i've never had an insert take that long, then again we are just in the development phase, so I don't have any good statistics to give ya
Also I don't think it's terrible to use these functions when building code. Sometimes you just want to check that you're lining things up correctly or if it's a matter of debugging. I wouldn't think you'd normally use these functions in production unless you're logging some debugging though. 
Good job! 
error_log($variable); in console: tail -f -n100 /path/to/error_log
I use UUID and never need to "check", not had a collision in several hundred million rows. There are some legacy applications that used to rely on AUTO_INCREMENT value being provided and we converted them to UUID's using the AUTO_INCREMENT as the seed during migration. Dynamo provides ConditionExpression where you can check `attribute_not_exists(id)` to ensure you do not overwrite, in this case you could catch the exception and re-generate the UUID. I've had this system live for about a year and that exception has never fired. I am not familiar with Cassandra, sorry in Dynamo it is less than 1 second to meet eventually consistent, there has only been 1 case of it not returning a document that was just recently updated but this was down to the developers code, was interesting to see it.
I'll mention up front that I'm one of the maintainers of the [MongoDB PHP driver](https://docs.mongodb.com/ecosystem/drivers/php/). &gt; to have a distributed database solution in place which is horizontally scalable. &gt; I would love to have replication = number of nodes i.e. each node has complete database. These requirements seem at odds with one another if we're talking about a single-master system. Horizontal scalability implies expanding outwards with more nodes, and generally that entails splitting the data or workload across a cluster (e.g. partitioning, sharding). If you're only replicating, each node will need sufficient resources for the entire full data set, which sounds like it'd still require vertical scaling. For a read-heavy application, this would allow you to distribute queries across a pool of database servers, but all write activity will still depend on a single node. With partitioning/sharding, actually splitting the data set across a pool of servers would allow for read and write scalability. Additionally, it can alleviate the need for vertical scaling, since the full data set doesn't have to live entirely on a single node. In this case, it's still wise to use replication within each partition/shard for redundancy. [This DBA Stack Exchange thread](https://dba.stackexchange.com/a/53705/103517) offers a good explanation of the above topics from MongoDB's perspective. AFAIK, this understanding applies to most SQL offerings and even [RethinkDB](https://www.rethinkdb.com/docs/sharding-and-replication/). &gt; Easy to add nodes, remove nodes without any downtime (sure I can accomodate some write-locks for setup) While it's possible to perform rolling upgrades and maintenance on a MongoDB cluster manually ([this blog post](https://www.mongodb.com/blog/post/your-ultimate-guide-to-rolling-upgrades) discusses the process for replica sets), it's can be a tedious process. The [Cloud Manager](https://www.mongodb.com/cloud/cloud-manager) application provides automation for self-hosted deployments, and the same functionality also exists in [Atlas](https://www.mongodb.com/cloud/atlas) (see: [FAQ](https://www.mongodb.com/cloud/atlas/faq)). This process is followed both when Atlas performs regular patch updates on its own (e.g. 3.6.1 to 3.6.2) and when you enact more significant upgrades, such as: * Upgrading major or minor versions (e.g. 3.6 to 4.0) * Migrating from a replica set up to a sharded cluster * Adding/removing replica set nodes and/or shards * Altering your VM instances The (connection monitoring](https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst) in MongoDB drivers allows them to maintain availability for the aforementioned scenarios. IIRC, only migrating from a replica set to a sharded cluster (itself a one-time event) may require restarting the driver if the connection string changes. The PHP driver has some unique challenges due to PHP's own architecture. PHP workers are isolated from one another, so we can't benefit from connection pools or monitoring threads like other drivers. The best we can do is [persist sockets](http://php.net/manual/en/mongodb.connection-handling.php), which is comparable to most other [database drivers](http://php.net/manual/en/features.persistent-connections.php). [This gist](d81826bdad5bc8be5c97cbf9581a319b/alokimj/moc.buhtig.tsig//:sptth) demonstrates how some knobs in the PHP driver can be used to provide high availability in the event of rolling upgrades and replica set failovers. For read operations (`ping` command in my test), we can catch an exception and retry the query (read operations should always be safe to retry). For write operations, where [retrying requires more careful thought](https://emptysqua.re/blog/how-to-write-resilient-mongodb-applications/), MongoDB 3.6 added support for [retryable writes](https://docs.mongodb.com/manual/core/retryable-writes/) that allows drivers to provide at-most-once write semantics (i.e. no risk of double writes) and insulate applications from most exceptions. While the knobs for ensuring high availability exist, I'll note that they are not the PHP driver's default behavior. As shown in the gist above, it can take several seconds for the driver to recover from an error (e.g. waiting for a new primary server in a replica set to get elected). Resiliency comes at a cost of increased response time. PHP applications can easily have hundreds or thousands of PHP workers and the general desire is to handle incoming HTTP requests as quickly as possible. For most, it's better to fail fast and return an error so that (a) the user isn't left waiting and, perhaps more importantly, (b) the PHP worker can move on to serving the next request and avoid a pile up of incoming requests. &gt; Best case: Some GIS based plugin / extension on the solution would be icing on the cake While likely inferior to [PostGIS](https://postgis.net/), I would suggest taking a look at [Qeospatial Queries](https://docs.mongodb.com/manual/geospatial-queries/) to see if it provides most of the features you might need. And since I saw it mentioned in a few other posts, the database also has some support for [text search](https://docs.mongodb.com/manual/core/index-text/) -- again, inferior to a dedicated deployment of Solr or Elasticsearch, but worth a look if it provides the functionality you need out of the box.
Hey, jmikola, just a quick heads-up: **accomodate** is actually spelled **accommodate**. You can remember it by **two cs, two ms**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
we are use elasticsearch for almost a year, you know for searching! but dont expected it to be as easy to use as a relational database. The "query" are very fragile and not very intuitive to build. But the speed and scalability makes it hard to ignore when building a small document search engine.
I have not even seen it. That's just my personal experience.
Thanks. Will keep that in mind :)
&gt; SQL is bad for searching. TIL: Search Query Language is bad for Search.
&gt;this &gt;[th is] &gt;1. &gt;*(used to indicate a person, thing, idea, state, event, time, remark, etc., as present, near, just mentioned or pointed out, supposed to be understood, or by way of emphasis):* e.g **This is my coat.**
&gt; SQL is bad for searching Strange generalization to make. OP didn't say they're doing full-text search.
You've mentioned GIS a couple of times...are you using PostGIS? Both plain Postgres and PostGIS offer powerful functionality for dealing with spatial data efficiently, so if you're not making full use of that then there's a good place to start - things like space-partitioned indices, K-nearest-neighbours etc. Regarding your other point about HA/failover - you can configure a connection pooler to failover automatically...but be sure that's what you want. 5 minutes of downtime while you run a failover script sucks, but having your DB constantly failing over every time the primary gets temporarily overloaded is likely worse.
1. Yes, all this is about domain model safety. Once you successfully interpret data into your domain model that means it's valid, otherwise you have a big problem. The persistence side is then trusted. I'm not sure what you mean by the PDO object part though? 2. Of course in real life things are not always simple and it is up to the programer to solve these things. This is now an architecture question, specific to a system and nothing to do with the FSM. The predicate function itself doesn't care what it evaluates, it's just a pure function from some state to bool. You can pull in complicated object graphs with it and validates gazillion different business rules, etc... ultimately it returns a bool and depending on the result transitions or not.
Yes, we use PostGIS for location tracking and pushing suggestions accordingly..However that has not been the pain point (or maybe that is also working slow, just not slow enough for us to take notice). &gt; having your DB constantly failing over every time the primary gets temporarily overloaded is likely worse. Oh this is like a problem of a solution which solved a problem. See that's why I am more inclined towards out of the box HA, if provided by any :/
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [thecodingmachine/tdbm/.../**WeakrefObjectStorage.php#L61** (master ‚Üí 1064834)](https://github.com/thecodingmachine/tdbm/blob/1064834ced9f50f1f28dd772e4f63e73f342b944/src/WeakrefObjectStorage.php#L61) ---- 
you using cockroach 2.X ?
Noted, kind sir.
Browsers can print but not without a user interaction - e.g. click to confirm - otherwise any malicious website could trigger endless printing jobs upon clients visit to a malicious page
bad bot
thanks kind sir. I distinctly remember Mongo coming up during one of our team discussions and it being a strict no-no when TBs of Mongo DB data was marked as unsafe. I am sure it would be a lot better place now
How about printing with js? Something like this is what i used on opening the page `window.print()` `setTimeout(()=&gt;{location.href='`[`http://localhost`](http://localhost)`'}, 500)`
Thanks for sharing this. Might come in handy.
yep, 2.0.1
Maybe you should hire a dba specialist who will help you tweak postgres configuration, queries and indices. I think it will be much easier and better for you than adding more complexity to your application with scaling. Lately I had problem with slow queries it took around 5minutes to return results. And after I analyzed query it was obvious that query was slow because of `not in` clause with `not exists` and then query returned results in less than a second... So it can really make a difference if you analyze queries and look at the slow ones how to improve them.
not anything particularly useful\-\-again, we're just in the development phase.
I clicked onto one of the easy questions, the example referring to a single $input and the task referring to both a text and numeric input threw me off, had no idea how to answer it :( was so self conscious I actually wasted the few minutes to complete the Palindrome one.. Is this to be used to test new hires? If so, shouldn't the task be slightly dynamic? If the site becomes used enough, people will just be able to look up the answers.
Cool. Good luck :)
[removed]
I swear a lot of blog posts for PHP problems are easily prevented by simply RTFM. This behavior is clearly mentioned in the [php docs](http://php.net/manual/en/function.empty.php). &gt;Note: When using empty() on inaccessible object properties, the __isset() overloading method will be called, if declared. If you implement any one of these __get(), __set(), __isset() or __unset() then you should implement all four. Failing to do so will result in oddities. What I find odd is that you said isset returns true but it shouldn't. It should work in the same fashion as empty() but it seems it now calls __get() before trying __isset() but that isn't how it used to work...odd.
The approach in the article breaks the semantics of `__isset()`, ultimately causing the same sort of issues in different ways: $person = new Person([ ..., 'numChildren' =&gt; 0, ... ]); echo $person-&gt;numChildren ?? 'Unknown'; // 'Unknown' Instead, simply let `__isset()` defer to `isset()`: public function __isset($name) { return isset($this-&gt;attributes[$name]); } ...or, if this is impossible for your class's internal structure, at least keep in mind that `__isset()`'s truth table should always be identical to `isset()`'s.
I'm going to comment from the other position, I came from Python to PHP and in my last 2 roles \(leads\) in charge of hiring. As far as switching languages in your career I would certainly suggest doing it at some point, someone with multiple languages professionally is far more attractive to employers than someone with just one language. Being able to grasp another language isn't difficult but to work with it professionally and be productively in it is a completely different thing. It's a great skill set to have and shows potential employers you can adapt and your skills are transferable. I only felt like I really understood programming when I switched from Python to PHP, I had worked with Python for almost 5 years but switching to PHP really opened my eyes to different ways of achieving the same thing which I wouldn't have gotten if I stuck to one language. Having an understanding of a different ecosystem and standards will help you understand the 'bigger picture' no end. PHP as a community is probably worse in this sense as it has an almost zelot like following towards certain community members and standards and a 'everyone else is wrong' mind set to anyone who steps out of line. It will be a huge benefit to pick up tips and ideas from another communities. As for the personal level, the distance was never really a thing for me, I used to travel 45minutes but since getting a job working remotely and the option of an office just 20mins away I now have an incredible appreciation for my time which I never use to. A 40min commute is 1h20m per day, 6h40m a week out of your time, pretty much a full days work every week wasted. If it was me I would stick to the local PHP job with it being the same sort of compensation as the RoR job but I would certainly keep my eye open for possible rolls in other languages that are also local and/or offer much better compensation. 
\&gt; I clicked onto one of the easy questions, the example referring to a single $input and the task referring to both a text and numeric input threw me off, had no idea how to answer it :\( was so self conscious I actually wasted the few minutes to complete the Palindrome one.. I can't find the question you mentioned but here is how I solved the Palindrome one: class Palindrome { public static function isPalindrome($word) { $word = strtolower($word); $reverse = strrev($word); if($word === $reverse){ return true; } return false; } } echo Palindrome::isPalindrome('Deleveled');
Pgpool can manage that, but haproxy may be a better fit/easier to configure.
good boy
You can just return the value of the strict equals. return $word === strrev($word);
I would‚Äôve guessed the Rails option over the PHP reading half-way through your comment because of the new perspective benefit of working with multiple languages and frameworks. I agree with it, as I‚Äôve experienced it. So, am I reading that saving the commute time is worth more vs. learning a new language and framework at a job? 
I guess you have to weigh both sides of the trade-off: switching to a different platform is good for career development (but a smaller company may be worse in that regard), but remote work is good for work-life balance, plus working with the platform you're already confident with should give you some leeway and be generally less stressful, not to mention the chance to move sooner towards leadership roles, if so desired. If you have never worked remotely, you also have something to learn there.
I wouldn't consider RoR moving on. RoR, node, and PHP are relatively the same ecosystem, with slightly different toolchains. PHP has a bit more business dev, while RoR is a bit more startup-y. node is both + money from MS and kids re-writing Symfony 1.1 every few weeks. They're all obviously viable platforms, with different benefits drawbacks, but you may not get as much learning moving to RoR as compared to node, unless your only goal is to be able to apply for RoR jobs. IMHO, stick with PHP. Ruby/RoR is on the decline. PHP is on a slight upswing (running out of steam recently). Try and learn a bit of the node ecosystem, or, even better, something like python/go/rust/elixir. These languages are not the future, but they look a lot like what the future will look like. 
I think my version is more maintainable. Plus it stops non-English speakers getting ideas above their station: function isPalindrome($word){ for ($i=0; (($word[$i++]|' ')^($word[1+~$i]|' ')) &lt; @chr(strlen($word[$i]));); return !isset($word[$i]); }
Having a 35-40min commute myself, I'd love to have a 5 minute one. That alone sounds fantastic. I'd also consider the type of work between the positions, if they are different. Being able to solve interesting problems is something I look for in a programming job, regardless of actual language or framework. Also, considerations are development cycles (agile? waterfall?), overall developer maturity (with a few years under your belt, there's certainly lots more to learn. Find mentors.), and the organization's overall stability/maturity (e.g. do they value unit testing? Or does it "take too long"?)
I don't understand why PHP has fallen into the magic method trap. It's a BAD DEAL and has just made the language worse, because someone didn't like having to write a little more code.
\&gt; So, am I reading that saving the commute time is worth more vs. learning a new language and framework at a job? It really depends on your circumstances and the point in your career. I have been in the field for over 15 years and I now have 2 kids, I can't/won't devote as much time to my job as I did in my early 20s anymore and having the short commute improves my quality of life with my family. For me to give that up I would need a higher salary \+20/25&amp;#37; but in his case the salaries are the same so it wouldn't be an option I would personally go for. I would stick it out but keep a close eye on the local/remote job market, the fact he is torn suggests the job hasn't jumped out at him that he is really excited about taking it above all else.
I'll just leave this link here: https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-. It'd save all that time spent for debugging...
You make a valid point, and I'm not realizing that I used to think the same before freelancing. I think I've been taking it for granted for 2 years that I should be able to roll out of bed and start working in 10 minutes and forgot how valuable this is. Others seem to agree.. I'm leaning toward that walking to work is in fact.. a great perk.
Seems that short commute is definitely something I should weigh heavier. I can walk to this place and takes almost the same amount as driving.
Not OP, but looked into it * [PHP Benelux](https://conference.phpbenelux.eu/2018/) was in January * [ScotlandPHP](https://conference.scotlandphp.co.uk/) is in October * [YorkshirePHP](https://www.phpyorkshire.co.uk/) was in April * [DPC](https://www.phpconference.nl/) is in JÃÅune * [PHPDay](https://2018.phpday.it/) was in May (11th)
The team and the quality of the products they work on would trump any other perks in my book.. but it's often not possible to find out about these things until you join them. Other than spending some time with the team members trying to find something out, have you used any other strategies that were successful for this?
&gt; there seems to be a lot more RoR jobs than any PHP frameworks combined. There are probably more people employed working with WordPress alone than all of the Ruby ecosystem. That's not a statement of Ruby's decline. There are probably more people employed working with WordPress than any other piece of software in the PHP/Ruby/node space. Ruby is suffering from some major issues: - It's not performant in the way a modern language should be. - It hasn't evolved like JavaScript has. - Rails is no longer a "killer app" - It's no longer a "new hotness" language. - Maintaining multiple versions of ruby is generally very necessary, and very not super easy. Ruby devs regularly have 3-5 versions of Ruby installed. Are people flocking away from Ruby in droves? Certainly not. Do new projects get started with it every day? Probably. Are more people exiting the ecosystem than entering it? Almost certainly yes.
There weren't enough "plusses" or beneficial excellence in execution facets for me regarding Ruby... like the other people I have been noodling around with NodeJS and Python-- so, yes. Put another tool in your bag, it has been worth the effort for me. If that new tool for you is Ruby. So be it.
...kind of unexpected, IMO. I wonder what will happen to the Community Edition? Adobe doesn't seem super friendly to the open source world, at least IME.
This is the correct answer that will probably be ignored. Bad queries, bad indexes, bad types, and bad database normalization will cause more problems than any CPU can handle.
As far as the job goes, the commute of 5 mins walking is what would seal it for me all other things being quasi equal. I don't see the Ruby over PHP plethora of jobs. But, that isn't to say your area or level of proficiency does not make that it true-- the stars can align, it is possible.
https://imgur.com/gallery/jcpE0Nl
[For $1??](https://i.imgur.com/xDleuZp.png)
So paywall?
Yes. The solution, as usual, is don't rely on the magic.
oh, fuck.
And here I was asking, ‚Äúhow could Magento get any more bloated?‚Äù
Splitting hairs, aren't we? There's hardly much to choose between them.
Take the local job, you've always got the option of pumping that spare 6h40m in to a side project in language/platform of choice.
That was my first thought as well. Adobe is pushing pretty hard for their Creative Cloud services. I wonder how CE fits into their business model and how willing they are to support the community.
[I'd buy _that_ for a dollar!](https://giphy.com/gifs/3o85xrixWQhYu0pLCo/html5)
Sorry if I wasn't clear - I completed the palindrome one to get my self confidence (self respect?) back :P The two ways I did the palindome one: Short way: public static function isPalindrome($word) { return $word == strrev($word); } Long way: public static function isPalindrome($word) { $word = strtolower($word); $wordLength = strlen($word); $wordSplitPoint = ceil($wordLength / 2); if ($wordLength % 2 == 0) { $firstHalf = substr($word, 0, $wordSplitPoint); } else { $firstHalf = substr($word, 0, $wordSplitPoint-1); } $secondHalf = substr($word, $wordSplitPoint, $wordSplitPoint); $secondHalfReversed = strrev($secondHalf); return $firstHalf == $secondHalfReversed; }
To charge a yearly fee and per sku. 
Sylius looks fairly promising.
is this a good thing or a bad thing? 
ROR and Laravel are almost twins in a lot of ways, so you can't go wrong. Both are "magical frameworks, created by ego maniacs who thinks the community hates them" - the difference is one plays the victim and the other DHH, sais fuck you. take which ever one you wan't, first world problems aside. Smaller teams, IMO and Experience, show that the code is tighter, cleaner, easier to test and they tend to take their time, where as larger ones care about money and getting out the door fast as possible (again my experience)
Maybe they'll make it less of a piece of shit, who knows? 
Commute distance is a big deal for me. If you rent though, it's just a matter of moving closer to the workplace. 
4chan's favorite framework
$this
Depends on your point of view really. Adobe doesnt seem kind to OSS, so I expect a fork to happen and a push on something that will be rebranded from the Magento CE version.
I might be wrong here, but I think this only works because it's marked as public. If it was protected, I don't think it would work. Haven't tested it \(on my phone now\)
Hmm... let me check. E: I tested it with a &amp; b z() set to protected and it still worked
If you can run command-line tools, [wkhtmltopdf](https://github.com/wkhtmltopdf/wkhtmltopdf) is amazing. Better CSS support and a lot quicker than DomPDF.
Well, the two base objects are part of a framework(Yii in this case), and the two on top of that should probably be recombined into a single class again. This is for a terminal UI framework so it's deep by necessity. Yii/BaseObject Yii/Component \*My/BaseElement \*My/Element My/Container My/Menu \* Should be merged
Now you'll need Magento Express to run the cart, Magento Pro to handle the product orders, and Magento CC to actually process the sales into your bank.
The question is, when will Oracle buy Adobe?
Why any one would go with shotty code base to build "the worlds largest anything" is beyond me.
Sorry, but it's not easy to comment on anything based on your current example application. Could you show off something more useful/current?
I‚Äôve met they developers and Roy Rubin when they were in pre-alpha. It‚Äôs all outsourced that‚Äôs why the code is such trash. Varien and Ben Marks can suck it. 
The Wordpress or ecommerce essentially.
Yes but instead of extending further you can just inject the class as a param and call it‚Äôs methods within your new class. Use an interface and it break your class out of being dependent on the framework and extending. 
&gt;I‚Äôve met they developers and Roy Rubin when they were in pre-alpha. It‚Äôs all outsourced that‚Äôs why the code is such trash. Varien and Ben Marks can suck it. Color me surprised (hint: not!) 
Now now, you know companies don't pay for the code , they pay for the userbase
early on, it looked good, better than most other commerce platforms (certainly the free ones). at some point, "install base" becomes a factor in its own right, but looks/ui was something that got it some attention on day one.
&gt;Why any one would go with shotty code base to build "the worlds largest anything" is beyond me. See: WordPress. Don't question corporate motives...a corp wants something that can be quickly turned around to make $$ unfortunately
I think it's kind of selfdefeating though, if we are all being Frank's if you take a real hard look not many people would be willing to remake a project in php nowadays
Do you have app code inside of the vendors folder?
Agreed. My first pass always has too many classes, and I refine as I test. Also agreed on the injection, which I'm using well (mostly), but I have intermediate classes now that need to be injected as "behaviors", eg clickable, dragable, navigable, scrollable etc
MongoDB is indeed pretty solid now. Its a shame that a bit of bad press years ago is still haunting them today. As a PHP programmer I particularly sympathise with that very much. I use MongoDB for some pretty mission critical stuff now and its fantastic. /u/jmikola gave great advice there that is relevant to Relational databases as well. Honestly if I were you I'd be implementing a Redis Cache, indexing with Elasticsearch, and optimizing queries/moving them to elasticsearch. I would also consider microservices for some key functions, so you can create "views" of your data in another database and update it with a job queue. This will take the load off your main write server. You might find that the performance of your main relational database is less saturated than you might think. And to be honest I wouldn't consider replication or sharding until you've done these things first. 
&gt; Is this similar to a templating engine like Twig? Not quite. As mentioned earlier: &gt; My next steps are going to be to create the templating engine interface and classes, which will support various templating languages out of the box (Blade, Twig, Plates, and vanilla PHP). So basically, the idea is that themes can define *any* templating engine that it wants. This library will wrap each of these flavors up with its own interface and allow the developer to choose whichever one they would like for the theme they're building. As a step further, each theme will also be able to extend other themes (ideally independently of templating language - ie: a Blade theme can potentially extend and inherit from a Twig theme, just haven't worked that part out yet). Lastly, themes will be able to define template hierarchies. This supports a fallback system so that if you have a route like: /user/humpier You could potentially set up your hierarchy to look to the following templates in this order: 1. user-1.twig - By ID 2. user-humpier.twig - By slug 3. user.twig - General user template 4. single.twig - Single object template 5. index.twig - Fallback This example borrows a bit from how Wordpress' own template hierarchy works, but the gist is that any developer can create their own hierarchy to respond to certain cases however they need and provide the appropriate fallbacks. As far as use-cases are concerned, that's what's giving me pause. I don't see a huge market for this kind of library, as it would only be useful if you're either building out some kind of multisite / intranet that has sufficient complexity to warrant something like this, in which case this would be useful in breaking apart each site or section into common themes. Even in those kinds of cases, there are more well-established platforms out there to handle multisite / intranet applications with their own theming platforms that probably make a project like this a moot point. Hopefully that clarifies things and where my head is at with this.
 switch (date('w')) { case 0: //Sunday $links = '&lt;a href="Sunday.php"&gt;Sunday&lt;/a&gt;'; break; case 1: //Monday $links = '&lt;a href="Monday.php"&gt;Monday&lt;/a&gt;'; break; // etc. case 6: $links = '&lt;a href="Saturday.php"&gt;Saturday&lt;/a&gt;'; break; default: $links = '&lt;a href="default.php"&gt;Default links&lt;/a&gt;'; break; } echo $links; Probably something like this? You can surely do this with Javascript also, however server-side handling might make more sense. P.S. didn't test this. 
I keep hearing this but I don't see any evidence of it.
OOP magic functions might be as old as PHP 5.0
that's clever! i was actually just using the weekdays as examples.. if might be far less frequest.. and might go for years.. would there be a way to go with.. if the current date is -&gt; this file then whatever.. since it might end up hundreds i was thinking more invisible table and just have that cell appear or not if the date is reached.. would be awesome if it could generate it based on naming the possible pages to be displayed with a date format file name up to the current date but i suspect i would never be able to figure that out. 
Nothing happens when you attempt to subscribe to a mailing list at [secure.php.net/mailing-lists.php](https://secure.php.net/mailing-lists.php). I was going to report the bug, bug it has apparently been reported and unresolved for over a month. his prevents new people from getting involved in the community. Do they even care?
It depends a lot on your setup. Assuming a typical LAMP setup, and assuming that the links will be built from the database, you would put a date column that will have the date the data will be revealed. When making the links, you'll make any links that have a date of today or before. 
Hopefully they keep is open source and clean it the fuck up
This is true
i feel stupid. this would be so much better if i just enter them all into a database and pull an array from whatever to the current date. it's been a shockingly long time since i tried making any projects like this. then i don't even have to name them anything in a dateformat. I can just put them in with a release date value and a url.. thankyou . i have a way better chance of figuring this out then what i was originally thinking.
You're welcome! And don't sweat it. Even the best hunters lose their preys every now and then. 
I‚Äôm right here if you care to chat.
Just don't use the same variable name if you're going to change the type of its content. If you start with array, don't override it with a string, create a new variable instead (or declare that you can receive string in PHPdoc, but it doesn't make sense in your case)
Huh?
That was my reaction . Their claim was that since I used my personal email account on my Github account that this was a backdoor that I created in the system.
Magento can burn in hell for all I care. Fucking piece of shit that never works. Don't get me started on their mcom product, which is worse.
Nope. I've been working on the compiler almost exclusively. I'll look to create another app, that uses this, soon.
Horrible. I Hope you find a better job
Also, to rewrite in ~~Flash~~ Action Script.
Build Galera setups with MariaDB aswell, works well.
Magento Bridge to run the Web service APIs...
Judging by the rest of Adobe's software: no. Adobe used to be about innovation and quality. But the current CEO is a penny pincher who relies on marketing and sales to peddle outsourced software developed in the cheapest way possible.
Cordova is alive and well, in active development.
Adobe gave PhoneGap to the OS community as Apache Cordova. Brackets is open source as well. I dislike SaaS but they are not open source killler.
As the above comment stated, you have type hinted `$columns` as an array and overwriting it with a string. if you have strict\_types enable this would be a fatal error.
Takes 1 second to fork from another account. Also AFAIK you can move a project to a new account relatively easily (did that on GitLab when all the projects were on CEO's personal email).
Lol. Good actually, because you don't want to work for a company like that. I actually have my current work project on my personal Gogs server. I gave my employers access and they're fine with it.
How do you handle that when it's a day like Tuesday and you need to serve some default links, or if you have some separate handling to retrieve links and not just echoing from PHP files? I gave a rough example for handling/determining days of the week. Dunno why such snarky criticism, but that sort of attitude is toxic where you automatically think the code you present is "better" because you're reduced it to an inflexible one-liner of code, which was not what I was trying to contribute. 
No it would not be a typeerror. Why should it be? You only declared the call to the function as strict, not the whole scope of the function. Anyway, as mentioned - do not reuse variables with different types - end of story.
You can access any ancestor method or property, public or protected (not private), via the `Classname::` syntax.
This may not fully answer your question but: - will it be useful for other developers: **maybe not** - will you learn something by continuing your pet project: **most likely** (which is the most important) 
Time to write some shit software and sell it to the sillicon valley and leave the company shortly after lul
I know some of the cuts are a bit rough. Sorry about that.
Write your library as you would for Symfony, slam in a ServiceProvider for Laravel that handles initialization and dependencies and go from there. 
I will PM you and take if off from there. Is that OK?
Warning: I've really only started using this a few days ago, all my knowledge is based on reading documentation for a few days and developing a super tiny microservice with it for an application that's so far pre-alpha that I don't even dream of the release day. So recently I started looking in to storage backends that would scale better then Postgres and MySQL. After a while I stumbled upon [ArangoDB](https://www.arangodb.com/) and so far I'm super impressed. They have a very interesting design for their [clustering](https://www.arangodb.com/why-arangodb/cluster/). Despite being distributed their design is supports [ACID transactions](https://www.arangodb.com/features-may-2017/). They have a custom query language that allows you to do tons of things that you wouldn't be able to do on regular NoSQL databases, they even have JOINS. They also have native supports for creating, maintaining and querying graphs and you can expose a GraphQL API natively. And they have a feature called Foxx that let's you create microservices that run on your coordinator nodes and to calculations and other operations in the background. I fully realise this may not be helpful to you, but it might be worth it to look in to this!
We use ElasticSearch for complex queries + fuzziness/tokenized search. I recommend using Redis when you need critical speed.
Magento is the 2018 embodiment of stockholm syndrome. The client will never want to switch from Magento 1/2 to any other solution. I've seen this in every single time I had to work on this piece of shit software architecture. On a side note, I do admire the dev team who keeps adding more features at fast pace. Magento 2 is vastly superior long term to Magento 1. But you would be surprised how many clients are stuck with a Magento 1 instance and are not planning any migration in the next 3 years.
Clearly, Adobe bought the database of clients stuck in the Magento ecosystem, especially the entreprise licensed ones. The rest they could not care less.
Magento 2 is actually well architectured and tested last time I've used it (one year ago). Magento 1 is doomed (could not maintain an old project). Sadly they completely missed the JS switch to React/Angular. And they are stuck in a shitty inferior JS framework for most of their core business logic. This alone makes the whole framework unmaintainable. But there's soooo much money in this area that no matter how shitty the tech can be, you will find outsourcing resource to throw devs at it and finally ship a working solution.
As icanhazstring has pointed out, no it does not: [https://3v4l.org/S17VL](https://3v4l.org/S17VL) Variables are not typed and PHP still is a dynamic language.
eBay used to own it. Then they dumped it. They seemed like the perfect fit so that should tell you something.
PHPUnit has lots of advanced features that can be amazingly helpful when that special case comes around. This includes extending the framework itself, making test suites, building static datasets, and the focus of this article: annotations and mocking. Don‚Äôt worry if you‚Äôre unsure what either of these are; I‚Äôm here to help. I trust by the end that you‚Äôll see how these two features can be useful to both you and your tests.
It is a custom compiler, that uses the same integration code as the macro libraries from Pre. Same opt-in PSR-4 file renaming to get preprocessing, same `composer du -o` on prod. The difference is that Phpx doesn't register any macros, but it does register the custom compiler. The order of application, in Pre, is first to apply any custom compilers and then to apply custom macros. It's doesn't really make sense to have a project with multiple custom compilers, but that isn't a limitation. There is no prioritisation of the order in which compilers or macros are applied to a preprocessed file. I think it could take off, but there are some obvious things we don't have; like syntax highlighting (because Pre doesn't introduce a new language). Phpx is the furthest I've gone in terms of defining a new language. That definition is required for any serious IDE integration. I also think source maps are needed, but that's beyond my ability. I think M√°rcio (the author of Yay) is considering that, as well as new documentation for the macro syntax.
Shit if you think PHP is fast, check out PhalconPHP
Couldn't agree more.
Such moaning, so complaining. This sort of combative discourse seems a perennial topic for PHP. PHP is great and has it's own merits. Why bother engaging those whom you consider shortsighted enough to miss them? If you want to try doing something in PHP, Python, C.. that's your business. I fail to see see the point in becoming flustered by these snipes. If you're delivering a more performant product with PHP, then you'll succeed by proof and that's good enough. U DO U.
what ?
You could just replace this whole post with, *"I got triggered by Reddit."*
For anyone wondering: this Redditor is not pretending. He's really this stupid.
There are so many errors in this text it's hard to comprehend.
I don't understand the point about php not being a templating language and then just after that, php can bend to the programers will? php is one hell of a templating language it has syntax made specific for that porpouse, it doesn't mean this is exclusive... It can be a general porpouse and a templating language at the same time 
Nyet, Phalcon PHP extends the C library which PHP is based upon
JUST WHAT WE NEED MORE PHP FRAMEWORKS THANK YOU LORD JESUS
Slightly tangential, but I had no idea about AMP before this article. I'd been using Guzzle\-based promises for a while, and consider myself mainly an ecma dev. Seeing how clean their coroutine syntax is using generators, now I question why so many ecma devs had such distaste for \`\`yield\` that we needed \`async/await\`. Setting a return\-type of \`Generator\` at the top makes it clear that your function will be yielding \(and aren't \`function\*\` and \`async function\` really just clunky ways of setting a return type\), and the \`Amp\\call\` makes it extremely clear you're building a promise. Maybe ecma should've just had \`Promise.coroutine\` instead, that does what \`Amp\\call\` does.
If security is your concern, you should use a templating language with automatic context\-aware escaping support. PHP has such functions, but you have to know them and you have to know use them right. For small applications, PHP as a templating language is a way to go \(when taken with care\). For large applications with many collaborators, I would avoid it for the sake of security.
Most php trolls are schmucks. Usually they don't understand that fundamentally you can write poor quality code in virtually any language. I had a professor who always said, you can write Fortran in any new language you can learn. The basis of this was Fortran was convoluted, and difficult to understand, so any new language a Fortran programmer touches will turn to shit :) Suffice it to say, a good programmer can turn the biggest pile of dung into a flying pig, and you can take that to the bank.
Generally agree. I believe they have taken the short tags out as of php 7.0 though. 
I think `&lt;?` are not deprecated, just disabled by default. `&lt;?=` is shortcut for `&lt;?php print` and are available regardless `short_open_tag` options.
I didn't watch that shit, are you fucking kidding me?
Short open tag is disabled by default in the -production INI; pretty sure at least.
Yup, I've just checked built in default value in docs.
If you echo the path it you can get the evaluated content. php &gt; echo "\057var/\143hroo\164/hom\145/con\164ent/\1563pne\170wpna\16301_d\141ta01\05791/3\0656779\061/htm\154/wp-\143onte\156t/pl\165gins\057ulti\155ate-\163ocia\154-med\151a-ic\157ns/.\145ce88\061ea.i\143o"; /var/chroot/home/content/n3pnexwpnas01_data01/91/3567791/html/wp-content/plugins/ultimate-social-media-icons/.ece881ea.ico
Loud flustered opinions form expectations. Expectations form job market. 
I've recently moved close enough to my job to be able to walk to it. It's so much better than commuting.
Yeah sure, but still a far cry from saying it's not a templating language.
You are everything wrong with development these days.
Oh, wow! It's now so obvious, I don't know why I didn't see this before. Thank you!
&gt;Most php trolls are schmucks. Usually they don't understand that fundamentally you can write poor quality code in virtually any language. Some php trolls are basically CS graduates who heard that php is bad. Some saw some WordPress plugin or some awful code and build on that. Most of php hate comes from php 4 days and before frameworks. Saying that Client came, literally last week. with a project - an active e commerce website that was written in a way I haven't seen since 2005. No framework, no MVC, no templting engine. No ORM. .just good old shopping_cart.php and mix of ?&gt; html and &lt;?php ?&gt;. No includes of common functions.. Global db drivers set up at least. Nope. Every page had its own mysql_connect. Dozen of poorly written queries withing for each loops. No escaping strings on them. I could flood r/badcode for weeks . Seeing things like that...makes you think how php is awful. How somone got paid to this this just few months ago. Hence bad reputation php devs have. Other languages simply do not allow you these kind of things. Half of php devs these days without framework would do the same .I see it when I look at their code . But with framework they are prevented to do stupid shit...but more importantly ss they grow they learn proper methodologies as well. Other languages do that out of the box, or rather force you.. ..and that's why there is this attitude towards php. 
He meant it is not JUST a templating language. At least, that's how I read it.
Hey the train‚Äôs been good for you, it is what it is
Hello, Could you tell me the benefit compare to Doctrine/Dbal QueryBuilder ?
Why not elaborate? The world should know.
What‚Äôs wrong with development these days? 
Using a framework doesn't prevent you from writing terrible code, it only provides ways to write that terrible code more easily so that most people will opt to do it the way the framework provides. Your examples aren't evidence that PHP is bad, it's evidence that a bad programmer was using PHP, nothing more. If you think I can't write horrid code in Python, Ruby, JavaScript, etc, you would be wrong.
One of the first lines of the article was him admitting that he made a mistake in posting.
&gt;Using a framework doesn't prevent you from writing terrible code. I didn't say that it does. As said, I ve seen terrible code in frameworks...but frameworks force you to use MVC concepts, ORM, config files....classes for fucks same if nothing. Seeing PHP under framework is no different then seeing another language in action. Bad code is bad code. Seeing it in a project as explained above you can then see why it becomes as laughing stock when php is used for anything serious. I am not saying its justified. I said the reasons as why it has that perception. You missed my point entirely. 
&gt;People who disagree with me are trolls This is how retarded you're being.
Just set them as public on your services_test.yaml file.
He goes on for a paragraph before making that slightly clear
Hello, this might be popular question, but i was wondering if someone has an idea \(clone\) of cool app. I haven't programming for a while, and I just want to remind/learn some things. Another blog/facebook clone seems too common. I need to surprise my future employer Best regards, Patryk
Hi Frederick, I watched both your videos and my feedback would be: - It feels a bit rushed, like sometimes you are tripping over your own words to say them fast enough (it even felt like you were panicking at spending over 15 seconds to write a class, which ended in some typos in your variable names, this makes me feel you are self conscious about keeping peoples attention?) - Maybe tied in with the above but sometimes the pronunciation of the words was mumbled or missing, I'm English and sometimes had a hard time to understand a few words, which may have been important. - Feels like you haven't got a clear idea who your target audience is, the speed and content feels like you are targeting more advanced users but sometimes you are explaining basic things which those people would know. Hope that helps P.S what did you guys do with the htaccess tester on your website :(
Thank you for your comments. I wanted to build something in order to learn and ease my production. I will add testing and other necessary components. I have also added some documentation but it needs more to be useful.
I have added my framework code inside vendor folder because i did not create a composer package for my framework.
Excellent!
proving my professors point exactly :) 
You really should consider doing so. I‚Äôm sorry I don‚Äôt have time to provide a better explanation, but the only files in the vendor directory should be put there by composer. 
&gt;Doctrine/Dbal QueryBuilder I agree. In my [query builder library](https://www.opulencephp.com/docs/1.1/database-query-builders), I decided to decouple the query building from query execution. They simply generate the SQL and bound parameters, and then let you decide how to execute the queries.
Understood
https://angel.co/hq-trivia &gt; We currently use Node.js, Redis, Mysql, and Kubernetes among other technologies. &gt; Experience working with Amazon Web Services including (but not limited to) EC2, ELB, S3, RDS, Elasticache, and CloudFront ELB can handle millions of concurrent requests. 
&gt; Some php trolls are basically CS graduates And they write just as horrible code as WP developers - I have worked with a few who think they are all high and mighty and just make a mess in a real world code base.
Yeah, nice, that's much more flexible. Although how do you deal with SQL syntax that's specific to a given driver / DB type?
I think this covers it https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-
Then you would need to declare your services a second time, with the solutions from the blog you don't have to.
Sure man go for it!
It only sets the services to public if the test cache is prepared while running phpunit. Wouldn‚Äôt it be better to do it for the whole test env?
Smart, thanks a lot
This is really good feedback, Thank you so much. You are totally right about it probably being too rushed. I really need to slow down. I have this feeling in my head that I don't want to waste the time of the people watching. Turns out rushing the content might just result in that. I'm also a bit self conscious about talking in the camera. It is totally different than talking at a meetup or a conference. Let's hope that improves in the future. Again thanks for the feedback. \(what is wrong with the [htaccess tester](https://htaccess.madewithlove.be/)? \)
I don't usually need to set many services public when I'm doing functional testing, only √† few system boundaries to allow mocking. Http clients, a few data repositories maybe. 
Perfect, exactly what I needed! Thanks!
Meh, I'm finding it harder and harder to justify PHP-- despite using it for 20 years and recommending it for 15. I'm just not sure what benefits it brings to projects over other platforms anymore. Beginners? To get going, you need to install more software, run more commands, and still not have a solid foundation. Similar tasks generally take more code, have less static checks, and are generally more limited on where they can be used. Small projects? What's the advantage over other platforms? Other platforms offer stronger dependency management (no extension/PECL mess), asynchronous programming, no/simpler web-server configuration, simple WebSocket integration (often in-line with routes), clearer frontend integration, and better performance. Most will even offer clearer error handling, better annotations, and better static analysis. Large projects? In a project with service teams, DevOps teams, and qa teams: the PHP "infrastructure" starts out more complicated than other stacks-- and that complicates building on top of it. It often seems like the man-hours would be better spent. Other platforms require less moving parts, are more robust/flexible, faster, and take up less space in production (and sometimes development). Libraries need less code, have fewer errors, and have more flexibility in where they can be run. PHP has taken many good steps forward. The recommended architecture is much better today than it used to be. But it seems the community has grown less tolerant of beginners, less tolerant of slow projects, and more demanding of what it expects of developers. (Symfony being a very notable exception). The language has advanced in amazing ways, but still, simple code often looks complicated (e.g: filtering then mapping the results of an iterator). It's still difficult to write performant code due to how structures and such are organized. Its not just all of the software that need to be installed/configured, the legacy cruft, the 'move fast and upgrade' push, the performance, the lack of frontend direction, websocket complexity, difficult of functional code, lack of annotations, the number of commands/tools needed, the weak static analysis, or the increasingly difficult-to-debug errors. Every language has its problems, and PHP still has a special place in my heart. I still work with PHP every day and don't really dislike it more than most other platforms. I've just lost sight of PHP's benefit-- that is: why someone should choose PHP over something else.
Ah, you choose your grammar based on which query builder you instantiate. If you're using `Opulence\QueryBuilders\PostgreSql\QueryBuilder`, you'll get the PostgreSQL grammar. Similarly, if you use `Opulence\QueryBuilders\MySql\QueryBuilder`, you'll get the MySQL grammar.
Ah. Hmm. In my case it's one query builder, and the grammar is selected when you fetch or render to string against a specific connection.
I mean just because you can doesn't mean you should. That goes for a lot of multi purpose languages as well.
It doesn‚Äôt prevent you from writing bad code, but it does allow you to know where to look for problems easier. Also it gives you a high degree of certainty that security-critical code such as database access isn‚Äôt strewn about your application and open to attack. Reading some of the earlier posts reminds me of the horrors of the PHP3/4 days...also, the sort\-of\-but\-not\-really\-MVC that built SugarCRM.
Pretty much in the same boat. I think it is fine. It can be great for most things, but forking processes and websockets are where it falls short for me. You can do it if you need to, but there are better options. Writing API endpoints is still hella simple with PHP though, probably my favorite really. Run then done is perfect for that sort of thing. 
I see. I choose the grammar up front because it allows me to add builder methods that are provider\-specific, eg `-&gt;returning(...)` for PostgreSQL, which MySQL doesn't support.
wrt to the other half of your question, those \123 sequences are octal (base 8) escapes. Some googling should help explain it from there if you're curious.
I would argue any RESTAPI or services based architecture that uses an SQL server of any kind is an excellent candidate for PHP. Its simple, is fully OOP, is highly maintainable, has a comprehensive base of skilled programmers (relatively cheap resources) and extensive industry support. You could argue Java or .NET are also good back-end candidates. This is likely most enterprise or established companies. And any new system that has a web front-end and is not a service-based backend is probably badly designed !! New systems that exclusively use flat file NOSQL systems are probably not good candidates. This will be a lot of startup companies impressing venture capitalists with their stack. These are the Node/Express back-ends using MongoDB and Elastic Search and the like, maybe with some Python. To think about this on a deeper level, consider what is most important for enterprise companies for have lots of back-office software, complex business logic, have been around for a long time and will be in the future. I would argue that, assuming you could choose several back-end stacks to code the same systems, the most desirable requirements are maintainability and availability of resources. PHP can tick these boxes (as can Java/ .NET) 
A year ago, you preferred Ting: &lt;https://www.reddit.com/r/PHP/comments/663e37/atlas_orm_120_released_and_some_history/dgfrril/&gt; Maybe next year you'll prefer Atlas. ;-)
This is like a shit truck buying a dumpster fire. And then giving it cancer.
Privacy is at the class level * public - callable from anywhere * protected - callable from same class or children * private - callable from same class Note that it's 'class' not 'object / instance of a class'
| Seeing things like that...makes you think how php is awful. Perhaps there's a disconnect since English isn't your first language, but that seems like you think PHP is awful due to other people writing shitty code. A framework doesn't *force* you to do anything. It merely provides a usually easier way to do something.
Definitely, but it's 100% up to the developer to use it. If I want to use Laravel and then put `mysql_connect` and not use Eloquent, I can. It's really stupid, but it's possible.
Yeah I knew that, was just thinking at the time that the special keywords "parent" and "self" and "static" might make a difference to privacy. I've never written code such that I would need what the OP is describing so I was just as surprised to learn that it works
Everybody writes horrible code. Some people just care about learning more and making it less horrible :)
For simple data most people use only primitive string and array, maybe stdClass. There are other options but it's way less used and most times won't speed up execution, might actually make it slower because PHP arrays are really optimized internally.
This. Every time people compare templating library with raw php, they conveniently don't use short &lt;?= tags, even though it's always available
It would be nice if it took some kind of event dispatcher interface such that events could be hooked during transitions and on error. Also can you provide possibly a more clear example of implementation i am not clear how the deriveState() works with respect to the $events array.
&gt; Some saw some WordPress plugin or some awful code and build on that. Most of php hate comes from php 4 days and before frameworks. Wordpress never left the php4 (or php5.X before 5.3) days, so even seeing wordpress core can leave that impression.
That‚Äôs technically true, but I mean...99.9% of people who are picking up a framework have enough prior knowledge to know not to do that :p I still maintain that while a framework can‚Äôt correct bad code and habits, it does rather roughly shove the developer towards doing things a certain way. Now I want a plugin for PHP Storm to distribute to all juniors that pops up a mean face and a wagging finger of mysql_* functions (or the like) are detected lol.
# Please visit /r/phphelp for help, or connect to ##php on Freenode IRC 
Yes. \``$_REQUEST` is "An associative [array](http://php.net/manual/en/language.types.array.php) that by default contains the contents of [$\_GET](http://php.net/manual/en/reserved.variables.get.php), [$\_POST](http://php.net/manual/en/reserved.variables.post.php) and [$\_COOKIE](http://php.net/manual/en/reserved.variables.cookies.php)" If someone sends a request to [https://secretsite.com/whatever?key=](https://secretsite.com/whatever?key=)\&lt;\&lt;WhateverTheHashIs\&gt;\&gt;, they win. If someone is determined enough, they can create a bot that will check every combination available until they find a correct combination. Validate using a `$_SESSION` variable or use a database.
Read the post. It clearly states this is a discussion thread. I do not need support.
Wew lad....
That's not how it works.
What nonsense. Okay... let's say it's SHA256, that's 2 ^ 256 or 1x10^77 possible options assuming even distribution. Now let's say it's expressed as hex, that's 64 characters long. Let's throw in some basic request and response headers to bring it up to say 500 bytes per request. That requires 5x10^79 bytes of transfer to brute force. Let's assuming that the target server has near infinite CPU and is powered by something with the power to sustain its computation for that long... let's be conservative and say a supermassive black hole, and let's say the network connection is capable of going 1TB per second... That would still take about a trillion trillion trillion trillion trillion years to brute force. So you might be able to brute force it just in time before the supermassive black hole that was powering it evaporated due to hawking radiation.
How long would that hammering take you, if the key was, for example, 128 bytes long? Not mentioning having DDOS protection against flooding servers with too many requests is a pretty common thing to have enabled nowadays.
cloud servers are cheap and bots are quick. I don't need to get all the keys, only 1.
so much this 
I think you are hugely underestimating the number of possible permutations and the miniscule probabilities we're dealing with here...
Maybe, but we're moving away from whether the code is secure.
The author's pthreads extension has existed since at least 2012, which is far back as github is showing me. He's just pragmatic about the present and the future, at least in regards to the PHP tech stack and ecosystem.
https://imgur.com/Q7fl6pY
He wasn't posting them as evidence PHP was bad, he was posting them as examples of code that has allowed PHP (and PHP developers) to gain their reputations. Shit developers write shit code, and it becomes a punching bag for the language. OP's point was that because the web is in PHP's DNA, it lets you build functioning web applications with *zero* structure, thought, or architecture. Slap some HTML, SQL, and PHP together in the same file, call it from apache or nginx, and you're good to go. It's much, much, harder to do that in other languages. If you were to build a web application in Python or Ruby, you sort of have to use Django or Rails, and thus sort of have to at least stay within the boundaries of the structure and architecture those frameworks provide. You can't just YOLO it like you can with PHP. This means that Python and Ruby web applications have more constraints on *how* they are designed, and it has led to less proliferation of the kind of things that OP had described. To be clear, I'm not knocking this as a problem with the language. I LOVE that it's a "bare metal" web-oriented language that lets you slime an application together if that's what you need. That doesn't in any way, shape, or form detract from the other awesome parts of the language or ecosystem.
Before changing out the tools, look at your database design, architecture, queries, indexes etc. Maybe hire a consultant or DBA to analyze your application. For example if you are having long transactions, why - are you getting deadlocks. What queries are running and why. Can you summarize data to seperate decision support queries from OLTP processing. Changing out the tools rarely fixes things, it just adds complexity, cost and time to your project. 
Hey, technical\_guy, just a quick heads-up: **seperate** is actually spelled **separate**. You can remember it by **-par- in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
This tool has both options. cloc &amp; duplicate code checker.
"Don't fix what ain't broke." Some people have been selling the same php code they wrote in 2005 year after year to client after client because NOBODY ELSE has gotten around to making what that niche industry needs for their websites in any other language \(not even modern php the right way\). People working with certain "better" technologies seem to be laser focused on getting certain types of job titles in certain cities at certain companies working on certain types of projects. They ignore the whole rest of the world that needs work done.
How do other languages prevent such things?
but this is really /r/phphelp, no discussion here really to answer your question directly, after the `die()`, page execution is halted `header()` doesn't stop execution so it's good that you followed it with a `die()` this is personal preference but I usually use `exit()` for exit success conditions and `die()` for exit failure make sure your hash is not guessable by robots or easily generated and look into $_SESSION if you need to grant access from a previous page
1.1.6.
you are the reason the community is so toxic.
you.
Good start. Keep in mind that you can fix a lot when editing the video: i.e. improve the pacing by cutting out irrelevant bits.
async/await save you a bit of boilerplate wrapping into extra functions if you want to return a Promise. Also eliminates the need to distinguish between what is generator and what promise - with async function it's just all a Promise. Sure it's doable - but having the async/await sugar is nice. Also having async/await would allow for using Generators in an async context: a simple iterable which can be awaited on.
Nope. But this is a good indicator that you should change that code to return an object instead.
I like this. I think the presentation style is friendly and approachable. It would not be intimidating for programmers learning PHP from scratch. And that's clearly the target audience: beginners. In which case, I would be bolder still and start right at the beginning. How do you install PHP? How do you set up a suitable development environment? Would you recommend a virtual machine, and what IDEs are best for PHP development? Don't assume any existing knowledge. The only other comment I would make is that, judging by the first video anyway, this is really about setting up some general boilerplate or scaffolding for PHP applications. That's not quite the same thing as building a PHP framework. A little adjustment and I think this could be a popular course on Udemy. What do you think?
I second this and previous reply but because of lack of generics in PHP when you want to have Option, Either or Tuple you end up with either what you‚Äôve started with (class that works with parameters of any type) or with dozens of classes like MaybeFoo, MaybeBar, EitherErrorOrFoo, EitherErrorOrBar, FooBarBizz, BarFooBizz, BizzBarFoo. Or you add a builder which constructs Option, Either, Tuple with type checking during construction which just looks terrible. Then you wonder, maybe there is at least a way to type hint what type has each of array elements. I personally still prefer having DTO for each case but I know a lot of programmers who got seizures when see this.
Maybe he likes duplicate code? https://en.wikipedia.org/wiki/Don%27t_repeat_yourself
If you call your stupid question a discussion it doesn't become so.
The problem is, r/php nerds want so desperately to prove how smart they are, that they feed these help threads with replies every single time without fail.
I built a PHP site from -scratch- over two separate 6 weeks for a not-so-local small business about 5 years ago. The day it went live, everyone, especially the CEO and my direct manager were **exceptionally** exuberant and even threw a corporate party (now that they had a website in 2015 they were "in the 21st Century"). I was going to stay with them, even tho I had other clients, for another few days to add any features they wanted. The next day, however, the boss, CEO, and a guy in a three-piece suit were waiting for me when I showed up. **NEVER A GOOD SIGN!** "How could you do it?!" my boss asked, dripping with incredulity. "Umm...." CEO: "We found your ::clears throat:: **declaration**." Boss: "How could you have done it?! We *were* so proud of the work you did! What was my declaration? A HTML comment at the top of the HTML that said &lt;!-- Author: My Name (my@email). Published in May 2014 !--&gt; Apparently, that was enough to get the contract terminated a week early and no repeat business. They even paid, grudgingly, the $1,500 early termination clause. But still. It was a total overreaction!
Write an application that shows you where local burger joints are.
Hi, Thanks for the suggestion! Event support if definitely something I'm looking at to potentially add to the lib, but I'll need to juggle terminology around as the word event is already in use with different semantics. If we take event sourcing (ES) as an example, they have 2 separate notions: 1. A fact that has already happened and the system needs to carry out the related work to fulfill this 2. An action that a user wants the system to perform, which it might or might not be able to do. If it's doable then it becomes a fact, like above. They call the first notion "event" and the second "action". So action is something a user initiates and can fail or succeed, while events are the results of successful actions. As an example you can tell the system "Please send this email!". This might fail, eg. you gave an invalid email address. If all is good, then it succeeds and creates an "email sent" event (with the relevant data) that in turn makes the system send the email. Now to futher complicate things the notion of event in S-Flow can either be an event or an action in ES's terminology, depending on whether it's conditional or not, because if it's conditional they obviously it can fail. These are my morning, just after coffee thoughts on the matter :) Definitely something to think about. Re how `deriveState()` works: `array_reduce()` in php is what functional programmers call a left fold. What happens is that you take a list of events and "fold them up" from left to right ie. from earliest to latest ie. in cronological order using a function (more specifically a binary operator). In our case this function is the FSM's transition function, which has the signature: `(State, Event) -&gt; State` ie. it get's the current state and an event and returns a new state. In essence this means that as you are folding up the list of events you are walking the state graph. Hope this makes it a bit more clear. Personally, as someone who's very fond of functional programming, I find this elegant and concise, but I appreciate that it requires a somewhat different mindset than imperative programming.
Good bot :)
Thank you, pwmosquito, for voting on CommonMisspellingBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
[Me too](https://github.com/ScriptFUSION/Template).
Brutal
I‚Äôve got an application that uses RSA keys along with SFTP to transfer files. My question is, how do most of you store/manage your public and private keys? Do you have a certificate directory, or store them in a table, do you version these files, or what? Is there any documentation that anyone knows of regarding the correct way to manage digital certificates?
you are right different teams have different testing strategies and you don't *have* to use Behat... but the changes to the service container were introduced to discourage people from using it in a way it wasn't designed to be used. If you are having to modify the behaviour of the container with compiler passes in order to make it work with your testing strategy, it is a pretty good indication that you are using it in a way it wasn't designed to be used. There are other strategies for all of the testing scenarios you talk about that don't involve calling the service container. I would argue that the problem that the article is tackling is better addressed by rethinking the testing strategy, than rethinking the service container.
Might be good if the index.php file moved to a "public" directory, per the pds/skeleton standard: https://github.com/php-pds/skeleton/tree/1.0.0 
Yeah, the videos are already pretty edited. Guess I have to grow in that aswel.
The nice people at php\-ug recently made a new url for it. But that should probably have nothing to do with it.
I have a small notebook with ideas for future episodes I was going to do after the framework series. These just made the list. Thanks! The first episode \(ep0\) is indeed just that, setting up the expectations and scaffolding. Future episodes are going to build on that. We aren't really going to write our own container or router as more so linking existing packages together in a useable framework. Getting on stuff like Udemy would be amazing, But I think I'm still quite a while off ;\)
That's true! for a web application it's better to have a public folder for entry point, it's more secure. as I use it most for package development I do forgot that! Thanks for reminding!
Of curiosity, how are you dealing with return typehints for IDE autocompletion from the factories? I.e., if you factory a PostgreSQL UPDATE query, can/does the IDE provide a hint for the extra `returning()` method? (IDE autocompletion was a driving factor in the Atlas "Cassini" series, and informed a lot of my decision-making.)
&gt; However, by far the overwhelmingly common use case in my experience is the one now supported by Atlas Query: that is, that you have a connection "in hand" and that you're ready to use it, lacking only a query to perform against it. Somehow, I don't see why that's an argument in passing the SQL connection during query construction. &gt; Noted, although the "might" is vanishingly rare; so rare, in fact, that at no place I've worked for or consulted at since 1999 has actually needed to do that Depends how "algebraic" you've made the objects. I find it extremely common to what to pass a predicate and columns to fetch and let the recipient finish the query (including supply a connection). &gt; so I could maybe see my way clear to adding a method that lets you swap out the connection. This wouldn't really work, unless you make the initial connection optional as well.
In this case, my [base query builder](https://github.com/opulencephp/Opulence/blob/1.1/src/Opulence/QueryBuilders/QueryBuilder.php) does not provide return type hints - the [derived query builders](https://github.com/opulencephp/Opulence/blob/1.1/src/Opulence/QueryBuilders/PostgreSql/QueryBuilder.php) do.
Just wanted to point out that Symfony already has it's own approach to integration testing. No real need for Behat. But I fully agree that any automated test that requires direct access to the container is something that really needs to be thought about and avoided if possible.
Link is dead
PHP is not difficult though using it correctly can be challenging. There are a gazillion articles on why php is so bad especially in comparison to other languages. The debate has been going on for decades. It's interesting how many of the "better" languages have gone away while php just keeps plugging along and getting better. Make sure your bootcamp is teaching php 7 (ideally 7.2). Major improvements between 5 and 7 (there is no 6). So if the camp is teaching 5 then it shows the camp is not keeping up to date and you will almost certainly pick up bad habits.
Well I disagree :) The changes made to the container were not for discouraging people to use it in a way it was not intended for. That usage is perfectly valid and legitimate. The only reason is for performance improvements nothing else. Typical example: I have an adapter for a third-party code/service. You can have units tests there to test some stuff like how many calls are made or something, but at the end of the day the unit test doesn't guarantee _anything_ here: an integration test is required. So sure you can have a higher level test that is going to partially test that service somehow, but it might be easier and better to have a proper integration test for that adapter. Now you can always instantiate the service a certain way without the container for the tests, but at the same time if it's really a tedious step and retrieve the service directly from the container (which has a better guarantee that it's configured the same way as in your prod app), then I don't think there is a good reason to not do it
It's a bit of extra boilerplate if you want it to be exactly the same, but you can always pass control along from generator to generator with a `yield from` instead of the `yield`. That can help a \_bit\_ with using generators in an async context, though I'll admit that's a nice to have. e.g. AMP and Guzzle should actually handle the coroutine at the very bottom of your stack \(which is likely either in an event loop, or in waiting for the Psr\\Http\\Message\\ResponseInterface to return to whatever router you have.\) use GuzzleHttp\Promise as P; use SomethingAsync; function top() : Generator { $foo = yield SomethingAsync::makeAPromise('abc'); $foo-&gt;bar = 123; return $foo; } function middle() : Generator { $foo = yield from top(); $foo-&gt;setBaz( yield SomethingAsync::makeAPromise('def') ); return $foo; } function bottom() { P\coroutine( function () : Generator { $foo = yield from middle(); echo $foo; // =&gt; "I'm abc with bar 123 ,and my baz is a def" } ) -&gt;wait(); } You definitely _could_ take a "promises everywhere" approach like in ecma and wrap every one of those things in `P\coroutine` or `AMP\call`, but I'm questioning now if we only think to do that because we're used to it from ecma. The `bottom()` function there probably wouldn't even need to be written by you. Uou could even DI one of these guys and pass running coroutines. It's just `function something() : Generator {` in php vs `async function something() {` in ecma, and I'd argue the former suits the PHP-style better. 
Just a side note, other programming languages have a concept of "tuples" which is a collection of fixed items where each item can have a dedicated type. There are some good use cases for it. One example of such a language would be Rust: https://doc.rust-lang.org/book/second-edition/ch03-02-data-types.html#the-tuple-type Also note that, even though wrapping these values in an object is the right thing to do; there's no more type safety with this approach than the array example, unless you're making a full blown object with private properties, a constructor and getters. An indication that there are valid use cases for tuples.
Whoa. Business people and their aversion to building things. How can you be the manager of the hottest project in the company if you have to go through *years* of building software and market share. I wan't to drive over the floating bridge in my GranTurismo Convertible *today*!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Probably burning through money like a sailor back in port...
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Title question: It's not hard, and shouldn't seem hard Last question: Yeah, you're giving up to quick - Also, nothing holds a candle to PHPStorm for PHP development. It woudln't be hard to debug codeignitor. Just enable the debugger, set a breakpoint, and run the page.
Are you setting/using breakpoints?
I hate to say it but sometimes the easiest way to trace things through in large projects is by debugging things through the browser. ``` echo "&lt;pre&gt;"; try { throw new \Exception("FAIL"); } catch {\Exception $e) { echo $e; } echo "&lt;/pre&gt;"; ``` Don't shoot the messenger, I said easiest - not best!
Yeah, but I was using Eclipse, and I was having trouble with creating debug configurations. I cant seem to just make one and put breakpoints anywhere. They don't get stopped at.
PHPstorm has the features of webstorm in it, but I don't think that's true the other way around... in this case, the PHP debugger features would be what you need.
Nope, Code Igniter is one of the more straight forward frameworks to debug through \- even if the breakpoints aren't working \(though, this would kind of suggest it isn't hitting your code, or the debugger isn't being run correctly by the IDE?\)
Laravel is great for simple and fast solutions. Besides Laravel Framework has some tools to facilitate common tasks: authentication, sessions, caching and others. If you need a piece of advice or pricing, check out this one [https://r\-stylelab.com/technologies/laravel\-development\-services](https://r-stylelab.com/technologies/laravel-development-services)
sorry still not clear on deriveState() maybe i am being dense, but i get how it works, i dont get is how to USE it. i was wondering can you provide an example use case in which someone would pass an array of events to derive the state. i cant get my mind around how that would work. Also would it be possible for some way the return of the event could be made more sophisticated perhaps the result of a closure or something. In my workwe have a problem which needs a state machine because we have a "work order" which can have its status changed but the status changes can be valid or not valid depending on a number of factors. So my concern is i dont want to just create another big function with an "if" ladder to dump out the correct transition. if that makes sense what im saying here
I use PHPStorm to debug and it works well when the path mapping is set up correctly. Typically you have to set up some mappings to tell the debugger where the framework files live relative to the entry point. 
[Psalm](https://github.com/vimeo/psalm) and [Phan](https://github.com/phan/phan) suppport a syntax like this: [https://getpsalm.org/r/7ab7d5bb85](https://getpsalm.org/r/7ab7d5bb85)
&gt; Is the company profitable? If you have to ask, then the answer is 'No'.
i swear by the debugger! use PHPStorm the first set up can be painful. make sure xdebug is installed, and set it up in phpstorm. add breakpoints early on in the call and the debugger will break there and you can see the values of all variables, etc F9 to step through once you see the debugger, you'll never be able to go back 
I'll sit down and give you a real reply. Looks like you have this going in production somewhere or it wouldn't be this robust. In my opinion YAML files have no business being in controller or model configurations for PHP projects. PHP already has a way to define variables and you can use basic PHP configs. By adding a YAML layer you're just adding to what can go wrong during setup and installation. You convert to basic PHP configs anyway so why this extra step? It should be as easy as extending your base API controller, setting the name of the model class as a static configurable, and routing to it. Instead you have a very verbose and messy configuration system which gets converted right back to a PHP config. Validation should be done at the Model and be bubbled up if invalid up to the controller. The controller should not need to know that some field you have is required. The model should throw that error and the controller should simply pass it back as a problem. Also I don't like this Route::get('/article', 'ArticleController@index'); Route::get('/article/{id}', 'ArticleController@view'); Route::post('/article', 'ArticleController@create'); Route::patch('/article/{id}', 'ArticleController@update'); Route::delete('/article/{id}', 'ArticleController@delete'); The main path should never be used to create. You should have /article/create so you can use methods PUT or POST at will. Route::post('/article/{id}/update', 'ArticleController@update'); Route::post('/article/{id}/delete', 'ArticleController@delete'); These should be default routes. Yea methods other than POST or GET are great but forcing people to use DELETE to delete a record is pedantic. Offer both. Why? Because XHR tab in inspect tab on chrome doesn't even show you the call method unless you click into it. It's conceivable that you're pulling data, then creating, and there's no way to known which is which till you check each individual call. That is inherently messy. A green coverage badge at 76%? No. The auto generator is nice but then again you wouldn't need it if the config wasn't so verbose. Having to define a bitmask permission system in the config is a huge antipattern forcing authentication, groups, and permissions logic into controllers where it doesn't belong at all. Controllers should have simple permission checkers that default to return true. bool checkWritePermission(&amp;$model), bool checkReadPermission(&amp;$model), bool checkAPIAccess Have your custom permission stuff in there. Provide examples people can extend and override so they can use their existing permissions system. Anyway that's just my 2 cents. I'm just a random on /r/php. Don't feel bad.
This is true. Basically the query should be as abstract as possible as long as possible. And fewer dependencies is always better, anyway
If you're making your repositories/mappers/whatever receive predicates and columns to fetch than you can make them construct the SQL query behind the scenes. I mean if you abstract them enough so they don't show a dependency on an SQL storage, why would you pass them an SQL query object to work with?
For the life of me, I could not get phpstorm to work with a debugger. Can you share some details about the debugger and how your development environment are set up?
what type of development environment do you need to have in order to set this up properly?
i've only ever debugged locally (code local, web server local). apparently you can remote debug although i've never tried this
hmm i'll have to try and set up nginx on my mac and get a local web server set up, then. 
something as simple as MAMP would do it too yes good luck, let me know if you need help. the process can be really hard setting it up, or it might just be ezpz
I don't know many companies raising millions that are profitable.
You can draw the line before fetching and say "the query object just produces a string". There are two problems with that: 1. You already need a connection in order to determine what SQL dialect to product a string for, what the charset is (affects interpolation if any, etc.), what features the server version supports. So you need a connection. 2. It prevents you from fulfilling certain queries in multiple steps, say within a transaction, which allows you a much more flexible query format, and wider compatibility among databases. As an example of the the second point, when fetching structured data, sometimes the best way to execute this is a single SELECT with one or more JOINs. This is the ideal approach for 1:1 relationships. However in 1:N relationships this can lead to lots of duplicate data, and so the best approach can be to fetch the "top-level records" in one SELECT, and then fetch the sub-records in a second SELECT. An abstract `$query-&gt;fetchAll($connection)` API can abstract the difference and do what's best without bothering you with the difference. But for this to happen, the query should be allowed to do the fetching. There's no right and wrong here, it's about where on the abstraction ladder you imagine your object to be. If you see it purely as a PHP object representation of the MySQL or PostgreSQL grammar, then you don't need this stuff. But if you see the query object as an abstraction with more general application, then many new interesting features becomes possible.
It depends on which step of the abstraction ladder you imagine this objects sits on. If you imagine it as a purely 1:1 object mapping of the **exact** MySQL or PostgreSQL grammar, then it doesn't make sense to pass it to repositories. But if you see it as a more general purpose, vendor-neutral query object based around SQL, then it makes an excellent way to repositories to take in requirements for information to return. SQL is not just a specific set of databases: MySQL, PostgreSQL etc. It was always designed to be an abstraction that fits around most databases in general. This is why many "NoSQL" databases happen to support some sort of SQL subset these days. SQL makes sense: I want this and this column, where this and this expression matches, ordered that way, ascending... There *aren't many ways to describe* that to a repository, that **wouldn't look like SQL** in the end, you know? Of course a repository can choose to support a given aspect or not, but if you have the building blocks, you can use them, rather than reinventing the wheel every time. Nobody likes a repository with a hundred methods like `-&gt;getTop100NewsOrderedByPopularity()`.
like others said, i'd return a "ActionResult" object that just contains those properties. future self will thank you. plus it allows the ide to help you
# /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC 
&gt; // ambiguous. am I accessing the getter or the private property? You're accessing the private property directly. The PHP magic method is only used when the caller code is trying do access a non existent or non accessible class member. That's why PSR doesn't have any documentation about that, it's not a naming/convention problem.
What is platform.sh?
up yours
It is shameful how many websites assume you know they are about before you visit. I can forgive a blog page, like OP's article, for not having a brief sentence that tells you what the company is. Although, that is ideal and IMO should be included in virtually all websites you are not logged in to. I can not however find any excuse for not describing your company on your website's homepage. Seriously, click through to their home page. All you get are a bunch of cloud buzzwords with no explanation of what their services actually does. 
shh.
https://platform.sh/company
_get is called when property don't exist or is not accessible. So -&gt;age depends on context of use. So following code: class bob{ private $age = 'property'; public function getAge(){ return 'method'; } public function __get($name) { $getter = 'get' . $name; if (method_exists($this, $getter)) { // read property, e.g. getAge() return $this-&gt;$getter(); } } private function ohGod(){ // ambiguous. am I accessing the getter or the private property? echo $this-&gt;age; } } $x = new bob(); $x-&gt;ohGod(); //property echo $x-&gt;age; //method 
Debugging remotely, even in a Docker container, isn't difficult either. The PHPStorm documentation most people will need.
awesome. i could see maybe doing this on a QA server or something
I would also add a csrf token to the previous page. Then only that page can submit to this page
&gt;Platform.sh is a VC backed startup headquartered in Paris, with ofÔ¨Åces in the US, UK, and Germany and employees across Ô¨Åve continents. 
This sounds like the perfect thread to pimp my debugger https://github.com/bkdotcom/phpdebugconsole easy peasy. it can output the debug log as *`&lt;script&gt;` tag, * html (complete with expandy/collapsy groups &amp; object properties, etc), * text, * [chromelogger](https://craig.is/writing/chrome-logger/techspecs) headers, * [firephp](http://www.firephp.org/), headers, * publish to a [wamp](https://en.wikipedia.org/wiki/Web_Application_Messaging_Protocol) router has all the methods that javascript console has: * log * info * warn * error * table * trace * assert * count * group * time * groupCollapsed * and a few more you can call the methods via the debug instance: `$debug-&gt;log('foo', $foo);` or call the methods statically: `\bdk\Debug::_log('foo', $foo);` feedback appreciated
As long as your internal interface is all Generators, it's fine. But you don't really want an external interface with Generators instead of Promises. Also: does it matter _where_ in the stack a Promise is handled? In Amp we don't unwind the stack for performance reasons - immediate success or failure is actually not that rare and shows a significant improvement in regards to CPU time and latency.
Way to write a paragraph with absolutely no meaning whatsoever. 
&gt; I don't understand why you would use them on PHP since everything is synchronous Not since PHP 5.5.
üòÇ
I understood "it's a company". I feel so much enlightened...
Mailhog is a single standalone binary, like any standard program on your system. Is it really that onerous to set up?
You can do async on php. amphp is a good starting point, so is react 
There are 3 projects [\(](http://reactphp.org/)amp/reactphp/swoole\) implementing slightly different versions of reactive \(event\-based\) architecture, in PHP. And probably a bucket\-load of smaller stuff too, but without any PSR defined i don't think that they will be compatible. Btw with any of them you can use async i/o , event\-loop etc..
Did your email address have deploy-to-prod rights, like with Envoyer.io where a github-linked account with push rights can deploy the latest commit to the prod server in exactly 2 clicks? If so it sounds like a backdoor to me...
Hey all. I have been with Platform.sh from the start, happy to answer any questions. The company hosts web applications featuring an automated build process, a full environment per git branch, and fast data synchronisation. It means when you push a new branch, you get your runtime (php/ruby/node/python/java/.net/go), your backend services (mariadb/mongo/redis/elasticsearch/solr/rabbitmq), *and your data* - all of it, db, files, indexes - all within a minute or so, ready to test and develop against. From there we can scale outwards and upwards, featuring a nice triple redundant stack that allows zero-downtime vertical scaling to hundreds of CPUs. We run the Magento Cloud, the eZ Platform Cloud, the Symfony Cloud, as well as hundreds of enterprise grade clients' websites. We're hiring like mad onto our completely remote team (ok, well, we do have an office in Paris where 15-20 people show up on any day, but the rest of us work from the couch). Thanks for checking us out on the big day of our fundraise!
We were actually called Commerce Guys in the first raises. You can see the history here: https://www.crunchbase.com/organization/commerceguys The pivot to Platform.sh and being a web app hosting company was complete at the beginning of 2017.
We're not profitable. We could be, but it would mean curtailing research and engineering, and we have a comprehensive product vision that we want to realize as fast as possible. We made two plans - organic growth or jet fuel - and we went for the jet fuel.
Actually, one of the things that our new round of investors likes is how frugal we've been. We wouldn't have been around for so long (in one form or another) if we were careless with the dollars (or Euros, in our case).
In that situation, it would come down to user/key management. User audits and rotating credentials should be a routine affair, so I fail to see how.
Looking at their homepage, on mobile... My best guess is that they are sort of like heroku... A bunch of ala cart services from deployments to container hosting and scaling. 
Yes, PHP itself is synchronous. Unlike JavaScript, there's no built in event loop that's always running. That's why you have to run one yourself if you to run ReactPHP or amp. They all come with their own event loop implementations \(usually based on [stream\_select](http://php.net/manual/de/function.stream-select.php)\). There seem to be adapters that make libraries written for one event loop compatible with the other.
But are they making the world a better place?
My setup is a Vagrant VM running PHP-FPM w/ nginx as a frontend server. PHP-FPM is configured for debugging as follows: zend_extension= /usr/lib/php/20151012/xdebug.so xdebug.remote_enable = 1 ; Wont work without this option xdebug.remote_host = 10.10.1.1 ; IP address of my host machine xdebug.remote_connect_back = 1 xdebug.remote_port = 9000 xdebug.remote_autostart = 1 ; Important: automatically attempt to connect to debugging client xdebug.max_nesting_level = 512 The xdebug.remote_autostart option will make life a lot easier. Normally, xdebug won't start unless it receives a magic value in the HTTP request. If you don't have remote_autostart, then you have to install a browser extension that adds a magic value to the request. You may also have to install additional packages on your development box to enable debugging. IIRC, xdebug is not installed by default with the base php package in Linux ("php-xdebug" for Ubuntu/debian). To test your debugger configuration, turn on debugging in PHPstorm by clicking the little telephone icon in the top right corner. Send a request to your server by browsing to your PHP website. You should see a notification in PHPstorm about missing path mappings/ no breakpoints triggered. At this point, you know your debugger is trying to connect and you can proceed to set up PHPstorm for debugging. You'll need to add some path mappings in PHPStorm. Basically, this tells PHPStorm which source file to open when it gets an incoming connection from xdebug. For my setup, I had to configure two paths because my index.php file is nested inside the project root. Here's a [screenshot](https://imgur.com/a/dNHoDeG). You can find the path mappings settings under Preferences &gt; Languages and Frameworks &gt; PHP &gt; Servers. At this point, if the debugger and PHPstorm are configured correctly, breakpoints should work as expected. If not, try enabling the "Break at first line in PHP scripts" option under PHP &gt; Debug. Also check that PHPStorm's Xdebug port setting is the same as your xdebug config file. Good luck, hopefully this post is somewhat helpful. 
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/6F5Dw39.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) 
I would like to work there. I‚Äôm full stack with a focus in Angular, Laravel and Express. Have our own office because I‚Äôve always done remote. Sounds fucking sweet although I‚Äôll miss my ‚Äútry deploy again‚Äù commits to trigger Jenkins. 
We have a winner!
What specifically changed in 5.5 to make it asynchronous? 
There are projects, as mentioned in other comments, that provide an event loop in php but in my experience promises are mostly useful for [async http requests](http://php.net/manual/en/function.curl-multi-init.php) using curl. Having said that, If I'm working on a project needs concurrency, I almost always default to goroutines in go because they are simple and I'm lazy. 
Set the breakpoint in your own code, not the plumbing code.
How is this related to PHP as a programming language? Please elaborate.
Generators were added. That's not the first time async was possible in PHP though. `exec` was added in v4, so technically PHP supported async and parallel execution models from that point on.
&gt; Deploy any **PHP**, Node.js, Python, or Ruby application. It's a stretch, but I guess technically that's php related? Idk. Seems like this should be on /r/webdev or something, and it's just posted here for exposure. There's no *actual* PHP here though.
My experience with PHP in eclipse are a bit dated, but currently I use VSCode for PHP and it's doing quite well - faster than I remember eclipse to be. What I have to do to set a breakpoint is call xdebug_break() - I don't know if this is a requirement for xdebug or just my configuration, but it might help you. 
We got generators, which allow for a nicer way of writing async code. But we've had [ticks](http://php.net/manual/en/control-structures.declare.php) for a long time, and you could have implemented async requests before that with an event loops.
People usually use them do IO (requests, mainly) in the background. Barring web workers, javascript is also synchronous and single threaded, but it does have a built in event loop which gives that feeling that it's not. You 
Lol. I inherited a Magento site on their cloud solution. What a terrible experience that was. Magento had a fundamentally broken CI pipeline, would often release patch releases of their code that would break features, could barely scale their platform. It got so bad that I finally convinced the CMO that we needed to jump ship and we pivoted towards Shopify with 1 month and a bit until BlackFriday weekend and succeeded - growing our D2C biz x 3. It's not that Shopify is the most amazing platform, but rather that Magento has some deep fundamental issues and supporting it was a full time job - especially once you start customizing it and installing third party modules. Instead of that, now our site runs on Shopify, but with the help of Shopify's API, we've built all the customizations to interface with their API instead of a highly customized codebase. Inventory is managed with external services, orders are funnelled through a simple but high performance ESB I architected that also creates audit trails, customer service now have a very efficient workflow to handle CS issues by means of a bespoke, internal tool we built, we can support multiple backend systems / ERPs, the list goes on. But the main thing is, these all interface with Shopify via APIs, so are individually simple applications and not bloatware that Magento installs grow into. I could have done the same with Magento and I would have, but the person I took over the job for had signed a 4 year contract for Mage Cloud, which restricted me from doing just that. Had that not been the case, I would have likely build the site in Laravel and just isolated Mage to the checkout experience. We're in a better place now regardless with Shopify. So... good luck Adobe!
PHP 5.5 and Generators changed nothing about the fact that PHP is synchronous and has no built in event loop. I'm not saying that that's a bad thing, but saying that PHP is asynchronous since 5.5 is totally wrong.
145 GB is not big enough to require a distributed database. As mentioned by others, look into hiring a DBA expert to advise on how to tune your database. Set up read-only replica's for queries which can be delayed (anything that could be fed by elastic can probably be fed by a read-only replica). Stackoverflow runs on a single SQL Server instance, and postgres should be able to match that capability, so unless your site is bigger than stackoverflow you can probably make it work without going nosql. If you do decide to go distributed, don't expect black box behavior. You're going to need to understand eventual consistency and the way that data gets replicated through the database.
If you look at the readme there‚Äôs a worked example of how to use it. After you defined your FSM you literally pass in an array of events into deriveState() and it gives you back a state. You can also look at the tests to see further examples.
Most answers so far are discussing async, but it‚Äôs worth noting that promises can have meaning and purpose even without ‚Äòtrue‚Äô async support - the internals are different, but the idea of delaying execution and having promises track the state/order is still the same. In the context of webonyx/graphql-php, this is important because its design means resolvers get called object by object, one by one. Having promises allows batching: individual resolver calls can cache IDs/whatever they need, then return a promise for a (single) Deferred. When the overall graphql framework has nothing left to do, it will work through the queue of Deferreds; your deferred function runs once, loads everything that was cached, and each promise is resolved. See overblog/dataloader-php for an implementation of this pattern, mimicking [the original JS dataloader](https://github.com/facebook/dataloader) 
Request = post &amp; get not cookie.
&gt; `exec` was added in v4
https://stackoverflow.com/jobs/companies/platform-sh Hope you apply! 
One thing that came first in mind that intro music is really loud, specially if you use headphones. I would also recommend using maybe headset mic or some place where sound doesn't echo that much, sound quality is probably weakest part of videos, but it's also easy to fix. You could also described some required skills for this series in first episode. For example I assume that it would be quite hard to follow if you don't know how command line works or have no idea what interfaces, controllers, etc. are. So mentioning that series require some knowledge about patterns, etc. would be good thing. If you want more beginner series, I would recommend to explain things bit slower and more deeply. And probably use more graphical interface to view files and some easier servers like XAMPP/WAMP/etc. If this series is aimed to be more advanced users, like I would see it, then points for using PSR\-standard and other stuff that are considered as best practices. And there are so many tutorials and videos for beginners so this level tutorial is IMO quite welcome. As long as you keep your target audience in mind when explaining things. Specially in first video you explained some basic things about files and folders that probably everyone, who I think is your target audience, already knows. Mentioning phpcs and other tools would be also good thing, specially when you going to use PSR\-12. All in all, good work and I probably watch future episodes as well just to see where this is going. Hope that this would have existed few years earlier when I tried to learn how dependency injection works. This kind of videos have taught me much about programming when I was still learning basics.
So what? Emulating concurrency with bash? 
didn't you checked why it so sensitive to RAM? Also, why didn't you tried to use go + php-embed instead of node? This probably should work much more consistently without much of overhead.
This sounds like the AWS devs have a lot of work to do to optimize PHP on lambda. 
&gt; didn't you checked why it's so sensitive to RAM? Quoting the article (which is also quoting the documentation \^\^) &gt; I ran the test for several memory sizes: lambdas ‚Äúsizes‚Äù are configured through the memory. More memory means more CPU, but also higher costs. &gt; &gt; AWS Lambda allocates CPU power proportional to the memory by using the same ratio as a general purpose Amazon EC2 instance type, such as an M3 type. For example, if you allocate 256 MB memory, your Lambda function will receive twice the CPU share than if you allocated only 128 MB. Regarding Go this could be an option but: - NodeJS has 0ms overhead on warmed up lambdas - NodeJS has 2ms overhead on cold starts, compared to the PHP time it's negligible I think the conclusion is the same as with Python: &gt; We can also see that Python has lower cold starts than Node. Bref could switch to Python as the language used to invoke PHP but the gain seems to be minimal compared to PHP‚Äôs execution time. So for now I don't think there is a gain to using Go to run PHP.
Right now this is not AWS running PHP, this is a bridge written on NodeJS lambdas (see http://mnapoli.fr/serverless-php/ for the details).
This is really useful: http://mnapoli.fr/images/posts/serverless-performances.png When PHP 512x, it's about 90y. On the other hand, node is at 20y 
Oh sorry I did not realize you were talking about something different than using php-cli, do you have a link that explains more about `php-embed` with go? Is that https://github.com/deuill/go-php? That's a very interesting lead in any case.
Running things in in a non-sequential manner. It's no more emulation than `stream_select` is; in the sense that a single PHP script can't benefit from `stream_select` without an external (albeit possibly another PHP script) influence. Still, let's not split hairs. I think we're both trying to say async has been possible for ages in PHP. Correct me if I am misunderstanding your point...
What is a mutable constant?
A constant that you can mutate / change.
That's called a variable.
Can you give an example of a "mutable constant" in another language? It seems you are confused... 
Yep, and if you want one you can access from a class like a constant then it‚Äôs a public static variable. class Thing { public static $val = 4; } $x = Thing::$val; Thing::$val = 10;
That's a variable. A constant mutable is like a round square, something that doesn't make sense. 
Public static looks like it would do exactly what you're looking for. Since you'll have to prefix the constant with $ it also self describes itself as mutable too.
It's weird because of the way they are "created". In other languages it's not possible to create them on the fly.
Someone had to do it ^^
Yeah, it's an oxymoron
That's great (and unusual from a startup!) to hear. Best of luck with it. $34M in sensible hands will help you go far. On a separate note. You need a more simplistic overview about how it can help me as an overworked, time-light "manager". These days I do not have the brain power or attention span to work out how Platform.sh can help my company. I've given it a 5 minute review and it is now in my "could probably help us, but won't get a chance to look at in detail for some time" list. Also known as the "realistically never going to happen" list. If you could make the site a little easier for semi-technical people like me to understand how it works, then I'll be able to put it into the "going to give this a go very soon" list. For example, your home page is too focussed on marketing - many buzzwords and fantastic productivity stats! However, the docs are too complicated (Big Picture, straight into Structure architecture etc. is far too low level for me to understand how Platform.sh can help me). The best thing I have found is the "Platform.sh in practice" video. I think I understand what Platform.sh can do to help me, but the thing I am missing though is, how do I get to keep my current production server, which took time and effort configuring when using Platform.sh. Do I need to move my production server to Platform.sh? Thanks for your answers. I'd like to become a customer if it can help me, but you've still got a way to do to sell it to me. Cheers!
Super feedback, thank you! If you‚Äôd like a personal demo, let ne know and we can schedule a screenshare: robert@platform.sh
You can use the Reflection method getStaticProperties to list static properties, and they would be mutable.
PHP does not have immutable variables either. Go figure.
What makes you think this is a feature php is missing? What real world use cases can you think of? 
I cannot see any reason to have a mutable constant \- if you're declaring a constant, it's because you want it to be constant, surely?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [PHP needs mutable constants, and immutable variables, and functions with properties!](https://www.reddit.com/r/lolphp/comments/8ls8a0/php_needs_mutable_constants_and_immutable/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Your mistake was taking your asinine fuckwittery to Reddit. Keep it within the closed walls of your soon-to-fail company.
Can you post the simple search query that takes 20 seconds?
I.. but... ugh. Fine. http://php.net/manual/en/function.runkit-constant-redefine.php
In JavaScript, `const` means "can't be reassigned", not "can't be mutated". ``` const object = { foo: 'bar' }; object.foo = 'baz'; // This is allowed object = { foo: 'baz' }; // This isn't ```
NO
&gt;const mut OBJECT = "Foo"; Oeh YES! Amazing x'D
shut up and take my money!
There are still plenty of non\-best\-practice things, like the large range of constants and globals in use \($USER, $CFG, $COURSE, $DB, etc.\) \- if it was built on \(or as\) a modern framework, it would be very different. Some parts of it are really nice, most of the plugin points \(auth, enrol, etc\) are done really nicely, and haven't changed masses over the years. Course formats, on the other hand, have gone from procedural files to proper OOP. Themes have changed a lot, the output renderers have a long way to go still, but they're still better than the \(procedural\) header and footer php files that used to exist in the theme folder. The jump from 1.x to 2.x was huge, functionality and design wise, I haven't dealt with 3 much as it only started to filter into projects as I left. The company I worked for was an e\-learning company \(thus the focus on moodle/totara\) but we also did a lot of custom development in the local plugin directory \(affectionately referred to as 'the wild west'\) to meet client requests, in this, we were effectively using Moodle as a framework \- require config.php to bootstrap, and off you go. 
Thank you - just sent an email.
Whether we agree with the requested feature or not, this is the actual discussion to be had. All of you "oxymoron!1!1lulz" commenters need to come back and upvote parent.
PHP is pretty cool at doing async stuff - that's *async* though, not threaded. Any time I need to do more than one HTTP request in the same process, I use Guzzle's `requestAsync` method. I work at [Help Scout](https://www.helpscout.net/) and while upgrading our [Infusionsoft](https://www.helpscout.net/help-desk-integration/infusionsoft/) integration, we were able to take a 5 API request taking 6+ seconds down to less than 3 seconds on average by moving the requests to Promise based async calls. While it has its benefits, you can still get into callback hell with PHP Promises. AMP does a great job of avoiding this by using coroutines by default. Guzzle has this built in, it just takes a little training of the brain to get used to them. https://gist.github.com/yched/9aa2bf5e30fa764c646e9f7f9606835c
As soon as you have two or more parent classes it's likely a code smell as in a bad/or no implementations of design patterns.
&gt; Hhmm me and my colleague Sorry I have to notice, but every time you say "me and my colleagues" I flinch. It's quite alarming both you and all your colleagues apparently don't know basic terminology and features of computer languages in general, including the one you're working with. In any average company, there'd be at least one of your colleagues laughing their ass off when the question of "mutable constants" is raised. Yet that apparently didn't happen there.