Cool. Go to 7, skip 6, and *continue* to falsely demonstrate to the web development industry that PHP is a flaky language that modern enterprise and start-up apps should stay away from... It's already hard getting non-WP/Drupal/Joomla PHP work, what's a few more "could-be-custom-PHP-but-we'll-build-it-in-python-instead-because-lolphp" apps? Sheesh.
I have quite a few at any given time. I think its better to release something than nothing. * [Stampie](http://github.com/henrikbjorn/stampie) Simple, Lightweight mailer library * [Bernard](http://github.com/bernardphp/bernard) My attempt at bringing structure to background messaging * [Flint](http://github.com/flint/flint) Silex meets Symfony Standard edition * [Tacker](http://github.com/flint/tacker) Configuration from yml,json,ini files and injecting into Pimple. And a whole lot more, even some i just have refactored out from pull requests (with the permission of the author) * [Lurker](http://github.com/henrikbjorn/lurker) Watches the filesystem for changes (events) originally by Everzet of Behat fame.
I really like this! at a glance the syntax looks kind of weirdo (`$book-&gt;{1}`) but the overall looks promising. Great work!
I'm sure we'll get a lot of flack from the Perl community because Perl 6 has been such a great success, or maybe Python with Python 3, or Java with Java 8, or 1.8, whatever it's called, or... you get the idea.
So first off, you should write tests around *everything*. If it moves, it should have a test. That test can be as simple as "hit this endpoint over http and make sure it returns the same html as before", but without tests you'll never know if you break something. Second, that's definitely a good idea! You should, as much as possible, replace the un-framework with a framework while extracting the core business logic outside of the framework itself. Whatever framework you choose should end up being little more than a thin wrapper around HTTP handling and calling into your core business logic layer. Not only does this make it easier to test, but it makes it easier to eventually replace or upgrade that framework, because you're not stuck trying to deal with framework inconsistencies between versions either.
But they kept their version numbers in line
decided to put this up on to github for this post: https://github.com/slifin/failingsand It's a falling sand game that barely works but is multiplayer :) demo : http://failingsand.meteor.com/ edit: sorry I can't read, this is not a PHP project 
I think this is totally valid.
This is *exactly* why I wrote [Modernizing Legacy Applications in PHP](http://leanpub.com/mlaphp). I know you want to "replace it with a framework" but the code probably is not well-separated enough to do that right now. The book shows you, with step-by-step instructions, how to get those separations in place. By the time you're done you'll have a codebase that is autoloaded, dependency-injected, unit-tested, layer-separated, and front controlled. Then, once all that is done, you'll have a domain layer that should be easily extractable, and the rest can be converted to whatever framework you like -- provided you still want to do so at that point. EDIT: Some reviews are at &lt;https://leanpub.com/mlaphp/feedback&gt; .
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
*Some* version number needs to be used internally. PHPng used 5.7.0-dev, because that's what it was branched off, and this caused one highly visible blog post to proclaim that PHP 5.7 is going to use PHPng. As such it's better to use the right version number sooner rather than later :)
Don't worry, I'm sure somebody is already about to publish "Beginner PHP 7 Enterprise Programming"
I think you're going to have a hard time if you're stuck on PHP 5.2 - a version that's **over seven years old** at this point. Since you plan on doing a full rewrite anyway, is there any reason you can't migrate to a server with a more modern version of PHP? Regarding abstractions and removing reliance on a framework, it doesn't have to be 100% abstracted to realize a ton of benefits. I've found that a moderate amount of abstraction goes a long way toward improving your application's architecture. Plus, being able to run most of your tests without having to spool up the entire framework each time (and without Lovecraftian nested layers of mocking) makes things to much faster.
"Lovecraftian nested layers of mocking" is the best line I've read in a long time, and it carries at least three meanings. Nice turn of phrase!
In the description he mentions a HAT stack (HHVM, Apache 2.4, Trusty)... What is Trusty? It was a pretty generic word to get google results from.
Actually it hides itself by not showing the payload to crawlers and website admins, which makes sense if you want to keep a low profile. If the admin will try to check what is going on will not receive the payload and crawlers will not mark the website as dangerous (*see google bot*). From what it looks like at a first glance, the website visitors are the targets, not the server.
Don't buy or even read this crap (or anything from this user).
If I understand correctly, the thing you're looking for is something slightly different. You've been using HTML/CSS and Javascript with JQuery. The code you write with these technologies will run on the client web browser. You could be running javascript on the web server, but I doubt this is your situation. The HTML/CSS/JS code you write, in your situation in these 6 months, runs in the client web browser. When a web page is requested from a web server, you can do more than just send the HTML/CSS/JS. You can keep a database in the server, and whenever a page is requested, look up some data in the database and generate HTML based on that data (like a table or a list). Then, instead of simply sending some fixed HTML, you can generate the HTML you'll send on the fly. The idea is that there are various reasons as to why you'd like a program to run on the webserver whenever a web request is made. PHP programs will run as these server side programs. So, you'd not use PHP instead of JS. You'd use it with, together, JS. The client would request a web page, and your web server, in return, would run a PHP program which would generate the appropriate HTML (maybe from the contents of a file or a database) and send that to the client. It's not really what PHP can do, but rather what you can do by having programs running on the server side of the client-server communication.
Oh, I understand that PHP that is server-side. Can you please give me example of where PHP is used to dynamically create html base off of an database. I understand I probably wont have a real need to build I am personally interesting in this kind of stuff.
Reddit keeps our comments, posts, and so forth in its database. It doesn't have to use PHP to generate out of its database these HTML pages we see, but it could. I don't particularly know the programming language reddit uses in its server side programs. These "persistent" content that, for example, users collaborate with are stored somewhere. The server must somehow build a HTML based off this content. This is done through a program which captures that saved content and builds an HTML based on it. __Edit:__ A famous web application which uses PHP is facebook, as far as I know.
Your username makes this a sarcastically helpful response.
Not really? It's just a branch name, no?
Okay thanks. 
The language restriction that exists in the client-side, which __generally__ makes you use html, css, js, doesn't really exists on the server-side. That's why the whole issue is not so much related ot PHP. It could be Python there, Ruby, Java, C#, C++, Go, or even JavaScript.
What would you vote if you were still on the internals?
My main project which I have poured alot of my time into is [Corvus](https://github.com/ilikeprograms/corvus). Its a Portfolio CMS and powers my website :)
Wait, can you explain to me what is the language restriction that you mentioned, I have not heard of this phrase before.
I've been reading through this series recently, and it looks ideal for you: http://code.tutsplus.com/tutorials/refactoring-legacy-code-part-1-the-golden-master--cms-20331
* [ConNeg](https://github.com/ptlis/conneg) - content negotiation toolkit * [Semantic-Version](https://github.com/ptlis/semantic-version) - stand-alone library for parsing, comparing &amp; working with semantic version numbers. Neither will ever see wide use (the problems they solve are relatively obscure) but I would be interested seeing &amp; supporting the integration of the ConNeg library into a wider set of applications/frameworks.
I actually read some of that - but it wasn't relevant at the time. Thanks for the reminder.
No, it's not just a branch name. It's the version that `php -v`, `PHP_VERSION` and a bunch of other internal and external places will report.
Darth is awesome.
The only language you can reasonably use in a browser is JavaScript. The server can run anything.
+1 PHP 5.2 has been EOL for 3 years! I realise that you don't necesserily have a choice in this but i'd say that a rewrite against such and old version of PHP is a poor business decision... you'll be writing a greenfield legacy application. Without at least 5.3 (which is itself *very* close to EOL) you'll be limited to legacy/eol components. For example, you mention CodeIgniter, a project which itself is effectively end of life'd - the only update it has recieved in the past 2 years was to fix a critical security bug which was a consequence of the poor practices which are endemic to the project. If you absolutely can't move on from 5.2 my reccomendation would be to stick it out with what you have until you can move on. Look at gradually refactoring the application towards sanity (it can be done!) and in the future when you are in a position to use a post 5.3 releas e of PHP your de-coupled components should be migratable with relatively little pain.
Because I haven't thought about what version of ECMAScript I'm coding with in...ever.
So you're not taking advantage of ES5 stuff like array extras and Function.bind. Or exploring ES6 stuff like Promise and Generators? (Or arrow functions and much more). If not you're missing out. 
I think if I'm going to ask for advice then I should give you guys some more background. This may end up as a wall of text - so apologies in advance. What currently acts as an inventory/asset system is nothing more than a basic CRUD system with HTML spattered throughout the code. The database is currently a nightmare - and let's reserve judgement because the person who developed this had limited resources and never expected it to be anything more than a glorified spreadsheet. It's essentially just 1 wide table. They were only tracking desktops, then when they needed to track printers they just added a couple columns for printer information.. this trend extends for a couple of iterations. So a printer has empty columns for OS and a printer flag of 1. Same for network equipment and any other add-ons. Now that the company has grown they would like more advanced reporting and with the current schema - it's just not possible. Hence the need/desire for a total re-write. Mind you - this is an internal application so a re-write isn't THAT big of a deal, but there's already talks of extensions to it because it SHOULD be trivial so I have to keep that in mind. My concern is that when I get this done I will shortly after start working on the other internal applications in use to get them up to snuff and hopefully pull them into which ever framework I use - then I will be able to upgrade. At which point **I** would want to go back and move this into a more modern framework. Ideally I just have to rewrite some controllers and minor edits to models - but realistically I don't see that happening without some sort of Data Abstraction -&gt; Framework Driver to Framework DAL -&gt; DB Driver situation... or just creating my own DAL which means I will have to write my own drivers because all of this may move from MySQL to SQLServer.. the later seeming a bit more sensible. Wow - that's a lot of text. Hope that helps clarify what I'm looking at.
Okay Thanks!
I did some manual deobfuscation and loop unrolling, and if I did that correctly, the script contains bugs.
Now they have to decide whether or not to put the needle or the haystack as the first parameter.
It does seem odd to build an acronym with a specific release of a distro, but I guess 'ubuntu' would give us the derpy-sounding acronym 'HAU' and 'linux' would give us the crazy-space-odyssey AI 'HAL'.
I'm curious if you have any positive feelings about PHP at all or if you only live to troll it? Confusing why you spend so much time around PHP subjects otherwise.
Not as trivial as you may think - if I'm on a cheapo-cloud hosted ubuntu VM, setting up HHVM w/ fcgi is about as much work as just setting up fcgi (personally I found the hhvm route a bit easier). You also don't have to be doing giant CPU-bottlenecking processing to prefer HHVM - shaving off an extra ~20% on your response time (which is about what I'm finding for serving my basic blog-type sites) improves the overall experience for any site. Yes there are other ways to improve performance and yes caching is great, but with hhvm being dead-simple to install and having excellent parity with the big frameworks (and wikimedia too, now), I recommend it to everyone. 
If they get phpng out as is in the next six months without breaking backwards compatibility (ie. no mysql_*) it will take off like a rocket. Just way easier to drop in and replace existing PHP compared to HHVM
how is hhvm lagging there? the hack language is a pretty nice sized collection of new features for programmers.
Oh whoops, my bad
Hack is not PHP, it's a different language.
Looks like it is PHP7.
Lol this is just sad. The last voting had PHP6 with majority favor and this one is now PHP7. Guess I'm off to Hack, laters.
I figured they would have used nginx with HHVM, not Apache.
Is it just me or does PHP internals seem somewhat chaotic and a bit crazy?
Where does one go if they wanted to keep up on the soap opera that is PHP internals?
What were the publishers thinking?
The version after PHP5.2 will be PHP6 &gt; PHP 6 and Unicode - &gt; PHP received mixed reviews due to lacking native Unicode support at the core language level. **In 2005, a project** headed by Andrei Zmievski **was initiated to bring native Unicode support throughout PHP,** by embedding the International Components for Unicode (ICU) library, and representing text strings as UTF-16 internally. **Since this would cause major changes** both to the internals of the language and to user code, **it was planned to release this as version 6.0** of the language, along with other major features then in development. &gt; However, **a shortage of developers** who understood the necessary changes, and performance problems arising from conversion to and from UTF-16, which is rarely used in a web context, **led to delays** in the project. **As a result, a PHP 5.3 release was created in 2009**, with many non-Unicode features back-ported from PHP 6, notably namespaces. In **March 2010, the project in its current form was officially abandoned, and a PHP 5.4 release was prepared containing most remaining non-Unicode features from PHP 6**, such as traits and closure re-binding. Initial hopes were that a new plan would be formed for Unicode integration, but as of 2014 none has been adopted. http://en.wikipedia.org/wiki/PHP#PHP_6_and_Unicode
You could just create a ``JsonView``, set the response headers in there and call it a day. [Here's one](https://github.com/hassankhan/ultron/blob/master/src/Ultron/View/Json.php) I used in my project.
thanks jsanc &amp; xanza :)
Reddit is ruby.
Symfony has a good ecosystem of bundles that centers around REST API development: * [FOSRestBundle](https://github.com/FriendsOfSymfony/FOSRestBundle) for routing, content negotiation, and marshaling "views". * [JmsSerializerBundle] (https://github.com/schmittjoh/JMSSerializerBundle) for serializing your objects into the appropriate format (JSON, XML), and allows you to configure exactly how through YAML files or annotations. * [NelmioApiDocBundle] (https://github.com/nelmio/NelmioApiDocBundle) for generating API documentation * [BazingaHateoasBundle](https://github.com/willdurand/BazingaHateoasBundle) to ease conformity with [HATEOAS](http://www.slideshare.net/trilancer/why-hateoas-1547275). I have used Symfony to develop 2 REST APIs already and it has been a pleasure, actually. I know its monolithic compared to Slim, but I think its well worth it considering how flexible its architecture makes it. Removing `TwigBundle`, `AsseticBundle`, `WebProfilerBundle`, and `SwiftMailerBundle` to trim it down a bit.
So... Does that mean PHP 7 is a go? Currently its 18 - 38, which fulfills that 50%+1 requirement.
The analogy I like to use to compare procedural vs object code is imagine you want to make cars. More particularly, you want to build a robot to make cars. The procedural way is to do exactly that. Make a robot that welds stuff onto a chassis, adds wheels, tires, engine, etc. As you can imagine, the stuff the robot has to do is going to be very complicated. It can be done. You will get a large and complex robot, doing a large and complicated thing. The OOP way is to look at each task the robot needs to do, and make a series of smaller robots to do it. A robot for putting wheels on, a robot for doors, the alternator robot. At a glance it's much more complicated, there are so many robots. But the benefits become quickly clear, especially if things go wrong or change. Every couple of cars, the door gets put on backwards. In the OOP factory, you go right over to the DoorBot. In the procedural bot you have to go through tons of electrics and hydraulics to even get to the right bit. Similarly, in the OOP factory, adding a Coupe style to the line means a minor change to DoorBot and BodyBot. The other systems don't care. OOP programming is about doing this same sort of thing for code. Instead of making a big slab of "stuff", you break all the tasks you're doing into little pieces and focus on making each bit of functionality excel at only what it does. To take a common use-case of a blog, let's say you have posts, and comments on the posts. You might well have a `Post` class, which handles all the details for posts. Saving, editing, displaying one, displaying the whole list, etc. You might well have another one that has functionality for comments, which you've cleverly called `Comment`. Logging in might be handled by yet another one called `Authentication`, and so on. The code for each of these is going to be completely dedicated to their own job. `Post` doesn't need to know a damn thing about comments. `Comments` doesn't need to know about how to authenticate anything, it just needs to know how to ask `Authentication`. The benefits here, the reason it's useful, is that it's much more clear to read, much easier to re-use or extend. The more experienced you become the more it becomes apparent that maintainability is critically important. By separating each bit of functionality into its own object::function structure you can divide and conquer, making each of those bits of functionality excel at its job, even testing them to make sure they do. 
Actually Apache rivals Nginx performance nowadays with the proper worker mode. Read up.
I am not sure about the problem you are facing with Slim. I feel /u/skrawg is correct also. I am one of the core developers of http://github.com/auraphp/Aura.Web_Project . This is what people say https://twitter.com/jacques_thekit/status/491957581313998848 And a bunch of other frameworks For REST you should consider https://github.com/koriym/BEAR.Sunday https://github.com/silexphp/Silex http://laravel.com/ http://framework.zend.com/ Caution : Your mileage may vary.
actually that's pretty much like I've done, plus I've added jsonp support. Later a route says `$app-&gt;render(null, $data)` more than once and *bad happend* -- how yo deal with it .. just developers taking care of?
People often undervalue having the business rules and expected behaviours implemented. Those things can hugely complicate what is otherwise a seemingly simple rebuild. 
Hey thanks for your reply. These a really invaluable for me!! I haven't being exposed to the Symfony ecosystems yet, so this may be a good oportunity. 
I'd say that should probably be handled by the route logic. If ``$data`` is null, then before ``$app-&gt;render(null, $data)`` is called, you should check it. I am assuming this is a REST API type situation. Personally, I return a 404 status code when nothing is found i.e. when ``$data`` would be null, and a 500 code for server errors.
Apache 2.4 can be as fast as nginx. Most people don't realise that simply disabling AllowOverride makes Apache performance pretty much on par with nginx. EDIT: I say this as someone who prefers nginx over Apache BTW
I have Outlaw - A PHP library helping implement CRUD in a dirty and fast way. https://github.com/howtomakeaturn/Outlaw
Reddit's code is on [github](https://github.com/reddit/reddit) actually, it seems they use python which isn't what I would expect.
Does that mean they can keep switching their votes?
Can someone contrast/compare all of that to a simple bash script? $ cat .git/hooks/pre-commit #!/usr/bin/env bash FILES=`git diff --cached --name-status --diff-filter=ACM | awk '{ if ($1 != "D") print $2 }' | grep -e \.php$` for x in $FILES do CMD="php -l $x" echo $CMD RES=`$CMD` if [ $? -gt 0 ]; then echo $RES fi done
To ease conversion, the Hack typechecker deliberately doesn't run on code that doesn't start with `&lt;?hh` (i.e., Hack files). This lets you live in a mixed Hack and PHP codebase without tons of spurious errors from your PHP code, since Hack is designed to be a zero error system. Depending on what you are trying to do, you may want to try out our automated conversion tools. There's documentation here http://docs.hhvm.com/manual/en/install.hack.conversion.php and I did a talk about Facebook's experience with the tools at the Hack Dev Day that's on YouTube: https://www.youtube.com/watch?v=5tEnAL_Fad4&amp;index=3&amp;list=PLb0IAmt7-GS2fdbb1vVdP8Z8zx1l2L8YS That said, something I want to experiment with is a script or cronjob that automatically runs the conversion tools on vanilla PHP projects and tries to programmatically detect bugs with the typechecker. Doing this is conceptually simple, but getting it actually running is trickier than it sounds. So not soon, but maybe keep your ears open :)
Does it's config still suck?
It is a weird choice, and what happens for the next release of ubuntu? The HAT acronym changes and anything written about HAT is lost when people are searching for the new HAx? 
What about if you use nginx and ubuntu? HNU. Sounds painful.
They absolutely can, yes.
Bad move, imho. PHPNG is going to give HHVM a run for its money without all the extra bullshit.
UPDATE: here is full download http://downloads.outbrainreview.com/PHP
Probably HEU or just HUE. After all, we don't call it LNMP, we use LEMP.
Wikipedia exists now, a stable NG release is **really** far away. You may be right about NG and HHVM competing neck and neck, but Wikipedia clearly needs a solution now.
She cancelled it because Zeev added arguments to PHP 7 but during that revision of the RFC actually removed some arguments for PHP 6 for some reason, and still thinks he did nothing wrong.
I know the entire story. It went to vote too early, and possible to re-vote too early as well. Oh well.
Biggest thing is Apache 2.4 enabled the same worker / thread model as nginx. So now it's much of a muchness. The only problem is nginx already had 2 years being categorically faster to itself, so the popularity mindshare had already started swinging. TLDR if you configure them properly they're now the same qualitative speed.
HHVM JIT-ed and PHP isn't. And there is still the possibility that a JIT for the official PHP can be developed. There is in theory still big improvements for PHP possible by developing a JIT. 
&gt; – Hack can build on OSX now This is great! I've been wanting to start toying around with it, but was too lazy to set up a vm to do so.
you can subscribe to the list on http://php.net/mailing-lists.php or you can read the archives on http://news.php.net/php.internals or some third party mailing list archive like https://www.mail-archive.com/internals@lists.php.net/ or http://marc.info/?l=php-internals
* [Restler](http://luracast.com/products/restler) - I am going to use this one * [Apigility](https://apigility.org/) - I was unable to run it properly
There's already a precedent for this: PHP 5 -&gt; PHP Vista -&gt; PHP 7
so if wikimedia is moving to hhvm does that mean that wikipedia will run on hhvm?
&gt; that wikipedia will run on hhvm? Someday :-) 
You could just have used https://puphpet.com/ by the way, it's super easy and it's "tidier" than installing directly to your PC/Mac imho.
Hmm... http://whois.domaintools.com/33db9538.com
Well... and based on what we see in internals now http://www.serverphorums.com/read.php?7,979538) it would be better if we move away from the php-internals controlled thing. So.. Moving on to hhvm... 
Good for them... At some point we should move too...
Think of PHP6 as an infant that was given a name but unfortunately died while still in womb..we shall remember it's name and move on to next in line, which is PHP 7 :)
That's a vm...
It is a VM however the OP implies some level of difficulty in setting up a VM and that utility makes it dead simple to do.
Filters are a very nice idea. In case of a positive validation are we able to get the filtered data out of it?
So it's better to not think through designs? It's better to have [missing functionality](http://docs.hhvm.com/manual/en/hack.unsupportedphpfeatures.parentstaticmethods.php) and [logical inconsistencies](http://docs.hhvm.com/manual/en/hack.otherrulesandfeatures.uniontypes.php). Much better to get something out the door that looks nice, rather than make it [complete](http://docs.hhvm.com/manual/en/hack.unsupportedphpfeatures.toplevelcode.php) and [consistent](http://docs.hhvm.com/manual/en/hack.otherrulesandfeatures.initialization.php) from the get-go. Don't get me wrong, I think internals is largely spinning their wheels. But I'll take an open process any day over "behind closed doors" development. And I think anyone that's not at least concerned about the "behind closed doors" nature of HHVM/Hacklang is missing the bigger picture...
I wouldn't vote. The entire RFC is a sham and an insult to the established process and to the people involved. I mean having "7 is a lucky number" as a reason? And stating: *"the case for 7 is very strong without it"* is about as biased as you can come. Plus pushing a vote less than 24 hours after a major modification of the RFC is against the spirit of the process as well. Rather than doing things right, certain people are trying to railroad their agenda through. And it's both disturbing and dangerous. And the fact that more people don't see it, and more people aren't disgusted by it, is IMHO a problem.
Benchmarks?
Because the benefits of semantic versioning are lost. How do you know if PHP 2016 had significant BC breaks compared to PHP 2015?
Sure. When you pass an object to be validated, its values will be filtered in-place, so you can retrieve the filtered data right out of the object itself. This also goes for arrays if you're validating those, as well. Here's an example: $data = [ 'username' =&gt; 'hello' ]; $validator = new Validator(); $validator-&gt;addRule( (new Rule()) -&gt;setFieldName('username') -&gt;addFilter(Filters::toUpperCase()) ); $result = $validator-&gt;validate($data); var_dump($data); /* [ 'username' =&gt; 'HELLO' ] */
Pretty googleable, tbh http://www.eschrade.com/page/performance-of-apache-2-4-with-the-event-mpm-compared-to-nginx/ See also the link at the top of that post, where for serving a php page the speed is almost exactly the same, as metanat said.
[Cloth5Client](https://github.com/Itrulia/Cloth5Client) It's a Riot Games api client build with a repository pattern. Currently no documentation and tests... (sorry guys). I just don't have enough time for everything, also working on my Google Material sass library.
He actually has a fair point. Usually some features are partially implemented, or behave differently across browsers. People focus on feature support rather than saying "I'm going to build this app with ECMAScript 5". That's not the case with PHP
This Looks very good however, it would be greater using mysqli. Thanks a bunch
&gt; as long as I don't need to Login to Facebook™ to read the documentation, I'm willing to giving them a chance Oh, don't get me wrong, I'm giving them more than a chance. Especially the work they are doing on the spec is amazing for the community as a whole. I'm just saying that the talk of abandoning "c-php" entirely (not for a specific project) in favor of it is short-sighted at best. 
I don't think that's a bad thing, and I certainly don't think Nginx is easier to configure.
You didn't really address the OP's question at all. 
You mean Dokku sets up nginx etc. on the droplet for you? Have you tried Dokku with Vagrant? 
While HHVM was difficult to build on CentOS 6.x, it is far easier on CentOS 7.0 for those in that environment that want to try it out: Here's how: http://ckon.wordpress.com/2014/07/18/hhvm-centos-7/
... [apigility](https://apigility.org/)? Seriously, it's an entire project devoted to building APIs. You can get a **proper** API up and responding with HAL in no time. It's easy to build an API but building an API right is a very difficult problem. Are you returning the right status codes? Headers? Are you handling REST properly? How about authentication? Versioning? Do you have a consistent API output (i.e., HAL) or are you just cowboying it? These are all questions that need an answer to do a proper API.
All of the issues you mention are specific to Hack, which is optional. Second, I would call them fixes and not issues. :D
So, for static files nginx is amazing and still twice as fast as Apache 2.4. For non-static files they perform the same except nginx leaves more memory free to run PHP-FPM processes. Thereby making nginx able to serve more requests their too. Hmm, seems like an all around loss for Apache 2.4.
It is dead simple to install. However, as someone who is used to dealing with a large php.ini file, I would like to know how to configure HHVM. For example, can I limit threads or memory? Is that all automatic? So many unanswered questions.
In my setup the global function is needed to extract the translations easilly from the source code (with the xgettext binary).
Glad I could help. I'd just like to say, there's no reason to actually do a separate endpoint for pass / fail. Think about it this way: if I know the URL to get a free hat is htttp://domain/contest/pass.pho, I can simply go and get another hat. Instead, simply show a different outcome on the same page. Make sense?
A more slightly cleaner way to handle this would be to have an array of correct answers that you loop through and compare to the POST data: $correct = array( 'question-1-answers' =&gt; 'B', 'question-2-answers' =&gt; 'A', 'question-3-answers' =&gt; 'C', 'question-4-answers' =&gt; 'D' ); $pass = true; foreach($correct as $question =&gt; $answer) { $pass = ($_POST[$question] == $answer); if(!$pass) { break; } } //etc 
I've been thinking about that actually haha I'm not familiar with PHP and have time constraints. How involved would that be? I think what I might have to settle for is feeding the data collected for the free hat into a spreadsheet, and tossing duplicates.
Don't be stupid. It's dead simple to you. You've done it. He hasn't. So it's not.
[This is my primary argument for PHP 6] (http://www.reddit.com/r/PHP/comments/2bhu2m/rfc_name_of_the_next_major_php_release_6_or_7/cj5ol58) I've worked with PHP in three main contexts: 1. On my own projects / apps 2. As a freelancer 3. As an agency mule The version of me that works on my own stuff, doesn't care whether it's 6 or 7, because it doesn't matter that much. The freelance version of me cares a little bit, but it's the agency version of me (and anyone else who is an agency dev) that should care very deeply whether it's called 6 or 7. I've spent the last 3 or so years working almost entirely in Drupal, Joomla, and Wordpress, or some old PHP 5.3 legacy apps via my agency gig. I have yet to work on a modern PHP application in an agency context. No matter how hard I push to develop apps in Laravel or Symfony rather than wasting dozens of hours trying to shoehorn complex functionality into Wordstress that could be done in minutes with FAR less frustration in a proper framework, I never get any traction. Clients insist on Wordpress because they've heard of it, the way some people at Staples insist on getting a UBS Linskees Rooter because their "tech guy" told them to. Management thinks that it's faster and cheaper to leverage Wordpress/Drupal/Joomla's extension &amp; plugin ecosystem, which several overbudget projects later have shown is simply NOT true (it's only true when the client is ok with whatever the plugin/extension can actually do, and are willing to accept its limitations). But that's not what clients are like. Clients want what they want, and as a developer you have two choices to give them that: either through custom code you write and understand that does exactly what it should, or by wading through a swamp of often shitty code from 10 different authors to modify or extend it without somehow breaking the rest of it.... This CMS nightmare world that I would wager most agency PHP devs are stuck in, is due in large part to the belief that custom PHP is expensive or time consuming, or that PHP isn't a good language choice. My open source (and by open source, I mean 90% PHP) team has lost MANY custom project opportunities to the .NET team because of that belief. I've been offered jobs at other companies that do proper custom application work, and even in-house product development.......... in python. In fact, they are all former PHP devs that I used to work with, who have switched to python for god knows what reason. When I was living in CA, the number of startups that were being built in PHP were trounced by startups being built in python or java. The available non-CMS work in PHP is in low supply (at least in my experience, and especially the area I live in now). So what does PHP's next version number have to do with this? Perception. Love it or hate it, perception is a real thing, and very inaccurate perceptions are why so many people regard PHP as a joke hobby language when in reality it's perfectly fine. Calling the next version of PHP 7 instead of 6 only adds more fuel to the perception fire that PHP is flaky and can't keep its shit straight. I don't know about you guys, but I want clients, and startups, and enterprises to say "Hey, we should build our app in Laravel/Zend/Symfony" rather than Ruby/Python/Java. There needs to be MORE demand for custom PHP, not less. Else PHP is going to slide further down into Fisher-Price territory whereby being a PHP dev pigeonholes you into working with CMSs and little else. Maybe I'm overblowing the effect that the version number will have on those outside of PHP. Maybe most won't care. But skipping 6 is classic PHP punching bag material waiting to bite it (and me, and you) in the ass.
Unix timestamps should always be stored in UTC. Provided the server timezone is set correctly, this will be the case. At that point, it's up to the display layer of your application as to how it wants to display it. Be it in UTC or a local timezone. 
In my case, I store all timestamp in UTC timezone, using PHP, you can convert the timezone based on user's setting I am using Carbon to help the task https://github.com/briannesbitt/Carbon
No, it would not be greater using mysqli. Mysqli is an API that should be behind an object wrapper like PDO.
I've used this one.. good customer service and easy to use : http://www.3dcart.com/
&gt; Maybe I'm overblowing the effect that the version number will have on those outside of PHP. Maybe most won't care. But skipping 6 is classic PHP punching bag material waiting to bite it (and me, and you) in the ass. I think you are overblowing it a bit. Whatever they choose there will be consequences, but ultimately I think there are more consequences going with 6 than with 7. The fact that there already was a 6 and there are whole books teaching you PHP 6 with outdated information will be more problematic for the lifetime of 6 than if they go with 7 which will have some "knocks" on PHP in the beginning but will then start to fade away. PHP NG has a lot going for it, I think people will get over the versioning pretty quickly once they see the benefits and we'll all look back at this debate and think how silly it was.
Ah ok, thanks for the clear up. When I last checked it, PHP6 was winning by a large margin. Must of been early on.
I've been working on [Bldr](http://bldr.io). A PHP based task runner
&gt; I'm just saying that the talk of abandoning "c-php" entirely (not for a specific project) in favor of it is short-sighted at best. I liked Rowan's "ZPHP' suggestion.
I don't. Despite how much Zend may claim it is, and how much their name is littered over the codebase, it's very much not their project. It's a community led project. 
Oh, I know. That's why I like "ZPHP" as it alludes to Zend but doesn't use their name explicitly. But I see your point.
Just stay away from OpenCart 
Oh yeah I know all about opencart.
* Store times in UTC * Users have a timezone * Adjust between UTC &amp; timezone on user input &amp; ouput
phil is butthurt because he voted for 6 and lost. Andrea also voted for 6, so it makes sense why he cancelled the first vote when the rfc was too "biased" towards 7.
Nope. That's the runtime library and it's a different animal (one which the php.net manual does a good job of defining, actually). This is about syntax. All the type-juggling, control flow, semantics, references, variable variables, and weird little quirks of PHP. Stuff like defining why this behavior exists: var_dump((int)'0xa'); // int(0) var_dump('0xa' + 0); // int(10) And conformance tests so that things like this wouldn't have happened in PHP 5.3: var_dump(0x0+2); // int(4) Edited for formatting...
Yes and no :)
It's also for the official PHP compiler. We (with my PHP hat on) will be able to design new language features better if we have a strong view of where the language is now. We might even start to clean up some of the weirdness in the next major version. (See also: Uniform Variable Syntax RFC)
The thing that bothers me most about this bullshit isn't even the version number (+1 for 6 as the only logical choice, though); it's how ~~unprofessional~~ ~~immature~~ childish certain internals members have been acting during the whole thing. The same people we consider to be *leaders*, and generally well-respected in the community for their contributions and opinions, can't even have a civilized discussion/vote about something they disagree on without showing their asses.
You should look at finding a gig as a Quant. Finance + Programming. I hear the pay is decent as well. 
Andrea didn't cancel the vote due to support for PHP7. It was cancelled because it was opened too early and there needed to be a more balanced set of arguments put on the RFC. (Initially, it was only really an argument for 6). The fact that 7 was winning after a day is somewhat telling, but not really meaningful. Also, calling Phil's reaction being butt-hurt is missing the mark. He's rightfully annoyed by the energy going into a superficial issue. I'm annoyed too (though on the favoring php7 side). I only care because I put a lot of work into PHP6, and even if it didn't go GA, it was still certainly a very real thing. I have no idea why rando people who didn't work on the Real PHP6 care about.
So, in order to prevent writing other languages like SQL in your PHP programs, you want to create a new DSL with Lisp syntax? And you don't see the irony in this? My suggestion would be to use any of the DBALs already in existenence, as most of their APIs are much more "PHP-like" than what you're describing.
Surely PHP6 didn't happen^* so there is still room for it to happen. Is it really more complicated than that? \* we never used it, unless I missed the event. 
Well yeah I do in fact see the irony here. But the thing is arrays are much shorter in some situations, such as html. &lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; &lt;div class = "some_class" &gt;Some text&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; This can be written far more concisely as array ["html", ["head"], ["body", ["div", "class" =&gt; "some_class", "some text"], ] ] As a bonus, I can manipulate the code using php array functions. Admittedly it doesn't work nearly so well for mysql. Your advice about DBAL is probably the most sensible.
A lot of people pretended it happened.
&gt; Calling the next version of PHP 7 instead of 6 only adds more fuel to the perception fire that PHP is flaky and can't keep its shit straight. I wouldn't get that impression at all... whether going to 7 is the best decision or not, *if it was made*, that smacks to me of a team that cares about their community, because the primary reason to go to 7 to cause the least confusion possible in perception (old perceptions about 6 are completely washed away). That's in contrast to say Oracle, running Java, who don't seem to care about their community at all.
To the best of my knowledge, of all the "security concerns" people who don't use PHP bring up about it, SQL Injection is the only legitimate one (at least the only one I've ever had to deal with). Most people seem to cite problems that were solved half a decade ago.
None. We're working with a formal spec writer with a lot of experience in this field. His tears, on the other hand... Some scars will never fade. That said, I sometimes do ask interview candidates what their most/least favorite aspect of PHP is. It's a low-signal question, but it often sparks interesting conversations.
You know this is backwards, right?
I am told that http://www.foxycart.com is excellent, and the developers behind it are fanatical about proper REST/HATEOAS behavior.
Yep. To the best of my knowledge, the only "gotcha" when dealing with SQL injections is that you shouldn't allow arbitrary input as a sorting field, because it won't be escaped/quoted/etc. But still, as long as you're aware of it it's pretty simple to guard against.
You can make insecure applications and website in all languages. The issues with PHP is that it is have a very low barrier of entry, meaning that it is very simple to start using PHP without fully knowing what is happening. So the problem is not with the security, but which what the programmer wants done.
&gt; The number one thing they always bring up is how insecure the language is. This was a valid argument in the times of PHP 4 when register_globals was on by default. In the time when this setting was enabled by default, imagine requesting http://www.example.com/index.php?myVar=foo and index.php containing the following code: &lt;?php echo $myVar Instead of producing an undefined variable notice as it would these days, it would echo 'foo'. This made it really easy to create unsafe code. Fortunately this functionality was disabled by default in PHP 4.2 and removed in PHP 5.4. A lot of strange decisions have been made in the history of PHP, but the last years PHP and it's ecosystem are maturing and PHP is getting better and better. &gt; When I ask them to elaborate I just get the same spiel about how the language is insecure and it's a mistake to use it. Using this as an argument shows to me that the people you spoke to are ignorant and don't know what happened to PHP in the last couple of years. As long as you are aware of the limitations of PHP (or any other language) is see no reasons to not use it. Perhaps it's a good idea to let those people read this article from Fabien Potencier (the creator of Symfony): http://fabien.potencier.org/article/64/php-is-much-better-than-you-think &gt; Are they just talking out of their ass? I've looked up the largest security risks with PHP and it's pretty much unanimous that the biggest security risks with PHP are from human errors. Yes, they're talking out of their ass. It's possible to create security risks with every language and there are no exceptions to this rule. 
This this this, a thousand times this. I wish I could upvote it more so it bubbles to the top. PHP is easy to use and has a low entry barrier... which also makes it easy to use *badly*, alas.
PHP is no more or less secure than other languages. While there were some serious concerns about the way it interfaced with C and third-party packages (particularly MySQL) a decade ago, these have largely been resolved as a matter of time and experience. The bigger complaint I hear about PHP is that, because it is fairly accessible to beginners and hobbyists, many PHP "programmers" end up writing insecure code. However I see this as a mark of success for PHP. Every good coder started out writing bad code in one language or another, and todays sql injection is just yesterdays buffer overflow (a much more serious crime when you think about it, and far easier to pull off). Thankfully PHP has an extremely large community that has made competent help easy to identify and access.
I work in a digital agency (a top 100 agency in the UK) and work predominantly with Symfony2 and ZF1, with a mix of Silex and other custom rolled micro applications. The agency as a whole also offers Magento, Drupal, WordPress and Sitecore (.NET). We've had situations where WordPress was (mis-)sold to a client and I've had the job of explaining to the client that they're far better off with something like Symfony2 + SonataAdmin. So it can be achieved :)
PHP's greatest strength is that it can be used to make a dynamic website quickly and easily. That ease of development means that n00bs flock to it and write really terrible, inefficient, and insecure newbie code to make their site. That code gets a lion share of the exploits and the lolphps. Most of the PHP hate I've seen stems from needle/haystack order or from things that may have been issues back in the pre-5.3 days. Unfortunately lots of code still exists from those days. The language is fine. Use it wisely or write your site using one of the many wonderful frameworks available today and you'll be good.
Escaping is context sensitive, and many people don't realize that. Example (assuming `...` expands to proper options): &lt;foo&gt;&lt;?php echo htmlspecialchars($foo, ...); ?&gt;&lt;/foo&gt; Is safe &lt;foo text="&lt;?php echo htmlspecialchars($foo, ...); ?&gt;"&gt; Is safe as well &lt;script&gt;&lt;?php echo htmlspecialchars($foo, ...); ?&gt;&lt;/script&gt; Is NOT safe (for hopefully obvious reasons) &lt;foo text=&lt;?php echo htmlspecialchars($foo, ...); ?&gt;&gt; Is not safe either (since it's not quoted)
I have, working at a marketing agency that did mostly CMS php work, occasionally delving into "custom applications".
&gt; Russians Contact page says Ukraine.
This isn't the place to post something like this and it's probably about to be removed by a mod, but anyway - you've misspelled "Curriculum". As an employer, you would go down several points in my estimation for getting that wrong before I've even looked at the rest of your CV.
I came to /r/PHP to find this article again, thanks! I do feel PHP has finally reached the threshold of not being allergic to deprecation. Even just not having to roll my own crypo made me reconsider moving to node.js for page serving when my websockets are already on it. I got as far as trying to get node to talk to mysql (before I shifted to sqlite) and started reading about PDO cleaning up the whole fiasco with native prep and whatnot. Hell, even just []. The Ubuntu PHP5-FPM package still being 5.2 is a bit of a nuisance. I was missing a ton of good shit. I can write a test page to spit out in whatever order my test case 'players' in about ten minutes. Of course it won't be perfectly secure, I wrote it in ten minutes! I still think Symfony is a fustercluck against just fixing namespaces already
PHP is just old, sloppy and clunky. It is perfectly capable of everything the other popular imperative scripting languages like python, ruby and nodejs are capable of, but those environments and communities tend to encourage better software engineering practices, package management, and language features. A simple example; Composer is an excellent but relatively new response to the absence of proper dependency management in PHP, but there is still a huge number of PHP programmers who don't use Composer, whereas other scripting languages don't suffer from this problem because the package managers are closer to what we might consider "first class", so everybody uses it. There are also a litany of minor annoyances that add up to a less than great experience, think sloppy unnecessary inconsistencies like isset vs is_null, array_map accepting a callback as the first argument and array_walk accepting a callback as the second argument (which creates ugly inconsistent code when using anonymous functions), the ubiquitous needle/haystack inconsistencies. You also have horrible design decisions that should just be removed from the language like @ error suppression, magic quotes (removed in 5.4 I believe) and on and on. With all that stated, PHP can still be used to write excellent software, it's just that the developer experience is much more polished with the alternatives.
There is no "official elePHPant". Vincent Pontier holds the copyright on the common design, and he's not a member of the PHP Group, nor an active contributor to the project. The "cheap copies" you speak of are no less "real" than the ones that Pontier licenses. They're just different, so as to avoid infringing upon Pontier's copyright. Nobody is a dick for wanting an elePHPant without having to pay into the monopoly on our community mascot.
I think an important aspect of programming languages (and platforms and frameworks) is the community of people around it. 90% of my programming is in PHP, but I've built things in other languages over the years... one of my favorite things about Ruby/Rails, for example, isn't the technical aspects of it but that the community of programmers around it seem to be very intellectually curious and interested in honing their craft. I think the community of people around PHP tends to be people who just want to get the job done (although this is changing with the rise in popularity of the more recent frameworks such as Symfony2, Laravel, etc.). So it is true that the language itself isn't less or more secure than any other memory-managed language, but the general level of knowledge around it (the people building with it and the blog posts and tutorials and forums etc.) does tend to be a bit more amateur on the whole. Not that this is overall a bad thing! I think the ease of learning is one of PHP's greatest strengths... but the downside of that is you do wind up with a larger population of beginners and people who just want to get something done without thinking through all the details. So I think this is why PHP gets a bad rap. At the end of the day, though, it's a tool and you like it and use it successfully so who gives a shit what someone else thinks?
Huh? I'm talking about sample apps or time taken to run test-suits for large projects, and not just "HHVM is super fast at running fibonacci sequences and random synthetic shit in tight loops." I'm not being unreasonable by asking that question. Most benchmarks I have seen put the two systems at about the same for general usage, but HHVM way out in the lead for synthetic benchmarks.
I'm not decided on either way but when you do an amazon search for version 6, those books are still going to be there.
I would add to this that the type juggling in PHP is not always predictable and can cause some fairly unpredictable results, especially when set up with a SQL structure that doesn't return things quite the way you might expect. Those two together mean that it's easier to miss security holes and errors becuase many times they are less than obvious to anyone without much experience.
Sure but I just did a search and there's only about 6 or 7 of them. They'd be quickly pushed down the search by the right books. Plus you'd hope they'd be discontinued, replaced with new editions or Amazon would stop selling them.
It's not like this is a choice between 6 or 7. Call the old 6.x branch 6a.x, or the new branch 6+ Jumping to 7 seems retarded, but I really don't care what it's called as long as it does its job. 
Nice. I've worked mostly at agencies/services shops and always had to do ops.
All three checked. But I still don't know how to proceed. Should I set the timezone in MySQL? Will MySQL be slower if I set a time zone for a session? How about index? 
So you convert the timezone with PHP? But I have thousands of rows... I don't think it would be efficient if I convert them with PHP. Thanks.
Well, unless I am missing something important (which is definitely possible), my html example actually seems less verbose and is easier to read. It is also immune to XSS attack since you can simply recursively escape all nodes (it won't be very fast, thought). Agreed that MySQL is more complex and probably not worth it.
&gt; I have no idea why rando people who didn't work on the Real PHP6 care about. 'rando' lol. Just wanted to say, it's fair enough that you worked on it, but the people who are using it would be the people who cared about it, I'd assume :)
tbh i clicked through for more juicy opencart drama.... /popcorn
&gt; Are they just talking out of their ass? *Yes.*
for php-tail, you might want to make use of the inotify extension when available. i made something similar to this before because inotify wasn't available on os x. this is cleaner :) thanks!
&gt; To the best of my knowledge, of all the "security concerns" people who don't use PHP bring up about it, SQL Injection is the only legitimate one PDO + prepared statements. SQL injection attacks are the developers' fault, not the language's.
You should join #python on Freenode. I got banned when I was defending PHP, #python-friendly is the channel I go with now.
Interesting. Do you know if they have a buildpack that sets up a droplet that can autoscale according to traffic spikes? Digital Ocean doesn't have autoscaling built in, but there is a tutorial about a script you can use to set up autoscaling. I'm not sure how well it works though.
Your database should know *nothing* about timezones, at all, ever. Conversions to and from UTC happen in your app code, never in the database. That's it. It's very simple, really.
I don't give a damn what it's called. I just want it to actually be released.
You can, but you should really use the native PHP methods instead of executing shell commands. Safer and more compatible.
As drrck2403 said. You server time and mysql time should both be UTC. Beyond that, leave them alone. :) When you receive a time from the user convert from their timezone (stored in DB) to UTC in your application code before saving. When you want to display a time to a user, retrieve it from the database, convert it from UTC to the users local timezone in your application code and display.
I meant something like https://gist.github.com/KizitoBryan/f3b1fccf780a63ceb0c9
Ehhh Let me ask you this, can you manipulate what the user uses as a deliminator? If they put in $, can you just replace it with ";"? And if the answer is.. "how do I know what the deliminator is to replace it?" The my question is.. how can you fill your possible deliminator array to cycle through and test for it? If you are limiting it to a subset of characters such as space, comma, semi-colon, etc then just allow those only then do a replace for each so they are consistent. then do your explode() and loop through to do what you need to do. I feel like you have to have some sort of validation on this to account for things correctly.
Even with register_globals being on, that doesn't automatically make code insecure. You'd also have to use variables without assigning to them. And ignore notices to that effect. And this only affected global variables. However, a lot of PHP configurations had register_globals on, then programmers explicitly ignored notices, which allowed them to not initialize their variables, and their file was a big blob of code instead of even being in functions, so these sorts of security problems did occur. 
use preg_split instead. $array = preg_split("/[\s,]+/", $string);
..taking this a step further, if you want to easily filter the array, you can use array_filter(): $array = array_filter(preg_split("/[\s,]+/", $string), function($email) { return filter_var($email, FILTER_VALIDATE_EMAIL); });
Yep that worked. I'm so happy I asked now.
I don't give a crap if it's called PHP6, PHP7 or PHPRainbowUnicorn, as long as they release it as fast and polished as possible. Let's forget this vote and concentrate on useful stuff, like an actual language spec for example.
To answer your question, yes you can. But php has a built in function for that: [copy](https://php.net/manual/en/function.copy.php) The php doc is great, use it! 
Everyone is going to laugh at us again.
&gt; my html example actually seems less verbose and is easier to read To me, it's visually almost identical in terms of structure. You did gain *some* readability by removing the redundant closing tags, but what you gained there, you lost ten-fold by breaking IDE/editor syntax highlighting (your DSL will just be one giant wall of PHP strings instead of pretty highlighted markup). So, ultimately, plain old HTML will be much more readable for markup of any significant size. &gt; It is also immune to XSS attack since you can simply recursively escape all nodes (it won't be very fast, thought). What you're suggesting here is exactly what DOM-parsing template engines do, so there is some merit there. You just have to be careful that you're properly encoding for all the possible contexts. And, speaking of contexts, how would this DSL handle embedded `&lt;script&gt;` and `&lt;style&gt;` code?
Most places have institutional politics, including school bullying and office politics, as barriers to entry. PHP has no such barriers and lots of opportunities even if you don't leave your home. Those who thrive like bacteria in the sewage of politics bash on open and accessible platforms like PHP.
Man Oh Man, do I hate the lack of consistency in PHP. Fan-bloody-tastic language, but someone needs to go through it with a blowtorch and iron that shit out. It would break pretty much everything mind you, but one can dream. I know that once I got a decent IDE with hinting, it saved me a bunch of time otherwise lost in tiny little ten second portions spent correcting needle / haystack misplacing, adding / removing underscores...
It excels at running on PHP 5.2, I suppose.
totally OT but is anyone else getting sick of flatly.css?
I can list quite a few *real* problems with the PHP language, and none of them are in that article. Meanwhile, the author wrote giant walls of text about things virtually no real PHP developer cares about. Things like function naming inconsistencies, for example. Quick show of hands - who here has ever given a shit that `strpos()` doesn't have an underscore and `str_replace()` does? ... Anyone?
&gt; type juggling in PHP is not always predictable and can cause some fairly unpredictable results, As always, it's sometimes [really really odd](http://3v4l.org/ggFcM).
Yes :)
Yep, I have thousands of record too, storing appointment data for hundreds of users, so far it doesn't have performance impact as long as those thousands of records not be retrieved at once
I have millions of rows and many have to be retrieved at once. Imagine it like a database for GoogleAnalytics
I don't store anything about timezone in the table. When I say the MySQL way... I mean it with setting it per MySQL connection session like this: &gt; SET time_zone= 'Pacific/Wake'; 
But that is crazy. Suppose I have millions of entries in the DB and I want to retrieve many thousands of them. So I should convert every retrieved entry with PHP? Also GROUP BY will be a little bit messy to convert
I agree with this. Just go to 7. If anyone asks, just say 6 existed briefly but we moved on. Nobody gave a shit when Netscape did it back in the day and there were arguably more non technical people involved then. Nobody will give a shit now. They *might* care if there are 2 different versions of something conceptually called PHP6. Just bypass the possibility. This shouldn't be a difficult decision, and it worries me that I belong to a community like this. Do it and stop wasting time. Edit: I should add I don't really care if it goes to 6 either. The arguments for and against are all trivial. Just do one and stop arguing. 
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
I have been a long time PHP user and do not condemn the language. Where I think the problem stems from is that PHP is a very easy language to get into as a non programmer. If someone has the basics of HTML down they can add a tiny sprinkling of PHP directly into their HTML (with an extension name change) and poof then have written their first program. Many PHP programmers have come from this "school" and simply kept upping the complexity of their code without ever having had any formal training. So oddly enough these people end up becoming responsible for sites that grow and grow and grow because the fundamental business underlying the site was good. Thus things like SQL injection attacks and other massive security holes can be created. But this is not the fault of PHP, if anything it shows one of its strengths; that is that it is easy to write powerful sites with very little training. I also extensively use C++ and find that there is a huge movement to make it as complicated as possible. For some reason simplistic code is rejected as childish. There is an insistence that templates be used wherever possible and often these can turn the code into a nightmare. I also program in Python and I see the same movement. Python is beautiful because as many have said, it is Pseudo code that runs. Yet I see people pushing constructs that you have to really scratch your head to figure out. Java has the same movement where people are pushing other JVM things like Scala that I find are often written to be as complicated as is humanly possible. I like to call all of the above "Hair Shirt Syndrome". This fundamental, unsubstantiated belief that you are doing things wrong if you make it clean and easy. Or more specifically that their ideas of clean and easy are not even distant cousins of what one might have written in Pseudo code. While PHP can be obfuscated quite badly I find that little is to be gained by doing so. Thus most PHP code ends up being fairly simplistic. For instance there is a Computer Science "Rule" that the presentation layer should be separate from the logic layer which should be separate from the data layer. PHP encourages the violation of this rule where many a PHP person will pull data out of database and use that to generate HTML right inside a while loop. For many occasions this is just fine. But if you are trying to build a multi lingual site with a RESTful API that multiple platforms will access then the CS people are probably correct. The key is that as a programmer you have choices and the nightmare for many CS hidebound types is that PHP doesn't force you to make what they consider to be the "Right" choice. Then even worse is that it works very fast, with fast development cycles, and is used by many of the top 50 websites.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
At this point in time, the CI has lots of robust third party libraries around that you can plug to your install. I too am itching to get into Laravel looking into it's beautiful coding patterns (at least syntax wise). 
+1 for "Sophisticated Sturgeon"
I don't have enough professional experience with Nginx to comment on it. But I *will* comment on XML as a configuration language for web servers. In short, I hate it. We as humans understand procedural processes well; we've been trained since forever that things at the top come before things at the bottom, and any system that mixes up the evaluation process tends to cause many logic bugs. Thankfully Apache doesn't fall into this particular issue\*, although I've seen other data-config systems do so. When deploying any non-trivial web application, there are going to be circumstances you have to deal with. You're going to want to redirect a certain url to another one, or require a password for only one url pattern, or strip cookies from requests coming to a certain subdomain. These are all *conditional* statements, and conditional statements are a bread-and-butter of programming languages, and are in fact one of the major distinguishers between a programming language and a markup language or data format. Often the argument for using XML is that you can run a DTD against it to verify correctness. I posit that 1) those people have never had to write a DTD, and 2) you'll need to write a parser anyways to turn the config into code that your server executes. In fact, the closer your config language resembles your implementation language, the better off you probably are. Varnish actually allows you to [drop in little bits of embedded C](https://www.varnish-cache.org/trac/wiki/VCLExampleSyslog) if its config language (VCL) isn't sufficient for your task. This is a implied acknowledgement that no config language will ever fully satisfy every task, so you should make it easy to drop into something more powerful. And yes, I've used that technique for work. Varnish's syntax is so much programming, you don't "validate" your config, you compile into C and it either compiles or fails to (in which case there's no object file to be swapped in, so you're guaranteed you can't accidentally reload with a bad configuration). It's also incredibly refreshing to be able to trace the flow of a request (not to mention adding debug statements!) from function to function, instead of muddling through hundreds of lines of XML blocks trying to guess whether one is being activated because it's not clear if the request filename has been rewritten yet. Mostly I'm just glad that I mostly no longer have to deal with lines like this, where `RewriteCond` affects the *next* `RewriteRule`, wherever it may be in the block, but not any other ones after that: RewriteCond %{HTTP_HOST} ^ifixit\.com RewriteRule ^/var/www/ifixit/pub/(.*) http://www.ifixit.com/$1 [R=301,L,QSA] in favor of something more like this: if (req.http.host == "www.dozuki.com" &amp;&amp; req.url ~ "^/blog") { error 301 "http://blog.dozuki.com/"; } ---- \* Although there is the incredibly confusing behavior of repeatedly processing a block until that loop's output is the same as its input, which can cause similar issues.
I agree with this, it's main issue for years has been the lack of consistency. Naming conventions, classes, functions (camelcased vs underscores). Indeed a good IDE with hinting is a must for such development, KomodoEdit does well on this regard (vs Eclipse). Other than that, anyone can make any language insecure. Security wise no language is better than the other.
That works for what you have now, but what if your needs change in the future? What if that script is working on a site that's become too big for mysql to handle and you need a new database engine? Then you need to rewrite that code. PDO is an abstraction layer. The example I gave you makes use of PDO to connect to the mysqli api. It's doing the same thing as your example there, only if you need to change to a different type of database, you only have to edit the PDO connection line and it's ready to go again.
When you are interacting with the DB, you don't convert the GROUP by with a timestamp that is adjusted as per user's TZ. Always interact with DB in UTC. Well, I for one love storing them in integer timestamp. By letting the application does the conversion during input or output gives you more flexibility. And if you are converting thousands of rows for timestamps in one shot, you're doing it quite wrong (LIMIT / OFFSET) comes into view. I am yet to see an app that will literally return thousands and convert timestamps in decent scenario.
Yes, I know, but I'll reiterate: &gt; Your database should know **nothing** about timezones, at all, ever. Setting a timezone on the session is problematic, because timezones are not specific to sessions; they're specific to *users*. And, while an HTTP request will always be coming from only one user, your application may be doing things involving lots of different users, or on behalf of other users, or any of a million different scenarios where setting a timezone on the session can get you in trouble. So, always convert between UTC and other timezones as needed in your application code, and never handle it in the database. Hope that helps.
CodeIgniter v2.2 (the currency active stable) actually runs on PHP 5.1, v3 (the never released but ready for two years not-even-beta) is the one that requires PHP 5.2.
wait..what? i've seen a lot of weird shit in PHP but...what?? oh... because `true` is in the array and all those things can be typecast to true. i gets it.
I think avoiding confusion with the mess of 6 is a good thing. It should be asked, "what is the point of the version number?" The answer isn't "To be one more than the one before". To many 5+1=6 makes sense, and jumping a version seems wrong. That's great, but why does it matter how it 'feels'? More important is uniquely identifying a version, so when we refer to it, we all know what we're talking about. The fact it wasn't released doesn't really matter, as it is still something we can talk about uniquely.
Pontier has a trademark on the elePHPant name? I'd like to see a source for that, because I doubt it's true. It might be true that there could be an issue with the PHP logo, but we have no indication thusfar that they *didn't* check with PHP Group before doing what they're doing.
See also: [you silly string, you're not a number](http://3v4l.org/ulqj3).
&gt; Indeed a good IDE with hinting is a must for such development, KomodoEdit does well on this regard (vs Eclipse). Have you tried [PHPStorm](http://www.jetbrains.com/phpstorm/features/)? It's from the same company as ReSharper, and it's awesome.
if it is like an analytics data, the record supposed to be static record which will not changed in some period, then better to cache the result in serialized or json format or run cron job to build the summary or report to be consumed later, working with thousands of rows in single call will affect the application performance, imagine the case when hundreds of users accessing thousands of records concurrently
&gt; You didn't really address the OP's question at all. I am sorry about that. May be for REST you should consider https://github.com/koriym/BEAR.Sunday . 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Change detection and notification**](https://en.wikipedia.org/wiki/Change%20detection%20and%20notification): [](#sfw) --- &gt;__Change detection and notification__ (__CDN__) refers to automatic detection of changes made to [World Wide Web](https://en.wikipedia.org/wiki/World_Wide_Web) pages and notification to interested users by email or other means. Whereas [search engines](https://en.wikipedia.org/wiki/Search_engine) are designed to find web pages, CDN systems are designed to monitor changes to web pages. Before change detection and notification, it was necessary for users to manually check for web page changes, either by revisiting web sites or periodically searching again. Efficient and effective change detection and notification is hampered by the fact that most servers do not accurately track content changes through Last-Modified or [ETag](https://en.wikipedia.org/wiki/HTTP_ETag) headers. &gt; --- ^Interesting: [^Google ^Alerts](https://en.wikipedia.org/wiki/Google_Alerts) ^| [^NetMind](https://en.wikipedia.org/wiki/NetMind) ^| [^Web ^feed](https://en.wikipedia.org/wiki/Web_feed) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cj76ya4) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cj76ya4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
yes. But that's a good thing. It prepares you for what the language is like.
Thanks! Hadn't seen that one before.
&gt; but you'll definitely get downvoted for linking an article that has been shown to be largely uninformed and outdated bullshit That's not proper reddiquette either, but whatever, it's all imaginary internet points. &gt; That's really the problem with people like you though - you don't actually learn anything about what you're trying to criticize, you just mindlessly parrot what everyone else is saying. This is what shitty programmers do. As a well-paid senior software engineer in a well-known company, I'd like to think I'm not *shitty* per se, but of course you know me better than I do. And sharing the views of someone else is not mindless parroting. Is that article perfect? No. Are some of the points outdated? Yes. Is the core of it, i.e "a fractal (look it up) of bad design" an appropriate description of PHP? Yes. For most decent programming languages, even those who don't use it can appreciate them as fine languages (i.e a Ruby dev who thinks Python is great too). But a non-PHP developer never ever finds PHP acceptable. I realize PHP pays most of my paycheck, but at least I'm not delusional about it being a shitty language. People who "love" PHP need to get their Stockholm Syndrome treated.
Ideally, yes. I have never personally worked on a project where UML diagrams were already present. Having class diagrams for inheritance and describing interactions/relationships between objects can be very helpful.
That is 5 years from now; presumably they'll upgrade to the new LTS at that point. A 5 year lifetime is not a bad strategy at all.
I'd start by looking up your local laws about handling patient records. "cheap web hosting" doesn't quite sound right when thinking about storing or accessing sensitive data. edit: nor does "not having knowledge about servers" ;)
thanks! I didn't think about that. In the office they already have the records for patients locally so I edited my question to be more clear. The remote part would be for the appointments which have no patients records. It would be for only for possible patients to get an appointment and for doctors to look their daily agenda.
Even those appointments could be considered sensitive data. Let's say you have a records showing that mr. John Doe has been seeing a psychiatrist. What would happen if those should happen to leak? (And who would get sued?) Checking the appropriate laws should give you an idea what you should take into account when doing this. (What you are allowed to store and how, how the data and access must be secured and auditioned...) Here even paper calendars are archived, locked up and stored with other patient data if the doctor writes patient appointments on them.
The things is most developers are currently on PHP 5.3, 5.4, or 5.5. To them, the next major version is 6.0. The fact that 100 years ago[1] there was some unreleased thing that only core PHP contributors and few bloggers actually knew about is completely insignificant. The community you are referring to, who might be confused, has about 100 to maybe 1,000 people in it. Everybody else would be confused by skipped number. [1] In Internet Time
&gt; If PHP was compiled with --disable-url-fopen-wrapper, it won’t work. No shit. You've disabled it, do you magically expect it to work or something? &gt; If allow_url_fopen is disabled in php.ini, this still won’t work. Again, no shit. &gt; Because of the @, the warning about the non-existent file won’t be printed. Well yes, because by having the @ there you want to suppress warnings &gt; But not if the right error_reporting level isn’t set. Oh dear, you've set your reporting level too high and now you're not seeing errors. Closed: Working as intended. &gt; Or if scream.enabled is set manually with ini_set. ini_set overrides php.ini, so duh? &gt; If it is printed, exactly where it goes depends on display_errors, again in php.ini. Or ini_set. Because having no choice as to where errors are logged to would be such a good thing (obvious sarcasm). So that was an awful lot of complaining to raise one valid point: `scream.enabled` is a strange setting to have.
I am assigned to make another local app for the doctor's assistants. That handles patients records and appointments.I am going to keep that in the db they already use then. The web app was something I wanted to offer but I didn't think about that scenario. With the web app I better of just keeping the doctor's appointments with no data about the patients. Just as any agenda would do right? Thanks for the reply!
these releases are so frequent
You conveniently ignored the parts you have no answer to. Namely: * Docs don’t say what “won’t work” means; returns null, throws exception? * I can’t tell how this innocuous function call will behave without consulting compile-time flags, server-wide configuration, and configuration done in my program For the first point, please don't reply with "try and see". Observed behaviour is not defined behaviour and should never, ever, *ever* be relied upon. For the second part, PHP is the only major language with a server-wide configuration file. I mean *the language has a fucking config file*! No sane language does that.
what are you'r error reporting settings? take in mind global php.ini, vhost, htaccess and file level settings. first run gives you a notice which does not abort the execution of the script. second one is a fatal error and thus cancels everything.
So I had been using the PHP function because of the project im working on. ini_set('display_errors', 1); error_reporting(-1); I just changed the php.ini "display_errors = On" (was off). And it is now giving me the correct error messages so I guess that "fixed it". But I would like to be able to use the PHP functions in the future (If I have to test something). Am I doing it wrong, is there another way without touching the php.ini? 
Yeah, the thing that makes PHP amazing is also what makes it problematic. To be honest I'd rather a programming language have a low barrier for entry and be more inviting to new developers. That said, there are also some crazy quirks and inconsistencies, not just in method names but things like how `('string')` returns true but `('string' == 0)` also returns true. Stuff like that is kind of insane, and while there's a decent reason behind it, it's gonna catch new developers out. I know the first time I encountered it I spent about an hour working out why my code wasn't working.
Its not a bug. You have a syntax error. You have an open parentheses "(" which you have not closed anywhere. Your PHP settings are not set to show all the errors, so you are getting a "white screen of death" (WSOD). See these two StackOverflow posts that give good ways to fix a WSOD: http://stackoverflow.com/q/1475297/1317935 http://stackoverflow.com/q/2914127/1317935 
Whoa whoa whoa, is there an explanation for this?
A PHP function would look like this: &lt;?php function exampleEcho($msg) { echo $msg . "\n"; } exampleEcho('My Message'); Is that what you're referring to? edit: Ah, it looks like you're referring to the error reporting functions. Yeah, they can't handle a parse error. They never get executed because the file is deemed invalid.
Even if `display_errors` is off the errors are still logged. Just check your logfile for them. Is this linux? Install `logcheck` - it will email you the errors.
I know its a syntax error. The "bug" I was refering to was in the "debugging process" because it wasn't showing the error message so I could fix my syntax error of the "(" the example was a watered down to talk about debugging.
Yes I am doing that already
Thank you, I never knew that. 
I just assume that returning an warning and failing means nothing (or rather, null) gets returned, although I guess assuming anything with PHP is a bad idea :P (Because there are things that do return false when they fail...). So yeah, 0 points to the docs there. It also just occurred to me that even if it PHP was compiled without fopen or it is disabled, the command still exists so you can't know if it works until you actually call it. If it is disabled it should be inaccessible so that you can either check it with function_exists or let it horribly fail (Which is better than the current quiet/passive failure as there is no way to let execution continue past that call). Personally I like the idea of the server-wide configuration although I guess I can somewhat understand why it isn't always ideal, if you're running a single application then its probably more sensible to have it with the rest of the data. In an environment where you're running multiple applications from one server you have the basic config in the global php.ini and then the per-application specifics in each of the fpm pools (At least, that is how I currently do it).
[mahacctissoawsum hits it on the head](http://www.reddit.com/r/PHP/comments/2bmf5k/php_and_the_people_who_hate_it/cj74ipp). It's cheating a bit because 'true' is in the array (as is false) and some of the searches can be type-juggled to either true or false.
Think about it. If there is a parse error in running the PHP code, then your function to turn on the error also doesn't run.
Since you have a parse error, PHP can't make any sense of the the script you're trying to get it to run. Ergo, it won't be able to execute those statements either, meaning that the values picked up from php.ini would be the current ones. It's a good idea to have different error_reporting / error_log / display_errors settings between production and development, where the former just log the error and does nothing more, while the latter gives as much feedback as possible at the moment.
upgrade of personal license costs $49. that's not expensive if you earn money by using it.
The adoDB package has been around for over a decade now. There has never been an excuse for SQL injection. 
License expiration just means "you cannot get any more updates", it does not mean "you must stop using this app right now". That said, the licence costs less than your monitor or MS Office, your boss should not refuse it just because of price. But if that does happen, a personal licence renewal is 49$/year, I don't think that's "damned expensive" tbh.
Ohhh right that makes sense. That's still batshit crazy, but now I know to be careful when using in_array()
You should always be careful when you're in a situation where type juggling can return unexpected results. Strict checking or using === (depending on how you're doing the checking) is always better when you want a more consistent behaviour.
$(wget -q http://whatthecommit.com/index.txt -O -)
That's what I use. ~~€100~~ €89 for a personal licence, but if I put a cost value on the time it has saved me, it has *easily* already paid for itself.
If you are lucky you can open the v1 link after few clicks in Intel Pentium 4 3.6 GHz and 1 GB ram while there is running EasyPHP and Firefox with one tab and nothing else.
fantastic ;)
That's not a bad thing. I imagine it's partly because releases now have a defined end of life date.
Up until today, it was "end of day commit". Now, it's "..."
The approaches are listed on that very page, in the "Three Approaches" section... The universal approach is: you save a copy of the page source somewhere, reopen the page later, compare the new source against the old copy. Sometimes, the target site uses HTTP headers correctly and specifies the page's Last-Modified date, so you don't have to download the whole content. Alternatively, the target site may support push-mode notifications where you can give them an URL and they promise to ping it when their page changes - in that case you also don't need to download the content.
http://semver.org/
There's one patch release per month (approximately).
Since the past year I've been refactoring legacy code... (not even my code) most of my commits lately looked like Code-cleanup Sanitized input, variables and keys #cs #strict-errors the last line telling CodeSniffer to pre-commit block on strict settings.
Also because PHP is one of few web-oriented languages, security oversights in PHP programs are more likely to be big problems because they're running websites on the Internet. Try to write a website in C and you'll have at least as many security issues, but nobody will condemn C for it because it's a low level general purpose language. 
"Don't even know any more."
Think of the C programming language - thanks to the existence of the [C99](http://en.wikipedia.org/wiki/C99) and [C11](http://en.wikipedia.org/wiki/C11_%28C_standard_revision%29) standards, the expected behaviour of a C compiler can be clearly defined. This has led to the proliferation of [many different compilers for C](http://en.wikipedia.org/wiki/List_of_compilers#C_compilers) over the years. Not so for PHP interpreters - until relatively recently, there was only one of them (i.e. the one that you download from php.net or comes packaged with your Linux distro). If I wanted to write my own, faster PHP interpreter then I'd have to use a combination of the docs at php.net and a **lot** of guesswork and trial and error, which is presumably what the folks who wrote HHVM have had to do. A PHP language specification would make the task of writing a new interpreter for PHP a whole lot easier to implement and test.
While the manual on PHP.net documents the PHP language to a certain extent, it mostly documents the core functions / libraries / extensions. With the manual alone, while you can reproduce all the core functions / libraries / extensions, and some of the behaviour of the language itself, there's a lot of specifics in terms of the language itself that are omitted for the sake of simplicity. The language specification being produced by the Facebook team documents in detail exactly how any implementation of the PHP language should act in a given situation - things like what values should be automatically converted to what types when type juggling and how variable variables / variable chaining is handled (see the [uniform variable syntax rfc](https://wiki.php.net/rfc/uniform_variable_syntax) ).
Yes, I have tried PHPStorm (funny twice, when it was first released, and recently couple months ago). I have a knack for everything 'dark-mode', and looking at both these IDEs, they seem to be just at par with one another. Biggest thing for me with KomodoEdit is that it is open-source and free. I'm always on the lookout though for better IDEs, maybe soon when PHPStorm will truly blow me away.
The main thing id like to see is easier navigation, this is what I see at python.org. If someone said to develop a site like Python.org, I'd ask why 5 times. I am a contributor to the docs and am slowly learning to be one for the website, but it isn't exactly an inviting experience. Are you a contributor or "doer"?
&gt; A properly designed language doesn't have such inconsistencies. Every single language ever created has inconsistencies, quirks, unexpected behavior, etc. I'll defer to Bjarne here: &gt; There are only two kinds of languages: the ones people complain about and the ones nobody uses. --- &gt; The article is titled "PHP: a fractal of bad design". Isn't that true? Are you really arguing that PHP is a well designed language? Really? Of course is isn't a well-designed language, and *everyone knows that*. I don't know anyone who knows anything at all about PHP and its history who would ever argue that point. But this has nothing to do with what I said. I noted that there *are* big design problems in the language, yet the author touches on *none* of them in this article. Instead, he builds up a giant mass of fluff, straw men, trivialities, arguments against *things that aren't even the PHP language*, and all manner of other things to play to emotion instead of reason. Had the author stopped typing after the article title, we'd all have given an affirmative nod and a sigh and moved on with our lives. But he didn't. And it's what's *inside* the article that makes it horrible. &gt; If PHP was compiled with --disable-url-fopen-wrapper, it won’t work. (Docs don’t say what “won’t work” means; returns null, throws exception?) Note that this flag was removed in PHP 5.2.5. &gt; If allow_url_fopen is disabled in php.ini, this still won’t work. (How? No idea.) "Won't work" means exactly what it sounds like. The author is being incredibly obtuse here. If it's not documented explicitly enough, that's a problem with the *documentation*, not the *language*. The author is an idiot if he thinks PHP is the only language with documentation holes. And an even bigger idiot if he found such holes, but did not report them so that they could be fixed. &gt; Because of the @, the warning about the non-existent file won’t be printed. &gt; But it will be printed if scream.enabled is set in php.ini. &gt; Or if scream.enabled is set manually with ini_set. &gt; But not if the right error_reporting level isn’t set. &gt; If it is printed, exactly where it goes depends on display_errors, again in php.ini. Or ini_set. All of this is well documented and expected behavior, with the exception of `scream.enabled`. And man, let me tell you, if I had a dime for every time that setting has ever come up for me or anyone I've ever met in my entire career using the language, I'd have... *$0.00.* &gt; This is neither outdated, nor an edge-case. This piece of code is used all the time in PHP codebases. Do you really think this is OK? Honestly? I'd appreciate an answer to this. Yes, I honestly think it's perfectly fine. I've never once had a problem understanding how `fopen()` works, how the URL wrapper works with it, and how error reporting in general works (with the exception of `E_ALL` not actually reporting *all* error... which, surprise, surprise, has been fixed).
a language spec defines the "grammar" of the language, it doesnt define specific functionality but abstract pattern/syntax/grammar of the language it makes it possible to make a compiler for that language - and it makes sure that all compilers for that language are compatible even though they might not all have the same features, they still all understand the same .php files
&gt; Yes, I honestly think it's perfectly fine. Then honestly we have nothing more to discuss. To each to their own I guess...
PHP is open source so instead of "a lot of guesswork and trial and error" you can investigate the source code. I agree a formal language specification would be useful.
And [here](http://forums.devshed.com/php-development/929746-php-fractal-bad-design-hardly-post2816643.html#post2816643) is the author's answer to that rebuttal.
&gt; PHP is open source so instead of "a lot of guesswork and trial and error" you can investigate the source code. That is just a big, fat, **NO** in language design. Looking at the code only gives you ***observable behaviour*** which includes bugs, missing features, unhandled cases etc. A **language specification**, on the other hand, **has no code**, it simply **defines grammar**. Anything that happens which is not in the specification is therefore automatically a bug. PHP lacked a spec for a loooong time and this new effort by Facebook will hopefully fix that.
Alright. Carry on then, I suppose
Have you used other languages extensively? I have never ever seen a single person who has used many other languages extensively say anything remotely positive about PHP. I found most of the ones that do praise PHP are people who have been exclusively using PHP and their knowledge of Python, Ruby and other languages does not extend beyond reading news headlines and casual web browsing. Firstly there are things like static typing and a powerful type system that PHP is missing which makes it produce fragile applications. This is not very specific to PHP, many languages have this issue but with PHP it's worse. I personally prefer static typing for large applications. More specific about PHP is the fact that it makes writing crappy software extremely easy. And when you can, you will. The counter-argument about this fact is often "well duh ... learn to write proper code". Which is like, say, Boeing creating a jet where if the pilot takes his hands off the controls for 5 minutes, or pushes the wrong button the jet just explodes. And then Boeing saying "well ... you guys just aren't good enough pilots ... learn to be better pilots and just remember not to push the explode button, and keep your hands on the controls". After all this my point is, if you haven't used other languages extensively you don't know what you're missing. If you haven't go use Python (or something along those lines) for 5 years then come back read your post. Chances are you will think "boy was I an ignorant bastard". No offense to you by the way, I have no idea who you are and what you know, the example I gave is what more or less happened to me. This kind of cycle will repeat itself. After some time with Python I understood why many people dislike PHP. Yet I didn't understand why some people disliked Python. In the same way that one day I didn't understand why people disliked PHP. After maturing even more I have started to understand why people dislike Python and praise Haskell or Ada. I'm learning and using Haskell, Ada and Go. The cycle is probably going to repeat itself here as well. I'm gonna really like them for some time, and I'm going to not understand why other people may not like it. Until given enough time and experience I will. And I say the things above not in a cult-like blinded love for any particular language. In fact I don't give a damn about language wars as long as I can get shit done that's all I care about. When I moved from PHP to Python that was not a "emotional" decision because PHP was no longer cool or anything like that. It was because I finally deeply understood what each one gets right and wrong and it was a no-brainer from there. Same thing later down the track. I developed my skills and could finally understand why static typing and powerful type systems and functional programming languages result in more robust and safer programs. From there moving away from Python was a no-brainer again. Now from all the above I may give you the impression that I'm some language hipster guy trying the flavor of the month, in reality very far from it. I spent significant time both personally and professionally with the things I mentioned so that is not the case. And having said that, and as cliche as it sounds, the more I learn the more convinced I become that it is a matter of right tool for the job. I still write fragile bash scripts when the situation calls for it. I write simple Python scripts or command line tools. I write cross-platform standalone programs with Go. And I write critical software with Ada. 
I've found that most of the people that crap on php have never used it. They think it's below then because of how easy it is to get started using it. They never even break the surface of the true power that's below the surface. PHP is easy to start, and hard to master. Only someone who has spent years with it can truly understand it, and appreciate it. One of the things I hear people talk about is how it's not strongly typed, and they act like its a lesser language because of it, but sometimes I feel like that make it more challenging when building larger programs with it. The only thing you can't type is the 5 or so primitives, you can "hint" everything else. Either way, it takes a detail oriented person to keep tabs on their types instead of offloading the concern onto the compiler. Don't get me wrong though, I'd love to be able to type hint (or whatever we want to call it now) with the primitive types. But I could use HHVM and Hack if I really wanted it that badly. As far as security, the only risks in a program are the ones the developer creates. 
**Newbie**: Hey, I can see lots of stuff about PHp 5 versions, and stuff on the recently released PHP 7, but I can hardly see anything on PHP 6. What's that all about? **Experienced dev**: It was a small shitty thing that got half released years ago. Ignore it and pretend it never existed. **Newbie 1 Response**: OK, cool. Thanks! **Newbie 2 Response**: What? Huh? I don't get it! I'm so confused!! I can't code, I can't sleep, it's tearing me up. WHAT'S GOING ON?!?! I think response 1 is more likely than response 2.
Ctrl-p baby. Never worry about haystack/needle again.
Good that you are contributing where you can. Honestly. I think it would help if you elaborate your vision on how things can be improved and create a list of concrete actions and present them in the ticket. Maybe it's good to find the appropriate mailing list (not sure which one), and ask other contributors what they think about your ideas. I can see how it is not an inviting experience. I've been there myself. Now i haven't contributed to the php.net website before, nor to php itself. Because it's not really my thing. I contribute to php by organising local community events, as well as improving the OSS that i use daily.
Awesome on organizing events! I love attending them (PUGs and conferences). Thank you for your comment though, I will update the ticket to highlight a couple points for making the site more usable. With all of this talk about PHP not being an enterprise language, I think a more usable site with case studies, how-to video feeds, whitepaper on using it in an enterprise environment would be useful to it's image. Maybe I am wrong? Maybe the community doesn't care about this. I feel that representing a brand is just as important as how well the language operates internally. Cheers
**Newbie:** The current version is PHP 5 and the next version is PHP 6. Makes sense. I have no questions. **Experienced dev:** The current version is PHP 5 and the next version is PHP 6. Makes sense. I have no questions. 
Here's another tip: you can give your datasets names in a data provider. public function someProvider() { return [ 'cash_payment' =&gt; ['Cash', 100.00], 'credit_payment' =&gt; ['Credit Card', 95.00], ]; } Why bother? Test's are meant to fail -- that's their job. They should fail well and provide you with information about the context of the error. Naming datasets is a way to do that.
The buildpack won't setup a droplet for you or handle autoscaling - This article has instructions on how to install Dokku on a DigitalOcean droplet. The buildpack just has things like nginx, php/rails/node.js/whatever, etc. so you don't have to install or configure any of those services to deploy an app. So basically you create a droplet, setup Dokku, then just "git push" your code to your droplet/dokku application to deploy it. The buildpack will be run on deploy and will go through the process of setting up the properly-configured application container for you.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
&gt;I realize PHP pays most of my paycheck I think it pays none of your paycheck if you feel that article is largely factual, and I feel only an incredibly shitty programmer lacks the ability to see how a given language has changed over time. You're either a troll, or you're largely ignorant. If you're going to make an argument against php, at least try using something that examines the current state of things not some badly written rant that was mostly wrong even when it was published.
There are a few different ways to do it, but here is one: $objects = array(); $objects[] = (object) array( 'id' =&gt; 1, 'input_type' =&gt; 'something_else' ); $objects[] = (object) array( 'id' =&gt; 2, 'input_type' =&gt; 'separator' ); $objects[] = (object) array( 'id' =&gt; 3, 'input_type' =&gt; 'separator' ); $separatorObjects = array_filter($objects, function($object) { return $object-&gt;input_type == 'separator'; }); $lastSeparatorObject = $separatorObjects[count($separatorObjects) - 1];
I... don't know why I never thought of this.
Personally I think I wouldn't solve this problem by automatically serving a version of an asset based on a language setting. You're much better off solving this *in* the html. Generate language-specific urls leading to language-specific assets. If you are unconvinced, and want to give your approach a shot anyway, you should make use of X-SendFile. X-SendFile reduces the time PHP has to be running and will improve performance because it hands control back to your webserver to serve the asset. Freeing up the PHP process means it can serve other requests again. There is still a performance hit in this scenario though. So to answer these questions: 1. How much? 2. Is the performance hit acceptable 3. Will it "destroy your server performance" 4. Will it make pages sluggish? The answer to all of those questions are not simple yes or no answers. This depends on: 1. What you quantify as acceptable performance. 2. How many people are hitting asset urls on average at any given moment. 3. Or more specifically: what you commit to support to your client. If performance is an issue for a particular client, give them specific numbers for what you intend to support, or at least reasonable guesses. 4. What your hardware and software set-up is like. The obvious way to find out is always the same: do performance testing. Be scientific and figure out the answers yourself. It's impossible to ask strangers on the internet whether "something" is "good enough" and expect a good answer, when you quantify neither "something" nor "good enough". 
"fixes"
That is good advice, I suppose my first question should be, what is the best way to go about performance testing in this scenario. 
fixed some stuff
It's a joke. It's called the DramaLlama because the PHP internals people can't seem to agree on anything.
Yes. As opposed to how it actually *does*, which is what you get by looking at the reference implementation.
You're thinking of VB.net.
The fact that you did not address any of my points and had to resort to ad-hominem attacks to argue your point makes me think we are talking at an entirely different intellectual level and makes me question what is the point of arguing with you... I'll leave you with this: Many programmers think many languages are great, but only PHP developers think PHP is in any way a passable language. And that, speaks volumes...
Thankfully, enterprise and xml usually don't have much to do with pl theory and design.
My favorite was just a question mark
Obligatory XKCD Reference: http://xkcd.com/1296/
"I forgot what a fucking beast &lt;insert product name&gt; was until now" (translated)
&gt; The fact that you did not address any of my points and had to resort to ad-hominem attacks When you actually start making points worth refuting I'll start addressing them. You use a bad article to make your arguments for you, and then you follow up with a wall of "PHP IS BAD" without actually forming an argument based in fact. Again, you're either a troll, or you're ignorant. I'm starting to inch towards the latter. I kinda wish you were a troll, because the world doesn't need another idiot incapable of thinking for himself.
6.1 would not be a good time to introduce major breaking changes from 5.*, because - as others mentioned - PHP has been (trying to be) SemVer since PHP 5.5.
I hate all of you. Here's a pretty normal commit from our codebase: BlurbFinder: Search for query in guide title The `BlurbFinder` (which is used to suggest prerequisite guides on guide edit) doesn't search for the query in guide titles. This usually isn't a problem because it searches the type, device, and thing which are usually combined to create the auto generated title. However, this doesn't cover custom titles. This adds the guide title to the search query so guides with custom titles aren't left out. QA == http://sandbox.www.&lt;redacted&gt;.com/guide/intro/meta/229 Before: Searching for `r` results in a single result. After: Searching for `r` results in many results. You can also test any guide with a custom title. Note: Only guides about the same device are displayed. When you're looking back at your code three years later trying to figure out if some behavior is a bug or was intentional (or if it's still needed), you'll hate you, too.
Didn't see the link posted but [here](http://www.reddit.com/r/PHP/comments/2bfdwl/facebook_shepherding_a_php_language_spec/) is the reddit post announcing Facebook's push to specify the language.
I think we're talking about shorthand commit messages here. ;)
"Refactoring the refactored refactor class"
CI is no longer developed and decaying rapidly. I suppose it excels on running on servers that are never updated.
&gt;That test can be as simple as "hit this endpoint over http and make sure it returns the same html as before", but without tests you'll never know if you break something. Can you do this in PHPUnit? What would it look like? 
If you must store PHI (Protected Health Information) in the database there are options available. Amazon [https://aws.amazon.com/about-aws/whats-new/2009/04/06/whitepaper-hipaa/](https://aws.amazon.com/about-aws/whats-new/2009/04/06/whitepaper-hipaa/) [http://aws.amazon.com/compliance/#hipaa](http://aws.amazon.com/compliance/#hipaa) 
the joke contained unicode characters
The transcoding is funny enough at the bottom of my priorities, but things like retreiving/modifying meta data and possibly pulling screen caps (which may cross over into transcoding capabilities) will probably be higher priorities, have you ever done those things? I'm going to start looking into ffmpeg right now too (shelling them off would probably be the only way I'd want to do them), thanks for the suggestion on that one!
Meaning whatever hash, iterations, and salt arrangement and juggling them into their own database keys instead of having just one automatic clever arrangement with password_hash. Keep in mind I was still on FPM 5.2, because I was a nublet and because the Debian/Ubuntu packages hadn't been touched in years.
A Spanish co-worker's commit message: "Bugfux"
It is even better when you have a descriptive name: public function someProvider() { return [ 'Cash payment should have a fee' =&gt; ['Cash', 100.00], 'Credit Card payment should not have a fee' =&gt; ['Credit Card', 95.00], ]; } 
ffmpeg can do all that. 
For basic metadata, I'd look at [`mediainfo`](http://mediaarea.net/en/MediaInfo). There even appears to be a [Symphony bundle](https://github.com/AmericanCouncils/MediaInfoBundle) for wrapping it in PHP. Assuming you can afford or pass-thru some money on this project, I'd really recommend [Transloadit](https://transloadit.com) for transcoding and getting stills from the video. They have a pretty seamless API that lets you upload (you can also point the user's browser to upload it direct to them), and when the video is transcoded they can put it pretty much wherever you like (S3, FTP), and then they ping your service to let you know the file is ready. I would not recommend messing around with ffmpeg unless you have somebody around who can test out the various compression settings and come up with some sane defaults for you. And you'd probably end up building a queue &amp; callback system for transcoding anyway, at which point you could have implemented a service like the above and been done with time and budget to spare. If you're interested in doing it as a personal project, then go for it. ffmpeg is awesome and can definitely do the job, including extracting stills. But it will take a decent amount of time to get it working well with the various input types you could be starting with.
transloadit would be about the only thing I'd have a hard time convincing anyone on. If it were a one time fee then I'd probably be able to swing it, but adding a monthly fee would be more difficult since I'll already be needing a dedicated server with an above normal amount of storage for this project. The development work of ffmpeg doesn't scare me off too much, just a lot of research for it still though. As of this moment this project is just a fact finding mission, so who knows what people will decide to do in the long run anyways, lol. The que system does bring up a good question though, can ffmpeg run simultaneous instances of it, or handle multiple requests at a time?
Mine is probably "Whoops."
So I've never done that on a commercial level, but is this a type of raid array your describing? if that's the case, can you change capacities without rebuilding the array? And aside from larger and backed up storage, what's the advantage? just faster read/write speeds I'm assuming?
ffmpeg is the way to go, I wouldn't attempt to shell out to it from a web page though. I generally use a web page to upload the video to a directory then have a cron job with the ffmpeg script watch that directory and process stuff as it comes in.
It's being actively developed, more so than it has in the past. It's just stuck in its own funk / without proper leadership.
Serving site assets using a download script shouldn't overly effect your performance at all. Usually the download script is just setting the header. Is it possible to engineer a shitty download script that delivers terrible performance, of course it is! Just don't do that. As an alternative to Cloud Flair you can set up a Varnish proxy.
that's about the exact process I'm imaging as well and that I'd allow for ftp access as well. but the cron watching a directory to process it in would be what I'd do too. 
Do some load testing: http://httpd.apache.org/docs/2.2/programs/ab.html
I will play devil's advocate. Some "benefits" to CodeIgniter: - Runs on older versions of PHP, if you happen to need legacy support. - More stable, in that the framework does not advance quickly, and has a primary target of staying as backwards-compatible as possible. - Smaller footprint; can be faster in certain environments (though that is more the env than the framework). - Simpler code base; easier to pick up how it works than Laravel (aside from the whole global instance nonsense, which can be difficult for beginners). I don't use CI anymore, personally, but I still suggest it as an option for devs looking to improve their knowledge from their procedural-only roots. Laravel is fantastic, but can be daunting. If you want to pick up on some of the basics of OOP, CI is a good step. I wouldn't *stay* there, but it's a step.
I'd probably push towards exec just because I'll probably be processing files that'll take the user beyond their 30 second attention spans (or times that risk timing out the browser)
It's basically the best framework I can use in my 5.2 environment. Also the documentation is pretty damn good.
haha there's a possability that it'll hit some pretty high useage, even as an internal tool. I'm adding some notes in my research that this would offer though, because it would cut down the development time.
That, or convert the input date to UTC before it gets sent to your MySQL query.
Regular PHP was keeping up just fine, it's just the FPM branch that is still 5.2. I was able to hook up a [PPA](https://launchpad.net/~ondrej/+archive/ubuntu/php5) for it. This was around 2010 anyway and I hadn't explored user login systems since.
With 1 new thread every 10-15 minutes does it really matter? I think it is a bit ridiculous to shuffle support questions off to another subreddit. Is it really that difficult for people to tell from a headline what threads are most likely someone asking for help vs. information about php?
As others have outlined. There are a few command line utilities out there for doing video inspection. FFMpeg comes with an FFProbe binary that provides all the details you were requesting. Also MediaInfo can sometimes read video files that FFMpeg chokes on. There are PHP wrappers for these things but I'd recommend just doing an exec. You'll have more control over the parameters used and it will be easier to test the commands yourself. For transcoding you have a couple options. 1. You could use FFMpeg. Just keep in mind that transcoding is a fairly CPU intensive operation so make sure you don't do it on your main webserver. 2. Amazon Web Services (AWS) offers a transcoding service. It's kind of expensive but it's easy to use and works really well. In terms of uploads you could use a javascript uploader like Resumable.js or something similar. They break large files up into small 1M chunks that you can then reassemble on the server side. - I'm responsible for video handling at the start-up I work for. We have folks upload large video files, transcode them (into several qualities), then stream them. Let me know if you would like more details on how to do this.
Math in PHP and math in SQL is all pretty much the same. I don't think you're going to fall over doing it either way, but of course you should benchmark it if you are concerned. Time how long it takes for foreach and convert times in PHP. Time how long it takes for MySQL to do it. Implement whichever wins.
A fair point, and I actually just got the same suggestion on Twitter. My original examples actually used inheritance, but I was worried it would be too much for beginners without a more complete (longer) example. Using includes is still a totally valid way of using templates, and it's probably easier to digest if new to this topic.
I'd love to hear more about how resumeable.js works (and how it's reassembled). Does it allow you to include additional data? Because what I'm imagining right now I'd want to accosiace some account info with that uploaded file. The ugly way to get this working that I envision is just having smaller web based uploads or ftps dump files into a directory where a cron grabs them and processes them. web based would create a DB entry with some basic info and file name for pairing. FTPs would just dump into a client specific directory so I know who to make the video available to. What kinds of upload times do you usually see on any of those methods? Do you place any limitations or find any big limitations what you can't work around or at least not very easily? Also, what's the processing time like? I don't think it'd be a challenge to get one or two dedicated servers for this project, but id' hate to have two videos being transcoded at a time and have that bring the service to its knees. A que system would be pretty doable, but it's hard to figure the best approach without just seeing what kind of abuse a potential server might be able to take and how quickly it could spit everything back out.
I agree with this. This sub isn't THAT active. I've been managing online communities for about about 12 years now and one thing I learned was never to over-organize. It was tempting to create 50 different forums to properly organize topics, but then not only did you make the forum harder to use, you ended up creating a "divide and conquer" strategy whereby the activity of each anemic forum eventually died, since there was no critical mass of activity to sustain each forum.
Perhaps have another chapter on extension which compares the old header/footer way to the new extend way.
Thanks for the replies everyone. I think I have found a solution (will need to adjust to only target images) with the following .htaccess rule: RewriteEngine on # first try to find it in the country folder... # ...and if found stop and be happy: RewriteCond %{DOCUMENT_ROOT}/%{HTTP_HOST}/%{REQUEST_URI} -f RewriteRule ^(.+) %{DOCUMENT_ROOT}/%{HTTP_HOST}/$1 [L] # second try to find it in default... # ...and if found stop and be happy: RewriteCond %{DOCUMENT_ROOT}/default/%{REQUEST_URI} -f RewriteRule ^(.+) %{DOCUMENT_ROOT}/default/$1 [L]
Since it hasn't been explicitly mentioned yet, for reading/outputting video metadata, I'd suggest using FFProbe, which comes bundled with ffmpeg. A command like this... ffprobe -v quiet -print_format "json" -show_format -show_streams sample_movie.mp4 ...will generate a JSON array for all of the metadata associated with the container and each of the streams (audio, video, subtitle, etc.). If you want a different output format, [the docs show](http://www.ffmpeg.org/ffprobe.html#toc-Writers) that it supports output JSON, XML, CSV, ini, or a custom key/value pair. Makes it fairly easy to read and store the metadata.
Keep in mind ffmpeg works best with large amounts of memory and I wouldn't try to do anything significant with it on a shared host or even a cheap VPS. My current ffmpeg projects involve dedicated server hardware if my budget didn't allow for that I think I would try to script something that works with youtube (which uses ffmpeg behind the scenes).
Another option is to tag it as [QUESTION] or something (maybe come up with some other ones too, like FEEDBACK when looking for a review, etc. And then just filter on them.
oh, and maybe [HHVMvsPHPNG-CircleJerk]
I have a site that does this. Here's the short version: * Dropzone for file uploads * ffmpeg to create several screenshots; one full size (for the "poster", i.e. what is shown before someone presses play), one small (for thumbnails) * ffmpeg to convert to mp4 if needed It can also attempt to shrink the size of the video, also through ffmpeg.
Or use a queue manager to do the processing.
Sorry, I should say the original developer has abandoned it. It's stuck in open source limbo like most other projects without a strong maintainer.
Ah no, don't do the processing while the user is waiting for the page to come back. Queue the job up, and let the user know immediately that it is being done. 
&gt; I think it is a bit ridiculous to shuffle support questions off to another subreddit. Is it really that difficult for people to tell from a headline what threads are most likely someone asking for help vs. information about php? You seem to be in the minority. I've found that most people don't like to shit where they eat and would rather ask their support questions in a place designated for them, if such a place exists. Sure enough, nearly every time I've reminded a poster that they are posting in the wrong subreddit, they've been apologetic and they usually quickly delete their post. The subreddit system is designed to create niches. To toss it back to you, is it really that difficult to subscribe to /r/phphelp if you find yourself enjoying answering random PHP support questions? 
Yes you can send additional data. Just consult the [resumablejs site](http://resumablejs.com/). Upload times are pretty good. It obviously depends on the size of the video but the nice thing about resumable is you could put up a progress bar to show how much has been uploaded. Here are some of the steps we use (I've simplified it a ton and removed a lot of the Amazon services we use for this): 1. User uploads using resumable or some other javascript based uploading lib. This breaks a video up into 1M chunks and sends those to the server. 2. Server receives each chunk and checks to see if it has all the chunks necessary to reassemble the file. 3. Once the server has all the chunks it cats the file together. We also upload it to S3 but you could just move it to some common area. 4. After the file is moved to a common location the server puts a transcode job into work queue. The web servers' work is now done. 5. A worker process monitors the queue and picks up the transcode jobs. It goes and finds the file to work on and transcodes it. When it finishes it moves the transcoded file to another common location and writes to the database. Our processing times depend heavily on the size of the video. We do have some autoscaling in place so that if the queue starts to fill up more transcode workers are spun up. The nice thing about having the queue is we can easily scale it horizontally. Our old transcode system could efficiently handle about 4 simultaneous transcodes per machine. That would max the CPU though so if you are trying to do other work on that machine it's not ideal. I should stipulate that we don't actually use a queue we use SWF from Amazon and have several workers each with their own EC2 instance to do things like transcoding, transcoding differently if the first transcode fails, writing to the database, and a few other tasks we need. This enables us to spot bottle necks and spin up servers to address just the bottle neck.
The problem is with really low effort questions (which are 90% of the questions here unfortunately). Questions like how easy is PHP, how should one start with PHP, what is $_GET etc. Things like these should be removed like OP said. That said, most of this could be solved with a proper sidebar: links to beginner resources, links to intermediate resources etc. If we had a sidebar like /r/ruby does, low effort questions could be removed without remorse. 
I would suggest clarifying that Smarty does not do auto-escaping by default (it can be [turned on](http://www.smarty.net/docs/en/variable.escape.html.tpl)). To me, this is a major downside to using (or even recommending it). Secure-by-default should be the standard (which both twig and mustache, the other two that are cited, do).
Beautiful, thank you.
I'll bet 0.001BTC
How does it handle orphaned data? I've got to assume at least once every now and then someone starts uploading something, then it messes up and they either never try again or they do something that causes it to create a new instance. Do you just do something like run a clean up script every 24 hours that looks for exactly that? I really like your approach though. I think setting up a que system of our own will be the biggest task of this project. I don't think we'll be using AWS, I think it'll be completely internal so that'll give us the most options to scale and retain direct control over everything.
Twig and smarty don't fill any void. They just attempt to convince people they need an extra layer of complexity for no good reason. Also, fix your anchor tags guys. There are a few links in there that just don't work because someone thinks foo_bar_baz is the same as foo-bar-baz.
I wish there was a standard way to report spammer douchenozzles like these straight to the upstream site and have them nuke the account there as punishment. Maybe they'd think twice if there was any risk to something they're invested in.
Yeah, Facebook would have been so much more successful if they didn't use PHP. I guess that PHP didn't help them much with their current 192 Billion with a B Market Cap #hatersgonnahate
 &lt;?php echo htmlspecialchars($user-&gt;getAddress()-&gt;getCity(), ENT_QUOTES, 'UTF-8') ?&gt; vs {{ user.address.city }}
[Template inheritance](http://twig.sensiolabs.org/doc/templates.html#template-inheritance) alone is enough reason to use it.
&gt; Twig ~~and smarty~~ don't fill any void. To an experienced developer, who understands XSS and how to defend against it, you're right. It value-adds little. Because you're going to build a wrapper function around `htmlspecialchars`. And you're going to use it everywhere, because you know the dangers of XSS. So the value add to you is trivially small. To even a mid-tier developer, the value-add is small. It gives them one less thing to worry about, but they understand the reasons. They just may not always remember to add the escaping functions to every context... To a junior developer, the value add is **massive**. They are not likely to understand XSS, and even if they do they aren't likely to appreciate it enough to be vigilant. And that's where auto-escaping alone will benefit massively (yet alone readability, etc). 
Second this. I wasn't a template enthousiast before I found out about template inheritance.
If 'The Right Way' is really supposed to be about best practices, then I think a few words might be needed about 'logicless' templates - you mention Mustache in the context of sharing, but really its more defining feature is how it prevents cluttering your templates with non-view logic. Separation of concerns is the main point. Even when choosing PHP templates, the same discipline should be observed. I'm also not sure about the suggestion that 'templates' are commonly referred to as 'views'. In most implementations, view *classes* (or view-models, like with Mustache) can *use* template files, or not. And the V of MVC might not use either (JSON, DOM-generated XML, etc). Edit: MVC on the web is still a really broken model ... server-side, anyways. 
Nevertheless would you still recommend Smarty? If not what would you recommend?
I don't get how people incessantly bitch that php is too easy to learn/mess up, yet we keep giving juniors more and more abstracted frameworks and tools - and that is generally considered a good thing. Make up your minds people, you can't have it both ways. 
Most new redditors comment before posting.
As he mentioned :P mustache and twig. 
Or you could just abstract it like any sane person would do.
Smarty is a bloated pile of bloat. Twig is my go to and if not already, rapidly becoming the most popular.
The more logical solution is to stop hiring bad programmers who can't understand such basic concepts. I don't know about you, but if a web dev walked through my door and couldn't explain XSS (and how to logically deal with it) to me the interview would probably end in rejection right there.
Yes, this doesn't follow the normal project workflow. This tool is built to get an overview of big existing projects (like Drupal).
As a side-note, here's a random example from the monolithic old skool phpMyAdmin code, which still makes me cry despite recent efforts to clean it all up: https://github.com/phpmyadmin/phpmyadmin/blob/master/libraries/Menu.class.php So, a class with a description: "Generates and renders the top menu". OK, so we must be dealing with view logic here. Scan through and what do we find: some methods that build raw SQL queries. Hmm. Other methods that hand-build html fragments. Right ... but at least now it's view-related stuff, even if the approach is a mess. Er, but scan some more, and we fined methods that query $_REQUEST, not to mention $GLOBALS. So now we have MVC all in one class ... So maybe a templating language would have helped here. But probaby not, if the basic understanding of best practices about separation of concerns is just not there. There's little point using over-engineered templating languages if you're just going to then fill your templates with database calls and cookie checks. This should be the take-home message of The Right Way, IMHO. 
"IE how I hate you"
I've recently seen several accounts that were created, posted one link to poorly-written blogspam, and were never heard from again. Obviously I judged too hastily. I apologize for the unhelpful welcome.
How does a templating system know the context you want to escape in? Is assuming utf8 HTML safer than forcing the user to escape for the right context? Eg HTML attribute, script or style tag content. Almost feels like PHP's magic quotes (but obviously not as bad).
It might be difficult for you to understand, since it seems you exited the womb talking about web dev best practices, but parent was talking about **junior** developers. Is the concept really that alien to you?
Codeception FTW! I've managed very easy to configure it with Selenium and run tests in Firefox, Chrome and PhantomJS.
Codeception misses the point of having the ubiquitous language of your application language in tests readable by non-tech personnel, making it just like a fancy base-test-case of phpunit, for functional tests. As long as the tool you are using supports gherkin or similar syntax, then it's fine.
I use Behat daily in my work on a Symfony2 project. I have found a few times that the documentation is somewhat lacking, but have found testing with it to be surprisingly easy. I don't personally like testing with behat/selenium, but we currently have a lot of tests that way. However, we quickly came to learn that testing any functionality through the UI is a recipe for extreme pain, especially when designers make UI changes without thinking what tests could break. Use behat to test the business rules themselves outside of the web server and/or database. The tests will run fast and without fail (unless you broke your code). A bonus is that a properly written feature context makes writing new tests relatively painless.
Both Python and PHP have the language item "pow()". Go to the python website, search for pow. Do the same on php's website. Right. Python's website is a pile of shiny, over a horrendous atrocity of a manual. My point being that I sincerely do not want to see PHP.net become more like Python's. The php website is built well for its purpose - for people to have good logical access to the manual. If you want *marketing* of PHP (which you call out in a comment below), then visit Zend.com. It has exactly what you ask for - white papers, success stories, an enterprise focus, all those things. Zend is the PHP company. PHP.net is for the community. You want the wrong thing at the wrong place, in my mind. But! I may be different than the community in general. Feel free to make specific suggestions, offer pull requests, etc. Nothing wrong with trying to make things better.
http://imgur.com/RjEUHRJ Symfony has officially gone off in its own direction. The "culture" surrounding it is unabashedly hooked on ~~using~~ abusing annotations, and each library has its own annotation conventions and syntax to learn. What PHP has gained in code interoperability, Symfony is stripping away in developer interoperability. Symfony and its satellite libraries have mutated into this hybrid PHP/prioprietary annotation syntax/YAML monster. Some symfony projects will be configured in YAML. Some in PHP. Some in annotations. Some in XML (shudders). It's like a minefield of inconsistency and an odd mix of different syntaxes &amp; languages.
That makes a lot if sense. I didn't even think of Zend and most likely should of. I even thought at some point of having a "try PHP" section and also show references to new users. Point them to php the right way or some decent git and composer tutorials. Something to help educate and promote. The site is amazing for developers though. 
Lmao. At least you can see their progress. 
I still float an ie-sucks.css around. 
Can this be changed to /r/learnphp? I thought that subreddit was setup for this style if questions. 
Abstract what?
So the way to teach someone to do things properly is to not expose them to it? Do you understand how stupid that is? And yes, XSS is a common enough concept that if you don't know anything about it you shouldn't be in the industry at *any level* where code is involved.
You realize smarty is faster and a smaller memory footprint than twig, yes? It has come a long way since version 2. Explain this bloat you speak of. Give examples. Just because it is the most flexible and long-living engine does not make it bloat just because you assume so. 
&gt; I'm also not sure about the suggestion that 'templates' are commonly referred to as 'views'. Agreed - it's misleading to say templates are often referred to as views for the same reason I wouldn't say functions are often referred to as methods. Also like that you mention having view classes (or view-models) set up separately would be a good point to cover, especially as it would make it more clear just where those templates are loading their data from. &gt; MVC on the web is still a really broken model ... server-side, anyways. MVC's one of the worst patterns when trying to implement it perfectly. If you're satisfied with being a bit pragmatic from time to time, it's excellent. Every single talented dev I know working on a framework/CMS always describes their product as 'mvc-ish', 'mostly-mvc', or 'comes close to being mvc'. In practice these tend to lean a bit more to the MVVM side. That said, maybe I just have become cynical in my old age, but so long as the code I inherit doesn't just cram everything into some giant god-model, or heaven help me, a few enormous 'helper's, I'm happy.
use ffmpeg to process video and get screenshots for thumbnails, use redis with phpredis to put the video processing jobs in a queue. Make sure to set your PHP settings pretty high for the uploads. Setting up FFMPEG in Debian https://github.com/charleshross/soarin/wiki/Setup-FFMPEG
Yes, add my "vote" (such as it is) for Two Step View instead of including header/footer.
&gt; MVC on the web is still a really broken model ... server-side, anyways. This is the part where I mention [Action-Domain-Responder](https://github.com/pmjones/mvc-refinement) as an alternative.
&gt; I'm also not sure about the suggestion that 'templates' are commonly referred to as 'views'. It's true, if only because there is a type of View called [Template View](http://martinfowler.com/eaaCatalog/templateView.html) that is commonly used in PHP land.
twig escapes html by default, but you can also configure escaping proper escaping for script content too.
Only the very foundational stuff that you don't really interact with directly in Laravel. Symfony framework is its own monster built on top of those same core components. Drupal 8 is also built on those components, but Drupal 8 is nothing like Symfony as a framework, or Laravel as a framework. Laravel fully abstracts away interaction with its underlying Symfony components, and unless you're willing to trudge through the kludgy Symfony and Doctrine documentation and deal with the clumsy API/configuration, Laravel is a better choice for 90% of projects.
I'm using Slim for my JSON speaking REST API. It works pretty well and the middle-wares features in Slim are powerful thing. Just make a one that sets the default headers you would like to have, done. The rest is simply echoing whatever you want whenever you need.
"Fuck off, Joomla" and "Done. Mike, if I have to work on another Joomla project, I'm quitting."
&gt; here's a random example from the monolithic old skool phpMyAdmin code That's probably the worst code I've ever read, that was so nicely PSR-styled and PHPDoc'd. I'm guessing the devs are probably pretty decent devs, but just ended up having to continue to build on an architecture they never thought would get as popular as it did. btw, love this function name: PMA_getHtmlTableBodyForSpecificDbOrTablePrivs($privMap, $db);
Legitimate question - why is configuration of a project and the object graph through XML so negatively viewed? Is it because of performance?
Let me put this in another context: I don't need parameterized queries because I know all about SQL injection. Even if all of your programmers know everything there is to know about XSS, they are still human, and humans make mistakes.
Cant always hire mid-senior level developers that know what XSS is
You overestimate junior level developers... Severely.
What version of behat are you using?
[Your comments are all in reference to a SINGLE bundle that isn't even included by default with the basic install of symfony2.](http://jmsyst.com/bundles/JMSDiExtraBundle) It offers customization, which shouldn't be viewed as a bad thing. They suggest doing things one way, but you don't have to follow it. You will find that annotation "abuse" in lots of places, not just symfony. I'm also curious how you think the different bundles have different annotation syntaxes... All of the ones i have seen follow the Doctrine annotation library... 
People don't like it because they view it as super complex. Which is can be. But it also adds a level of functionality that yaml and json can't offer... I kinda get why people do use it, but i definitely understand why people dont.
I'm sorry.... but the symfony documentation is no where close to as bad as you make it sound. And you can't really say if laravel will be a better project, if you have no clue what projects they are working on.
I think i read somewhere that Codeception didn't care if it was easy to read by non-tech on purpose... 
&gt; if you have no clue what projects they are working on. I can make an educated guess. There is very, VERY little that Symfony can do, that Laravel can't. Laravel doesn't really make enough assumptions to get in your way. For the vast majority of problem spaces, Laravel is a much easier to work with solution/tool than Symfony is. Though I would be curious as to what Symfony can do that Laravel straight up cant or that Laravel makes you go significantly out of your way to do. I guarantee most of whatever that list is, is going to be edge cases though. &gt; but the symfony documentation is no where close to as bad as you make it sound No, it really is pretty awful. Laravel's is incomplete, but you can learn 95% of the common stuff you do in Laravel, in about a day. I did it, and so did every other member on my open source team. It's super easy to skim the Laravel docs and both learn and reference the API. The examples are also very straight to the point. Symfony's docs are a lot like Cake's....
If you store in unix epoch, it's converted to utc automatically. But the down side is you don't get the benefit of date time object in your sql without casting. 
Mohrt, you're just bias. But I certainly do like Smarty more than Twig.
&gt; All of the ones i have seen follow the Doctrine annotation library... Look at that example page more carefully. Dot notation here, Title case here, snake_case there, whatever '%' is supposed to mean etc. That is a string-based pseudo-language unique to that library, plus whatever naming conventions it uses. THAT is what I'm referring to. 
I've updated [SpiffyApplication](https://github.com/spiffyjr/spiffy-application) to use annotated services. Sample code below: https://github.com/spiffyjr/spiffy-application/blob/develop/package/application/src/Home/IndexAction.php **EDIT** It's important to note that there will be **absolutely no performance hit** in production. A future iteration will actually generate factories which will be faster than using the array configuration with the speed benefit of using annotations. I've also updated the [Conventions &amp; Best Practices](https://github.com/spiffyjr/spiffy-framework/wiki/ConventionsBestPractices#annotations) documentation to highlight when and when not to use annotations.
Are you referring to the DependencyInjection\Configuration class? Also what's wrong with being configuration heavy and just shipping with sensible defaults? 
that's what i said. "the hack language". using hippyvm won't give you hack.
Can result in poor performance &gt;Looking at the components that make up this measurement, we discovered that the raw parsing and execution of JavaScript caused massive outliers in perceived rendering speed. In our fully client-side architecture, you don’t see anything until our JavaScript is downloaded and executed. The problem is further exacerbated if you do not have a high-specification machine or if you’re running an older browser. The bottom line is that a client-side architecture leads to slower performance because most of the code is being executed on our users’ machines rather than our own. https://blog.twitter.com/2012/improving-performance-on-twittercom
Playing Devil's advocate here: Magic quotes escapes for mysql (well, sort of, not really) by default but you can also disable it and configure escaping for other contexts too.
Could be elaborate on why you think mvc is a broken model? 
How many of you comes to reddit thinking.."Oh well, let me answer some support questions today". I know, I never do. But I answer questions now and then, when I see one in /r/php. The point being, the questions will get much wider and better exposure by being in /r/php. Even more important is the exposure and chances of peer validation of the answers for those questions. So I think it is better to do this at /r/php itself. And regarding low effort questions, if you are using php, then by definition, you are looking for low effort solutions. So it is no surprise the /r/php recieves many low effort questions. So if you are bothered by the questions, just downvote them and help them move down from the top, and in the meantime, if someone cares to answer it, then so be it.
I don't have the link but somebody said that testing tools that use "plain english" are for those that live in the world were product owners (not the testers, not the programmers) write the tests. If you need some gherkin syntax that is needs an interpreter you need to take a programmer from his job and make him/her implement that interpreter. And if you are in a company were the usual people people that write tests need to write Given I am on page / and click on "submit" than I should see "Your form has been submitted" because they are incapable of writing $I = new WebTest; $I-&gt;open('/'); $I-&gt;click("Submit"); $I-&gt;shouldSee("Your form has been submitted") I think it's safe to say you have bigger problems than not having an ubiquitous language.
It was ok to start with, dependencies injected, well commented, seemed to be alright, then just got worse and worse…. My favourite bit is https://github.com/phpmyadmin/phpmyadmin/blob/master/libraries/Menu.class.php#L219 where he includes a fucking file within his class. 
Interesting read, thanks! Hopefully this kind of discussion will have an impact. Edit: how about Receiver, Domain, Responder? :)
I don't think I can do it any better than pmjones in the article he linked above. Just to add that it's a different matter if you're using an MVC framework on the client-side too. Then you can wire things up more transparently by the MVC logic. But on the server - it really just confuses what's actually happening in the request-reponse cycle. 
Are you talking about the 3.0 docs here? http://behat.readthedocs.org/en/latest/ It's mostly because 3.0 is a bit new, and still needs some time to settle. I don't think there is a better alternative for PHP currently though.
XSL is painful. I used it on several projects during my career (loved it 10 years ago, hate it now). The problem is that it is too verbose and too strict. It provides flexibility, but 99% of projects do not need this kind of flexibility
Yeah Facebook uses PHP, and so does Wikipedia and Wordpress. According to this google search result: http://w3techs.com/technologies/details/pl-php/all/all around 82.2% of websites use PHP, which is a loads!
I think the main benefit of PHP is that it's relatively easy to learn and it's not very strict which means anyone can hack together a website using PHP. Obviously, that brings up a lot of other big problems which is why the language is always accused of being insecure, because a lot of devs don't consider security. I know PHP better than any other language but if I were to learn and use any other language instead, I would probably opt for Python, although that doesn't have foreach loops, as far as I'm aware, which is annoying when you want to get the keys of an associative array
Symfony means configuration over convention. If you're looking for less configuration, laravel might be for you
People find those docs hard to write, Everzet is trying to get behat.org revamped but there are some roadblocks.
Can you expand on where the pain points in Behat are for you? I've not found myself consulting the docs too much, maybe there's something I can help with?
Symfony2 has very little convention, it's all explicit configuration inside the space controlled by the end user. It's so fundamental to the design philosophy it'd be hard to change now.
That's why PHP needs a dictator. So I'll volonteer and my final decision is PHP6.
Why not mix the two? Whenever My navigation part of the layout becomes too large to fit on screen I always move it to a separate file that is included in the layout.
The right way? PHP has a built in templating engine, why anyone would need anything else makes no sense.
Bias is a noun.
Thank you for the way you've phrased this. Too often I see "PHP already *is* a templating language" used as some sort of justification for not using any sort of template object to manage separation of concerns, rather than merely a choice of preferred syntax. It's an egregious derp that comes up in /r/php pretty routinely. The decision to use a plain PHP templating library like Plates is a totally reasonable one. The decision to not use one at all and just dump values out is very much not.
There is more than one way to structure an app. Client side templating is not always, I would argue rarely, necessary.
I used to use a template class I carried with me for years. Then I found an inheriting template system (Blade) and felt like such a fool. So much less verbose, so much easier.
&gt; How many of you comes to reddit thinking.."Oh well, let me answer some support questions today". No, but I quite often will answer support questions if the answer is readily apparent and the question isn't absurd.
Comments being executed as functioning code make me filled with horror and sadness. I just don't get why this is a thing. A comment is a comment. The idea that a comment is just a comment except for this special kind of comment which totally does a whole bunch of stuff... Just no, thank you.
While maybe not quite as polished, inheritance can be done with plain PHP templates as well. See [Plates](http://platesphp.com/templates/inheritance/).
It's a comment only because PHP lacks any sort of built-in annotation support. Java, .net, c#, and even [Ruby Annotations](http://martinfowler.com/bliki/RubyAnnotations.html) exist for good reason. Maybe someday PHP will have core support for annotations but until then we'll have to use "comments".
XML shouldn't be abolished, because it solves some problems that JSON can't solve. The classic example: &lt;story&gt; &lt;character type="good"&gt;Red Riding Hood&lt;/character&gt; lived in the &lt;location&gt;deep woods&lt;/location&gt; with her &lt;character type="good"&gt;grandmother&lt;/character&gt;. She was hated by the &lt;character type="bad"&gt;Big Bad Wold&lt;/character&gt;. &lt;/story&gt; XML was created to mark-up "narrative" documents in customizable and extensible ways. It does this very well--much better than any alternative. The problem is that XML was a hammer, and everything became a nail. Encoding narratives in XML is a great idea. Storing program configuration in XML is pure stupid. 
You should avoid injecting the container by [registering your controllers as services](http://symfony.com/doc/current/cookbook/controller/service.html) and injecting only what you need. Restrictions tend to encourage cleaner code and this one has been very helpful. Generally I've found configuring everything (routes, templating, caching, entities, DI, serialization, validation, etc.) with annotations is more trouble than the convenience it adds. It also leads to quite a messy code base where everything is mixed together. All of this can be done externally from the PHP code in a much simpler and more focused way. For example the `routing.yml` only configures the bundle routes, `controllers.yml` for the controllers, etc. What you're left with at the end is separated concerns and a plain old PHP class.
I do that as well. My goal with these examples was to keep them very simple and understandable. Maybe some more complete examples on a separate page might make sense (as gearOsh is suggesting).
Not to derail the thread too much, but "action" is derived from both "controller action" and "form action=...". I considered "receiver" along with lots of other words and none of them carry the quite same connotations. 
This is how you configure services and reference parameters whether you configure them using annotations or using YAML configuration files. This is very well documented in the [Services section of Symfony2's documentation](http://symfony.com/doc/current/book/service_container.html) The rest here is just Doctrine annotations I've heard the same type of arguments from junior devs at work. All it boiled down to was "It looks hard to learn." However, I do not think annotations is the way to go to configure dependencies. You are better off registering your controller as a service.
There are only 4 *real* scopes to worry about: 1. HTML This is the 99% case 2. **Unquoted** attribute This happens from time to time, but shouldn't (meaning that the developer should **always** quote just by practice). 3. Script Tags You should be aware you're outputting within script tags. And it's up to you to understand that. It would be interesting if Twig could auto-detect that, and require a different syntax (so that at least it forces the developer to think, if it couldn't do auto-escaping)... 4. Style Tags Same thing above. I'd argue that putting input into script tags is rare (but it happens). And putting into style tags is even more rare. And unquoted attributes are easy enough to avoid. So the 99% case is HTML. And that's covered by Twig/Mustache. It's not a replacement for thinking, but I'd rather have the 99% case done for me, so I can just worry about the 1%. Rather than having to worry about everything...
Oh, I'm not saying not to mention Smarty. I don't recommend it, but it's a popular tool, so feel free to mention it. And since Smarty *can* auto-escape, if you mention Smarty at all, I think you should mention that you should turn it on. And I don't think there's any "the right way". I think there are ways that are better than others, but every way has advantages and disadvantages. I think as long as we openly discuss them (both advantages and disadvantages), then it doesn't really matter...
Maybe so but that is irrelevant. This is not based on opinion, it is benchmark able. 
You two should meet. http://www.reddit.com/r/PHP/comments/2bpu4p/templating_added_to_php_the_right_way_got_feedback/cj8avg1
% and @ are the same thing they are in the service container configuration.... Dot notation is just how people name their services. You dont really seem to understand anything about whats going on here.
That's a silly argument. You *can* use PHP to write your templates, and sometimes that's the best choice, sometimes not so much. Other templating languages can provide certain benefits such as a simpler syntax, autoescaping, reusability across systems, etc. It's a trade-off and depends on the needs of the project.
&gt; as a simpler syntax Yes, because `&lt;?=$var;?&gt;` is so complicated. &gt; autoescaping A tool for designed for bad programmers. Did the mistake of magicquotes not teach this lesson perfectly? &gt; reusability across systems Yes, because native code is only able to run...... everywhere. Whereas templated code using smarty is only available where smarty is used. You're not too persuasive. 
For the 99% use case auto escaping definitely makes sense. I can't help but feel that that's what the PHP developers were thinking when they decided to make magic quotes the default. The stripslashes/addslashes dance we had to do years ago due to this isn't fun (and still exists in WordPress due to taking BC to the extreme). If some component is not under your control is escaping data but you need it unescaped (whether it's magic quotes or HTML auto escaping) then you have to go through this process. Pragmatically I agree with you, and I'm glad of Twig's auto escaping. As PHP and templating languages are generally for HTML then I think my argument is moot. I've just had a look at the Twig home page and it doesn't say it's an "HTML templating engine", just a "templating engine". It would be nice if you could use Twig for all kinds of templating, with build in escaping. Eg console output (auto escape escape codes), HTML/SMTP headers.
I personally don't mind XML. You seem to be glorifying JSON though. I think I hate typing in JSON more than XML. Weird curly bracket stuff. Sensitive to trailing comma's. No comments possible. I prefer YAML over both any day of the week.
That wasn't your argument. You said that PHP is already *a* templating language and therefore nothing else makes sense. You can argue over specific features offered by other templating languages, but clearly sometimes another language is better suited for a task. Regarding your points: &gt; &lt;?= $var ?&gt; This isn't the only use case. Twig for example provides specific syntax for blocks and template inheritance. You could replicate those in PHP, but you'd lack the convenience of a dedicated syntax. &gt; autoescaping Not everyone who writes templates is a programmer. I've worked several jobs where a front-end developer needed to provide simple templates where you don't want said developer to make mistakes. Besides, even seasoned programmers make mistakes. &gt; reusability I'm thinking of use cases like using Mustache to write platform-agnostic templates which are sometimes rendered on the client side and sometimes on the server.
We're still using version 2. Not sure how stable is 3 since there's no mention of it on the official site. Similarly, it isn't clear how tools like Mink work with version 3.
I've looked at phpspec before, but it seems like they follow the same recipe: sparse documentation with really trivial examples. Looks nice, though.
Version 2.
Well, a recent issue was integrating PhantomJs. But basically everything that was a bit harder than trivial was a pain. The fact that there's almost no documentation meant that we had to constantly read the source or even the issue tracker. Mink's API also somewhat resembles Goutte so we kept finding out the differences the hard way. 
I'm not particularly fond of testing with Behat either, but we have a lot of legacy apps that require some sort of acceptance testing. Pure Selenium is a nightmare, so we found that using Behat somewhat eased the testing process for our QA people. That said, it also came with its fair share of idiosyncrasies and roadblocks. 
Codeception is fine for programmers. We have some people on our QA staff who are not programmers though, so Behat seemed like the easier road to take. In retrospect, not sure if this is true.
Mink is developed by the same guy, as far as I know they are developed in parallel.
phantomjs --webdriver=4444 and use the selenium mink driver
Why?
Do an RFC with proper annotations for PHP and try and get it through (protip: the BDFL won't let it for whatever reasons). Until then, docblock annotations are the only way to achieve this very important feature.
I think you should add a few words about [the alternative syntax](http://php.net/manual/en/control-structures.alternative-syntax.php), which shines when used in templates where knowing where your if condition ends is very valuable. Also, some words about how and why output buffering is often used in templating systems would be interesting I think.
Not everyone here speaks English as their first language. I'll criticize someone's language skills in PHP, but not their English :)
&gt; Templates are often referred to as “views”, the second component of the model–view–controller (MVC) software architecture pattern. While the statement is correct it makes my skin crawl. **Template are not views. Views are not templates.** Can we add [Trigger Warning] to PHP: The Right Way?
Nope. We say that it is really easy to teach your non-tech personal to read PHP DSL code. The rule is simple: "try mentally ignore special chars $,-,&gt;,(,) and you see human readable text": I amOnPage '/' I click 'Hello' I see 'Welcome!' How is that hard to read? By learning to read and write in PHP manner you get more benefits than drawbacks. Plus, we have option to generate all test scenarios in human readable manner (via: generate:scenarios command) so business could review them. But business is not supposed to write tests. 
Join discussion [here](https://github.com/codeguy/php-the-right-way/issues/414#issuecomment-50235293). :)
Loading all files through PHP means using a lot of server memory (actually loading the file into the PHP process before dumping it out into the browser). That's pretty inefficient - I would try like hell to find another solution which makes use of web servers' ability to serve static files much more efficiently than loading them through PHP could. That being said, if usage is low enough, you might never hit server memory limits, so it's that's potentially an acceptable trade off.
I'm not clear on if the author reduced time by only sharing HTTP connections, or if this also ran HTTP requests in parallel in addition to sharing HTTP connections. (also wondering if the author is clear on that point as well :D )
Which is something I think should never exist.
&gt; We all know what good commit messages should look like lol. Given the commits I see spread throughout open-source, I have to strongly disagree. The other possibility is that you know what a good commit message is and make a bad one, anyways. This entire thread bothers me in a very deep-seated way. It's full of people who may *say* "oh, sure, this is a bad commit", but who are simultaneously **celebrating** their shoddy work. With that comes the implicit idea that it's ok to do because everyone else does it, and you internalize the idea that it's ok to do as long as you laugh while doing so. Structurally, this is similar to threads where we joke about rape, but deny that it has any effect on our perceptions of women (although obviously this is much less serious). The older I get, the grumpier I get. By the time I'm thirty, I'm going to be constantly thumping my cane against the roof and complaining about kids on my lawn. \*sigh\*
% is for parameters, when you inject services over YAML you also use @ for services. It helps you quickly see which is which. The dot notation/snake_case for the service/param names isn't fixed, you don't have to use it like that, the creators of the framework and the libraries chose to use it for their services/params. If you don't like it like that, don't use it. It isn't a pseudo-language, because the services/params can be named HOWEVER YOU LIKE. You can still use the code the annotations describe in other frameworks, you just manually have to do what the annotations are (injecting the dependancies). This method of injection is just another way to do what symfony does. Typically the defining of the injection wouldn't even be done in the same class, but in a configuration file, so you would have to redefine it it whatever type of DI you use. As for your "Too verbose" comment in the picture, from what I can see that's just displaying a verbose way. If your injection parameters are named correctly I think the annotations library can guess what is to be injected, so you would only need `@DI\Inject()`. And if you're still not convinced... Don't use annotations. You don't have to, in any use case. There is always an alternative.
It says a few other things too, about how PHP is a templating language itself, but there are lots more useful features in other systems that build on top of that.
Good shout! Thanks.
Good grief, why register them as services? Are they generally injected into other objects on a regular basis? If not, they probably don't need to be services.
In the last 24 hours there have been 4 posts to this subreddit what is there to moderate?
I have used other languages extensively and I still think php is a good language. Every language has flaws, many popular ones doesn't have syntax or design flaws like php but they have other flaws like having to restart the server when doing something or a like. The one reason why I like php and still decided to use it for my new project is because I can lay an icredible amount of track in a small timeframe. This is exactly what I and other needs when starting a new project. I would define myself as a decent programmer with experience in several languages (Ruby, Python, Groovy, Java at the top). Actually I agree with that when you come far enough php is almost never the right tool for the job but if my project is successful I am probably just going to rewrite it in another language to get the performance. I can't think of any other language with a framework like Laravel that is so easy to start with and so easy to deploy. Rails, Django and Grails is pretty easy but they still have defects that I don't approve of. For example both Rails and Django requires a lot more configuration to get deployed well whereas Laravel is just as easy as any php project. Grails is probably the easiest to deploy but have a huge amount of pain when it comes to permgen issues. Not to talk about that you have to restart the server when you create a new domain class. When it comes to the framework, Laravel has so much built in that I need in my project it would make less sense to use anything else. That said, if Laravel didn't exist I would probably never had started my new project in php.
Totally okay. Just make a note of it in your documentation.
&gt; Is there anything wrong with re-releasing such a framework once I feel it's production ready Nope. Especially with frameworks, there are a lot of opinions about how software should be written and, most importantly, how it can be used to solve problems. Some people might not like you for not contributing to the new hotness, but that's their problem. You might even find people in a similar situation: unable or unwilling to upgrade and wanting improvements to the older version. Forking is awesome, and you should do it as much as possible. If other people fork from you, that means you're doing it right.
"update"
Thanks for the reply, and yea, I will make sure it's noted somewhere about that. That's one of the problems with the old Kohana I felt, the documentation was horrid. Gotta make sure to learn from their example and work on some docs soon!
Jokes have to have some basis. If PHP was known for enterprise apps and using shitty XML then your joke would be funny.
Also note you can't call it Kohana, since the name would be property of the creators.
Agreed. If he wants to use the name, he'll have to get their consent. If they've abandoned the project, they might be okay with it.
I used to enjoy Kohana, but it fell to the wayside. Good luck breathing life back into it!
Intellectual Property...
&gt; Would this be something that gets me either in legal trouble [...]? http://kohanaframework.org/license
That's like saying the subject line to an email or the title to a reddit post shouldn't exist.
The problem with magic_quotes/etc wasn't that they did anything automagically. It's that they did it on input. Filter-In, Escape Out. Escaping is context sensitive to the output medium that you're rendering to. Magic_quotes added database-style escaping (which didn't even work, mind you) on input, so no matter where you used the input, it was escaped for SQL (which is why you still [remnants of it](http://people.php.net/user.php?username=ajf) in HTML contexts)... The **only** reason that a component should be escaping, is that its product is HTML. It shouldn't be returning you data to be used in HTML. But if it returns a block of HTML as the result (widget or whatever), then its job is to escape the data put into that html. It's a fine line for sure. But if you're not rendering to HTML directly, you don't belong escaping data. This is why I (and many others) recommend escaping *as close as possible* to the point of output (meaning where the variable and the HTML become intermixed). Not a function call sooner, not earlier in the function, right at the point of output. That way it has no chance of messing anything else up (like magic_quotes) or you forgetting if you escaped it or not (does the output have the escaping call? No? Then it's not escaped!)...
Not sure what you mean. I would suggest talking to lawyer about that. Now IANAL, but maybe this will help. https://tldrlegal.com
Registering the controllers as services is not about injecting them into other services. That should not be done. It's about making the controller's dependencies explicit by injecting them in it's constructor and avoiding the service locator anti-pattern. This helps prevent fat controllers that abuse the container and place many responsibilities into the controller out of convenience. Each time you go for another service in the controller you have a chance to evaluate whether it is really needed or the responsibility can be better placed somewhere else. It helps to set off a code smell when you see a constructor with an excessive amount of dependencies rather than having them hidden with many calls to `ContainerInterface::get`. When treating controllers just like any other PHP class it becomes more testable and can actually be unit tested. There are benefits to edge-to-edge testing that unit tests can't offer but it tends to be more of a scapegoat for it's ok to write bad code in the controller. The overhead of registering controllers as services is minimal compared to the overhead of refactoring or modifying a messy controller with unlimited dependencies.
Just because people have bad commit messages, doesn't mean they don't know what a good one looks like. Jump off the high horse for a bit and realize that developers have bad days, and this is one way they blow off steam. We know these are bad habbits, but theres no point bitching about them after the fact. Just rebase over it and everything is ok. 
&gt; MVC on the web is still a really broken model ... server-side, anyways. May be you have a look at ADR ? https://github.com/pmjones/mvc-refinement Edit : Seems /u/pmjones already mentioned.
Ha, I'll give this a shot Seems fun!
It's already been done. Twice. And rejected or ignored. Twice. Much sadness. :-(
The moment PHP supports real annotations is the moment people will stop using this method. Until then, there's no sense in whining about this or getting all religious about it. This is the currently accepted way to accomplish annotation functionality in PHP. In a production setting, these kinds of annotations are typically read and cached, then they aren't re-parsed until you clear the cache, etc.
Sorry, thanks 
&gt;You said that PHP is already a templating language and therefore nothing else makes sense. No, all other "templating systems" add complexity without solving anything that PHP doesn't already do implicitly. &gt;Not everyone who writes templates is a programmer. Then they shouldn't be writing anything that is going to be executed. They should write the HTML, then a programmer should integrated their HTML. End of story. &gt; Besides, even seasoned programmers make mistakes. Not really, no. I don't make these kinds of mistakes. &gt;platform-agnostic templates which are sometimes rendered on the client side and sometimes on the server. Oh god. You're one of those...
That add no useful features.
thanks ;) i use that SSH library for several tasks similar to this
Seems like a good idea, but for actually comparing algorithms, each player needs access to some sort of game state so they can make informed decisions. Right now, P1 is a simple RNG and P2 moves linearly. The quick'n easy fix would be to allow access to the current arena state. But the *better* fix would be allowing access to the other players' *last move*. The latter would perform much better as players can keep an internal state however they like and avoid traversing the entire tree on every move.
I agree with you that controllers shouldn't be too fat and shouldn't do too much but are you really unit testing your controllers? To me the controller should really be the only thing that is specific to the framework you're working in. A lot of the code in your bundles can be moved to a "Component" just like symfony does, your models your interfaces etc. You define your services in YAML/XML whatever (except annotations...), and use the DI system provided by that framework to wire it together. Your controller just accesses these services and sends it to a view. Your controller code shouldn't really do all that much aside from dispatching events and maybe logic based on the request (is it a POST? Then validate the form not just create it..). You should unit test these standalone services and functional test your controllers if you really want to. Injecting the container in your controllers actually has an advantage in that it lazy loads the services that you need. If you always inject the mailer service in your controller and it's not used you're doing unnecessary work. Your services however should never use the container as it couples it to symfony. It's easy to make a simple controller in whatever framework you want that just talks to your other framework agnostic services, and passes it to whatever templating / view system.
Hey Cory, I'd work on [Bolt](http://bolt.cm/), which shouldn't be surpising to anyone who knows me. It works well already, but so much cool stuff can be done, still. 
Too bad I'm already working on Bolt =P
naming data set for data providers I think is a good idea provided the names are not too long. For debugging data providers you can easily comment the one that pass and run the test with the case where it fails to debug it. Thanks for all the comments.
And I bet you don't really have a year off, either? ;-)
I agree. Never really experienced any issues with learning Symfony, the documentation is really fantastic, and has had an entry or note about just about every edge case I've ever come across. Laravel feels like it's the next CodeIgniter, it's really awesome and we'll supported today, but in 5 years you'll be stuck porting a lot of really tightly coupled code. I really love that Symfony code is mostly plain PHP, with just enough additional stuff to stitch it all together (really just the DI and routing) . 
It doesn't matter if comments have an actual function in any "other context." In THIS case, comments have a function as comments and/or annotations. End of story, imho. You are 100% correct that this is a big problem in PHP, so I can't debate you on that point, but it's a problem that people have built a (hopefully temporary) workaround for. EDIT: For the record, I say "religious" because any time anyone mentions PHP annotations, you can be absolutely certain that someone is going to chime in and say exactly what you did, with all the fervor of a religious apologist. It's a guarantee. We all know it's a problem. We all hate that there aren't real annotations in the language. Most of us are over the fact that we have to do something wonky to achieve annotation functionality...at least for now.
The term itself could possibly be trademarked. They may or may not have registered the mark. It is also possible the mark was registered at one point but is now abandoned. Regardless of whether the name is legally protected, using the old name without permission is unethical and could complicate your efforts if you ever want to protect your project with a trademark.
IANAL either, but as I understand it, in laymans terms, if you fork a BSD project, keep all the copyrights in place. You can change the other text in the license to be more specific to your company/project. If you change a file, you change the copyright notice at the top from: &gt; Copyright © 2007–2014 Kohana Team. All rights reserved. to &gt; Copyright © 2007–2014 Kohana Team, Your Q. Name. All rights reserved. New files your project produces: &gt; Copyright © 2007–2014 Your Q. Name. All rights reserved. https://tldrlegal.com/license/bsd-3-clause-license-(revised) Note: Based on that link, it seems that only the copyright has to remain, but the verbiage in the license makes it seem like the Kohana trademark "condition" might have to be retained as well, or at least updated to include Kohana and your own company/project. Personally, I'd keep all references to Kohana and add references to your company/project, just to be safe. As always, a real lawyer can tell you for sure.
??? Symfony2 is hard to learn? In what way?
So a gherkin tool is the only valid way to write tests? That's an interesting perspective.
There are a couple things people against DocBlock annotations fail to process. The very existence and standard of tags in a DocBlock is to allow parsers to interpret metadata. This is absolutely invaluable to automatic code documentation with a tool like phpDocumentor, mainly because PHP does not require a variable to declare a type. Nobody has a problem with @param int $count in a DocBlock, but use @Column(name="count", type="integer") and people lose their damn mind. When you write types out in your DocBlock, your IDE (if it's not terrible) will use that to autocomplete code. That's 2 extremely common and useful examples of "comments" having a function in day to day coding, and it's not even the code people like you are thinking about when you sweepingly declare that it's evil. It's not an ideal way for a language to do annotations, but it's the only way to do it in a non-convoluted way like having an entity in PHP and metadata defined in an XML file that lives somewhere else in the project.
i second this. non technical people should only write requirements, that technical people then can use to translate into test cases.
if I had a year off, with money not a problem, i'd spend it away from tech, and all of it with my wife and daughter, and working on my fitness.
Thank you for mentioning BEAR.Sunday.
Nothing wrong, go right ahead. Just bear in mind: don't remove other people's copyright notices, and watch out for registered trade marks (Kohana?) which you may need to change, or get permission to use. 
Id starting from scratch, that's all good advice. I think the OP is more in a situation where he is trying to extend support for legacy projects a little longer, and to share the updates that have been done, and maybe provide a path towards the kind of framework you describe. 
Sometimes it's not possible to verify the controller behaves correctly from the Response alone. Such as creating a job with the correct values. From a UI perspective the Response can be "successful" but did it actually do what it was supposed to? This is easier to verify with lower-level testing. So it's on an as needed basis but not the main goal with injecting the dependencies. If a dependency is not always needed is it really a dependency or should the controller be split to become more cohesive? The case of only needing the `Repository` on valid form submission is one thing, but using 10 dependencies or more just because they're not always instantiated is another. [Lazy services](http://symfony.com/doc/current/components/dependency_injection/lazy_services.html) seems like it may offer a middle-ground between using the container and being forced to instantiate all the services up-front. Why loosen up the restrictions that apply to other classes when it comes to controllers? Why should it be a Symfony controller when all it's doing it looking up some data in a `UserProvider` based on some parameters and returning a JSON response for example. I'm all for adjusting restrictions when they become a hinderance but have not found this to be the case. In theory my controllers contain no coupling to Symfony but in reality that's really not true. I could got a step further and depend on my own `TemplatingInterface` and `UrlGeneratorInterface` but it's really not what I'm looking to do by injecting the dependencies. It's all about having limitations and being explicit in the constructor about what you need. If the container is injected every controller has access to your entire application (which is way more than it needs) and developers will and do abuse it and I'm one of them who has.
Aha! A clever plan for self promotion!
Well, sort of.. I'm working on it now, but I would also work on it, if I had a year off. :-)
I would love to clean up the codebase for Wordpress. It's such a great CMS/blogging platform but every time I delve into the code it's like trying to navigate a labyrinth. I'd love to essentially fork it and keep the front end exactly the same but rewrite the entire code base into something object oriented and well structured
Yeah, whenever I tried kohana years back, that was always the reason I didn't stick with it. I think I even saw on here some of the devs saying "the docs are loads better now, honestly, try it again!". So I did, and they weren't. Shame really. Although personally I feel that even laravel's docs aren't as good as the old CodeIgniter docs. CodeIgniter as a framework might be awful and out of date, but I still think some of the new frameworks could learn something from its documentation.
you wouldn't be able to get a single patch merged to WP as the core team think change is literally worse than hitler.
Really cheap 3D laser type navigation tools for robots. The idea is to get it well under $100. Yet useful for even a self driving car. 
Please don't tell me your wife and daughter are open source projects.
You just need a simple "ticket_read_by" table to store each user that has read the ticket. Left join to that table and if it is NULL then the user hasn't read it yet.
The problem is that PHP has so many crappy tools that beginner users/companies use, like wordpress, drupal and joomla. When so much crappy code is written with theese technologies its a fact that people will complain. You can write good code in PHP but it takes more practice, and as with all languages code design. People using drupal and clicking away in the cms backend usually have zero knowledge of anu design at all, they just click and install very poor quality contrib modules and have their fingers crossed and wish the module works, then ship this nightmare of a product to a paying customer. This goes on and on, year after year.
If you want something a bit more comprehensive, I've found http://boundary.com/ to be pretty awesome.
I'd release it myself and call it BlurdGress
Good point! But think of the satisfaction afterwards! Also I just kinda think WordPress is the single biggest reason that there are so many PHP developers who write bad code because they learned by making WordPress plugins and stuff
hahaha
I agree with the agency thing, ive been there and done that. Agencies use these crappy old cms systems (wp had php4 support untill recently) and drupal 5.2. Dont know about joomla. This is a big problem for the wider PHP community, when agencies are mostly run by business personell who have zero tech talent, and dont want to innovate at all if the money keeps on coming. So the use of these crappy tools will continue, and the worst part is that developers lock themselves to these products. Therse very little intresting stuff beeing built with PHP theese days, and thats a big shame.
Yeah this, you might even want to have a 'read_at' column in there and log the time so if you wanted to have a 'last read at' output either now or in the future you already have that data
Meanwhile at the agency. - Dev: Heard about PHP6/7 And all the cool new frameworks? - Manager: were sticking with Drupal and PHP 5.2. - Dev: goes to /user and continues clicking.
Came here to say this. I live and breath WordPress, and I have so many ideas on how to improve the CMS, but my time for projects like that are very limited. That being said, I'm trying to at least help with bug tracking/fixing.
If it goes to vote again, i dont think anyone voting PHP7 will change their mind. Does this kinds of "problems" only occur in PHP? It all seems so childish.
You could always keep it simple have a ticket_read column and store a serialised object with all the information. Which you encode and decode at the application level 
The problem is MySQL can't parse the JSON data. It wouldn't be an issue if you wanted to list your tickets and let the application flag it is read/unread. But if you wanted to put a filter in place to view all unread tickets, you can't do it in the database.
Do you mean, complicated in Laravel? That might be true, I do not know Laravel, but generally, in raw MySQL it does not seems to be too complicated to write SELECT * FROM tickets LEFT JOIN ticket_read_by ON tickets.ticketid = ticket_read_by.ticketid WHERE... or SELECT COUNT(*) FROM tickets LEFT JOIN ticket_read_by ON tickets.ticketid = ticket_read_by.ticketid WHERE ticket_read_by.userid IS NULL AND .. 
I feel like there's three main environments where I have the best ideas and solutions to problems and none of them involve having a computer near me, so it's a real challenge to remember them. The environments are: 1. In the shower 2. In bed just as I'm about to fall asleep 3. On the toilet without my phone
Plates also supports the following alias: &lt;?=$this-&gt;e($this-&gt;var)?&gt; But yeah, the extra `this-&gt;` is a few extra characters. 
Number 2, every bloody time! Then its age old question of is it good enough to get up and write down, or do i go to sleep and forget it forever….
I'm gonna scope creep a little here. Everyone else's solution assumes that people only need to look at the ticket once, when in the real world a ticket could have multiple updates over time that everyone needs to read. Keep in mind that a ticket usually has one or more "followers", and as such each follower could be in a different state as to whether they've read the ticket or even the latest updates to the ticket. Here's how I'd solve it: Build a many to many table which includes the ticket id, the person id, and a timestamp of the person's last visit (last_seen) to that ticket. The ticket itself should have a last_updated timestamp. When it's time to get a count or a list of all the tickets the user has not read, you'll do a LEFT JOIN with the condition of the last_seen = NULL OR last_seen &lt; ticket.last_updated. 
I can offer some good advice for you. I'm a developer for the kohana project. We started 2.4 and never completed it, the goal was to backport new 3.x features. If you wanted to use this code as the basis for a framework with a new name, you absolutely can. You cannot use the kohana name or drop the kohana copyright on the files. We are BSD license and a Google search should be able to help explain what you can and can't do. Good luck! 
You've cracked it. Code naked for optimal performance
&gt; I personally don't know why XML still exists when we have json. I don't like XML for config (as you say it's overly verbose for that purpose) but equally I don't like JSON for one *very* big reason - no standard way of embedding comments! For this reason alone i'd still prefer XML of JSON for this purpose. I usually use YAML these days as it has a light-weight syntax like JSON but allows for inline documentation which is invaluable.
Places where you can think with out any distractions. I keep a wet erase marker with me in the shower and just write on the walls. Bed there's a notebook. For the toilet, I usually just try to finish really quickly when an idea strikes me...
&gt; It's about making the controller's dependencies explicit by injecting them in it's constructor and avoiding the service locator anti-pattern. I get that much, but that does not (or should not) require registering the Controller as a service in the DI container. Are you saying the only way to make sure the Symfony DI container injects dependencies into a Controller is to register that Controller as a service?
I always choose sleep :&lt;
Pantsless driven development. I coined the term, now pay me money. 
Puff Daddy likes this.
It's the only other way I'm aware of in Symfony other than using the [JMSDIExtraBundle](https://github.com/schmittjoh/JMSDiExtraBundle) covered in the article. Once the controller is registered as a service you can point your routes to the `{service_id}:{action}`.
&gt; Nobody has a problem with @param int $count in a DocBlock, but use @Column(name="count", type="integer") and people lose their damn mind. It's because @param isn't intended to influence the actual running or behavior of the application, only the development process. 
Maybe I'm not getting the benefits of annotations over, say, a naming and behavior convention. Having a service called "DemoService" live in, say, /services in a project, then being able to say something like &lt;?php class myController { public $demoService; public function __construct() { } // etc } ?&gt; then have the service object automatically created and injected on to the controller class before use by default makes some sense to me, and avoids the annotation stuff. It's what some other frameworks do (not in PHP, of course), and I like it. The annotation stuff (and also a lot of the configuration stuff in PHP frameworks) seems to often be so much boilerplate/repetitive stuff that would be solved by enforcing stronger conventions in a framework. But... maybe I'm missing something obvious to everyone else?
I guess that's the crux of my point. If the container cannot create an instance other than *as a service* that seems a weak point to me. As the author of [Aura.Di](https://github.com/auraphp/Aura.Di) I am clearly biased, but I was honestly unaware of this limitation in Symfony until now (if indeed it is a limitation). With Aura you can create a "lazy new" instantiator and drop it into anything else that uses a callable; this is how we register Controllers (or Actions) with an independent [dispatcher](https://github.com/auraphp/Aura.Dispatcher) system.
I'm not arguing for two different DI systems; I'm saying that if the container cannot instantiate-and-return a new instance, without having to name a service, that sounds like a missing feature to me. But again, I am biased as the author of [Aura.Di](https://github.com/auraphp/Aura.Di).
Not at all. First off, a more accurate comparison would be posts or emails with no body (commit messages in git were designed specifically to be translated to full emails). Secondly, those are entirely different contexts - a meme pic is quite appropriate on /r/pics, but not in an official company email (for most companies).
Man the typos on that webpage are brutal. | domanite | puting warriors | There is to situations etc.
Annotations are only meant to aid the development process as well. You can just as easily put the configuration in array, xml, yaml, json, etc. In production the annotations are never even read or read once and not read again depending on the implementation.
Thanks for your input! Hopefully you guys get around to finishing 2.4 :p I'll give it a search.
I'm not sure I understand what the implied limitation is. Registering as a service just means defining in the container how to create an instance of this class if it's requested which in the case of a controller happens upon successfully matching the route and only then. Looking at the Aura.Di documentation and `lazyNew`, it seems to be the equivalent of the default behaviour for the symfony container's service definitions. All services are lazy and only created upon being requested. You can even go a step further and mark a service as `lazy` so when it is requested from the container (directly or as a required argument to another service, etc.) it will return a proxy and not actually instantiate the service until a method is called on the class.
&gt; requires lots of reflection which is never going to be very performant without a compiler to generate classes for you. I guess I'm a simpler sort of guy, but I'd think basing things on the names of the files - $demoService and /services/DemoService.php - wouldn't be that much of a performance hit. Having to annotate an injectable component, then also annotate the injection target - it simply feels like a lot of work for... not necessarily a whole lot of benefit (relative to the typing and thinking involved). It works, of course - you're using it - but I'd somehow like to see a project take a more convention-based approach - this annotation stuff still feels like a lot of configuration to me.
Well, they're supposed to feel like configuration. Configuration empowers choice and hard conventions remove choice. Forcing conventions that strong on users gives them zero choice to diverge outside the lines. I don't want my framework to enslave the users. I want it to free them.
I'd love to do something like this too but would the core developers allow it? Why don't we create a parallel version of Wordpress that will always work with the latest wordpress plugins and themes?
&gt; Registering as a service just means defining in the container how to create an instance of this class if it's requested That's exactly what I'm saying -- there should be no need to *register as a service* if you only ever need one new instance of it just once. Services are for sharing and reuse and injection into other objects. But maybe that's just me.
There's also the "I can't wait to finish implementing this..." part of life...
Don't take it specifically at your code - it's more an issue I have with almost any PHP framework, and it's partially due to the language - I do a lot of Grails, and there's generally so much less ceremony in the code because it's a different kettle of fish. Coming back to PHP to do projects, I'm just overwhelmed with the boilerplate I need to do to set up basic stuff that... 99% of the time - I just want 'standard' behavior. For many many many developers, the ability for them to 'configure' things however they want really is a bad idea, because they really don't understand the basics, but somehow manage to make things work. There do not seem to be any frameworks aimed at that market. :( 
I knew there was a reason my code got worse once I started needing to go into the office again...
PR and fix it?
Have you taken a look at the JSON REST API in the works? Its restored my faith in the WP platform. There are still some gaping issues I'd like to see fixed, but I'm glad to see things moving forward.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
I think there is a slight misconception here, controllers are framework depended classes (at least within the context of any normal Symfony set up) and services are not. Instead, services are supposed to be as POPO as possible. If your controller class extends from a framework class it basically doesn't matter if your using DI or make the container available to the controller. Another way of looking at it is, how reusable is your controller going to be? Normally a controller only makes sense within the context of a specific application and therefore it doesn't matter that it knows about the container. However, having said that, I personally prefer to register my controllers are services and explicitly inject whatever they require for clarity. 
Don't worry, just review your code a few months from now and you'll feel like an idiot again.
I definitely work better without shoes on, but co workers might not appreciate me relaxing in my underwear while coding 
Some of those frameworks still exist. Yii, for example, and I believe CodeIgniter as well.
I agree that it should be rewritten with a pretty simple MVC codebase. After all, a benefit of WordPress is that a lot of people with little experience can write plugins for it, if the codebase had the complexity of, say, Symfony 2, it would probably scare a lot of people off. Not sure about Codeigniter though, I mean I've never used it but isn't it EOL'd?
So, what were the tricky situations and how did you solve them?
I don't totally understand the discussion to be honest. To me anything that needs to be constructed in a particular way must be created by a service manager (DIC or service locator) and as such I call it a service. I tend to just use silex for most things where everything just goes in the container and there really isn't any framework magic to speak of. Controllers are just plain objects with no base class when using the controller provider.
That's the thing, I doubt anything is going to change until someone comes along and develops software that ensures backwards compatibility.
It'll never be finished, the devs who wanted to finish it were doing so for the benefit of jobs they had at the time using it, they have since moved onto kohana 3.x related jobs and now solely contribute to that branch 
I want a job where I can go to sleep while doing a number 2
Relevant Feynman quote on confusion: http://youtu.be/lytxafTXg6c
I would like to work on Moodle. I believe that the codebase is not even using a framework right now, so it would be cool to work on that.
~~redacted~~
You, sir, are the only genius in this thread.
"Did I really write that? What was I thinking?" 
Closing ?&gt; php tags are not required. In fact, it is often [recommended not to](http://stackoverflow.com/questions/4410704/why-would-one-omit-the-close-tag/4499749#4499749).
I know a startup that is based around using this &amp; they've mentioned that the core team doesn't play very well with others.
M'kay. Why not use a complete [parser](https://github.com/nikic/PHP-Parser) and generate whatever you want from that? 
That's awesome - usually the solutions come to you at the least expected times while *away* from the computer
All I need is *something* to run a script when an email arrives. Your method could work. I'm also researching it at the moment figuring out whether the standard free version would be enough to do that task. Do you know if it requires a live email account? edit: seems like it [could work](http://www.mailenable.com/kb/Content/Article.asp?ID=ME020028&amp;SS=).. 
Yep, after bandcamp.com throttled connections in part because of my site bandcampdownload.com (since taken down) I came up with decent way of [threading downloads with curl](https://gist.github.com/MattSandy/1113347a896cb3b6b0a0) to speed things back. 
I had a dream once where my alarm went off, (IRL) and I was somehow able to write a program to stop time for two hours. It made perfect sense and clearly worked... Until I woke up two hours late.
I would probably write something to better peoples lives....always have all these ideas but never time to write it.
Just note that "open source" doesn't identify the license in use. There are plenty of PHP projects where the source is "open" by virtue of being PHP, but where the license specifically states it's a commercial product. cPanel is a good example of this (yes I'm aware they obfuscate their code).
A related issue is that nearly every "beginner's guide to PHP", including several of the man pages, teaches insecure code. This becomes, by default, "insecure PHP" as people learn. This doesn't mean "PHP is insecure", but can lead to a culture of insecure code among PHP devs.
And on the other side, "I wrote that?? Oh yeah! Heh, cool." 
Sure, and you can break that down even further: each ticket contains many messages, each created by one user and read/followed or not by many users, and each potentially edited by many users. So it's basically a bog-standard message thread with a fancy name and some domain-specific functions and message types (to assign, close, re-open, etc). Easy enough then to count tickets that have been updated, number of new messages in each ticket, flag edits, count messages per user across tickets, and aggregate for a quick count of tickets needing attention for each user (as per the OP's main requirement). 
http://www.phpshare.org/articles/Piping-Incoming-Mail-with-PHP
this is great!
The type that does not get extraneous white space output on the end of each included script. 
Making the world a better place :) https://www.youtube.com/watch?v=4To3elrrwdI
&gt; The idea that I have is to have a 'read_by' column. And if a user opens the ticket, it automatically add his/her ID to the column, and I'll be able to tell who has read the message. Isn't that exactly what was described?
Because it is exactly 2 years later, and it still is in alpha phase. It is a shame, FuelPHP was an easy to use framework. The first version is now horribly outdated, and I was really anticipating version two. Switched to Laravel since. 
&gt; flatly.css I will make sure I implement it as a option in my next template project!
git commit -m "previous changes done by not me." "Yeah, I'm a genius."
I may have missed something simple, but what wizardry is returning $ret in that code example for you to "Do stuff with the results" ?
Yep tried that .... but ended forgetting every insight I had :P
Mink hasn't changed at all for the new version. MinkExtension 2.0 is the version that works with Behat 3.0, and integrates Mink into the Behat setup.
Assumptions are the mother of all fuck ups.
I came up with something too this weekend and realized how absurd it could sound if I described it to the project manager: "I'm going to get it to work by making it work like it did before I broke it."
It's of medium difficulty. My first suggestion would be making your watermark transparent rather than walking through the pixels on an image to find a clear part. That being said you will need to determine the type of file, then create the image using the right type (e.g [imagecreatefrompng](http://php.net/manual/en/function.imagecreatefrompng.php) for png files) once you have a created image you can manipulate it by overlaying your watermark then saving it back to disk. Check out all the image manipulation methods here: http://php.net/manual/en/ref.image.php
[Use ImageMagick](http://php.net/manual/en/book.imagick.php) Extract each corner with cropImage, count unique colors of each corner with getImageColors. 
A simple trick is to change your watermark so that it contains both white and dark outlines (white text with a dark border or the other way around). This way it doesn't matter where the watermark is applied, it is always going to be visible. [Example](http://www.imagemagick.org/Usage/fonts/font_shadow.jpg)
Sounds like you're creating work for yourself, hah like creating bugs to fix again yourself. 
I've only had it looking back at projects I poured everything into. At college I created an animated card game (using Java Swing) in about two weeks of 12 hour days in my room being a madman. I sometimes look back at some of the crazy code I wrote to make it work and think 'if I could do that, I can do this'. 
Control structures are more like the movement of the hand rather than the screwdriver.
actually, i do not want to limit it to the corners, any help in getting to know the clear part using ImageMagick? 
 That is the exact method I use right now, I use 30 as pct via imagecopymerge, but that is giving bad results considering MEMEs have TEXT on top and bottom and are generally overlapped with my watermark which sucks
Watermarking the images is important for the project I have created and the random 4 corners is giving me bad results because MEMEs have TEXT on top and bottom and are generally overlapped with my watermark and that sucks hence I am looking for a different solution.
A big difference with PHP vs other languages like Java or RoR is that PHP is very easy to deploy anywhere on an apache server. Java requires it's own strange server, and then there is a ton of time-consuming tools that everyone thinks it's great to use all the time like Maven etc
Sorry, i dont know that much about image manipulation. What i would try is this: Divide the image horizontally in two halves, then add 20% to each rectangle. this way you have lower 60% and upper 60%. Compare their unique colors. Choose the one with fewer colors. Repeat vertically with the chosen half. Repeat, while alternating horizontal and vertical splits, until you have a box fitting your size. This is a **very** naive approach from the top of my head. Propably far from optimal.
There is an [article here about cropping images based on entropy](http://codegeekz.com/cropping-images-entrop/). That technique may be useful to find the areas of least entropy - the least "complexity" in the image - and put your copyright there. As for writing your own algorithm to count numbers of colours in areas, I suspect that may be a bit more involved than people think. I suspect you want to put the copyright where it *looks right* and that is probably better worked out with a bit of Fourier analysis, rather than counting beans and hoping there are plain enough areas to detect using that technique.
In the same vein, http://mandrill.com does 12.000 free.
If you don't mind me asking, then what is the purpose of your watermark? As I understand it, most watermarks intentionally go "over" areas of the picture so that it cannot be easily photoshopped out. If you place your watermark specifically over a portion of the image that is only one color, someone could even remove it in M$ Paint.
A good commit message is awesome and can be useful down the road, but your example isn't a commit message; it's the beginnings of an internal wiki entry.
What the fuck.
how did you do this? php is relatively simple (IMO). i come from a java/c/c++/unix server side background and found it pretty straightforward.
I'd start with PHP :) 
The position required no experience and I have programming experience but not in PHP :) 
Ask them what they spend most their time developing with... whether it's a framework, cms, vanilla... learn the basics from phptherightway.com then sandbox using whatever they develop with? You should know how to approach this if you have dev background... http://www.codecademy.com/en/tracks/php
damn. you lucked out. congrats. there are PHP resources all over the 'net. i'd focus less on the syntax and more on the stuff that's built into it that's not terribly obvious i.e. how to interact with data posted to the server from the browser etc yeah, that might be pretty basic PHP (I don't know, I'm no expert) but its not something that wasn't intuitive to me.
Yeah I've been looking at syntax and it seems *pretty* standard. I'll look into that I guess, thanks :)
I too was hired for web dev (PHP and other) with a desktop dev background. PHP is getting better at OOP with every update so I've just tried to approach it like an OO language built for the web. The first thing I'd do is skim over the manual pages to learn its capabilities and find features you might expect to work similar in Java or C# and figure out their proper use in PHP. For example, arrays are actually ordered maps with tons of built in functionality which you wouldn't expect coming from something like C++, my first language. Once you get a general idea of the risks and opportunities, I'd learn further at a pace of one project at a time. Get a task, figure out the best way to do it PHP, deposit what you learned for next time. It can seem a little chaotic at first (IMHO, I like strong static typing) but it's fun and not terribly difficult depending on what you want to accomplish.
Well, cropImage would just make it easy for you to get the corners, since you give a start and endpoint. You could just as well split the image in 9 fields, or anything you like and apply the same principals to it.
And his own images doesnt even work! I guess its a smart way to fix it, simply remove the images on your server. 
I frequently screw up my sleep schedule this way. I usually hit a difficult problem, realize I'm probably too tired, and go to bed. As soon as I hit the pillow, my mind stars going a mile a minute and I'll come up with a solution, get out of bed, and attempt to implement the solution. 
You dont have to wait until you start to ask what they use as their primary framework or model or whatever. The last job I started used Symfony and as I’d never touched it, I wrote a todo app in it before starting. Its not perfect and only really teaches you where things do and what things do, but understanding some core concepts will help you loads. I would read go through as many of the basic Nettuts tutorials, then work up from there. http://code.tutsplus.com/search?utf8=%E2%9C%93&amp;view=&amp;search%5Bkeywords%5D=php&amp;button=
Also this set of courses might be a nice gentle place to start http://code.tutsplus.com/articles/become-a-modern-php-developer-with-tuts-courses--cms-21099
the points you mentioned are the exact reason why i am looking forward for watermarking, and its okay if the image / watermark can be removed even via ms paint, but then what other solution do we have at our disposal?
I have used this snippet to find the **least** plain part of an image to crop away. Maybe you can reverse the strategy or just identify the part of the image you **don't** want to watermark: https://gist.github.com/groinkster/794289
LOL, I am also a Junior PHP developer with a Java background ( I didn't want to work for a big corporation doing Java). I took a whole summer to read [this](http://www.amazon.com/PHP-MySQL-Web-Development-Edition/dp/0672329166) and that was more than enough to get the basis of PHP. Its way easier than Java for sure. Good luck.
Was already wondering since when hotlinking became a problem again...
Thanks, do you think its worth the investment? Or should I just get it online
Yes that is true but for a long-term or semi-serious project and above that benefit in my opinion is irrelevant (unless you have a installable product you want to make it easy to install for the "users"). The benefits that some languages bring in such as static typing increase over time. Where as the "easy to deploy" benefit gets smaller and smaller over time. So if I need a webpage that shows the current date or maybe needs a few drop-downs and a HTML form, sweet I'll use PHP and throw a few tags in there to get my quick and dirty dynamic page. I wouldn't deploy a Java servlet for that. In this case I get the short-term benefit of PHP and I don't care about the long-term. But for a serious code base that is going to be maintained over the years and grow and grow I sure as hell would rather suck it up and use a safer more static language with fewer warts, and in the early days I might think "gee I sure as hell could do this in 3 minutes with PHP" but 4 years down the road you look back and think "thank god I didn't use PHP". My 2cents anyways.
so I could forward all my mail from x@gmail.com to a mailgun account and have a php script (perhaps hosted on my own server/domain) run whenever a new email is received?
If you're used to Java that means you're in pretty good stead to program PHP using OOP, which is what everyone should be writing imho. I'd warn you that the loose typing is probably most likely to confuse and frustrate you, especially as PHP handles some of this logic in a pretty weird way, i.e. ('hello' == true) and ('hello' == 0) will both return true, as in the latter instance, PHP is trying to convert the string to an integer, and not finding the string to be '1' for instance, is claiming it to be zero
http://phptherightway.com The most up-to-date resource on PHP development available at the moment!
Yeah. Exactly what I thought when I read the title. Sigh.
its hard to answer anything to that as "its not running" is kinda not a real error description most likely what you mean is "it is never called" which means your email pipie is not working - which is a very server specific problem that cannot be answered simply, my way was the one that works only for postfix, but not for other MTAs
&gt;And on the other, typing the long use statement, defining the member, adding the translator to the constructor, setting the object member in the constructor, finding the entry of instantiating the class in the DiC to include the translator as one of the parameters; Which takes, what, all of five seconds? &gt;not to mention I'm breaking backwards compatibility by modifying the constructor. That's a fair point, but you're going to have BC breaks in your code base eventually anyway (and that's where semver comes into the picture). Anyway, in this specific case you can add the dependency without breaking backwards-compatibility, assuming the translator is optional. Either you add a setTranslator() method on your object into which you inject your translator object, or you add it as an optional parameter at the end of the constructor's argument list (or both). Another option is also to subclass your class and turn it into a translator-aware version.
&gt;patterns like this tend to break it. For explicitness' sake, and to not create any confusion, the pattern SomeCollegeBro is referring to is handling translation via a global function, which makes it more difficult to unit test as compared to injecting the dependency via a setTranslator() method. 
Please, for the sake of all that is good in this world, normalize your indentations. 
I don't think this would work very well at picking the best location, as the bottom half of the image may have many different colours in it (more than the top half), but you might miss a perfect solid-colour area just because it's in the more complex half of the image. A better way would be to detect edges in the image, so you have an image that is mainly black with the edges visible in white. Then, divide the image into regions and take the average colour of each area. The darker regions have fewer edges in them, so just pick the darkest region and draw the watermark there.
yeah I figured. I'll keep playing with the piping command to make it work but wanted to make sure this code isn't blatantly wrong. It seemed a bit odd that the shebang would just be there at the top outside the php tag, as if it was just HTML
I don't know why GitHub messed the indentations. Everything's alright when the files are opened in an IDE...
This is a fantastic little project! I'd especially like to see a PHP equivalent of gofmt. The transpiler seems ambitious, but sky is the limit there, so who knows what you can do with it :)
You seem to be missing the point. Here, let me quote it for you: &gt; So when I learned Go, and I watched Rob Pike’s talk on writing the text/template lexer, I thought it would be fun to try out that language and idea on reading PHP
The reason is because you mix tabs with spaces. Settle on one format please. See this file for instance: https://github.com/angelov/eestec-platform/blob/master/app/controllers/AuthController.php
#1: there's a lot of terrible coding advice about PHP. 90% of PHP's problems with security and performance come from bad stackoverflow answers from 2005. Start here: http://www.phptherightway.com/ #2: Database abstraction layers with parameterized queries, always. PDO, OBDC, etc... Avoid using the deprecated mysql functionality (assuming the php version is 5.3 or less). #3: Don't make PHP into something it's not. It's a great language for web apps, not necessarily for multicore processes juggling separate threads. 
This shit is one of the biggest things that bugs me about Reddit. We're supposed to upvote comments that move the conversation forward, and downvote those that contribute nothing to the conversation. And *this* is top comment. Within the conversation that OP intended to start, how the fuck does this contribute anything at all? Great contribution to entry leve PHP advice. Your "What the fuck." comment probably provided everyone who is interested in this with so much insight.
Traits too! Make a `TranslatorAware` trait, and now having a getter/setter is as easy as `use TranslatorAware`.
Bro, get a proper IDE. It'll save you a lot of time. &gt;including finding out the exact namespace for the translator This can automatically be resolved by an IDE without you having to look up the namespace. &gt;break the now too long parameter list into multiple lines to adhere to PSR-2 IDEs normally come with code style formatters. &gt;reloading the browser and getting an error due to forgetting something The auto-completion and type hinting will help that. &gt;Also, I am using PHP 5.3, so without traits, TranslatorAware as only an interface will make the whole think take even longer. Implementing an interface is usually just a right-click away in most IDEs. 
As someone who is desperate to find entry level work, but is getting turned down because I lack 3 or more years of on-site experience, I agree... what the fuck??
&gt; 3: Don't make PHP into something it's not. It's a great language for web apps, not necessarily for multicore processes juggling separate threads. I beg to differ. I made a nice living off of doing just that for 3.5 years. The trick is how you manage those threads. Me, I built a system (useful for the requirements in front of me) that didn't need to worry about inter-thread messaging in order to get anything done. 
I guess you are looking in the wrong fucking place. Possibly *that* is the fuck? 
Have you made web applications before? If not, you may want to spend some time learning the HTTP response codes, encryption and common attacks, etc. The design patterns and syntax are similar enough that the language itself may not be your biggest challenge. As linked above, PHP The Right Way is definitely a great reference. Most times googling "php *what I want to do* site:stackoverflow.com" takes ~3sec and will give you whatever obscure method you were looking for anyway. 
Do you mean setter injection using a Trait? Setter injection is for optional dependencies only, else you make it really confusing for the user of your class to know which are your required dependencies.
In your Auth Controller you do this: Session::flash('auth-error', 'Wrong email or password.'); return Redirect::back()-&gt;withInput(); Which can be simplified too return Redirect::back()-&gt;withInput()-&gt;with('auth-error', 'Wrong email or password.'); Also I'd look to remove indentations from code. I rewrote the login function in the AuthController: public function login() { if (!$this-&gt;validator-&gt;validate($this-&gt;request-&gt;all())) { return Redirect::back()-&gt;withInput()-&gt;with('auth-error', 'Please insert valid information.'); } $credentials = $this-&gt;request-&gt;only('email', 'password') $remember = ($this-&gt;request-&gt;get('remember') == 'yes'); if (!Auth::attempt($credentials, $remember)) { return Redirect::back()-&gt;withInput()-&gt;with('auth-error', 'Wrong email or password.'); } /** @var \Angelov\Eestec\Platform\Service\MembershipService $membershipService */ $membershipService = App::make('MembershipService'); if (!$membershipService-&gt;isMemberActive(Auth::user())) { return Redirect::back()-&gt;with('auth-error', 'Your membership needs to be reactivated. Have you paid the fees?'); } return Redirect::to('/'); } The main change there was changing the order of your failed log in attempt and removing the else. In your original code the else wasn't need. Also made the with('auth-error') changes. One suggestion I had here, is that you may not want to log out the user. Ideally if a user hasn't paid, you'd redirect them to a paywall but leave them logged in. This paywall would be maintained by a route filter. And since it would be handled by a route filter you'd be able to remove the $memberShipService logic out of the AuthController::login() and in to the filter. 
Why not just forget about watermarks altogether, and enjoy happier users, who may use your application a little more?
Thanks! That link is super helpful; way more in depth than previous stuff I've read on php forms.
You can do it but why wouldn't you use a language better suited for the task? When you have a hammer everything looks like a nail. 
I'm not sure what you mean by "what technology is being used" it's an HTML form, PHP driven to send the form to my email account. I figured it was assumed that I was using PHP by posting in the PHP sub? I realize that sounds snarky, but I'm not sure what other technology you're referring to.
If only there was a stash for our mind. We could apply it when we wake up. 
Its a basic image manipulation algo... You can find it everywhere on internet. Images are matrix of dot (pixels) which can conveniently view as an array. Parse that array and for each dot extrapolate the color value. If there are contiguous dots with the same color value, enough to cover your requirements (100x20), get the coordinates, with some geometry magic, and place the logo. Drawback: 1. You need to check weather you touched the edge or not. Maybe the contiguos area is part in right edge and the other part in left one. 2. Do not parse px by px. Maybe a larger area of 20x20px. 3. Put the script/routine/program in some job queue handler like gearman. 
No, sorry; I see how that was confusing! I had a similar question last week and was informed that what I wanted to do needed to be done by, basically, HTML&gt;Javascript&gt;PHP&gt;my result. I thought this might be a similar situation.
Why learn a new language when I can use what I already know? Really, the decision came down to a simplistic requirement, and a short time restraint. I wasn't about to pick up a new language just for that when the system works perfectly well. Do you approach every project with a 'what is the best language to implement this in'?
I think you need to be registered
Is it impossible to do the translations in the view? I would say it might be easier to do them in the view, instead of all over your services
Make sure you join ##php instead of #php
Should mention that this is specifically for the devosc framework, no?
If you're able to compile Imagick from source, there is a really useful function that was recently added, called [statisticImage](http://www.phpimagick.com/Imagick/statisticImage?image=Skyline&amp;statisticType=1&amp;w20=5&amp;h20=5&amp;channel=134217727) that will help you a lot. Basically it allows you to do a statistical function over the whole image. In your case you probably want to choose gradient, which will convert the areas with the highest rate of change to be brighter, and those areas that are constant to be darker. You can then access the pixels directly with an [ImagickPixelIterator](http://www.phpimagick.com/ImagickPixelIterator/getNextIteratorRow) and sum the regions you want to test - the one with the lowest value will be the one with the least detail. Alternatively you could just use the ImagickPixelIterator and do the pixel analysis yourself, if you either are not in a position to compile from source, or want to use your own function for analyzing the 'plain-ness' of a region.
I noticed that it says #phpc at first, and then it says ##php. I would say that the proper channel on Freenode would be ##php. If it says that you need to be invited, they probably turned `+i` on because of a spam attack possibly.
I just tried that, and now I'm getting this message: ##php Cannot join channel (+r) - you need to be identified with services
I don't have any comment about the DI aspect, only to question why the (nested) traits added to your ViewModel give the templates so much access to functionality that they shouldn't need. The Url trait with included RouteMatch trait, for example, allows the templates to reach right up through to routing information. Templates shouldn't care or know about routes or controllers, and nor really should ViewModels. These concerns belong properly outside the view layer. This is assuming that I've understood the code correctly. The deeply nested traits &amp; services and the event pattern make it a bit hard for me to follow, tbh. 
And that fucking place is almost every job site out there, with the words JUNIOR and ENTRY LEVEL right in the ad titles. Plus getting about 3 emails a day from recruiters with dead end leads, who all think that if I have the word 'programming' in my resume that I'm automatically qualified for senior level work two cities over. Seriously... fuck this nonsense. 
Relax. They hired you because they saw potential. As a junior, they expect you to know nothing, but be able to learn and grow. 
All this advice (w/ exception of What the fuck. and Give me your job.) is relevant. I'd say what it is entirely missing is the development environment. In general, you're either coding for a Windows IIS environment, or an EVERYTHING ELSE environment. In the prior, it's pretty easy to set up something that'll mimic the *reality* you'll be coding for. In the latter case, though, it may (or may not be) difficult to precisely mimic the production environment. My suggestions: * [Vagrant](http://www.vagrantup.com/) * [Puppet](http://puppetlabs.com/puppet) * [See here on how to set it up](http://www.linux.com/news/software/applications/694157-setup-your-dev-environment-in-nothing-flat-with-puppet) In a nutshell, you create a VM similar to your production environment to code in using Vagrant. Puppet lets you create a script to automate this process. Just my two cents. Good luck!
The configuration syntax is for the framework, the rest is straight forward php - its the concept.
The traits aren't nested (nor intended to be), some may rely on a config trait. Their usage is a replacement to depending on a locator, e.g a plugin manager, by explicitly wiring an available "service" or "plugin" trait. These traits are expected to have their respective components injected and the trait simply provides helper methods to that service's methods. So in my mind it resolves to the same thing, except now each template and view model have explicit definitions associated to them. I take your point about the ViewModels, but my thinking is that this is a practical solution, it provides a clear interface for its corresponding template and is a bigger gain. Either way if the template calls a service plugin, that plugin has to be made available some how, and this way seems to alleviate the need for a locator in the templates; there is the choice. The event pattern is just a facade for invoking a method, some methods might be the aggregation of multiple ones. See the [sample configuration](https://github.com/devosc/ZendSkeletonApplication/blob/master/config/event.php)
DerpPress
Being hired to a junior programmer position with no experience in the particular language is more common than you think, for one. One very very big thing to remember about PHP: It will not hold your hand. You may be used to methods and handlers that take care of things like sanitation security and sanity checks for you - PHP will do no such thing. It is incredibly easy to do things the wrong way and still get the end result you want from PHP. That is one of the main reasons people consider PHP bad for security. Check and double check your work, then have someone else check it.
&gt;When you have a hammer everything looks like a nail. If you spend 10 years working with a hammer, it may not* be the best use of your time to spend 4-5 more learning the intricacies of the nail gun. **Depends on your preference*
This is not even a case of "learn to walk before you run.", it's a case of "learn to walk before you try to build yourself an olympic stadium to run around in." Vagrant and Puppet come after a year or two of learning and trying to get beginners to do this is yak-shaving at an extreme. It's good that you're trying to help people with advice, but that advice is better saved for intermediates than somebody who is literally trying to learn PHP before they can even call themselves a junior PHP developer. I [wrote about this](http://philsturgeon.uk/blog/2014/05/the-tale-of-tom-dick-and-harry) sort of thing. :)
The nested services allows you to create objects without them having to be registered with the container either before or after their creation. There is some visibility management available still by making properties protected or private, these could be used by the trait method and so only their public methods would be available. A service can provide very specific plugin traits if desired. Thanks for the comments.
&gt; 90% of PHP's problems with security and performance come from bad stackoverflow answers from 2005. Most of PHP's problems pre-date StackOverflow, which launched in 2008.
&gt; You can do it AFAIK, PHP does not support multithreaded applications. I'd be surprised indeed to learn that with vanilla PHP, it's possible to build any.
that's the actual address. I think it's because I'm on a shared server
WerdPerse
When I had a kid, someone in my family gave me some advice I'll never forget: start as you mean to go. Puppet can definitely be left behind, but working in a VM that mimics your environment can't be beat.
Why not just append a 20px bar at the bottom of an image that says "This image was stolen by iksv2, but we are copyrighting it now".
If your mail server is configured correctly, it will mark the emails as spam or outright reject them if you modify the From header to contain the user's email address, due to SPF/DKIM. Look into the Reply-To and Sender headers, though note the latter is not well supported.
&gt; Upon first visit to the website: A session is created in the database. Is this really necessary? It must slow your site down quite a bit that you can't cache page views from un-logged-in users.
Well, it's just a soft-coded switch that moves sessions to disk. The code was originally designed to scale to multiple webservers hence the sessions in a database.
PHP has threading libraries, pthreads for example. However most people implement parallelism though multiple processes e.g. fork and use sockets or shm for IPC.
My experiences with ##php have been truely sad. There seem to be a lot of assholes, bad advice and if they get a chance to shout RTFM, they'll do so. I generally ask my PHP related questions in #symfony. Would love to know a better channel. 
#/r/webdev
When time and budget allows, personally, I always go a little on the paranoid site too. It depends on what your site handles, if it's something with sensitive/private data then I'd say you're never too paranoid. ## A couple suggestions &gt;* a separate token is generated and stored as a local cookie on your machine and in your session as well. The cookie name is random. Why is the cookie name random? Chances are that a malicious person would probably be able to identify the correct cookie name by its value anyway. This might just be adding complexity for the sake of complexity, it would maybe help against automated bots and similar attacks. However, depending on the other cookie values, they might be able to bypass checking the name by looking at every cookie value for a string of hex characters that is 64 characters long - bang, they've found the "secret" cookie. It might better for debugging/code maintainability and readability to just use a simple name, but this is preference of the person(s) working with the code. Personally, this might be a little overkill and just add needless complexity. ---- &gt;Your user-agent, browser name, browser version, OS, IP address, and a random token are concatenated into a long string, and then hashed to generate a 'machine token' which is stored in the database. Again, this totally depends on what your site actually does and what data it stores. If it's holding sensitive/private data then this kind of protection probably outweighs the drawbacks. Some users have dynamic IP addresses from their ISPs, and users on mobile might hop through so many different radio towers on their mobile data that could change their IP address plenty of times. This would force them to be logged out of their account possibly every couple of minutes. Think about what sacrifices in usability/UX you can take in the name of security. Perfect security is a pain in the arse. ---- ## Captain Obvious Points * Ensure you're using HTTPS/SSL on all the site's traffic. * Ensure you're using [HTTP Strict Transport Security](https://www.owasp.org/index.php/HTTP_Strict_Transport_Security) headers if you're using SSL. * Is all your user-generated content (even yours) being correctly escaped on the pages? Don't let any XSS slip in the cracks. * CSRF attacks should be covered as you're validating the user's IP address etc, but if you consider removing the IP address check in favour of usability, check for CSRF. * Remember, malicious JS on another site can also read the user agent and send requests to your site. * Ensure all cookies are [HTTP-Only](https://www.owasp.org/index.php/HttpOnly) (JS can't access/modify them) and [Secure](https://www.owasp.org/index.php/SecureFlag) (never sent over HTTP - only HTTPS). ---- Hopefully at least a little of this is useful for you, just ask if you have any questions :).
Question: why are you injecting the request class in the [FeesController](https://github.com/angelov/eestec-platform/blob/master/app/controllers/FeesController.php)? At first I thought you were one of those guys against facades, but you're using things like `App::make()`. --- Also, just a personal preference, but instead of storing my repository implementations in the same namespace as the interfaces themselves, I generally put them in `Acme\Repositories\Eloquent`.
I haven't made any attempts at it since, but I did write a PHP server off of the 5.3 release. Yes there are threading libraries, but garbage collection was the the wild wild west. 
Thank you :)
My advice: Ignore recruiters, they're mostly a waste of time even at senior positions, but they have very little motivation to spend time placing junior candidates (which is why they do the whole "throw you against the senior position wall and see what sticks" approach). Write some code for your resume. Work on a project and put it on github, even it's something basic you can show it as a concrete example of your ability to code, and it will give the people interviewing you an idea of where your coding skills stand. Stick to smaller software shops that know how to recognize and develop talent. If you're talking to an HR person you're at too large a company. Don't be picky. Offer to work on whatever grunt work they might have for you (data entry, image touch-up, etc etc) while you learn to write better software. If you're in a smaller / less active market, consider relocating. In the larger markets I'm familiar with many companies are hiring for lots of skill levels.
I'm subscribed to /r/webdev, but really, I'm looking for an IRC channel where I can get some quick thoughts and responses.
Thank you very much, I'll take a look :)
You need to be identified, then after that you need an invite. I just tried myself (having been authed for a few years) and am told I need an invite. Update: Whoops, just realized it is #phpc in the sidebar (missed the c) so yes, this one is letting you in. #php is the main room that needs an invite.
The reason is `xgettext`. It's a program that extracts all translatable text in PHP code that it finds in `_()`, `gettext()`, their "n" variants, and any other custom function/method you provide. If a source text appears outside of the view, is assigned to a variable, and then translated in the view, then the xgettext parser won't be able to parse the strings as translation source strings.
Hmm, you bring up a good point on mobile users jumping networks, I actually haven't thought about that. This whole framework has been a labor of love really. I do things with it to see if it's possible/feasible. I've had it running static websites, active directory user management stuff, account management for google apps for education, system monitoring, power monitoring (alerting me when my house loses power and when it's restored), ticketing systems, etc. 
`##php` is open to everyone.
PHP.
It may sound stupid, but when I started developing for OpenCart, I just "got it". We mainly used procedural PHP for simple sites, but MVCL just seems so much more intuitive. With how everything is moving now, I'd say focus more on OO, but as in my case, be prepared for the fact that they may not be working with latest technologies or best practices.
Put a hash in front of it. That's our channel, what I was trying to say but Reddit used the hash for formatting I think. Not sure, I'm on mobile.
So, from what I understood, it is probably a good idea to change the cipher from MCRYPT_RIJNDAEL_256 to MCRYPT_RIJNDAEL_128?
&gt;The code was originally designed to scale to multiple webservers hence the sessions in a database. That's a job for the load balancer, not the database. 
you do understand that the load balancer does just that, balances load. It doesn't keep file-based php sessions persistent across every webserver in the cluster. You need to either store sessions in the database, store sessions on a remote file-server or have some sort of persistance product keeping all the php-session directories in sync with each other. With file based php sessions, if I go through your load balancer and log into your site using webserver#1, that session is stored in a file on webserver#1. If my next request goes through your load balancer and is thrown on webserver#2, that box will be like "who the hell are you?" because it has no knowledge of my session on webserver#1. The session data needs to be in a persistant place, usually a database.
&gt;you do understand that the load balancer does just that, balances load. Load balancers can also be set up to always direct you to the same node. -.-
so you'd rather write your code to only work with that one load balancer algorithm? This method will work on any load balancer algorithm by any brand configured in any manner.
Sure, it will break with round-robin DNS (which isn't a load balancer and really shouldn't be used anyway), but even then there are better options than to store the session in a database. For instance, a memcached server or similar would be much preferable, and you wouldn't have to change your application logic, just your php settings. 
memcached server would be nice, I just don't have one setup to write a 'module' for yet :(
interesting, I'll have to install memcached on my text VMs and give this a shot.
If you know the basics and principles of programming (especially the major design patterns), you'll be fine. It's like with anything else; just need some time.
Start with a framework. Figure out the one they use. Don't worry you have to learn somewhere and they know you are fresh. You will be fine.
&gt; I recently scored a job as a junior PHP dev, but don't know PHP. What should I know before starting? Oh, I don't know... perhaps I would start with PHP? :)
Awesome, I'll be following your progress.
Some people like to be technically right so you'll get the most correct answer even if it's only different on a minor technicality!
Everyone here is going to hate me for this, but my advice would be to cut out and find another job that uses a different language, such as javascript, python, go, haskell, C++, rust, anything but PHP. Especially since you are young. I don't hate PHP. In fact I have coded it for over 10 years. It's just that it's a dying language and the software development community's hate for it is strong, relegating it to a small number of projects and legacy code. Most of the top devs don't want to be associated with PHP regardless of its merit so you see most innovation happening elsewhere. If you decide to ignore my advice, go with Zend2 or Symfony. Everything else is bullshit.
Further be sure to read the web security stuff. Juniors don't often get the chance to screw anything major up but you want to be sure to know that stuff well. It's a big deal and it wouldn't have been covered in c or java. Best of luck and enjoyment on your wonderful journey that you are setting out on. Php has a lot of warts but sometimes when she's just been polished and then sun hits her just right, that turd can be beautiful. Just kidding; ignore the php haters.
Yep, I'm familiar with jsp/servlets...and of course stackoverflow is home :)
yes. 1. You setup Mailgun to receive your emails (much around with DNS). 2. you specify a rule basically saying, when I get an email call www.yoursite.com/newemail.php (the post contents has all the details of the email). 3. Profit. 
Sorry for going off topic a bit here, but where is this huge market for any of those languages besides C++, javascript. I don't see a large community / market for any of those languages. Maybe my eye's have been to close to keyboard for the past decade or something. 
Then clearly no one else in the world does, and WordPress lacks that feature.
Python is definitely huge, go is growing extremely quickly, haskell is worth learning because it will make you a better programmer. Rust will likely be important in the near future, but is the weakest on this list as a choice for new programmers.
Also its not purely about currently having a huge market. You have to look at trends - which languages are growing and which are declining. Also, there is supply and demand - some languages may have a small market but the supply of programmers is lower than the demand. Lastly, just because a language has a large market doesn't make it worthwhile. For instance open source advocates would not be interested in c# depsite its large market.
wouldnt taking averages kill the purpose of finding a solid color area?
tried it, doesnt serve the purpose
Oh my fucking god. This is horrible. mysql_connect("YOUR.database.info.hostedresource.com", "YOURusername", "YOURpassword") or die(mysql_error()); mysql_select_db("YOURdatabase") or die(mysql_error()); For a start, `mysql_connect`? Seriously? More importantly, though, this is on every page. Not even as an include. if(isset($_COOKIE['ID_my_site'])) //if there is, it logs you in and directes you to the members page { Oh god. How do you put comments there?! How... how does your brain let you?! Oh god. Giant block of nested ifs. Oh god, that indenting! Running `die` on query failure. Oh my god so much sql injection. :( Can someone please make a pull request that's just `git rm -rf .`?
This is sad. '15 years experience and can't write *slightly* secure code.'
I remember when I wrote my first user system. Brings back memories.
Do people read about.com for information anymore? It's been years since I used that site for anything relevant.
What is the point of load balancing if one user can only be serviced by one node and that node happens to be busy?
How does reformatting have anything to do with the things I mentioned, like injection security or sanity checking? &gt;Nothing "teaches" you best practices ... Really? Not the classes, seminars or group workshops designed to teach best practices? Not the tutorials or books about the same? Dude, stop talking out of your ass, you don't sound smart saying this crap, you sound like you're regurgitating nonsense.
That's not how it works. Load balancers have the ability to distribute load over the available nodes and then keep returning visitors on the same node over a period of time (such as the lifetime of the session). This is a common setup for load balancers. Read up on sticky sessions. 
As soon as someone suggests something is "overkill", you have useful security features actually removed in the interests of "I didn't understand it so you probably should be less secure". Unless any of these points are literally nonsense, no, it's not overkill.
No - the purpose of taking the average region colour after finding the edges would be to find an area of the image that has fewest edges in it. In fact, my method would treat solid colour areas the same way as areas with smooth gradients - they both have low-detail and would both be suitable for an overlay.
Oh yeah, you're right, sorry bout that ;)
Mainly so that if you wanted to, you can insert content between those tags. It's nothing more than a preference made by whoever writes the code. You may very well include it all in one set of tags.
WordPress themes and plugins typically mix logic and presentation together. The stuff that is outside of PHP tags is HTML, which is outputted to the browser. In your example, there's various conditional logic and what looks like some helper functions littered in the HTML.
Listen to this guy.
why would you do that? i mean - i can only judge from berlin/germany ... stepping from java to php would be a significant salary downgrade. if you have some time before you start ... take a look at problems you solved in java and see which of one are solvable in php, also install common php frameworks and do a "hello world" in them, get XAMMP (or something similar for the OS of your choice) running, and then take a look at common php open source software that might fit the company you start for (ie. blog software or shop systems, or crm, etc) 
I'm still at college, this is a casual job so salary isn't a major issue 
&gt; MVC on the web is still a really broken model ... server-side, anyways. Yep, PHP is not Smalltalk :) [PHP and Model View Controller: impossible!](http://www.copernica.com/en/blog/php-and-model-view-controller-impossible)
Pardon me for bugging you with more questions..but I can't seem to find the info that I am looking for. In such a set up, will there some set up to prevent a node from initializing too many sessions by re-directing new sessions to a different, less busy node? Even with such a setup, I think you cannot guarantee that the load balancing is optimal, because the number of sessions owned and the number of requests received by a node need not be related. So a machine handling 20 sessions that are very active may receive more requests than a machine handling 50 not-so-active sessions. In that case, without the ability to direct arbitrary request to arbitrary nodes, the load balancing can't be optimal. So I feel that the sticky sessions are there to support application that were written without load balancing in mind, and using it may lead to some performance hit, at least theoretically.
chose whatever framework you are comfortable with, there is no "better" framework (except of course laravel and phalcon ;) 
I'd personally pick symfony2 oder zf2
There is no such thing as the best framework. In the end the framework is only a tool you need to reach your goal: build an awesome app. Pick whatever framework looks good to you, and you'll be fine.
By default, a load balancer will route a request to the node with the smallest load. When you have sticky sessions enabled, the load balancer will bind the visitor to a specific node for the lifetime of the sticky session (which should be configured to match the lifetime of your application session). If a node goes down or becomes unhealthy, the load balancer will stop routing requests to that node, and the session will no longer be sticky. 
"I am really trying to tackle this, but i'm just so confused because of all the functions being called from many different files, both core, and theme files." Welcome to WordPress
I guess its like that initially, they're planning on keeping me on though
There are no “best” frameworks. Symfony2 and Zend are both pretty advanced frameworks requiring a good understanding on some key principles, Dependancy Injection, Service Containers, OOP and can be tricky to get up and get working … (from a beginners perspective), as theyre not designed to be put on a shared host and run like Wordpress. I use Symfony at the moment as the company im working for is using it for its larger projects and its a really good way to learn ‘Best Practice’. But Laravel might be a better place to start from as it does more for you and you can sign up for laracasts and get a bunch of video tutorials to walk you through most of the concepts. 
Because Wordpress. 
keeping people is always a good thing - just make sure you get a competitive salary then p.exp. by just applying at other companies up to the point where you could sign there
Interesting, I'll take a look. Also, you might want to remove the .swp files. Something like `.*.s??` in your gitignore should work.
Take in consideration that The best for me now, maybe is not the best for you tomorrow. Now we are using our own Framework extending Phalcon for the pure backend tasks and Symfony for the backend of the frontend. We try Symfony for the frontend because there isn't something comparable to Friends of Symfony for Phalcon.
Personally, I'd say Symfony. But that's purely because I have a Symfony2 background. It really is a case of what you feel best with, ultimately. 
besides it is a solid article about architecture. you should consider keeping your return values consistent throughout your code. E.g.: public function send($to, $message) { return $this-&gt;sms-&gt;send($this-&gt;from, $to, $message); }
Thank you very much. I've never really wrote any coding articles before so feedback much appreciated! I'll update it now :)
For the start you could stick to some "how to start" tutorials or something. Maybe then you can see which framework fits you most.
I tend to think of a model as a place to have business logic more than just a data abstraction layer, my thoughts they have just ended like that to suit the ORM not the principal - however I haven't thought of service like that before. Is there any more examples?
Uhm... Why do you replace dependency injection with an anti pattern (container aware or A.K.A. service locator)? Also, your `SMSService` class is just a wrapper of a service. The `SMS` class is already the service. What you are looking for is an IoC with bindings which you setup once.
https://github.com/laracasts/Validation as an example.
Yeah that's a pretty good point, I think I was in Symfony mode whilst I was writing it haha. Sure thing, for example in a project I have that's eCommerce (built in Symfony), I had a service for registering new users, billing users, creating orders. So chunks of logic such as that. That's because my application was taking new users, and orders from different areas of the site such as web, SMS, phone and API. So instead of rewriting that logic in my API controller, my webstore controller, SMS controller and phone controller etc... I just wrote them as services and called those services in each of those controllers. This means you only have to configure a service once, on top of that, if you make the configuration so that you can override configuration also, you've got something highly flexible and re-usable. It's not so clear initially to see why services are so useful, but when your application makes use of same blocks of functionality in several places, it really starts to make sense. In fact I might add those examples to the post :)
Well it was just an example to keep the article snappy. It could have been any block of logic in there. Should I update the article to maybe perform a simple block of logic to better demonstrate that? 
The problem is, is that you switch from DI to SL which may confuse some users. Why don't you just leave the dependency injection there and follow best practise with it? Or are you speaking of the wrapper part? Because if you want to show something with an example you should show it, because in the current setup you don't show us a service. Instead of a binding in an IoC you just made a wrapper class.
Well I'm still DI'ing the servic, it's just being called from a container. I was just trying to demonstrate the use of services in frameworks rather than bloat controllers which complex logic. I may be missing your point though, apologies if so 
Ahh I see. yes I think you should go a bit deeper in your article, be good to see a bit more.
How do you like Phalcon? Been thinking of using it similar to your usage. Then have a another framework be the glue for js. 
I've made a few alterations and given a few more examples for further clarity. Thanks for all your feedback, folks! 
Done! 
If you are experience with PHP and know OOP and best practices, why don't you build a project and make a framework out of it, that how most the good frameworks where builds. Ofcourse only fo that if you have the intention to taking most of this as a learning experience.
Symfony 2 and ZF2 are both built in solid best programming practices. Both frameworks offer lots of features, community bundles/modules, tons of online resources, and a solid code base. If you're wanting to learn quality coding practices then ZF2 and Symfony help push you in that direction. Using them won't make you a rockstar but with time, commitment, and practice you can learn a lot from either framework. Laravel, as someone else mentioned, is not the framework to go with if you're looking to better yourself as a developer.
I've never heard of a full stack designer.. But aren't all the things he listed that they do the things that regular designers are already assumed to be able to do? 
In other paradigms, the controller is set up once, then used multiple times - on most web languages that doesn't work as the controller is destroyed and rebuilt each request. JS MVC makes more sense as in that case the controller can persist.
Me neither, that's what makes it interesting. Not really, for example, a friend of mine is a typographer that specializes in poster design. He have no idea how to do web design. Yes he can design a nice looking site on photoshop. But it's often either impossible to implement or not practical. So yes, there's a little truth in that. I think he forgot to include liaising with the customers themselves.
I just started playing with memcached last night
Hey man, great article. I just want to point something out since it's apparent that English isn't your first language: the word "liaising" is not common at all, I've heard or read it almost never. Only the noun form, "liaison" is ever really used. Perhaps "communicating" or "interfacing" would work better in this context. And I too have never heard of a Full Stack Designer. I like your chutzpah in coining new phrases though. Kudos.
This seems to me to be a significant overstatement of a simple definition. A frontend developer handles UI/UX, javascript, layout, etc. A backend developer handles PHP, databases, and general serverside code. A full stack developer handles both. Design isn't involved. That's it.
&gt; the word "liaising" is not common at all, I've heard or read it almost never Seriously? I've heard it routinely, especially in the context of discussion with clients or customers.
They're essentially treating this code as a "template". Code is often `&lt;?php ?&gt;` wrapped like this to facilitate movement in and out of tags.
In my opinion Laravel is a good choice here. Unless you're omitting it for some reason it's probably a great option because it's got excellent "getting started" resources in things like Laracasts.
Same here; in fact I probably hear the verb forms "liaise" and "liaising" more frequently than I hear "liaison".
Hey, thanks for the feedback. And that's interesting. I've used the word liaising a few times, mostly liaise and liaison though. Maybe a more appropriate term would be collaborating? In fact, my whole office uses the word liaising, and it gets thrown every once in awhile. P.S. English is my first language :&lt;
Well, IMO, there's a continuum through from design to development, scripting, programming, dev ops, sysadmin, etc. And a developer can specialise in any one of those areas or multiple. But I believe to be considered "full-stack" a dev would only really need to be able to cover front and back end. That said, these days some basic dev-ops/sysadmin is probably necessary, and the term isn't exactly clearly defined.
There is an english version: http://blog.henriquedias.com/diferencas-operadores-igual-identico/?lang=en .
You're forgetting server administrations. Some devs don't touch backend configs. They just write the app and uploads via ftp or some other protocols. Thats why you have sysadmins. But full stack devs are required to know sysops. e.g. Being able to deploy the app from an empty VPS, configuring everything from SMTP to server hardening to deploying and installing prerequisites.
We call it "full service"
No, I'm not. I'm omitting it, not forgetting it. IMO it's not part of what I would consider the definition of a full-stack developer. Your definition may vary, but I would consider front + back to be a full stack, with sysops experience as a "nice to have".
Does it include a happy ending?
Hehe... you better ask my clients ;-)
Very nice article. But I have a problem with this block: &lt;?php class ModifyController extends Controller { public function modifyStringAction($string) { echo $this-&gt;container('modify.string')-&gt;modify($string); } } Your service dependency (modefy.string) is not visible from outside the class. You would have to inspect the code to know what service each method is dependent on. A better way to do this would be: &lt;?php class ModifyController extends Controller { public function __construct(StringService $stringservice) { $this-&gt;stringservice = $stringservice; } public function modifyStringAction($string) { echo $this-&gt;stringservice-&gt;modify($string); } } and construct the controller with your (IoC) container: $controller = $container-&gt;make('ModifyController'); By doing it this way your controller class is exposing its dependencies in the constructor as well as decoupling its association with the DI implementation. The container could easily injects the proper dependencies recursively when constructing the object.
Only if it's in previously defined requirements. NO SCOPE CREEP. 
This is precisely it. Also consider that many of those who participate in \##php are some of the most devoted &amp; experienced in the PHP ecosystem, whether it's core &amp; extension contributors, library authors, etc. If you actually contracted their services, you'd be paying top-dollar for their time... but you don't have to pay a dime, they do it all for free. When I've had a question for ##php, I always try and take a few questions myself, so that I'm not just consuming their help but also contributing (a tiny bit) back to the channel. It's when you do that which makes you realize what they deal with on a continuing basis. I'm also reminded of the scene with The Wolf from _Pulp Fiction_: &gt; `The Wolf:` Jimmie, lead the way. Boys, get to work. &gt; `Vincent:` A please would be nice. &gt; `The Wolf:` Come again? &gt; `Vincent:` I said a please would be nice. &gt; `The Wolf:` Get it straight buster - I'm not here to say please, I'm here to tell you what to do and if self-preservation is an instinct you possess you'd better fucking do it and do it quick. I'm here to help - if my help's not appreciated then lotsa luck, gentlemen. &gt; `Jules:` No, Mr. Wolf, it ain't like that, your help is definitely appreciated. &gt; `Vincent:` I don't mean any disrespect, I just don't like people barking orders at me. &gt; `The Wolf:` If I'm curt with you it's because time is a factor. I think fast, I talk fast and I need you guys to act fast if you wanna get out of this. So, pretty please... with sugar on top. Clean the fucking car.
Since most of my front end is heavy JS nowadays, I've switched to using JS to run my GUI tests. https://www.npmjs.org/package/selenium-webdriver Nicer syntax, since you can use promises to handle waiting for things to happen, and it's an officially supported client.
Where is that down vote button ? Ah, found it !
&gt; Your user-agent, browser name, browser version, OS, IP address, and a random token are concatenated into a long string, and then hashed to generate a 'machine token' which is stored in the database. I believe this technique is called [fingerprinting](https://wiki.mozilla.org/Fingerprinting) ([more info](http://programmers.stackexchange.com/questions/122372/is-browser-fingerprinting-a-viable-technique-for-identifying-anonymous-users)). Just letting you know incase you weren't aware of the formal name for it. As for overkill? I'd say it depends solely on your site's purpose. Do you deal with credit cards? How about health data? Both of those have their own set of very stringent security standards (PCI-DSS and HIPAA, respectively), which cover everything under the sun pretty much.
&gt; What is the general attitude you guys have toward legacy systems? Is there anyone that sees one and gets excited by/enjoys the challenge? Anyone who specializes in this kind of stuff? Or is it safe to say no one wants to work on a legacy system? Personally, I find it a combination of frustrating and challenging, and finally exhilarating when you fully tease apart bad code and refactor it into good code. I've done it so much over the past 15 years in PHP that I wrote a book about it taken from all my notes and experiences working with legacy code (some of it code I created myself in the first place). It's called [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp) and it gives step-by-step instructions for dealing with the kind of codebase you describe.
&gt; the terrible management who tells me not to work on documentation because I have "more important things to do," the cheap attitude that they can cut corners to get whatever they want and just in general shitty workplace politics (I mean really, Dilbert worked there in a former life), I've decided it isn't worth it to go through the migraines every day. As a followup, there is *no reason* for you to have to go through that. We want to enjoy our work, and most of the time we do, when we are allowed to actually do the work that is truly needed. It sucks that so many workplaces are as you describe.
Please stop making up things and saying "you're wrong because I've decided it means this now." You are guessing wrongly, and the thing you're insisting on isn't even named what you're calling it. On top of that, Laravel and Symphony have *nothing* to do with ops. It's only kind of hard for you to draw the line because ***you don't know what the phrase you're trying to define for others means***. Stop arguing. Take your wrong article down, and learn from the people around you.
This mistake is a hiring red flag. It absolutely would not.
Common in British English. Almost unheard of in US English. Don't know for the others.
I disagree if only because some modicum of design skills are required to implement UI/UX. Definition be damned, companies say they want a "full stack" dev because they don't want to hire a designer AND a web dev AND a server admin, right? So somebody who can do all of the above jumps to the front of the line. My weakness was design so I learned how to use Bootstrap. This was a shortcut that allowed me to quickly deploy responsive HTML5 compliant websites without mucking about too much in the CSS and JS. I've found that this, and some basic Gimp skills, papers over my lack of design chops in a way that is acceptable to most interviewers seeking a design-inclusive full stack web dev.
Or as they are more commonly known, "22 year old devs who want to look important more strongly than they want to look like they have self awareness and good judgment."
Whoa whoa whoa
&gt; Laravel, as someone else mentioned, is not the framework to go with if you're looking to better yourself as a developer Wow, what a load of uninformed ignorant shit this is... Heavy use of annotations in Symfony isn't "quality coding practices", and don't say "but you don't have to use annotations in Symfony" because ALL of the documentation for Doctrine and every other 3rd party library the mimics it is heavily biased towards annotations. Comments should not affect code. End of story. Please go ahead and explain to everyone here why you think Laravel is not the way to go to better yourself as a developer.
&gt; The biggest problem I see in this code is that it's all indented wrong That's not the biggest problem, in fact that is the *least* of the problems there. Just to name a few of the bigger ones: * Global state / functions that directly mutate said state (wp_reset_post_data) * Direct access to db results / lack of abstraction ($page_query) * Combining business logic, routing logic, database access and templating into a single script ... and so on. So no, indentation doesn't even make top 3.
Wordpress is truly one of the worst codebases out there, PHP or not. It has global mutable state, complete lack of abstraction (including db access) for anything, extremely outdated codebase (PHP 5.2, released 8 years ago) and a very poor security track record. The fact that it has a huge plugin/theme community makes it worse as its popularity encourages bad code on a huge scale. If you are looking to start learning PHP, I'd suggest moving away from Wordpress to.... anything else really.
"Full stack designer" sounds like a designer who wishes they could code and makes up for it by adding "full stack" to the front of their title.
Full STACK. What STACK do you use? L(E|A)MP? What does that mean? Linux, Apache/Nginx, MySQL and PHP. A FULL STACK developer should know all of those. Sysadmin (Linux), Webserver (Apache/Nginx), MySQL and PHP. UI/UX also goes into that too.
Meh, that comment was meant to be tongue in cheek, I mean the indentation DOES make it hard to read and the rest is just lol wordpress
I'm working on sugarcrm for my dayjob. The backend side of this product is very, very, very dated, full of (IMO) bad design decisions and the team developping it clearly don't want it to evolve. But the fact is: it's working (most of the time). But god, when it's not working it's soooo frustrating, they basically reinvented everything (from logging to DBAL), and the code is fugly. So, to answer your question, I don't have a problem with it being "legacy", but when it breaks, it's nearly impossible to understand why, because of the (bad) quality of the code.
&gt; Laravel, as someone else mentioned, is not the framework to go with if you're looking to better yourself as a developer. Uhhhh, how so?
But then what's the point in having design patterns and architecture patterns such as MVC? Surely these 'pigeonholes' help people conform to a set of standards and methodologies that are interoperable and easy to follow for other developers. I don't see what the problem with naming conventions is. Classes have different types of interactions with each other, which then have different uses and different implementations. Why should those not be named and documented? 
You both have some good points. I'd give you my detailed opinion too if I hadn't been up for 24 hours launching three redesigns simultaneously.
Looks like a matter of course to me. The points you are making for a "full stack developer" are e.g. a natural part of the german apprenticeship for becoming a qualified IT specialist ("Fachinformatiker"). Furthermore during such a apprenticeship you will also learn many things you didn't even mention like safety related things, legal forms / laws, acquisition, ecologic aspects of the work, team work, plannung of work / managing, system architectures, hardware / software, privacy and copyright related things and much more. The list 1) Code 2) Commercialise 3) Implement 4) Test 5) Maintain seems almost ridiculously shortened to me. And actually - doesn't any employer ask for all of those things anyway? Who want's a programmer only being capable of one or two of those things? It doesn't make sense
Personally i think you should keep the strong point of your article, namely don't put potential reusable code in controllers. Dependemcy injection is rather peripheral in this instance IMO. Your point did come across though, I just wanted to outline what may be concidered an anti-pattern.
To be quite honest, I even hate having to work with someone else's code let alone someone else's *bad* code. It sounds like they are a far cry from your coding style in addition to being crappy programmers, and I fully understand how frustrating that is. Although sometimes I go back and look at some of my old PHP code I've accumulated over the years, and there is some raunchy code in there from my early years of programming..
Please do, when you're well rested and sober :D Looking forward to it!
Ah, but I'm referring to just the developer itself. Not an IT Specialist, which usually are sys admins. A developer wouldn't need to learn about data centre and operations (for e.g.) Law... Yeah of course, but that's not required of a "Full Stack Dev". Well, you'd be surprised how some devs have no idea how to conduct a unit test and have little UX expertise. But they write beautiful codes. Thats why we have experts in different fields :D
&gt; Meh, that comment was meant to be tongue in cheek Sorry, I didn't get that from your post. I was a bit afraid someone actually thought wp is a decent codebase :) 
Lol mate, Rust is still under development and PHP is not dying, in fact it's evolving rapidly...you put in the same basket, web development, system development, functional programming and learning how to cook. PHP is not dying and in fact there is a huge market out there. The best for every developer is to be a generalist. Stick with the basics and use the tool you think is the best to solve your problem. The guy found a job, he does not study to become a developer in few years from now... Also when it comes to trends http://stackoverflow.com/tags ... 
Because those names don't fit most projects adequately, which results in no actual convention achieved. You have a "model" in name only. But because it's unclear, ambiguous, and 100 different developers will have 100 different opinions as to what a model is, on project A, you have a model that is behaving more like a table gateway. On project B, that model contains everything that's not in the controller. On project C, that model contains some code that on Project D is in a service layer, that in Project E is in a repository instead. If there was a way to enforce a concrete use for a "model" or a "service", then you should by all means name and document it. But due to the nebulous, generic, abstract nature of these names/classes, architecture is WIDE open to interpretation.
Just so you are aware, it's recommended to set up your Symfony controllers as a service, and use dependency injection instead of service location anyway. So, even if you were rewriting parts of your article to be Symfony specific, this would very much still apply. See http://symfony.com/doc/current/cookbook/controller/service.html
Thanks for your reasonable response. If you look at my other posts in this thread, I admit that Rust is a weak recommendation. Regarding tags on Stack Overflow, those are a measure of popularity of a language since Stack Overflow started, and not the current popularity. It says nothing of trends. I would bet that if you look at the rate of new tags instead of overall, you will see PHP much further down. anyway I don't disagree with your overall statement - be a generalist, and learn to program however you can. This guy may not have a choice of language, but if he did, would you recommend PHP as his first language?
This is pretty much the reason I don't use Wordpress - wtf is that?
TIL I'm a unicorn edit: awaits hatemail for comment
Well, if your biggest concerne is using a global function, you can search &amp; replace __() with \Vendor\Translator::trans(). And then why not eventually replace it with dependency injection later on.
thank you for that counter, before this place turned into circle jerk
I'm the reverse, but now there's bootstrap so I don't need artistic talent
I'm wondering if Exception handling might be the best way to define these bounds.
Seriously. Must be a Britishism or a domain-specific buzzword, but it's awkward as fuck for me to hear or read.
Just a spelling correction: I think you meant 'interoperable' rather than 'interopable' at the end of the first paragraph under Services. 
Ty for the downvote? No, I havent used the tool at all, but i want to. I was simply replying to a comment about readability of tests by non-tech personnel. I'm not talking about the report, I'm talking about writing the tests... Did you even read the comment by one of the devs (/r/davertua) right after yours? 
I'm sorry that I didn't recognize that. You write as if English is not your first language. Maybe you could benefit from more thorough proof-reading.
Well, I don't feel like enabling someone who is all talk.
Ho ho ho! I earned myself my very first hater from this post!
They're basically just ways of pulling repetitive code out of your controllers, like if you have a bunch of routes that start with `/admin`, you can set up a middleware that checks if a user is logged in before allowing access to it. You could look at [some of these](https://github.com/codeguy/Slim-Extras/tree/master/Middleware) for examples as well.
I actually don't mind working on legacy code too much, with a couple of caveats. Firstly the company needs to want to change it and support making major changes if required. Secondly the original developers of the system need to want to change or not be there. It gets really hard to criticize a system in view of changing it when someone takes it personally and defends the old ways of doing things at every turn. The best legacy code projects are the smallish abandoned applications with clear behavior (or at least a clear vision of how they SHOULD work) that can be practically re-written in a short space of time. These tend to be paint by numbers exercises which can be quite satisfying. You already know exactly what the app needs to do - you just need to implement it and implementing stuff is the best bit. That being said I don't think your problem was with legacy code as such. It sounds more like there was no developer or business buy-in to tackle technical debt. You can't do anything in that situation (except leave).
&gt; The concept of a full stack designer is nonsense. It seems like nonsense, but I agree with the point- How well does the designer know design? Are they creating raster and or vector art? Can they format an image for web and digital prints and screen prints? Can they convert their web mockups to HTML/CSS/JS? There are as many nuances in the design as there are development.
I don't think a service is "a thing". It's just a word that is appropriately vague for the things it covers. Controllers need to be created somehow with specific dependencies and you probably need to be able to name them so they can be associated with a route. That all sounds like stuff a service manager or DI container can do. So if the service manager is in charge of creating controllers then why not call them services? The purpose of IoC isn't primarily to allow objects to be shared across the application in my opinion. It's a side effect of the rest of SOLID and the fact that you can't test things that cannot vary their behavior. So the argument that because controllers are not "reusable" as such they aren't services doesn't sound correct. Generally I would question trying to define a "model" or a "service" in strict terms.
I agree. It seems like there aren't two people on the planet that have the same definition of a model. It makes sense in real MVC but because you can't actually implement proper MVC on the server side everyone has done it differently. 
Check out [Redis](http://redis.io/) as well. I prefer it to memcached.
Check out /r/forhire - lots of developers/freelancers looking for work there.
This sounds exactly like a place where I used to work, except to cap it all off they develop on PHP 4.4 with MySQL 4.0! That version of PHP was EOL in 2008, and most of their core systems are still running on it. This is an online retailer with daily turnover &gt;£1,000,000. Unfortunately a lot of places are like that. 
That's lovely, but you can't do that. Without names, people have no way of even discussing these things. Without layers, it's impossible to design a framework. Frameworks typically take some route, send it off to some action within a controller, and that action returns a view. But you just tossed all those concepts out. So now what? Anonymous layer 1 takes in a URL and, well, where the fuck does it send it? It needs a consistent interface to be able to do anything useful, and that interface kinda needs a name. You can shove whatever where-ever following your principles, but you still have layers and labels. And it's not silly to say what belongs where either. N00bs need guidance. If they don't know any better, it's better they follow some rules of thumb. Once you're knowledgeable you can start deciding when and where to break these rules; there's always exceptions, everyone knows that.
I'm referring to the organization of business logic specifically, and the attempt to split the business/domain logic up into genertica architectural layers/patterns such as "model" and "service". I'm fine with routing/controllers/views as layers as those are mostly unambiguous and have well-defined responsibilities with fairly intuitive names. But when it comes to your domain/business logic, "model" and "service" aren't sufficient for organizing your code, nor are they named in such a way that they clearly communicate the intended responsibility and behavior of the code contained within them. I have no problem with referring to the business logic as a layer in and of itself, but a "model layer" and a "service layer" within the business/domain logic layer makes zero sense for the reasons stated previously.
&gt; Competent in ASM &gt; Pre-boot (BIOS/EFI) experience ok.jpg
The "holy shit, I wrote that?" feeling happens to me uncomfortably frequently to the point where I'm beginning to think I'm getting dumber as time goes on. Either that or gnomes refactor my code while I'm not looking.
So he can do the work of five people for the price of one? He can work five times faster than any other motal? I don't think that's what he meant to say. 
&gt;To measure the script running time I simply added the “`` seconds” line before the /body tag of the footer.php’s That doesn't really seem like the most accurate or trustworthy test. I'm sure the other tests were perfectly fine, that just struck me as odd.
I think the biggest problem in the Wordpress scene are the plugins. You sure can rewrite Wordpress itself, but plugins will take a long time to catch up.
I thought PHPNG was still in development. Where did you get a working copy? also, does this mean we can deploy PHPNG for production? 
I would _strongly_ advise against that (using it in production). It can be compiled from the official source (git) or you can find ready-made packages too!
Please please *please* name and unit your axes when you are putting up graphs. What is the Y axis on these graphs? Kilometers? Gallons? Hamsters per square inch? Sure I can deduce that it should be seconds, but that really doesn't make it ok. That said, the results do look interesting. EDIT: Also fix the graph colors please. Maybe its just my monitor, but I can barely tell which is 5.5.9 / 5.5.15 in the second graph. Maybe use something with more contrast?
Devops meaning developer operations, in terms of infrastructure and/or developers changing infrastructure. Google: Flickr +devops It's very common.
Good idea, I'll run it! **edit:** wait, I'd have to add all .php files as parameters to create the database for hhvm first? Or am I missing something?
The bigger problem I have with this example is why on earth anyone would create something called a ModifyController with a modifyStringAction method. Setting aside that the method name tells us nothing about what it's actually doing ... what request would ever be routed here? The main issue is that this isn't controller logic at all, so of course it belongs in another (helper) class. Otherwise inheritance and traits allow code reuse of *controller logic only* between related controllers. Otherwise, it's time to move away from this preoccupation with MVC and read about clean architecture, in my view. Your application doesn't belong in the delivery layer, and just pushing use cases into service classes doesn't really help at all. 
An African or European hamster?
One of the opening lines says that "full stack developer" doesn't return anything on google. Except for 8+ million results. Everybody knows what a full stack developer is. It is not necessarily someone who does 5+ jobs but someone who can do any of 5+ jobs. Often I have met people with fine arts degrees who were competent programmers and could easily manoeuvre around the linux command line. But that didn't mean that their job was system admin. What it meant was that that when each "full stack developer" was talking to another FSD that the two could understand each other's needs. So if the person working on the front end was asking for the server to run faster and the people further back would say that the DB could not go any faster but that implementing a memcache could speed things up; the front end developer would know what that meant and how much work it implied. But even better it also meant that all the people could sanity check the other's work. That one person could not go wildly off the rails. So if the back end guy said that he was rewriting the kernel to implement a PHP opcode cache then the other people could go, "Whoa there cowboy, that sounds about as maintainable as an early 80's Hyundai." 
"Without further ado, these were my test results, the lower the better, values in seconds:"
Exactly agree with you. What does that even mean (question for OP)? What script generates the HTTP requests? OP doesn't really explain how the benchmark works, or I'm missing something.
&gt; I thought PHPNG was still in development. It is. I didn't believe it either! &gt; Where did you get a working copy? Probably from upstream's VCS. &gt; also, does this mean we can deploy PHPNG for production? Would you drive off in a car before they've finished fitting the brakes or seatbelts?
Since you ran this on Vagrant: What type of Synced Folders did you use? There's a MASSIVE speed penalty if you use VirtualBox, NFS or SMB sharing folder types. If you used anything other than rsync, you should run the tests again as they will be massively different. 
Something isn't adding up here. According to the HHVM blog from 12/17/2013: http://hhvm.com/blog/1817/fastercgi-with-hhvm Using the normal PHP interpreter, they get 23 requests per second. Which is slower than what you were getting, but perhaps within experimental error. But with HHVM, they got 949 requests/second (!). Which is way beyond what you're seeing. So I think there's something wrong with the setup or the way the results are measured.
I will run them on a cloud server, however given that all interpreters were using the same file reading method I don't think it will change the results. Maybe more requests per second but definitely won't put HHVM first and the rest of them behind?
You're right, it doesn't make sense for business rules and your application as such to be identified with what are still almost entirely database-centric monolithic web frameworks where Active Record is still painfully dominant. Your application shouldn't care about the framework, nor should any framework dictate an application's architecture. Business rules of course have no place in classes designed to manage persistence, if anyone's still doing that ... Thankfully all the good stuff from Uncle Bob's [Clean Architecture](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html) is finally seeping through to the PHP world, so let's hope that this obsession with db-centric MVC will be replaced with discussion about how to design use-cases and business objects properly. It's really not that hard if you just follow the very simple dependency rule that nothing inside should depend on/know about/name anything outside. Perhaps by Symfony 3 .... 
To be honest we've been running it on production servers too and the general experience is the same. Now with a more powerful computer in a non-virtualized environment the RPS could be way higher but it will be for Zend too! Anyway, I'll run it on another machine too to confirm.
Some things I can think of: 1. Automatically validating a CSRF token and then removing it from the request data 2. Authentication and Access Control, ie "is the current user allowed to edit this resource"? 3. Basic data validation 4. Implementing a "maintenance mode" feature with whitelisted IPs By implementing those kinds of features as middleware, it makes it easier to separate your application logic from your domain logic.
You're comparing two different aspects of Slim. Middleware allows you to load external libraries into Slim's Core, after Slim itself instantiates. This allows you to add things like the [PHP Debug Bar](http://phpdebugbar.com/) or [Whoops](http://filp.github.io/whoops/) into your application using their respective middleware libraries ([slim-debugbar](https://github.com/yusukezzz/slim-debugbar) and [php-slim-whoops](https://github.com/zeuxisoo/php-slim-whoops)). While hooks are functionality that should be triggered at specific times during the request's lifespan. If you want to check if the user has an active session before dispatching a route, hooking onto *slim.before.dispatch* with your authorization and login check would be ideal. There are some [predefined hooks](http://docs.slimframework.com/#Default-Hooks) in the framework as well as the ability to [create your own](http://docs.slimframework.com/#Custom-Hooks)! I hope this clears up a few things.
No. 
I saw another benchmark that also showed HHVM much faster, but actually I came across this which is more interesting: http://stackoverflow.com/questions/17898783/hhvm-poor-performance Bottom line, I think you're seeing the poor performance because you didn't run it long enough: "HHVM engineer here. In server mode, HHVM will run the first N requests it sees in interpreter-only mode (i.e. with the JIT off). The default in an optimized build is N=11, so if you were to run the request 12 times, the 12th one would be much faster." So I suspect the first 11 might be skewing the overall results. But I also agree with the other poster that your method of measuring is probably not as accurate as other methods might be.
&gt; implying Haskell is a productive web development language
How much memory does your vagrant has? Your machine only has 4gb, so your vagrant is around 2gb? Check if you're swapping ram. &gt; HHVM can only be run as one user, which means less security (in shared environments) Why can you only run it as one user? It's a service like any other, pretty sure you can change the user.. &gt; HHVM does not restart itself after it crashes, and unfortunately it still does that quite often Supervisor is your friend, I wouldn't like a self-restarting service TBH.. it's the same with node, nginx, and pretty much everything. There's something wrong going on with your tests, you're the only one that I saw so far with those results. 
Nice strawman there bucko. I said some people on the QA are not programmers. Didn't say they were not technical. Our sysadmins aren't programmers either. Are you going to misunderstand that as well?
I said it in the Wikimedia post a few days ago, HHVM is NOT the future. PHPNG is going to blow everything out of the water and Facebook can go running away with its tail between it's legs.
There are kinda two camps here: 1) MVC with the model containing the business logic and all the "servicey" things. You call your model's methods from within the controller, and those methods handle "all the things" like business logic, database lookups, etc etc. 2) Super thin models (properties, getters, and setters only), you use a DBAL (ex: doctrine), and you have a service layer providing the business logic and bringing resulting data or hydrated models into your controller. In this camp you never handle business logic or direct database interaction from w/in your controller. You expect the service layer to do that for you. People seem to be increasingly leaning toward Option 2, though the ZF2 quick start guide still explains the process using Option 1. I personally prefer Option 2 because it provides a clear separation of duties in your code, and your model is just its namesake. It's just a model of your data.
I have not looked at the details of the used setup, but it's quite obvious that these numbers are wrong. HHVM should definitely not be slower than PHP 5.5 (with opcache). HHVM should also be faster than PHPng for WP 3.9, just by a smaller margin than previously. Friendly reminder: Don't trust benchmarks you didn't run yourself. Actually, be very careful about trusting your own benchmarks as well ;)
the fuck did I just read
&gt; underhanded attempt at FB for the engineers to do an end-run around PHP I think it's pretty obvious. As stated, they needed things that PHP Group (the official maintainers) weren't going to do. This included simple optimizations and fixes. PHPNG is an attempt to incorporate and improve general changes with a different bend. &gt; I suspect that MZ sees nothing wrong with PHP Is this supposed to be an understatement? &gt; My prediction is that these guys will wail away at HHVM until they realize that with MZ at the helm that the bulk of the FB core code will remain PHP; then they will leave for greener pastures where they can use Haskell or some programming language that they have been pining for. So FB C developers will work on their job until they get unhappy with their boss and leave +random Haskell reference.
I'm re-running them on a DigitalOcean machine now. We'll see!
I like your blog theme, is it available anywhere?
Really interesting. Could provide some usage examples with promises?
Yep. Been there, done that. Walk away, it's not your problem. They're bad at code, and bad at development, bad at management, and probably bad at business. There are two options for a codebase in this state, either you can bring it up to your level, or it can bring you down to its. Given a complete lack of support for the former, the only option is the latter. Staying will hurt your career long term. For the record, I worked on a system that could be described similarly. It was only started in 2013. Some things are legacy from the moment they're born.
You're free to install a VVV vagrant box and do the same tests? I think I described the environment pretty good.
And you still made a choice specifically designed to enable them to program without knowing how, which was stupid.
It's actually an ElePHPant plushie cunningly disguised as a hamster, but don't tell anyone...
I think people are forgetting that HHVM can also run Hack. Maybe the results would be different if Wordpress were to be rewritten in Hack? I'd like to do a project with Hack. It'd be cool to work with strong typed "php"
The ramblings of a mad man.
Heh. In 2012 I almost got a project which was using PDO to connect to the database, except that every single time the code made a query it created a new PDO object and closed it afterward. None of the queries had any parameterization or escaping, just "SELECT $foo FROM table WHERE '$bar'".
The theories of a tinfoil hat that has achieved sentience.
You should also test the major PHP frameworks as well, because I feel wordpress is a bad example.
I hadn't realized quite how small /r/symfony readership was, and Doctrine is really the main thing I'm asking about there, which isn't Symfony specific, so I thought I'd share the post here also. [details on the original post in r/symfony](http://www.reddit.com/r/symfony/comments/2c3cn3/symfony_doctrine_and_complex_relationships/) any thoughts / opinions are appreciated!
Article has been updated with new results based on test run on a 4GB DigitalOcean box.
Article has been updated with new results based on test run on a 4GB DigitalOcean box. I've sent the whole vagrant folder to the HHVM guys for testing because obviously there was something wrong with that particular instance. Cheers.
Article has been updated with new results based on test run on a 4GB DigitalOcean box.
Nah sorry it's 100% custom :) But thanks!
It's a fucking controller, who the fuck cares. Wiring up the controller and injecting the dependencies would be utterly stupid and a huge waste of time. There's certainly some cases where it makes sense, but it's ridiculous to cry anti pattern for doing the sane thing.
As the message says, decision made - let the team get back to their excellent work on the core.
Because it wasn't hard enough already to get hosts to upgrade that old PHP 5.2 install.
Checkout http://code.google.com/p/selenium/wiki/WebDriverJs
fwiw, the guy asked me why i turned it down and i explained, and he thanked me. i understand everyone isn't born knowing this stuff (I sure wasn't!). But... he's supposedly been doing this 10 years...
for extremely small values of "a few" stop guessing about other peoples' eligibility please