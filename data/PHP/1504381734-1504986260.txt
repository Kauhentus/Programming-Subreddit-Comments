It's bizarre that this thread keeps getting downvoted - wonder what the agenda is?
Your guess is as good as mine. Any time I submit something to /r/php it gets almost instantly reported as spam and downvoted. I think some people just hate me for some reason.
I get you 100% :)
I fully support this adding UUIDs to PHP. This is something PHP has needed for a while. Any plans on a polyfill for older versions? I think Zeev raises some really good points [here](https://externals.io/message/100347) though. I would prefer the implementation he suggests to a class based one.
&gt; Well to be fair you don't have to use the flag You have to use the flag, otherwise you'll go to line 210, which may not be CSV row 210 and you'll end up reading the wrong row (or outright fetch corrupted data). CSV rows can contain multi-line quoted values. &gt; You absolutely can argue that SplFileObject is a OOP implementation of standard php functions, and that is because that's exactly what it is, in fact so are all of the others. Objects are not folders where you can group functions by category. Grabbing all the standard PHP file functions and putting them in one object was a mistake. PHP's file functions handle many distinct concerns, and CSV parsing is one such very distinct concern. It doesn't belong with the rest.
&gt; singleton is considered an antipattern I am not saying it is an anti-pattern per se. I am just saying it is **considered** to be one. If you define a class to be instantiated as a singleton, it will **always** be accessible in a global scope. And yes, if you use some kind of service locator/container you can still simply put an instance into it and receive the same one all the time. But the true reason why i personally see singleton as an anti-pattern, is the problem unit testing it.
I appreciate your work and effort a lot. I also think UUIDs should be inside core. But, tbh, I have to agree with Nikita and Zeev. The main things I don't like with this RFC: - Performance definitely matters and, imo, is one of the main reasons why this should be added to core. Otherwise you could just use `ramsey/uuid`. - I can't really see the added value with UUID being a ValueObject. It just doesn't fit to PHP and is pretty inconsistent to how PHP works. It's really different with an object like `DateTime` as this really adds value (there are lots of things you can do with `DateTime`, but `UUID` is basically really just a string).
Only thing I don't like about this RFC is the inconsistent casing of the static factory methods (some have an upper case first letter). It's true that this isn't the traditional PHP way to implement this kind of functionality, but I would much rather have a strongly typed value object over a function which returns a string.
&gt; Hi mate, no not at all; Don't lie.
This... exactly this. Adding UUIDs to PHP is a great idea, but I feel like this implementation misses the mark. It's overly complex and non-optimized. This doesn't offer a lot over what `ramsey/uuid` for my use cases.
I wasn't. 
For reference: Here is my ImageError class class ImageError { private $totalTitleError; private $totalAltError; private $errs; public function setError ($titleError, $altError) { $this-&gt;totalTitleError = $titleError; $this-&gt;totalAltError = $altError; $this-&gt;errs = $this-&gt;totalTitleError + $this-&gt;totalAltError; } public function getError () { return $this-&gt;errs; } }
Honestly you used the term anti-* which kind of puts me off. It's our job as engineers to challenge each other, that does get heated sometimes. If all you pay attention to is the web wars of people going back and forth, well you're going to see people get a bit childish. Your opinions _will_ be challenged and you'll be forced to provide data to support your claims, not _"Yeah I did this at x company and it worked."_ I can't assume where the point of your article came from, but to me it sounds like you're deflecting a lot. Like someone's told you this and you took it to heart, not really your view on the attitude of the communities. If someone tells you that you really are the worst _they've_ met, that's not an excuse to turn around and say, _"Well I've met a lot of people who don't think I'm *that* terrible."_ If this person is being honest with you, even in a fit of frustration, then you should be looking at yourself for self-improvement. In the same way, if you can't identify use cases for different frameworks then you essentially do lack skill and insight. Edited for clarity.
Absolutely, when you have lots of evidence to support your opinion or approach and get shot down it gets quite annoying. The point I was hoping to make with this article is that the younger in their career amongst us can lose out and be put off Those of us who have been around a bit longer get the points you've made above, it's part and parcel of the journey 
Fair enough, I edited for clarity.
iPhones are only common in US, it has nothing to do with cost.
there's as of yet no way for php to distribute parts of the stdlib written in PHP alongside the C extensions. HHVM has done it for awhile, and SaraMG wants to do it for PHP, but it hasn't happend yet.
Sounds like something I need to try out instantly after my vacation.
Thanks I didn't know there was a php help subreddit 
Thanks!!
Yeah, that person is me.
Here is the quickest thing I can do. I can further optimize if you are interested but I think this is good enough for now. class ImageData{ protected $images; public function __construct($url){ $html = file_get_contents($url); $doc = new DOMDocument(); //circumventing error, decided not to use libxml_use_internal_errors(true); for this use case @$doc-&gt;loadHTML($html); //crawl page for images $imgCrawled = $doc-&gt;getElementsByTagName('img'); $titleError = 0; $altError = 0; $totalError = 0; //get attributes from all the images foreach ($imgCrawled as $img) { $singleImageData = new SingleImageData($img); $titleError += (int)!$singleImageData-&gt;hasTitle(); $altError += (int)!$singleImageData-&gt;hasAlt(); $totalError += (int)$singleImageData-&gt;hasError(); $this-&gt;images[] = $singleImageData; } } public function render(){ print "&lt;h3&gt;Image Data&lt;/h3&gt;"; echo "Titles missing: " . $titleError . "&lt;br&gt;"; echo "Alt Text missing: " . $altError . "&lt;br&gt;"; /** @var SingleImageData $img */ foreach($this-&gt;images as $img){ $img-&gt;render(); } $tE = new ImageError(); $tE-&gt;setError($titleError, $altError); echo "Total Errors: " . $tE-&gt;getError(); } } class SingleImageData{ protected $data; public $title; public $alt; public $src; public function __construct($img){ $this-&gt;data = $img; $this-&gt;title = $img-&gt;getAttribute('title'); $this-&gt;alt = $img-&gt;getAttribute('alt'); $this-&gt;src = $img-&gt;getAttribute('src'); } public function hasTitle(){ return !empty($this-&gt;title); } public function hasAlt(){ return !empty($this-&gt;alt); } public function hasError(){ return !$this-&gt;hasTitle() or !$this-&gt;hasAlt(); } public function render(){ echo "&lt;li&gt; &lt;strong&gt;Image Data&lt;/strong&gt; &lt;br&gt; &lt;strong&gt;Title:&lt;/strong&gt; " . ($this-&gt;title ?? "NO TITLE &lt;span&gt;X&lt;/span&gt;"). "&lt;br&gt; &lt;strong&gt;Alt:&lt;/strong&gt; " . ($this-&gt;alt ?? "NO ALT &lt;span&gt;X&lt;/span&gt;"). "&lt;br&gt; &lt;strong&gt;src:&lt;/strong&gt; " . $this-&gt;src . "&lt;br&gt; &lt;/li&gt;"; } } The most important thing I believe is to split the render and processing logic. Then by adding a simple entity class you can accomplish a lot by reducing all these img_prefixes. Also be sure to that methods are short, descriptive. Avoid having complex logic in loops. I believe its always better to say the actions in words when inside a loop. Like do this, do that, do third, loop. Oh this assumes php7 for the ?? operator. If you are using older version I am sure u can figure it out but since this is a rendering logic be sure to not set it as variable parameter, instead as a default render behaviour. This way you can extend to multiple rendering templates. Cheers
Thanks!!
This looks very similar in premise to Voyager except instead of an addon package its the whole thing or am I missing something?
i agree. the title is misleading. it should say symfony components. namely foundation, kernel, di and a couple more + their dependencies.
Why is everyone saying "thanks" in this thread?
Thanks!!! (Either a bot that does not like Markov chains, or everyone says "thanks" with one or more exclamation marks) 
the Sylius release date is in september isn't it?
17th I think? Maybe 13th. 
I was talking about poorer countries
Explain yourself? If you mean Symfony Framework it's very fast with an optimized and cached DI container and lots of other caches.
What is complex, and what is not optimized? Could you elaborate?
I agree, performance matters, but many people during the discussion saw it differently. I wrote the text as it stands to avoid that argument, because I feared that it would not be accepted as a valid one. A `UUID` is not a string, it is a 128-bit number. It is a common misconception to treat it as a string, especially in databases which makes them super slow and wasteful. The class adds the value that people do not need to care anymore what it is, for them its just some object that does the right thing. I understand that you, like Zeev, prefer procedural and no type safety. I on the other hand prefer OO with its auto-discoverable APIs, and type safety for all its good for.
Polyfills are ready as well as mentioned and linked in the PR. I will release them on Packagist if, and only if, the RFC is accepted. https://github.com/Fleshgrinder/php-uuid I think that the type safety provided by a class is superior to a procedural API without anything.
Why isn't there a link to the repository before you sign up? I wouldn't book a course like this without knowing that the author at least follows some good practices.
i think its very optimistic to think yii2.1 will come out this year. what do you say u/samdark ?
The capitalization is not inconsistent. All Enum constructors are using `PascalCase` whereas all others are `camelCase`. The Java approach would be to make the Enum constructors `SCREAMING_SNAKE_CASE`, but I believe that this convention is very wrong for methods. The differentiation directly tells you as a developer that you will always receive the same value upon calling any of the `UUID::Namespace*` constructors, whereas calls to `UUID::parse` will always yield different value depending on their input.
I'm really not keen on this "starter project" approach. The problem imo is that you discover its flaws as you use it, but by that point there is nothing you can push back to the original project or your fork, because the fixed scaffolding is now an integral part of your project. The scaffolding support itself needs to be a series of packages. 
My personal bugbear when looking for scaffolding these days is roles. A role defines things the user can do on the system. By that definition, a user can have multiple roles. A user identifies a person, and yes, a person can be both a supplier and a customer. A user can manage both stock and orders, while other users may be responsible for orders and not stock. So why do so many frameworks like this have a single drop down for a users role, forcing a user to be only one thing at a time?
Personally I don't think you should ever check against roles anyway. Roles should just be a way of defining a collection of permissions, they should be used to easily grant these collections not confirm ability. Everything should have a fine grain permission allowing for more flexibility. Otherwise you end up with lots if extra business logic checking all the various roles that my contain that specific permission.
&gt; symfony &gt; lightweight /facepalm
Add http://github.com/fastpress/framework also. I'm working on it locally and I might release it sometime this year
I know it's pedantic reply, but what happens when you then get the need for different types of admin? I'll shut up, because... yeah ;)
Signed up just to say thank you! 
Reflection classes are one of those classes in PHP core that I get excited when I use them. UUID class looks pretty neat too. 
I like how those polyfills gradually get better with scalar types, content visibility, etc. Really well done!
We need initiatives like this to stave off the wordpresses of the PHP world. Still, doctrine really should have made it a major version bump...
Yes, I agree with this. Permissions/Abilities/Capabilities are the level that defines what actions the user can do, or what the user can see. Roles are very much a business level collection of these capabilities.
Why 7.1 specifically? Or is it an initiative to keep pushing major libraries and frameworks to the latest PHP version?
You create roles for those, adding in ALL the privileges those admins need. This relies on there being privileges for everything, i.e. there is no functionality that is accessible ONLY through virtue of the user being in a role. Except, perhaps, there could be a role for a super-admin with access to areas that mere mortal admins cannot get to ever.
Nullable and void return types are a big deal when writing APIs. Multiple exception types are a nice bonus
Look for the link at the bottom of the page.
Sure. I'm just stating what I have found with other projects that do a similar thing and that I have tried. I'm happy to provide PRs for improvements, but this approach does not make that an easy part of the workflow. It's not about being right or wrong; it's just about knowing what you are walking into, pros and cons. To hit the ground running without having to go out searching for the best-of-breed in all the packages, then it's a great starting point. All credit due :-)
Bloody hell, that was quick! This is a great feature.
Oh, absolutely. We all have lives, and supporting open source projects we have brought to life can suck up a lot of time. 
No tests, no license, but a paypal donation button nonetheless :) 
The good: the UI looks nice. But considering rsync exists, I wouldn't recommend this. Also git and svn run on servers and are really good at downloading revisions and putting them on the filesystem quickly and reliably.
Wordpress at least [recommends](https://wordpress.org/about/requirements/) PHP 7 now.
I was scared this was a Go Lang-PHP weird hybrid
Man, this is weird lol: `activity()-&gt;by(auth()-&gt;user())-&gt;on($role)-&gt;withProperties(request()-&gt;except('_token'))-&gt;log('Created Role');` Is this what modern laravel apps look like btw? Haven't touched laravel since 4.1-2
&gt; PHP is a server-side scripting language used to craft a website or an application that stays true to all your codes and commands. Is that in contrast to a programming language like Entropy? http://andrew.wang-hoyer.com/experiments/entropy/
It's an open repo. If you want it before you sign up for a FREE course, Google can help you with that. GitHubs search feature is useful too. 
Just make it a single package, nothing wrong with that.
Why not simply link it? €dit: Okay, after typing it into Google I found it: https://github.com/KalobMTaulien/PHP-Login-System This is honestly pretty bad code. Why do you not use autoloading? Why no templating? Why no PSRs? Why do object classes hold a database connection? Why no dependency injection? Why no controllers or any structure like MVC? Why no front controller? Why do you not check for re-hash? Basically you wrote procedural spaghetti code. Do you really think that you should teach that to newbies, let alone take money for it? This is just one of those thousand tutorials which give PHP its' bad rep.
Or - and this may sound weird, but it does help - use https://deb.sury.org/
We're waiting on the Mongo extension I think :(
Why doesn't PHP provide official repos for the major server distros? RedHat/CentOS and Ubuntu (LTS)/Debian would be great. Remi and Ondrej are cool guys, but it's still more or less a one man show and thus a low bus factor.
I agree, that's what I stated in my initial comment. You shouldn't be checking for roles to confirm abilities as they will change over time and expose access that could possibly be unexpected.
Many do, but a role is not an ability its a way if granting abilities, which can/may change later. So you should still continue to check abilities not roles otherwise you end up with additional logic outside of implicitness of a permission grant.
Why wouldn't you just link it if someone asked for it and you're fine with them accessing it? Being obstructive isn't a great way to get people to sign up for something, free or no. 
Define waiting? Waiting for distros to pick it up?
Oh my god, you have no idea how helpful this was for me! Thank you so much. I was havings a really tough time with separating responsibilities and didn't know what to do. Creating a SingleImageData class was the thing in your code which really made it click for me. I have about 15 more functions I'm going to need to transform to classes and now I feel like I have a chance. Thanks so much!
Using [docker](https://hub.docker.com/_/php/) is also a viable alternative. Especially as FPM module.
By setting the 'verify' request option to false, you are skipping over a critical part of the whole TLS secured transmission. This is not something that should just be blindly put into example code -- if your machine does not have the cert bundle, you should fix that.
Why make it a major version bump? There are no Bc breaks and changing the major version most likely won’t speed up the adoption of the new version. The BC breaking changes are coming soon enough (scalar type hints, nullable return types, object type hint).
ext-mongo won’t be adapted for PHP 7, it was replaced by ext-mongodb. Until the software you’re using has been rewritten for the new driver, check out https://github.com/alcaeus/mongo-php-adapter. (Full disclosure: I wrote that library to ease transition for users of the Doctrine MongoDB ODM)
There are BC breaks. It'll give you a nice big parse error if you try running it on 5.6 (Never mind 5.3 which was the previous requirement)
Which is why composer won’t install it on 5.6.
Which doesn't matter unless you explicitly set your PHP version in your config, unless you're developing on a machine that's as out-of-date as the average server...
Most places won't let me link to outside of the platform, to be honest. They do they whole "sign up then you get access" kind of thing. 
Ah good advice thank you! I'll bring that up with our ops guys tomorrow 
You have lots of great points. The course is for newbies just getting into PHP though, not a full 10 hour course on all those awesome subjects. I'd LOVE to add all that in there, but I'm pretty certain it'll scare people off from taking the course. An upgraded version of this course with all that would be awesome though! 
Which would be the correct way to do this in the first place. If composer sees PHP 7.1 it will assume you want packages that are compatible with 7.1, not 5.6. If you want compatibility with 5.6, set a platform config, or better yet, run 5.6 on your dev machine as well.
I really don't understand why he is explicitly using Guzzle 5 and not the latest version, 6. To me, this is a very bad practice. Also, spaces before and after ` -&gt; ` might be one of the ugliest formatting things I've ever seen.
Some of those tricks to get a fully installed and running Jenkins container were very illuminating. Automating Jenkins setup phase has been a HUGE pita -- the software was just designed before the era of throw-away compute and it shows in the UI and processes for setup/configuration.
Yes, the code format is ugly and I will fix that.
In order ti be convenient, I skip the cert checking, but I agree with your opinion. So I will change the false to true then adding the message.
The default is true, so the extra lines of code are unnecessary.
Is Laravel 5.5 minimum of php71 now?
recommends maybe, but support goes back to 5.3 I think, I've seen some people say 5.2 is supported.
Glad to be of help ! Good luck :)
As an app and user base scales it is far easier for admins to create roles and assign multiple roles to users.
It would be good if the https://gophp71.org/ site actually said that - might help convince people.
A lot of people won't want to run Docker on production servers. Especially if they want long term stable servers, Docker CE's "1-month upgrade window between each [quarterly] release" makes for a lot of upgrades. https://blog.docker.com/2017/03/docker-enterprise-edition/
A lot of people won't want to rely on a one person run repository for production servers. (With all due respect and no offense meant to Ondřej Surý - it's a great service, thanks!)
Very true, but from my point of view a role !== abilities it's use to grant (and revoke) those abilities to users on mass. I'd rather have `$user-&gt;hasPermissions('billing.creditlimit.increase')` than `$user-&gt;hasPermission('billing.creditlimit.increase') || $user-&gt;isRole('BillingAdmin') || $user-&gt;isRole('SupaDupaAdmin')` Check for permissions, grant by roles ;) opened a can of worms with this one :D 
7.0, not 7.1.
minimum is 5.2.4. still. a version that was released an entire decade ago and went out of support 6.5 years ago.
Thank you for your answer. For me, this is not about type safety or not, though. We, in our team, love ValueObjects a lot and use them throughout our code base - I just don't think it's something that should be added to PHP Core, as I don't see how it adds real value. If I want to have that functionality inside a ValueObject, I can just wrap it into one on my own (well, or use a Composer package, etc.). What is really needed inside PHP Core is generating UUIDs in general, etc. So I just don't really get why not just add the demanded functions? The thing with the auto-discoverable APIs: Sure, it's great, but is it really needed? What if we just add the few functions that are needed and add them to the documentation? I feel that new stuff added to PHP should fit to the language how it currently is and also be a bit pragmatic. I would really avoid adding additional overhead to the core, but that's just really subjective.
Because it's trivial for anyone to compile the software themselves? There are official Docker images, too.
Then those people should simply compile it themselves, and subscribe to the security update mailing lists to know when to update. 
No kidding! I just had to go "fix" a WP plugin my company has because it used short array syntax and didn't work on PHP 5 point fucking 3. 
No, go for PHP 7.2 so we won't have to do this shit all over again in another month.
I agree. Right now it's just "why? Because all the cool kids are doing it!"
I don't think the upcoming 4.9 release will increase it's kinda version either. Honestly, I don't think they will make the php7-only switch for a few more years. I'm not using WordPress but I submitted a few patches to WP core to make it at least work well with php 7.2, and I could make all the tests pass except for one (https://travis-ci.org/Ayesh/wordpress-develop/jobs/266282372#L1222)
Thanks for this Kalob! Brilliant tutorial!
Thanks for the tips. I also recommend integrating phpstan into any PHP CI process as it is a fantastic static analyzer for finding bugs in PHP 7 code.
Whilst PHP in core would allow a lot more people to contribute to core, which would be very cool, for something computationally intensive, surely C makes the most sense anyway?
A lot of WP plugins require at least 5.3 or higher. I can't believe they really have many people still on 5.2. Matt Mullenweg said they've stuck with that to prevent people on older versions succumbing to security flaws, but it would probably be better to just given all those websites a big error message in their dashboard telling them to upgrade their PHP.
Why 7.1? It seems unnecessarily specific. PHP 7.2 is about to be released so it's already out of date. Should've stuck with v7 in general. 
I disagree. PHP does not follow any single paradigm, it actually follows them all. We already have value objects like `DateTime`, or stuff from SPL. Sure, they are not well designed or real value objects, but they come close. Another thing that I don't understand is why PHP should not evolve to become something better. Something that fits better the needs of the current PHP community. Look at how everything is evolving towards OO, and DDD. These are good developments, and they are here to stay with frameworks like Symfony who are promoting that. Why should the language not provide all the basic building blocks? Why do we have to collect hundreds of over-engineered Composer packages if all we need are a few value objects?
&gt; [C]onsidering rsync exists, I wouldn't recommend this. Upvoted for this part.
3 months, 7.2 is due to release December 31st, 2017. and nothing changed in 7.2, just bug fixes and performance improvments.
Pretty much every developer I know get PHP from this repo https://launchpad.net/~ondrej/+archive/ubuntu/php Or go with Arch, they always keep their packages up to date https://www.archlinux.org/packages/?q=php
Most of these projects have a huge bus factor anyway: the PHP bit is minimal
I didn't do much in the last year :p
Probably because 7.1 contains some of 7.0's unfinished business (e.g. nullable types, void type).
This sounds like you're headed in the wrong direction...
“PHP” is just a bunch of people on mailing lists and chatrooms. Remi and Ondrej's efforts could be reclassified as official, perhaps.
&gt; Especially if they want long term stable servers Doubt we are lucky, but we have been running Kubernetes for almost a year and we have had pods that have been running perfectly stable for months. Before that we ran our containerized apps on ECS which worked perfectly. Docker is super stable and a fantastic tool.
It's definitely not something I *want* to do.
It's a lot more readable like this: activity() -&gt;by(auth()-&gt;user()) -&gt;on($role) -&gt;withProperties(request()-&gt;except('_token')) -&gt;log('Created Role'); 
None of those examples are "native" extensions though. They're simply pulling in a foreign module and executing code from it. PHP unfortunately does not have this ability so you'd have to build a wrapper extension around your complied module basically that's written in PHP extension style.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I was expecting this to be a question being asked, but found instead an article with a number of dubious statements or claims * I've never heard 'localization' referring to what this article claims - in fact I've never heard in refer to anything in the software world except for i18n. * How is it that running a local version of a (L|M|W)AMP stack is listed as being 'resource reliant', yet containerization (which uses the exact same local resources) is not? * Same as above, except this time for being cost-free as a pro instead of resource reliant as a con. * While virtual machines theoretically can replicate live perfectly it takes effort to make sure that is always true - if you use containers it'll most likely be easier to keep you dev and live systems in sync given you can use the exact same Dockerfile / aci image for both. * Why are only containers considered clusterable as a pro? They all can be except maybe the hosted form depending on the hosting solution you use. Certainly you can cluster digitalocean droplets or EC2 instances or other full VPS systems. * And finally: &gt; The Concept [of containers] is the same as virtualisation, however, you don’t have a single machine. You have a container – that holds one, and/or, many machines. which is pretty backwards considering the point of containers is that they aren't virtual machines, they're contained environments that still run in the context of the host system's OS. (And are therefore constrained by it, but also require far less in the way of resources seeing as they don't virtualize a full system the way a VM does. A container holds no machines - that's rather the point. A container holds 1 or more running processes while it's 'alive' and holds it behind various walls and access control schemes that sandbox the process for security purposes, and these features are also handy for walling off the processes for the purposes of given it a very specific set of dependencies reliably. (Instead of letting updates to the OS cause your app to suddenly go from using v1.0 of some system library to v2.0 and causing a regression unexpectedly, you instead install v1.0 in the container, test it and deploy it and the containerized process wont be affected by the changes on the host system if it goes and updates that library for itself.)
https://github.com/kitech/php-go
Oh nice, that looks viable. Thanks!
I'd set this as per priority in your DB. I don't think a PHP app would process orders without going through the database. 
Why Jenkins? Familiarity? Why put together a modern setup on Docker and then invoke it through Jenkins? I'm doing that right now for a client and I keep telling them Jenkins is old and they need to stop using it. I would look at http://concourse.ci/ as a replacement for Jenkins. Jenkins just needs to go away.
This of course is a great effort but I wonder if such conversions are entirely legal. I mean, the legal term for this is "derivative work" and afaik only copyright holders can publish those.
I don't see how this is a trading platform. More looks like a poorly coded collection of wrappers for exchange APIs. Please correct me if I'm wrong.
The wrappers provide a standard interface to the exchanges. It is an early stage prototype, but "Trading Platform" is the goal for what I want it to become.
Fair enough. Would you accept an advise? Website that's linked from your github looks terrible. It's barely possible to navigate through it. Make it a little bit more pleasant and with more UX, otherwise people might run away right after navigating to it. 
And it behaves totally nuts
Why do you not expose an API using gRPC or HTTP and call that?
It's /u/sam_dark And he submitted PR himself saying ~2017, so I dont know...
I would focus on documenting the thing first....
At some point in life, when you look back on your own old code, you can say that about yourself too. There is always something to complain about, in own code or in code of others. The good stuff about the "complaints" is, that the receiver can widen his/hers mind. I always say, that attention for something I did (made) is always made out of love, even if it's on the negative side. Why bother to send something negative? Because the writer of such loves his/hers ideas about it, and want to share the new point of view. The positive part of it for you as receiver of such, is that you now have 2 more pairs of eyes to look at your creation. Even if you don't agree, you can do something with it. Make it more clear to outsiders why it is how it was made. And if you (partly) agree, you can improve something to make it even more better than it already was. All software is becoming better, and better each day, because of the reactions it gets. Reactions aren't bad, they are the motor to improvement. I won't claim I'm a bad programmer, but just a lazy one, who wants to pick all of your brains to make the best thing ever ;-)
The class is one way to go, but you could also try to make it a Trait.
You didn't really answer my last post. I mentioned in my first post already myself that there are ValueObjects like `DateTime` in PHP. Please explain what's the real use of having a OOP solution in this case. OOP is **not** always the right answer to all problems. `DateTime` is way more complicated, you can modify the object (add or substract date periods), you have different time zones, date formats, etc.pp. With this `UUID` thing, why not just having a function `generate_uuid(int $version): string`. I mean, in the end, that's all it's about, isn't it? We want a functionality inside core to generate UUIDs. What additional functionality does your OOP approach bring? And please, auto-discovering the API is not a valid argument in this case, because if it's only a single function, it's extremely straight forward and simple. As there's only a single function then, no real need to discover anything. And what's kinda funny - you name it yourself: "Why do we have to collect hundreds of over-engineered Composer packages if all we need are a few value objects?". Great, so now your plan is bringing all those over-engineered Composer packages that provide ValueObjects inside core? So instead of adding the Composer packages someone needs, we add all of them to core, so that just in case we need them, they're available? Please seriously consider the idea of just having a single function provided with the real functionality instead of the bloatware you want to add.
Quick Tip - Never Ever Echo out of an Class... use Return instead ...
 W What I miss, is more information for starting developers. Like : Use the same vocabulary for the same type of variable. The same kind of variable? Explain more about this "phenomenon". What I also miss, is the why. Why this is a good idea? Why is a usage of getUser() and getUsers() a good idea? This can be something valuable you know. Anyways: I loved reading it, and I think it will become a nice place for clean php code knowledge. 
Oh God yeah going back to code you wrote X years ago is always a fun one! Feedback is only ever good as long as it's constructive, it's when youngsters get flamed without any kind of educational content then it's just a bit harsh
True, it can be harsh, but perhaps I wrote the comment for the beginning developer who can learn that even the harshest comment has something you can learn about. I always laugh about myself when I now look back at how I handled those comments. They felt like an attack on my child. And did I just produced the prettiest kid ever made? Haha, I learn so much about ... me ;-)
Hi, some good points raised there - thanks for putting it across in a constructive way; too often r/PHP is just a flame war. - How would you refer to the method that I've referred to as Localisation? I've never seen it named anything else; however that could be some ignorance on my part. - I mention in the post that containerisation is localisation on steroids, so I thought that readers would naturally understand that it's an extension thereof - inheriting the pros and cons unless otherwise mentioned. An unfair assumption, given hindsight. - (see above with regards to costs) - My experience with making loacl servers true-to-live, is easy; I use Vagrant. Much the same as Docker has it's Dockerfile, I'll have a Vagrantfile. - Clusterable environments, other than in containerised solutions (and hosted), I've never seen done well, nor natively. Hence why the Pro for Containerisation stands. Yes, I should have put that on the Hosted analysis as well. I did mention in the post that I'm rather inexperienced with containers, and you seem to know a lot more than me on it. I won't even try and argue points on them, as I'm more than likely to be wrong; or making wild guesses. Thanks for the feedback though. As this was my first blog post, I'll be taking everything on board and hoping to improve things for the future
this link? 
Thanks. That is the website that comes with the platform. The website is part of the platform that can be be cloned from github. It is not the public facing website. I have not yet created that. If the the project starts to gain any traction, I will work on getting up a nice website to promote the platform.
This is certainly the wrong subreddit for this however, because each of the left joins is only joining to 1 row as far as I can tell, this is most likely an issue with indexes on the tables. So... 1) Use an [EXPLAIN](https://dev.mysql.com/doc/refman/5.7/en/explain.html) to figure out exactly what's going on and see if it makes sense and... 2) Make sure you have your indexes correct.
1) - I already have and it makes perfect sense. As mentioned, the problem is, that it's going through 123953 rows to find the ID.. I need that to go down. 2) All indexes are correct
I'm guessing this is maybe a snippet of a larger query? orders_products seems redundant as it's not in any of the predicate or the select. Also, removed the LIMIT because of the aggregate min() SELECT min(orders.orders_id) FROM orders LEFT JOIN orders_status ON orders.orders_status = orders_status.orders_status_id WHERE orders_status.language_id = '4' AND orders.orders_date_finished != '1900-01-01 00:00:00' AND orders.orders_id &lt; 4868771 Should give you the same results. Run an EXPLAIN and you can maybe pick some low hanging fruit for indexes.
Try pushing your selection criteria into the tables being joined to. This will limit the number of rows that need to be joined by: SELECT min(orders.orders_id) FROM ( SELECT orders_id, orders_status FROM orders WHERE orders.orders_date_finished != '1900-01-01 00:00:00' AND orders.orders_id &lt; 4868771 ) AS orders LEFT JOIN ( SELECT orders_status_id, products_id FROM orders_status WHERE orders_status.language_id = '4' ) AS orders_status ON orders.orders_status = orders_status.orders_status_id LEFT JOIN orders_products ON orders.orders_id = orders_products.orders_id LEFT JOIN products ON orders_products.products_id = products.products_id (Completely untested.)
Logged in just to say I have a similar issue - when I scroll a tiny bit, the article whizzes down to the end of the page. 
It's not a snippet of larger query :-) It's the complete query, but it's part of a function. Thanks for the example! orders_products should of course be removed - My bad! - It's being joined in depending on the active filters for the function. Same result, same slow query though :/
&gt; should of Did you mean should have? -------------------------------------- This is a bot account.
It's either should **HAVE** or should**'VE**, but never should **OF**. See [Grammar Errors](http://www.grammarerrors.com/grammar/could-of-would-of-should-of/) for more information.
Scroll to the bottom of the page linked by this reddit post.
That's properly odd, what browser, OS, etc etc are you using so I can try to replicate
Okay, well only you can see the columns you have available. You need to bring the number of rows down by making more specific. Something like: SELECT min(orders.orders_id) FROM orders LEFT JOIN orders_status ON orders.orders_status = orders_status.orders_status_id LEFT JOIN orders_products ON orders.orders_id = orders_products.orders_id LEFT JOIN products ON orders_products.products_id = products.products_id WHERE orders_status.language_id = '4' AND orders.orders_date_finished != '1900-01-01 00:00:00' AND orders.orders_id &lt; 4868771 AND orders.orders_id &gt; 4868771 - 1000 LIMIT 1 Realistically, your database shouldn't have trouble getting through 123k rows if your indexes are set up correctly. You might consider indexing the `orders_date_finished`. Side note: `orders_date_finished` should probably be null if it's not yet set.
This seems to spit out an error: #1054 - Unknown column 'orders.orders_status' in 'on clause' and I can't quite figure out why.. It should be working just fine.
Ah, it's because I didn't select the `orders_status` column from within the `orders` subquery. Edit: added.
Why are you joining the `orders_products` and `products` tables when you don't fetch any of their fields or use any of their fields in the conditions? Also, instead of selecting everything and then doing a `MIN()` call, why not order by the `orders.order_id ASC` and `LIMIT 1`. That would give you the smallest `orders.orders_id`.
It's a legacy system, as in really, really legacy-old. (5.2) Thanks for the example, the problem though is, if the ID needed is even lower than the (ID - 1000)
Could look something like this: SELECT orders.orders_id FROM orders LEFT JOIN orders_status ON orders.orders_status = orders_status.orders_status_id WHERE orders_status.language_id = '4' AND orders.orders_date_finished != '1900-01-01 00:00:00' AND orders.orders_id &lt; 4868771 ORDER BY orders.orders_id ASC LIMIT 1;
Hello @tech_tuna, I write PHP extensions for fun and profit. Although the linked project "php-go" looks useful, it's significantly lacking in functionality. However, depending on the complexities of your golang library then you may be able to sneak this in. For example, it doesn't support Namespaces or accessing class members, which could be part of your library's implementation. I recommend giving this library a shot and see how far you get with it as a PoC, but I recommend you have unit tests too, to check for regressions or bugs in functionality that php-go doesn't support or causes fatal PHP errors. Good luck!
My bad! Question updated with current query ORDER BY and LIMIT 1 makes the query even larger, that's why :-) It ends up going through 867679 rows instead of the original 120000 **EDIT:** Well, this is surprisingly a lot faster and seems to be the solution!
Here are all the issues that were most pertinent to the project: https://github.com/AdamCox9/nickelbot/issues I added one for Namespaces: https://github.com/AdamCox9/nickelbot/issues/32 and, for autoloading: https://github.com/AdamCox9/nickelbot/issues/33
 A couple of items... 1. Use an INNER JOIN instead, since you always require orders_status. 2. Insure field types match the way to are using them. Is language_id really a char/varchar? If it is an int, then the where clause shouldn't use quotes on its value. Also, do the field types match for orders_status and orders_status_id?
Laravel 5.5 offers LTS (long term support), so it's normal to have PHP 7.0 support (in my oppinion). In the next version I'm sure the minimum version will be PHP 7.1.
I think his point was using them as primary keys without thinking about the pros/cons of doing it. the reality is that for smaller scale apps UUIDs are not generally required for primary keys
Peter - Guzzle 6 was released well over two years ago. Why in the world would you write something about Guzzle 5? All that does is tell me "this guy doesn't really know anything about Guzzle. I'm not going to bother reading his blog" 
We'll try to make it.
[laravel-permissions](https://github.com/spatie/laravel-permission) by Spatie and [Bouncer](https://github.com/JosephSilber/bouncer) by Joseph Silber seem to be the two go-to permissions packages at the moment. There is [a great write-up here](https://laravel-news.com/two-best-roles-permissions-packages) which also mentions some of the older ones that have fallen out of favour. I think as Laravel includes more of the permissions framework internally, libraries can find it difficult to adapt without BC issues. Anyway, both of these work seamlessly with Laravel 5.4+, take slightly different approaches in their data models, and are both pretty good.
well, her English is decidedly "Indian", so you make the call
Glad you found your fix. :) I agree. My solution should have been slower from, but I've found databases quite often behave in the opposite way my expectations. The internals really are mysterious black magic boxes... Edit: Upon reflection I think it's quicker because your query goes "MySQL, get me all the rows, then get the smallest ID" whereas my query goes "MySQL, just get the smallest ID". I guess there's a lot more work for MySQL in the first query.
Property accessors is a much better way to go than adding a readonly keyword. It's a shame that RFC failed. I don't know the reasons but you could try searching the mailing list to find any discussions around the time (try externals.io if they have stuff from back then).
&gt; What is preventing it from being implemented? There wasn't enough votes. Jokes aside, introducing accessors wouldn't solve anything that can't already be solved in PHP. People are getting way to hipster with everything nowadays that they forget that instead of implementing 10 ways of doing 1 thing (which only makes things harder to maintain), using the one correct way is forgotten about.
Sure, but I have work to do, so I don't want to have to compile PHP myself.
So let's do this and host the repos at php.net!
username checks out
This assumes everyone believes magic methods are the correct way...
Can anyone tell me whats the difference in using readonly vs using a constant (that has been already implemented + got a visibiility options in 7.1)?
Why would magic methods be the correct way, and/or preferred over the example below? /** * CorrectWay */ class CorrectWay { /** * @var string|null */ protected $name = null; /** * @return string */ public function getName () { return $this-&gt;name; } /** * @param string $name */ public function setName (string $name) { $this-&gt;name = $name; } /** * @return bool */ public function hasName (): bool { return $this-&gt;name !== null; } } In PHP, a public variable can be changed. It's just how the language is constructed. To get around that we use accessor methods instead.
I think a readonly property is readonly from outside of its class, but can be modified from inside of its class. A constant can never be modified.
Hi @dragoonis, Thank you for the info. My Golang library will be fairly simple - it will just take a salt and a password and hash it. I want that operation to be fast and I want to "hide" the algorithm by putting it in compiled code i.e. not PHP. Hopefully that library will do the trick.
This is probably my favorite RFC ever. I really hope it is implemented someday.
I think you will be fine. You can tweet me down the line if you get stuck. @dr4goonis
&gt; Property accessors is a much better way to go than adding a readonly keyword. I wouldn't say either is a "much better way". Both have complementary use-cases. Readonly properties would be extremely common for a wide range of uses, so it'd be good to skip the repetitive boilerplate and pointless method invocation of writing the same getter over and over when all you need is a readonly public access.
``` /^([a-z]+)\s+(\d+)\,\s+(\d+)/i ``` Now you have capture groups and can use them like: * $1 - month * $2 - day * $3 - year In any order :)
The dull way: class DullWay { /** * @var int|null */ private $unix; public function __get(string $k) { switch($k) { case 'unix': return $this-&gt;unix; break; } return null; } public function __set(string $k, $v) { switch ($k) { case 'unix': $this-&gt;unix = (int) $v; break; case 'datetime': $this-&gt;unix = $v-&gt;getTimestamp(); break; } } } The fun way: class FunWay { /** * @var int|null */ private $_unix; public unix { get() ? int { return $this-&gt;_unix; } set(? int $val) { $this-&gt;_unix = $val; } isset() : bool { return isset($this-&gt;_unix); } unset() { $this-&gt;unix = null; } } public datetime { get() ? DateTime { return isset($this-&gt;unix) ? ((new DateTime())-&gt;setTimestmap($this-&gt;unix)) : null; } set (? DateTime $val) { if (is_null($val)) { unset($this-&gt;unix); } else { $this-&gt;unix = $val-&gt;getTimestamp(); } } } }
[0-9]{1,2})[ ]([0-9]{1,2})[,]([0-9]{4}
The code has a typo: MoneyHall instead of MontyHall
The missing part is, that this is a simulation, where the program randomly finds the next door. Random by a computer is not so random. As A human I can pick door nr 1 each time, out of the 3 doors. Still I had the choice, so it's random. A random generator will never do that, because it has diversity build in. (the chance it picks a different number is greater than the chance it would pick the same number again.) You don't know how the tv-show would pick the door where the car is located, so it is very hard to simulate. but... It is a nice try and a good simulation for "the unknown" ;-) (leuk bedacht)
This is interesting problem. I think the easiest way to grasp it is to start assume the odds for the correct first round choice is obviously 1/3 and then if you change the answer in the second round, the winning odds must be 2/3 (because the odds for the right element being already chosen is 1/3). 
&gt; so it'd be good to skip the repetitive boilerplate and pointless method invocation Not the case at all. According to the above RFC you can do this: class Foo { public $bar { get; set; } public $qux { get; } } $qux is readonly, $bar isn't. Hardly boilerplate; it's barely more characters than using "readonly".
So instead of using the available tools provided, you want to implement a new syntax? Your latter example still doesn't show any benefits at all, compared to my example. In fact, it only makes it harder to read.
XAMPP in 2017 .. Better install ubuntu via VB.. + bonus you will learn Linux what is good benefit.
You could use named capturing groups to clarify what your regex is doing: /(?&lt;month&gt;[a-z]+) (?&lt;day&gt;[0-9]{1,2}), (?&lt;year&gt;[0-9]{4})/i But even better might be to just use the php function for creating from a format (http://php.net/manual/en/datetime.createfromformat.php ): $date = DateTime::createFromFormat('F d, Y', 'August 9, 2015'); if ($date === false) { // invalid date } This has the benefit of actually giving you a DateTime instance and handling incorrect month names/invalid dates like 'February 31, 2012'.
That's one of the variants the RFC suggested. I don't think /u/LtAramaki read it, and probably assumed you'd be having to actually write a function.
Excellent, thank you!
Sure: - Chrome 60 - macOS Sierra 10.12.6
Except how your entire example could be rewritten as `public $name { get; set; isset; }`.
And in that single scenario, whats the difference from just writing `public $name;`?
`public $name` is equivalent to `public $name { get; set; isset; unset; }`, so the difference would be that it wouldn't allow unsetting of the property, just like your example doesn't. *Edit: After re-reading a portion of the RFC for another comment chain, I discovered that `isset` and `unset` implementations are implicit, which means to allow setting, but not unsetting, you would have to explicitly override `unset`.*
In which case, if we're getting technical, you still have not fully replicated my example. As I have type checking on my setter.
Is it normal that whenever I put in February 31, 2012 it directly moves to March 2, 2012? 
A constant is set in the code and can never change from its initial value. A readonly value is set once during runtime and then can never be changed. Therefore, a constant must be known ahead of time, while a readonly property doesn't. 
Ah, I missed that. Regardless, adding the typehint on the setter still nets you far less boilerplate for equivalent functionality: public $name { get; set(string $name) { $this-&gt;name = $name; } unset {} } *Edit: I should add that if we also get typed properties someday in addition to accessors, this goes back to being a one-liner again: `public string $name { get; set; isset; }`.* *Edit #2: Altered the code to reflect that `isset` and `unset` implementations are implicit.*
 Not exactly. A readonly property means that once it's set, it can no longer be written to by anything. Let's take an example from typescript: class Foo { constructor(readonly bar: string) {} function bam() { this.bar = "bam"; } } const foo = new Foo("baz"); console.log(foo.bar); // "baz" foo.bar = "bam"; // error foo.bam(); // error 
It may be barely more chars, but also makes very little sense, and communicates intent very poorly. - `{ get; set; }` is the same as writing nothing at all. - `{ get; }` implies not having "set;" means setting is not possible... **yet you have isset() and you can skip isset; and it doesn't mean checking isset() is impossible**. I know it's PHP's tradition to come up with awful syntax and semantics, but maybe we draw the line somewhere and try harder. Let's compare if we have both: class Foo { // Normal property. public $bar; // Readable as-is, with setter method. public $bar { set($val) { ... } } // Read-only. public readonly $qux; } /cc /u/captain_covfefe
I made a 'crowd sourced' version where every play is recorded to come up with an overall score: http://montyhall.dixo.net/ So far, out of 629 games: * Out of 198 games where the player didn't switch, they won 62 games (31%) * Out of 431 games where the player switched, they won 279 games (65%)
Related post and motivation behind this post: https://www.tomasvotruba.cz/blog/2017/06/05/go-php-71/
Try a reboot? I had this issue before but it was Skype hogging the port. I will also advise you to move away from XAMPP. The following are alternatives: - Vagrant - Find a vagrant-box (template) which matches your needs - WSL - Windows Subsytem For Linux - uBuntu - create a Dual Boot setup - Docker
implemented your way: $foo = new YourWay(); $foo-&gt;setUnix(time()); $bar = $foo-&gt;getUnix(); $baz = $foo-&gt;getDateTime(); if ($foo-&gt;hasDate()) { // do thing } implemented the fun way: $foo = new FunWay(); $foo-&gt;unix = time(); $bar = $foo-&gt;unix; $baz = $foo-&gt;datetime; if (isset($foo-&gt;unix)) { // do something } tl:dr; property accessors = ever-so-slightly cleaner code
Good point, thanks! I have added the post there to explain: https://www.tomasvotruba.cz/blog/2017/06/05/go-php-71/ If you find any more trouble, feel free to create issue on the Github repo: https://github.com/TomasVotruba/gophp71.org I got here by chance :)
These are methods though. Access syntax (like in C# for instance) and property access are different. 
It's so difficult reading this conversation without linking to https://preprocess.io/#class-accessors
Thanks! Must have been the spellchecker in my IDE that suggested this. Well spotted, I've updated the text.
thanks! I do address it in a note under the first example. &gt; Note here that we are assuming random_int(1, 3) is truly random. PHP does do a good job of having a real random value but it remains pseudo-random. But, for the sake of this example, it is good enough.
That's weird, that's the same setup as mine but I can't replicate. Would you mind messaging me anything else which might help me to replicate (and consequently fix) the issue?
That is really cool! I've bumped your counter by one ;).
What? Compare my "CorrectWay" with your "FunWay", which one is easier to read?
Holy moly, that's a mess :D
I might misunderstand but that reasoning is somewhat flawed. If you were to play this game with 100 doors and in the second round the host opens 98 door which have a zonk behind them, the odds are different. In that case you have a 1/100 change of wining when you stick to your original answer and 99/100 when switching. Checkout https://www.youtube.com/watch?v=4Lb-6rxZxx0 for more information on how the odds work.
I'm a bit torn. On the one hand I don't like having a syntax that tricks the reader into thinking getter and setter functions are actually properties. I'm referring to when you are not looking at the class, but are reading code using objects of that class. On the other hand from a reflection standpoint it takes something that you had to implicitly assume, and possibly incorrectly, into something you can explicitly know for sure. What I mean is, before you might assume that if a method started with get or set it was intended to be a getter or setter for a property, when in reality it might be a different type of function. This would make it explicit by adding relevant methods to the ReflectionProperty class.
http://php.net/manual/en/function.password-hash.php why don't you use this directly? you don't need to hide any algorithm, that's the secure way to hash passwords and compare hashes.
The FunWay is much more readable. The context of each method is 100% clear. You aren't making your own methods names as well, so the principle of least surprise is better fulfilled. Just because we aren't used to the suggested syntax doesn't make the current syntax better. In the end they are functionally equivalent though. I'd also point out that the FunWay syntax is way more semantically rich since the accessories methods are wrapped up in the property definition.
A read-only accessor is actually *less* characters (by a whole 1), and communicates the intent quite well to anyone familiar with accessors from other languages. It's admittedly less communicative of the intent than the blatantly expressive `readonly` keyword, but that's hardly a compelling argument when considering the myriad of other benefits accessors bring to the table, and the redundancy of having both. Your example defines `$bar` as a write-only property, as evidenced by the fact that it has no `get`. I'm not sure why you would label it "readable as-is", since [it isn't readable](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2#read_only_and_write_only_properties). The [`isset` and `unset` implementations are implicit](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2#automatic_implementations). Using `unset()` on a property that has no setter would [emit a warning and do nothing](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2#invalid_usage_of_issetunset). Using `isset()` on a property that has no getter would [return `false`](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2#invalid_usage_of_issetunset). This is very intuitive behavior. You wouldn't expect to be able to `unset()` a property defined as `readonly` under the other RFC either, as that's a write operation. And should there ever be a `writeonly` counterpart to `readonly`, you likewise wouldn't expect to be able to `isset()` it, as that's a read operation.
check on [regex101](https://regex101.com), there is a section where people submit regex, you might find what you need + its a great tool to test and learn regular expression.
99/100 should indeed be the correct answer: https://en.wikipedia.org/wiki/Monty_Hall_problem#N_doors
I guess you could say the same thing when reading the class. The getters and setters would change from implicit to explicit. This is an interesting duality where the definition of the getters and setters is more explicit, but using them becomes more implicit/magical. Previously you actually had to use magic to get something like this working. In a way I would be glad to see people not use magic for it. But at the same time it is a magical like thing to add to the language and if it gets added everybody will use it.
&gt; Your example defines $bar as a write-only property, as evidenced by the fact that it has no get. I'm not sure why you would label it "readable as-is", since it isn't readable. The isset and unset implementations are implicit. Using unset() on a property that has no setter would emit a warning and do nothing. Using isset() on a property that has no getter would return false. You wouldn't expect to be able to unset() a property defined as readonly under the other RFC either, as that's a write operation. And should there ever be a writeonly counterpart to readonly, you likewise wouldn't expect to be able to isset() it, as that's a read operation. Look how long it takes you to explain the rules of that flawed RFC. Here's my take on it: - No handler(s) = default behavior. - Your handler(s) = custom behavior. - Readonly = "can't set, can't unset" behavior.
1 - look up what algorithm is that function using 2 - find and use the exact same algorithm in other languages In that case, the default algorithm is BCRYPT. You don't need to write an extension for that. Most languages have a BCRYPT library already.
I know the Guzzle 6 is released and this blog post introduces the Guzzle 5 firstly. The Guzzle 5 is still maintained now.
It could be a service that blocks it. CMD -&gt; services.msc -&gt; OK Search for Skype/Teamspeak or anything related that could block that ports.
Security through obscurity is not a good idea, in cryptography it is frowned upon to hide the algorithm because this gives a false sense of security, you should always treat a system as if the attackers already knew the algorithm
&gt; I need more obfuscation/hiding than an approach like that. L-0-L &gt;I need to achieve security through obscurity. This is how retarded you're being.
This is Reddit not SO. You can also try the support channel of the Symfony Slack: https://symfony.com/support. But I guess what you're missing is a `NormalizerAwareInterface` normalizer to normalize your books
The key is not using properties for non-trivial tasks that might surprise another developer reading the accessing code. For the reader it shouldn't matter whether what they see is a property with a setter or just a variable.
&gt; With this UUID thing, why not just having a function `generate_uuid(int $version): string` He already told you: because a UUID is not a string. Are you actually attempting to comprehend anything before you click *reply* or do you just love the sound of your own keyboard?
Ah yeah, I'd forgotten about that, basically PHP is trying to be helpful for when you're doing calculations using dates, so if you have a date over the limit based on the month it will wrap around to the next date. The reason this happens is when you add on a month to a date that doesn't exist in the next month, so 30th January + 1 month will be the 1st/2nd of February depending on the year.
The RFC follows C# accessor syntax almost to the letter. And creating a setter while omitting a getter creates a write-only property (and vice versa for read-only) in every other language with accessors. Your take on it is counter to every reasonable take, in that regard.
Yes..I agree with this suggestion.
1. Why are you using XAMPP? 2. This has absolutely nothing to do with PHP 3. This is not a support sub
..but why use guzzle5? It's pointless teaching with an older version.
Me too, I'm more of a think 10 times write once kinda developer which usually serves me well. Granted I might write a lot less code than someone else but still achieve the same result 
I find the property-read attribute to work quite nicely: /** * @property-read string $gameNumber * @property-read GameTeam homeTeam * @property-read GameTeam awayTeam */ class Game { public $gameNumber; private $teams[]; public function __get($name) { switch($name) { case 'homeTeam': return $this-&gt;teams[1]; case 'awayTeam': return $this-&gt;teams[2]; Of course the properties are not really read only but the IDE will warn you if you try setting the values. And it handles magic properties as well as data types. 
&gt; At some point in life, when you look back on your own old code, you can say that about yourself too I say it about the crap I produced the day before 
C# has `readonly` https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly C# also doesn't have `isset` and `unset`. So to say this RFC follows C# "to the letter" is such a loose read of what C# does, I might as well say what I propose also follows C# "to the letter".
You're right, but sometimes we will maintain or look at the old projects and it maybe uses the Guzzle 5. So we have to know the Guzzle 5.
thanks bots, but we're gonna stick with should of here
&gt; should of Did you mean should have? -------------------------------------- This is a bot account.
It's either should **HAVE** or should**'VE**, but never should **OF**. See [Grammar Errors](http://www.grammarerrors.com/grammar/could-of-would-of-should-of/) for more information.
Nope, he definitely meant should of
Ok that makes a bit sense :)
&gt; C# has readonly https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/readonly C#'s `readonly` disallows writing to a property *even within the property's own scope* (excepting the constructor). We can debate about the actual utility of that behavior if you want, but the relevant point is that it functions markedly differently from the PHP RFC, where a `readonly` property could always be modified anywhere that satisfies the property's scope modifier. That's what makes it redundant with accessors, where C#'s is not. &gt; C# also doesn't have isset and unset. So to say this RFC follows C# "to the letter" is such a loose read of what C# does, I might as well say what I propose also follows C# "to the letter". C# not having `isset` and `unset` has nothing to do with the PHP RFC following C# accessor syntax. There are no parallels for them, so of course PHP doesn't follow for them. For everything with parallels, the syntax and semantics are virtually identical.
Checkmate mofo
&gt; C#'s readonly disallows writing to a property even within the property's own scope (excepting the constructor). Yes, I'm perfectly fine with that. The PHP RFC also triggers property accessors from non-public access as well. BTW, it seems people don't understand how common Value Objects are in PHP, and they're ALL full of readonly properties we currently write getters for. Explicit readonly properties would be a godsend to eliminating boilerplate, improving performance (via dedicated logic, separate from get/set properties), and code clarity from user's perspective. 
You can detect this by checking DateTime::getLastErrors() after creating a DateTime value.
Saying that all random generators have diversity built in is a bit of a stretch. I was going ask you for source, but honestly, you are just plain wrong.
Internals discussions (from a quick search on externals.io): * RO properties: https://externals.io/message/78284 * Property Accessors: * v1.2 "master thread": https://externals.io/message/63358 * isset / unset "failable": https://externals.io/message/63641 * internal accessor method visibility / callability: https://externals.io/message/63640 * Extra shorthand declaration: https://externals.io/message/63643 * Interfaces: https://externals.io/message/63642 * Consensus changes: https://externals.io/message/63963 * Final review: https://externals.io/message/64469 * Vote: https://externals.io/message/65011 * Revisit: https://externals.io/message/97450 NB: There seems to have been a large number of threads on property accessors - it's entirely possible I've missed some due to search results limits on externals.io. --- From the revisit thread, it looks like performance was a big concern for the accessors RFC. It's entirely possible that a big blocker to them right now is someone who's interested / has the time to pick up and run with the RFC. Getting RFCs, especially for big / complex features, through can be no small task. If you're interested in getting involved, I'd suggest sending a message to internals (it's an open list - anyone can subscribe an post)
I can't commit to PHP 7.1 for most of my projects. However, I will be able to commit to PHP 7.2. (Most of my projects are already on 7.0.) Does this count? 
&gt; 10 ways of doing 1 thing (which only makes things harder to maintain) Using this analogy, if your code is already doing something 9 different ways, then your code (via developers/standards) is doing it wrong, not the language. So adding an nth way is not going to make things any worse than they already are in the first place. &gt; using the one correct way is forgotten about. Pardon my bad memory, but what is the _one correct way_? --- If anything, adding the syntactic sugar of native readonly properties would be a lot cleaner solution than anything you could come up with in PHP userland. That said, as neat as it would be to have readonly properties, I can understand why people (like yourself) aren't keen to jump on the hype train. Personally, I'd rather see new features with more substance being added (first-class Enums), or more effort to go back and clean up some of the older APIs (yes, I'm referring to the age-old [never-gonna-happen] function renaming/argument order, etc). But, if people are going to focus their time on syntactic sugars like this, I wouldn't necessarily complain either. I like being able to write clean and concise code, and I feel this would open the door to doing so, in comparison to the existing ways you can do readonly properties. 
I would disagree. It is the most concise way to convey the meaning of the property compared to accessors; especially if the only thing you're trying to achieve is a near-immutable state. Now, if you need to add logic to the property, then accessors are the way to go. So I would argue that accessors vs. readonly properties really are distinctly different. They both happen to be able to do one thing the same way. 
7.2 ≥ 7.1!
Yes, I know that. I can't explain why I'm hiding the algorithm but I have a good reason. BTW, I am NOT attempting to roll my own crypto either, I will be using standard Go libraries. "Hiding" what I'm doing in a binary is sufficient for this use case.
What makes it's elegant? I'm not saying it's not, just that I don't know enough about UUID implementations to judge one way or the other.
Nice. If the big libraries enforce the modern versions of PHP like that, soon even the laziest companies will have no excuses anymore.
Sorry, I think I was bad a explaining again, the queue is simply for which order is being fulfilled, not being placed or processed. That all happens elsewhere, this is simply logistics of dispatch.
What are the main reasons that the vote is currently not passing?
For sure I read that. But the fact is, you can represent UUIDs very well as strings and I highly recommend doing so (debugging purposes, readability inside the database, etc.). Sure, you can also represent it as binary. It's called micro-optimization. ;-) And, my whole point and post was not about how a UUID should be represented at all. You could also just return a resource, an integer or whatever you like, if you want to represent it differently. So I have to ask you back: Did you read my post or do you just love the sound of your own keyboard?
You could for example read my comment and the answers following: https://www.reddit.com/r/PHP/comments/6xkc9q/uuid_rfc_now_in_voting_phase/dmhchoa/ I guess that's the main concern so far. It doesn't fit well into the PHP API and is overly complex. But unfortunately, it seems like rfussenegger is pretty resistent to feedback and comments. You find that throughout the discussion here. I still appreciate his work and efforts, we definitely need more people who want to improve the language and move things forward. Just his feedback handling could be improved imo.
It's just a ton of boilerplate, and gets pretty tedious to write. Having a more terse way to synthesize accessors is a nice quality of life improvement. Having it built into the language (as compared to using magic methods) allows for smarter tooling.
Go PHP 7.2
last time we talked we discussed the way issues/pr's are handled or better said abandoned being left unattended for months by a yii core developer till the original submitter gives up and abandons it too. have you achieved any progress on this too? there are 58 issues/pr with 2.1.0 millestone, 133 for 2.0.13 millestone and around 17 weeks till the end of the year, you would have to solve 10 issues/pr per week to barely manage the end of the year or produce a lukewarm 2.1 release with few difference from 2.0 branch and which will be stuck due to the bc policies.
For me PrestaShop is one of the best plarform for e-commercial.Yes,sometimes i have problems with modules. For examples one time i bought "Stripe" module from official site prestashop.com. I had many problems,this module didn't work normally.Then i bought same module,but from any prestashop site with modules. Now I am using this module https://www.modulesshop.com/en/prestsashop-modules/17-stripe-official-worldwide-payment which works correctly. Besides that it works worldwide and support few local payments methods. Maybe PrestaShop is not the best platform in the world,but for beginner this platform is simple.
Your butt's a mess. Preprocessors are beautiful, like nature intended!
That's the same reasoning as far as i can tell - you were either right with your first guess, or you weren't.
Yes, some issues tend to be left for later milestones because these are not critical for the next one or if there are higher priority ones. If the pull request is way to complicated, it tends to stuck as well. One need to allocate days to review it and often time could be spent on more obvious things that may give better results. 2.1 is in more or less active development since late summer. Of course, we can't promise releasing it this year since noone from the core team works on Yii fulltime and time allocated varies. I'm being funded by community and, thanks to them, I am able to allocate time on Yii but I'm taking freelance jobs as well to cover my expenses. Still, I the goal is to release 2.1 this year and we'll try meeting it.
Firstly, thank you for your article. I'm confused about all the methods of classes. Are they public?And I don't see any keywords about the "public" or private. I think it's important for us to read the code. BTW, the code format is not good. Thanks.
I agree with everything you wrote. I fully support UUID in the stdlib, I think this approach isn't the best though.
*PHP doesn't handle asynchronous tasks* I think the alternative way is use the pthread or multiple process. http://php.net/manual/en/book.pthreads.php http://php.net/manual/en/function.pcntl-fork.php
Cache the results
Why does this keep happening?
&gt; Cache the results I think &gt; You can install memcached You're not &gt; I currently run a small website On the same page... Huge PHP systems like symfony handle thousands of requests a second. Horrible bloated nightmares of shitty code like wordpress handle thousands of requests a second. Just including a sidebar on a small site is not worth caching, just write your code and be done with it. &gt; I would like to automate the sidebar list generation using PHP Is it generating the list that's the issue, or displaying it in multiple places? If it's raw HTML+CSS it sounds like you'll be adding to the sidebar manually anyway and you just want to skip updating it on all your pages by hand. (In which case all you need is a single include) Just throw your sidebar in a separate file, and shove `&lt;?php include 'sidebar.php'; ?&gt;` where you want it to show up in your page. That's it.
Its been said so many times, and the argument I always see is that the main hate is due to the older versions of php, people didn't use it as the older versions were bad for one reason or another, and because of that their views have stuck and they've not bothered coming back since. 
What are you going to generate it from? I presume you don't have a database, since you're working with raw HTML/CSS, and listing all the raw files in the folder is a good way to get hacked. Generally, every site out there does the menu manually, because it's so important. But ignoring all of this, have you tried a static site generator? Jekyll and Hugo are excellent at small HTML+CSS sites and sound like they'd fit your needs better.
pthreads are a nice addition but can't be used outside of CLI. The use case I'll describe is image resizing on the fly for instance (where you could generate multiple formats on another thread) but you are right, I should mention this.
My guess is because PHP is littered with inconsistencies in its API, but still powers so many sites. People just want a better experience.
Generally, the mix of OOP and procedural programming is not fun. I also expect you'll get plenty of responses along the lines of: There are "better alternatives" and too much legacy code. (funny, I could replace PHP with Java in that instance)
Because it's happening in Java and JavaScript and over in those communities, it turns into a big circlejerk about how the new language is the future. 
tried docker for a few months (dev and production via AWS ECS) and I'm done with it. we were running jenkins from within docker, building other docker images for our php and react projects. it was constantly having performance issues, builds were taking 15 minutes minimum (up to hours when it freaked out, until I killed the container instance and replaced it with a new one). so I started running jenkins on its own box (same instance type that it was the lone container on before) and builds were immediately taking half as long, and no weird issues plaguing jenkins itself. eventually I moved the projects out of docker and changed the jenkins builds so they made a tarball for the project and stashed it on S3... half as long again. so now builds are ~3-4 minutes, no docker shit to deal with, and life is much better. having CI via jenkins and running an automated test suite is definitely the way to go, but I'd recommend a hard pass on using docker to get there if your project is even the slightest bit complex.
1. Provide proper test setup (psr-4 peter\\test\\ ... same namespaces thereafter) 2. Stick to PSR-2 which is a supplement to PSR-1 (Class names MUST be declared in StudlyCaps) your classnames all begin lowercase letter 3. Maybe provide a vagrant setup to simple start an test your code 4. Split your tests. It is more wise to have multiple tests with fewer assertion, not the other way around. Way easier to spot the problem if smt breaks 5. Please don't use require in your test. Simply stick to psr-4 autoloading 6. let travis run with php 7.0, .1, .2 as well 7. Provide a more straight forward interface, you are using 'sendReq' every time with an ugly switch case. Why not simple having the provider (for each service) inside do the job? (DI - Dependency Injection) 8. You are creating hard coupled dependencies (like guzzle), which is pretty hard to test. Make you you can replace this for your tests (DI), so u don't have to actually send the request to those apis and keep your tests as unit tests. not integration tests 10. make sure you have your clover.xml ignored as well
&gt; Familiar JavaScript-like syntax. https://i.ytimg.com/vi/DnK1c1sHJqg/maxresdefault.jpg Seriously though, a LOT of effort went into this! Seems interesting. :-)
I mean, they are two completely different extensions. This isn't a php7 issue, they both were available before as well.
I think the real question is, why do you want it to be implemented in the first place? Just don't write to the property. It's not like it's just going to randomly happen because the property isn't readonly. You still have to actually write to it.
I Know someone mentioned upgrading from 5.4 to 7. So I thought this might be of interest
One god class that calls multiple third-party services based on a string passed in an array in the constructor feels a bit icky. Perhaps refactor to multiple classes, each implementing the same interface, and then providing a factory, if needed.
This page is a pretty thorough answer to the question of "why", including a list of changes. https://tht.help/tutorials/how-tht-compares-to-php
I stuck and won. I knew this whole thing was baloney 
Great suggestions!I will add these items in my TODO lists. Thank you for your help again!
I hope that this post was a result of a three day Labor day drinking binge.
This appears to be a sort of mash up of a more fully featured web *framework* (router, base stylesheet) and a templating system packaged as "a programming language." There are some odd choices here mainly because templating systems are already broadly available as pure PHP libraries and since this "language" transpiles into PHP you won't see any performance or type safety advantages. If PHP is so inadequate, and I say this as a *career PHP programmer* for what seems like forever, why not just use a *different language*? Or, if PHP is your jam (and there are plenty of reasons to choose PHP in the first place), write libraries on top of it. Is the syntax really that horrible?
&gt; It may be barely more chars, but also makes very little sense, and communicates intent very poorly. How so? The intent is clearly "I can get this property but not set it" which === "this property is read-only". 
Unfortunately, even if nothing changed, it's still going to be a huge pain to get package developers and hosting providers to upgrade to the new version.
I presume you've read the 'fractal of bad design' article? That has some legitimate gripes about the language itself (though most of it is out of date now). &gt; PHP is slow Pretty sure it's faster than most web languages out there. &gt; it has to read every file every time ! &gt; Opcache can be used limits the disk I/O Opcache has been bundled with PHP for years so there is no "can", it *is* used on basically every website. Complete non-issue. &gt; PHP community is split, everyone creates a framework, nothing can be shared Not really true. As you said composer has many framework-agnostic components. Plus the community has mostly settled on 2-3 frameworks - no one's using CodeIgniter or Zend these days. 
 public $foo {get;} is more concise than public readonly $foo;
I think you are missing my point. You need to organize a way to handle the developers and your time. Issues and PR's shouldn't wait months to get reviewed, it only causes people to stop contributing to the main project. I know you do it on your free time like the rest of us, you need to find a way to delegate and supervise a team of developers or ask for help about it.
You have asynchronous libraries for PHP, like reactphp or ampphp. They work with event loop. Pthreads is for true parallel processing. I now wonder if there is such alternative in nodejs, or they still "solve" this by spawning more processes
Thanks for the candid response. Obviously if you are happy with the current PHP experience, THT might not be for you, and that's okay. But there are a few points I can clarify: - The syntax, with all of its ideosyncracies, is indeed a problem for a lot of people. Especially the standard library, which is completely disorganized. Sure, I use PHP for personal projects and muddle through it because it's a practical choice, but I don't really enjoy it. Part of the motivation for THT is to bring it back to something that I would enjoy working with. - No other language (like the ones with arguably better designs) have the immediacy of web development like PHP. THT tries to have the best of both worlds. - No mainstream language seems to have web security as a central concern. They off-load the responsibility to the developers and library creators. The same vulnerabilities come up over and over -- it's something that languages can help solve, instead of leaving it open for human error (multiplied by millions of sites). THT offers some solutions here (LockStrings and built-in templates), which hopefully are a step in the right direction. 
I'm curious to know what parts you think are bizarre? Double-brace `{{ ~ }}` is pretty much the standard way of embedding expressions nowadays. The pepper `::` symbol is different, but it's just a way of embedding lines of code without having to close them. The advantage of having templates as functions is that they can be pre-compiled, and organized in any way you want, rather than having each one be in a separate file. This is not too different from JSX, or even just plugging your output into a heredoc. 
&gt; No mainstream language seems to have web security as a central concern. uh how out of touch are you? TWIG basically provides all the security you need. Unless you are actively doing something stupid that solves most of the problems. All of the other problems are caused by: - Articles from 2004 - Using mysql_query - Not using prepared statements ^ similar to - Using security libraries incorrectly - Thinking cookies are secure - Replacing sessions with JWT - Mixing templates and php code
Get a better photo before you share it to Reddit! Smile!
Template libraries do mitigate XSS, if the developer uses them. But it doesn't handle all of the other security vulnerabilities, like SQL injection. I've been doing web development for 17 years. It might be easier for us old timers because over time we internalized most of the best practices that you listed. But it's still a sign that web security has become incredibly complex, even for those of us with experience. PHP in particular is a veritable minefield of vulnerabilities, but it doesn't have to be that way. It's very easy to make a mistake without "actively doing something stupid." =) Rather than expose developers and all of their users to those vulnerabilities, why not make it easier for everyone as a default? That's what I am exploring with THT. 
Creating a new class on each iteration seems rather inefficient.
You're right. I should have to fight the damn language to solve my problem.
Concise does not always mean "shortest version possible". It means "brief **but** comprehensive". And at least for me, seeing "readonly" instead of "{ get; }" has a more natural and easier to understand meaning; therefore being both brief **AND** comprehensive. But, to be clear, I'm not trying to argue one feature over the other. I'm simply stating that I would prefer readonly if my goal is nothing more than making a property near-immutable. 
I like how it's made as an expression composing simple functions, I guess.
&gt; ALSO, you are assuming that the interface for the encryption algorithms will be available out of the box in all the languages I need to support and that each implementation will behave exactly the same way. &gt; pretty sure BCRYPT is the recommended algorithm for password hashing today AND is available in the majority of main stream languages. I suggest you read about BCRYPT because what you are trying to do is absolutely useless. If someone gets a hold of your source code on the server you have other things to worry about than password encryption. The amount of effort you put into this is effectively useless. You cannot reverse a string encrypted with BCRYPT with today's hardware in a reasonable time frame. 
Thanks for improving my points. I didn't read 'fractal of bad design', i'll read it right now.
memcache =/= memcached It's unfortunate these extensions share similar names.
&gt; OK, how about you do my work for me then. . . you seem to know what the requirements are better than I do. You give no reasonable argument as to why you need to write your extension with Go. It takes one minute on Google to find a BCrypt implementation for each language out there. &gt; I didn't say I needed BCrypt or just BCrypt If you want to hash password that's the only reasonable algorithm today. And if you think Go will give you more security think again, a good hacker will crack whatever code you wrote with a simple use of GDB by examining the stack frame.
Similarly, `phpredis` and `phpiredis` exist, which are 2 completely different redis extensions for php.
&gt; If PHP is so inadequate, and I say this as a *career PHP programmer* for what seems like forever, why not just use a *different language*? Don't forget that some of the newer features (e.g. strict typing) in PHP were taken from transpilers like Hack, which were built to extend beyond the at-the-time limits of native PHP. I mention this only to suggest that ventures like these hold the potential of benefiting PHP in the long run. Disclaimer: I really don't like transpilers personally. But, sometimes they are useful. 😊 Edit: fixed erroneous reference from HHVM to Hack re: strict typing. 
...This is an April Fools' joke, right? Just five months late (or seven months early)? I mean... &gt; foreach changed to for (el in list) { ... } &gt;List append syntax changed from [] = to @=. &gt;String concatenation operator changed from . to ~. &gt;Only // for line comments. No #. &gt;No ===. Instead, == is strict comparison. &gt;High risk PHP functions like eval are forbidden. &gt;Security workarounds are prefixed “dangerDanger-” for easier auditing. &gt;Only single-quoted strings. &gt;No null. (see “The Billion Dollar Mistake”) Try Result instead. &gt;No nested ternaries. &gt;No switch statement. Try a Map lookup or if/else instead. &gt;No while statement. Try for { ... } instead. &gt;No ++ or --. Try += 1 or -= 1 instead. ...Seriously? Why would I (or anyone) ever use this over PHP? Most of these are either cosmetic features (just get used to how it's done in PHP) or removing functionality (just don't use it).
Always afraid to post in this forum because there is always some numb nut that is trigger-happy with the down vote button... Anyway, how about that unless you use the SPL library, that arrays are both associative and indexed with no differentiation. Related are inconstant return types and typing in general. I didn't study CS and I'm happy enough with what PHP provides but I sort of suspect that muddied concepts and ambiguity are what makes academics ignore the language. You can't teach CS with a language with that sort of carry on.
Looks cool. Any idea what license you're leaning toward applying to the project?
What do you mean?A better photo?
Because computer science is literally built upon this type of thing? All programing languages are merely abstraction layers to interface with a computer. Modern programming languages are multiple layers of abstraction; take PHP for example: ASM -&gt; C -&gt; PHP. People experiment with new languages and the semantics and ergonomics that excel theoretically propagate into other languages and it's a good thing for computer science and programmers overall. For instance Brendan Eich has stated certain parts of ES2015 were inspired by CoffeeScript, most notably perhaps is the "fat arrow" functions (`() =&gt; {}`). 
Good point, PHP is a very specific language that is web oriented, added this to my list ;)
Ok, I know whay do you mean! Thanks.
To be honest, I didn't looked further into nodejs since it gave me too little control over concurrency. I ended up using elixir since I needed to have multiple processes runing in parallel (video encoding / uploading). But i'll take a look at ampphp/reactphp to see if it can handle some edge cases but I'm not sure that bending a tool to fit a need is a good thing.
If you were willing to use a compile to PHP language, with all the caveats that entails, then I think [Haxe](https://haxe.org/) is still the premiere choice, just in terms of ecosystem and mindshare.
Hey guys, THT is pretty cool but it's got some issues and inconsistencies so I created a new language that compiles to THT, called BHB. You don't need to know THT to use BHB. It has a familiar PHP-like syntax. It brings back $ sigils and the -&gt; operator for method calls and string concatenation is changed back to . from ~. When you update your BHB code it is automatically transpiled to THT which is then transpiled to PHP which is then preprocessed into HTML. The really innovative thing about BHB is that it comes with its own preprocessor called DHD, that has a plugin-like structure so you can add third party language features like switch statements. The switch statements will then transpile into standard BHB, and then into standard THT, and back into standard PHP so you never have to worry about compatibility! BHB also comes with its own framework called Baravel which has a familiar Node/Express-like syntax and transpiles into actual Laravel.
Hey guys, I tried BHB and its pretty good... i used it as the basis for my new languange called ZHZ. All the same features as BHB-&gt;THT-&gt;PHP but with new syntax for comments.
Have you seen any real world security vulnerabilities caused by using JWTs to replace sessions?
Congrats on shipping. These things are a lot of work!
https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/ Here is what I feel is a pretty decent reason why you shouldn't use JWT for sessions. http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/ but hey; if we want to split hairs we can call the security guru in. https://news.ycombinator.com/item?id=11895440 He sums it up nicely, &gt; * Using JWT for authorization, particularly for one-time use == GOOD &gt; * Using JWT to represent long-lived persistent session state == BAD 
We JavaScript now.
Here are some of the more substantial features you might have overlooked: - Totally organized standard library - String methods all support unicode - Modular namespacing by default - Consistent error reporting with full stack traces - LockStrings to prevent injection attacks 
I've used Haxe for non-PHP development. In comparison, THT has a looser syntax, and it has the same update-and-refresh workflow that PHP has. There's no extra compilation step.
Thanks. I haven't really gotten to the point of figuring out the subtle differences between licenses yet. I'm open to suggestions, though.
+1. Your new comment syntax is what I'm building JSJ on -- it allows executable JavaScript inside of ZHZ comments.
Never code and drink ;-)
MIT
Amazing thing you build there. I hope you get enough audience so it will keep alive. There are more projects aiming at making PHP better. (example: https://github.com/nkkollaw/zubr/) For me personally, I stick with what I know (PHP, GoLang, Java), but I admire your passion to try and improve "the Beast"
For what I understand, is you need to change some stuff into a dependency injection kind of style, and perhaps also an configuration array, which tells you more info on the magic_number that is in adapter_code.
https://www.youtube.com/watch?v=RFZrzg62Zj0
&gt;[**OMG WHO THE HELL CARES! [0:04]**](http://youtu.be/RFZrzg62Zj0) &gt; [*^bnz0*](https://www.youtube.com/channel/UCRLkaV1ty98pK-rtb7UBigQ) ^in ^Education &gt;*^12,484,778 ^views ^since ^Mar ^2009* [^bot ^info](/r/youtubefactsbot/wiki/index)
I didn't say it is in direct relation. However memcache is not supported in PHP 7 - I know, it is long dead since years. :) I also understand that they are different extensions.. my problem is that they are for the exact same thing (communicating with a memcached server), some compatibility between them could have saved me (and I believe others) a few days of work time and years of lifetime expectancy. :) Especially as the real issue only comes from a single enum choice for flags, everything else is perfectly fine or at least configurable (like the possibility of disabling the igbinary serialization).
So build my own index of strings to numbers essentially? Not sure if that's what you mean? I was thinking I could make the adapters self indexing and load based on namespace to register themselves and map their adapter code back to them?
"PHP is slow, it has to read every file every time !" I would state it like: PHP has to read every used file every time ! File reads aren't always slow, depending on your operating system, and the way it caches stuff. (it was in the old days, but we advanced) "PHP community is split, everyone creates a framework, nothing can be shared" Every modern programming language has multiple frameworks to choose from, which is an advantage. You can choose what feels good to you and fits your needs. People like choices, or else we would all be driving the same car, and eat the same food ;-) I would rather see that the PHP community had some balls to make new functions with correct parameter order, and deprecate the incorrect ones, so the language would become a mature one. 
I'm inspired to create DHD to reach distant parts of the galaxy to fight snake heads.
It's not unfortunate, they wanted a rewrite and gave it a different, but similar name as expected; very same situation for mongo vs mongodb, mysql vs mysqli, ereg vs preg. I understand that someone wants to write a better extension, indeed I would encourage it, but I don't agree on not giving a f*ck about compatibility with the previous extension. For example there are lot of PHP 4-5 code that can run on PHP 7 in parallel, but you can't do the same with these two extensions for example - I have to add the mongo vs mongodb change was far worse, had to wrap all the layers of it in adapters, converting BSON to array, MongoId to ObjectId and in the other way around.
part 1 If i'm correct you have this adapter_code, which is 1 number, like 23. It will always load config-array (or object) 23. You can put inside the config, which number is loaded and even a string what it represents. If I am wrong you could still do that for every config-array you have Part 2 the adapter class should be injected (DI) and behave accordingly It can behave to the injected model and injected config-array I would get rid of a lot of constants, and put them in the config-array, or something along the way. 
Luckily I have my own PHP implementation for Redis communication. Meanwhile working on the $subject I was thinking of writing my own PHP implementation for memcached as it is also providing a simple textual protocol. I know I would loose pooling features and what not, but the Redis lib is working quite good under heavy load, so... :)
It's not about doing it wrong, it's about the new generations and how they learn the language. Just look at web browsers, every big company wanted to do their own things and today we live with something called "cross browser compatibility". Nothing good rarely comes out of more options of doing one thing on the basic level. It's important to respect the tools provided and how they do things. Look at jQuery for example. "I work with jQuery but I'm not very good at JavaScript". Do you hear how stupid that sounds? jQuery is a wrapper for JavaScript API's. This is what laravel is basically doing to PHP nowadays. PHP is a scripting language. A really good one at that I must say. It has a really good base. I'd hate for it to go under just because hipsters vote in features that exists in a different language. It's not just about accessors, it's as a whole. If PHP becomes too diverse it will be back at the day where everyone complains about PHP being a mess (remember 5 years ago?). And personally, accessors makes the code harder to read imo. Just look at the example above in "FunWay", double declarations for just one variable, overriding get/set for a variable inside of a different variables scope, etc etc.
**PHP is bad for long running process** Actually, not true. It has never been designed with that goal in mind and in it's early days the standard modules had a lot of issues with memory leaks. But those memory leaks were mostly fixed in the early days and since PHP 5.3, when a GC API was introduced, there are no problems running daemons in PHP. Sure, you have to write the code a certain way, handle errors, clean up after yourself explicitly (close files, network connections, check for connection availability, unset large data sets by calling "unset", have multi-level error handling) - y'r golden. And these days PHP 7 is rock solid in that regard. It is mostly poorly developed 3rd party libraries and PHP extensions that result in memory leaks these days. But if you stick to known and quality stuff, report any memory leaks you find and follow the rules on daemon development - you have to be a knucklehead to bork it up.
As someone with a serious case of JS fatigue, this hits closer to home than I'd like to
Yeah, PHP is slow is a 100% myth - right now it beats the shit out of every direct interpreted competitor - Python, Ruby, NodeJS. And that's without the JIT, and that's being worked on right now. Go is in a different league - it's a compiled language, so comparison does not apply here.
* It's only maintained by one person. The "Bus Factor" rating is through the root. * It isn't battle tested so it will have edge case bugs. * It doesn't appear to have any tests so it will have edge case bugs. * I can't use existing PHP libraries or extensions. * It's not supported at any web hosts or PaaS providers. * I can't recruit developers who have experience with it because it's not out of beta. * It adds layers of unknown complexity to any build. * It feeds the retarded JavaScript bullshit circle jerk mentality of development these days. I can't make a good business case for it to management for all of the above reasons therefore I can't use it in production. It won't last or go anywhere.
What about compromise with oldfags: add procedure approach alongside classes? 
I have payment gateways with lists of constants. By keeping the constant names consistently prefixed, I use reflection to pull them out as arrays when needed as arrays. Put into a trait, it can be used anywhere: https://github.com/academe/Omnipay-Wirecard/blob/master/src/Message/HasConstantListsTrait.php
Ok i will add more : PHP is happy with 1 + 'a' (weak typing) and i know the joke about good programmer are carefull so carefull they never miss a free when they do their C i think you get the joke. UTF8 is not a first class citizen you have to resort to mb_* functions. PHP still has new design error (at least one) var_dump(1 &lt;=&gt; 2 === 1); doesn't parse, so &lt;=&gt; look like an operator, smell like an operator but doesn't combine with others operators. 
wow. this guy managed to post two shitty links to their website in two days. I'll be damned if he won't post another one tomorrow, "My new improved library", with spaces removed from around `-&gt;`.
Most of these problems exist for other, similar tools. And, those tools probably also have other folks phrasing their feedback as poorly. Good thing language designers are so full of hope or this would be a bleak undertaking...
&gt;No “variable variables”. Required for some generic solutions though. &gt;No ===. Instead, == is strict comparison. How do you compare value objects then? &gt;No warning suppression via @. IIRC the whole deprecation system done in Symfony relies on it... &gt;High risk PHP functions like eval are forbidden. Cannot make https://github.com/nelmio/alice work then :/
Also most of the time a queue system is more than enough.
&gt; PHP is bad for long running process Show them this https://twitter.com/boden_c/status/709894701479038977
That's fine... But "familiar JavaScript syntax"?! Come on!
&gt;PHP is bad for long running process Truth is, the issues you get with long running processes in PHP are the same ones you get in Java, Python, Ruby or nodejs: memory leaks. If you want a good long running process, look at Haskell or Rust, otherwise forget it. &gt;PHP community is split, everyone creates a framework, nothing can be shared That's true, but I would argue that it is much less split that Ruby or nodejs. The community is much more mature (compared to nodejs), there is a good core pushing for framework-agnostic tools/libraries. Framework nowadays are not more than a bit of a glue between components (except some like Laravel). We left the framework era for the Composer era. Also the PHP community is very sensible to Semver, there is very little non-semver libraries and it is in general well enforced.
Nothing is perfect, especially when it's still in development. Calm down, hop off your high horse and try providing some constructive feedback.
&gt; THT has a familiar JavaScript-like syntax. And I'm out
&gt; No other language (like the ones with arguably better designs) have the immediacy of web development like PHP. I'm a PHP fan and will use it over almost anything else for web but this statement simply isn't true. Source: https://elixir-lang.org/ 
+1
I'm gonna wait for BHB v2: the ground up rewrite because we didn't fucking know what we were doing the first time. I guess it should be 12 - 18 months out?!?
\&gt;14.2 minutes \&gt;Video is 26 minutes \&gt;wordpress.tv
The ``` -&gt; ```problem is only existed in this library because this is my first project.After that, this problem is not presented anymore.
Looks good!, bit confusing having the same name as https://github.com/kreait/firebase-php though. otherwise I might have found it when searching a month ago for this exact solution, there was a need for some more solutions, as his appeared to be the only choice when i looked. 
Thanks!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I personally like MIT. But I've found sites like https://choosealicense.com/ and https://tldrlegal.com/ very helpful for researching options. 
Whats this about? Some more information in the video, or here would be nice. So its just a speed up video of ppl sitting in front of each other.
&gt; No switch statement. Try a Map lookup or if/else instead. What is a Map lookup and how does it look in PHP?
The extension implementations are much faster than any PHP implementation could ever be. See Predis for probably the best maintained lib, it supports phpiredis to accelerate itself.
[PHP 5.2 O.o](http://php.net/eol.php)... Also using a fast hashing method (`sha1`) for your password. Probably vulnerable to XSS too. 
 function label($index) { $map = [1 =&gt; "one", 2 =&gt; "two"]; return $map[$index]; } 
&gt; feels a bit icky That's not a good justification for making a change.
A queue system is another way of designing a solution when you need async work doing, it has its own drawbacks though.
&gt; Always afraid to post in this forum because there is always some numb nut that is trigger-happy with the down vote button... Oh God, I know, right? Imagine how awful it would be if you got a downvote. Personally I'd kill myself.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Can you stop erroneously capitalizing every occurrence of *SPL* in class names.
As this is just the [same OWL thing as last month](https://www.reddit.com/r/PHP/comments/6ppvgt/owl_a_better_php_for_singleserver_apps/) let me repeat my comment: &gt; &gt; // The Db module knows how to safely escape placeholder values. &gt; This is going to be good... ~~https://github.com/joelesko/owl/blob/master/owl/lib/modules/Db.php#L31-L36~~ https://github.com/joelesko/tht/blob/master/tht/lib/modules/Db.php#L31-L36 &gt; Suuuuuuure where we are going we don't need to disable emulation of prepared statements or set up the connection encoding. &gt; &gt; By default, ~~OWL~~ THT defends against the most common security risks. &gt; I am not going to test whether that is the case thank you very much.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [joelesko/owl/.../**Db.php#L31-L36** (master → afae905)](https://github.com/joelesko/owl/blob/afae9054816aeddfb0686e333126df6162b5e8d4/owl/lib/modules/Db.php#L31-L36) * [joelesko/tht/.../**Db.php#L31-L36** (master → afae905)](https://github.com/joelesko/tht/blob/afae9054816aeddfb0686e333126df6162b5e8d4/tht/lib/modules/Db.php#L31-L36) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dml5hdj.)^.
You won't believe it. The guy is named "Pedram Habibpiran". Initials PHP. Nothing to do with PHP. But it is PHP. 
No people volunteered so far to do the job except for Twig and ElasticSearch extensions maintenance. If anyone will, I'll organize that.
TypeScript + Vue cured the fatigue for me.
Yes, 5.2 and it has reasons. Many big companies have sites on old version of PHP and they can't simple ways to update their backend environment. So and some cheap hostings have servers with old PHP, unfortunately.
When do you guys usually use Firebase ?
What serious company would run a website on a PHP version which is not supported since, like, 6 years ??? Same for hosting, when you can have a DO droplet à 5$/mo, it's hardly an argument IMO 
&gt; Many big companies have sites on old version of PHP [citation needed] Also you didn't address any of the security concerns I have.
I do not argue, all this is very stupid. But this is reality.
&lt;strike&gt;PHP EOL was 20060613, more than a decade ago.&lt;/strike&gt; [Edit] Sorry 20110106 per http://www.php.net/eol.php
What's the problem with sha1?
Well, I can imagine that there can be old legacy applications that for a given reason, could be too costly to upgrade. But a simple landing page, sorry I don't get it. 
I don't understand you. What's the problem? It is PHP 5.2+ and not -. For such a small project is not a rocket science supporting PHP 5.2. It is not a killer feature. It's a small advantage.
It's not a problem in itself, but by targetting this low, you're missing a lot that modern PHP has to offer, `composer` if I had to name one ;) 
It's not suitable for hashing passwords because it's too fast for that purpose. Also (somewhat related) your code is vulnerable to timing attacks.
I think you are replying to the wrong person :-)
They can be nice when rapid-protyping SPAs but I have found now that my app is built that I'm slowly wanting to move it to a more-defined REST API because there are some double-edged "features" of Firebase (e.g. no real data schemas, all "migration" stuff in the client).
Oh, thanks for explaining your opinion. This is only an alpha version and I know about these problems. I did not try to create the most secure system. The part of authorization in the future should be completely modified. This is a temporary enough good solution, I think. Those who want to improve the project as soon as possible can create a pull request or an issue.
Ah right. The infamous "temporary" solution. You just made it public without any warnings about the fact that the project is not secure to use. That is hardly good enough.
Two zeros before the version number speak about this, as well as the bolded phrase in README - "Be careful! While that is an alpha version.". It's an alpha version of open source. If someone wants the best, they can do it better.
I would hate myself for making IE8+ landingpage in 2017. And my client ofc. Dir structure looks weird :( 
Unable to have a php script running for a long time is usually caused by not knowing what a memory leak is
Obviously all of your files in your project. Assets folder, protected runtime will need write permission. The yii framework will also need to be on your server and your bootstrap fie (index.php) will need the path to the framework. 
Configuration and classes in web root, No autoloading, no Composer, no PSR-2, no namespacing, non-class code in class files, using directories as page names, using rand() for randomness, third party library code in the repo, no tests, rolling your own password management... I sincerely applaud your work and willingness to share -- but this is five years out of date, at best. You should probably checkout some modern resources for PHP development, if you ever want this to get traction. There is no good reason to support such an ancient PHP version and sacrifice all the advancement made.
I am sorry I was incorrect and thank you for pointing it out, I will, of course, try to be correct from now.
because PHP is a horrible language but still valuable ( deployment on cheap hosts, C extensions). 
 1. HHVM is not primarily a transpiler. 2. Strict typing was not taken from HHVM.
If there is a *de facto* standard why do we need an *official* one? Particularly when they aren't similar at all?
 1. This library requires no features of the C API. 2. The implementation is not battle-tested out in the wild. 3. The implementation has pointless helper methods like `toHex`. 4. The RFC does not convince me that existing libraries are insufficient or inadequate other than they aren't shipped in PHP by default. 5. *Edit*: I would like convincing cross-platform tests, including endianness, as well. My opinion is solidly in the "anyone who votes yes for this RFC does not fully understand the impact this decision has" camp. Would I like UUIDs in core? Yes; just not this attempt. And there is nothing wrong with features taking multiple iterations and attempts before making it in. I encourage the RFC author /u/rfussenegger to continue this effort.
1. Wasn't HipHop (the precursor to HHVM) originally used to transpile PHP-like syntax to C++? 2. Hack¹ was announced on 2014-02-20, while Andrea Faulds's RFC was only put back under discussion on 2014-12-31². It wasn't till after 2015-09-30³ that the RFC was voted on (1 year, 7 months, and 10 days) after the feature first surfaced in Hack. Seems disingenuous to suggest Hack and/or HHVM had nothing to do with strict typing. ¹https://en.wikipedia.org/wiki/Hack_(programming_language) ²https://wiki.php.net/rfc/scalar_type_hints#php_rfcscalar_type_hints ³https://wiki.php.net/rfc/scalar_type_hints#changelog Edit: I'm assuming /u/dohpaz42 and /u/morrisonlevi are referring to scalar type hinting, when they say "strict typing".
i have volunteered and submit pr's/issues for gii and yii2 core. last time i even proposed you to create a reviewers team to read and fix pr's before they get abandoned by the people who submit them.
It says pretty clearly on project page that it's v0.1.3 (Beta) and that it's currently meant for early adopters. 
 1. Yes, but that's not transpiling in the direction the op was talking about. HHVM does have a transpiler *to* PHP, but maybe that project was sent to the graveyard because all references to it on their docs website are broken. 2. I am not implying it "had nothing to do with" strict types, rather it wasn't "taken" from. There is a significant difference. Also, if you check the history it is one of the RFC with the most attempts, many of which predate HHVM.
1. Yep 2. Yeah, it definitely seems to have undergone a lot of discussion, some of which predates the Hack announcement. I don't want it to seem like I'm saying Hack is why the feature landed in PHP (and you're right that implying it "had nothing to do with" strict types, rather it wasn't "taken" from are different) but rather that the spirit of the previous comment seems valid to me. That being: new languages can and often do push existing languages and tools in a good direction. HHVM was good "competition" for PHP, in terms of performance, which may have influenced PHP 7's performance gains more than some would like to admit. That's a good thing, and one of the main reasons why I think discounting new languages and tools (even not implemented 100% correctly or efficiently) is unhelpful.
Thank you. I updated my comment. 
Sara G is working on a Hack-to-PHP transpiler: https://github.com/phplang/phack
PHP 7.1 in 5 minutes: http://php.net/manual/en/migration71.php
One's official, defacto is not. Hence why I said *standardized*. Better to have everyone singing off the same hymn sheet than to have potential for discord.
... you missed the point. I suggest looking up what a "de facto standard" is. And, ironically, by making an "official" standard that isn't compatible with the de facto one we would create discord...
I think that my answer on Internals answers your question to a great extend: https://externals.io/message/100347#100389 I agree that OO is not always the right answer. A good example is `assert`, it just makes no sense to have a class here. However, I think that it makes perfect sense for UUIDs (be sure to read my post on Internals). I do not believe that my proposed solution is over-engineered. As I wrote on Internals, it is probably the smallest implementation of all that are provided as part of standard libraries in programming languages. Compare it with [`ramse/uuid`](https://github.com/ramsey/uuid) which has ~50 classes to provide the functionality. That are at least 50 reasons to change. This implementation has 2; while the exception is not worth mentioning as it has no logic at all. Other than that, yes, my plan is to bring more useful functionality into PHP's core. I think it makes sense that the standard library of a high-level language provides the basic building blocks (our definitions of what that is differ highly) to ensure interoperability between userland implementations. Basically what the PHP-FIG is trying to bring to PHP, and what other languages have. PHP is not C, not anymore.
1. True, what exactly is the point here? 2. Yes 3. I disagree with `toHex` being pointless, it is the shortest text serialization format (e.g. JSON). 4. That is not the goal of the RFC. Dependencies are a burden and I wanted to avoid them, especially with the cross-platform problems that come along with it. The implementation would be much more complicated because you need to have conditionals for each supported library. Adding something like this to core is imho hardcore, because every user needs to accommodate that new dependency. 5. Endianness does not matter, because the `fromBinary` accepts the given 16 bytes as is, in order to support custom needs of any kind. It expects that the order of those bytes is in network order, as per RFC. However, ensuring that is up to the user. The `parse` method will always produce the same result, regardless of the Endianness, this is per design. MD5 and SHA-1 – correct me if I'm wrong – always produce the same order. Random bytes are, well, random. I have no problem with more iterations. I have to admit that it is kind of annoying that nobody cared during the discussion time, but that's just how it is. I already wrote on Internals that it might be best to stop the vote to avoid that 6 month voting ban for the topic.
I would like to dissociate myself from the term *oldfags*, but your proposal is still a valid one. I already explained that on [Internals](https://externals.io/message/100347#100389), I think that a procedural API is harmful and not helpful, and I stand by that.
 1. If it does not need any features of the C API then why use the C API? 2. Glad we agree. 3. ... `toHex` is basically base16. This is not the most compact text serialization format. 4. Convincing me to use your RFC code over existing solutions should be a goal of the RFC. I am uncertain why you think it would not be. 5. I've heard "endianness does not matter" enough times where they were wrong I don't believe it without tests. Your annoyance with the lack of feedback during discussion is merited, but you must admit you basically put it to vote abruptly after a long silence on the list. I've found that in these cases it is better to do a pre-vote email announcement to the mailing list as a new discussion (not a reply to anything). It cuts down on the 'feedback at voting time' somewhat. 
&gt; Compiles to PHP, so it's quick &amp; available everywhere. Where it's not available: - IDEs and editors (syntax highlighting, refactoring, error detection, autocompletion, semantic search, go to declaration etc. etc.) - Debuggers and profilers. - Ability to use existing Composer/Packagist libraries (or any PHP libraries). I commend any effort to build a better platform on top of PHP. But it's *not that easy*, because you need to also have all the pieces from the developer tooling, and ecosystem support for existing libraries. Without that, even if it has the best syntax, and semantics in the world, I'm afraid it'll remain in the toy category.
1. Because it is part of the standard PHP distribution afterwards, and every and any PHP library can depend on it without problems. Besides the performance factor which I did not use so far, because I feared bad feedback. 3. That is true, but any other form contains special characters that require special handling, or are not very widespread. 4. I thought you were talking about C libraries to generate UUIDs, are you? I think that the dependency argument is sufficient, to me it is. If you are talking about PHP libraries: this UUID implementation is meant to become the common denominator if it is about interoperability of UUIDs in the PHP world. You can use any library on top, or not, it does not matter, because all of them will be able to depend on this to interoperate. 5. Your help in adding those is much appreciated, we would need hardware that has a different Endianess because we cannot cover it without it. 6. Well, I did not know that; how could I. As I said, probably best to stop the vote and start the discussion again. Maybe this time people will take part in it.
I've seen, reviewed and merged many of your pull requests so thank you for these. Reviewers team isn't proposed for the first time. Good idea actually since recently github provided infrastructure for it.
yes I think thats a necessity for a project as big as yii2. Wanna talk about it privately to make it happen?
Regarding 2: see [Douglas Crockford's Base32 encoding](https://www.crockford.com/wrmg/base32.html). Honestly I don't like the design of ramsey/uuid and I think there is room for a better design that's less object-y while also being more than just a string generator. I'm not certain this proposal is that better design but that should be the goal, I think. To that end I suggest releasing this as a PECL package with the user-land polyfill. Advertise them both and gather real-world usage. This experience will hopefully allow you to design an iteratively better API. Then an RFC can be focused on delivering it as part of PHP core. Since hopefully it will have been designed explicitly for this purpose it will have clear strengths compared to existing libraries.
Well, you know, we're probably not that far away with our opinions and I definitely have to agree that PHP is not C and needs more useful functionality inside the core. For me, just with this specific UUID feature the approach is still wrong, but maybe for another feature the approach is absolutely great. It's a pretty subjective thing and I guess we could argue about the pros and cons of the different approaches for many, many hours. Anyway, I hope you keep up your work and are not demotivated, because of the feedback you might get. In the end, I think we all want the same: A better language and eco-system (thanks for your work with the EA Extended plugin, too). :)
As cool as this might seem storing images in a database is a mistake. The browsers and http servers have a lot of logic to deal with caching, which is a pain to implement in PHP correctly. And if you won't you're adding unnecessary strain on the server (by involving PHP and the database in the simple process of image retreiving). Just spare yourself the headache and use the server's file system or a CDN for image storage. I know there are some edge cases where you might want to have a middleman between the browser and the image (to, for example, verify that the user is allowed to see the image, or to modify it on the fly), but really don't do it if you don't have to.
Honestly why would you make such an tutorial and post it here? I'm not trying to be mean or bash on your video but its just a new point of low quality for me. Its actually kind of hilarious. Question time: 1) Is this serious or satire? (If so you did a good job) 2) Why not use a text / code editor with colors, Or just step u your game with an actual IDE? 3) Why don't you use any sort of tabbing (or at least spaces) to make your code more understandable? 4) Would you follow such an tutorial yourself? Would you find it useful or practical?
Check email.
I reckon reading earlier about hashing the old hash being the Only True Secure Method. Maybe even from you, in that case good, because you know what you're talking about.
It does take time to fully learn JMeter, but IMO it's quite simple to build a decent test plan that you can improve on along the way. A way to simplify things is to generate required parameters, POST bodies etc in PHP. You can submit them to clients via custom headers, then use Regular Expression Extractor (one of the post processors) to extract the values and store them in variables, that can be used to set URLs, complex POST bodies etc of subsequent requests of the session. So if you want to spread requests across many product pages, you don't have to define the product pages in JMeter, instead you basically fetch a random product page in PHP and submit the URL of that page to the client.
What exactly reached 1 billion downloads? The framework, or all components together? Anyway, congratulations, this success is absolutely deserved. I do not want to imagine working with PHP without your libraries.
Hashing the old hash is good because it forces all passwords to be migrated to a more secure hash immediately, without requiring a disruptive move that many users will disregard which creates a UX nightmare. When in doubt, remember [AviD's Law](https://xo.tc/avids-rule-of-usability.html): "Security at the expense of usability, comes at the expense of security." This also fits in with the [threat model](https://adamcaudill.com/2016/07/20/threat-modeling-for-applications) for password hashing, which is roughly: &gt; Assume that, at some point in the future, an unauthorized user will gain read-only (at least) access to the database. &gt; &gt; * How can we protect users' authentication credentials in the event of such a breach? &gt; * Bonus: If we cannot stop users from reusing passwords, how can we ensure other services they used the same password remain secure long enough for them to rotate their password elsewhere? Opportunistically upgrading password hashes, on demand, is what I call the Yahoo Folly, because that's what they did. Don't be a yahoo, be a wise developer.
&gt; Don't be a yahoo That sentence alone convinces me.
The total downloads of the components.
Scott's posts never get the updoots they truly deserve.
[removed]
I didn't say there was no good reason to use UUIDs as primary keys. I said you shouldn't use UUIDs as primary keys *unless* you have a good reason to do so. There are many good reasons to do so: - You need to ensure that your primary key is truly unique. Perhaps it will be reused across different databases or within some form a sharding. UUID makes this much easier. - You need to know the PK before insertion (perhaps you have an additional "child" table you need to insert another row in during the same transaction, or maybe records are being generated in a different place without access to the database) Now, let's look at some disadvantages: - Much more memory efficient, especially when considering frequent use of foreign keys. Uses up to 4x more space. - The above can mean more trips to disk as well, as table/index might not fit in the cache - Much worse performance, especially on inserts on large tables - These are especially concerns on MySQL, where primary keys are necessarily a clustered index - Potential added application complexity (need application logic to generate the keys instead of just letting the database handle it) IMHO, the disadvantages outweigh the advantages *in situations where you don't actually need any of the advantages*. In other words, use UUIDs *if you need them*, but don't use them by default. 
I didn't write this one, but [Michal](https://twitter.com/spazef0rze) is rather clueful.
I used to work for a company where they used md5() to hash passwords (when the app was built, md5() was not considered weak). I could never convince them to fix the problem, but I had always kept it in the back of my head for how to tackle a problem like this. Thank you for adding a new way to solve it! I can die in peace now. 😂
That's cool I guess? I probably count for about 100 of them in the past month on different vb's lol.
This is all well and good but it does not help you if someone got a dump of your database before you did this operation, or if they found your backups from before you did this operation. This third option lends a false sense of security.
[removed]
According to packagist or are they adding packagist downloads to whatever they used before packagist?
Luckily I don't have these problems. The project I was working on just stored them in plain text... /s What do people think about the automated rainbow table lookup and rehash method? 
7.1 Screwed up my sessions collection. Had to revert back to 7.0 and everything works normally. Though I haven't had time to investigate it but was clearly a cause of 7.1 changes. Still weary on upgrading. 
&gt; false sense of security No. Literally everything about password hashing (the threat model for which I defined elsewhere in this Reddit discussion) is inherently proactive. There's nothing reactive about it. If they get your plaintext password? It doesn't matter how you stored it server-side, it's already leaked. That doesn't make the security gains, which **are only measurable within a sane and reasonable threat model**, false.
Sorry, I should have been more clear. The users who were "automatically" bcrypted from md5 have more feasible threats to their security than the other users in your database added later - as it would be easier to crack their passwords that it would be for everyone else's, at least a bit, in the scenarios I described. I am not saying that it gains nothing at all, just that it doesn't provide all the protection that having done them all with bcrypt from scratch. The older hash with salt in a dump or backup lying around (as mentioned in the article) there's your threat model. I should have said instead, that this third option lends a false sense of security if your app makes any claims about how your passwords are stored and does not explain the difference.
&gt; PHP is slow versus Ruby https://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=php&amp;lang2=yarv versus Python 3 https://benchmarksgame.alioth.debian.org/u64q/php.html 
&gt; The older hash with salt in a dump or backup lying around (as mentioned in the article) there's your threat model. But password hashing is a strictly proactive security measure. Do not attempt to be reactive with password hashing. It's a house of cards. Password hashing is a tool that mitigates a specific class of attacks. It means nothing if an attacker silently slurps up all plaintext traffic (e.g. by breaking HTTPS). It means nothing if you had every old user's passwords stored in plaintext. The hash-upgrade strategy isn't a special case to the reality of the situation.
I'm not sure why you're being down voted. I agree with you. If your old database was leaked hashing the old passwords using bcrypt gains you nothing. The attacker will use the old dumps to find the correct password and then hit your newly hashed system when they have the plaintext.
If you have errors you are probably not implementing ADR correctly. ADR apps are incapable of having errors. 
Eagleson's Law : "Any code of your own that you haven't looked at for six or more months might as well have been written by someone else."
&gt; so what is the purpose of something like this? You can setup a try catch block to capture various types of exceptions and respond accordingly. The "empty" exception classes you are seeing could be used as markers to help catch various scenarios of exception. try { // do some complex work, that could throw any number of exception types } catch( PDOException $e ) { $dbh-&gt;rollBack(); die('oops, but i know the database broke, but i rolled back the changes'); } catch( UserAlreadyExistsException $e ) { die('you guessed it, the user already exists'); } catch( Exception $e ) { die('oh no, I don\'t know what broke'); }
You might be interested in this: https://github.com/imarc/checkpoint As for where in the pattern handling them occurs. I would think it's really up to the responder to determine how errors should get presented, which includes flash errors. Using the above library, I'll inevitably only have one inspector to cull for messages so you could set the inspector on your responder an leave it up to the responder to translate those errors into whatever type of response it actually handles (I would think for HTTP this would include session based flash messaging). Note, I would think your domain would still execute it and decide whether or not it should continue or give up, but the outputting seems obviously a role for the responder.
This was already addressed in the article: &gt; Now, if you've created a backup, don't forget to securely delete it. This should be done for all other regular backups too, shred them, or remove the old hashes from within. Backups are quite often the source of a leak of the old weakly hashed passwords.
You can run Chrome headless. Having access to a rendered DOM and beeing able to inject JS makes crawling amazingly easy. Obviously depends on your needs.
We take into account only Packagist stats. In this page: https://symfony.com/stats/downloads you can see the downloads for each component and you can click on each of them to browse their Packagist stats and see if they match. That page also explains how we provide a pseudo real time counter even if Packagist doesn't provide that information.
One thing I dislike about PHP is that even now, many things lack type-hinting, which isn't that nice when you love using IDE and autocompletion. Sure, with PHP7 things have improved, and before that you could always use the `@var` thing, but still. Many libraries still lack proper type hinting. I'd love to have generics as well for collections, even nowadays we still have to use that `@var MyObject[]` thing. Many libraries are still not type hinted correctly. For example in a project, if I'm going to refactor one file or variable that is used in many places I always have to double-check if it's not going to break some code somewhere. It's usually not something I have to worry about that much in strongly typed languages like Java. The counter argument would be that PHP is very flexible with magic method and reflection and thus very hard to have an "intellisense" that works accross all the code.
[mysqli or die, does it have to die?](https://stackoverflow.com/questions/15318368/mysqli-or-die-does-it-have-to-die) 
That is. Making a library conform a coding standard is a good justification.
You don't need to store the type of hash in the database. Just try each type. You think an md5 hash is just going to happen to match a bcrypt hash? It won't. If it fails move on to the next. Once you've exhausted all hash types you've ever used give the user an error that their username or password is wrong.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
If you have a cli crawler, make use of async signal handling. You won't need ticks anymore. See the RFC: https://wiki.php.net/rfc/async_signals For me, this helps to remoce the overhead with ticks. It's now easier to report status, safely halt the crawler, etc. 
Don't mind people like these. Enjoy working on your project and have a fun :) I personally look forward to see what can come out of it.
If you want to do your scraping in a regular full featured browser, and even watch it and it runs, you can use Selenium. 
Rainbow tables are useless for salted hashes.
you could output a image tag to a spooky skeleton gif if you wanted.
What about changing the salt when rehashing? Then the old (poorly hashed) passwords are useless?
whatever your homemade tinkering with exceptions is just terrible. to do a rollback, you should catch \Exception, not \PDOException. and your handling of \Exception it simply out of place. And UserAlreadyExistsException has nothing to do with them all.
That's great success to the Symfony Team. Keep up the good work to empower other frameworks via Symfony Components :)
&gt; PHP is slow, it has to read every file every time ! Page cache is a thing, SSDs are a thing, ramdisks are a thing, OPCache is a thing. Also, pretty much any modern application has to communicate with other services (APIs) and talks to a database to store data - both actions taking much, much longer than an FS read, cached or not. Even with this "slowness" it still beats pretty much any other language you can put on a webserver that isn't compiled. &gt; PHP is beginner friendly and you have lots of bad code shared on the internet Lots of bad code is shared on the internet in other languages too. Thankfully, people in the PHP world learned their lessons and created things like [PHP - The Right Way](http://www.phptherightway.com/). If you want to learn how to use the language correctly, the resources are there. &gt; PHP community is split, everyone creates a framework, nothing can be shared You think PHP's situation is bad, look at the [JavaScript ecosystem](https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f). As others already noted, most composer packages are framework-agnostic, and there really aren't that many different frameworks in widespread use nowadays. I reckon Symfony, Laravel, Phalcon, Zend and Yii are the most popular. Most projects that are built from scratch or use something like Codeigniter are likely legacy and EoL. &gt; I'm curious to see if you have heard other arguments against PHP The ultra-liberal typing and type-casting which could land you in serious trouble if you don't know exactly how it works. A familiar example: &lt;?php $foo = 'foo'; if (strpos($foo, 'f')) { echo 'Found the "f"!'; } which prints nothing even though "foo" starts with an F. I have no argument in defense of this mechanism, I hate it too and it really is extremely confusing. 
It absolutely is not. "I don't like it" isn't sufficient justification for requiring anyone to make changes to any code, no matter who you think you are. You should learn to develop the skills to express *why* it makes you feel that way and identify what the problems with that approach are.
Generally I agree with that C is faster than PHP, however especially since 7.0, I may not believe anymore that there is a significant difference in this case, especially because when you have a pure PHP implementation, you are still using native socket methods with a textual protocol it's really not that much of an overhead. If we have our caches close, so that the connection speed is very fast, then even the connection pooling provided by the extensions is not giving a significant benefit. Maybe I just didn't encounter such system where our Redis library would be the bottleneck, it works very well with 200 incoming request per second, doing multiple operations in each. Just checked, we have 46 operations for a single page, on average they take 0.1ms, it is only more, like 0.4ms for MGET requests where we are sending ~36 keys and getting back JSON documents for each (in average 3.5kB per doc), therefore the network time is much more significant than the library's speed that handles the connection. You also have the benefit of not having to deal with extension installation and more probably won't break on PHP version changes. ;-)
Points themselves are not important but it's still slap in the face when you get drive-by down-votes when you haven't broken etiquette, taken away from discussion, said anything disagreeable or broken any rules. That sort of environment doesn't cultivate discussion but it's rife in this subreddit - which is bizarre, you'd think a bunch of developers might be above petty crap.
Well to me they exactly as easy to understand as each other. The latter says "foo is read only", while the former says "foo can only be gotten".
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I see, following the custom of this sub, you are nitpicking on the phrasing. Feel free to keep going. 
XPath, oh god XPath for locating content in DOM
Eh... Apache tends to have some flakiness under load unless configured just right. NGINX does not. I'm not saying both cant do the job in most cases. Apache just requires more tweaking.
I think that would be less secure, because now you have two passwords that can work for each user. 1. The original password - user enters this, it fails against the bcrypt hash, so you md5 and bcrypt it and it succeeds. 2. The md5 hash of the original password - attacker enters that and it succeeds against the bcrypt hash. It would also mean if your old database had been leaked, like the company at the beginning of the article, attackers could log into any account using the md5 hashes. They wouldn't need to brute force anything to find the original password. 
can this be done by setter ?
If your database was leaked you need to reset everyone's passwords, no matter how they are stored. If your bcrypt hashes are leaked you are also somewhat screwed because attackers can try common passwords against all users. 
You can't change the salt for a password hash unless you know the plaintext password. 
 &gt; Is this a security hazard? Does anyone else access the production environment? 666 is generally not OK.
I think, what he means is "errors", since the application is a multi user environment at some point you can create a record, that an msec ago, was created by someone else. That generates an "error"; a foreseen outcome that needs to be handled 
It's a dedicated server and there are no other accounts on it.
I would say that with pthreads combined with things like ReactPHP or Amphp you can get things up and running in CLI SAPI just fine, just use some static file server for serving files from disk and proxy PHP requests to the running PHP-CLI application.
Just wrap `&lt;=&gt;` in parentheses and that'll work. Learned this the other day.
I run in Docker so extension installation is easy. I noticed a huge speed difference with my queue system when turning on phpiredis with Predis. I'm just saying, it's probably worth trying it again and doing some quick benchmarks to see
Use Symfony's CSS selector Component http://symfony.com/doc/current/components/css_selector.html It makes finding stuff in the DOM a piece of cake
There are php-memcache packages for both CentOS (remi) and Ubuntu on PHP 7 and PHP 7.1.
I don't know why you keep mentioning being "reactive" and slurping plaintext. That's not what I'm talking about at all. I give up.
It's not just about user accounts, you are giving read and write access to every account and process running on your server, which is generally a bad idea. 
"Well what if an attacker grabs an earlier copy before you added this security layer?" is the same scenario, and it does nothing to the security analysis except add a footnote of &gt; Don't leave backups lying around, also, if you're already pwned, adding security does nothing, but everyone already knows that and it's hardly relevant. You can only apply password hashing proactively. That means "what about old backups?" or "what if already compromised?" is strictly ***outside of the threat model*** here. This is because "what if the attack already succeeded?" is a reactive security concern, and does *nothing* to obviate the need for proactive measures.
normally the apache runs as a user on the system. That user should have enough credentials to do stuff. Other users don't.
How can I check this? Why can some processes on the site write to 664 files and others can't?
Y'know how elsewhere we just said "store a boolean flag for `this is a legacy password`"? You'll also want to store the old salt until it's migrated to a new algorithm.
Absolutely nothing to do with nitpicking, and I'm not sure how someone with basic English comprehension skills could ever jump to that conclusion. Not a single valid, objective justification was given whatsoever, and therein lies the problem.
&gt; it's still slap in the face when you get drive-by down-votes when you haven't broken etiquette, taken away from discussion, said anything disagreeable or broken any rules. For what reason do you think you're getting "drive-by down-votes", then?
But you get the plain text password unless it's hashed on the client. If the compare op says the password is valid and you choose to re-hash then, I think you'd have it?
Just be careful as you might be invoking Santa
I'm tempted to put 666 on all files - maybe Santa will come sooner then
perhaps you can find out as which operation system user those processes operate.
[removed]
&gt; If I understand correctly application facing errors ( username exists, etc. ) would be defined by something like this and handled by the app accordingly, while throwing exceptions would be app/fw critical errors? First, we have to talk about what we mean by "the app." The kind of error you're talking about ("UsernameAlreadyExists") sounds like it would be raised in the Domain logic, so that's the part of "the app" that should be handling this. Nothing outside the Domain should have to handle Domain exceptions, so that means your Domain code should report it back to the Action in a non-exceptional way, typically via a Domain [Payload](https://github.com/auraphp/Aura.Payload). Some pseudo-code for the Domain: public function createUser($username, $password) { $existingUser = $this-&gt;userMapper-&gt;fetchOneByUsername($username); if ($existingUser) { return (new Payload()) -&gt;setStatus(PayloadStatus::NOT_VALID) -&gt;setMessages([ 'username' =&gt; 'Username already exists.' ]); } // user does not already exist. // insert, and return a CREATED payload. // ... } Again: all exceptions and errors occurring in the domain ought to be captured and reported, rather than allowing them them to escape the Domain boundary. It's not the job of the Action or Responder to handle Domain issues. &gt; what is the purpose of [empty exceptions that just extend the base exception class] ? For myself, the purpose is to know more specifically what happened to cause the exception, so that I can tell just from the class name. Then you can set up try/catch blocks to catch the different kinds of exceptions and handle them appropriately. Again, pseudocode: public function createUser($username, $password) { // ... // user does not already exist. // insert, and return a CREATED payload. $user = $this-&gt;userMapper-&gt;newInstance([ 'username' =&gt; $username, 'password' =&gt; password_hash($password), ]); try { $this-&gt;userMapper-&gt;insert($user); } catch (\PDOException $e) { return (new Payload()) -&gt;setStatus(PayloadStatus::NOT_CREATED) -&gt;setMessages([ 'reason' =&gt; $e-&gt;getMessage(), ]); } catch (\Exception $e) { return (new Payload()) -&gt;setStatus(PayloadStatus::ERROR) -&gt;setMessages([ 'error' =&gt; $e-&gt;getMessage(), ]); } // ... } If you had additional custom exceptions, you could add them to the catch block as well, and report them appropriately. The Responder can then inspect the Payload, and display the results appropriately. I have an older article about Domain Payloads [here](http://paul-m-jones.com/archives/6043) if you want to read more. Does that begin to help? 
How do you presume to solve the issue when apache runs as a user, but CLI scripts running as a different user, both needing access to read and write to the same log files?
I don't pride myself on my image editing skills... but [someone had to do it](http://i.imgur.com/u9ZEmlZ.png). Oh god it looks even worse after imgur compression.
Will be the total downloads of components so they will even be counting installs of Laravel and other things that use some of the components
You usually put them in the same group, then give access rights to the group
Any ideas how to do that?
Why do you have CLI scripts as a different user? You can put them in a group. To avoid trouble (eg wrong group) when new log files are created, you can use *setgid* on the directory. It will force new files to be owned by the group of the directory rather than the default group of the user.
I found this post a while ago, but I've been trying to figure out how to respond to you because [I was in the exact same place three years ago](https://www.reddit.com/r/PHP/comments/5wpqcs/third_times_a_charm_weve_finished_a_complete/). Maybe the best thing I can do is share my experience with you: 1. Maintaining an open-source framework is **hard**. If you want to build a quality product and build any sort of community, it will become a second full-time job. 2. If you respond to feedback from your users, _you_ will eventually become a better developer. Your users will suggest things like routing engines, templating engines, ORMs, automated testing, PSR compliance, and Composer. Listen to those suggestions - they'll help you improve your skill set and become a more professional developer. 3. Documentation is essential. You've got a start, which is good. Good documentation will reduce the demand for your time, and help you avoid answering the same questions over and over again. See [You Should Write Blogs](https://sites.google.com/site/steveyegge2/you-should-write-blogs) - the same principle applies to documentation. Some things I regret: 1. Being reluctant to adopt better ideas sooner. It took me a long time to transform UserFrosting from a procedural framework, into an MVC one. I was afraid of scaring people off, but in reality as the framework matured, so did our user base. It's harsh, but I now believe that people who are not even _willing_ to learn modern application design principles have no business writing production-level software. Procedural code is a maintenance nightmare, and unfair to future developers who might have to maintain it - including the developer's "future self". I feel that early versions of UserFrosting actually did our early adopters a real disservice. 2. Focus on infrastructure, not features. Yes, your users will mostly demand features because those are shiny and they can show them to their bosses. This doesn't matter - features are just more code that you need to maintain, while distracting you from building a solid foundation. In software, "less is more". Anyway, those are just my thoughts. Feel free to [join me in chat](https://chat.userfrosting.com) if you'd like to discuss any of these points more, or if you have any questions. Good luck!
What does a modern &lt;insert framework&gt; application look like? I haven't used traditional frameworks in about 2-3 years now. Pretty much built everything on top of slim or silex during that time and I'm in the mood to jump back into full fledged frameworks and I'm curious what a modern app looks like in different frameworks to see how the development flow is so I can decide which one fits my style. If those examples actually exist.
Even if you mean "what if they got the db with the older hashes" Scott is still right. We don't hash passwords for "already stolen dbs" (reactive) - we hash passwords "in case" the dB gets stolen in the *future* (proactive). Regardless if you were talking about before they were ever hashed or before they were rehashed as the topic of this thread - the same application of threat modeling applies. 
I've used https://artillery.io/ a few times and it worked really well, you can use random numbers like: {{$randomNumber(0,255)}} And it is scriptable beyond that as well: https://artillery.io/docs/script-reference/ 
&gt; memcache is not supported in PHP 7 Hein? https://imgur.com/a/nedgi
^(Hi, I'm a bot for linking direct images of albums with only 1 image) https://i.imgur.com/BRAAiuO.png ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme) ^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20dmn1jq9) 
I'm not following. What situation are you talking about? The database has the salt and the md5/sha1 of the password+salt, so you can't change the salt there. You only get the plaintext password when the user logs in. At that point the salt for the old password is irrelevant as you're switching them to bcrypt. 
The top comments says it all about how toxic the PHP community is. Rather than have some meaningful discussions like any mature community out there, we have author shaming, jokes, and full-on negativity. I feel bad for the author who clearly spent a great deal of time and effort in making this. To OP, I suggest you move on to other languages. All the other talented devs I know of have migrated to "cooler" languages.
Yeah, I was thinking out loud and I'm not sure it has added much to the conversation. I _was_ considering whether there would be benefit in messing with the old salt. But I've discovered (probably not for the first time) that bcrypt ~~generates~~ stores its own salt, so there's no need to store a second one. Perhaps if one were to move to a stronger hashing algo that needed a separate salt stored...
IMO stuff like `:: }` is pretty ugly. Something like Blade's @for ... @endfor would be much cleaner. But overall, I do like this more than most people here. I don't really have a huge craving to use it, but it's a cool idea nonetheless. 
If docker is giving you longer build times something is wrong, and you need to look into your setup. You're done with it because you couldn't do it, simple as that. There's nothing wrong with Docker.
💯
Sorry my bad, I kept clicking download, and I didn't notice the download window is on my second monitor.
Or even better - CSS selectors.
Both of these are equally easy now a days IMO with chrome. Inspect, right click, select css or xpath and it copies either to your clip board. Done
&gt;&gt;Hacking favors scrap-and-rebuild over patch-and-extend. An essential part of hacking is ruthlessly throwing away code that has become overcomplicated or crufty, no matter how much time you have invested in it. &gt; “Scrap and rebuild” is essentially “rewrite from scratch” and that is almost always a losing proposition in terms of time and budget. I take ESR to mean "scrap and rebuild" on a smaller scale, like rewriting a class from scratch, not tossing the entire system.
Using nodejs for this specific purpose is a huge improvement to me 
Fiddler from Telerik has been always really helpful when it comes to simulate human behavior on sites, aka scrapping sites under custom login systems. Lets you analyze/save/manipulate sequences of requests and save them for later analysis/usage, etc.
Wait, what does this mean? 
How come? 
I use xpath in my cron jobs and it works a treat. Just gotta remember that sometimes when finding the xpath in Chrome that sometimes it adds elements in that are not really there, like a &lt;thead&gt; for instance, just to make the code look pretty. 
cool. didn't know that, thanks! 
That's neat. So technically Laravel can never claim more downloads than Symfony.
You're asking why asort()/arsort(), which is quicksort written in C, is faster than a mergesort written in PHP which invokes a user-defined PHP closure on every sort cycle? The answer is in the previous sentence I just wrote. Depending on your definition of "at scale" a custom mergesort may be faster if you start reaching collection sizes that PHP can't fit in the available memory. At that point, any mergesort time is faster than "I crashed and never sorted it". But since it never crashed, it means this limit wasn't reached.
Situations like this are the reason I'm explicit (`!== false`) about "truthy" values.
You're talking about the function defined [here](https://github.com/laravel/framework/blob/c4d1c471d2a9d080362b8bed70be35cd84e2cdef/src/Illuminate/Support/Collection.php#L1341), right? Recall that running those two full loop-throughs of the data run in O(n) time, whereas a sort operation runs in O(n lg n) time. Thus, the sort operation dominates the run-time of this whole process. You're looking to optimize the sort operation if you want to squeeze the most performance out of it. As LtAramaki points out, the underlying C routines are faster than PHP. Even using those native sort functions and passing a closure in results in a slowdown, as the PHP has to be called for each of the n lg n comparisons made. tl;dr The foreach loops just don't matter in the overall run time.
Well, yes calling function is fucking slow - not only in PHP but in computing general. But results are pretty normal and expected. First of all default php sort probably uses quick sort - which is usually faster than merge sort, and is written in C and because so. well optimized by compiler. Foreach sandwich does too many things™ - first it fills array on `key =&gt; sorted_value` basis - that's O(n) operation, then it sorts it using PHP builtin function - which probably is O(nlog n) and then it builds array - another O(n) - and so we get something like O(nlog n + 2n) - normally you'd ommit 2n part because it's pretty insignificant but we're gonna compare it to another functions. Then we have PHP functions using callables - O(nlog n) - only, well, this sort is little bit slower than sort from first method but this is so simple function that it's not as significant as 2n part, because PHP probably can optimize it a little bit. And then we have in PHP implementation of merge sort - the first thing is that in your case quicksort 'll be probably faster (even if both are O(nlog n) - just "1" takes less time). Second thing is - PHP will always be slower than C implementation because there are at least few more things to do per every instruction (not even line of code!) and cannot be optimized as well like C. The basic rule is - if you can achieve something by using builtin function - do that, it will be probably faster than any other implementation.
Congratulations to Fabien and Symfony team. Great job!
Thanks for your reply! I guess that makes sense the more I think about it. Now I'm wondering if usort is even implemented in C... I guess it doesn't matter since it has to keep calling the closure and there's no hotspot compiler like in Java (that I know of). Interesting. Foreach Sandwich vs. Pure PHP Mergesort: (php(2n) + c(nlog(n))) is better than php(nlog(n)) Foreach Sandwich vs. usort+closure: (php(2n) + c(nlog(n))) is better than mixed c/php(nlog(n))
Processing Time while Scraping is mainly Network IO wait... In nodejs no IO wait so INFINITE POWER xD Disclaimer: there is probably others languages which offer similar or better approach to Scraping but i don't regret the switch from php to node for scraping.
I can't figure out how you figured out this is your personal help forum.
My mistake, I'll move it to /r/phphelp
**Here's a sneak peek of /r/PHPhelp using the [top posts](https://np.reddit.com/r/PHPhelp/top/?sort=top&amp;t=year) of the year!** \#1: [Is it necessary to use a PHP framework?](https://np.reddit.com/r/PHPhelp/comments/51g86f/is_it_necessary_to_use_a_php_framework/) \#2: [First time writing OOP can anyone check im on the right track.](https://np.reddit.com/r/PHPhelp/comments/65qzgl/first_time_writing_oop_can_anyone_check_im_on_the/) \#3: [Can someone explain what this php malware does?](https://np.reddit.com/r/PHPhelp/comments/5phn6r/can_someone_explain_what_this_php_malware_does/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/6l7i0m/blacklist/)
[removed]
&gt;(built in Laravel) There's your problem.
My problem is that I actually miss symfony 1.x
&gt; anyone think of why this would be insecure? Literally the first result for "double hashing insecure" on Google is https://stackoverflow.com/a/17396367/2224584, which answers your question more thoroughly than I have time to. (I have a hurricane to prepare for.)
Any more info on this?
[removed]
[removed]
googlesheets and IMPORTXML / IMPORTHTML / IMPORTJSON saves me incedrible time monitoring competitors ... no need for "code" and crawlers, just a google sheet.
What version did you upgrade from and to? And what was the exact error? `must be (as in class !) or weaker in` just makes no sense, that can't be the error message. 
This is super vague. Are you looking to hire a contractor? Have you checked with a contract firm like Cyber Coders or posted a detailed description of the problem you're trying to solve on StackOverflow? 
&gt; But that's stupidity ... &gt; ... this moron ... ... &gt; ... but your reading comprehension is pretty lacking. Care to try that again, but without the attitude? If not, fuck off. The community here doesn't need more ego.
It means that you can't have a method in`Child` that is private that was public in `Parent`. I honestly don't believe you even tried to google this. The answer is within the first results of "PHP class weaker error".
Check for PHP7 backwards compatibility using Phan. Fix the errors. https://github.com/phan/phan/wiki/Incrementally-Strengthening-Analysis#just-backward-compatibility 
[removed]
[removed]
[removed]
&gt; if usort is even implemented in C It is; everything in the PHP standard library and other extensions is implemented in C at present. We don't (yet) have the ability to implement extension functions and classes in PHP yet. There's been some talk of changing that. Even if we had PHP standard library functions that weren't implemented in C, `usort()` and its siblings would most likely be in C anyway because they're performance-critical (and I think `asort()` is hard to implement efficiently without internal APIs).
Also there's gonna be lotsa heap memory allocations going on (all those arrays created), and memory allocation is expensive (mind you PHP has a custom allocator to improve this) and not necessarily constant-time. :)
I write my own, generally. Made a composer package mainly for my own use but yeah.. nonamephp/php7-common 
I've had good experiences with [respect/validation](https://github.com/Respect/Validation).
I also use Symfony Constraints, I don't really find it too verbose: if ($this-&gt;validateInput($this-&gt;input, [ 'name' =&gt; new Constraints\NotBlank(), 'email' =&gt; new Constraints\Email(), 'message' =&gt; new Constraints\NotBlank(), 'groups' =&gt; new Constraints\Optional(new Constraints\All([ 'constraints' =&gt; new Constraints\Collection([ 'fields' =&gt; [ 'precedence' =&gt; new Constraints\NotBlank(), 'position' =&gt; new Constraints\Optional(), 'status' =&gt; new Constraints\NotBlank(), 'type' =&gt; new Constraints\NotBlank(), ], ]), ])), ])) { // do the thing }
It looks like a HHVM error https://3v4l.org/Y5ZcV
Lately I have been using JSON Schema for validation. http://json-guard.thephpleague.com/ 
What a nightmare!
I see aggregate stats like this all the time, but the reality is that saving any one user 1ms or 10ms or even 100ms, doesn't save them enough time to matter. You could argue it saves the *planet* a certain amount of fossil fuels by saving 1,470,000,000 processing-hours, but no single user is going to be able to capitalize on a 1ms savings in load time...
You asked about "double hashed passwords with md5()" which, by the way, [is totally doing it wrong](https://codahale.com/how-to-safely-store-a-password/). I provided a link to an answer to a Stack Overflow question that was relevant, because **the answer mentioned the specific security weaknesses you were inquiring about**. You proceeded to call the questioner stupid, then accuse me of having poor reading comprehension. Not only have you expressed ignorance (by not knowing that you shouldn't be using MD5 for password storage), but you did so while trying to tear other people down. Then, you proceeded to attack the wrong thing (the link I gave you should have even moved your scrollbar directly to ircmaxell's reply to the question, there's really no excuse). Then you proceed to post a bunch of comments calling me a retard, which is ignorant and ableist, presumably because you weren't getting a reaction out of me or anyone else, and it frustrates you that we aren't taking time out of our lives to give you attention. Then to top it all off, you're trying to passively aggressively threaten to "happily leave [the PHP community]"? This is what we call emotional blackmail, and is indicative of personality disorders that will leave you severely crippled in both personal and professional relationships. Let's recap: * Ignorance * Arrogance * Hostility * Name-calling * Passive aggression * Emotional blackmail I think that's BINGO? I'm not going to report your comments as failing to remain civil, and I encourage others to follow suit in not reporting them. Please consider what you want out of this community, and ask yourself if this behavior is the best way to go about getting it. I'd wager the answer is "no". If so, the ball is in your court. If, on the other hand, this *is* what you want? GTFO. Toxic people leaving the community is a net win.
I think your linux admin can tell you which process is run by which user (and he prob. will use the ps command for that) But somewhere in the above, you can see the suggestion that you might have different users: 1 for web operations, and 1 for cli operations. Both have to belong in the same group when it comes to creation of dirs on a certain level (=directory) on the server. Other users should only have read access (or no acces at all, if everything is presented via the web) 
If everyone could just give $4 a year, we could end world hunger.
1ms arguably is too small to care about, but a 10-100ms time save is *incredibly* valuable to a high-volume website. Speed is absolutely critical. Also IMO it *is* worth considering aggregate stats when dealing with web traffic, because at the end of the day if your site's business model depends on users performing certain actions on your site, and each action takes a fraction of a second longer, that will result in fewer actions being taken overall and thus a dip in your profit. The article definitely takes this wisdom to absurd levels, but the message is still valid.
I use Yii2, so Yii2's. return [ [['name', 'email', 'subject', 'body'], 'required'], // the email attribute should be a valid email address ['email', 'email'], ];
The most complete validation library i'd say is the symfony constraints. The easiest to use must be, hands down, https://github.com/webmozart/assert
Imagine if bcrypt was a snail, and md5 was a [SR-71 Blackbird](https://upload.wikimedia.org/wikipedia/commons/thumb/9/97/Lockheed_SR-71_Blackbird.jpg/1280px-Lockheed_SR-71_Blackbird.jpg). Double MD5ing your passwords might cut the jet's speed in half, but it's still going to leave that snail in the dust. Now remember that my analogy probably undersells the speed difference by a few orders of magnitude, and you'll see that md5 isn't going to do anything worthwhile compared to bcrypt even if you double it, triple it, 10x it, and so on. On the topic of rainbow tables, your average password cracker would probably rather invest in GPUs than in storage. I'm willing to bet a couple of GTX 1080s could probably tear through MD5s faster than you could pull them off of a disk anyways. Also, I think you should try being nicer to the people that respond to you. It's okay to ask followup questions if you don't understand something or you don't feel your question was adequately answered. But when you start lobbing insults around, it'll just leave the people who tried to help you upset, and it will not help you answer your own question. I encourage you to treat your fellow PHP developers with more respect in the future.
Jesus F Christ, my mate. With today's hardware, your coffee would still be hot when all your passwords are cracked. 
This is great. I love that assert paradigm. I dont have to do a lot of mental shifting when writing validation and unit tests because its similar to writing phpunit tests. Been looking for something like this.
You fixed the wrong thing. 
+1 for validator reuse
PHP is ok if you are fetching a single URL. But if you need to fetch multiple URLs at once (esp in webscraping), its very difficult. There is no way to write easy non-blocking async code.
https://github.com/imarc/checkpoint -- which uses respect/validation
I use third party tools for downloading, like wget. cron job runs to check if wget is done. I only use php for processing the downloaded data. But headless chrome is better since it can deal with JS redirects unlike wget.
As someone who uses a fairly standard nginx and php-fpm stack already - How is this better and what would it change?
Here are the docs that explain it better imo: https://unit.nginx.org/docs-nginx-unit.html It looks like nginx but easier to configure multiple applications.
Ah that is better, thank you. Answer to my question for others: it simplifies the stack completely by pulling all the configuration into a single area in nginxs usual clean format.
Thanks for a brief summary.
I actually *just* learned Python and selenium for this purpose. I've completed the proof of concept script. If I get with this new company, I'll merge it into a small web app with Symfony microkernel to run headlessly.
https://developers.google.com/web/updates/2017/04/headless-chrome The "Dev Tools" are basically a web service you can communicate with to interact with chrome / chromium. Here are the protocol docs: https://chromedevtools.github.io/devtools-protocol/ Someone also wrote a small driver in PHP: https://gitlab.com/DMore/chrome-mink-driver/tree/master
tl;dr anyone?
Instead of requesting a plain web document and xpathing your way to the data. You can run a real browser which will obviously also act like a real browser. That means pages that utilize one of the million JS frameworks out there will be rendered to their desired form or if a page loads things asynchronous you can simply wait for network idle to do your thing. Also you have lots of flexibility to fetch the data, you can inject javascript, listen to Dom events etc. Bonus point you can also take screenshots.
PHP's password_hash() produces crypt(3)-like encoded hashes. That is the output contains everything needed to check a password against the hash. &gt; Perhaps if one were to move to a stronger hashing algo that needed a separate salt stored... This is actually a traditional "local parameterization", so that in addition to hashing a password, you introduce a separate parameter which must be known to be able to verify a password. I.e. after hashing the password you encrypt the hash (preferably in a separate instance, so that the "additional parameter" or key must not be accessible from the app doing the hashing). Just as a side note Argon2 has the following encoding: $argon2&lt;T&gt;[$v=&lt;num&gt;]$m=&lt;num&gt;,t=&lt;num&gt;,p=&lt;num&gt;$&lt;bin&gt;$&lt;bin&gt;
It's basically a tour of all the empty buzzwords in IT from the last two decades.
The most interesting part of *serverless* is the servers.
That said it's very different, this assert paradigm is to compensate with the lack of complete strict types in PHP, it's to throw 500 exceptions in case that happens. On the other hand, the validator component is for a proper user input or business rules validation.
&gt;When you run Chrome with --remote-debugging-port=9222, it starts an instance with the DevTools protocol enabled. The protocol is used to communicate with Chrome and drive the headless browser instance. It's also what tools like Sublime, VS Code, and Node use for remote debugging an application. #synergy Holy fuck did this guy just "hash tag" outside of Twitter? In a *technical article*, no less? It hurts to live.
&gt; So technically Laravel can never claim more downloads than Symfony Depends on how they are counting the downloads. Either way, I don't really give a shit :)
We wanted to add some checks in addition to the ones provided by CodeSniffer itself. After implementing them internally we decided to share them on GitHub. Feel free to use, if you want.
looks exactly how it is supposed to look
~~Read your link against, it's not just HHVM. PHP 5.0-7.x has the same error.~~ OP was missing half the words in the error message though. But reading their post again that might be what they meant in the second paragraph. 
wait...wait..so if I just slow everything down a bit, I create more jobs?
what is his/her name? Perhaps he/she reads it. The direction is always go forward ;-)
I always get an April fools feeling when I read "Serverless". Perhaps the software is not running on my servers, but it's somebodies server (for hardware-starters). Apache, NGINX, to name a few, are software-servers. How come people stil invent crappy buzzwords that stick in the minds of the innocent? And 22 years ago, php was born, but not the only stage at that time (example: coldfusion)
https://github.com/beberlei/assert deserves some love
A modern usage of &lt;insert framework&gt; should have clean separation between the business logic and the framework. When we bet on the wrong horse &lt;insert older framework&gt; then you can easily switch without too much effort. Personally I love the micro versions of &lt;insert framework&gt;, because you can use any library of choice and have more control. I compare a micro-framework with a base car which you can bend into your favorite shape by adding stuff. A full fledged framework is like a huge truck. You have to remove stuff to make it your favorite shape.
&gt; There is no cloud, just other people's computers.
https://twitter.com/symfony_en/status/904602759156117504 "Symfony Components" -&gt; RT by Fabien
&gt; How come people stil invent crappy buzzwords that stick in the minds of the innocent? Aha, a question that answers itself. :) "Serverless" was a term coined by AWS for exactly this reason. You'll see "functions as a service" being tossed around more and more frequently for this model as applied to compute, specifically (it's more descriptive), but what "serverless" generally refers to is autoscaling, self-healing cloud infrastructure that can be billed for down to the millisecond. Most of the people building atop "serverless" infrastructure have long gotten over the fact that (A) there are still servers somewhere and (B) yes, they are other people's servers. The reason it's so easy for this segment of the industry to accept this (yes, including malleable newcomers) is because they're not paid to manage servers, they're paid to deliver business value, and if they can do so without managing even a facsimile of hardware (and just focus on the software they're building), all the better. Not necessarily an intellectually satisfying answer... oftentimes people hear "serverless" for the first time and they think of decentralized compute / etc., but still a tremendously valuable innovation.
I would always go for a defined ruleset. That being PSR-2 or others. With my current employer we tend to have a highly customized ruleset, which is more annoying than helping. For example: 1. More than 3 codeline in a controlblock (if, function, foreach...) there MUST be a single empty line und beginning and end 2. There MUST be a comment for each parameter in docblock 3. There MUST be a description of a function (very useful for.. set_username... 'Set the username' - thanks cpt. obvious) And the list goes on with even more ridiculous rules. So please if you define codesniffer rules for your coworkers, or open source. Do everyone the favor of simple sticking to a preset (like PSR-2) as mentioned. This will improve codequality more than the time needed to fiddle around the strict sniffer rules and wasting time with it.
The author's framework - https://stdlib.com/ does look pretty great, the video on the homepage is worth a watch.
Yeah I know how SOLID works, I just can't find any good examples to &lt;insert multiple popular frameworks here&gt; that apply those rules. Aside from symfony of course, but then again I don't want to use symfony right now aside from FLEX which seems promising. I like a decent amount of symfony components, but I don't like the bootstrapping of the symfony framework itself, but that's for another discussion entirely.
You're correct, of course. The actual error message is: &gt;Access level to &lt;class method&gt; must be &lt;access level&gt; (as in &lt;class name&gt;) or weaker
&gt;Read your link against, it's not just HHVM. PHP 5.0-7.x has the same error. It doesn't. The *or weaker* variant is HHVM-only.
Sorry, let me rephrase: php-memcache doesn't have a stable version for PHP 7. https://pecl.php.net/package/memcache - 3.0.8 is the latest version, flagged as beta, released on 2013-04-07, more than 4 years ago. https://packages.ubuntu.com/zesty/php-memcache - 3.0.9 is the latest version, by version number I assume it is created from the latest beta version.
Can you share details about your measurements? For now seeing my 0.1ms response times, I don't think it can get better, our Redis cluster is behind firewalls and load balancers, so this 0.1ms includes going through multiple servers to get back the payload, I don't see how a C implementation would do that faster. :)
https://github.com/phpro/grumphp
I think the the deb comes from here: https://github.com/websupport-sk/pecl-memcache Source: https://github.com/oerdnj/deb.sury.org/issues/186#issuecomment-186217296 It's stable, but deprecated, so good work on your part for moving on.
[removed]
Now I think "serverless" is completely idiotic as an expression (its basically CGI fronted by Apache, it works exactly the same way). One difference though is the promise of infinite auto-scaling without provisioning servers.
&gt; rubycreative.slack.com Why ruby? :o
The thing I'm excited about here is that Unit allows you to run PHP 5, PHP 7, Python, AND Go applications all using the same application server, with seamless and no-restart configuration changes and application updates. It also lets you do blue-green deployments on the server.
A lot of what I do is of single URLs but with absolutely no rhyme or reason to the content structure between the sites. Im not sure how I would actually approach it as multiple URLs. 
How's so?
It's interesting they are not providing the signing key over HTTPS in the installation manual: http://nginx.org/keys/nginx_signing.key
Looking at the comments on php.net for, really, anything is amusing and this one is particular entertaining. Do you have any specific behaviors you'd care to elaborate on?
Instead of doing a proxy_pass to your single-threaded development server, you can use a more legitimate (performant) server configuration which you can tweak independently of the 800 other things nginx is doing for your microservices-based ~~clusterfuck~~ platform. It seems like the middleware needed to build tomorrow's cPanels. Nginx gets to be the reverse proxy with crippling feature creep everyone deserves, configured at an organizational level by nasty unixbeards no one fucks with, and configured at the level of individual microservices by regular devs who know enough nginx unit json syntax (there's barely any to know) to deploy things at predetermined location endpoints (again, predetermined by the nasty unixbeards no one fucks with). I'm guessing that's kind of what it's for. "Here's the equivalent of a ~/public_html directory for your service, go nuts" basically. Am I off base?
&gt; You should set 777 permissions for upload and DB directories oh.... dear..... god..... I'm not even going to look at how bad this code is, that line says it all
Ah yes, my mistake. Disregard.
If Valet is working for you then sure. Mamp is great for starting, but most people move to Vagrant quickly, or go to Docker.
I had tried to set up Vagrant and I just ended up going down one of those yak-shaving holes to try to get it working. I just found it really tricky to set up, but my knowledge of the whole unix environment was not so great back then. Maybe I should give it another shot. 
Can you make regular curl requests to https sites without a problem? 
I had some trouble with it at first, then I started to see some light. Now, its fairly simple with Laravel Homestead if thats the box you wanna use. 
If you're going to dump MAMP, I'd suggest trying to learn Docker as containers are the future of where the industry is heading. I made a post the other week sharing my experience getting started with it which you can see here: https://www.reddit.com/r/PHP/comments/6wnlo4/docker_getting_started_why_its_useful_how_to/ # EDIT: So someone downvoted my comment, I'm assuming due to the "containers are the future" remark. Let me clarify that I'm not trying to put down Vagrant or virtual machines, and I don't think that comment should be controversial. To quote an article featuring senior product lead for Google Compute Engine's Craig McLuckie: "McLuckie believes containers will complement rather than replace virtual machines. The Google Cloud Platform -- App Engine and Compute Engine -- puts a customer's workload in a container, then puts the container inside a virtual machine."[1] ## Containers are a proven technology that is actively getting even better Containers are not some unproven technology. It's been stated that pretty much everything at Google runs in containers (they were using them even before Docker with their "Borg" container management software [1]). After they outscaled Borg they developed another management software Omega [2], and then in more recent times it was Google engineers that started the popular Kubernetes container software. You can read about Google Vice President of Infrastructure Eric Brewer talk about Containers and his work on Kubernetes here: https://medium.com/s-c-a-l-e/google-systems-guru-explains-why-containers-are-the-future-of-computing-87922af2cf95 ## Adoption By Major Service Providers Although Google is a great example of containers in enterprise level usage, they are far from the only company using containers. One example mentioned in the article with Eric Brewer is that Snapchat runs their infrastructure on docker containers hosted on Google Cloud. The other lists I've seen include GE (general electric), BBC News, Uber, Lyft, Spotify, Groupon, eBay, Expedia, Paypal, and the list goes on. * https://www.contino.io/insights/whos-using-docker * https://www.docker.com/customers ## All the major cloud service providers are now offering container hosting: * Amazon - https://aws.amazon.com/getting-started/tutorials/deploy-docker-containers/ * Microsoft - https://docs.microsoft.com/en-us/azure/container-service/dcos-swarm/container-service-deployment * Google - https://cloud.google.com/compute/docs/instance-groups/deploying-docker-containers ## And it's being actively marketed by the cloud computing Big 3 * https://aws.amazon.com/docker/ * https://www.microsoft.com/en-us/cloud-platform/containers * https://info.microsoft.com/rs/157-GQE-382/images/Container%20infographic%201.4.17.pdf * https://cloud.google.com/container-engine/ . I want to clarify that **I don't even use docker currently**, so I have no dog in the fight and am not some crazy fanboy. The ecosystem surrounding it is also young and there definitely seem to be things that can improve. However, when someone is asking what their tech stack should look like if they dump MAMP, I think it would be highly disingenuous to not recommend they look at Docker. . 1. https://www.informationweek.com/cloud/infrastructure-as-a-service/google-docker-does-containers-right/d/d-id/1319146 2. https://medium.com/s-c-a-l-e/google-systems-guru-explains-why-containers-are-the-future-of-computing-87922af2cf95 3. https://www.informationweek.com/cloud/infrastructure-as-a-service/google-docker-does-containers-right/d/d-id/1319146 
If everyone moved 1,000,000 feet closer to all the web hosts we could do the same thing. 
Cool. Thanks!
+1. It can be reused in front-end.
I wrote this article awhile back that may help you: https://pathfinder.space/2015/09/get-going-with-laravel-on-docker/ 
Great stuff, as usual. Nice to see a clear summary.
Do you have the openssl extension enabled? 
Very much is: [07-Sep-2017 15:34:42 UTC] PHP Fatal error: Access level to PHPExcel_WorksheetIterator::next() must be (as in class !) or weaker in /home/x/public_html/x/x/monthly-export/Classes/PHPExcel/WorksheetIterator.php on line 29
OP didn't miss anything. This is the exact error message. Don't always assume everyone is an idiot. Very much is: [07-Sep-2017 15:34:42 UTC] PHP Fatal error: Access level to PHPExcel_WorksheetIterator::next() must be (as in class !) or weaker in /home/x/public_html/x/x/monthly-export/Classes/PHPExcel/WorksheetIterator.php on line 29
Actually, i'm about 9 hours of googling this issue thank you very much. Everything I have found so far says what you are saying, but then PHPExcel is implementing the base Iterator class, then telling me you cant override a public function with another public function, yea i'd love to hear what you have to say about that.
mod_(php,python,go) for nginx?
Any ideas on this?
To think about this even more broadly, regardless of whether you use constants or not, you need to pick one of the following: * 1. References to hardcoded numbers (this is what you currently have with constants) - nice and simple and lets you rename things fairly easily with some search and replace * 2. References hardcoded strings - makes it difficult to rename something - rarely a good option * 3. A regular database table with an ID column, and a column for some kind of keyword string (likely the PHP class name) - the most flexible, and likely the logical choice once you start having many different items. Seeing you feel like there's too many items now and it's getting messy, you might be at the point of #3. Put some methods in the parent class to convert IDs to class names and stuff like that. And if performance is a concern (i.e. you don't want to query the DB every time you convert a the 'ID number &lt;&gt; PHP class name') and you still want to be able to use constants, you can write a small maintenance script that outputs the SQL records to a PHP file of constants. This might also help with migrating from your current usage of constants through-out the code base, and autocomplete and stuff. But the autocomplete should mostly be handled in your PHP classes.
who needs a plugin when you have good old CGI! /s
thx!
Goddammit, dad......
Definitely meant domain specific errors that are shown in ui/to user. Couldnt find my post without logging in and viewing recent posts. Does someone with this subreddit delete post relating to certain topics? 
This. There are probably many great examples but one I recently looked into was the Laravel worker daemon. Works very well and had self-protection measurements: watching its memory/execution/signals between runs and uses external tools for continuous restarts (supervisord). It's not always feasible to use NodeJS when all your logic you need you already have in PHP
Why?
This in not a support sub-reddit and stop posting the same shit. https://en.reddit.com/r/PHP/comments/6yitry/php_upgrade_causes_access_level_errors/
&gt; https://pathfinder.space/2015/09/get-going-with-laravel-on-docker/ Hey, a quick note about this guy's tutorial. He goes about setting up a docker environment in a different way than in my tutorial (not necessarily bad, just different) and I just want to make a quick explanation about the difference between them. In his tutorial he takes an Ubuntu image and installs both Nginx and PHP into it, using supervisord to manage the processes. This all gets packaged together into a single container which is then used in his Docker Compose file as the "web" service. This is in contrast to my tutorial where Nginx and PHP are both separate services. I asked the main devOps guy at my company if one approach was better than the other and his response was that either works just fine. The main difference comes down to how they would scale in a production environment. When Nginx+PHP are packaged together, in order to scale your app horizontally (to multiple servers) you would have to scale them together with both running on every server. However, Nginx takes less processing power than PHP, so if they are packaged separately it would be possible to have Nginx running on just one server, but have say multiple servers running the PHP container. I'd also argue it's a little more work to upgrade to a newer version of PHP if they are packaged together, but that's whatever. Hopefully that helps you understand the differences between the tutorials in-case you're curious. :)
It is code that is oriented around the one path to success, instead of the multiple paths to failure. For every case where the validation fails, the code should provide the flexibility to do something more than just bail out. How do you differentiate between a form submission that fails because the name was blank versus the email is not valid? One thing to think about is that when the validation is successful, it ends up one block level deeper. If there is a new requirement to run 'message' through a spellcheck, does a second successful check put it yet another block deeper? If we keep changing the block depth, do we adjust the tabs for "do the thing" and force a meaningless commit to those lines?
&gt; Does someone with this subreddit delete post relating to certain topics? I was surprised when I found the text had been deleted; thought it was you (the author) but apparently not. /u/frozenfire do moderators delete the text of posts sometimes? 
&lt;- This guy/gal fucks!
I attempted to hold back my laughter from reading this and in doing so choked and bit my tongue. Damn You. 
What are your arguments ?
Looks like it was a great event. Sorry I missed it. one day I'll make it over there.
Hey, thanks. :) Not just a framework, a full-stack solution for creating, deploying, discovering and sharing applications / APIs built upon remote "serverless" functions.
Lol. I've been head on with this. They know where they stand. 
_less pets, more cattle_
Use Vagrant or Docker instead. Laravel has a first party Vagrant box which is pretty good. Installing MySQL, PHP, etc on your own box is essentially MAMP just without the MAMP.app UI and is less self contained.
I haven't. Is cyber coders a good resource? I'm not a programmer. I have exhausted all of my options for finding someone via recommendation. I figured I'd post here to see where it leads. We have the resolution to the problem (which we got from the vendor), but just don't know where or how to do it. Our interface isn't supported by the vendor. All custom code. It's a problem with a specific hook in an API. It's kind of like having a car but no road to drive on. 
I think it's the `live re-configure` which to my mind is a misunderstanding / misapplication of the value chain. Things that change most often are the least valuable / most experimental. Why you'd want to be able to change faster than rule-update and reload IDK. Then again, I tend to like working on SME projects, so maybe it's not for me.
This reminds me of docker/containers, just .. less useful, harder to scale .. ? Don't get me wrong, it looks very interesting, I'm just not sure where it fits in the docker world ;)
Ideas on what? Multiple people have answered your question fully already. And you still haven't answered what versions of PHP you think you've updated from and to?
Well Symfony constraints returns each failure as its own violation, so if you want to deal with them separately you can. Also adding more constraints is as simple as using an array `'message' =&gt; [new Constraints\NotBlank(), new MySpellCheckConstraint()]`. And there is nothing stopping you using the fail fast principle: if (!$this-&gt;validateInput(...)) { return 'Failed user name'; } if (!$this-&gt;validateInput(...)) { return 'Failed email'; } return 'Valid'; The fact that is flexible enough to cater for these use cases is a plus IMHO. Side note, any modern diff tool can ignore white space changes. 
Looks like the post got removed by another mod, who likely saw it as a help question, versus a discussion. I've approved the post. Sorry about that.
con, like confidence scam? 
I think there's a lot of hate from people who see containers as a overly complicated way to build simple LAMP style web apps. In some circumstances, that may be true. If you've already got infrastructure to turn on a VM easily, and your app is never going hit more than ~25 concurrent users - then using docker just seems like an extra layer of needless complexity. I still use vagrant to build the local dev environment for my current project, because I find it easier to experiment with different bits and pieces. Adding reddis, memcache, a profiling tool, or whatever else I might try to a full nix box is easier than dealing with docker images, and I can push the network configuration of those down the line until I'm sure I want to keep using them. However, my CI pipeline uses docker images for testing, and staging and prod will probably go the same way once I get the app to that stage. To the OP, if you really want to know how the pieces fit together, I'd recommend building a LAMP stack on a VM running Ubuntu (because of apt mainly), then automate the creation of that using Vagrant, and then when you want to start running Continuous Integration (CI) or Continuous Deployment (CD) then look at Docker. I recommend this approach, because each stage builds on what you learnt before. tl;dr; Parent is right, but VMs are still useful. Use the right tool for the job.
You can add the https https://nginx.org/keys/nginx_signing.key
Because they are? I know pear is. aptitude -y install php-pear &gt; Pear is no longer compiled by default, instead you need to install php with the --with-pear option, such as: brew install php56 --with-pear. &gt; github.com/Homebrew/homebrew-php
Less cattle, more chickens. 
Pear is practically deprecated. You should be using Composer instead. And libraries are pretty straightforward anyway - they're scoped to the project and live conveniently in the project directory. As for pecl, since it's system level installs (php extensions), it's necessarily more complex. Different systems have radically different system installs.
On debian pecl is under the php-dev package, php7.0-dev respectively.
Certain shit, like the Oracle eBay connector still requires pear or compiling from source. It's infuriating. 
I don't think it's really meant to fit in the docker world - it's probably more meant to bring a little tidbit of it to those that aren't there yet. Probably more targeted towards shared hosting environments and small teams that aren't on the cutting edge.
Sorry for the tease :-) Perhaps if you rephrase the question, people can be of assistance ;-) Your question says: I need help in "how to find a developer". Well I guess you found a lot over here.... you don't need help with that. But perhaps you meant to say: I need a developer to help me with a development gig..... In that case, I would mention the help part in more detail, like : what is the problem you want to solve. 
every modern php development library is available via composer. If you still want to use other ways, then you have to think about the future of the library (does it have one?)
Just a hint: spellcheck. Nice article, but the typos distract a bit.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
For quick development , I always use laragon (which is like mamp, but easy, and flexible) https://laragon.org/
Hope to see you next year
Compile?
Given you've deleted a lot of posts, the one thing I've got is the quote below. &gt;double hashed passwords with md5() If you truly mentioned this in any capacity other than describing "what not to do", and you're here calling anyone incompetent. Nope, this is a troll account. 
copy/paste it then?
&gt; IDE cannot autocomplete the setters/getters because they aren't concrete methods. You can work around this with class method annotations. But for me the biggest problem is debugging of magic methods. If you don't have a break point in your setBlaProperty the debugger will not step into it.
Really useful summary - thanks for sharing.
 $ /c/XAMPP/php/php.exe -m | grep openssl openssl
Request https://github.com/request/request and cheerio https://github.com/cheeriojs/cheerio are my friend for this First one for fetching content, second one for extracting content from dom using jquery style selector.
what a fucking spam. reported
Trying to try the version with docker, but it seems xdebug is not available for 7.2? 
I think that Xdebug is not available for 7.2 yet. If I understand it correctly, it usually needs a lot of changes to follow the changes in PHP. Doctrine is waiting for it as well: https://github.com/doctrine/doctrine2/pull/6577#issuecomment-325842143
Thank gods this "tutorial" won't actually work in PHP 7 (uses mysql_*)! Sins at a glance: * Uses removed mysql_* functions * SQL injection vulnerabilities galore - should use parameterised queries * Uses md5 with passwords - should use the password_* functions
Fuck grouped namespaces.
[@spazef0rze's latest tweet](https://i.imgur.com/sOrhPag.jpg) [@spazef0rze on Twitter](https://twitter.com/spazef0rze) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Why?
Because it's horrible. The only two arguments in favour of it are: - Readability: very subject as personally I find them ugly e.g. `use A\B\{C\D, function b\c, const D};` - Avoiding to type some characters or extra lines: really the use statements are the last case I would worry about for this. Just get an IDE or editor that does the import/auto-complete for you or deal with it. And on another hand: - It's not useful per so: only esthetics - Add yet another way to do things - Make it harder for PHP code analysis tools like PHP-Parser or any consumer of the generated AST TL:DR; it's an abomination and putting that in the core was anything but a pragmatic decision.
I've done the following test: &lt;?php $curl = curl_init("https://www.twitter.com/"); curl_setopt_array($curl, array( CURLOPT_RETURNTRANSFER =&gt; true, CURLOPT_SSL_VERIFYSTATUS =&gt; true, )); $response = curl_exec($curl); var_dump($response, curl_error($curl)); curl_close($curl); And it returned the following: C:\XAMPP\php\php.exe "C:\Users\Defalt Hackinson\Desktop\curlTest.php" C:\Users\Defalt Hackinson\Desktop\curlTest.php:8: bool(false) C:\Users\Defalt Hackinson\Desktop\curlTest.php:8: string(25) "No OCSP response received"
That's not very good. Aside from it being verbose, it's very loose. I'm alarmed you don't constrain length, you also don't constrain the contents of most fields at all. It's ok for "name" and "message" to be unconstrained in terms of contents (length aside), but you'd think fields like "precedence", "position", "status" and "type" will have more concrete formats. The library should make constraints like these easy and natural. Comparison with my personal library: use Foo\Bar\Formatters as f; $input = f::dict() -&gt;required('name', f::text(1, 100)) -&gt;required('email', f::email()) -&gt;required('message', f::text(1, 64 * 1024)) -&gt;required('groups', f::list(f::dict() -&gt;required('precedence', f::int(0, 5)) -&gt;required('position', f::int()) -&gt;required('status', f::enum('pending', 'processing', 'success', 'failure')) -&gt;required('type', f::enum('foo', 'bar', 'baz')) )) -&gt;apply($input); 
This is array dereferencing, added in PHP 5.4. If that index is all you need from the function, then I see no problem with it.
Give Homestead a try, it's pretty much ready to use out of the box.
I'm against it for readability, but just my opinion: the function should return an array and you should pick the element after the function call. $vars = function(); $var = $vars['index']; 
I always like array dereferencing. I do this from time to time. I feel it express the intent in a fairly clean and concise manner. Maybe it's one of those "strange until you're getting used to it" things.
No pipe operator?
In this case you are actually an idiot, though.
&gt; estethic 
What a strange comparison... Serverless is not only about just uploading some code that can be scaled beyond regular limits but mostly it's about your code being executed by all sorts of triggers.
I think this is said by someone who doesn't understand the concept of "cloud". I've worked on an app that would have 100k+ users for only a few hours a week and with AWS you could just boot some servers for the event. Try to do this with your own metal servers...that would be very expensive. Also, something like AWS S3, try to build something with such high availability yourself. So even though in some way cloud is "just a bunch of computers in a datacenter" it's more about what the service that is offered and brings you reliability, stabiliy and scalability which you could not achieve on your own.
I think it depends on the usage and context for me... I would prefer $firstname = $user-&gt;get_info('firstname'); over $firstname = $user-&gt;get_info()['firstname']; Partly depends on if it's a function that you are at liberty to change or not, and it seems to me that if you know the index you're after, particularly if it's a large array the function returns, it's cleaner to only get the element(s) you wish to use in that part of the code?
Still on 5.6 at work :-( So much talk about migrating/upgrading, so little action. I think nobody understands how backwards compatible it is and how important it is to upgrade before security updates end.
I don't like it, because no checks for the return value are done and since there is no space for them, nobody misses them.
What makes you say "nobody understands how backwards compatible it is"? The list of deprecations are pretty clear and straight forward, and most of the CI servers now support 7.2/nightly. 
Returning an array does not preclude the function from throwing an exception if a problem is encountered. If, by design, the function is guaranteed to always return an array with specific keys then there is no need for explicit error checking. Resulting in cleaner more readable code.
Considered PHP &gt;=7.1 you could go with strict types and expect the return value to be an array. This way the only thing happening could be non existing index but this could be solved using null coalesce operator. declare(strict_types=1); function abc(): array { return []; } $var = abc()['index'] ?? 'default'; If you are not working with strict types, there is always the risk of no checks being done (as mentioned in some other comments). So your application might break.
 You mean $object-&gt;sometthing() |&gt; method() ? No.
The typo is all you took?
If everyone moved within 1foot of eachother and severs ping wont be a thing
$var = function(); $var = $var['index']; The above would raise the same PHP warnings. I don't really like to wrap everything with `if()` blocks.
The language has really matured. I'm happy to use it.
[removed]
Is all you need to know about outsourcing your IT services to an India-based company. 
I assume mjcov is referring to his/her work colleagues, rather than the community at large.
Yeah, it's available on https but their docs links with the http protocol.
If this link as merely OP taunting how terribly unsafe that code is (injection), please use a means of indicating sarcasm in the thread's title. If OP actually think this is how you should write PHP code interacting with a database, I'm going to have to report this ticket. The blog post is from 2012, yet some ignorant souls or troll-boys still praise this solution in 2017. I'm baffled...
&gt; RFC: Parameter Type Widening Does this work with interface implementation or just when extending a class?
The new stuff is good. But I'm just as excited to see the deprecated features that will be removed. Slowly remove all the warts as they add the good new features.
Yep. It was a proposal for 7.2 that looked very will received. I was most excited about that.
I feel you. My place is still working with a bunch of 5.6 sites, and there's even a couple legacy 5.4s floating around (and one 5.3 we are updating to 5.6, thank god)
FWIW, it compiles against the 7.2 Code base but there’s no release. I know Derick appreciates test feedback, so if you’re willing to install the devel version, go for it and give feedback!
&gt; A typo is when you can't use a keyboard but in your case you can't use a dictionary. I think it's time to get off reddit for the day and take a walk or some shit to get rid of your angst.
Yea the implementation of grouped namespaces has always looked janky as hell to me.
For Argon2i to have a fixed length of 98 characters implies it: * Cannot use more than 9999 Kb memory * Cannot "cost" more than 9 * Cannot use more than 9 threads * Version cannot exceed 99 That seems a bit shit.
I feel your pain, friend. One of our last migrations to 7.x is happening tonight, but it's been a long road...
I was pre-emptive: https://archive.fo/ywBvZ
Before going full on laravel, i used [Valitron](https://github.com/vlucas/valitron) with Slim 2
Not sure about compiling, but: https://packagist.org/packages/pear/crypt_gpg Every time I need a PEAR package, I can just install it with Composer.
I have recently worked on a machine with 5.2. :(
Both - https://3v4l.org/X4n1r
oh man, that's great. :)
Here is what got the company I work at to finally update. We moved to AWS. For some reason changing everything at once was more palatable to upper management, even though that is exactly the opposite of what is practical. Anyway, I am loving 7.1 now that we finally have it.
I wonder if they will ever get rid of `$` at the start of variables...
I'm stuck with this... And cpanel!
You must be lost, please follow the yellow brick road home /r/ruby
Still got 1 here.. luckily it's internal.
They're gonna replace that with a language localized symbol in 8.0. eg. `£` in the UK, `€` in the EU, etc.
RIP
Were the mysql_* functions removed yet?
Plesk here. Seems a bit nicer than cpanel.
LOL MODS
TOP KEK
I'm going to reconsider my decision to not drink alcohol if that passes.
The "cost" you're referring to is the number of rounds. Argon2i is parametrized by: 1. Memory cost (number of parallel memory lanes hashed together) 2. Rounds (number of passes) 3. Parallelism (number of threads, which IIRC the memory lanes are split by the number of threads then hashed together with a domain separation constant in the last step)
as /u/digitalend said, it's my coworkers. I could tell them 1000 times to read that list, but nobody will, or they will read it but not comprehend or learn anything, and continue to repeat that we don't know what will break, how big of a migration it will be, that all code needs to be rewritten, etc.
A lot of great stuff but I'm disappointed to see trailing commas squeaked in. Devs have become so obsessed with cleaner diffs they're willing to let bugs sneak into their code.
the birth of region locked php software
In 7.0, yes!
I'm assuming you have a good testing platform that lets you try the upgrade and tests you can run to verify the upgrade was ok?
[Those died with 7.0.0's release](http://php.net/manual/en/migration70.removed-exts-sapis.php)
Try explaining benefits of Tdd to your stakeholders on a next standup. In many cases not up to devs.
You can convince your stakeholders as a dev as well. The only difference is, you have to tell them in different numbers. Money always works. If you calculate how much money they'll lose when not using TDD, often you can argue that you need TDD. Also your teamlead (if you are not one) should support the need for it. But this article is not about TDD, or that you HAVE TO use it. Because often TDD can be quite overhead on the get go if you didn't have tested before. Simple provide tests for stuff you need, for example some core functionality, calculations etc.
1. /r/phphelp 2. http://www.php-fig.org/psr/psr-4/
how do you calculate how much money you can save by using tdd? and then convince your boss/stakeholders to believe the calculation?
&gt; Oracle eBay connector You've got me curious, what is this? A quick google didn't find it.
From the docs: Serving Laravel Typically, you may use a web server such as Apache or Nginx to serve your Laravel applications. If you are on PHP 5.4+ and would like to use PHP's built-in development server, you may use the serve Artisan command: `php artisan serve` By default the HTTP-server will listen to port 8000. However if that port is already in use or you wish to serve multiple applications this way, you might want to specify what port to use. Just add the --port argument: `php artisan serve --port=8080` The caveat with this approach is that it doesn't match production. People have tried to solve this with Vagrant, and now Docker is all the rage (but solves a different set of problems... [1] ) If you work in an organization that has this infra, use what they provide. If you commit against a well tested continuous integration workflow I think `php artisan serve` is fine. It's basically the same as Mamp without the GUI. [1]: I'm old. Nothing has ever matched production. Ever. The Docker development flow is the closest I have seen but it is better suited for developers that recompile and/or restart their web server every time they save their files (Think: Typescript, Node.js, Python WSGI, Java ... ) It ends up creating a git looking binary blob that is supposed to be a final version of something. People say it's faster! Sure. Faster for ... production deployments ... When your web app is built with scalability in mind, when you intend your app to end up being multiple containers in a https://kubernetes.io/ like environment. If you are still using MAMP and page refreshes to debug, then Docker is a long way from solving your problems.
Lets assume you have shipped a feature without testing it. Some variables: * Total cost of the feature (developing + shipping) is worth **$48.000** (40h of one developer) * Feature will make **$10** every minute * The developer costs **$20** every minute he is working Your features breaks, sometime. It needs 1h to detect that its broken. The developer needs another 1h to find the bug and fix it. And rolling it out 120m * $10 = $1200 // 1h downtime + 1h fixing - theoretical feature income 60m * $20 = $1200 // 1h fixing - cost for a developer to fix the bug Lets assume deploying takes 0 time. This would cost your stakeholder a total of **$2400** to fix the bug. That would increase the cost of the feature, because this is basically time you invest IN the feature until it works again. So overall, your stakeholder pays **$50400** for this particular feature. Now lets see. If the developer has done TDD, which maybe takes some time more, which will of course depend on the developer to write tests - lets assume it would take 1h of the development on top. That would be raise the total cost of developing the feature to **$49200**. BUT it would not break on the same problem. So the 2h downtime would not happen. Of course, the time need to write tests would take maybe a bit more in the first place if you start doing (if you never done it before). But in the later on, this would save much more money. This may not be the most accurate calculation. But I guess you get the point. If it were impossible to calculate how much money some method costs, the job of a controller would not exist :)
After successful convincing, you'd better not have bugs in production, or stakeholders will kill you ;-)
Unfortunate. A lot more likely that people test both the next version of php and xdebug if xdebug exists for php versions that are available as RCs through conventional channels. Like I can't ask travis to run my testsuite against 7.2 because it cant do coverage report. 
Lol. Do you really assume that? Because everyone has right? Specially companies described as his..
Hehe. Well the advantage of tests is, that tested behavior won't break. If something new happens u would write a test against it. This way it never breaks again. Of curse this is investment. I yes I know what u mean. As said in the article I have fought for a long time to get some kind of tdd or at least a good test coverage for new features. This was a team effort to convince the stakeholders. 
I understand that. Honest question: do you generate coverage reports on all platforms? I’ve started generating them on one platform only to save time. Might be an option here...
What? How do trailing commas introduce bugs?
Isn't Active Sync that old tool that basically refused to sync? I feel like I use to have reoccurring nightmares about installing it on Macs for syncing to Palm Pilots.. it was basically a coin flip if it was going to work or not.. if it didn't you just need to try 10-20 more times and eventually it worked if you held your mouth right.. 
Php is the new Perl.
Wow, amazing. What does that have to do with anything I just posted?
To be fair there's way worse on that point, like Ruby :P
Typo, I'm on my phone ,on the move, not sure if this is the exact documentation but this is the db client I'm referring to www.oracle.com/technetwork/articles/technote-php-instant-084410.html
&gt; What does that have to do with anything I just posted? See: &gt; * Cannot "cost" more than 9 I was clarifying something you wrote in scare quotes for passersby so it didn't cause confusion. An Argon2i "cost" (really, number of passes) of 4 offers a much higher security margin than a bcrypt cost of 4, (assuming Argon2i is using 32 MB of memory and a parallelism degree of 1). Reusing the term "cost" here might make someone try to reason about it the same way they intuitively understand bcrypt cost factors, which would lead to bad experiences.
pear is easy enough but pecl is a bit harder, agreed though composer covers 98% of use cases.
Sorry, should have looked closer. Every part of the trailing commas RFC was voted down except for grouped namespaces so it's fine.
It s really impressive that this guys red the rfc and made a such detailed article. Btw it s not for random users.
Do you have to convince the stakeholders that you need to use factories? Or dependency injection? or to create another entity? Or to create another abstraction? Tests are a part of a high quality code. If you treat them as a separate — and disposable — thing, people will try to get rid of them to save some time &amp; money. I don’t, I just plan tests as a part of the feature estimate.
Lol if a company is scared that they don't know what will break moving from 5.6 to 7.0 then they obviously have a code monster lurking under the hood likely with no testing.
Trailing commas are intended to prevent bugs bro. When did a trailing comma in an array ever create a bug for you? 
I recently took over a project using Plesk. Plesk 17 is actually quite impressive. There is a nice CLI tool `plesk` that you can automate shit easily so end users get UI, and you can automate most of the things.
&gt;$49200 they'll just counter that this new feature you'd instead coded would increase traffic by 0.1% making up the money. instant fail. "don't fix what's not broken" they'll say. SAD P.S&gt; Better yet - if you actually convince them -&gt; they'll do something completely wetahded like outsource just a TDD part to some Indian shop that will write tests in java for you.
All it takes is one dev or engineer with average skills to put together Docker containers that will test legacy apps using upgraded software. Where I work the red-tape gets sticky. Requesting a server? Takes weeks. Docker allows us devs to get shit done in the meantime. Hurry up and wait.
CentOS provides most pecl packages in RPM format via yum.
Still doesn't refute that it cannot be greater than 9.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
a lot of extensions like php trader libraries seem to depend upon pecl to install... 
It works for me, for http and https. I guess they fixed it.
Laravel with a good crud system?
On the contrary, if I'm understanding things right, I believe Nginx Unit will work great for running your app inside a container.
Don't worry, we thought of this. For international interoperability you can use the universal `¤` symbol!
Internally I think PHP treats those as the same, at least insofar as checking compatibility. Interfaces are just abstract classes with multiple inheritance, after all ;)
No idea how or even if it would be possible to say to travis build differently based on php version. The script lists runs on them all. (Talking about .travis.yml)
Sounds pretty useful. Otherwise, every library would need to write their own operator wrapper functions. However, I don't think these function names are valid for userland functions, so we can't write a compatibility library that polyfills the functions on old PHP versions. Maybe it would be better to just use regular function names like plus(), shiftLeft() or pow() (which already exists) which can be implemented by user code. These function names seem to add another little inconsistency into the language.
I actually like this suggestion more than the proposal.
The existing function names in the RFC are ~~intentionally~~ fortunately unable to be polyfilled, as using names like you suggested would mean a pretty big BC break. That's a non-starter for something this niche.
Somebody posted and deleted the following comment, which I wanted to respond to in case others had similar concerns: &gt; To my mind, everything about this looks wrong... like... function call of an arbitrary string wrong. &gt; &gt; I don't see what his provides the PHP ecosystem to make up for how ugly it looks. PHP 7.0 and higher already has this functionality: https://3v4l.org/m3DM5 
I think I just didn't see a need to rename the operators. `'+'` is intuitive (it should be obvious what it does if you know `+` exists) and it's short. The complete absence of BC breaks is merely a nice bonus. I *can* see a use in “friendly” names, but I think those make more sense for method names in potential future operator-overloading interfaces, rather than for global operator functions. Said methods could be more specific subsets of what our current operators do. EDIT: Some other reasons I like using the operator symbols: 1. You don't need to remember a second set of identifiers for them (if an operator has symbol X it has function name X). 2. It avoids ambiguity (would `or` be `|` or `||`?) 3. It avoids naming conundrums for operators that do multiple things (`+` is both numeric addition and array union, `^` works on both integers and byte strings) (i) We don't have to have a bikeshed about how to split operators into sub-operators :) 4. Generally you should be able to forget that operator functions are special things in the standard library and just think of it as being able to pass operators as callables, which is the end goal!
The RFC even points this out (though I've edited it now to be more clear about this). This wasn't my idea, and in fact I was surprised it worked!
What would it do?
"Intentionally" was definitely the wrong word (I edited).
That was me posting, I was going to re-write but got distracted by Metal Gear Solid V (7 replays of the same mission to get Quiet back?!) I personally think the string call is an ugly mechanism, it's a syntax which to my mind makes the code less intuitive to read, mixing symbolics and constant strings, which yes has been around for a long time, but that doesn't make it clean... I get a gut feeling that it just seems wrong, especially as there's a "clean" way to do it at the moment using functions which would be flexible (and effectively over-loadable) vs trying to emulate a particular opcode as a function.
One is a syntax error when you forget to do something. The other is a linter error when you forget to do something. For normal programmers, the syntax error was a once-every-few-years problem, while the linter error is now a several-times-a-day problem, because writing syntactically correct code has been seared into their subconscious and trailing commas are an abomination that their brains completely reject out of hand before the premise ever reaches the decision-making region. Trailing commas ranks right up there with null pointers.
Pipe operators make code super duper readable. Instead of `three(two(one)))` it would be `one |&gt; two |&gt; three`. It is a much nicer syntax used in functional programming languages.
It would pass result of the function call into subsequent call. [RFC](https://wiki.php.net/rfc/pipe-operator) a() |&gt; b($$, $param) |&gt; c($$) |&gt; d($something, $$) === d($something, c(b(a(), $param)));
You have assumed incorrectly. We have many client sites built on top of mostly Codeigniter but some Wordpress and Laravel, each in varying stages of decay depending on whether the client has continued to pay for upkeep or just hosting. Since they're hosted in something like a shared environment spread across several servers, but not containerized / in a VM per site, there's no easy way to just start making new sites with a new PHP version.
&gt; I personally think the string call is an ugly mechanism Me too, but who is going to write `'+'(1, 1)` in practice? &gt; emulate a particular opcode as a function There's not really any “emulation” here (with the possible exception of `&amp;&amp;` and `||`). Almost all the operators have a corresponding internal C function. These functions are just wrappers that call said C functions.
&gt; All it takes is one dev or engineer with average skills to put together Docker containers that will test legacy apps using upgraded software. It also takes time that they'd rather budget for paying clients needs (billable hours), so nobody has time to work on improving development process. We're supposed to get 20hr/month each for that sort of stuff but it usually gets taken away because of other "more important" needs.
This feels like "stringly typed" operators. The language shouldn't have strings with special meanings. This might work with the actual operator (`$numbers = array_map(+, $_GET["numbers"]);`) or a constant for the operator (`$numbers = array_map(Operator::ADD, $_GET["numbers"]);`), but that also feels a little confusing. It may be best to leave well enough alone with this one.
Well a (non inline) function assumes the creation of a new set of data on the stack and a given return value. Where as the opcode is directly manipulating zval pointers. I think it would make much more sense for the examples given to just define a native class with static methods that has the relevant operations contained within.
&gt; The language shouldn't have strings with special meanings. That ship sailed two decades ago. If it makes you feel better, you can do `Closure::fromCallable('+')`.
I guess if it's not introducing strings as operators, but just applies them elsewhere then this feels better. Thanks! TIL!
Well, thats not really the fault of the library, more just the example I gave. There are `Range`, `Type`, and `Choice` validators, and more: https://symfony.com/doc/current/reference/constraints.html Also your library looks inflexible, and breaks the single responsibility principle. How do you even add or extend validators if you are calling static methods? And as for being more verbose, your example is basically the same. Is your personal library avalible?
There is https://www.adminer.org/en/editor/ Demo: http://adminer.sourceforge.net/editor.php?username=
I read the RFC but fail to understand what this is for. Can someone please educate me on how is this going to be useful? What Im getting is that this is a poor man's implementation of operator overloading. I dont think other languages have a so called "operator functions".
Actually I think this is pretty cool! Totally agree about the issues of security and these have bit me on the arse with CSRF and XSS, nice to see a language incorporate these concepts into the core (no matter how simple the language is at this point in time). My rough sample from interviewing PHP developers of varying skills, is that about 30% know what CSRF is, 60% knew XSS. I think basing this language on PHP is cool, but if you even further abstracted this language, it would be interesting if this language would be able to run on Python, Ruby, Go, Node... I'm not 100% sure if there is a use case for this, but it potentially could make the language more portable. Haxe has proven you can have a cross compiled language, but a cross transpiled language might be something new? I think you have something cool, but I don't think you have found your use case, I think THT just needs to solve 1 more problem and you might have something really interesting. Maybe it's the ability to run on more than one platform? Maybe it's being able to transpile to something that runs easily on some hobby hardware like Arduino? (yes you will pull me up on all this stuff existing, just thinking out loud here). 
I'm the senior dev at my shop and am in the process of upgrading the team's dev environments to a Docker environment using php7.1, while staging will still use 5.6. Once we've been developing in 7.1 for a few months my boss and I can make the case that the code is already compatible and there's no reason not to upgrade. It has worked nicely so far - none of our apps have even raised any notices. 
While making sweeping statements like this is a point of pride for your own skills, the process has taken my shop several weeks, including change management efforts to train my team on the switch from Vagrant to Docker, configuring the application environment to respect its cross-server and auth dependencies, etc... It's worth doing, but it does require a cost benefit analysis and the cycles to implement it. 
I'm not familiar with functional programming conventions, but I can see how it could (would) be more readable.
Did you read the examples? What makes you think this is a form of operator overloading?
Er, to be clear, what I meant by that is PHP has always used strings for passing function names to things. These are just a new set of functions with slightly unusual names, but they're otherwise nothing special.
&gt; Well, thats not really the fault of the library, more just the example I gave. There are Range, Type, and Choice validators, and more: https://symfony.com/doc/current/reference/constraints.html I'm very familiar with Symfony's library and its (many) faults. Faults like: you validated a form of scalar fields up there, and a list of dictionaries. Oddly that's all Symfony offers out of the box. Sub-dictionary (i.e. $foo['bar']['baz']), list of lists, any other composite structure? Not supported. Recursive structures? Not supported. Unions, intersections? Not supported. As for the example you gave, you need to offer a good example in order to judge the library API effectively. And that's what I'm criticizing mostly - your example. It's severely underspecified and very loose. In the real world it'd be trivial to abuse that form. "But it's just an example" is a poor excuse for how little your constrained your input. Mine's also an example, but it's not artificially weak in any way. Notice how many more constraints I managed to add to the form in my example, while having **less code overall**. Try to reproduce what I did using Symfony validators, you'll end up writing 2-3 *times* more code, and lots of "stringly" configuration like "fields", which is just poor API design (they could've easily made this a builder for ex.). Also, error reporting - I can add exactly 5 characters to my example, in order to receive detailed hierarchical report of validation errors (both machine and human readable) that occurred while processing that input (directly mappable to the form structure). As your discussion with other users here points out, that's another thing Symfony doesn't do well. &gt; Also your library looks inflexible, and breaks the single responsibility principle. How do you even add or extend validators if you are calling static methods? They're just factory methods. To say they break the "single responsibility principle" is... I don't even know what you're referring to when you say that. Everywhere you see a factory method called, you can instantiate your own class (or call your own factory method) or pass a closure with a very simple interface. It's extremely extensible and there's *zero* "stringly-typed" APIs in there, everything is autocomplete-capable in an IDE.
The RFC mentions Haskell has something similar, called Infix function. Haven't used them. But I don't recall anything similar in other languages. 
I really like some of Andrea's RFCs, such as Closure call, and void return type. But this, I don't personally like. - These function names are illegal in user space, so nobody will be able to write a polyfill. Proper CSPRNGs, Sodium, are some of the excellent features the language gained. There are also great polyfill for them, so you can forget about the minimum language version requirements. I'm not saying we shouldn't evolve; I would gladly bump my minimum version for scalar types and void return types, but I have doubts for this. - I suppose static analyzers will have hard time figuring out function name vs operator. - It doesn't really offer any new possibilities to the language. For each of these operators, it is pretty easy to write an anonymous function. This has been the case for array_map, sort functions, etc. Anonymous function make it easier to see the logic at a one glance. - The basic +-/* are much easier to predict, but not others if they accept multiple parameters. - Much difficult to see if it's an operator or a string. Turn off syntax highlighting and you'll see. Easily overlooked with heredoc syntax and &amp; references. 
&gt; Sub-dictionary (i.e. $foo['bar']['baz']), list of lists, any other combination? Not supported. Not sure what you are getting at here, you can nest `Collection` and `All`constraints. &gt; Try to reproduce what I did using Symfony validators, you'll end up writing 2-3 times more code, and lots of "stringly" configuration like "fields", which is just poor API design (they could've easily made this a builder for ex.). 'name' =&gt; new Constraints\Length([ 'min' =&gt; 2, 'max' =&gt; 10, ]), 'email' =&gt; new Constraints\Email(), 'message' =&gt; new Constraints\Length([ 'min' =&gt; 1, 'max' =&gt; 64 * 1024, ]), 'groups' =&gt; new Constraints\Optional(new Constraints\All([ 'constraints' =&gt; new Constraints\Collection([ 'fields' =&gt; [ 'precedence' =&gt; new Constraints\Range([ 'min' =&gt; 0, 'max' =&gt; 5, ]), 'position' =&gt; new Constraints\Type('int'), 'status' =&gt; new Constraints\Choice(['pending', 'processing', 'success', 'failure']), 'type' =&gt; new Constraints\Choice(['foo', 'bar', 'baz']), ], ]), ])), Thats not exactly 2-3x more code (well what are we counting, lines, bytes, or actual code?). But yes I do somewhat agree that having `min`, `max` arguments as an array is not ideal. So your unreleased library, how would you combine my own custom validator? Like this? -&gt;required('message', [f::text(64 * 1024), new MySpellCheckFormatter()) 
I'm a freelancer, and I can see what you are saying first hand. For almost any project I bill per hour, clients don't want me to write tests. Some projects are messy as hell that you can't write unit tests at all. With system/integration tests, I can grow a full beard by the time test suit runs, and I'd still run into bugs. A few days later, the client is grumpy and you start to just do it without proper tests. And then PHP 8 releases, and shit like that happens. 
&gt; Thats not exactly 2-3x more code (well what are we counting, lines, bytes, or actual code?). It's twice more code whatever you count. And thanks to all the stringly-typed arguments, like "min", "max", "constraints", "fields", it'd probably take you at least twice the time (I'm being generous and assuming you don't typo one of those thus making it all even slower). &gt; So your unreleased library, how would you combine my own custom validator? Like this? &gt; -&gt;required('message', [f::text(64 * 1024), new MySpellCheckFormatter()) Depends how you want to combine them. There isn't a single way to combine things: f::or($f1, $f1, ...); // Union. Matches each format individually, stops on first match. f::and($f1, $f2, ...); // Intersection. The combined output of all formats (useful for combining dictionary formats into bigger dictionaries etc.). f::pipe($f1, $f2, ...); // Pipeline (functional composition). Feeds the output of every formatter into the next formatter. And of course you can just pass: function ($input, $log) { ... apply any number of formats in any way you want }
I've only spent a couple hours working with Haskell, but my understanding is that infix is just an indication of (basically) what order parameters are passed - e.g. `infix function +(a, b)` isn't called as `+(val1, val2)` but instead sits between them in the way you'd expect: `val1 + val2`. Swift supports it as well. The concept doesn't translate to PHP at all due to how language parsing works (defining an infix function is basically defining new language syntax at compile-time) Being infix or not is largely irrelevant to the utility and the RFC - this is just trying to solve the problem of functional programming concepts need to pass around functions, and `+`, `-`, `&amp;&amp;`, etc are not functions (hopefully I'm not totally misinterpreting things; I fully defer to Andrea on any corrections here)
&gt; It's twice more code whatever you count Not really, its like 20% more code if you also used aliases like your example. &gt; assuming you don't typo How is this any different than typo in a function name? The arguments in Symfony are strictly checked. My point about combining was more the fact that its inconsistant and confusing to mix constructors with static function calls. It also looks you library is mixing validation with sanitisation. 
Interesting idea to evolve PHP towards the likes of Haskell. I understand multiple ways of doing the same thing seems weird. I thought D's [Uniform Function Call Syntax](https://tour.dlang.org/tour/en/gems/uniform-function-call-syntax-ufcs) would be hard to remember and utilize but its similarly handy in more cases than I expected it would be. Potentially the same here :) I must admit I expected to see something like an incorporation of [Rx](https://github.com/ReactiveX/RxPHP) standards. Regarding that,this is rather something RxPHP would modify its code to use, I think.
The [original RFC](https://wiki.php.net/rfc/list-syntax-trailing-commas) allowed for trailing commas in functions and methods, among other places. I didn't realize almost all the RFC was voted down before commenting.
They are expanding thing like $a = $b + $c into some shorter version of functions... I was trying to write an example based on their example in the PSR, but currently my mind isn't working and I can't get something working with the map reduce... One the examples they show is this: "$numbers = array_map('+', $_GET["numbers"]);" So.. http://myurl.com/?numbers=1... you shouldn't be able to do numbers=1&amp;numbers=2.. Also no sanitation... OK. I'm starting to think that these people are f'ing drunk. This is PHP, original built in PERL to be C like. PERL can be a mind boggle, and the shit that is happening with PHP is mind boggling. Next thing you know, semi colons will be dropped. I understand what they are trying to do, but it seems that it's being done because people are like "wahhh I don't want to type... wahhh" and "I want to PHP to completely different but emulate all the other languages out there so it's unique because it's not like one lanugage." I think that PHP need to take a step back, fix the issues that have been an issue since the release of PHP 4 first (needle haystack stuff), fix the strange ass things they have done recently, get OO in order, and all the other issues and just call it PHP 8 and F all the backwards comparability. But there are so many people in the "council" that are like "I'm in it, but I like X language better, so we should make it like that", they need to be ejected. So want to go on and rant (trust me, I have many rants with the things that have happened in the PHP community), but I've got better stuff to do.
Have you tried using https://developers.google.com/apps-script/ to build a fool proof front end for them to use? I've just started something that might be good - http://www.directoki.org/ It's really for a slightly different case - that of a website where members of the public can suggest edits and additions, like a structured wiki. For that reason we have moderation. All edits are versioned to and it has an API to get the data. It's early days but it's already used in 2 production websites so we'll see how it goes ... 
Would this mean that we can get operator overloading as well, or is it aliased the wrong around for that?
&gt; Not really, its like 20% more code if you also used aliases like your example. Nope. 13 lines, 486 bytes: use Foo\Bar\Formatters as f; $input = f::dict() -&gt;required('name', f::text(1, 100)) -&gt;required('email', f::email()) -&gt;required('message', f::text(1, 64 * 1024)) -&gt;required('groups', f::list(f::dict() -&gt;required('precedence', f::int(0, 5)) -&gt;required('position', f::int()) -&gt;required('status', f::enum('pending', 'processing', 'success', 'failure')) -&gt;required('type', f::enum('foo', 'bar', 'baz')) )) -&gt;apply($input); 25 lines, 796 bytes: use Symfony\Component\Validator\Constraints as C; if (!$this-&gt;validateInput($this-&gt;input, [ 'name' =&gt; new C\Length([ 'min' =&gt; 2, 'max' =&gt; 10, ]), 'email' =&gt; new C\Email(), 'message' =&gt; new C\Length([ 'min' =&gt; 1, 'max' =&gt; 64 * 1024, ]), 'groups' =&gt; new C\Optional(new C\All([ 'constraints' =&gt; new C\Collection([ 'fields' =&gt; [ 'precedence' =&gt; new C\Range([ 'min' =&gt; 0, 'max' =&gt; 5, ]), 'position' =&gt; new C\Type('int'), 'status' =&gt; new C\Choice(['pending', 'processing', 'success', 'failure']), 'type' =&gt; new C\Choice(['foo', 'bar', 'baz']), ], ]), ])) {} Also your example still has the following flaws and omissions: - The "Type" constraint actually would run an "is_int()" check, so it'd reject floats, valid numeric strings, value objects with __toString() and so on. That makes it useless for most real-world user input processing (i.e. form fields are always strings for ex.). - The story of reporting the list of errors on each field is still missing. - Obscure text parameters that you need to dig into docs to figure out or know about. Zero discoverability. In my case I can pass a second argument to `apply($input, $log)` and all errors end up in the $log object, tagged by hierarchical field name, error type, machine readable error details and a human readable message. I can then output this as JSON API response, or use them to render form errors, whatever. Those should be basic features of any validation library. Symfony falls quite short. &gt; How is this any different than typo in a function name? The arguments in Symfony are strictly checked. It's extremely different, because: 1. In an IDE you're not typing any of these functions, the IDE autocompletes them for you, i.e. f::t[ENTER]. 2. If you mess something up, the IDE shows the error right there, instead of running the app, seeing an error, hunting back the file and line and only then fixing it. I just want to say if you're one of those "I code in Notepad" guys, I'm not interested in that line of argument. As a professional, I value my time and my clients' money so I use professional tooling, and I like libraries that make full use of that tooling, as well. &gt; My point about combining was more the fact that its inconsistant and confusing to mix constructors with static function calls. I didn't mix those anywhere. You chose to mix them in your own example, did I force you to do that? You can write your own factory methods, you don't need my blessing to do it. It's often better to use a factory, because often the **same class** can implement multiple types of validators just through reconfiguration. static function text($len1, $len2 = null) { $f = (new TextFormat()) -&gt;normalize() -&gt;trim(); if ($len2 === null) { $f-&gt;hasLength($len1); } else { $f-&gt;hasLengthBetween($len1, $len2); } return $f; } static function enum(...$values) { return (new TextFormat()) -&gt;normalize() -&gt;trim() -&gt;isOneOf(...$values); } Also mixing factory method (which returns an object), and calling a constructor (which returns an object) is hardly "inconsistent". The common theme is: the formatters are objects implementing a common interface. How you do it is up to you. The recommended way is factories. &gt; It also looks you library is mixing validation with sanitisation. First of all, this word "sanitization", doesn't exist in my dictionary when it comes to validators. I don't "sanitize". I validate and transform to a canonical format. And yes, this is necessary in real world applications because there are often multiple ways to format a value, many of which mean the same thing. So any sane approach includes things like trimming whitespace (when it's not significant), encoding, decoding, balancing etc. For example someone might give you this as a float input in a form: `" +0.0907401E+10 "`. This is a valid float. Is this what you want to work with? No, you either want to work with a canonical representation of this value as a string `"907401000"`, or you want it as a PHP float `907401000`. A more common example, here's a basic international URI: www.пример.com/путин-президент/ Is this a URI format you should support? In 2017, **absolutely yes**. But can you store it and send it as-is? **Absolutely not**. Here's it converted to a valid URI as most servers and clients need it: http://www.xn--e1afmkfd.com/%D0%BF%D1%83%D1%82%D0%B8%D0%BD-%D0%BF%D1%80%D0%B5%D0%B7%D0%B8%D0%B4%D0%B5%D0%BD%D1%82/ To do this automatically, effortlessly and transparently, you need to be able to transform input where you validate it. So the validation and casting/normalization of input are inseparable and part of the same concern: known, canonical and predictable domain data. In fact, I need to put this in the list of *flaws* with your example, as you can't even trim the input you're processing for whitespace. A basic operation.
Hi, looks really great! If you looking for points where you can extend the lib you could add helpers to create the object structure from different sources. I.e. if someone posts a resource object it would be great to directly create such on object from the json decoded body. Or you may want to add support for annotations (i.e. @Attribute or something) which extracts specific properties out of an doctrine entity. 
nikic and ajf are my two favourite PHP language designers, and since Nikita is on haitus, I'm glad we still have Andrea to take us forward.
Uhhhhhhhhhhhhhhhhh... I'll choose to see this RFC as a sign that it's about time we get short closure syntax. Once we do, we can start talking about inlining simple expression closures like this: $sum = array_reduce($terms, ($a, $b) =&gt; $a + $b, 0); But "+" being a callback is definitely not a good direction forward. It has a high WTF factor and its utility is very low, as there are only few operators. You can quickly enumerate the existing operators as functions... function plus($a, $b) { return $a + $b; } ... and then use: $sum = array_reduce($terms, 'plus', 0); Maybe we can pull an ECMAScript and allow quoted function names to allow this exotic use-case: function '+'($a, $b) { return $a + $b; } $sum = array_reduce($terms, '+', 0);
This is going to save a whole bunch of time implementing operators for things like Shunting-yard algorithms. $add = Closure::fromCallable('+'); And you can use PHP's implementation. Neat.
If that's the use case, a better solution would be a native factory for common operations as closures: $add = Closures::add(); This would pave the way for more than operators. 
Alright, you've sold me. Where can I get this library? 
I'm not sure why you'd want to do this rather than simply have them as methods, that way you reuse the same interface everyone is familiar with.
&gt;we shouldn't introduce new language features that can't be backported in user space with a polyfill Stopped reading there.
&gt;The language shouldn't have strings with special meanings Look up `callable`.
Haskell isn't the only language with higher order functions, and since that's where the similarity ends, mentioning it does nothing but prove how limited your frame of reference is.
Are you the official php implementation of the spec or did you make that organization a bit presumptuously? 
What makes you say that it's "fortunate" that it can't be polyfilled? Let's not kid ourselves, legacy PHP versions will be around for decades. Nobody is happy about this, but that's how it is. If we could polyfill those functions, It would allow even libraries and applications that still target older versions to be standards-based and future proofed (forward compatible). Otherwise, we'll end up with dozens of identical operator-wrappers in our vendor folders. We could even have both, operator names and operator symbol names as aliases. Then code targeting the new version that features those could use those nice shortcuts, while code for legacy versions would still be standards based.
**Stand back! I know Unicode!** And I implemented this RFC in it: function ⁺($a, $b) { return $a + $b; } function ⁻($a, $b) { return $a - $b; } function ×($a, $b) { return $a * $b; } function ÷($a, $b) { return $a / $b; } function ％($a, $b) { return $a % $b; } function ××($a, $b) { return $a ** $b; } function ＆($a, $b) { return $a &amp; $b; } function ｜($a, $b) { return $a | $b; } function ∧($a, $b) { return $a ^ $b; } function ～($a) { return ~$a; } function ←($a, $b) { return $a &lt;&lt; $b; } function →($a, $b) { return $a &gt;&gt; $b; } function ≈($a, $b) { return $a == $b; } function ≡($a, $b) { return $a === $b; } function ≠($a, $b) { return $a != $b; } function ≭($a, $b) { return $a &lt;&gt; $b; } function ≢($a, $b) { return $a !== $b; } function ＜($a, $b) { return $a &lt; $b; } function ＞($a, $b) { return $a &gt; $b; } function ≤($a, $b) { return $a &lt;= $b; } function ≥($a, $b) { return $a &gt;= $b; } function ⤄($a, $b) { return $a &lt;=&gt; $b; } function ＆＆($a, $b) { return $a &amp;&amp; $b; } function ａｎｄ($a, $b) { return $a and $b; } function ｜｜($a, $b) { return $a || $b; } function ｏｒ($a, $b) { return $a or $b; } function ｘｏｒ($a, $b) { return $a xor $b; } function ！($a) { return !$a; } function ⦁($a, $b) { return $a . $b; } [Yes, it works.](https://3v4l.org/jo50k)
I'll add you on my notification list. :-)
If they're methods you need to pass them like this: array_reduce($a, ['Closures', 'add'], 0); Creating the array, the unsafe string names in a string... it's slow for you, it's slow for the interpreter. Versus: array_reduce($a, Closures::add(), 0); Easy to write (autocompletion), safe, and fast to execute.
Just like in [Lisp](https://en.wikipedia.org/wiki/Lisp_(programming_language\)). But in Lisp you are not restricted with "build-in operators". https://kuomarc.wordpress.com/2012/02/02/why-i-love-common-lisp-and-hate-java-part-ii-code-examples/ (defun get-max(list) (get-from-list list #'&gt;)) (defun get-min(list) (get-from-list list #'&lt;))
That's unrelated to this change though. If you want to address the usage of magic strings in PHP then you should address that problem specifically, rather than suggesting it should be addressed by the back door through this issue. Closure is only one of very many places you can use these strings, and you'd need to consider these too if you wanted to solve it. This change simply some new functions, and is inkeeping with the style of PHP as it stands.
I'm entirely **for** solving the issue of magic strings, and **against** further entrenching it via RFCs like the current one. So yeah I'd rather work on the bigger issue. The closure class was a proposal for solving the concrete issue you said you're having.
So I'd take an overarching attempt. With one new server running PHP 7, port over the client sites that are paying for upkeep. Then run some static scans on the others to see if they'd have any obvious problems. Port over those which have none. Then you're left with just those who are not 7 compatible on the old server. Spin up any new projects on the 7 server, and then worry about the lack of 5.6 security in 1.5 years. 
... well you should have read this part at least: &gt; I'm not saying we shouldn't evolve; I would gladly bump my minimum version for scalar types and void return types, but I have doubts for this.
No, the onus is on you to back up something that, to other people, sounds stupid. And to be clear "we shouldn't add new capabilities that can't be implemented in current versions" sounds amazingly dumb to me. &gt; I suppose static analyzers will have hard time figuring out function name vs operator. This is also ....'not clear' thinking. Not only shouldn't we limit ourselves to what current tools are capable of, some things are inherently not static analyzable in any programming language that doesn't have a complete type system. PHP is never going to have a complete types and there will always be part that can't be analyzed. 
When I have to tackle this issue I almost invariably end up shoving the constants in a database table with an auto increment field and then writing a short script to write them out into a computer generated .php file. Or have a map file that goes like so... $mapping = [ Handlers::APP_CONST1 = YourAppClass::class ]; That way something like phpstorm will adjust it for you if you shift namespaces.
Each of his points is iteratively more stupid than the last but he used bullet-points so he gets upboats.
Seems so obvious that it's weird this was never done before. It's conservative so has a high chance of passing. Would be even better if we didn't need the quotes around the operator. 
&gt; These function names are illegal in user space, so nobody will be able to write a polyfill. Do they have to have a polyfill? Like, in a way the fact they aren't polyfilled is sort of the point. You could already write your own `add` function if you wanted to. But `+` is shorter and would now be built-in and there should be an equivalent available for every operator to the point you don't need to think about it. &gt; I suppose static analyzers will have hard time figuring out function name vs operator. Why would they? These operator functions are, well, normal functions. `'+'` and `'strlen'` are just normal callables. If something takes a callable parameter, you can pass any callable, and these new functions, like any other, can be used as callables. The only particularly unusual thing about them here is they have names you can't normally use in userland, but callables and class names don't actually have to be valid identifiers, that's just a restriction PHP imposes on userland code. Things like anonymous classes, private properties and `create_function()` already use names that userland can't. &gt; It doesn't really offer any new possibilities to the language. Well, PHP is Turing-complete, you can in theory do literally anything with it, so I don't see the value of this kind of analysis. I prefer to look and see if a feature can improve how something existing is done. I know you can write this already: $merged = array_reduce($arrays, function ($a, $b) { return $a + $b; }, []); But I think it would be nice if you didn't have to write the wrapper yourself. &gt; The basic `+-/*` are much easier to predict, but not others if they accept multiple parameters. Can you point to an example of one which does not seem intuitive? &gt; Much difficult to see if it's an operator or a string. As opposed to `'strlen'`?
I like it! Definitely going to save me some time in future projects 
This would happen to me. 
The hand-written wrappers will exist regardless of whether operator functions are added to the language.
For better or worse this proposal is completely orthogonal to operator overloading. I think that's more likely to be done with interfaces if it's done at all.
Short closures would be great, for sure, but even if we have them, why should you have to write your own wrappers around the operators?
No they don't have to have a polyfill. But but in this case, you can't write one even if you wanted to. Take `random_bytes()`, or `hash_equals()` for example. They are quickly adopted in userland because there are great polyfill for them. Creating an class called `string` to bring scalar types to 5.6 is overdoing it. Static analyzers: sure they can be improved to prevent false positives, but something something being an operator and a valid function name can _probably_ cause troubles at least until they are fixed for 7.3. I'm sorry if my words sound any harsh/negative - just my opinion but I'm grateful for your contributions to the project as always. 
Haskell isn't the only language with higher-order functions, but it *is* a language where operators (well, most of what other languages would call operators) and functions are unified: $ ghci GHCi, version 7.10.3: http://www.haskell.org/ghc/ :? for help Prelude&gt; 1 + 2 3 Prelude&gt; (+) 1 2 3 Prelude&gt; :t (+) (+) :: Num a =&gt; a -&gt; a -&gt; a Prelude&gt; let add a b = a + b Prelude&gt; add 1 2 3 Prelude&gt; 1 `add` 2 3 Prelude&gt; :t add add :: Num a =&gt; a -&gt; a -&gt; a This was an inspiration for this RFC, and in fact it's mentioned in the References.
The reddit way. I also upboated from my fake accounts :)
The key thing from Haskell is that its infix functions are, well, functions. You can use them infix (`1 + 1`), but you can *also* call them like a normal function (`(+) 1 1`) or pass them to higher-order functions (`foldr (*) 1 [1, 2, 3]`, equivalent to `array_reduce([1, 2, 3], '*', 1)`) In fact, Haskell goes even further and lets you use any normal function infix by putting it in backticks. $ ghci GHCi, version 7.10.3: http://www.haskell.org/ghc/ :? for help Prelude&gt; 1 + 2 3 Prelude&gt; (+) 1 2 3 Prelude&gt; :t (+) (+) :: Num a =&gt; a -&gt; a -&gt; a Prelude&gt; let add a b = a + b Prelude&gt; add 1 2 3 Prelude&gt; 1 `add` 2 3 Prelude&gt; :t add add :: Num a =&gt; a -&gt; a -&gt; a 
I'm fan of functional approach in programming - but i don't see any added value in that - I can already make function function operator($operator) { return [ '+' =&gt; function ($a, $b = false) { return $a + $b; }, '-' =&gt; function($a, $b = false) { return $b === false ? -$a : $a - $b; }, ... ][$operator]; } and use it like so: `array_reduce($array, operator('+'))` or `array_map(operator('-'), $array)`. So there is nothing that cannot be achieved right now - maybe that proposed construct will be a little bit faster. And probably only that.
&gt; Static analyzers: sure they can be improved to prevent false positives, but something something being an operator and a valid function name can *probably* cause troubles at least until they are fixed for 7.3. I don't understand. `'+'` is a callable. There's no special concept of an operator callable or an operator string. Where, exactly, is the conflict? This RFC merely adds functions to the standard library. That is all it does. It does not change the language's semantics or what callables do.
I'm never sure if arbitrary Unicode in identifiers is PHP's best or worst feature.
Because in 90% of cases you need a callback that does a *little bit more* than use a single operator. So at this point we can try and reinvent the concept of "expressions" and "statements" by functionally composing these operator functions, which would be terrible in a language whose library is not built for this, or we can just write a short closure with the expression we need and be done with it. Also, I wrote an implementation of your RFC elsewhere in the thread as a joke (using Unicode chars), but the joke led to a real insight: a lot of these operators make no sense in array_filter/reduce/map etc. context. You should've seen me struggle to come up with a sample for '&gt;', '&lt;', '&lt;=', '&gt;=', '==', '===', '!=', '!==' and so on in array_reduce(). There's a similar lack of utility of other groups of operators with usort() etc. So bottom line is I think this is a bad idea because there's very little overlap between the *full set of operators* and *typical callbacks that are needed*. So I think you're trying to generalize a few special cases you use, which are best resolved as what they are... special cases. I.e. write yourself a static factory for the dozen or so closures you use often, put it in a package and call it a day. I actually have a factory like this and it works like this: array_reduce([1, 2, 3, 4], lambda('+'), 0); As you see, one can go pretty far without adding core language features. Actually this factory dates back from before PHP 5.3 introduced closures, I don't use it anymore, but aside from basic operators it supports basic expressions, which we won't get with your RFCs. Also for many of your examples, a much better performing (and common sense) solution would be a foreach loop. Making things more functional for the sake of it, just adds more "WTF" to code, and makes it slower to run. We don't need that. Especially, I think it's very harmful to the "functional" agenda, as there's true value in functional programming, but turning everything into array_filter/map/reduce() is not it.
Neither. ¯\\\_(ツ)_/¯
&gt; Because in 90% of cases you need a callback that does a little bit more than use a single operator. Of course. The usefulness comes in combining pieces together. Unfortunately, PHP doesn't yet have built-in functions for some common primitives here like function composition or partial application, which would make operator functions shine. I want to do that in a separate proposal.
I can respect that but this is probably why internals don't give a shit about Reddit.
I see that this matches https://github.com/JetBrains/phpstorm-stubs, and often overlaps with it: any reason not to join forces? Is there a different aim to the project?
So is Lisp.
True, although it does that by not having infix operators at all.
&gt; Unfortunately, PHP doesn't yet have built-in functions for some common primitives here like function composition or partial application, which would make operator functions shine. I want to do that in a separate proposal. It won't make anything shine, it'll just make PHP crawl. Please, poor PHP has seen enough mutilation over the years. Its creator designed it as a shitty Perl, then it evolved as a shitty C script, had a flirt with being a shitty Python around PHP 3-4, and eventually Zend decided with PHP5+ that it should be a shitty Java. *Stop trying to turn it now into a shitty Haskell*. We should strive to make PHP a good PHP first and foremost. If you like the functional paradigm so much, fight for these *much more important* functional features: - Tail call optimization - Typed arrays (as a stand-in for value types, which all FP heavily relies on). - Support for generics, unions and intersections. - Function/method inlining support (with callback reification support). Once we have these, then when you start calling things recursively or composing them functionally, at least it'll work well, instead of it all being a toy: all style and no substance, maybe good for a presentation demo, and then forgotten.
Again, if it could have been polyfilled, then it would have been a major BC break, and the RFC would have faced overwhelming opposition. It's fortunate that it can't be polyfilled because that's the only way it has any chance at all of getting into the language.
Cool. While I have your attention, what happened to enums?
I'll echo the comments in /r/laravel: to be useful to a wider audience this could really use some tests, there's a lot of functionality that could be quite fragile between updates and the tests would help provide extra documentation. This isn't useful to me (even with tests), but good on you for putting it out there and it obviously represents a fair amount of work packaging it all together.
I thought this was about allowing custom operators :@
Why would it be a major BC break to choose normal function names?
https://3v4l.org/viOoR It's variable.
&gt; fight for these much more important functional features: Welcome to open source software, where you get as much support as you pay for. If you want some feature, you can either implement it yourself or pay someone to do it. But in the meantime, telling people who are giving up their free time that they need to work on something else, is obnoxious.
Extensions are not regular libraries, they are C code additions to the engine. Therefore they need to be compiled for the target system. Hence pecl, as opposed to pear, which used to install userland libraries before we had Composer. 
Implementation difficulties. I still want to add them.
That's what I was trying to get at, but thank you for explaining better and more clearly!
Yes. Turtle is Owl as a package. It is a lot more maintainable this way and way easier for people to implement or remove from their projects. 
I would replace that with a more modern emoji 🌐 or something else
I have an idea about how to do those, but this is orthogonal.
You *do* realize that PHP contributions are purely voluntary, right? People make cool things that interest them, and if enough people like them, they might make it into the language. If that list of functional features is important to you, maybe you should code up some patches or write up some RFCs for them and stop railing on someone else's free time investment. By all means, criticize proposals on their own merits, but don't play the "you should work on &lt;insert thing that's more important to me&gt; instead!" card. That's a dick move.
Because those names would conflict with existing userland functions with the same names, and subsequently break applications using them when they upgraded PHP.
What a nice lecture about the principles of FOSS. Bravo! But I didn't say any of those are important *to me*. I just said they represent *substance* in the domain /u/the_alias_of_andrea is interested in - functional programming. That's my opinion as a professional who's familiar with that domain. And this RFC is just making PHP a noisier, shittier language.
I don't want any of those features. I'm just saying what OP would be working on if he truly cared about making PHP a good FP language. I, personally, don't see value in making it a good FP language.
This looks really useful, going to take a deeper look soon. Thanks for sharing.
You can say the same thing for just about *any of PHP's built-in functions*. Why does `strlen` exist, when you can already make it yourself? function strlen(string $str): int { for ($len = 0; ; $len++) { if (!isset($str[$len])) { break; } } return $len; } 
I'm considering writing tests for it. That seems to be the main criticism so far.
You're welcome :)
&gt; I didn't say any of those are important to me. You said: &gt; If you like the functional paradigm so much, fight for **these much more important** functional features: If you weren't saying that they were more important to you, the alternative (that you're arrogant enough to think you know what's more important to the rest of the community) is even worse. I was actually giving you the benefit of the doubt there.
&gt; If you weren't saying that they were more important to you, the alternative (that you're arrogant enough to think you know what's more important to the rest of the community) is even worse. I was actually giving you the benefit of the doubt there. LOL, the way you act is not arrogant at all, you've shown me! /s Watch out, guys, we have a badass over here!
There has also been a bug report for `strtr` being buggy recently. https://bugs.php.net/bug.php?id=75172
That means you work somewhere where timelines are determined by engineering. Congratulations. We're told when we're going to have our product release done by, and then we get sort-of-specs from product, and then we waste our time estimating stories because "we're agile!" Because ultimately, tests *are* optional. Its not a good idea to skip them, but its clear fact that tests are not required for code to run. It happens all the time. Its equally obvious that you can't ship a product without making the product (i.e. entities, factories, whatever). Trying to conflate them to stakeholders is only going to work if they happen to be a moron.
nice work dude, love me some laravel
Nice this is somewhat similar to something I am doing in CakePHP: [Yummy](https://github.com/cnizzardini/cakephp-yummy). So I know how much work these can be.
Because measuring length of string is pretty common task, and doing it in PHP'd be a lot slower and we'd end up with JS ecosystem. Also if that was a part of some in-core functional library with other functional things like partials, currying which are A LOT more important for functional approach and used a lot in many different scenarios, where simple operators have very little usage on its own. Don't misunderstand me - I'm not telling that adding that feature 'd be bad - I'm just saying that this adds nothing really beneficial. Short closures (that cannot be simply implemented in PHP), currying, partials - that are things that we need because they are really basic and general and not specific. Aaand also - I think that `operator` function would be a lot better approach - it can be polyfilled (it is language feature that can be really easily implemented in language so, why not to allow that?), IMHO is more obvious from first sight what it does `array_map($array, operator('-'))` - It's clear that this applies `-` operator on `$array`, `array_map($array, '-')` - well, it applies some '-' function - whatever it is. But that may have reason in my disapproval of string calling. 
hiatus? D:
The same would go for any kind of newly added function. array_column, the sodium functions, intdiv... By that logic, none of them should have been allowed to be implemented. There's also been a feature to prevent these kinds of naming collisions since PHP 5.3: Namespaces. The core devs have nobody to blame but themselves for refusing to use them and bloating the global namespace even more.
Go on. I understand there's an autoloading difficulty with generics but I cannot understand how enums could be so complicated.