I had to go back to the previous version, on large files my CPU would just top out at 100%. I'm sure I could have got rid of it by turning off all the error/syntax checking, color coding etc, but then what's the point.
Yeah I know that's why I didn't understand. Maybe I need to restart the bash command (or just exit my docker container and re-enter).
I am the one who proposed/implemented return types. It's logical that I would implement a feature because I want to use it, right?
Check the application/config folder. Here you will get the idea. Application/config/config.php is the file that you need to check.
Thanks for the kind words! I can only hope the nerves don't reduce me to a stammering mess :P
If you need to use `break 2` for the outer loop then `continue 2` for the outer loop seems reasonable to me. I'd rather have it this way than have the continue be offset from break. It could get really confusing if you nested a lot of loops/switches without having them match up like this. 
If it were me, I'd check the manual after using continue and break one next to the other.
I'm fairly certain Bluehost and Hostgator are the same company.
Thanks again for your great response, and your encouragement! I'll definitely try my hardest to show them what I've got!
Why would ever write my code in PHP 5.6 on an -unreleased- project to convert it to PHP 7 later ? Pure loss of time. PHP 7 isn't only about type hinting, there are tons of new things I'm using. I'm really exploiting most of the new features from PHP 7. My current code is shorter, faster, cleaner, I'm testing it as much as I can, and I can do things I couldn't do this easily before. And writing it for PHP 5.6, then for PHP 7, means that I'll have to check and eventually rewrite my tests, and run them again. Why would I ever do something like this when my code is currently running perfectly with the latest build from GIT ? Features are frozen, must of them are present, we are at the first alpha, the expected behavior won't change this much.
 final class Tonis Don't declare stuff as final. Are you sure nobody using your class will ever need to extend its functionality? If you do, you're certainly mistaken.
Compared to people who bash PHP over shit like this, I'm either really fucking smart, really fucking naive, or not a spoiled crybaby, because I don't get tripped up over stuff like this. I want something to behave some way, I try what I think is intuitive, if it fails, I go find the answer in 5-10 minutes or less. If the answer is hard to use/confusing/unintuitive, I get mad, but I deal with it. As a language, PHP has not been a problem for me. Shitty tools written in PHP, like Joomla, yes. But that's not PHP itself. There's nothing in PHP that has actually been problematic for me, *regardless* of my pre-existing expectations. I ran into this *same* issue not that long ago - I had nested loops that I wanted to break out of entirely, and 'continue' only broke me out of the inner loop. Rather than getting mad, I googled, found the answer in 30 seconds, and went "Oh cool, I can selectively control when I break/continue in nested loops". Maybe I'll spin up C++ and whine that I have to compile my code before testing it in my browser, or whine that I always have to import stdio which PHP automatically does for me? **Different languages are different. Get over it**
&gt; PHP 7 isn't only about type hinting, there are tons of new things I'm using. I'm really exploiting most of the new features from PHP 7. My current code is shorter, faster, cleaner, I'm testing it as much as I can, and I can do things I couldn't do this easily before. I'm curious if you can be more specific. I like everything in PHP7 but your remarks seem a bit arbitrary. Shorter - how? Faster, well any 5.6 code is also faster on PHP7, return type hints won't make your code *faster*. Cleaner - how? You could do things easily you couldn't - what? &gt; And writing it for PHP 5.6, then for PHP 7, means that I'll have to check and eventually rewrite my tests, and run them again. You realize 5.6 to 7 is a smaller change than 5.2 to 5.3. Why on Earth would you have to *rewrite your tests*? Do you realize how ridiculous this sounds. PHP7 is not a major departure like Python 3 and even for porting from Python 2 to 3 what you say would be an overstatement.
It's free for 30 days, then it's $99.
I will agree it's a bad practice, but it shouldn't be a strike solely against Laravel when it happens...everywhere. I am totally in favor of productive workflow tools and neat code, but there is a certain tradeoff where the framework's productivity is increased by sacrificing the IDE's comprehension of the project. It's really a usability perspective, and developers have to make the decision as to whether it fits their style. Sometimes it's too much magical, sugary shit for me, but I am cool with it once I learn how the magic works. IDE is a grey term to me really. Some folks will say they don't use IDEs, even though they run Sublime loaded up with packages that emulate most features you'd find in PhpStorm. I have problems confidently drawing a line as to what should or should not be considered an IDE.
How large are your source files? Perhaps more importantly... why?
This project does not implement PSR-7 at all.
I am that lucky guy who gets to fix a website which was previously outsourced to an unnamed country. I have a few files which contain various AJAX requests etc in giant 5000+ line .php files. It works fine in v8, but cacks it in v9. 
If they do they can use composition. I want my public API to be strict so I don't have to account for bc breaks to methods I didn't intend to be public. *EDIT* Also, the code in Tonis is pretty slim. Nearly every method is just firing an event.
Correct, I should have said PSR-7 compatible.
&gt;I'm curious if you can be more specific. I don't have everything in my mind right now (I have quite a lot of lines in my project), but here is a non-exhaustive list * I've created a pretty complex error managment system based on the exceptions. Won't tell the details. * I'm using ?? and even &lt;=&gt; * I'm taking advantage of the context sensitive lexer by using names I couldn't before * I'm relying on soft type-hinting to do some casts I need. * I rely on the new foreach behaviour * return type declarations * I'll use generator delegation in a few days * I'm grouping my uses &gt;Shorter - how? Can't you see it ? &gt;Cleaner - how? Less code, more clean. And since I won't refactor my code from 5.6 to 7, I have less risks to make my code dirty because I need to rush (remember my timeline ? No refactoring : more time to complete the project. You know how timelines behave, don't you ?) or because I've forgotten to delete some useless code. Consequently, it will stay clean longer. &gt;You realize 5.6 to 7 is a smaller change than 5.2 to 5.3. Why on Earth would you have to rewrite your tests? Do you realize how ridiculous this sounds. Because, in my code current state, I have to refactor quite a few methods to migrate from 7 to 5.6. I don't know if it would require a rewrite of my tests (well, in fact, I'll have to refactor heavily my errors management system, so...yes, I'll certainly have to rewrite some tests), that's why I said "check" before.
First, check inside application &gt; config &gt; config.php and see what the value of $config['base_url'] is set to. If they did things the CI way, that URL will get used everywhere in the app by calling base_url().
Hehe, this is why I think most people should just name their projects "&lt;Username&gt;/Hyperbole".
You probably shouldn't have said "I'm grouping my uses". For many of the rest I could just find it a strange coincidence that your particular project perfectly matches all the PHP7 new features. But you're definitely not grouping your uses. It's slower than letting your IDE manage them, it's gives you nothing, and it breaks all PHP IDEs currently available, including PhpStorm 9. Same goes for some of the other features you mentioned. Anyway if we'll just lie to each other, I'm out of here. Gotta work on my PHP8 project.
Thanks! You live up to your handle, too.
I think you should have a hello world example in your readme that goes beyond just setting up a single GET route, because with all those micro-frameworks that have this identical "single GET route" example, it... well... it's unclear what your framework is about, aside from apparently having a router. BTW: &gt; \Tonis\Tonis\Factory\TonisFactory I think it will *be ok* if you just make this \Tonis\TonisFactory
This is a pull request to add a streaming interface for [defuse/php-encryption](https://github.com/defuse/php-encryption). It allows developers to encrypt/decrypt files (or other `resource`s) on command using **authenticated encryption**. Generally, streaming APIs for cryptography are a bad idea^TM. We verify the MAC before we decrypt a single byte. I'd like to get as much feedback as possible on this pull request from the PHP community as a whole.
&gt; so it's early to start building extensive codebases against it just yet. Since PhpStorm 10 probably won't come out until 1 year after PhpStorm 9 this means that you can use PhpStorm 9 partially on PHP 7 when it is released this winter. Plus not everyone is writing extensive codebases or sellable products.
The quality of the site is unsurpassed :S Here's a couple of golden columns from the completely un-normalized db I am fixing as well! https://imgur.com/N9nl23Y 
Your writing actually isn't too bad, the first time I read through the Laravel documentation and kept coming across words like powerful, artisan, elegant, eloquent, masterful, etc my eyes started to hurt from rolling. I thought Hyperbole would have been a much more appropriate package name than Illuminate. I actually like Laravel a lot, still wish they would tone it down a bit. Best of luck on your project.
is interesting.. just measure your words still is a work/idea in progress
Thanks friend, that exactly what I was looking for.
&gt; It's odd, but I don't know if it's worthy of such a rant (by OP) If the OP were going to choose something to rant about, why not go with the tried and true array/string function parameter ordering?
If you do not want to maintain the infrastructure ( including PCI compliance ) I would pick Shopify over the other solutions. They have an API you can integrate with and it is fully hosted on their platform. EDIT: Given http://www.shopify.com/pricing if you spend more than 1 hour per month maintaining it yourself, Shopify will be cheaper.
...I think this guy is really an idiot...
Not at all...
Thanks. My app is still small...so maybe I should get it over with.
We just picked up shopware. http://www.shopware.com
What a beautifully designed and well-implemented site! Did you write this in-house, or have a design agency build it?
Been using PHPStorm for the past year in my first post college job. I think I would be lost without it. 
One more thing. Tonis as a whole is just a group of components. Originally \Tonis\Tonis was \Tonis\Mvc but I wanted people to be able to associate the word Tonis with a single thing. So now I have \Tonis\Tonis which is both annoying to type and look at. I can't just shorten it to \Tonis\&lt;whatever&gt; because the other components already have \Tonis as a vendor namespace. Maybe I should just go back to \Tonis\Mvc then the factory would be \Tonis\Mvc\TonisFactory. 
Name your component after the purpose it exists to fulfill, not the pattern it implements. It's for making the website part of a project, right Maybe it's \Tonis\Web\WebFactory or \Tonis\Site\SiteFactory or maybe you may prefer a more brand-oriented approach like \Tonis\Sparkle\SparkleFactory, but I would personally suggest against calling it "MVC".
Solid advice. Likely going to go with web as its broad enough.
Similar response as above but if properties are marked private it is bwcause I want them to be private. I didn't just do it for funsies.
I hope you are charging per hour! :)
&gt; Generally, streaming APIs for cryptography are a bad idea. Why?
This seems to be common complaint, but what is weird is that for most people PHPStorm is fast and doesn't show those symptoms. Obviously there must be some cause for some people (including yourself) to see such a massive performance difference. Have you contact the Jetbrains guys to try to get it investigated? 
Go on...(please)
Ah yes, Latitude/Langtitude. They must--of course--also include åtlitude too, right? Because otherwise you can't find your location in a Ʒ-d coordinate space, can you?
thank you very much for the info, super helpful
Sorry I meant that in an ironic way. Private properties are useful, so is final class ;)
Oh, carry on then!
I'm not so useless as a sysadmin, and I have guys at work with years of experience that can help me out, VPS sounds like the way to go, and seeing all the freedom to install whatever I want is what I'm really liking.
If your use case is simple enough to be doable with Shopify, then use Shopify. Won't get easier than that. Otherwise accept that there's no "work right out of the box" and pick the solution with the best developer experience, and that's Sylius.
It has really bad performance problems on OS X 10.10, and I don't think I'm the only one
seems the symfony devs agreed with me and changed the deprecation notices with 2.7.1 but thanks for all the downvotes guys. https://github.com/symfony/symfony/pull/14900
What stops me from reordering blocks?
Or you can prepend the ciphertext with the previous MAC. Like a linked list, sort of.
Yeah, I was thinking about this, but got the order in reverse for some reason (block N containing MAC for block N+1) so I thought it won't work. That would be most clean. 👍
You're not facing immediate problems, but it may suggest you're trying to run an SQL query outside the mapper, and then map manually by calling mapObject. You should instead prefer adding a method on UserMapper for performing that query, so all the SQL logic and DB interaction is in one place. 
The whole point of the data mapper pattern is to isolate the storage mechanism of the domain objects. If the method was public, it would indirectly expose the database columns used to create the domain entity, and any change to those column names would break backwards-compatibility, thus negating the entire point of using a data mapper in the first place. 
It does support HHVM already by utilizing the XHProf extension that ships with it (https://tideways.io/profiler/docs/setup/hhvm). That means though only callgraphs will work, the Timeline Profiler will not unless you create the timespans manually using the custom instrumentation: https://tideways.io/profiler/docs/integrations/custom-instrumentation
Eclipse sucks in comparison.
Solid read. Really gives me an appreciation for the language as a whole.
isn't `$user = $userMapper-&gt;mapObject($data);` the same as `$user = new User($data);` ? but I understand what you're saying ok I'm trying to build object relations and want to call my `$groupMapper-&gt;mapObject()` method from within my `$userMapper-&gt;mapObject()` method. How should I proceed instead?
I am doing this on a mammoth project, I am still on CI 2.2 and have no intention of going to 3. You can use composer with 2.2 just fine. The basic plan is to gradually migrate the business logic into namespaced testable services and progressively swap out CI dependant functionality for interfaced / abstracted code. I am borrowing heavily from Laravel to guide my code style and am already using the Container, Validation and Translation components. Eloquent is next on the cards. Mid to long term, ideally the domain logic will be relatively framework agnostic so that I can switch out CodeIgniter for the entire Laravel (or perhaps some kind of hybrid, i'm not adverse to picking the best components for the job wherever they come from). Some starting points to decouple from CI are: * require the composer autoloader in your front controller * Use packagist to find the best package for the job. I'm yet to find a package that doesn't work in CI * Stop using and writing CI libraries * implement a container; I'm using the Laravel Container. From CI controller land you can resolve stuff with app('something'), and in your namespaced code you can start using DI I still often struggle trying to reconcile legacy code with more modern conventions but every week it becomes a little easier to maintain and develop. 
It begins. O_O
&gt; isn't $user = $userMapper-&gt;mapObject($data); the same as $user = new User($data); ? but I understand what you're saying ok It's not the same though. Let's say you have a Post object and it has a "dateModified" property. In PHP this property will be a DateTime instance, but in SQL it'll be a string datetime. mapObject() is fed raw SQL data, so it'll expect the date as a string, while "new Post($dateModified)" will expect it as a DateTime object. The idea is everything you do outside the mapper is "the PHP way" and format of doing things. Anything specific to SQL will be in the mapper. &gt; I'm trying to build object relations and want to call my $groupMapper-&gt;mapObject() method from within my $userMapper-&gt;mapObject() method. How should I proceed instead? Two ways: 1. Do one query for each relation, one from each corresponding mapper. This is actually often what real mappers would do, because a blind JOIN for an 1:N query will typically produce a lot of duplicate data you have to untangle afterwards. 2. A better way IMHO is keep *closely related tables together* under the same mapper. Then their mapObject() method will be accessible internally and it'll be mapUser(), mapPost(), mapComment() etc. If you go the second approach try not to stuff too many tables in one mapper. Typically you can have 2-3 tables per mapper, not many more. For example just because all data has a userId doesn't mean you need to put it in the same mapper as the UserMapper. Treat userId as an opaque identifier, not a relation. But let's say you have something like a Forum, Thread, Post feature. Those three tables can be in one mapper. 
Loves my PHP. Happy customers, good economy.
I do too. I am forced to use phpstorm at work and I still prefer eclipse on my home machine. It's like phpstorm has all the features in the world, except the ones I want. :/
SO EXCITED
inside a switch?
Some of us have been enjoying the benefits of ~~PHP 7~~ HHVM since August :P Seriously though, great news. Looking forward to both teams pushing PHP to its limits. In the end, now we all win :)
Just in case anyone else has the same issue and wants to play with it on windows; VC14 x86_64 doesn't work for this. Have to install the regular x86, not sure why. Happens on Windows 8.1 x64.
There's a note at the top of the page. http://php.net/manual/en/control-structures.continue.php Also the way he phrased the question, makes it seem like there is no difference between the 2.
`composer dump-autoload` will fix the autoloading problem!
Benchmarks// (php-octane) (https://github.com/facebook/hhvm/tree/master/hphp/benchmarks/php-octane) /opt/php-octane$ php run.php //php5.5 Huffman: 155 Richards: 195 DeltaBlue: 843 Splay: 27.662 SplayLatency: 186 QuickHull: 830 Score (version 9): 218 /opt/php-octane$ /usr/local/bin/php run.php //php 7 alpha Huffman: 1096 Richards: 503 DeltaBlue: 2204 Splay: 1151 SplayLatency: 1468 QuickHull: 1841 Score (version 9): 1248 
I disagree - extract *can* be used well (define your defaults before the call, and use `EXTR_IF_EXISTS` flag for the second param), though the default behavior is asking for trouble. Though it's still fundamentally a kludge around not having named arguments or an indication that your code is poorly factored.
hmmm, that is kinda strange...
and when you hit rock bottom and you need some dirty job done you know he'll be there for ya
It's getting to be about that time!
My blog is oriented to beginners and I didn't want them to miss the additional pages. The length of the tutorial doesn't match the single page theme, so I used page breaks. I'm using free wordpress. The intent is to help readers skip over the ads, which are placed between the content and the pagination on the interior pages of the post. I don't get paid for ads or page views, so nothing nefarious going on, just trying to contribute something positive...
Ugh.
Higher is better?
Does it have those 20 screen long if inside if inside if statement files?
What more do you want to know? This in itself is a pretty big refactor and good start. I would say the first thing to do after you decoupled all your CI specific code is to move away from CI to a more modern framework that supports named routing, DIC, and doesn't rely on GOD objects. 
Please report for spam
Just run it in Vagrant and change your hosts file to match whatever the domain name is: problem solved.
Dunno why you're getting downvoted for a simple joke so have my upvote. :p
I am forever thankful for PHP. It allows me to make a decent living being a shitty programmer.
/opt/php-octane$ /usr/bin/hhvm run.php Huffman: 675 Richards: 500 DeltaBlue: 576 Splay: 6171 SplayLatency: 13050 QuickHull: 2629 Score (version 9): 1858 PS: on 3.7.1
We used it in a framework feature, to place variables in scope for PHP views, and then later realized we caused organization troubles for ourselves and placed all values in a containing StdClass. If extract had not existed, we would have done that from the start. 
Are there any good articles/blogs that goes over the new stuff in v7?
&gt; **THIS IS A DEVELOPMENT PREVIEW - DO NOT USE IT IN PRODUCTION!** hold my beer
You should check the Mothership: http://mothership.ec
Dang it. I was hoping there was a clear-cut winner. Does anybody with experience with the different tests want to give us a summary of how to interpret the differences?
&gt; Do you honestly not know what the difference is? Yes, I do honestly not know the difference between break and continue inside a switch context. I even didn't know that continue could possibly have any impact on a switch context. So, could you please be so kind and explain the difference between continue and break in a switch context?
Good luck with CodeIgniter
What features would that be? Maybe you just haven't found them yet?
Some benchmarks I've seen for wordpress have seen page load times cut in half. You need to test specific scenarios though. This is because it includes PHPNG, which lays the foundation for a [JIT compiler](http://stackoverflow.com/a/95679) (though it's important the haven't actually implemented JIT compiling yet, ala HHVM) and has cleaned up a lot of the internal APIs.
After reading that it does just 'click'.
Hahaha, so I'm not the only one. The good thing is that with the rise of OOP, MVC frameworks and Unit testing, I feel like I'm slowly becoming a decent developer :-)
It depends where the bottlenecks are, PHP 7 won't make your SQL queries faster for example. Honestly, I doubt it will be noticeable for individual requests, it's rare that halving the execution time of your PHP code is going to be distinguishable from the regular variation in HTTP response times. It's going to be relevant at the larger scale where your server is potentially dealing with vast amounts of requests per second.
As I've often said, typically you want the API layer (i.e. service layer, business logic, domain model, call it any way you want) of your application to be framework independent. If you use this thing as demonstrated, your API will be a monolith tightly coupled to: 1. Symfony 2. Doctrine 3. This product Just so you know what you're getting yourself into. **EDIT:** One more thing. Even people who swear by Symfony and Doctrine know it's a bad idea to just directly expose a Doctrine model as a public API. Should you ever tweak or refine your model implementation without breaking the API you'll find they're tightly coupled together (through *YAML files*, nonetheless) and you have to pretty much rewrite everything to get that flexibility.
[YES](https://i.imgur.com/KWl6pqT.jpg)
The Batman slapping Robin one could work.
Exactly. But anyone *that* concerned with performance is already on 5.6, so this is disingenuous at best, deceptive at worst. Why bother posting benchmarks that aren't relevant? If 7 is twice as fast as 5.6, that's still damn good and my systems will love it.
(serious question) why does that matter?
Well, it looks like you didn't read the article entirely and didn't looked how the framework is designed. * Doctrine ORM is **fully optional** (and it's explained 2 times in the article): you can use it, or not use it. Data can come (and can be send) from everywhere. The API part **can be totally decoupled** from the business logic. If you do so, you can tweak the data model as you want without breaking the API. * You can use API Platform to be the public entry point of your information system (and we do). The front (public) API can call any other (private) independent API (micro-services) or even use messaging system such as RabbitMQ. Your several layers are still decoupled. * Serializing data in JSON-LD and Hydra (and hypermedia API in general) is a very complex task. Doing it "by hand" is hard and this is precisely why this solution exists. It's also why it relies on several Symfony components (but not all: the framework is decoupled and its own components can be used independently) It **can be** perfectly OK to expose directly some views of Doctrine entities (see https://github.com/dunglas/DunglasApiBundle/blob/master/Resources/doc/serialization-groups-and-relations.md): prototyping, RAD, tiny web apps, micro-service... When the system become complex, **it can be necessary** to add more abstraction levels and you can perfectly do it with API Platform. Everyone is not building gigantic enterprise IS (but you can do that kind of systems with API Platform, you just need to go further in the framework and you cannot follow the "not a line a PHP" approach of the tutorial). By the way, monoliths are OK for many projects and you should start with a monolith: http://martinfowler.com/bliki/MonolithFirst.html
Novice opinion here, but the Just In Time compiling engine behind hhvm takes time to "warm up", or optimize the memory it is using. It is slow at first and gets MUCH faster after it has had a while to optimize itself. What /u/krakjoe was saying is that if jit wasn't warmed up for the hhvm benchmark, the numbers don't mean anything because a production system would be warmed up. 
tidy still makes the most sence, you can configure it to do just exactly what you want p.exp. to test this as a command line call tidy -xml --indent auto --indent-spaces 2 --quiet yes index.html 
&gt; Saying it doesn't make it so. All of API Platform's components are integrated with Doctrine and if you try to put something else, this entire article demonstrating a superficially easy workflow, and ending with "it couldn't be any easier!" is void. All components **can** use Doctrine but they can also use anything else (you just need to implement some interfaces). Of course if you don't use Doctrine it's less easy. But is still far easier to create APIs (especially Linked Data APIs) with API Platform (and without Doctrine) than from scratch. You cannot have the cake and eat it too: if you follow the RAD style it's easy and rapid. If you want a highly decoupled system, it's less easy and less rapid. &gt; Martin Fowler is talking about single-unit-of-deployment "monoliths" vs microservices, and I'm talking about tightly coupling vs loose coupling within a single codebase. So that quote is not relevant. You're wrong. API Platform (as well as Symfony) allows decoupling the code base: put your business logic in separate libraries (decoupling from the framework approach). Put glue code (ORM mapping, data providers, operations, routing...) in a bundle. The framework will integrate with your standalone components easily (again, some interfaces to write). Your business logic can evolve independently of the framework. Look at the doc of DunglasApiBundle. You don't need to import anything from ApiPlatform nor Symfony namespaces in your business logic. 
&gt; put your business logic in separate libraries (decoupling from the framework approach). Put glue code (ORM mapping, data providers, operations, routing...) in a bundle. You consider ORM to be part of a "glue code" between **business logic** and **API**?
You always leave it down or the girls in your workplace will rip your head off. It is pretty simple.
ORM **mappings** (the XML files, I was not speaking about repositories, hydrators and others). It can be contested but it's convenient because most framework integrations (Symfony, Zend) autodetect them when they are inside a bundle (convention). But I stop responding to you, you take one word or sentence and don't speak about the rest. You're not here to construct something but just to troll. Bye.
This should be fairly easy to implement yourself with preg_replace_callback. Search for opening and closing brackets and increment or decrement the number of tabs you need to put in along with a new line. You might run into some issues with embedded JavaScript, but should be straight forward. If I get time I'll make a PHPfiddle and share it.
http://php.net/manual/en/control-structures.continue.php
This is very likely due to some unrelated change in configuration. Like having opcache on one and not the other or having xdebug on one or not the other. I really don't see 5.6 being twice as fast without some major change elsewhere.
If it's a shared public bathroom, it could be argued that you should leave it UP, or some dude will come along and piss on the seat cause they're too lazy to lift it.
I don't think an API-first framework should address specific use cases and return the most general return type (arrays or json). "Data models provided by Schema.org are popular and have been proved efficient." Plain JSON is more popular and have been proved very efficient. The JSON-LD output should be the result of applying decorators or different output strategies. Ideally the output should be decided using content negotiation.
&gt; And, I would say that it will be fair to run by turning jit off in hhvm, as php7 doesnt do JIT. So two candidate drivers show up to be tested for a new job, and one says "I'm blind, so to make this test fair, keep your eyes closed"... Thanks for your benchmarks, BTW. Very interesting.
it was hugged to death: https://twitter.com/seldaek/status/609422756854263808 &gt; @seldaek: Ok I had to turn some things off for a bit while the disks calmed down, now back up and looking more stable. Hoping I don't jinx it.
There is another package on GitHub that I used on 5.0. I'll find the link soon for you. I also forked it to fix a couple issues, original package isn't accepting PRs though, so it's probably abandonware at this point. If you're interested in taking it over with me, let me know. 
There are a bunch of built-in error handling functions: http://php.net/manual/en/book.errorfunc.php. You can also throw around exceptions: http://php.net/manual/en/language.exceptions.php. For best practices check out PHPtheRightWay: http://www.phptherightway.com/#errors_and_exceptions
http://php.net/manual/en/function.error-reporting.php http://php.net/manual/en/language.exceptions.php 
&gt; Node doesn't follow SemVer, Rails doesn't do it, Python doesn't do it, Ruby doesn't do it, jQuery doesn't (really) do it, even npm doesn't follow SemVer. Just because some people doesn't do it (correctly), and the author doesn't understand something doesn't make the argument valid. The moment I see this, it becomes very clear that the author does not understand what SemVer requires: &gt; If your package has a minor change in behavior that will "break" for 1% of your users, is that a breaking change? In SemVer, it very clearly dictates that the PATCH version must maintain API backwards compatibility, so if you're breaking anyone, regardless if it is the illusive 1% or the 0.00000001%, you need to bump the MINOR version. Just because some people doesn't follow the guidelines, doesn't mean the guidelines are invalid.
The only way is to trigger a password reset for your account and that allows you to set a password. By default if you register with github there isn't really a password.
Alright the performance woes have been addressed now by rolling back dependencies. Should be back to fast mode, at least it is for me :) Aside from that, if anyone spots things that are out of place let me know, I tested in a few browsers but you never know.
Every person in the sequence has a different preference than the previous person.
I had been under the impression that 5.6 was faster than 5.5 ever since 5.6 was released. Evidently what I had *READ* was that "5.7" would be faster than "5.6" and in the intervening year, bit-rot caused my brain to completely fuck up that fact. 
&gt; lordable Assuming this wasnt autocorrect, its 'laudable'
What was the issue?
Is that a picture where you are peeing from a mountain?
I'm personally using major.break.minor.patch on projects that have some public apis or rely on specific versions of parent applications. But actually it doesn't matter as long as you write propper changelogs and point out that stuf x may break or has been replaced/removed. I really see no point fighting over version schemes. One likes that type, another one likes the other. Has always been so and nobody complained and it just worked. At least we found our way up to the year 2015 so far regardles of version syntax. 
Then there's no way around switching it every time unless reordering the people is allowed. Seat adjustments will never be better than n-1 in this scenario by any method
No, you're right it's not the frameworks fault. But it's not my fault either. The project is in a bad state (code wise) because of a few reasons. 1.) The project was inherited from an offshore company who didn't know what they were doing, and didn't give a crap about quality. 2.) The project has extremely tight deadlines. I would love to spend the time to write proper clean, well designed and modular code but I work for a web agency and I have lots of projects to deal with and not much time in which to deal with them. 3.) The project owners would never allot the budget required to pay for the extra time to clean up the code base, not unless it meant the collapsing of the business. And a multitude of other reasons which I can't think of off the top of my head. Basically the code is a mess and there isn't much I can really do about it in the near future. The suggestions that were made by other commenter's are actually excellent and I will definitely propose some of them as we move forward with the project in an effort to increase the lifespan of the product. Just because I inherited a project it doesn't mean I don't know how to write clean and modular code though. I have started multiple new projects since joining my company and I am very specific about maintaining excellent code quality by those projects. EDIT: Just to make it clear, those are excellent resources and I've already seen most of them (and I'll look at the others). Also before somebody posts saying that I should look for another job, my response is I don't really want to look for another job right now. I'm happy with the location of my current job (It allows me to see my Girlfriend much more often) and the varying projects that I work keep me interested. I'm not really going to consider working for other companies for at least another 6 months.
Heh, that does not look very useful :(
Actually re-reading the question I think you're technically correct. Most of the wording implies that they're trying to reduce the number of people that have to fiddle with the seat (which I posted my original answer to), but then the actual task states that they want to check the number of seat adjustments. The seat adjustments can come in halves whereas a person comes in wholes so I guess it depends on what the question actually wants, seat adjustments or people adjusting the seat.
Sometimes?
&gt; if you're breaking anyone, regardless if it is the illusive 1% or the 0.00000001%, you need to bump the MINOR version That's not what it says (see Specifications, #7 and #8): &gt; Minor version Y (x.Y.z | x &gt; 0) MUST be incremented if new, backwards compatible functionality is introduced to the public API &gt; ... &gt; Major version X (X.y.z | X &gt; 0) MUST be incremented if any backwards incompatible changes are introduced to the public API.
Maybe there's a way we can standardize the documentation behind how a package's versions are released, rather than only being able to choose from SemVer or gobbley-gook.
Personally I use [sentry](https://getsentry.com/welcome/). It's open source so you can set it up yourself or use their limited free platform. Basically you put in your bootstrap or index.php a few lines of code that tell PHP to send all exceptions and errors to the sentry handler and that's it. From now on they're all captured with stack traces and environment variables. You can even set it up to email you when an exception happens. It's absolutely invaluable if you're running a public site. When users trigger bugs in your code you get the full picture of what happened and you don't need to wait/hope for your users to report it. 
Kind of an open-ended question. What sort of error handling? - Better errors displayed on the page? [http://filp.github.io/whoops] - Logging? [https://github.com/Seldaek/monolog] - Debugging? [http://xdebug.org/, [Clockwork for Laravel](https://github.com/itsgoingd/clockwork)] - Aggregation of errors somewhere? [https://bugsnag.com, https://getsentry.com] - Notifications and alerts in the event of an error? [Aggregates usually have this built-in or as a plugin]
Ya ya ya I am lordable
&gt; so this is disingenuous at best, deceptive at worst. Someone had too much drama for breakfast.
&gt; A modern version of Codeigniter already exists. It's called Laravel. That's confusing. You should call them and tell them to rename it back to Codeigniter.
Yeah, I saw the reply from /u/fred_emmott earlier. You are a bit late to point this one out ;)
Well, thinking about javascript code, css code, &lt;textarea&gt; and &lt;pre&gt;, which all need their whitespace to be handled a bit differently, I wonder if it is so straight forward.
Never trust the end user to use your software the way it was meant to be used 
Or even better Solution 8: install space shuttle style "facilities" at all work spaces. 
You running any caching like varnish? It'll help a million fold if you're not. 
I think [lodash](https://lodash.com/) does use SemVer, though. So, if you don't want your shit breaking, switch out your underscore dependency for lodash.
The orange is a bit bright and hard to read on my monitor but looks great none the less, good job!
I see. Thanks! :)
Suggestion - put information/instructions there for publishers on how to version their code, and put explicit versions in the json file. FWIW, the versions need to be tags on the git repo, but ... it's been a while, and I think I found it through trial and error. There's already a lot of 'how to' on that page; add direction and guidance on versioning, so I don't end up with loads more 'dev-master' packages. Ahh... I do see there's versioning info here: https://packagist.org/about linked from the front page - I hope more people follow that and we see more explicit versions in more packages. Thanks :)
&gt; so if you're breaking anyone, regardless if it is the illusive 1% or the 0.00000001%, you need to bump the MINOR version. That would be the MAJOR version. MAJOR is for API breakage. MINOR is for new stuff. PATCH is for bugfixes.
https://blog.engineyard.com/2015/what-to-expect-php-7 https://blog.engineyard.com/2015/what-to-expect-php-7-2
Try https://github.com/nette/php-generator
That may do. I also found this one which looks a bit cleaner, but doesn't look like it has a way to define the body of methods: https://github.com/gossi/php-code-generator
Yes, I looked at zend but the array stuff is a no go.
Where are the details pointing to Sentry's open source version that can be setup on one's server? The only similar option I see is the Enterprise edition.
The method still rely on heavily nested array structures: -&gt;addProperties(array( array('_bar', 'baz', PropertyGenerator::FLAG_PROTECTED), array('baz', 'bat', PropertyGenerator::FLAG_PUBLIC) ))
That's not documentation.
Looks awesome! Great job on the redesign. I'm a bit late to this post but the site is really speedy and responsive for me.
And I'm not your bitch. Find it in the documentation yourself. :)
I'm not asking you to find the docs for me. Never was. You made a suggestion, I gave the reason I don't intend to use it. There are *obviously* other options with better docs and cleaner APIs.
***triggered*** edit : confirm the same. 
I've used this with success before: https://github.com/tonicospinelli/ClassGeneration Also, there is nikic's AST parser in reverse: https://github.com/nikic/PHP-Parser/blob/1.x/doc/4_Code_generation.markdown
Hi five to us! I'm in the process of shifting a php5.1 site into 5.3 before I incrementally bring it closer to 5.6. I was smiling for about a week once I got it out of enough deprecation errors to get composer and psr4 autoloading going. The guy before me just had thrown in mountains of require_once and global variables to get anything going. 
&gt; put explicit versions in the json file That sounds really annoying, having to remember to update the composer.json every time you tag a release.
I use a C approach... Mainly avoiding exceptions when possible, and testing returns everywhere. 
I may have got it wrong - it's what I'd done before, and it worked, but looking back, yeah, it doesn't seem like it's actually necessary. 
&gt; They're probably too busy learning what Composer does. You should call them and tell them to rename it back to PEAR.
Nothing, I basically yolo
There's also the relatively new [Memio](https://github.com/memio/memio) ([tutorial](http://www.sitepoint.com/automatic-php-code-generation-memio/)). Doesn't really support line by line adding of code to methods though, I think, so it might not be a perfect fit for your use case.
Even still, you're getting the same splatter if you accidentally hit the side of the bowl mid-stream. Smaller target, more chances on accidents!
Solution: Whether you like it "up" or "down" - ALWAYS leave the seat in a different state than you found it - so there is no bias, everyone has the same job. Other idea: Before lunch "up", after lunch "down"....
I was coming here to talk about that statement too, but taking it from the other perspective : If I'm not mistaken, if you correctly create an index on lower(username), I think you should get the same performance as with looking in the system_username database, which would maybe eliminate the need for said table (depending on what you're using it for).
We use ansible for this; here are a few resources: - http://blog.servergrove.com/2014/04/01/deployment-symfony2-applications-ansible/ - https://www.digitalocean.com/community/tutorials/how-to-deploy-a-basic-php-application-using-ansible-on-ubuntu-14-04 - https://github.com/ansistrano/deploy
So for each release you would install all dependencies from composer? Or is Capistrano "intelligent" enough to find only diff of changes and apply that? &gt; You don't need a different git branch for each server. Often, you'll deploy the latest version of a branch to all servers (e.g. master). If I did this, I would end up with same files across all servers, right? What I want is to have a few common classes on each server and then differentiate the rest (e.g. my cron server doesn't need the same files as my frontend server)
error_reporting(E_NONE); edit:iPhone keyboard
It's true that the general term is "value-type" and I can interpret Martin Fowler's comment specifically in the context of reference objects. There are some alternatives for value-objects too, with explicit copy barriers but I won't go there. Although it's possible in some cases even with reference-based object to have explicit "copying barriers" that allow reference value object to behave But it remains the case we *can* use value-types instead of immutable value-objects with the same (or greater) success in DDD and software in general, and more and more modern languages provide such value-types today. Immutability is neat, but nothing beats the simplicity of logical mutable copies, as shown by PHP arrays.
&gt; i want it to be all done the right way yeah, I guess this is my main problem. I have found out that it is possible to use [.gitattributes to exclude files or folders](https://github.com/capistrano/capistrano/pull/626), but this won't work on a per-server basis. At least I'll be able to exclude static content which should be deployed to CDN. Another things I wanted to exclude was a frontend stuff from API server, just in case (since the server is publicly accessible).
Hi, all! WellRESTed is a library I've been working on for a while now. The latest iteration of it uses PSR-7 messages, chainable middleware, and URI templates based on on RFC 6570. It's tailored to making RESTful API, but would work for regular old websites as well. My goal is to keep it lightweight and not impose too much on consumers, such as a specific dependency container or templating system. Feedback appreciated!
What is question ?
Ansible is open source and free as in "free beer".
How about [Rocketeer](http://rocketeer.autopergamene.eu )? Or [Deployer](http://deployer.org)? Edit: I should read the whole post before commenting... Edit again: I just mistook u/rmas comment, as your post... It's late, I should get off reddit 
Thanks for the enlightenment, makes sense to me! 
Lost me at: "We will put the starter code in a directory called todo-app by cloning a git repo.". If I never saw another example showcasing a 'todo' app until I die, I'd be too fucking soon. 
You are right, no library write it for you but they can make your work easier. Just like Frameworks like Laravel, don't write code for you but make your easier. And good frameworks make your code clean at one hand and at other hand the they make it more debuggable if you are using testing framework. If you are still unclear then let me know so that I give you some examples.
&gt; The trouble is immutables are a pain to work with Why is that? You lose in-place mutators, but it is trivial to assign the result of some operation back to the original reference. If you need to perform a lot of mutations, then you can create a mutable, temporary verson, ala StringBuffer, which you convert back to the final immutable value object once you're done.
The IV is public data.
Neat idea
Have a look at Whoops (http://filp.github.io/whoops/). Just remember to use it only in development environment
Some of those method names do seem a bit inelegant, granted. It's so we don't need to manually map the easy test name `pdo-mysql` with a method name. I think it's in the readme, but what I'm doing is converting dashes to underscores and then using `ucwords()` to build the method name. Sometimes that makes it ugly, but it saves creating (and maintaining) a map of test names to method names. Perhaps there's a better approach.
heh, some of the tests are funny https://github.com/drewm/morse-php/blob/master/tests/DbTest.php
the reason why i looked at them is exactly because how hard it is to test and I was curious about your approach. the issue is the tests will end up with pretty much random results on different boxes. if you seriously wanted to test this, you'd probably have no other option than to have some helper in the tests which would actually enable/disable extensions and test that the app correctly detects the presence of those features. they will no longer be clean unit tests, but who cares as long as they accurately test the feature set. btw, phpunit might no longer be a good test tool, since you'll need to start each test case with a clean slate (not in the same php process)
&gt; Where does he say "entirely immutable", he says heuristic. This also discards many of your arguments.. What do you think "heuristic" means in this context to you as a developer implementing value-types? You'd "kind of" make value objects "entirely immutable"? You'd "often" make them "entirely immutable", sometimes reference? None of that covers the point I'm trying to make about copy semantics. What I'm saying is that immutability is not a property of value-types at all (therefore a poor heuristic). It's an implementation detail that becomes necessary (and otherwise undesirable) workaround when implementing large value-types with reference objects. 
&gt; Why is that? You lose in-place mutators, but **it is trivial** to assign the result of some operation back to the original reference. If you need to perform a lot of mutations, then you can **create a mutable, temporary version**, ala StringBuffer, which **you convert back to the final immutable value object** once you're done. This became non-trivial very fast. You have to manually create a builder class for every other class you have, it *doubles* the number of classes to maintain and adds a lot of boilerplate to your codebase. It's not trivial to create builders and then create back values *every time you want to update something* (it's even less trivial having *two interfaces* two change everything - builder and withFoo()). I'm well aware of the techniques you're talking about and I use them every day, and this is why I'm saying it's not trivial (except in trivial cases). Or rather, it's very verbose, tedious and redundant. One example is producing an updated version of a *nested* immutable structure. You can't reach deep and push a value, instead it becomes a little adventure in creating new versions of the structure at every level and assembling them back like Russian nested dolls. Let's take this: $foo['bar']['baz']['counter']++; For this one, in your trivial example, we're looking at creating eight objects (four of them builders) and around a dozen of lines of "updating logic". If you're paid by the line, congratulations, you're getting a raise. As someone at WWDC said while explaining value-types: &gt; "Immutable values solve the problem of references. Instead of mutating the temperature knob on the oven by setting a mutable temperature object, and risking to also set the temperature of the thermostat, we just create a new temperature value to give. But this is not a very honest example of immutability, we're not going deep enough. Because with immutability, in order to change the oven temperature, now we'd have to also replace our oven with a new oven, and our house with a new house". Then you come in and say "that's trivial: just have a house builder". Nope. Not for changing the oven temperature. I'll take copy semantics instead. 
Do you really think this is a helpful comment? The person is trying to compile the 7.0.0 branch from source. Yes, technically the version name should be 'php-src git master branch', or similar, but what they're trying to do is clear.
Things like `extension_loaded()` are the building blocks, sure. That might tell you that, for example, `curl` is loaded, but it won't tell you that the host has then disabled the `curl_exec()` function. So you need to test for that, too. Once you're into testing more than just one thing, you can hit the situation where you have inconsistant testing across your code. What if you test for one set of stuff in one place, and another somewhere else, causing different parts of your codebase to behave in different ways? One good way to achieve consistancy in that case is abstraction. Create a library that performs a consistant set of tests and returns the result. That's what Morse is doing.
You don't have to create value objects for everything, use good judgment for what would benefit from it. &gt; For this one, in your trivial example, we're looking at creating eight objects (four of them builders) and around a dozen of lines of "updating logic". What does your nested structure represent? If it is just some sort of collection, like, number of items in a cart, then it is essentially dynamic and you don't really need immutability here, unless the order is placed, got an ID etc. If it is not a collection, you might want to refactor that into a class and use composition. Then, depending on the nature of the change, you could create a new instance or update the existing one. If you have a recipe, and you swap the beef with duck, is it still the same recipe? Perhaps not, that depends on your domain. &gt; Then you come in and say "that's trivial: just have a house builder". Nope. Not for changing the oven temperature. I'll take copy semantics instead. So you replace your car with a new vehicle, but instead of creating a new value, you keep the same ref with COW. You're going to the beach, so you put your luggage in the trunk, but it has no trunk. Ok, you update your value. Then, you go to the gas station, but it does not work with gas. Damn, you update. Then it rains and you're wet, so you want to put the roof and activate the windshield wipers, but it has none of these. Update, update. After some time you get strangely tired with aching legs; perhaps there's some problem with the pedals or something. You bring it to the car repair, but the clerk looks at you weirdly: "is it a joke? that's a bicycle you got here, not a car". Moral: it's easy to make silly stories :)
&gt; If it is just some sort of collection, like, number of items in a cart, then it is essentially dynamic and you don't really need immutability here, unless the order is placed, got an ID etc. I don't *need* immutability, I never claimed I did. I need value semantics (vs. reference semantics). I'm afraid you're missing the problem I outline, and that value objects exist to resolve. &gt; Moral: it's easy to make silly stories :) It's a silly story only when you haven't lived through that pain in your code to understand what the story illustrates. The silly story resonates with me because I do care about spooky action from distance in my code, and I know the existing solutions are inadequate. Check PSR-7, if you want a real story. It's an immutable god-object with everything bolted on it (uri, query fields, body fields, headers, other metadata), because if it was broken down and composed explicitly as a structure of immutables, it would be exceedingly complex and verbose to modify. And still an HTTP request is hardly the most complicated value I've seen and used. So it does get worse if you try to use immutable to ensure value semantics.
Since the Cv is only about a single person would you not associate the items with a master Cv object? However you do it yeah, wherever you have multiple entities (education and employment) I would do as an array of objects.
In 2015, the right way would be to use an ORM - Object-relational mapping - system. I'd recommend Doctrine ( http://www.doctrine-project.org/ ), others might think of alternatives. With Doctrine, anyway, one-to-many child objects are stored within (Doctrine provide) ArrayCollection objects. These relationships can be bi-directional. Consider: class Person { /** * @var ArrayCollection */ private $resumes; public function __construct() { $this-&gt;resumes = new ArrayCollection(); // } public addResume(Resume $x) { $resume-&gt;setPerson($this); //hook it up, bidrectionally $this-&gt;resumes[] = $x; } } class Resume{ /** * @var ArrayCollection */ private $skills; /** * @var Person */ private $person; public function __construct() { $this-&gt;skils = new ArrayCollection(); // } public setPerson(Person $p) { $this-&gt;person = $p; } public addSkill(Skill $x) { //no reverse link $this-&gt;skils[] = $x; } } .... Anyway, that might be enough to get the 'ol brain going.
You could use logicalOr: $this-&gt;assertThat($this-&gt;logicalOr($this-&gt;isTrue($result), $this-&gt;isFalse($result))); Or InternalType: $this-&gt;assertInternalType("boolean", $result); Or you could abuse @requires /** * @requires function mysql_connect */ public function testMySqldetected () { $this-&gt;assertTrue(Morse::featureExists('db/mysql')); } Though that last one would not give you a negating test.
phpstorm. I especially like the fact that it can also tunnel a connection over SSH.
Netbeans has built-in DB access - I expect Eclipse and Aptana too to have some DB plugin / extension / functionality MySQL Workbench is meant for this SQL Workbench/J needs you to install Java 7 but is a super tool All three are free and opensource.
totally respect anyone who can do sysOps well. still, i like to see this as a culture thing. developers are hackers. they make a sport of solving problems. like larry wall said: virtues of a programmer: laziness, impatience, and hubris. even with automation tools like Docker, i think it's a good idea to outsource those tasks to focus on getting code shipped first. i really agree to that: http://blog.circleci.com/its-the-future/
&gt; can you clarify why typed mutable VO would be useful? I gave some arguments in the other comments here, but maybe I can direct you to this video: https://developer.apple.com/videos/wwdc/2015/?id=414 It's about Swift, not PHP, but the arguments placed forward are conceptual, and not in any way specific to language or platform. I can give you another direction: you know PHP developers frown when you pass an array by reference. Consider why this is. Many of the reasons are the same as what I'm discussing here about reference types and value types.
Well no not **exactly**, but I did manage to come close enough with PHP Tidy so yeah for now I'm okay with it. :-)
I will definitely look into it. Your code helped me a bunch here though, thanks! If I want to iterate through the array of objects to echo or return the stored information, what do you think is the best (and simplest) way to do it?
Sweet! Nice job :)
ORM or not, just do a loop on the array collection, matching on whatever criteria. Access directly, if you have an id. If the tree is huge, look into lazy loading the children from the db. 
Couldn't you just use is_bool ()? http://php.net/manual/en/function.is-bool.php
&gt; in order to not be **afraid** of changing things This. There is nothing that kills your productivity more than being afraid to make changes. You never refactor. You rarely re-use code. The quality of your code gets worse and worse. Anything you can do to prevent this from occurring the better, and this is exactly what automated testing does. It gives you the confidence to code how you **want** to code.
I think this is mostly because the last insert ID isn't guaranteed to have come from that exact query, at least on some DBs. It sounds like Postgres has an INSERT INTO ... RETURNING ..." syntax that will actually do everything in one shot and essentially act like a SELECT specific to the row that was just inserted. That would be nice to have everywhere, but alas, it is only Postgres that rocks.
Mostly try 'n fail. In sequence: - learned some basic computer programming with stuff like GWBASIC/Turtle (old manuals found in the cellar of my home). Loads of `GOTO`. - learned some basic spaghetti-driven game programming. BlitzBasic or C++ with DirectX7 stuff in it. I had no idea about what I was doing, but stuff was on the screen, and sometimes it didn't blow up. - Geocities! WOHOOO! I CAN HAZ HTML!!! I now qualify as "webmaster". - went to build basic websites with some minimal dynamic stuff in them (stuff that should not be allowed to be deployed on a server, EVER, mainly due to security issues) - scaled my little web project(s) - lots of mistakes with my little web project(s), learned about SQL query optimizations, Big-O notation, caching, logging, monitoring and... unsatisfied users! - loads of rants about MySQL being a piece of junk that always has corrupted MyISAM tables - learned about XSS and SQL injection the hard way (having users being actually damaged/robbed of their virtual assets, fortunately no real money involved :| ) - introduced libraries to not repeat myself and to solve the problems above. Learned about clean code/OOP and other similar things implemented in these libraries/frameworks - started paid work as PHP dev - started contributing to ZF1/ZF2 (libs that I was already using before), started testing/etc, started prophesying clean code and things revolving around it, mostly because I saw the difference in results - started helping on the Doctrine mailing list, trying to answer questions by reverse-engineering library code - started writing my own libraries - functional programming learning, mostly inspired by [igorwhilefalse](http://twitter.com/igorwhilefalse)'s visions on LISP - concepts of DDD This spans across 15 years. Things that I suggest to get up to speed nowadays: - [get a mentor](https://phpmentoring.org/), or multiple mentors for different topics. - I suggest mixing JS *and* PHP, especially since they are focused on very different paradigms - be eager to learn and dedicate time to reading and learning - don't focus on the language itself, focus on the things you can make with it, because other languages will likely allow the same too - test test test. Nobody (sane) will let you deploy something that isn't tested properly - the quirks of the language are something that you will find out via testing anyway - don't get too tangled up in patterns and similar: patterns are something that emerges from code, and you learn to recognize them as you write code. Pattern-driven development leads nowhere, IMO - code is more about intuition and engineering rather than mechanical application of techniques - to gather said intuition, you need experience: coding katas can help a lot here, ask your mentor! I think that's enough, but start from a mentor. If you get that, then you're already 7 years ahead of me with this schedule :-)
Lynda.
I already know ASP.NET MVC but I'm interested in picking up PHP. My approach is to read books, watch videos on Pluralsight, and connect with other PHP developers at meetups.
The bot was 100% correct on UTC time...
There are definitely more diverse environments in my own codebases.
how so? First, I was wrong in my post. It was 10pm EDT, not EST when I commented. So the bot posted at 9pm EDT, which is 1am UTC isn't it? EDT is UTC-4 So I guess the bot didn't post directly on 00h UTC ? ;)
For auto-numbered fields, the last insert ID goes into a per-connection "variable". The result of an INSERT/UPDATE/DELETE query is normally the number of records modified or a success/failure flag. Some databases, such as MySQL, have functions to specifically retrieve the last insert ID. For example, [mysqli_insert_id](http://php.net/manual/en/mysqli.insert-id.php). You'll notice that this function takes a connection as a parameter. You can also get the last insert ID from inside SQL with the [LAST_INSERT_ID()](https://dev.mysql.com/doc/refman/5.0/en/information-functions.html#function_last-insert-id) function (e.g. `SELECT LAST_INSERT_ID()`). 
On the job. About my 2nd or 3rd year out of college, started a job with a fairly large-size site made in PHP that had an admin tool built with Flex. Learned a lot, now it's my primary language. 
honest question: why?
I don't know your American time zones (*tsk tsk* typical arrogant yank :P) but New Zealand is +12 and it was posted at around midday. Oh and I cheated after that, if you mouse over the thread's "submitted four hours ago" the UTC time posted pops up. :P
¯\\_(ツ)_/¯
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**ISO 8601**](https://en.wikipedia.org/wiki/ISO%208601): [](#sfw) --- &gt;__ISO 8601__ *Data elements and interchange formats – Information interchange – Representation of dates and times* is an [international standard](https://en.wikipedia.org/wiki/International_standard) covering the exchange of [date](https://en.wikipedia.org/wiki/Calendar_date) and [time](https://en.wikipedia.org/wiki/Time)-related data. It was issued by the [International Organization for Standardization](https://en.wikipedia.org/wiki/International_Organization_for_Standardization) (ISO) and was first published in 1988. The purpose of this standard is to provide an unambiguous and well-defined method of representing dates and times, so as to avoid misinterpretation of numeric representations of dates and times, particularly when data are transferred between [countries with different conventions](https://en.wikipedia.org/wiki/Date_and_time_notation_by_country) for writing numeric dates and times. &gt; --- ^Relevant: [^ISO ^week ^date](https://en.wikipedia.org/wiki/ISO_week_date) ^| [^ISO ^2711](https://en.wikipedia.org/wiki/ISO_2711) ^| [^ISO ^2014](https://en.wikipedia.org/wiki/ISO_2014) ^| [^ISO ^2015](https://en.wikipedia.org/wiki/ISO_2015) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cs6x2h3) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cs6x2h3)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](/r/autowikibot/wiki/index) ^| [^Mods](/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Call ^Me](/r/autowikibot/comments/1ux484/ask_wikibot/)
For the same reason I'm 31 years old and still like to play with legos?
On the job. Back in '03 I picked it up in a couple of days and launched a pretty successful ecommerce site with the knowledge. Using what you're learning in a project is always the best way to learn it. I learned about cookies and location header redirects and such out of necessity while building out a shopping cart, etc.. 
PHP is incredibly popular and widespread, which means it's likely to have a lot of fatal bugs discovered. You don't want to be sitting on an old, unmaintained version of PHP when a bug that allows remote code execution surfaces. Depending on who discovers said bug, it might not even be publicly disclosed. Furthermore, more and more third-party PHP libraries require PHP 5.4 or higher to work, which means you're potentially missing out on third-party library security updates as well as PHP security updates.
ELI5; What is a framework and what is a library and what is the difference between the two? Being new to OOP, what is the difference between $object-&gt;method and $object::method? Which do I use when? What are good ways to keep a user logged in? I suspect that sessions alone won't suffice outside of the test area.
It's a nice idea, it would be very useful to have that in Composer, maybe it's worth suggesting in an issue on the official repository? Also the output is encoded in JSON but a more human readable output might be nicer to read.
What happens if the first few hundred requests are similar and $foo is the same type, and after a while there's a different request where $foo is another type ?
I would recommend starting with a Framework. (I recommend /r/laravel). From here you can easily create the structure of your web application. A library is a chunk of functionality that you wish to add-on to your application. The idea being that you either don't want to re-invent the wheel, or functionality you wish to add is so complex that it is easier to get a pre-existing (and hopefully tested) library. The difference between $object-&gt;method and $object::method is that $object-&gt;method requires you to "new up" the object. The idea that perhaps you have an object with multiple internal values, and that returning a function requires all this data to be known. A static function ($object::method) simply allows you to run that function without creating an object first. So perhaps something like $var = Tools::ParseText("!@#abc test") could return something like "abc-test" for cleaning up a title for use in a URL. Otherwise I would have to do something like: $tools = new Tools; $var = $tools-&gt;ParseText("!@#abc test");
That is the answer I was looking for. Thank you! $votes++;
Annnddddd, I've spit my soda over my desk. Thanks. 
Would you attach a new garage to your house, before the house is built? The garage provides additional features to the house. Having said that, I'm giving a talk tomorrow about the OmniPay library. The demo involes no framework - just a couple of simple scripts that use the library. The library by itself can do nothing. It needs to be used by something else. Just like your garage doesn't park your car or fill itself with shit - YOU do that with the facilities it provides (a door API, storage shelf services, space to DI insert a beer fridge, etc)
Ah very understandable.
Why not? :)
You're right, a lot of frameworks do bad things like this. Personally I still prefer Symfony 2 (hell, I'd take ZF1 over Laravel) for MVC, though I'd rather take a PHP API with a JS MVVM... but perhaps I've had an unusually bad experience with Laravel. Referring to my original point though, ahughesb (the commenter) should try out Laravel (or any other framework) before making any recommendations to his boss.
Output to DOT format, so you can make a pretty picture in GraphViz would be a nice touch ...
* It is guaranteed to come from the last insert * It isn't guaranteed to have come from that exact query Isn't the same thing....
Adminer is an order of magnitude better than phpmyadmin.
**Framework:** A framework is a large chunk of the work already done. For PHP we have frameworks like Laravel and Symfony2 which basically includes all the groundwork, so you can get right down to making the things you actually want to make. For instance, Laravel comes with user authentication finished out of the box, so you can get right down to making different user groups and permissions. It also comes with a mailer (if I remember correctly; SwiftMailer), so you can just go sendMail() to send mail. It's kinda like having to build a house, but you get the floor, outer walls and roof already done, so you can just start setting up rooms, putting up wallpapers, painting it the way you want etc. **Library:** A library (following the same ELI5 mindset) is like calling a plumber, and he makes sure you have clean water. Then you can just add the toilet and faucets and showerhead you want to make use of the plumbing. **Class/object accessors:** The difference between `-&gt;` and `::` is that we use the former for accessing methods/properties on objects. The latter is for accessing static class variables/functions.
While I was at University, they tried to teach us Perl. For those that don't know PHP was made *specifically* because Perl was a bad language for the web (specifically shared hardware). Anyway, for less clever reasons, I didn't like Perl, so I taught myself PHP out of a book. I thought I was pretty good too. Truth be told, I did know the language very well, but there's much more to it than that. My first PHP job was with a digital agency filled very smart cookies and my knowledge just exploded from there. I learned about MVC, SCM, best practices like single responsibility, FIG standards, testing. **TL;DR:** Read a book, learned the rest on the job. What's you're background? Knowing where you're coming from might help us direct you. :)
I was screwing around with VB script writing ASP (curious how web pages worked) and got so sick of the server not processing scripts half the time. Ooh I don't miss those days. Heard about PHP &amp; MySQL and gave it a try. Never looked back. Started building sites for musician and artist friends that had an admin section for them to upload images to display. Keep in mind this was all in PHP 3 way before Zend Framework, Code Igniter, etc.. So there was a lot of spaghetti being whipped up. But I loved it. So I set small goals to learn above and beyond the requirements for each project, and kept plugging away adding something each project. I wrote a bunch of BASIC on the Apple II when I was a kid so it took a while to get my head around PHP. OO was the biggest hurdle to grasp. Probubly took me 6 months of reading, experimenting, throwing stuff against the wall, and having tiny ah-ha moments. Rinse and repeat. But once I got it, coding was so much more enjoyable being able to structure and organize my apps. Good luck on your journey! There a ton of info and code to learn from out there. Use it to your advantage.
If you would have to choose between two new CMS (or ecommerce system, etc) and one of them is based on a well known framework (e.g symfony or laravel), and another is custom made, which one would you try first? Would you try them both or just stick with the first one? 
How do you go about starting a new project? Before you write any actual code, do you diagram relationships, write down business rules, etc? Is there any specific tools or processes you use and would recommend?
I started by modifying the code of phpBB. I had no development knowledge, I only knew HTML and CSS, and my grades in SQL were very bad. Then, I created a crappy website Then another website, slightly better. Then I created many discussion boards prototypes Then I created a pretty popular website, which I closed after 5 years. Made many mistakes, but improved each week. During the lifetime of this website, I learnt OOP with Java and such in High School. Then I created many frameworks, a few of them are currently in production. And now, I have a PHP certification, which I got on my own.
What about using postgresql? It looks like all the requirements you have, postgres would cover them quite nicely.
have you hit a point where you need to scale the solution past single server?
No, we currently use on mysql server for all database (topics, comments, etc). Now we have over 3 millions of comments and selecting, counting them is quite expensive. We have caching layer, bet we need as much fresh data as possible. Best would be to eliminate caching layer at all.
The problem isn't the database selection, usually it's database design, and correct indexing. You can get the results you want from mysql, just have to look at the queries you'd use, and create indexes for join fields, and where clause fields, so as to improve the performance or scalability.
I had used coldfusion for a few years, and while the syntax was different, the basic building blocks were the same. Variables If then else if Queries/Databases File Operations For me, what helped was to have a fun or test project to work on. And just keep at it. Endless practice.
Why not create index on every column (except thgose like ip, datetime etc.)? Just curious..
Again switching to a different persistence engine is not going to solve your issues. To deal with a peak user flow, you need to change your infrastructure to Write/Master - Read slave and also have a load balancer to balance the the read load across all servers. Having more servers to handle application load is also called horizontal scaling. You can also vertically scale, by adding more resources to your single server. The great thing about horizontal scaling is that with many infrastructure providers it can be done dynamically when the server pool reaches a certain load point.
Creating indexes speed up querying, but slows down write/update/delete operations. Any change to your dataset means having to update a BTREE, RTREE or a HASHTABLE (for InnoDB in MySQL, other engines might have other indexing types) **for each index**, which is not so fast. This is why we only index what is really needed and why we always choose the correct index type.
I'll look into it I was really only using the json to test the underlying data structure needed to build the graph
I've been looking into PSR-7 a bit. Now up until now my (unreleased) framework has relied on the $_SERVER/$_POST/$_GET variables, but PSR-7 looks like a nice way to stop relying on global states. Is there a library that will take the current input and turn it into a ServerRequestInterface? Or should I just make my own now? (something i planned to do eventually)
I learned php by installing apache locally and taking 4 hours to hook php up (php 4.0.1). Then I took to the interwebs and googled how to write php. Being a CS major at the time the syntax was quite easy to pick-up. At the time I had to write a survey system, so I was able to complete that just by googling although in hindsight it was terribly done, but it did work.
Have you profiled your mysql? Turned on the slow query log to see what is actually slow? 3 million records should never pose any issue, they usually still easily fit into ram. How big of a load peak are we talking about? Of then when watched with a slow query log, people realize that they do 50 db queries for every web request which is often very easy to fix.
We profile mysql regularly, we optimise slow queries. Peek vary on topic 10-50 or even more comments per second. But most important we would have nested comments this bring even more complexity and queries count to retrieve comments.
NoSQL is not a good solution for this since comments tend to be very, very relational.
http://www.adminer.org/
Serious question - what is/are the use case(s) for this library, other than a crawler? I'm struggling to think of what type of non-crawler application I might be building that would necessitate the use of such a library. 
Java has this down to an art / science. If you ever do a software course in University with Java, you'll be up to your ears in it. This is also a pretty much a "software engineering" question, rather than a PHP question. After writing out these few sentences I've realized I'd have to write a few paragraphs to give it a breadthful answer.
What if your last query wasn't an insert? Then $result-&gt;lastInsertId() wouldn't do anything because the query wasn't an insert.
This would be where, say, a single pipeline handles a stream of queries in a single session from many sources? If so, that is more an issue of the framework and the way queries are run, than a problem with the MySQL function. Would there be a circumstance where the last insert ID in a single session is not the ID generated from the last insert statement in that session?
I've not found any support for [text format](http://www.sitemaps.org/protocol.html#otherformats) which is also supported by Google. [Our sitemap](https://dobre-nemovitosti.cz/sitemap.xml) is using XML SitemapIndex which points to text format sitemaps with 10k links at most (specification says 50k or 10MB). We have named sitemapXX.xml - that .xml extension is only think I'm not sure about, but specs say &gt; You can name the text file anything you wish. and it works well. Also: * I think you should put your code in namespace `tzfrs/GoogleSitemapParser` * I think composer.lock file should be commited only in projects, not libraries * I'd add `"ext-curl": "*",` in require section in composer.json * The code would be split into Loader, Parser, Validator etc.
Hi, I should have been more specific. I was aiming to only support XML Sitemaps. Sorry. It is possible though to have a sitemap like you have. I have the same on my site: http://tzfrs.de/sitemap.xml However, on your sitemap I'm getting from `libxml_get_errors` the following message: &gt;Start tag expected, '&lt;' not found Do you know why this could be? 
Canada is an enormous sparsely populated place with rather sizable differences in culture. If I said yes, but I live in [Iqaluit](https://www.google.ca/maps/place/Iqaluit,+NU/@67.042026,-53.0823961,5z/data=!4m2!3m1!1s0x4dd31647708ada07:0x1f1ed0067c9129c2) you might be in for a bit of a shock :P
I know that for cURL, you can't set this globally, you have to do this for every request. I can imagine the same goes for `file_get_contents` but I am not sure.
Do you work as a developer now? How long did it take to get from the basic treehouse stuff to building something useful or getting a job?
Hi, thx for the input * Okay, I now return that directly * You're right. This should be the job from the cURL library. I wanted to implement guzzle at first, but I thought that guzzle would be way too big for such a small task. Even the library I'm using is too big, 'cause I'm only using it once for a get request. :P So not sure about this one * Okay, I'm switching this * Ok, I'll read some more about that topic Yes, I know, if you mean it like this one here `http://tzfrs.de/sitemap.xml` then this is already working. It checks whether the links in the sitemap are links to other sitemaps or direct links to posts and then crawls them too. Thanks for your input. **EDIT** I changed the library according to your input. However, what exactly do you mean by iterators? I mean, I know what you mean, but do you have something I could read about for using this in this library? 
Just like the difference between a car and a plane, they both transport people. I think taking a closer look at either MySQL (because you can probably get the performance you need from it) or Postgresql (since it is just that much nicer of an RDBMS, seriously.) would do you better than looking at NoSQL solutions. If you really need some of those NoSQL-features like a document store, you can still use Postgresql, because Postgresql can everything. Edit: If you gonna downvote me, at least tell me why.
I have to create a web application with an admin portal. The web application is really simple (register/login, download a software, manage your account). On its own, the admin portal is a little bigger but nothing I can't handle. The complicated part (or what's new to me anyway) is, my boss wants the portal to only be accessible within the firewall (so like an intranet). I've been away from PHP for a while and working with C# and .NET a lot. What I would do in .NET is create have have different projects in the same solution and publish them in different environments. With Laravel or Symfony, is there a way to create something like that or do I need to create two separate projects?
I just want to add this rule to phpmd? How do I do that? https://github.com/lukzgois/laravelmd/blob/888a4e91e7ecd5af9b3e359c510c45c4bc94de43/ruleset/cleancode.xml#L71-L107
EDIT: I was referencing [**stream_context_get_default**](http://php.net/manual/en/function.stream-context-get-default.php) when I should have been referencing [**stream_context_get_options**](http://php.net/manual/en/function.stream-context-get-options.php) ----------------------------- What you want is this: stream_context_get_options(stream_context_get_default()) This only returns options that are explicitly set as default for any new stream contexts from what I know, it does not return all defaults for all stream options. Because of this, checking if ssl-&gt;verify_peer exists is a viable logic gate. If its set at all, that means something set it, and you can use that to figure out the default for new streams. If it's not set, you fall back - returning the default behavior based on the current PHP version. Again, this will only tell you what the default is at any given point in time. Any stream context in the past or future can override the defaults, so you can't rely on this logic for much. But if you need to know the current default for some reason, it is possible with the above logic.
You had me at "Montreal". It's one of the cities I felt best in, in my whole life...and I've stayed in quite a few. It's big and small at the same time...love it, and the people there (kinda easy to be welcomed there since I'm French :) I always heard great things about Wellington, except for the wind. Lots and lots of it, all the time... (I'm sorry in advance for the huge stereotype that's coming in 3...2...) It's funny to me that you're a Canadian willing to move to NZ. In my mind, NZ and Canada are the same kind of country. The very rare kind of "we kick ass but we stay humble" kind of country. Love that attitude in a country.
You also have to trust that someone won't change your default context in the future if you rely on the defaults. Thats why its better to ignore the php defaults, and build a stream object factory that creates the context you expect and then apply it to every stream you use. Checking for the existence of a default is probably slower then just setting a default per stream, because you still need to override the default if its not what you want. If you explain why you need to detect the default, I might be able to help see if its really needed, but it's usually that case that it you won't ever really need to know the defaults.
If I understand correctly this is another: "database as a service" service. Why would anyone pay money for a remote database with far larger latancy than having it on a local server? The "multiple versions" is not really a selling point, since instaling databases is not hard at all. There is no difference with trying out MySQL 5.6 if you already know how to configure 5.5. Also using a database as a remote service doesn't allow you to teak it, which is where a lot of performance comes from. After 3 hours of tweaking my my.cnf file I managed to squeeze 30% more performance out of the same server. With these "services" you get a generic setup catering to the lowest common denominator. If your website has large amounts of traffic be ready that the extra network access to talk to the database may contribute towards network congestion. The |basic stuff as a service" systemmay work for some things, like say sending email, because setting up a proper mail server is rather hard. But database as a service is kind of useless. Next time: PHP as a service =)
&gt; Warning: DOMDocument::validate(): no DTD found! This is because these sitemaps are missing a DTD. Since there is no declared document type the meaning and structure of the XML cannot be verified. This is not an error with DOMDocument; it is an error with the XML.
I have about double that on a $40 VPS on a side project. I'd guess you need to do query/index optimization. Frankly, the only circumstances where I'd suggest NoSQL is when you are hitting 1,000+ inserts/second on a per node basis and you have a minimum of 5 nodes. Short of that, you simply are not going to get what you want out of it because of the learning curve of MySQL v. NoSQL for indexing, operations, etc. The per-node performance of a well tuned MySQL machine vs. Cassandra, etc. is pretty close to even due to the amount of denormalization you'd have to do. I've only found NoSQL really worth it as a cache or as a distributed log where you don't have to denormalize. If you can't hit 1,000 inserts/second on a MySQL node, you've screwed up and/or are inserting something very large in those inserts [are these comments weighing in half a megabyte on average?]. I highly suspect you aren't there on 3 million rows of comments over 6 months. I doubt you are hitting more than 100 writes/second if you only have 3 million comments. Plenty of people were hitting 1k inserts/sec 5+ years ago on MySQL. It should be easily doable on modern hardware. This is just some random guy's blog from 5+ years ago to emphasize the point: http://tech.bluesmoon.info/2009/09/scaling-writes-in-mysql.html &gt; After partitioning, tests showed that we could sustain an insert rate of 10K rows per second for some time. As the table size grew past 10 million records, the insert rate dropped to about 8500 rows per second, but it stayed at that rate for well over 44 million records. I tested inserts up to 350 million records and we were able to sustain an insert rate of around 8500 rows per second. Coincidentally, during Michael Jackson's memorial service, we actually did hit an incoming rate of a little over 8000 records per second for a few hours.
Interesting points, but this service is not meant for production use. This is for testing only, e.g., running your test suite or just playing around with different versions of popular RDBMS. This can become handy if you are developing a framework or library that supports multiple databases and you want to test against all versions.
Use generators to return the entries, instead of building a large array of elements.
Then I would say you are not using it properly. The last insert ID will be available under the conditions specified by whatever ORM you are using, or PDO documentation, or MySQL documentation if you are getting it direct from the database. My issue was the statement that it was not "guaranteed" to be available. If it is used as it should be used (e.g. the last insert ID is fetched immediately after an insert statement) then it will be guaranteed to be set as specified. If you don't use it as it should be used, then all bets are off - there is no point in even describing it as "not guaranteed" - we don't code to that situation, because it makes no sense to have something that may work, or may not. The result is simply undefined, and you don't go there. The take-home from all this, is that the last sequence ID is guaranteed to give you what the manual says it will give you, if it is used correctly, and you can rely on that. Just read the manual.
I've been to Toulouse. It's a very nice city with a very nice vibe to it. I have not been anywhere else in France unfortunately. And my god did I have the single greatest lunch of my lifetime. Huge pieces of foie gras, cassoulet, some kind of salad with duck meat, four bottles of amazing red wine, and loads of baguette. But yeah, traveling to places, and living in those places, is a very different thing. Also, I'm not 100% fluent in french, and the french I do know, is Quebecois french, which is amusingly different than France french. I don't think the French will be terribly happy with me when I bump into someone on the sidewalk and yell "Esti calisse, regarde ton position sur le pieton tabarnak!"
I would try both, as the functionality provided is the most important thing. As for being based on a framework, there are pros and cons. I figure if you're building a web app, build it on a framework. If you're building a content based site, build it on a CMS. If you're building an online store, build it on an ecommerce platform. But if you're building a CMS or ecommerce platform, don't build it on a framework - you're supposed to be the framework.
~~It returns the last inserted id. If your query runs, and then by the time it asks for the lastInsertId() another insert query has run you would end up with the wrong id in your script. If your script is only being run once, and nothing else is using the database at all then everything would be fine. Otherwise it's a potential race condition waiting to happen.~~ Edit: Welp, today I learned. (see judgej2's response)
Inserts in other connections will not affect the last insert ID in *your* connection. If it did, most databases would be a real mess, with race conditions all over the place; it would not be practical. If an ORM fetches the last insert ID from a global place (e.g. a sequence) or MAX(ID) from the table, then that is also going to cause big problems for the same race condition reasons. Thankfully I have not seen any of that tom-foolery for a long, long time. The database will provide the connection-based last insert ID, and it is up to the ORM or application to take a copy of that at the right time.
the jitted code starts with a load of "if type is not what I expect, jump to &lt;address&gt;". This address initially contains code that just jumps into the interpreter. If we get enough requests with the unexpected types, we'll re-JIT it, and put the new code at that first address. Essentially, we end up with a linked-list of different versions of the function for different circumstances.
Ah this is very useful. It makes total sense but I never really looked into it how exactly it all worked. I think your explanation will help clear up a lot of the confusion.
Hahaha I miss that from Quebec :) Toulouse and the whole south-west is awesome. For food and for general quality of life. I live on the south-east part, which is a bit different because of the heavy tourists affluence and rich-ass foreign investors (and mob). But we have a great quality of life as well, and a huge concentration of IT companies (in Sophia Antipolis, near Antibes &amp; Cannes). If I was a foreigner, that's where I would come to live for a couple years :) Paris has better jobs, and more food options...but life there is kinda sad and expensive. The language is not relevant...It will honestly take a couple weeks tops for you to be perfectly understood.
No idea, but it looks like they plan to go all the way to PHP7, which takes us to AT LEAST the end of this year. http://akrabat.com/testing-my-zf1-app-on-php7/
So from Teamtreehouse, it took about 5 months to get a job, but it sucked(It was a .NET shop, but that wasnt the reason why it sucked). After about 8 months on the job, I found an internship more geared towards PHP/MySQL and then since then Ive been employed. But I spend weeknights and weekends working harder cause its time to go to something bigger and more awesome. 
The entire concept of not verifying the peer sounds like a terrible idea in general. If people want to form partial &amp; insecure SSL connections, why not have them do it themselves from lower level components/steps, rather than officially support such an option that can't be easily globally controlled or even checked?
I was building apps in classic ASP with VBScript. Microsoft announced the end of ASP and launched their .NET ecosystem. Not being from a formal CS background, it all felt heavy and overblown to me. So I decided to switch to PHP. I started with some personal projects at the weekends until I'd found my feet, and then switched to using it for commercial projects. That was about 12 years ago. Now I have tens of thousands of websites running the software I've created, and I still don't feel like I really know PHP!
Learned Perl first. The switch was pretty easy.
1. Include the exception class inside the main class since it's your dependency. 2. Don't use `RC` versions in your composer dependencies, like: `"jyggen/curl": "v4.0.0-RC1"`. 3. Make sure to check for `simplexml` extension and don't assume it's loaded. 4. I don't know if you ever use this: `use Symfony\Component\HttpFoundation\Response;`. If not, can be removed. 5. Try to not make your class a static one. Something like: `new GoogleSitemapParser($params)-&gt;getPosts()` could also work. Static classes are usually considered bad practice. 6. Use `===` instead of `==` on line 67. 7. `throw new GoogleSitemapParserException('Sitemap has no posts');`, I'm not a big fan of this. You can just return an empty array, which means there are no posts, anyway. 8. `return $doc;`, it looks like it's returning something at first glance. You may replace it with `return true;` for clarity, or remove `return false` two lines above and have a single `return $doc;` 9. Else blocks in `getPosts` can be removed. Just return in each block. Also, reconsider if an XML being empty would be an exception cause. 10. "The XML found on the given URL doesn\'t appear to be valid according to ". According to what? Make your exception messages easier to understand.
Stream constructs are about as low level as it gets for decent IO in php.
No. is_dir() will only need to do a single, exact-match check. It doesn't know or care about the other 9,999 entries (ie. there's no difference whether there's 1 or 10,000 other directories).
In Symfony it would probably be a [bundle](http://symfony.com/doc/current/cookbook/bundles/best_practices.html). Depending on how your deploy system works, you might make it enabled/disabled by configuration rather than by adding/stripping code and files.
Maybe I'm missing something. Why would this be useful?
The most important step is people, unless you're building purely for yourself. The best technology and tools can't save a project with mushy requirements or which is trying to make the wrong people happy.
&gt; Why would anyone pay money for a remote database with far larger latancy than having it on a local server? far less maintenance for one. Dont need to hire a DBA. Second, theres no guarantee that it will have a "far larger latancy". I run on AWS, so does compose. Very little lag. &gt; The "multiple versions" is not really a selling point, since instaling databases is not hard at all. There is no difference with trying out MySQL 5.6 if you already know how to configure 5.5. Plenty of people out there are not exactly skilled at installing different versions of mysql. Let alone other versions of postgres, mongo, rethink, etc etc. &gt; Also using a database as a remote service doesn't allow you to teak it, which is where a lot of performance comes from. After 3 hours of tweaking my my.cnf file I managed to squeeze 30% more performance out of the same server. With these "services" you get a generic setup catering to the lowest common denominator. I'm not entirely sure this is true. Its their sole job to provide their users with an optimized install. &gt; If your website has large amounts of traffic be ready that the extra network access to talk to the database may contribute towards network congestion. If your website has large amounts of traffic, i hope to god you are not running a sql/nosql server on the same machine running your webserver. So, theres gonna be a network call anyways.
I can easily develop something that supports most versions of the different sql databases.
Given this is a small market project I would just write the project yourself. There's a lot of resources out there to get started and people here tend to be helpful as long as you show you're putting forth effort on your own. I disagree in using something like WordPress as it has a lot more of what you don't need vs what you do, and you'll have to write extensions/plugins for it just to add in what is missing. Doing something with Joomla or Bolt though could be an option, however, I would also weigh in on other frameworks too like Symfony and Zend if you're looking to make this a portfolio project.
&gt; Dont need to hire a DBA DBAs do far more than select a database. Nobody hires a DBA for that. &gt; Its their sole job to provide their users with an optimized install. How does that work? Do you send them your source code so they can tweak the database for your needs? One size doesn't fit all in database world. Event optimizing for reads and optimizing for writes are two wntirely different beasts. &gt; So, theres gonna be a network call anyways. To a server in the same room connected via a direct cable. Instead of being routed through 20 routers around the world. I haven't even started on the security implications of such an approach. What if someone hacks their servers? And all your sensitive info gets exposed. So the bottomline is I wouldn't trust an external database with a sensitive highload application, and non-sensitive aps like a wordpress blog don't really need testing on multiple databases. I really see no niche for this 
I think our sitemap.xml is valid, error would probably come from [sitemapX.xml](https://dobre-nemovitosti.cz/sitemap0.xml) which is not valid XML (it's that text format sitemap)
&gt; Uh, Yeah you do. How exactly do you even build a database system w/o a DBA? By building the schema yourself. If you can't build a schema, you need to re-evaluate your focus, and go learn how. It doesn't require a DBA. &gt; If I am in Europe and your service is based in the US. I 100% guarantee that there is at least 50ms lag because of physics. Is that a lot? Fuck yes it is for any significant load. Several DaaS providers have european locations (INCLUDING compose.io). &gt; Absolutely, but there is a big difference between in the same data center and NOT IN THE SAME DATA CENTER. Yes, there is a difference. But he implied there was no network call at all.
I'm a C#/.NET developer that's about to inherit a web site that's primarily written in PHP. What are some of the gotcha's that are common pitfalls for a developer used to a strongly-typed imperative language, and what resources would be good for jumpstarting into building a useful set of domain knowledge for an experienced developer?
Magento is using a micro framework on top of ZF. Magento modules should not access ZF directly. http://magento.stackexchange.com/questions/37024/why-arent-magento-developers-using-zend-framework-2-for-magento-2 
I thought about just using Joomla and a file repository component but I want to make this a learning experience and I don't really learn anything by doing it that way.
"By building the schema yourself. If you can't build a schema, you need to re-evaluate your focus, and go learn how. It doesn't require a DBA." I did not realize building a proper schema including foreign key relations and optimizing indices was a quick study. /sarcasm
My first bit of PHP was maybe 7 or 8 years ago when I was 15 or 16. I started looking into Mu Online private servers with a friend and there was something call MuToolz (I think) that you could use to create websites for your private server with - written in PHP. I made small edits here and there. I'd used other bits of PHP software for a while, and poked around every now and again to keep adding little features that I wanted, only really simple stuff. Later on, when I started my degree at Uni I started learnt JavaScript as part of the course. During the time between my first and second year I decided to try learn some server-side scripting, as I wanted to make more complex applications. I just decided to I was going to build something, and went for it. I came across problems, looked for answers, solved my problems, and moved onto the next. About a year and a half later, I was in my third year of Uni, which was my placement year. I managed to land a job at one of the largest e-commerce sites in the country, and that really, really accelerated my development as a PHP developer. In my final year of Uni I used PHP for all of the projects I had a choice of language in. By the this time I'd done a lot. It just all added up, and everything made sense. Aside from what I learnt while on placement, my PHP skills have been self-taught. It can be tough to know what's right and wrong there, and academically I've felt a bit behind at times, but I've read tons of books now, and learnt other languages too which has really helped. Basically, just code, and keep on coding. Don't be intimidated by other developers if you feel like you are, it'll come in time as long as you keep at it. Good luck!
Don't really need a DBA to set up Foreign Keys, and optimizing indices isnt that hard either.
Case 5 would be my choice - I'd expect a return value or an exception if you can't return a value. It's up to me to catch the exception and deal with it.
it doesn't need to be an amazingly generic crud to develop an application that uses an ORM.
&gt; Does this way consume less memory, not only on the PHP side, but also on the system as a whole? Are all rows fetched internally to an array inside PDO, and then "extracted" one by one to be used as needed by the code in the loop, **or is there some sort of "live" connection where each row is taken from the database and presented as needed, thus keeping memory use to the minimum?** The latter is correct, at least from my experience. If your table is huge, say hundreds of thousands of entries, memory usage will sky rocket if you attempt to fetch them all at once as opposed to iterating through them via ` while($row = $stmt-&gt;fetch())`. This only matters in extreme cases though, if your table is a couple thousand entries, fetching it all into a single array will only consume a couple dozen MBs or so at worst, which is usually fine. 
According this [this stackoverflow thread](https://stackoverflow.com/questions/2770630/pdofetchall-vs-pdofetch-in-a-loop), using `fetchAll()` will be slightly faster but will use significantly more memory than looping on fetch().
ORM provides usually CRUD + onetomany + manytomany + nested sets/closure table. This is all is "amazingly generic". Try some cross database triggers and maybe a few complex joins using temporary memory table sand then we'll talk mysql &lt;--&gt; oracle etc. 
I prefer the visualization of [clue/graph-composer](https://github.com/clue/graph-composer).
&gt; since it is just that much nicer of an RDBMS, seriously. I didn't down vote, but I'd like some examples of this as a day to day developer.
https://github.com/phine/lib-country
&gt; ORM provides usually CRUD + onetomany + manytomany + nested sets/closure table. This is all is "amazingly generic". What. There is no way you can say that every ORM implementation comes out "amazingly generic". An application doesn't need to have triggers (let alone cross database ones) to not be considered generic.
Safer defaults, strict error handling, better error messages. It can handle UTF-8 without having weird quirks and has nice stuff like the json-fields or hstore fields which can handle document-type data. I'll get downvotes for this post, too. That's just what happens in this subreddit.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Timeline of country and capital changes**](https://en.wikipedia.org/wiki/Timeline%20of%20country%20and%20capital%20changes): [](#sfw) --- &gt; &gt;This is a __timeline of country and capital changes__ around the world. It includes dates of [declarations of independence](https://en.wikipedia.org/wiki/Declarations_of_independence), [changes in country name](https://en.wikipedia.org/wiki/Geographical_renaming), changes of [capital city](https://en.wikipedia.org/wiki/Capital_city) or name, and significant [changes in territory](https://en.wikipedia.org/wiki/Political_history_of_the_world) (viz. land [annexation](https://en.wikipedia.org/wiki/Annexation), [cession](https://en.wikipedia.org/wiki/Cession) or [secession](https://en.wikipedia.org/wiki/Secession)). &gt;__ 2000s 1900s 1800s 1700s 1600s 1500s 1400s 1300s 1200s 1100s 1000s 1st Millennium CE 1st Millennium BCE 2nd Millennium BCE 3rd Millennium BCE 4th Millennium BCE __ &gt;&gt; &gt; --- ^Relevant: [^Lists ^by ^country](https://en.wikipedia.org/wiki/Lists_by_country) ^| [^Lists ^of ^capitals](https://en.wikipedia.org/wiki/Lists_of_capitals) ^| [^List ^of ^timelines](https://en.wikipedia.org/wiki/List_of_timelines) ^| [^States ^headed ^by ^Elizabeth ^II](https://en.wikipedia.org/wiki/States_headed_by_Elizabeth_II) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cs7mgdu) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cs7mgdu)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](/r/autowikibot/wiki/index) ^| [^Mods](/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Call ^Me](/r/autowikibot/comments/1ux484/ask_wikibot/)
If you really want this to be a learning experience your best bet is to probably do it with either Symfony, Zend or Laravel frameworks (those are the big players in the field). This will give you a better idea as to what companies will be looking for. To make it more of a learning experience try to do certain things (i.e.: filesystem I/O) by hand before using helper components like Symfony's Filesystem component. This will give you a helping hand on how things actually are being done so you don't just know the how, but the why.
True, they "only" have relations to the creator of the comment, the post they appear in, the people that voted for/against, and the places where it was shared. Not to mention that it could have relations to the people that is mentioned in the comment itself, The people that saved the comment in their favorites, the parent comments, people that reported it for spam, and people that replied to it in sub comments. It seems (looking at the reddit comments example) that NoSQL is indeed a very poor choice for them.
It is similar as in both a relational database systems, but they have different features. Postgres for example allows you to query tree structures in an efficient way and also lets you, for example, store json as real columns in the database.
It's OK but not really tackling the same problem. This locks you into a specific format and works off installed packages only. Mine works off remote and you can easily make a graph like that from the json.
Huh, I didn't even notice the links at the bottom. They're just little non-descript boxes when left out in the open like that. Got to the end of page 1 and thought, "Well, shit, that was easy. Did that really need a blog post?"
Which is not totally correct, because by default mysql drivers anyway buffer the results internally, see my answer.
This is exactly the answer I expected and I love it. :D
oh, by the way, note that this answer isn't totally correct. The mysql driver actually internally uses a different memory manager, so memory_get_usage() is not showing you the *real* used memory, but just the internally used memory. (btw. no, memory_get_usage(true) doesn't help either in that case.)
Might be targeted at a younger crowd (that's when I read it) but [Head First PHP &amp;amp; MySQL](http://www.amazon.com/Head-First-MySQL-Lynn-Beighley/dp/0596006306) was my first PHP book and it was great. It teaches you the very basics of the language, and it's up to you to take your education from there. For example, it'll cover connecting to databases and file inclusion, but it won't cover frameworks or advanced Apache/Nginx configuration. IMO the chapter on image manipulation was a tad too long and unnecessary, but w/e. Hope that helps. Welcome to the addiction.
Very interesting approach on rebuilding legacy app with symfony components. I suggest watching this video https://www.youtube.com/watch?v=-qh4bYRABDs
Yes, that's the case. But you can just after doing fetchAll() immediately release that memory by unsetting the statement. Yes, it uses some additional memory, but if you can afford doing a STORE_RESULT (the default), then you usually also can afford copying your results into an array.
The codeacademy courses are good but lacking at the moment. I'd start with smaller features of this project first. Break it down into parts you can manage. First I'd get a simple index page setup with a db connection and your db mapped out. Then look at the [Steam API](https://developer.valvesoftware.com/wiki/Steam_Web_API) and start tinkering with it. If you're lost, always check out [php the right way](http://www.phptherightway.com/) and remember to just have fun, you don't need to create the next huge thing.
you don't need to call validate() in this case, there's no dtd to test against. So in this case if DOMDocument doesn't error out, and you can assume it's valid XML. However, if you have a schema or DTD you can give it to DOMDocument as well.
That's what I ended up doing and it works perfectly. Kind of unrelated: I'm storing my objects in sessions, because I'm transfering the Person-object from page to page when I'm adding new things to it. I've read this is not considered good practice. Is there some other way to do this?
A good way to do that is with `compact()` and `extract()`. (Extract can be dangerous with user data, but it's perfectly fine when you control the input.) So: return compact('result', 'status'); And then: extract(function_name(.....)); One nice thing (which is also a bad thing) is you can change the what you send with the compact call without having to change the function call (well, except to make it deal with the new variables). This is a mixed sword, some people hate that this is possible - a function call should never be able to change the caller, other find it useful. You pick for yourself.
Yes I can, and it is. Why would anyone hire DBAs then if CRUD and basic relationships were all you needed ? They dont even scratch the surface of DB possibilities. What about even some aggregation ? Apart from basic stuff like count() not much is supported by crossdatabase orms
Haha got me. It is goodish. I have looked at entry leaving programming jobs on upwards of (NZD) $75,000. Unfortunately for me I don't have a formal programming education (though I do have a degree and CPL...). I was coding extensively (and badly) 7 or 8 years ago before I stopped while I was at Uni. Now I've returned to the coding life it's all about getting my skills up to a professional standard and building a bit of a portfolio. Anyway that means my prospects aren't very good... Wellington is my home town! I no longer live their because I grow bored of places particularly easy, but it is a great city. A good mix of everything. It sounds very similar to your Montreal in that they don't really care for what Auckland/Toronto is doing.
Taylor Otwell, the creator of Laravel, also built a service called Envoyer: https://envoyer.io/ I haven't had a chance to use it. I use his other service, Forge. It's pretty neat. You might find luck with Envoyer.
Doesn't look like you're getting a lot of answers to your second question. &gt; what is the difference between $object-&gt;method() and $object::method()? Which do I use when? The first form, `$object-&gt;method()`, is an **instance method**. That is, it requires an instance of a class before you can use it. $car = new Car; $car-&gt;drive(); The second form, `$object::method()`, is a **static method**. This generally means that an instance is not required. $wheels = Car::numWheels(); (Bad example, sorry.) The best way to think of it is that if the object you're dealing with is a specific object (an *instance*), then you use instance methods. If you're dealing with an entire class of things (e.g. all cars have 4 wheels), then you use a static method. Sometimes you can use static methods to return instances: $car = Car::findModel('Accord'); //static method, returns instance of Car echo $car-&gt;model; // "Accord" Here's another example: $user = new User(15); echo $user-&gt;name; // "Joe Schmoe" $gender = $user-&gt;getGender(); // Male In this case, you want a particular user's gender (Joe). An example of a static method with a User object might be: $users = User::loggedIn(); // Get the user that is currently logged in or: $users = User::allFrom("Kansas"); // returns Cletus, Sally, and Bob, the users from Kansas 
4.1 with results an array as well. 
&gt; It rather defeats the point of having a default value if you can't configure it, Preventing stupid behavior by the user is the responsibility of the language. Globally disabling peer-verification would indeed qualify as a stupid behavior and is therefore disallowed. Security is not the kind of thing you allow people to globally disable. You make things as secure as you reasonably can by default and allow people to relax those restrictions on a case-by-case basis if they really know what they're doing. &gt; and can't check it, Wat? It's possible to check any value in the stream context used to establish a connection. That said, there is no need to check it as it's a fundamental feature of the language version in use. If you're using &lt; 5.6 you should have already been specifying this yourself and if you aren't your transfers will fail as of 5.6 because they shouldn't be allowed in the first place. &gt; and have to explicitly state it for each use case. Wat? You only have to explicitly state it if you want to do something stupid (or you're operating in a one-off scenario where you know what you're doing). &gt; It's useless, no? I mean, the value's currently 'good', but untrustable. Useless. How is this untrustable in any sense of the word? Can you imagine the internet blow-back if PHP moved from a secure default to an insecure one in some future version? No, this is perfectly trustworthy and in no way useless.
I did the same thing migrating an application from zf1 to zf2. Creating a new index.php has many advantages, most of which is being able to leave your current application untouched as you move pieces over. Once you migrate a feature over, you can deprecate the old one for a while to make sure you don't have any regressions before removing it. 
I wrote [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp) for just this reason. tl;dr: It's probably too early to switch to a framework. More likely, you need to get the application as-it-is into better shape first; then, once the concerns are well-separated, you'll be in a better position to transition to a framework. Above all, do not consider a rewrite first. For a longer treatment of this topic, cf. &lt;https://vimeo.com/47849625&gt;. Hope that helps, and good luck.
This is kind of a huge, wide open problem. Since you brought up typing, I guess the main thing is that even though PHP is dynamically typed, you can type hint and make it a *little* stricter about types. If you're using a modern framework (Laravel, Symfony, etc), then there aren't a ton of gotchas. I mean, I guess you just need to be more specific about what problems you're running into for me to be more detailed with answers.
If you test it on a 5.5 server and everything still works, it should be fine to just apt-get upgrade. You should be aware that the latest stable version is 5.6, though... And PHP 7 is on the way... (we skipped PHP6, long story..)
This page describes how to add a custom ruleset: http://phpmd.org/documentation/creating-a-ruleset.html Sounds like you can just copy that rule into its own file and refer to that ruleset. Alternately, I *believe* with phpmd, you can make a config file that will include only specific rules that you want to follow, but I don't see that in the docs. It's probably similar to `phpcs` though.
Again... You don't need to build something COMPLEX for it to be non-generic. Read this a few times before you comment again. My experience, nor anything you said in that comment has anything to do with my response.
How i learned all my lamguages. First lynda then books.
No doubt, you're absolutely right that it's a huge problem space. I guess the best I can do is establish a few things that we can try to assume and narrow from there. Let's assume that I can look at an example codeset, and with less research than a complete beginner, determine what it's attempting to accomplish. Let's also assume, that since I'm mostly used to imperative, strongly typed OO languages, I am unable to properly determine what, exactly, is good practice for development in a loosely typed language. From what I can tell, with the minimal information I've been given at this point, is that I'm going to be handed off a Zend/Magento installation. The assumption is that it will be feasible for me to take over with this, and while that is almost certainly the case I would like to have time to prepare so I'm not looking up insanely simple things on stack overflow all of the time. I haven't run into problems yet, because I haven't actually begun maintaining it yet. It's just a thing that will happen later this month, and since it's moronic monday I figured it was the right time to ask what the best approach to not just being completely lost would be.
Can you point out any tutorials thay may help?
Well the application itself might be non-generic (when talking about actual code side), but what we are talking about is non-generic database access. Surely if all you is get all rows and then do some complex permutations with the data in PHP its not a generic app, but the data access is generic indeed
Nice ;) By Iterators, I mean that you should check the SPL (Standard PHP Library) Iterators classes : http://php.net/manual/en/spl.iterators.php For the moment you open the XML, crawl it then store it in array... I suggest that you can change the behaviour of your class that it can be used directly as a foreach input. It just allows to limit the memory storage overhead added by the stored array... Maybe it's a tiny optimisation for your lib but I think it's just good practices to rely to Iterators in that case :)
Benchmarking across languages is always a challenge. Even if you devise a perfect method, how will you replicate code across languages to ensure a fair trial? Do you want to benchmark string manipulation, external requests, database interaction? (No, a simple "Hello World" is not sufficient). Honestly, I'd wait till PHP 7 is at least in Beta before comparing to other languages.
See you say "I'm gonna get down voted for this". But really, when you make a comment that people feel like they should react to, "you've been using x all long while y is better", if you provide solid examples you'll get upvotes. 
While probably unpopular in this sub: If your company has already invested in the .NET environment and you are confident in C#/.NET, why not stay in that environment to develop that app? Learning new things of refreshing old knowledge is always a good thing, but it can make sense in a business environment to build on what you already have.
Thx for pointing out. Didn`t realize that it works remotely.
PHP is prtty much always going to be slower than things that compile to actual bytecode and use JIT ( JVM and .NET stuff) by simple logic. PHP7 might catch up and outrun Python and Ruby though.
This thread has revealed half the PHP devs don't know how last insert id works. Someone even downvoted you for giving an accurate description of how it works. That's hilarious.
It is just one of those topics that was discussed so often already that I get lazy providing examples and explanations every time it comes up. I also don't have a good "default link" that I can drop since most articles about psql vs mysql tell tales of superior performance of mysql and bad scalabiltiy of psql where as the reality looks quite different right now. If you are not stuck with very old versions of psql, those typical problems of psql have been solved in the last years. The performance has increased overall, there are now decent systems for clustering servers and psql has document db features as well as a decent full text search. Disclaimer: the json features probably wont work well with megabytes of data in each document and should be used for additional data, not the meat of it. 
&gt; Benchmarking across languages is always a challenge. Even if you devise a perfect method, how will you replicate code across languages to ensure a fair trial? I remember seeing a Java vs C# benchmark back when I was learning C#. The benchmark was terrible because they were writing their code in a way that no C# programmer would write it. I had about a month experience and even I could see how flawed the comparison was.
Do you mean the same as /u/shulard who told me to use iterators?
Built on Laravel 5.1? :P EDIT: The site I mean, obviously.
Yes. Since PHP 5.5 there's no reason to using iterators anymore. Iterators are the poor man's generators.
I just keep plugging at it, and try not to get stressed :-) I expect many are coming at it from different directions, so they see the problem from different levels - their favourite ORM or framework, and don't really grok what is going on under the hood. I'm old school. I like to understand how things work from the ground up, so in this case I know what the database *can guarantee* and that there could be any number of layers of PHP over that which could break that guarantee to the coder, but that still doesn't change the underlying mechanism. It's Moronic Monday, so I won't judge :-)
Is it maybe possible that you help me with the implementation? I have now done this if (isset($sitemapJson-&gt;sitemap)) { foreach ($sitemapJson-&gt;sitemap as $post) { if (substr($post-&gt;loc, -3) === "xml") { $this-&gt;setUrl((string)$post-&gt;loc); yield $this-&gt;getPosts(); } } } elseif (isset($sitemapJson-&gt;url)) { foreach ($sitemapJson-&gt;url as $url) { yield (string)$url-&gt;loc; } } However, when I access it $posts = $this-&gt;getPosts(); foreach ($posts as $post) { print $post; } I'm getting an exception: &gt; Catchable fatal error: Object of class Generator could not be converted to string in But all the tutorials and examples are doing it like I am doing it. Do I have to do that different? Can it be a problem, that I'm having a method, that can be called again by itself? I mean, the method `getPosts()` calls the method `getPosts()` if the posts are not single links, but an array. But I also tried it like this First if: $this-&gt;getPosts(); And then in the elseif yield (string)$url-&gt;loc; But this didn't work either. Because if I have it like this, I'm getting an empty response. So, printing it out doesn't return anything. And when I `var_dump($posts);` I'm simply getting this `object(Generator)[3]` 
From the original source * line 68 becomes `self::parse((string)$post-&gt;loc);` * line 73 becomes `yield (string)$url-&gt;loc;` * line 43-50 replaced (since idk why you're having an array unique there): foreach($gsParser-&gt;getPosts($validXML) as $post) yield $post;
Okay, so there is some semantics going on here. By "last insert statement", I am assuming it was executed, and successfully inserted a row. Without an inserted row, the whole idea of getting the sequential ID of that inserted row is a moot.
TBH, if B fails, I would normally treat `lastInsertId` as undefined. I mean, get the insert ID for something you just inserted, if you know it got inserted. Don't just blindly run an SQL statement, ignore whether it worked or not, and then run another statement that *assumed* the previous statement worked. The arguments against the last insert ID being guaranteed come down to: &gt; "If you don't use it right, and don't check the success of each stage, then it ain't always gonna work". Well, yes, that *always* applies when coding.
Thanks! And I'm going to have to google PHP6 to read that long story.
&gt; Well yes, I wouldn't argue with that. That's what I meant with my first comment. I was just noting you guys on the semantics because you were actually arguing something which was not a point of discussion at the first place :) 
This entire tree exists from semantics. &gt;I am assuming it was executed I think this is what beryllium tried to make a point of, this cannot be assumed in this instance and the `lastInsertId` should only be used within the successful brackets which OP didn't have. When you do `$result-&gt;lastInsertId()` (what OP wants) you link this method to this exact statement and no other. This is not how the current `lastInsertId` works and guarantees, not to mention $result could also be a `select` which makes it weird. So the naming of lastInsertId is correct and the responsibility being in the connection class is also correct imo. Don't forget `lastInsertId` also returns the inserted ID of *the first row* if you insert multiple rows with one query. essentially not being *the last inserted ID* as well.
You can only get options of an existing stream. So you can't test before calling file_get_contents() because the stream doesn't exist yet, and can only test after the fact, which would be too late. So you have to supply the value every time, or instead of directly checking it, check unintuitively via the PHP version number. And trust that in the future the code doesn't execute on a version of PHP that is as unsecure as pre-5.6 ones have already been, by 'default'.
Yeah, with the whole tribalism around languages i wouldn't trust anyone to come up with a fair comparison. It's hard enough to get meaningful benchmarks in the same language (every browser vendor decided to come up with their own js benchmarking suite so they'd look better, for example).
Great tutorial. Loved the way you're explaining class and functions.
Nice tutorial, but I'll never understand you would still do `private $_name;` when we've actually had property visibilities for like years. It doesn't bring anything and will just confuse a newcomer that may think properties need to start with an _ or something
If you want to see benchmarks of PHP7, [check out this page](https://wiki.php.net/phpng#performance_evaluation). They've been consistently benchmarking PHP7 as it is being developed. The parameters around the benchmarking are documented there as well.
I think the point was not to start creating superfluous new files (index-new.php), but instead just let the VCS handle the changes you're making. This also lets you remember what you've done weeks down the line, simply action roll-backs and makes the deploy far less error prone. Of course a VCS may not be an option depending upon the host and level of access. In general (and depending upon your PHP level) I'd suggest a pragmatic approach - patch what you have to allow the site to continue running safely / provide easier maintenance and then start building something new once it's manageable day-to-day. This avoids the disjointed foisting of a modern framework onto legacy code (which is often less clean that one might imagine). A very, very simple new router class that just includes existing files would indeed be a nice first step and allow an initial and quick update of an unmanageable .htaccess files. All your entry point would have to do is get the the required route (e.g. parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH)) and then either include that file (put all existing files in a directory below the public route and you're done) or check against some hard coded patterns. Then a file at a time separation into a simple MVC style system (or whatever - logic separate from presentation is key) would provide a nice stop-gap (and allow simpler maintenance) while a new framework driven project could be considered as a true replacement in due course. Take all with a pinch of salt, without seeing the project it's very hard to advise!
I absolutely second this. You will never make something perfect the first time (nor will you the next 1, 2, 10+ times), but you will learn and meet / overcome lots of real world issues by actually trying to do something for yourself. I'd say that the above project is a little ambitious for a first foray into PHP. I'd suggest you make something that simplifies static HTML first (i.e. a basic, static site), then update it to store the content in a database (use PDO to connect to MySQL), then make this content editable (forms and POST data) and then make the editor secure with a login system (DB, sessions, hashing). Once you've researched enough to complete all of those you have the basis of a simple (and no-doubt insecure) CMS. At this point you should have a look at object oriented, best practice approaches to everything you've just done and think about improving / re-writing what you have. Again do this from scratch without just copying someone else. Improve this system into a blog - that will teach you about routes and vhosts (.htaccess) if you're using Apache or server blocks if you're using NginX. At that point you have a good appreciation of the basics and can move on to using a framework (e.g. Laravel, Symfony, Yii, Zend etc etc), but I wouldn't skip to that point without a bit of messing about on your own first. As mentioned above, Google and StackOverflow are excellent resources... Good luck!
Thanks again for your input. I updated most of the code from your and others suggestions https://github.com/tzfrs/googlesitemapparser/releases I'm now also using generators instead of arrays.
Bottom part of [this infographic](https://www.zend.com/en/resources/php7_infographic) benchmarks PHP7 against Ruby and Python. 
I just like the convention of beginning private class variables with an underscore. It is just a personal preference and doesn't hurt anything. I can understand if it isn't your thing my friend.
it seems promising. what about firewall, security updates etc?
About 15 minutes after posting this, I got a reply from Dan at Block 8 that cleared everything up.
Only digital Ocean? I'll have to keep an eye on this for AWS support :)
&gt; I had actually implemented this a long time ago before I knew there was a name for it That's how it goes for most patterns ;) 
Just to drop something positive. I like it and may use it for a bigger API soon. I also see no problem with your decoupling Arguments in the previous comments and fully agree with you. Using bundles to decouple through interfaces seems to be an valid and nowadays often used approach. I am looking forward using it. :-)
The interesting thing about this tool is that we do need something do maintain our license files, but also we have regex, so... I guess the question is how does this compete with multi-file regex in any IDE. Maybe it does, genuine question.
Hi, I thought about this too. Unfortunetely I have no idea how I would test this class.
Clarifying questions, yes, thank you! I'm actually doing a simple thing - trying to calculate the changelog between two packages, and was deciding between a preg_match style `if (getChangelog($fromPackage, $toPackage, $changelog)) { /* yay, changelog */ } else { /* boo, failed */ }`and throwing an exception. Your questions made me think about the problem area once more, and to consider the angles I haven't considered before. As I'm not so much looking for the solution to the immediate problem, as for a way to do things like that in a robust and easy to use way, your questions are very welcome. &gt; How rich is the code-domain? Are `DivisionResults` something you might want anyway in order to flow them into other methods or to channel developer into writing code in a certain way? I'm not sure I understand that one, though. Would you mind to elaborate?
Aren't there hot keys in both of those (I know for sure in Terminal it's CMD+k)... not sure why you would need this.
Bravo
Fair enough. Thought maybe I was missing something beyond personal preference.
this is a huge list.. thanks
For more advanced CLI manipulation use cases there is http://php.net/manual/en/book.ncurses.php
&gt; I'm not sure I understand that one, though. Would you mind to elaborate? I guess what I mean is "how much are you trying to model the universe?" For example, suppose you're building some code for a company that is trying to figure out how much to tell customers a given task will cost. You might end up with code like: $result = pricingService-&gt;makeQuote($taskSpecification); Now, maybe you can get away with `$result` being a `float`, but in that style of application you might want a `Quote` instead, e.g.: /** @var Quote $result */ $result-&gt;isDoable(); $result-&gt;getAmount(); $result-&gt;getWarnings(); $result-&gt;getErrors(); 
thanks. I'll put it in the todo list. 
You are taking it too seriously. PSR's are a guideline nothing more.
Is the source on GitHub?
Might've been the better option, indeed. In this case I was trying to avoid using databases to see how far I could go with object-orientation and sessions.
Are these resources good for someone new to PHP?
I'd say just get something on paper (or in code in this instance). Depends on what the project is I guess, but just start building. Put the HTML/CSS down first. Then figure out where the PHP stuff is needed and start writing that. Don't overthink it too much just put some code down and then refactor where necessary as you go.
Community established coding standards are just a guideline, yes. But I believe it can be worth the extra effort to adhere to some standard. That is what will improve the maintainability and readability of PHP code. I believe there are some valid points raised here that are worth listening to.
That what im going for, so far I can handle stuff like getting variables to display (provided they arent too complex) and populating divs with content that way. However work have set me a task which does cause me some concern as I am struggling with it, when its nothing too crazy. Its just a bit frustrating that I can remember what certain things do, but not the practical use of such things.
It's all about what I call the Experience GAP. The you, you are now, is based on skills, decisions, abilities you have excersized since birth. To explain who you are now, and how you get there, compared to a far younger version of your self is very hard to convey. So basically all the most experienced programmers/dev have gone through a lot of painful learning experiences, but once they went through all that, to get a solid grasp of the basics, then they have contempt for anyone who doesn't. Here is my suggestion. 1. Stop worrying about how you compare to other people. If they don't respect you, why should you respect them? 2. Focus on endless practicing. Find project ideas, githubs, anything you can to do practice all aspects of your craft. 3. Never assume you know it all, anyone who acts if they do, is prolly far less competent then they pretend to be. Here is what I consider the basics of any programming language, at least server side ones. Variables Data Typing File IO If Then Else Database Store/Retrieve Data Display You talk to any ten people who have had the same years of experience, and you will get 10 different ways of handling different situations. You should learn from other people, and learn mostly like in any field "WHAT NOT TO DO". Now once you master basics, you get into advanced stuff, what I consider advanced, which if you ask anyone else will be a billion other things. 1. Web Server Configuration/Setup/Tweaking/Monitoring 2. Database Design/Modeling 3. Query Writing/Rewriting 4. Views and Stored Procedures 5. Web &amp; Data Security 6. Web &amp; Database Performance 7. Maintenance/Backups Etc. I am sure there is more to this list but this is my list. The only limit is, your willingness to learn from any positive and any negative experience. Shit happens, and how you learn from it, and how to make sure shit never happens again, is your ability to become a craftsman, vs someone who does a hack job. I hope this helps, and good luck!
&gt; Community established coding standards are just a guideline, yes. The community was never involved in these standards. A small group of framework and application authors decided on these 'standards' this for themselves for better inoperability between their projects. &gt; But I believe it can be worth the extra effort to adhere to some standard. That is what will improve the maintainability and readability of PHP code. Yes, but there are many coding standards. Arbitrarily deciding what which one everyone should adhere to, and complaining about violations of your preferences is ridiculous.
Great idea. Keep it up. As for the recommended books (let's change it to "materials") part... Go to https://laracasts.com/ - you'll find there few really good (a sometimes even free) tutorials on how to start project in a solid (literally S.O.L.I.D. - Google that someday) way. For example the one on laravel 5 fundamentals (and this one is free - https://laracasts.com/series/laravel-5-fundamentals). This alone probably would solve your problem right away. In the meantime start going through http://www.phptherightway.com/ - don't get some bad habits right away.
Looks cool! However, could this not be simply defeated by extracting the text and running it through a dictionary to find words of x many letters beginning and ending with the parts of the word you have. Also, (though this is not a weakness) some CAPTCHAS would have more than one answer. E.g. wr_ng could be wring, wrung, or wrong.
No reason. I usually do `getStatus()`, but I was just giving an example. I do sometimes just do `status()`, but pretty rarely and only under the circumstances where it's a read-only thing. I dunno. Good question. :)
Oh, now I see. I *should* get used to using ValueObjects or something in place of simple scalars more often. Thanks!
Nice project, I'm always looking for new packages. I don't really like the design as it's a bit hard to understand what is what on the first look. But other than that it's really awesome.
Something like [react](http://reactphp.org/)?
ReactPHP seems to fundamentally change the execution model of PHP. 
Well, you asked for node, you got node (and php is capable of hosting longer running cli applications since 5.3) ;P Maybe guzzle 6 is closer to what you are looking for as it implements async http requests using an Promises/A+ inspired API.
thanks. I always like checking out different CMS' and I haven't even heard of Bolt. Honestly, I should be better than I am considering how long I have been doing this stuff. I was using Joomla back before it was Joomla. I just got to a point where I knew how to do what I needed to do at the time and I stopped learning and growing. I regret that but am trying to make up for it now. 
Will you have to store it somewhere. From page to page I can only think of 3 places. Session, database or post data. You could maybe use some sort of cache I guess but that's not really much different to sessions in this instance 
Done. But, as /u/alt_account10 suggested I'm now using generators instead.
Yes, definitely! I must say I'm already in love with your project. I'm pretty sure you will find someone who could make you a design easily (if you cannot make it by yourself of course). 
I agree, swiping back on my touchpad is so much easier than closing a tab. I guess I'm lazy 
Is this just about hosting/deployment? I could still use Larvel in combination with Google App Engine, right?
Yes, it could be done. But I wanted to create a human-friendly captcha. If hacker wants break captcha, he will use anti-captcha services, so ...
&gt;Comprehensive Meaning pointlessly long and likely containing many overlapping documents?
That's kind of the idea. React changes the execution model to be very similar to Node; what you see is very similar to how Node works. The real difference is if you just want parallel requests, or if you want a completely asynchronous program. React, and other true asynchronous systems, are an all-or-nothing kind of deal.
Not if done right. Take NGINX; it is implemented as an event loop reactor (like ReactPHP), where each component of the server is added to an event loop. Or Node for that matter. Granted, both of these use thread pools *in addition* to help lighten the load and delegate time-consuming tasks.
The problem I see is that a web server is designed to respond to traffic differently than an event loop should. When a web server gets too busy it just throws its arms up and does who knows what. Error 500 is more likely than not. What I am saying is that putting the webserver in the event loop is basically DOS'ing yourself. Also how do you get a JSON request with CURL async anyway? Doesn't PHP wait for a response before it moves on?
Nice article, although I do find the suggestion that we use HTMLPurifier for casual HTML output escaping strange. The use of this library suggests we're taking HTML from an untrusted party (as opposed to plain text that we can escape and decorate with HTML in out templates). The HTMLPurifier site cites a legitimate use example: filtering HTML emails for XSS attacks. I can also think of a few other cases, but they're all very specific, and definitely not the norm when rendering a basic site template. And the performance hit of parsing and rebuilding HTML on every page display as shown would be significant.
I was originally waiting for someone else's XSS filtering library to be ready for public release, but that hasn't happened yet. (Said library allegedly operates several times faster than HTML Purifier and is just as effective at stopping XSS.)
I haven't used NGINX a whole lot either, to be honest. :) Concurrency is just what I've been working with (and implementing) lately. Node is a mainstream example of what async event loops done right gain you: threads that don't stop for nobody!
PHP is single threaded (unless you use pthreads), so in order to have true async you need to use multiple processes. cURL supports multi-execution, which is sort of like async, except you have to poll for completion, it doesn't call you back. You need to sit in a loop. You can create a simple reactor using sockets with nonblocking I/O, but this is also not true async, because you need to sit in a loop for this as well. Basically you can't truly emulate async without completely inverting the control flow, like what React does. Node also does this, because JavaScript is also single threaded.
Why would you want to do this? If you're just trying to draw a user interface, use ANSI escape codes. These will also let you erase the screen. This is what ncurses uses. https://en.wikipedia.org/wiki/ANSI_escape_code Also consider just pressing CTRL+L
Trial and error, starting in 2002. Eventually started reading the C source code, because I got tired of trying to divine undocumented behavior.
How do you allow users, with the strategy you've outlined to submit some HTML but not trigger XSS attacks?
&gt; How do you allow users, with the strategy you've outlined to submit some HTML but not trigger XSS attacks? As I said, I consider this scenario quite specific and highly unlikely (although not impossible), almost as unlikely as someone submitting Win32 GUI commands or iOS Cocoa API commands to me. HTML is a client UI technology, it has a ton of surface area, so it'd be my last resort as a part of a service API and a domain format. Not just due to security - it'd be a poor design and a lot of effort to maintain, I'd prefer a format that matches my domain semantically, so I can understand it, adapt it to non-HTML clients as I need, etc. So it depends why they submit HTML. What's the use case you have in mind (don't say "a comment form", heh).
PHP 7 is on its way!
For years I took the easy route and used wordpress and plugins. For my final 3rd year project in my university diploma, I had to build something from scratch for the first time. I absolutely battled to get going at first. Until I treated thr project, like an actual project. I used Asana and set myself tasks, with subtasks. Basically breaking down the project into much smaller pieces. Before I knew it, I was getting stuff done. I ended up building an invoice, quote, expense app in php as my first thing I've ever built. For me it was such a relief seeing those subtasks get ticked, and then finally the main tasks. I was just way to overwhelmed when I just looked at the entire project as one big task. 
Right, PHP development isn't done in Vagrant...oh wait.
"clear" would just clear the current screen, but not the scrollback. Clearing the latter is useful when your program prints a lot of output that you later want to select, e.g. generating SQL import/export code.
Gonna listen to Darkthrone while I peruse this. Br00tal.
Pretty interesting! It could be perfectly used for small sites. 
That's a fair point, but since people are already accepting specifically-HTML in their apps, this advice is meant for them. You don't have to follow it. If you can avoid HTML and instead use, e.g. Markdown, I agree that it makes life **much** simpler.
That's ok, but in this case the correct place to use HTMLPurifier is when you *accept* the HTML, not when you display it. First, you place undue burden on the view to assume it's being given malicious content. It's the job of the view to encode content, not to filter it for attacks. The difference is subtle, but crucial. When you give a view a piece of *text*, then having &lt;script&gt; in that text is not an attack. It's just a piece of text saying "&lt;script&gt;" to be displayed verbatim. But if you give a view a piece of *html*, then having &lt;script&gt; in there may be an attack. It's not view's business to fix this. It's domain's role. the semantics of purifying HTML here are an input filtering/validation step which should happen before the HTML is stored in your database (which goes contrary to your advice "don't optimize prematurely"). Filter/validate on input. Encode on output. Not only is it more semantically correct (you don't want to store HTML with XSS attacks in your DB, right?), but also it's faster: a piece of content will be accepted once, but read thousands of times (to give a modest number). Do you want to run HTMLPurifier once or thousands of times.
Escaping for XSS attacks before inserting in a database is the sort of engineering failure that caused the XSS vulnerability in WordPress 4.2. Feel free to cache the output (Memcached, another column or table in the same database, etc.), but keep the original data in the database intact.
I always encourage people to validate data on input, then return a recoverable error state to the user to correct the error. (i.e. "This is not a valid email address you dunce.") The purpose of libraries like HTML Purifier is to prevent XSS attacks on blobs of valid HTML. It's not an "encoding" step. You shouldn't be encoding HTML entities unless you want it to break. An XSS payload sitting in the database **that can never execute** in your web application context is the *desired* state, because it allows you to collect data about the attacks that people have launched against your application. A good middle ground would be to **store the original wholesale and then store a purified version either in the same table, another table, or in a caching layer**. Then fetch that instead of the original unless you need the original (e.g. to rebuild the purified version). That way if you upgrade HTML Purifier and it produces prettier output, you can rebuild it from your unmolested input. But chewing data up before you insert it? I don't condone that.
 function () {... return [$result, $status]; } list($result, $status) = func(); 
&gt; The purpose of libraries like HTML Purifier is to prevent XSS attacks on blobs of valid HTML. It's not an "encoding" step. You shouldn't be encoding HTML entities unless you want it to break. You should read my comment more carefully. I also said it's not an encoding step. Once again 1. On input: filter (trim whitespace for example, convert UTF8 encoding to canonical form, etc.) and validate (ensure the value matches the domain). 2. On output: encode one type of content (say plain text) for another type of output (HTML). Therefore HTML Purifier, as it's not an encoding step, it's a filtering and validation step, should be performed on input. If you don't want to accept HTML with scripts in it, you should *never* allow one to be stored in your database.
&gt; An XSS payload sitting in the database that can never execute in your web application context is the desired state, You're mixing concerns: 1. Logging (for security, audit, whatever purpose) 2. Domain state. I'd never advise mixing those two concerns. Logging invalid input doesn't mean you have to accept invalid input in your canonical domain state.
Addressed here: https://www.reddit.com/r/PHP/comments/3a3lec/everything_you_need_to_know_about_preventing/cs9bo29
Changehub is a product we've been developing internally at http://madewithlove.be. It allows you to manage project changelogs using Github pull requests written in the keepachangelog.com format. The product is still in beta and being actively developed, we're looking for beta testers that can provide us with feedback about how to improve Changehub.
Well, holy sh\*t, that's **much better**. I did think the naming was confusing when it was introduced, but I thought there's no hope of changing anything as the specs are locked. But... I'm glad the rules were broken a bit here in order to fix this. Great job!
Where you develop your PHP scripts is irrelevant. Fact of the matter is that the setup of that environment is out of scope for this subreddit. If anything, you should be asking this question in /r/vagrant, not here. What's next, are you going to ask for hardware help because you're developing on a computer?
Do they still disallow CURL? Thats kind of a killer for me (although I'm slowly moving over to Guzzle)
I know this is going to sound very "generic", but I suggest checking out how to create a simple todo list. It will show you CRUD in it's most simple form. You could also try creating a very small framework using components from Composer and autoloading in the classes. If you wanted a contact form, then try and create that, get the form to email it over to you and save a copy in the database. Key things you need to know when starting a project are... MySQLi/PDO functions (decide which one is best), Composer, PHP Classes, PHP methods. There's probably more to this, but I think that would be a good start.
It might be a bit scary/hard/not possible but I would seriously consider having a look for other jobs. A great junior dev place can do wonders for your skills. It sounds like you are smart and willing to learn so I'd bet on you doing well either way but why make things harder :-) 
The people here are very nice and sociable, and the general atmosphere is good. I am just not learning as much as I want to. I have learnt some front end techniques, gulp, Sass etc, never really got taught them just got given the project files and worked that out. I have been here for around 3 months, and I have learnt more from my self study at home. It does even cross my mind getting a normal none dev job, even like in a store or something just to give me a bit extra free time to learn what I want. Not too sure though
&gt; I'm glad the rules were broken a bit here in order to fix this. The PHP release process is more what you'd call "guidelines" than actual rules. In exactly the same way that Congress/Parliament can't trivially pass a law that limits future Congress/Parliaments, any RFC can overturn any decision that was made before. The reason why this doesn't lead to chaos is that people are (currently) reasonably sensible about planning out releases ahead of time, as they aren't just idiots with opinions.
This is a pretty cool project. I just want to say that Laravel uses Bootstrap by default so head over to http://getbootstrap.com for more information on it. Bootstrap is pretty good for a starting point and being able to override anything you want. :)
I agree that Iterators better encapsulate logic. But I would also think there is no additional logic to be encapsulated here, just the desire to stream the results. Even with the presence of generators I'm still using the Iterator interface when I also wanted to add some "decoration" to the result (ex: Decorator/Facade/Flyweight pattern) And indirectly, I've suggested generators since I think the PHP community doesn't use them enough. The more developers get exposure to it, the better it is for the general userbase. At least that's what I like to think :) 
&gt; You can currently extend EngineException which is renamed to Error by the RFC - and removing the ability to do so isn't mentioned in the RFC. Indeed, but I'm nervous when it's not mentioned explicitly in the RFC that it's allowed. I've been burned by this before (relying on an undocumented feature). The RFC says they reserve the right to implement errors differently than standard exceptions (while following the same interface).
I'd stick with the dev job. The experience of doing some real life work with constraints is valuable even if it doesn't always feel like it.
You could always ask for clarity on something you're concerned about the internals list. Alternatively you could look in the pull-request to see the actual details: [Fatal error: Class Failure cannot implement interface Throwable, extend Exception or Error instead in %s on line %d](https://github.com/trowski/php-src/blob/throwable-interface/Zend/tests/throwable_003.phpt) So it's only the 'Throwable' interface that can't be implemented in userland.
I signed up for the beta and went to link it to my GitHub profile but the access it's asking for is a bit crazy....read and write to all public and private repositories? No thanks. Full access to all personal data? Nope.gif.
Or a debugger built into PHP 5.6+... http://phpdbg.com/
Looks interesting, will this support BitBucket?
Will review the data we're asking, thanks for the feedback!
Yes, you can extend Error just like Exception to make your own Error classes. This point was debated, but I decided it made a lot of sense to allow users to throw Errors for exactly what @Danack posted above: errors that require a programmer to look at.
If you need to have permissions to do certain things in the future then I suggest running CMD as admin. I'll give you an example. I use homestead for my Laravel projects and when running my VM it will write the IP address to the hosts file. On Windows 8+ you need admin permission to do this. :)
Thank you, glad to hear people are happier with the new hierarchy! I spent a lot of time discussing the proposal and implementing the patch.
&gt; IIRC, new submissions targeting 7.0 were frozen. Anything already submitted could still make it in even if voting was still pending. Incorrect. Votes had to be opened by the official freeze date (March 15). The reason we voted on this and accepted it is that we all felt that we couldn't really release as-is without this sort of change. So we agreed to vote/accept this as a one-off because it was really needed, not just because it existed.
Would it not be better to have functions which return back values after generate is run instead of dumping into a results array: $captcha-&gt;getImageObject(); $captcha-&gt;getCaptchaWord(); $captcha-&gt;getSkippedCharOffset(); So your generate turns into returning a boolean instead of an array to say it has worked or not.
&gt; If you can avoid HTML and instead use, e.g. Markdown, I agree that it makes life much simpler. Do I need to start listing the situations where Markdown libraries fail to XSS? No matter how you do the [DSL] -&gt; [HTML] conversion, you'll still need a filtering library or function to clean things at the end. http://stackoverflow.com/questions/5266134/best-practice-for-allowing-markdown-in-python-while-preventing-xss-attacks/5359237#5359237 https://github.com/html5lib/html5lib-python/blob/master/html5lib/sanitizer.py [the link in the SO answer is dead, hence the second link] Yes, I'm aware its a python example but the point stands :P
Are we still looking at 32bit? *iirc* Hack isn't even provided for 32bit.
I love how the article goes from PHP GA to App Engine vulnerabilities in Java... But thanks for the news!
&gt; I'm glad the rules were broken a bit here in order to fix this. It was understood at least by some that the RFC that added this exception left room for renaming it, hence why it wasn't really a rule broken. I don't like either hierarchy and naming scheme so I didn't vote. "Hey, here are two bad options: pick one"… no thank you!
&gt; "Hey, here are two bad options: pick one"… no thank you! Eh come on, there's a precedent for this kind of naming (in fact... that literal naming and hierarchy): http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html Notice what it says: &gt; Instances of two subclasses [of Throwable], Error and Exception, are conventionally used to indicate that exceptional situations have occurred. And in the case of Java, this hierarchy didn't happen due to BC concerns. AFAIK, it was like this from the very start. And yet, the design looks so intentional in PHP, as if it was like this from PHP 1.0. Did... did I win you over? ;) Maybe not, but I just won myself over for a second time.
Happy to help! Also, give this a spin, I can't work on Windows without it: http://gooseberrycreative.com/cmder/
&gt; The proposed patch does not allow userland classes to implement the Throwable interface. Instead all classes declared in userland must extend one of the existing exception classes. Does anyone know the reason for this rule? It feels arbitrary and the RFC doesn't explain further.
None of that tells us the basic information we need to know about the programs mentioned in the infographic.
&gt; And the performance hit of parsing and rebuilding HTML on every page display as shown would be significant. Down that road lies madness. There's no reason to not store both the original content and the filtered content. This also allows for the filtered content to be updated as the filter rules change.
&gt; 'Sanitizing' and 'escaping' are the same type of operation from a security point-of-view - one removes the undesirable input, whereas the other converts it to a 'plain format' where the context-dependent meaning of the input is ignored (in the case of HTML, to escaped HTML). Just for saying this, I hope you don't deal with security, because it's absurd to say **input filtering &amp; validation** and **context-specific output encoding** are the same type of operation from a security point-of-view. - input filtering &amp; validation: aligns **input** to your **domain model**. - context-specific output encoding: converts your **domain model** to your **output**. I realize, that's two things! So much brain overheat, so much confuse, so many feels, *let's just do everything on output*! But no, actually once you know what your **domain model** is, you know whether to do an operation on input, or output. Doing everything on output means that your raw input is your domain model. Which is to say, you have no domain model at all. Which makes me sad about your spaghetti code. BTW, while we're in the pedantic train of thought, there's no such thing as "escaped HTML". There's text encoded as an HTML text node or an attribute value (and a few other contexts). [There is no escape](http://vignette4.wikia.nocookie.net/prettylittleliars/images/5/58/There-is-no-escape.jpg/revision/latest?cb=20150226201704).
You're awesome! BTW can you please say: 1. Will it be officially ok to implement Throwable in userland? 2. Will it be officially ok to extend Error in userland?
I found an interesting article which kind of goes with the theme of the comments in this thread: http://www.brandonsavage.net/the-case-for-maintainable-code/
[Nice try, zdnet guy :P](http://www.reddit.com/r/PHP/comments/3a252e/google_app_engine_for_php_generally_available_no/)
&gt; You're ignoring my points I have not ignored any of your points. We're discussing HTML filtering, you're saying that the "same input can have a different meaning in different output contexts". HTML by definition will have only one output context *as HTML*... and that's *HTML*. Your point refers to encoding, which is irrelevant here as we're not changing the encoding context (from HTML... to HTML). Or how about this one of your points: &gt; Do you understand what 'escaping' means? You're not escaping a format to another format - you're escaping a sequence to another sequence that doesn't trigger the special meaning in that context. "Trigger the special meaning" sounds like how a 5 year old may describe it. Escape sequence is a way of encoding a state change into a given format. Each state has its own vocabulary. What you want is the semantics of the input format to match the semantics of the output format by encoding the *input semantics* into the *output format vocabulary*. And that process isn't limited just to escaping, an escape is an implementation detail. I may be converting from one format with "special meanings" to another format with other "special meanings". Say like in here when I type \*\*foo\*\* it comes out bold: **foo**, see? The thingy became special! You're encoding. We're adults here, we can talk like adults. &gt; and just repeating what you already said (and what I already contradicted) You didn't contradict it, you just took my sarcastic questions and decided to be a parody of yourself by saying that, yes, you do store everything as raw input in your services (except passwords), in order to preserve invalid data. You did answer "Yes" to "You'd store invalid Unicode characters" after all. Which technically means storing everything as a bunch of byte arrays. Was I putting words in your mouth? No. I know you don't do this in "real life", because it's nonsense, but you're willing to say you do, only to remain consistent with your advice. Which is adorable. I did say it'd be hilarious and it was. Thank you.
That's the first I've heard of that format. Can look into supporting it in the future.
I would definitely start on a framework. I was determined for the longest time to not use a framework, but if you look at any PHP job it will require a framework (not saying you want a job in PHP, but this is a good indication of what you need to know). Also don't get too worried about which framework you learn. Every framework will have libraries, routes, a controller, a config file, a model / data layer, so the important thing is just to get started on one. &amp;nbsp; Personally, I would pick Laravel. The main reason for this, besides how popular it's become lately, is you can then sign up for [Laracasts](http://laracasts.com), whose lessons tend to require Laravel. Laracasts will teach you to be a great developer (how to use Vagrant, code patterns, unit tests, etc) and nothing can really match it since it's entirely PHP focused (and quite cheap!).
Throwable cannot be implemented in userland, but Error can be extended. Throwable is not implementable for a couple reasons: 1. A thrown object needs to carry a stack trace, which the engine builds and adds to the object when it is created. A userland class would not automatically have this functionality, so it makes more sense to extend an existing exception class. (This behavior could be changed in the future to allow implementing Throwable, but would require a drastic redesign of PHP's exception handling system and seems unnecessary). 2. By preventing userland implementing of Throwable, code can depend on all thrown objects either extending Exception or Error. If users could roll their own throwable classes, error handling would become more challenging.
I've explained this in a comment above: http://www.reddit.com/r/PHP/comments/3a4my5/throwable_interface_rfc_accepted_for_php_7/cs9vpy7
Check out PHP the Right Way (http://www.phptherightway.com/) next. Cheers! =C=
You should look at the library I'm working on, [Icicle](https://github.com/icicleio/Icicle). It uses promises to build coroutines that let you write async code without dealing with so many callbacks. I'm nearing the first release of the HTTP component that can be used to make HTTP requests and create and HTTP server.
I considered this too, but what happens when a thrown string bubbles up to the top? Where did it come from? Sounds like a potential debugging nightmare. Throwable needs to have some methods or the thrown object wouldn't be very useful. Building the stack trace isn't terribly expensive, especially in the big scheme of things. An app shouldn't be throwing exceptions so much that this really becomes a problem.
Learning a framework like Cake or Symfony will be useful. They are extremely powerful tools and are widely used. You may also want to review the php-fig PHP Standard Recommendations (PSRs) which have recently become very popular to inform how PHP projects ought to be built. Finally meet some of your fellow coders: there is very likely a PHP Users Group or Meetup in your area, plan on going to a couple of meetings and getting involved. Cheers!
Thanks. :)
I was a "hacker" when I was 13 or so, and one of the main resource websites I found focused almost exclusively on webappsec in php. I learned enough to get curious about making things instead of breaking them. Stared making really awful CLI apps and websites. Found codeignitor a little while later and got the idea to make a skinnier version of it, which meant I had to learn a lot of OOP stuff. Bailed on PHP for a few years after that and picked it back up fairly recently (March or so). Very pleasantly surprised at the level of improvement since my last exposure to PHP. Loving Laravel and Laracasts. 
Also [icicle](http://icicle.io/), but I haven't used either of them for production things (yet).
Cool. It is the format used by angularjs, ionic, and others. You can use it with commitizen too: http://commitizen.github.io/cz-cli/
Hi. I included support for text sitemaps now :)
Well, you'd certainly know better than I would! Thank you for clarifying. Knowing when to break the rules is half the battle, after all ;)
learn symfony if you want to have more freedom of choice, laravel if you want to develop faster but in a very opinionated way.
&gt; Difficulty: Biginner ಠ_ಠ
I find particularly funny when I see developers unit testing internal abstractions. Thus: public function a(){ if ($some &amp;&amp; $complex &amp;&amp; $evaluation) return true; } is refactored into public function a(){ if (significantName()) return true; } private function significantName(){ return $some &amp;&amp; $complex &amp;&amp; $evaluation; } but then, they circumvent private `significantName` with Reflection to test have it tested, instead of addressing the coverage through the public interface (in this case, `a()`).
The post recommends using the embedded Chrome (CEF) version. That way you'll know your app will look and behave the same on any computer, it doesn't matter what browsers or version you have already. Popcorn Time does essentially the same, except it's embedded Chrome+Javascript. From what I can tell it's becoming more common. IIRC the Atom editor too. Negative vibes in here..
Keep at it, youll be an expurt in no time!
Several comments are suggesting learning a popular php framework like symfony or laravel. I agree with that. One alternative I would offer is to learn the ins and outs of a popular php platform, namely wordpress. edit: like it or not, WP experience opens doors.
Look into a proper templating engine like Smarty, learn how to design webapplications the MVC way. Also learn OOP if you didn't already. 
Isn't guzzle overkill for anything other than writing API clients? It seems like a very heavy library when all you want to do is download a single file.
isn't that what I said?
Haven't tried their hosting, just the self-hosting. One thing I know for sure is that my raspberry pi is far too slow to run it (although this might partly be the fault of the wifi driver). :)
IMO, Laravel is quite nice. Pros: - Easy to use - it's VERY similar to rails since it used it for inspiration - good documentation - friendliest community that's ever helped me Cons: - Eloquent uses Active Record, which isn't good for unit testing - Not used in almost any corporate/enterprises yet, so if you are learning to get a job just learn Symfony instead Laracasts is great, though at times def went a bit over my head in the later sessions.
I always find it weird that they call passing objects to your method "dependency injection" like it's this crazy complex design pattern. It's like the first thing you learn how to do when you write a function, before you even learn about classes. You just pass stuff. I've always thought of DI as *automatic* DI. As in some mechanism is passing those objects in for you.
There's a bit of a subtle cognitive difference though: sure a method can take parameters, and sure those parameters can be objects sometimes, but the point is to remove any *dependencies* from the class and pass *those* as constructor arguments. The difference is generally between: function calc(Number x, Number y) { $calc = new Calculator(); return $calc-&gt;op(x, y); } and function calc(CalculatorInterface $calc, Number x, Number y) { return $calc-&gt;op(x, y); } obviously the example is contrived, but it shows the ideas that you should be internalizing when you hear *dependency injection* as opposed to just passing parameters.
&gt; Look into a proper templating engine like ~~Smarty~~ **Twig**, learn how to design webapplications the MVC way. there i fixed it
Note - I spoke there last year and am speaking there again. I enjoyed php[world] last year, which was it's first year. It was kind of a nice break from the norm of most PHP-specific conferences like SunshinePHP, php[tek], LonestarPHP, etc, with the entire point being to get the different communities within PHP talking. There were a variety of tracks for people to attend that were specific to frameworks/CMSes but you could float between them at will. It's put on by the same people as php[tek], and they know how to put on a good conference. The talks are usually pretty good, the food is excellent, and the after parties give everyone a chance to mingle and do things. There's not an emphasis on drinking (though drinks are provided, and Eli is a stickler for the beer selection) so it gives a chance for everyone to talk about the things they went to that day, catch up, network, and such without it being a huge drunk-fest. The venue is nice. It's in Tyson Corner right next to a small shopping outlet, and a short walk from the Silver line, so getting places is pretty easy. The hotel itself has a nice sitting area ringed by the main rooms where everyone congregates for the hallway track. If you work in any of the frameworks that are represented at [world], I think it's worthwhile to attend. You get a chance to talk to people off of your island and bounce ideas off of people you normally wouldn't. Last year I remember overhearing a conversation between Drupal and Wordpress devs about auto-updates and how to handle them, since that was a big thing Wordpress was pushing. There wasn't any turf wars going on and it really felt inclusive.
It always sounded like some sort of hacky exploit to me. We're taught "injection = bad" so I have a bit of a mental stigma against "dependency injection." There should be some simpler term for it. As you say, isn't providing objects instanced by other Classes as an argument to a Class just a standard part of object-oriented programming? I don't know why it needs to be called something as scary sounding as "dependency injection."
Because it's not at all about passing any old thing to any old function. It's about entirely removing the need for the method to create other objects it needs, and instead you provide that TO your object as a param... and in this way your code can function exactly the same EXCEPT that it also allows you to write tests for the methods and provide mock/fakey/dummy/whatever objects INSTEAD of what your actual program normally passes. This is why it's called "dependency" injection. The "injection" part is the least important word of the two. You are providing all the tools the methods "depend" on, so that you can swap them for something else when running unit tests. The difference is that if you have a class that retrieves shit from a database and then other classes use it to retrieve various data then if your various class methods THEMSELVES create an instance of your db object then that's locked-in stone, whereas if you pass as a parameter your db object to your various methods for those methods to use then you are able to also write a test for your methods that passes something that looks, tastes, smells, and behaves just like your actual db class except it IS NOT your actual db class and instead can be just returning fake data and not hitting your db at all. If you have a whole shit-load of tests that would all require hitting the database, or even modifying it, then that's horrific to test for if you all of your methods reach-out and instantiate their own instance of your ACTUAL db class, as opposed to you providing to those methods some object which may or may not be the actual db class or may or may not instead be your mocked-up class that behaves similarly but which just returns fake data. Sure, it means providing a few more params for every method call, and seems like a fuck-around. It is, but the trade-off is that you can write tests that pass mock objects instead of the legit objects your program actually uses. So, you get to completely engineer the expected return values from your mock objects and use those expected values to test your methods.
http://giphy.com/gifs/3oEdva8PnecPoI1ugM
No. Just... no. With all of the hassle there is with dealing with php + javascript + css + html just to create something user-friendly why the fuck would I choose to use all of that to make something that pretends to be a desktop app but which isn't? Fuck that. The time it takes me to get anywhere significant with web-based projects would take FAR less time to do in a language that compiles for the OS you are wanting to run your project on. No fucking-around trying to style shit just to get some damn button to sit in the right position. Just pick that fucker up in the IDE GUI and drop it pixel-perfect where you want it. Done. No fucking-around with AJAX to try and make your page respond fluidly to user actions without doing an entire page reload. Just find the right event handler and dump your code in it. No mental context switching as you switch languages back and forth. Nothing. Why would you use stuff that is intended to hackishly recreate a desktop app experience through sheer will and the sacrifice of sanity instead of actually creating a legit desktop app? This is the type of embarrassing nonsense that the PHP community cops shit about. This is the definition of doing things the hardest fucking way possible. This is just wrong, and encourages wrong behavior and thinking. If it's designed as an online app then upload the damn thing online and stop pretending to be a desktop app.
Does it auto route? Or do you have to add a route to the controller?
You can add routes in the index file just like in Laravel, the only thing missing in my routing system are route parameters, I'm still figuring it out. $app-&gt;get('/', function() { echo "Welcome!"; });
i know right, talk about clueless
There are also [alternatives](http://www.sitepoint.com/3-ways-develop-cross-platform-desktop-apps-php/) but none are *good* (including this one). It's all one big hack with caveats thrown in for good measure. Bottom line, if your app is so simple it can be made in this (single process, only internal data storage with SQLite, memory hog surroundings due to Chrome) then you'd be better off making it in a proper desktop oriented language - you'd finally have a good use case to learn it and it wouldn't take long.
Aren't magic methods much slower than calling normal methods?
&gt; People who ARE good at these things, have no trouble at all. That doesn't address the fact that it's as simple as picking-up an object and dropping it on your form in any GUI and it existing literally where you drop it, as opposed to having to fuck at ALL with css to do... anything. Or is there some Dreamweaver-like utility that I'm not aware of which will let you design a page with simple drag and drop and then let you build code off event handlers for everything? If you need to load a graphic for some object as it's background then press the button and load the image and it's now a part of the resources for the project. No fucking around trying to figure-out the correct tree-structure to drop your css and theme images into and then figuring-out how best to style it so it sits in the correct position. No matter how you look at it there's always going to be more work involved with attempting to recreate a desktop experience with something that is a web app. Web apps are, after all, nothing more than a very poor facsimile of a native application. &gt; I am interested in what languages you think, trivial desktop applications are produced in and why a PHP/Web developer would be compelled to use it. That's such an open ended question. Literally any language that compiles to a native exe, or provides native controls and a gui to design the window. If you are using a language intended to compile to some OS you'll usually find a plethora of objects you can drag and drop onto a form and then drop code into their event handlers. It's been a long time since I've written anything in Delphi, but I'd still choose that any day of the year over this threads PHP abomination. It's absurd to entertain the idea that bundling a web app which aims to emulate a desktop app into a package which itself then emulates a desktop app is somehow going to be anywhere near good enough or worth the time to waste on it. Upload the files and stop dressing up the web-app to be something it's not. I can't believe you would even ask the question. Why WOULD you choose to use this stuff to try and recreate the online experience instead of just writing an actual program that deals with regular system messages and events. You are just bundling all of this overhead for a far inferior experience that requires more time and effort to create.
You can't in Symfony 2.5. You need Symfony 2.7 where you can use the choice_attr option: https://github.com/symfony/symfony/pull/14050 Upgrading to 2.7 is easy and worth it, since 2.7 is an LTS release. Just be careful for deprecation warnings!
why are you hand selecting pages of things on the screen instead of writing to sql files
How heinous are the binary sizes? Still cool even if they are unreasonably big, just curious if anyone here has given it a crack (at work).
Laravel is a modern version of Codeigniter. You'd use it for websites, not much else. 
I'm not saying people won't find a use for this stuff. My fear is that they will. But it should be abundantly obvious that they SHOULDN'T. And as you demonstrated here this may be a shit solution to a shit situation because of dumb people. It's not a rational solution to any rational situation. I use php. PHPStorm is open right this very minute on my screen. I would say I almost like PHP and have few issues with it. But this "desktop application with PHP" concept where it is just packaging a web app into a browser+server combo exe is pretty fucking dumb IMO.
filmdc, it's possible check this out: https://code.google.com/p/phpdesktop/wiki/KnowledgeBase#Can_I_use_MySQL?
Use an API?
Facades are really just a bit of Laravel syntactic sugar that allows for you to resolve an object out of the IoC container and call a method on it. I have not benchmarked magic method performance but I have never noticed a significant increase in execution time from using them, but even if you do, every single Facade has a [documented class](http://laravel.com/docs/master/facades#facade-class-reference) that you can choose to inject if you wish. Laravel does not force you to use Facades at any point. 
And how much overhead is there with all of this? Are we now at a point where we just don't care about bloat in our programs and it's more important that we try to shoe-horn these languages into circumstances they were not designed at all for? If that's the case then let me know so I can update my stance on things like this because as far as I know it is still relevant. It's like things have swung the other direction from being razor sharp in asm, and now we are on the other end where we are packing a whole bunch of shit just to run a bit of php and js on something that's not the browser. This all seems inelegant and a regression.
Yes 
Was this written as a learning exercise and posted here for feedback? Or is it intended as something that people would use?
I agree that this has a lot of overhead that could be avoided, both in development time and processing power. But when you're making a simple, one-screen program for a tiny company's internal use, it doesn't really make a difference if the program takes 11 ms or 200 ms to open.
Its too much for a website, I think Laravel is appropriated for big web apps, don't get me wrong, but its just too much sugar for a simple website.
I'll just point out your template variables are actually the model. And the model doesn't conceptually belong to the page triad (it's a domain service). It's a very common mistake in web MVC interpretations. Your code isn't bad for it, just badly named. There is something bad, though. Your "registry" is just a reimplementation of global vars (try and mentally replace all instances of "$this-&gt;registry" with "global"... fits). Explaining how to avoid this is a long topic, but you can start with reading about dependency injection (not *containers*, just the pattern itself).
Agree, testing private methods using reflection is probably the worst thing you can do for coupling your tests with production code. Refactoring leave the tests green, all the behaviour is still tested, so why would you wan't to change the tests? If you do, you risk coupling your tests. Some might disagree but in my opinion that applies when extracting into a class as well. As we extract into private methods that are not tested directly, why would extracting into private classes be any different?
Hi, Why did you copied all the files to vendor folder. * Use composer.json and add move dependencies to it. * the code of https://github.com/Alewex/Luna/tree/master/vendor/Luna can be moved to a different folder * I don't know why you kept Routing, Core etc in https://github.com/Alewex/Luna/tree/master/vendor/Luna/Services . It seems to me it can be in `Luna\Router` , `Luna\Core` etc. * May be the `Core\Route` can also be moved to routing. I can write more, but yes that may be my preferences . Good work! Keep moving. Thank you
&gt; You have a piece of HTML. How many meanings can it have aside from "HTML"? You're confusing input validation to output encoding here. This HTML won't be encoded for HTML output. It's already HTML. The same input can be used there in the literal meaning (HTML markup, filtered before output) or encoded (htmlspecialchars before the output). What /u/joepie91 and /u/sarciszewski said, is that in the case there is supposed to be HTML markup in the blob, you shouldn't filter until the time of output. Filtering here means the operations HTML Purifier does for the blob. With such, say comments, which are allowed to contain HTML markup, you accept the input if it is in valid length range (say, 1-x) and in addition to that, I'd too in general, allow only valid byte sequences (valid UTF-8, otherwise alert user with an error and exit). I find your comments about passwords, numbers, booleans and such not related to this topic, as such specific inputs needs to be handled accordingly, but here we are talking about "generic text blobs" such as comments (one wouldn't handle integer param or passwords with HTML Purifier). In general, when dealing with this kinds of generic text blobs and web pages, you validate the input and filter the output (in case HTML formatting needs to be reserved), or you validate the input and encode the output (input must not contain markup in the HTML document). At least that's my stance on it. Filtering on input (as you wrote, like trimming whitespaces) may be something many do, but there is the problem with data loss, and indeed I'd consider it to be more suitable to do on the client side. While ensuring valid UTF-8 can be done by "filtering" (iconv() for example), it can also be straight away rejected (mb_check_encoding) and thus no need to filter. JFYI, comments like &gt; "Trigger the special meaning" sounds like how a 5 year old may describe it. and &gt; Just for saying this, I hope you don't deal with security.. doesn't really contribute anything to the discussion (otherwise this is a good conversation, we should keep it as such and on topic).
I was happy to see it in new hands and actually being worked on. I never said I don't use Laravel or Symfony. They are just other tools in the tool belt. Get your neck beards out of knots. For me, Code Igniter is what got me going in frameworks about 4 years ago. Nobody was even talking about Laravel yet.
Laravel was only just released 4 years ago, it's now the most popular alongside symfony.
&gt; The same input can be used there in the literal meaning (HTML markup, filtered before output) or encoded (htmlspecialchars before the output). We have to get past this kind of descriptions because it's the reason for all those "mistaken context" security errors we see in software these days. There's no such thing as "literal meaning". Nothing is literal, everything represents a symbolic encoding which should be interpreted in its context. A piece of plain text encoded as UTF-8 isn't its literal meaning. It's literal meaning is a sequence of bits which is Unicode text only by means of seeing it in the context of a specific format encoding (UTF8). As such, when you prepare a piece of data for output, you convert your current (domain) encoding to a new (output) encoding. The "escaping literal data to not trigger special meaning" mindset is what brought us magic quotes and other horrors of programming. So the options are: 1. You can treat your data as HTML (for placing it in HTML, charset encoding may be required, but otherwise HTML is HTML). 2. You can treat your data as text (for placing it in HTML, must be encoded as a text node or attribute in the given HTML context). You wouldn't treat a piece of HTML as text, unless you're specifically rendering a code listing. So talking about this is just a diversion from the topic at hand: filtering that HTML for XSS attacks. I'm kind of nitpicking our mental model but not just for the giggles, but because it's really crucial for certain choices done in the software pipeline when time comes to implement all this. I do facepalm (in real life) every time someone starts talking about "sanitization" and "escaping" and gets confused what's validation, conversion and encoding. &gt; JFYI, comments like [...] and [...] doesn't really contribute anything to the discussion (otherwise this is a good conversation, we should keep it as such and on topic). I know what you're saying, but you have no idea how much I want to shoot back with a "your mom" joke right now. Just kidding. But to address your point, it's really hard to take serious a person who says he stores everything with the untrimmed whitespace and Unicode errors, because we should "never, ever, ever" filter and interpret on input, but only on output. It's bullshit, and when a certain threshold of bullshit is crossed, I do switch to bullshit mode myself.
Twig is basically a more polished and refined Smarty. 
I used [Nightrain](https://github.com/naetech/nightrain) on a project recently and was really happy with it. Tie it together with a flat file database and your'e good to go with an executable site that you can run from a USB stick.
Who is still die()ing? Xdebug is the way to go :D
haven't used hack, anyone has impressions?
I am hoping this to be fixed now they have a LTS version
I believe the best captcha-s are the ones with pictures where you have to drag and drop certain picture. Or even align them in certain order. Weakness in this were already pointed out by others.
From my experience, the following conferences, while they have open bars, generally don't focus on drinking as the main event for the evening. Almost all of them couple it with something else: * SunshinePHP * MidwestPHP * LonestarPHP * php[tek] * ZendCon * php[world] * TrueNorth * MadisonPHP Conference That's not an all-inclusive list obviously, just the ones that I've attended.
Not exactly PHP, but a must read: the pragmatic programmer.
Yes: https://github.com/facebook/hhvm/tree/master/hphp/hack
I think you missed the point. JS wasn't designed to run server side code. And in GTK, PHP is used no differently than on a website, just without the HTTP requests.
That's a bit of a double standard, isn't it. Where are the "PHP tooling APIs"? It doesn't have any.
Has anyone dug into the different PHP REPL's? PHPepl, PsySH, and Boris seem to be the biggest. Anyone tried all three?
Hack exists because Facebook had a ton of PHP code, a monolithic architecture (not as much as of last 2-3 years, but previously) and they didn't like where PHP is going. It's basically their insurance they have their fate in their hands. As a third party developer, relying on Hack has the opposite result: your fate is in Facebook's hands. It has a quite more fleshed out type system, but with PHP7 the gap is starting to close in many important areas. And if you don't drive yourself in a corner like Facebook did years ago, you can also introduce other languages in your app as microservices you can connect to from PHP. **tl;dr** It has nice things, but it's strategically dangerous &amp; the benefits are not substantial (anymore). I wouldn't.
If debugging worked as fluidly with PHPUnit as it does with JUnit then by all means I will stop using `die`, in the mean time, I will coordinate the usage of both where needed.
Use a paid 3rd party service like Travis CI or CircleCI instead of Jenkins.
I wrote a blog post recently about setting up and using Jenkins for PHP projects - http://www.reddit.com/r/PHP/comments/333z9p/setup_jenkins_and_test_a_php_project/
Hey, The Resources folder inside https://github.com/Alewex/Luna/tree/master/vendor/Luna is a default folder to store sample controllers, views, etc. You can change the location of the resources folder by adding a line in the index file. ```$resource-&gt;path('resources/');``` * I'm still taking a look at Composer's documentation, although I want to keep it as simple as possible. * I don't know what you mean by moving the framework to a different folder, to a libs folder perhaps? * I might move all the files in https://github.com/Alewex/Luna/tree/master/vendor/Luna/Resources to a resources folder outside Luna to keep it cleaner. * Done! Thanks for the feedback!
To quote myself from my first comment: &gt; Explaining how to avoid this is a long topic, but you can start with reading about dependency injection (not containers, just the pattern itself). Read about dependency injection and if you have questions let me know. Also read about: 1. Abstract factories. 2. Interface segregation. 3. The "Encapsulated Context" pattern.
Definitely going to take a look at these. Thanks!
For now I'm using FluentPDO to work with SQL queries. Didn't think of a templating engine before, so I'm going to take a look at Mustache. Thanks!
Most developers have about as much control on PHP as they have on Hack (i.e. very very little).
I don't have to explain the RFC voting process controlling PHP, I hope, but in short - you're wrong.
I don't get to vote on RFCs, like most developers. That's what I meant by I have very very little control. I just hope the majority of internals makes the best decisions (not always the case), just like I can hope Facebook's Hack team makes the best decisions for Hack.
Anyone, including you, can propose RFCs and patches. If you propose RFCs and patches regularly, you'll be able to vote. You're complaining that you can't take an active role in the process... because you're inactive. The trajectory Hack and HHVM are following shows they're narrowly following Facebook's interests, and many not that well designed features are haphazardly added into the language, sort of like how PHP was back in its early years. &gt; I can hope Facebook's Hack team makes the best decisions for Hack. No, Facebook's Hack team makes the best decisions for Facebook. I'm not saying they shouldn't, it's their project, their rules. It's generous enough that they have opened the source at all. But don't fool yourself. Facebook cares about your interests as a Hack user even less than it cares for its social network users.
Lets not throw around absolutes like they are candy. Laravel may very well be more opinionated. To say its not, is just your opinion :p
seriously. how the fuck do you get anything done?
xdebug has been proven to add huge slowdowns with code, thats definitely xdebugs problem. I really dont run into big enough problems for the use of xdebug that often. A simple die gets the job done in the same, if not less time, with no code slow down.
This really isn't the place for these types of questions ... maybe http://www.reddit.com/r/webdev
&gt; All over laravel I see static classes, and from what I have read it uses Service Location which is an anti-pattern. Good folks of /r/php do you think Laravel is a good PHP framework? The reality distortion field you'll experience as Laravel fans explain away these static classes is amazing. Grab popcorn and enjoy the show. But yes, in short, it's a bad idea. You can simply not use them (although the manual keeps telling you to), but you're still stuck with an app-global dependency container, which is almost as bad. The right way to use Laravel and other frameworks, IMHO, is to use it power a thin web client, while keeping the bulk of your application (logic, models etc.) framework-independent in the form of services (as simple classes).
&gt; I'm sure someone will correct me and **I don't claim to fully understand it, but I'm fairly certain that the criticism on Laravel having static classes everywhere is wrong**. Yeah that's a fairly standard attitude for a Laravel fan: "I don't get it, but I'm certain criticism of Laravel is wrong". Here, get your Larabadge.
Have a look at session, header redirect, and mysql.
I'm working under someone right now, and he doesn't want a database for the passwords. He wants "a simple way."
You could save the data as json to a textfile for each users.
Hahaha. By not using a database this will be the opposite of simple if you plan to build this out to do lots of things. Sure you could make the passwords sit in a JSON object in a file somewhere but then what about storing user specific data that they will then see? You can't avoid having a database here really mate.
Many duck
I'm the engineer working on Hack that has been in contact with JetBrains. We on the team were really sorry to hear that they were dropping plans to support it in the next version of PhpStorm. I'm more than happy to help them or anyone else who wants to look into adding Hack support to PhpStorm or any other IDE. For folks looking for another IDE to use with Hack, there's a (currently somewhat short) [list on our wiki](https://github.com/facebook/hhvm/wiki/Hack-Editor-Plugins) of plugins maintained both by Facebook and by community members. And, of course, the upcoming [Nuclide](http://nuclide.io/), as JetBrains said.
What is... the most misused mantra in all of software development? I'll take Haterade for 1000, Alex.
Dumb like a fox. I mean, Docker is basically the same exact premise in different clothing, and you'd be burned at the stake for saying these kinds of things about that. Even your browser itself is using the same premise. It's practically a VM these days. Don't be so quick to dismiss PHP as a platform. The arguments against it are all completely superficial at this point. They boil down to "it feels weird" rather than anything substantial or objectively and demonstrably inferior.
Well when you're stuck using a shit language its nice to have some convenience. 
Is this for training/learning/demonstration/actually homework?
"All I really did was google "how to do x in *insert language here*" and copied code from the results." sums up my college education and internship experience.
Yea, I'm not very happy with it. Since I made this post, I've reached out a few times as we're getting file permission errors on the hosted version. Response times for issues are horrible, and there's no ticketing system for paid customers. For $20/month it was worth it for me to support the development and not have to deal with these issues. At this rate, I'm spending more time following up with support than it would have taken to spin up a VM and install it myself. :(
This is something my boss wants to do so we can demonstrate what our service will look like. Also learning for me cause I want to learn how to create a secure user registration system using mysql and php.
What are you talking about, this is the perfect place to ask this kind of question. I'm really confused what some people think the point of having a programming subreddit is for. He's asking if he can solve a problem, programmatically in PHP, in a PHP subreddit. What should we be doing here? Selling purple elephants?
Laravel seems like a modern replacement for CodeIgniter. Great for getting started but frustrating if you want to do things therightway. The facades feature (which is a misleading name) is an 'everything everywhere' convention no different to $this in CodeIgniter providing access to anything in the app. It can be avoided, but it's still teaching beginners bad habits. 
Such go
I'm only refuting the statement I quoted. I don't disagree with the idea that it's difficult for most developers to have any control over a product's direction (be it PHP, Hack, or others). But your argument is presented as "I haven't taken any action, so that's why I can't do anything", as /u/idiot-with-opinion also expressed. We might even share your opinions, but not how they've been portrayed here so far. That and I *hate* people who make that excuse for why they don't vote for politics, so I felt compelled to reply. :)
Well he wants to get something that people can use now. Meaning, he's going to show it to people and try to get them to buy it while I work on trying to make a better system.
&gt; The most important feature of Hack, its instant-feedback static analysis tool, isn't available for PHP7. […] with PHP, you still won't get errors until you actually run your code. I find Hack amazing, though on this point a serious IDE (PhpStorm) + type-hinting + a lot of phpdoc comes close to it (I didn't say "identical" :) ). PhpStorm's static analyzer is very good because it interprets phpdoc on the same level as actual PHP code, and that allows us to simulate a stricter kind of PHP (e.g. we get a lot of warnings and errors in IDE, without running code). Of course at the expense of writing a lot of phpdoc (this will improve a little in PHP 7 with scalar type-hints), and without support for advanced stuff like generics, shapes, etc… But I've come so used to this static analyzer being great already that what I find most interesting in Hack is the "official" (as in, not simulated with phpdoc) support for stricter typing (generics, shapes, property types, type aliasing…) rather than the static analysis tool itself. TL/DR: - PHP: - IDE: strict typing with static analysis (PhpStorm) - runtime : loose typing - Hack: - IDE: strict typing with static analysis - runtime: strict typing (please note when I say "strict typing" it's a big simplification, let's ignore the details) So what I mean is: the big difference isn't on the IDE part but rather on the runtime part. (at least IMO)
omg, the most expressive follow up ever. too funny. where are those scenes from?
Yeah, absolutely -- the type inference stuff PhpStorm does is quite impressive. It just doesn't do the full generality of the Hack type system, generics in particular (which are quite tricky to infer correctly) and a bunch of other small odds and ends. 80/20 rule kind of thing :). And as you mention, it also doesn't do any sort of runtime verification, since it's just in the IDE, which the Hack team has found to be surprisingly important: every time we've had holes in HHVM's runtime enforcement, we've ended up with large bodies of self-consistent lies.
I have a [run-php](https://github.com/websiteduck/Run-PHP-Code) folder on my devbox, it's great for simple stuff but also for a bit more complex stuff
I'm just using this to get experience I can put on my resume. I'm currently go to college and taking any computer course I can get my hands on. I want to work with security/monitoring servers/some database, but I'm not too sure how to get a job with no experience. I met him cause he's my roommates dad's friend.
Looks cool! I was looking for such a Slack team before but didn't find any of interest at [chitchats.co](http://www.chitchats.co). I think I might join. Thanks for the post.
Meh. It's not.
&gt; Well when you're stuck using a shit language its nice to have some convenience. That's such an irrelevant remark I feel this applies: https://www.youtube.com/watch?v=C3JzbWVDzac
I'm so nice and constructive in this thread already, I bring shame to my nickname.
Installing a database server and configuring php, be it mysql, mssql, or postgresql, takes literally 10 minutes. A database schema to do what you described would take two hours maybe to sketch out and refine. There is no reason not to use a db for this project. And your boss needs to learn the difference between a tech demo and a shipping product.
That's a good idea and really well realized! I have a bit of feedback: having "tests" for patterns is probably not that useful. In fact, I outright think it's just adding noise to each page. I think that effort could go into having a more detailed description and example of uses (in plain English) as it applies to typical PHP applications. The code examples could be shorter and sweeter as not to overwhelm people new to them. - For example about "needs more description" I think it'll help people put things in context if the Facade pattern says things like "a way to expose third party dependencies from Packagist (and elsewhere) in your app without high coupling; so you can port easier to the next version or another library if the first one gets abandoned" etc. - And for example on "shorter code examples", aside from removing tests, I think the Decorator example could go without an abstract class implementing just the constructor (instead that should be just the Decorator class with both the constructor and renderData() implementation). And the Multiton, as another example, has __clone, __sleep and __wakeup so it can't be serialized and cloned, which... just feels like a random concern to have about a multiton.
I think it's Tim &amp; Eric.
I was under the impression that the main issue with service location pattern was that it's abstracted away a classes dependencies making room for runtime errors in compiled languages. Since php isn't compiled, less of an issue here? Not sure....
Typically it'd be the constructor, not a setter, so more like: $a = new A($b); The objects can still be moving from the root of your application, but the point is to avoid your components referring to that root. They should just see their dependencies, not the registry itself. For more complex modules that have lots of dependencies, I use the encapsulated context pattern, which a fancy factory interface A defines for itself: interface DependenciesOfA { function getB1() function getB2() function getB3() ... } class A { function __construct (DependenciesOfA $depsFactory) {} } The important thing is that DependenciesOfA is defined where A is, it's not defined elsewhere and mixing in dependencies for other components, like a registry would. Now A only depends on its own DependenciesOfA interface for grabbing the B1, B2, B3, which is more decoupled than registry.
&gt; Do you even know that Hack is open source, and it's hosted on Github? Yes, and I even said it earlier in this same thread. &gt; In a few years people won't even think of Hack as being a Facebook project, in the same way we don't think about memcached being a LiveJournal project. Ok, Nostradamus. Or it might end as the original HipHop by Facebook - obsoleted and abandoned. &gt; Tens of thousands of developers rely on technology incubated at Facebook. I judge Hack on its own. The halo effect produced by Facebook's popular JavaScript toys means nothing about the strategical viability of depending on a complex C++ ecosystem like Hack and HHVM. Take React, which is your implicit reference. React is simple enough that: - If it goes stale, I can just fork it and maintain by myself. - There aren't any serious vulnerabilities that can crop up in a client-side UI library. - It's relatively isolated from the core of my app. Now try saying this about Hack &amp; HHVM. Not the same at all, is it? &gt; I would happily argue the opposite. No need, I think the consequences of following your convictions would be more amusing than any argument.
Yup, that's the response I expected, but I thought I would try anyway. Nothing was accomplished here, but if it makes you feel any better but you sounded really smart. You can pat yourself on the back for that.
Thank you. Your subtle sarcasm flies over my head and brings a glimmer of hope into my shallow &amp; empty existence.
Even though the tests aren't very relevant, I like them because it shows some interesting ways people use PHPUnit in the wild.
I'm actually new to reddit so sorry for 'bad comment quality'!
It's all ok, I was just kidding around. FWIW, I don't think downvoting you was deserved.
I would go to every page, try every functionality on every page. And document and create a wireframe of all the pages, and what each page is supposed to do and look like. I would focus and identify the smallest part or page of the site, and just focus on that. Keep your focus tiny, on one small aspect of the site at a time. So that you will gradually learn the methodology to the madness, and gradually write cleaner, more commented, more organized code. But it really helps to start small rather than facing a mountainous challenge.
TDD might help in not introducing any new bugs. Static code analysis could also be helpful in improving the codebase by showing you where the biggest problems are (large files, high cyclomatic complexity, general code smell). I wish you the best of luck!
[/u/pmjones](http://www.reddit.com/user/pmjones) won't mind me recommending [Modernizing Legacy Applications In PHP](https://leanpub.com/mlaphp). It is an excellent read even if you don't follow it cover-to-cover.
Changing every thing just puts you in trouble, since most users wouldn't understand performance and just want to stay in their own 'happy' place! Maybe you first want to read every class and function and document everything, it would help you. And since it's PHP and no functions will ever be deprecated, you can still use a lot of it. Don't do anything to the front-end if it's an old website, you absolutely don't want to mess with users. Try to reduce class numbers, add some structure to them. As for the database, if it's mysql, after a certain amount of data it would really slow down. So try to reduce similar columns and add tables instead of them, connecting rows with a key. It would really help. Try to reduce the amount of code. If a data is just going to be passed to a function, no need to save it into a variable. Try to make a class that would control every thing if you feel you're getting lost. Do not forget to make that documentation, and write every thing in it. It's time consuming, but it's better than remove some functionality.
There's a project I've worked up to help make user management a bit simpler, [Gatekeeper](http://gatekeeperphp.com), and it now includes an "examples/" directory with a simple login form. It sounds like you need more than just a login form as you state that they "can only effect their own column" values. Gatekeeper also provides simple role-based (permissions) access control too, so it might be something to check out.
I though that was the purpose of including them, its basically saying "here is a design pattern, and here is how you can test it"
I checked the three: I didn't like PHPepl. Boris is good. It's more popular than PsySH but less active. In the end I prefer PsySH but it really comes down to personal preference.
I would really start with the database. Try to get an understanding of the data and how it relates to the business use cases. Once you understand what the thing is supposed to be doing you can start small. One function, one feature, one page. Refactor/rewrite and make writing unit tests and running unit testing a requirement for all new code. It will take time to understand this beast but once you do you can safely nuke from orbit one piece at a time. 
For the first question I would recommend Laravel. Simple to setup and has user auth almost out of the box. For more info see this in the docs: http://laravel.com/docs/5.0/authentication For the database, I would assume the words table has an auto increment ID column. Create a lookup table with columns for the user ID, the word ID and the word number or rank (1 to 10). A one to many relationship from user to words. One to one for (userID + wordID) to rank. 100k+ rows in a table is not overly large. With proper indexing is should be able to handle CRUD quickly. 
I noticed some problems with some fo your implementations. For example your proxy pattern example relies on extension which is not correct: http://designpatternsphp.readthedocs.org/en/latest/Structural/Proxy/README.html It should be handled in the same way as the Decorator example, with interfaces and actually proxying method calls. Using *parent::__set($name, $value)* is not the Proxy pattern. In fact you are introducing tight coupling by extending which makes you proxy not reusable. Check out the UML diagram on the wiki page: https://en.wikipedia.org/?title=Proxy_pattern 
if done such things a lot i am no fan of refactoring if the original code is far away from what you do nowadays best aproach then by my experience is breaking down the site into microservices, and creating those microsevices from scratch, it has the big benefit that you can do it step by step and not at once.
Needs more Java! function calc(DeveloperFactoryInterface $devFactory, ProgrammingLanguageFactoryBuilder $codeFactory Number $x, Number $y) { $language = $codeFactory-&gt;language('PHP')-&gt;expertise(1, 6)-&gt;build(); $sucker = $devFactory-&gt;create($language, 'John'); $sucker-&gt;placeEmail('Okay, I've got a great idea, I just need a partner to help with the implementation. You'll be paid in exposure and a share of the profits once we hit it big!'); }
This is dangerous when you're not familiar with what the application is supposed to be doing. Chances are you'll miss a lot of edge cases and functionality if you take that route. I'd try to break down individual features and update them to something sane one by one.
Simply put: divide and conquer. Your worst enemy in legacy code is entangled shared state. You need to start splitting the app into pieces that communicate through minimal, well defined interfaces, and share no state. Both vertically and horizontally (if unsure what I mean here, ask). It doesn't matter how messy they remain inside. Split it in two enough times, now you have many isolated pieces of mess instead of one giant mess. And you can refactor small pieces of mess, one by one, while keeping the communication interface stable. I wish I could be more specific, but that depends not on the language as much, but your specific codebase.
Bookmarked. This is a fantastic resource.
Hi p-barker. Thank you so much for your advice. Laravel did pop up in my research, I just wasn't sure what it was capable of, and whether it was worth the time of learning it. Thank you so much for linking to the relevant documentation. Now I am confident that it was worth some serious time learning! :) The database words table does indeed have an auto increment ID column. I am relatively new to database design. (maybe it showed). But I think I follow the logic here. I will experiment with lookup tables, and relationships then hopefully I will be confident enough to implement your solution. Again, my sincere thanks!
Ah ok
Cool, good to hear. Is that already available in the EAP version?
I've heard really pretty things about http://appserver.io/[1] , but its integrated components seem too involved at this point. I'd like to write code that as much as possible doesn't rely on their modules but mine
I still don't see how this offers me something XDebug doesn't. Evaluate expression / console work just fine for me in PHPStorm via XDebug, even on the last line of execution. Seeing as there's no context to inspect after execution is over, what do you mean by "once the endpoint has been reached"?
Take a look at [Doctrine](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/#)
Maybe... 
When the page is not fully loaded the snippet appears white on mobile devices. I just checked it on my phone.
uh oh, VB? you mean VB.NET or VB6? :O
:) Does you have use Phalcon PHP
The last reservation system I worked with was ROS2000 by Digital Rez. I *believe* it was built in VB6. It's been too long to remember, though.
I may be downvoted to hell for recommending this, but I've actually had pretty good luck with building large sites like this on ExpressionEngine. It's based on the old CodeIgniter framework and has a pretty good collection of third-party add-ons that are well tested. EE stores pages as templates in the database or you can save them as files. If you want static content you just paste it into the templates, otherwise you can create channels to store one or more content types. Basically think of it as a custom post type in Wordpress. You define all the fields, then make one or more channel entries. You then drop loop code into your templates to output and format those entries. You can mix and match just about anything. For permissions you can create custom groups and define access on a template-by-template basis. Templates can also be saved as versions in the database to easily go back after a screw-up by one of your editors. I've also heard from fellow devs having good results with the following, but I haven't used them: Craft (https://buildwithcraft.com/) ProcessWire (https://processwire.com/) Bolt (https://bolt.cm/) Definitely see what others are using though, and in a crunch you can always roll your own in Laravel.
On the contrary. Code becomes complex to understand as you increase the scope of "things to analyze at once" in your head. If you need to keep your entire application in mind the entire time in order to work with it, at some point you hit a limit and code starts looks like "legacy code" - some kind of mess where you don't know when you change something what you break. The secret of easy to understand is reduced scope. You want to reduce scope by keeping your app small, and this works to a point. But another way, which scales better for large apps, is to split your app in well-defined components, each with its own scope. Every component is self-sufficient, and has easy to locate and identify points of input and points of output. And one important case of this is where the component gets its dependencies from. If a component just declares "I need A, B, C, my creator should give them to me", as you work on the component you don't have to think where they come from and how they're named *elsewhere* in the app. You can continue to think only about the component. But if you embed knowledge about your registry into that component, now you have to also think about the registry when you think about the component. And when you need to change the registry to accommodate a change, like, say, rename the database property because you'll now have two databases, your component needs to change too, and you need to replace those references throughout your entire codebase. This promotes code which is less reusable (because it's tightly coupled to what's in the registry - you can't drop it in another app without either replicating the same registry setup, or changing the component code), and promotes code with a large "scope", i.e. you need to think about more things at once, as they're wired together and depend on each other.
+1. Reiterating what he said: If you don't do this you're stuck with php4 practices for eternity since your client won't want to do a rehaul after a rehaul. 
Take a look at the [Google Identity Toolkit](https://developers.google.com/identity/toolkit/). It will handle sign in for your web site. Users can use their Google, Facebook, Yahoo, PayPal, etc id.
&gt; How do you deal with relationships? That's exactly the task of the Object Mapper. Think about you example of a blog post. The blog post in the database contains the posts information. Comments are stored in the comments table which probably has a foreign key to the posts. The task of your object mapper is to translate this foreign key constraint into - for example here - an object composition. A post object would have an array of comments. It would be the data mappers task to fill this array when the post is loaded. Where do you keep the query? Keep it in the object mapper or extract it into a repository if you need it elsewhere. &gt; Also would I need a interface for each mapper so I can easily test with an array mapper instead of database? Give the object mapper a database-connection object per dependency injection. Then you could mock the db-connection your object mapper users in your tests. But seriously use a library. &gt; When do I need a mapper or repository? I am just lost and want to get it right. Unless you implement you own ORM you don't need to build a mapper by yourself. Libraries like Doctrine do that job for you. As I already wrote the object mapper deals with the necessities to translate you object model into rows or documents in your database. Repositories on the other hand represent the object relations. As a simple example: If you wanted to show all comments for posts in a certain category you would put that query into a repository. Repositories are hard. In my experience they either end up as huge overblown classes which have a method for every query imaginable or they do basically nothing **except** providing a *findBy* method and could easily be replaced by a number of functions because they just abstract complex queries that are only useful in one or two rare special cases. Also I noticed, that repositories can become bottlenecks, as you can easily forget that they can hide complex queries. As the application runs and more data is added this can become a problem. 
I believe there are two approaches, based on my understanding of DDD: A. Create separate repositories for each entity, with the ability to load them based on the related entity. Example: $blog = $blogRepo-&gt;findById($blogId); $blogPosts = $postRepo-&gt;getPostsByBlog($blog); //alternatively $blogPosts = $postRepo-&gt;getPostsByBlogId($blogId); B. Allow your repository to (optionally?) load related entities: $blogWithPosts = $blogRepo-&gt;includePosts()-&gt;includePostComments()-&gt;findById($blogId); Keep in mind that tags seem more like **Value Objects** as opposed to **Entities**, and as such they might not need their own repository even if they have their own database table.
The diagram in this example is possibly a bit misleading - you don't need to have separate mapper objects for every table. It's ok to have one mapper for several connected tables. So this is where you can deal with relationships. Your mapper will need to be given some configuration: the names of your tables, how do you want to refer to them, what class you want to hydrate them as (in case you use objects, I often stick to arrays at the mapper level, though), and what relationships are defined. For example you can enter "User", "Posts", and enter relationship "one-to-many" from "User.id" to "Posts.userId". When you select a user, I'd strongly suggest you're explicit in your mapper call if you want the relationship fetched and what filters you want on it (which will render to WHERE, LIMIT, ORDER, HAVING, GROUPBY clauses). Always fetching lazily (i.e. never on first go) or eagerly (fetching everything every time) may seem like you save a few keystrokes when doing a mapper query, but it's more headache and pain than you can imagine down the road. Let the mapper map, but tell it exactly what you need, don't make it second-guess you. As for mapper or repository. A mapper is a design pattern. A repository is a DDD component which *may be implemented via that pattern*. So it's the same thing, in a nutshell.
I have in my other comment in the thread. But I'm not looking for a big argument, Laravel arguments are tiring.
I disagree with the API signature of the DataMapper. A DataMapper is not a poor-man's repository - it shouldn't have methods like `findByID()` and `findAll()`. It's *SOLE* purpose is to prepare data for insertion into the data store abstraction layer, and to prepare data taken from a data store abstraction layer for a factory to construct the object out of. The DataMapper shouldn't even be responsible for `new`ing up an object - that should be handled by a factory that the DataMapper uses. Thus a Repository would wrap a DAL to fetch raw data, feed it into a Mapper, which feeds it to a Factory, which then returns the properly constructed object. The Repository can then optionally cache the object for cloning. To persist, the Repository would take an existing fully formed object, update its cache if applicable, pass the object to the DataMapper for deconstruction, and then pass that deconstructed data to the DAL for persistence (or the DataMapper could do that directly, not really important). 
The problem isn't the execution time, but the fact you reach out to a global static location in order to fetch your dependency. This means if you have two components that need to be fed differently configured views, you can't: they'll both reach out to View:: and get the same view. You can change it, but **not independently for each component**. You can only change it globally for both components. If that doesn't start any alarms in your head yet, it will over time.
&gt; I wasn't defending anything. I was just stating how it works, or how I think it works. They aren't actually static classes, which is a fact. Does it have some of the downfalls of static classes? Sure. But they aren't static classes. They are **static classes**. Static classes that proxy other classes. It doesn't make them not static just because they proxy. Here, I went into a bit more detail here: https://www.reddit.com/r/PHP/comments/3a8jge/opinions_on_laravel/csc0vja
Choosing the framework/tools for a project can be daunting. Laravel has a small learning curve, a large developer community and tons of docs. For the database, keep it simple. Just map the tables and how the data relates before building the tables. If you have any further questions just give a shout here. 
Is it just me who cracks up when they see a GitHub repo with 1-2 small classes, but all package attributes: full PHPDoc comments, tests, travis integration, readme and so on. Just the fluff is several times the code itself. Maybe it's just me.
The site says it's focus is on Ruby and I couldn't find any php engines. Is this related to php at all?
Wow, I must be blind.
Wouldn't this be more beneficial once SDN picks up? I'm just trying to figure out why someone would use it is all, not trying to bring down the code or anything.
Why? You can easily load folders or retrieve services. To me it seems an "eval box" is far more limited in both functionalities and usability. Or maybe it's just me that don't see how your eval box really works.
You should technically head over to /r/phphelp - but while you're here it would help to know what error you are getting.
At a second look-through I'd start with: $dbc = mysqli_connect('localhost', 'aliendatabase') or die ('Error this has not connected'); Should be in this format: $dbc = mysqli_connect('localhost', 'username', 'password', 'aliendatabase') or die ('Error this has not connected'); Edit: Left out a quote.. 
But i have no username and password. But I updated the code like you said and it wont connect so i think thats not the problem. i get the message "error with database" so obviously something to do with the query bit or mysqli_query bit but i dont know which bit
You should have a username and password. It's the credentials for your database. Try using the following details, to see if it works: Username: 'root' Password: '' If that doesn't work you could try opening the MySql console. You can do this by clicking on the WAMP icon in the system tray, then browsing to 'MySQL &gt; MySqlConsole'. When the console opens, it should ask for a password. Click enter, if it works, then your password is indeed blank. At this stage, you can find out what users exist by typing the following: SELECT User FROM mysql.user; Alternatively, to see details of the error, rather than the static "error with database" message, you can use the code below. die('Connect Error: ' . mysqli_connect_error());
Holy shit: &gt; With opcache the memory usage is 32 MiB, but without opcache usage rises to a whopping 390 MB, because each element of $array will get a new copy of ['foo'] in this case. 
Ah you're a genius! It was the 'root' which solved it . My text book assumed i was using a rented webserver with a username and password so didn't tell me about root or doing it via localhost! Thanks alot!..Ill owe you gold one day! ha 
Awesome! Too bad their installation instructions don't work for me on OS X
Right now install Google analytics and generate heatmaps for the site from 7 days of traffic. You'll learn what's important functionality on a page and have an index of high traffic pages.
I asked a similar question recently and was given 2 solutions that helped my understanding of the pattern. 1. Do one query for each relation. 2. Keep closely related tables under the same mapper. At first I was seduced by the second solution but decided to take the performance hit and went with the first instead as my code was "cleaner" that way. My mappers extend an abstract mapper and it does pretty much everything (query, map...), entity mappers then only define table name, table fields and entity relations while still allowing me to override any base mapper methods or add custom ones). In your example that means you'd have a mapper for each of your "entities", PostMapper, CategoryMapper, CommentMapper... each one responsible for querying the database and mapping the results to entity objects. Then you could have another layer responsible for mapping the relation between your entities, I'm not sure how it's called :D, I've seen it called composition, repository or just "service", say you have a PostService object, you inject all the mappers needed to build a Post entity object with all its relations. But what I do instead is I have some kind of Service Locator / Registry that holds the DB connection and my already instantiated mappers and can make new mappers too (and store them in the "registry"). I inject this "service locator" inside my mappers and build the relations right there in my `mapObject()` method. I think the data mapper themselves are very simple components but they bring many problems that you have to be careful about like the N+1 query problem... but also very cool stuff like lazy-loaded proxy objects and Identity Map look into these projects: * [Spot ORM](https://github.com/vlucas/spot2) * [fluentpdo](https://github.com/lichtner/fluentpdo) * [Aura.Marshal](https://github.com/auraphp/Aura.Marshal) and articles from [Alejandro Gervasio](http://www.sitepoint.com/author/agervasio/) on sitepoint have fun! ^^ 
Already made the changes and started using Composer, it's a lot easier now to manage the only dependency I had. Thanks!
I second that
&gt; MD5 is not used There's no point in enumerating only this when all of the SHA functions are comparatively as weak as MD5 next to bcrypt. Just say "bcrypt is used with an appropriate cost, don't use other hashing mechanisms" because there is effectively no safe alternative in PHP.
I have a project. I have a class which is 300 lines, which is acting a bit off. I want to quickly play with it and in some cases maybe even run some unit tests every time I update the code for the class. In my eval box, I copy the entire class, and paste it in my eval box. I can do "live edits" and every time my code changes, the results update. When I'm done, I copy it back into my codebase. How would I do this in a line-by-line REPL? I'd probably keep the code in the class file and run a REPL command to load and execute it all from time to time. But that offers no benefits over simply refreshing my browser, or using an existing PHP command line to run code.
It can useful if you're using an API that gives you X requests per minute, and you don't want to go over that. It allows for bursts while still staying under your limit. 
Check?
Check mate, phpists.
&gt; Email addresses are validated. How is this related to securiy? 
&gt; Passwords stored safely. Plaintext in the database is safe, right? Right guys? I used base64 encryption to make it safe. I would really recommend to describe those things further like: &gt; Password stored hashed by password_hash with bcrypt or similar modern algorithm. Otherwise I think the idea is not bad. Just a bit vague.
To be fair some companies say everything is the most important. "I want to change the text from 'register' to 'join'. I don't care if we need a feature to let users register this is the most important task!"
I'm not sure what you mean. Doctrine would work normally in Icicle.
Not sure about the dependency injection note. What do you mean?
Nah, you don't have to provide everything manually, it should be possible to reuse the existing composition root. Here's how it works: 1. You paste the class. Because you pasted it, the original definition won't be autoloaded. 2. You paste the line instantiating the app, or at least your composition root (be it a container, factory or whatever). In my case I can provide a snippet to be executed in advance as part of the box configuration, so no need to paste it, but anyway. 3. Add lines to play with it. In your case you can play with it, but it's somewhere else - in a file, and you need to go there, edit, save, go to REPL, reload and enter lines to play with it. In my case I just edit it inline and click "run" (unless I have the option enabled that runs automatically as I edit, which is also handy).
Gotta verify its real to secure funds in my account when I sell them to spammers!
Yeah but the app would or should already announce in some fashion how many requests are available in a given session
&gt; Yeah but for traffic shaping/throttling you're better off performance wise and such to have it controlled much deeper down the OSI layer. The problem isn't the layer level, but more that PHP isn't async. In Node.JS such throttling for a stream would be mostly free (despite it's at the same OSI layer). But for PHP, it's like shooting yourself in the foot a bit. As for OSI, things move down the OSI model when you have the scale, budget and return of investment justify it. I once told a client "I need 120 million USD to produce the machines that will fab the silicon wafers implementing your blog, it's more effective to burn on-chip than to use PHP." He stopped answering my calls.
I tried both sets actually with the same result. I've opened an issue on the home brew repo to ultimately see if anyone can help identify why it isn't working but I didn't get a response yet on the issue. It tells me boot2docker needs to be started but it's installed and started using the instructions it gave both on the repo and when it failed to install. https://github.com/codeclimate/homebrew-formulae/issues/3
&gt; Longer than 20? Your horse is correct, anything goes! Even "aaaaaaaaaaaaaaaaaaaaa"?
Have you updated your .bash_profile file with the three export values from boot2docker? That tripped me up when I first tried to run our install. If you run: "boot2docker up", does it say "Your environment variables are already set correctly."? Feel free to send us a support ticket at: http://www.codeclimate.com/help if you would like to troubleshoot this privately, otherwise, I'm happy to keep working on it here. Whichever you prefer. 
There are so many uses for md5 functions beyond just passwords. I use it all the time to generate unique array keys for data sets that doubles as a checksum.
I work from home. I've done so for roughly 6 years. I use the same computer for work and play. Basically I just do whatever I want whenever I want, but I've got great discipline. First off I have a dedicated office, I finished my attic (it's huge) into an office space and that's all it's used for. Doing this I get a clean separation between work space and living space. Secondly I use Jira for issue tracking. Everyday I'll build a list of tasks that I think will fill up my work day. Then I buckle down and bust out the issues, if I get done early I might work on some more issues, or I might play some video games. It's up to me, my goal was met! Sometimes I don't get them all done, but I always stop for the day at 6:30, remaining issues get pushed to the next day. Usually I'll go back to my office for a half hour before getting in bed and I'll poke around to help get an idea of what I want to work on the next day. On weekends I'll go up to my office I might work for an hour or so, but I mostly play video games or do some code experiments, just a free for all kind of thing. It really works well for me, but its not for everyone. I've had to fire good developers because they couldn't perform in their home environment. Working from home you really need to love your work and be seriously self motivated. But at the same time you need to understand and realize when you just need to stop working. 
I have a work laptop, but I sometimes check in from my own machine where I ssh into my laptop (right next to me) and use a work-only Chrome profile. I do all my work, except mail, FogBugz and Slack, in a command line anyway so ssh is super easy.
I'll definitely try it out thanks for the exchange. I believe PsySH will still be handy at some times but one should always seek out new ways :)
Of course it'll be handy. An ideal tool, I think, would be something to combine both methods (REPL and a code pane). But I don't have a suggestion how they should be combined. Haven't thought about it.
Thanks I intend on becoming a hermit as I learn as much as possible about PHP and this resource looks great! Your suggestion of a practice project is a good idea as well.
Perhaps "investigate well-tested community components before making decision to DIY". There are good reasons for DIY, but often I find those reasons were "I learned this 9 years ago", or "this way is OK". I don't necessarily mind projects where they've rolled something in-house - again, there may be valid reasons (legal, performance, time to market, etc). But I like to know they were aware of other options, had done at least cursory investigation first, then made informed decision before the DIY. This doesn't have to be "learn entire framework X before starting", but taking a bit of time to research community components (phpleague, auraphp, just browsing packagist, etc) can make you aware of modern practices that'll keep you ahead of the game re: security. *Not always* - there are some duds out there, but the community curation factor tends to weed out obviously bad stuff. And if someone's not bothered to make their library in to something consumable by composer, they possibly haven't been keeping it up to date WRT to security practices anyway.
If you know C/C++ already, the missing pieces are mostly syntax and function names, which you'll learn by rote, and Internet fundamentals. PHP is a web language and when I interview programmers I ask questions about how the Internet works. Make sure you know how PHP fits into the puzzle that makes a web application function. It doesn't hurt to know about HTTP, DNS, load balancing, caching, and typical systems used to do those things. 
Dual boot. Do shit in ubuntu, play in windows.
See this is what I was looking for. "What is missing from my current programming knowledge to make me a competent PHP programmer?" would have been a more appropriate title for this question. Thank you for the info; I will be well versed in those subjects by Monday. THANKS! EDIT: I also know HTTP well so that helps.
I agree but I don't use it for anything critical and if a collision were to occur, its usually not the end of the world for my use cases. In case anyone is curious: http://crypto.stackexchange.com/questions/1434/are-there-two-known-strings-which-have-the-same-md5-hash-value
You are correct. I think, as pointed out in many of the other comments here, the list if terribly vague. What they mean to say is present over HTTPS (assuming correct tls version and cert hash strength) instead of HTTP
This - people often forget to utilize the multi-user functionality that is available to them. Chrome profiles are useful for keeping you logged out of distracting websites, since you have to actively switch profile or login to reach them. If you want complete separation and you don't have two machines, create two operating system users (one for work and one for play).
[Defenders think in lists. Attackers think in graphs. As long as this is true, attackers win.](http://blogs.technet.com/b/johnla/archive/2015/04/26/defenders-think-in-lists-attackers-think-in-graphs-as-long-as-this-is-true-attackers-win.aspx)
Frameworks can make secure practices easier, but throwing a framework at a newbie or someone that doesn't consider security important won't suddenly make their code secure.
Two computers. One paid for by my company and one for my own personal use. Work computer will come home, but it's never on my desk unless in using it specifically to get work done. Having said that, I might write my own code for fun on my own time on my own laptop.
Get a wife. Since I got married as soon as I get home I get a bunch of chores to do, which keeps me occupied for hours )
I never said don't use it for other things. The context of "MD5 is not used" is in an article called "Security Checklist", in a section called "Authentication". The context clearly implies you shouldn't use MD5 as it relates to security and authentication, which is true. MD5 for non-security applications is perfectly fine... 
It comes down to re-usability. If the Mapper object has other dependencies, then to use it as a factory means pulling those dependencies along with it. A factory, meanwhile, should be a completely standalone class that's easy to pull in any place you need to do object construction. Further, `mapObject()`'s existence in the Mapper context implies that it's a specialized kind of factory - one where the source of data is a specific kind of data store. A factory is meant to be more generic than that.
Q: what thinks the unthinkable? A: An itheburg 
That's my secret, they are never separate 
I have a repository with one class, full tests, ci, scrutinizer, maybe someday soon even gh-pages. The size of your source has no effect on how you should be testing and verifying the code. I don't care if you have ten times more meta data than actual code. At the end of the day all I'm interested in is: what does it do, does it work, can I rely on it, is it compatible. You can crack up all you like, but I'd like to see you laugh when you use a no-fluff library that bites you in the ass. 
I work remotely and separate three ways: 1. Home office. I never go in there except for during work hours. 1. Office hours. I work 8:30am to 6pm, with a 1.5-2 hour lunch break to exercise. Outside of those hours, work doesn't exist unless shit is burning down. 1. Work laptop. All work is done on it. It's all about finding some way to kick on "work mode" and turn it off. For me that's hours + physical location (home office). The switch could be something like putting on certain clothing (slippers was an example in [Remote](http://37signals.com/remote/)) or just switching machines.
My intention is not to direct away from the content of this post, but I was wondering how you might back up your argument in the context of two examples; one my own (a [cache handler](https://github.com/rtheunissen/guzzle-cache-handler) for Guzzle 6), and [array_column](https://github.com/ramsey/array_column) written by Ben Ramsey. Both are single class projects, and in my opinion are significant enough to be versioned etc. Your car analogy is weak because it's *you* who is taking care of the maintenance, insurance etc, not the person you are hiring the car from. What if they took care of all that for you? All you need to do is turn the key and off you go. You'd be happy with 10 cars because they are even storing the car for you and keeping an eye on it while you sleep. 
&gt; Making PHPMyAdmin as secure as possible? Remove PMA from your system, and use a proper tool like Sequel Pro or MySQL Workbench to connect via SSH tunnel.
I run PMA with mysql/mariadb [skip networking](https://mariadb.com/kb/en/mariadb/configuring-mariadb-for-remote-client-access/) enabled, along with a custom alias and I use apache [require ip](http://httpd.apache.org/docs/2.4/howto/access.html) directives to limit access to my ip address. A self-signed cert is sufficient.
At the very least, password protect the directory on the server with a secure username and password that's unique from your phpmyadmin login credentials. Digitalocean has a good easy tutorial. I wouldn't say don't use it......just make sure, like everything, it's up to date on security patches etc.
MySQL Workbench is one of the buggiest tools I've ever used. Crashes left and right, the "search".... doesn't search at all, and there are times where it will flat out refuse to write changes to a database it's clearly connected to and clearly has the right privileges. Sequel Pro is several orders of magnitude better - the main problem is it's OSX only, and doesn't support SQLite. The only good, universal solution for SQL DB management is to become a command line ninja.
Remove phpmyadmin. Start using HeidiSQL
Why am I being downvoted for this? Doctrine has the best example(s) of how to implement the DataMapper pattern properly.
Yeah you can. User Manager, IIRC
F PHPMYADMIN. If you're going to use it, setup phpmyadmin on a bastion, limit to only vpn, no public exposure period when using phpmyadmin, too risky. then atleast you know anyone using the tool is on your local internal network.
Hooray! Now only 5.6 (and, soon, 7.0) will be actively supported.
Hello /u/againor ! I am actively developing few projects in Laravel while one is being quite bit large. And unfortunately it is nowhere near ideal, but still framework of my #1 choice. For bad sides: &gt; total lack of any reasonable forms support, you have to use bad laravel/html addtional package from composer but if you have a lot of forms, you will end writing your own form system with themes, error displaying etc anyway. &gt; while eloquent is quite good "orm" (actually active record), its great for small projects. For large projects it is quite hard to use repository pattern because you always have possibility of extracting db data anywhere on code. Also it uses a lot of magic methods which makes your models to provide zero IDE help and you either have your PMA, SQLYog or whatever open for looking up field names or you have to boilerplate-phpdoc-annotade every your model. &gt; while facades are there, they do not have to be used. unfortunately, using facades makes your app too much "global scoped" and it provides no ide help either; while not using them sometimes limits you (for example there is no helper function replacement for view::share, db::raw and using cache and session through dependency injection is confusing because you must inject some not related interface). &gt; form requests are very nice feature, but in larger projects, they are turning into huge boilerplate mess. we have in project over 400 form request classes, most of them having simple $this-&gt;Guard-&gt;check() on authorization rules &gt; default folder structure is weird, forcing you to put all of your controllers into one dir and having a lot of basic directories like commands, http, providers, events. Putting your app there means you will have to jump between your business logic directories and laravel internals; I suggest creating a new directory in /app/ called lets say App and namespace it in composer.json &gt; there are many incosistencies in using laravel; for example in view you want to use string from lang files, you have to write @lang( 'something.something' ) while if you want to use plural transation you are forced to make {{ trans_choice( xx , yy }} &gt; writing action links in views are painful, blade lack some special syntax sugar like @action , @route annotations in views, you have all the time write {{ action( 'somethig\something\somecontroller@something' , [ 'a' =&gt; 5 , 'b' =&gt; $obj-&gt;z ] ) }} &gt; earlier versions of laravel (4.2) were very quick and simple, but they are adding unnecessary complexity in version 5 requiring you to do a lot of boilerplate. if we have write that much boilerplate code in laravel now, why wouldnt we use symfony instead? &gt; eloquent is full of quirks, pitfalls and hidden features. it is also badly documented. i do not like field/table name guessing in eloquent, eager loading is tricky, $dates and $casts looks like dirty hacks for me, defining accessor and mutators is weird, pivot tables works ok but you cannot specify relations in them which means you will have to manually select something by id using pivot table field timestamp based migration system is really great, but unfortunately it does not include timestamp in migratino class name. so you may create migration with name update_user_table and after two weeks you may create another update_user_table migration, they will have different timestamps in files but actually their class names will be both UpdateUserTable; this means you may execute migrations one-by-one successfully, but making migration that contains both migrations will fail with php "class already declared" error &gt; weird structure for resources, database, tests directories ; composer weird interaction with seeder and test classes, you will have to do a lot of composer dump-autoload's to make everything work properly But Laravel has also some good sides: eloquent is quite simple and declaring new models takes 10% of time we would use in symfony blade is very readable and powerful templating engine auto dependency injection is really great, automatically inserting dependencies for your classes, you only have to declare them in constructor providers looks like nice feature to structure your application into smaller packages, if you have to reuse them in several projects artisan commands are very useful
If WordPress, CodeIgniter, etc. all committed to keeping up with supported versions of PHP and pressuring shared hosting providers to do the right thing for their customers, this would be less of a problem. (As for everyone else who's running insecure versions of PHP, I say, "Screw 'em, let them get pwned." Natural selection, etc.)
how to secure it? stop using it and use ssh, thats the way!
I'm gonna be slightly OT here (and yet not): does anyone notice the whole way PHP is handled has become a lot more mature in recent couple of years? We get fast releases with sane features, the worst legacy stuff is carefully deprecated and removed. And there are also all the "little things", like PHP.net getting a revamp so it doesn't look like ass (and recently the same happened with Packagist), and this clean presentation of supported versions and the roadmap ahead. Maybe it's the sobering effect of PHP6's failure and competition from HHVM that did this, I don't know. But I like it. PHP doesn't feel like a ghetto anymore.
One thing I do is set up phpmyadmin locally and then use a ssh tunnel to connect. Self signed is fine. 
I have the feeling that PHP7 will be suspiciously quickly adopted by shared hosting providers. Hint: handle twice as many sites on the same amount of hardware.
I agree there. The workbench crashes regulary while making schemes too, which is not that much fun. Any alternative, btw? Mostly for designing databases, not so much administration.
They have hundreds, maybe thousands of sites per instance. These are all paying customers, each with varying quality of code. One slip-up, one outdated function call, and an upgrade could break a client's site, losing the provider many customers. Additionally, there's the fact that upgrading such an environment is no easy task, infrastructure-wise. Sure, you can just plug in a new PHP version, but who's going to test all the client sites and make sure they still work? Financially, the ordeal is just not viable to them. Their customers are generally low-priority entities like websites for florists, butchers, pets, or simply used as email relays. That kind of stuff will keep working long into the death of ancient PHP versions, and as long as they can maintain that status quo, they can keep their income levels high with zero additional expenses. Upgrading would be an expense, and is by default uninteresting to them. I'm not sure why they don't opt to power up new servers with newer versions, but that's more or less the explanation for why they don't upgrade the old ones.
The real question is why a PHP version only has a lifetime of about 3 years. That's way too short.
&gt; Could anyone explain me like I'm five: while PHP 5.2 and 5.3 are totally outdated, still little less than half sites (at least based on WordPress https://wordpress.org/about/stats/ ) are hosted on these versions. You're looking at the bottom of the barrel (and yes, it's a thick bottom). I have clients with more unassuming needs who host at shared hosts. I've not seen 5.2 and 5.3 in a long time. It's mostly 5.5 and 5.6. Worst I've seen is 5.4. &gt; Why? Why hosting companies simply not update their servers to 5.6 or 5.5? Some people are just not good at their job. That's why. And many people lack the knowledge to tell who's bad. The issue of backward compatibility is often cited. You don't have to auto-switch everyone to the latest PHP, but you can at least show them big honking warnings both over email and in the panel and give them a grace period for switching. But again, if you're bad at your job, you prefer to do nothing, just get the cash and ignore your customers' security. &gt; Is there any drawbacks of this move? Endless developer frustration aside, you're open to all unfixed vulnerabilities from 5.2 onward.
&gt; final methods (another sin) I have the impression that PHP land is not aware of the final modifier, as I can't remember seeing that in any code. Anyway, why is final a sin? What about designing for subclassing?
Yeah I've tried to create a new user with password to phpmyadmin and it did no diffrence.
Do you have a "phptest" database?
Yes and table: "users"
You can connect to your MySQL server with phpmyadmin, just not with your script? Maybe it's permissions on he user? Try using root to double check 
In the line: mysqli_select_db("phptest", $db) or die ("Cannot select db");. You switched both of the arguments in mysqli_select_db("phptest", $db). So it should be mysqli_select_db($db, "phptest");. Source: http://php.net/manual/en/mysqli.select-db.php But you don't really need the: mysqli_select_db(). mysqli_connect() takes another argument after the password which is the database name so it could be: mysqli_connect("localhost","root","","phptest");
another day, another same question and [same answer](http://www.phptherightway.com/). Good luck.
Don't most of the major nix distributions back port fixes for EOL PHP? We recently encountered a server running 5.3.x which is now EOL but emailing the sysadmin he said that Debian is back porting security fixes so nothing to worry about. 
mysqli_query also needs the $db parameter: https://php.net/mysqli_query
$result = mysqli_query($db ,$query); Don't be afraid to check the documentation if you have problems, the documentation is so helpful.
The error message is somehow descriptive, you are supposed to pass the MySQL connection ID ($db) as the first parameter in those functions. If you don't feel like adding the connection variable all the time, use the Mysqli class instead: http://codular.com/php-mysqli Check the official manual if you have doubts when using any function. PD: thanks for not using the old mysql_* functions.
You should improve your error handling so you get back the messages that MySQL is probably sending to PHP. The simplest way to do this is to switch mysqli using exceptions by [setting report_mode to strict](http://php.net/manual/en/mysqli-driver.report-mode.php). Alternatively use the [error and connect_error](http://php.net/manual/en/mysqli.error.php) properties / methods. Additionally, ensure that [error_reporting](http://php.net/error_reporting) is set to E_ALL and that either [display_errors](http://php.net/display_errors) is enabled, or you're [logging errors to a file](http://php.net/error_log) (the directory you put the error_log in will need to be writable by the webserver - the same as for file uploads or any other file creation in your scripts) ---- On a side note, stripslashes() is not the correct way to escape data before inserting it into an SQL query. stripslashes() doesn't handle all the special characters for SQL queries. You should instead use either [mysqli_real_escape_string](http://php.net/mysqli_real_escape_string) or [prepared queries](http://php.net/mysqli_prepare)
A full virtual private server at Digital Ocean, for example, is $5/month. *How much cheaper can it get*? You can install anything on a VPS, even PHP7 alpha 1 (if you're nuts). The only real reasons for running PHP 5.2 mid-2015 are laziness and indifference.
wow thanks so much it worked, I will check documentation instead of blindly following tutorials
I agree, it feels less lolphp and more a 'proper' language for developing in. My main criticism is that it's taken too long to get around to this way of thinking which puts PHP at a disadvantage to other modern web languages. I'm grateful to the people making efforts to improve the language with proposals and new tooling, since I'm stuck doing PHP for a living, at least it can be a bit bearable this way.
SQLYog
Some shared hostings have an option to choose the PHP version globally. (Some even let you choose different PHP versions for your subdomains/parked domains). Not every shared hosting does this, and not every user is aware of this behavior in their CPanel accounts. 
I don't think adaption rate will be influenced by that. It mainly depends on the support of the distributions (most of which usually lag behind dramatically) bcz having bleeding edge versions is usually too high a risk for such a low-margin business like shared hosting. It also depends on how many customers you will piss off bcz their 10-year old CMS the son of a friend once coded in PHP4 won't work anymore or if the company sells additional services for more demanding customers which actually require a bleeding edge environment. Those shared hosting providers who offer a selection of PHP versions will probably add PHP 7 to the list of available versions, but I don't think the PHP version necrophilia of the vast majority will change anytime soon. 
Wow, and I thought I was doing well moving our sites onto 5.5. It's the official version for 14.04, are the Ubuntu repositories going to be updated too? Otherwise this seems quite premature to be dropping support.
I don't use PhyMyadmin, so I can't offer advice there, but why go with self-signed certs? Just get a free one from startssl.com. They work just fine.
Up to you.
Within a given major release, no it's not. PHP has been quite reasonable with backwards compatibility breaks from 5.4 onwards. We had no trouble upgrading some larger apps (with components ageing back to php 4) that were running fine on 5.4 all the way up to 5.6 without code changes (yes, that's anectdotal). If you've written code that will not run on later versions you always have the option to use some distribution backports (debian still supports 5.4 till 2018, afaik) or pay Zend or Red Hat to have access to enterprise level support for older versions. edit: Removed the last edit...(sic)
I have tried learning via book and it isn't fun, I'd suggest video tutorials. Once you're cool with HTML and CSS, which I'd recommend going through W3Schools for (it won't take you long to learn!), going to TheNewBoston and watching his PHP tutorials.
What the heck is PhpIgnite.
Heh ;) BTW, this framework isn't considered quite... state of the art. I'd suggest you shop a bit more for frameworks to learn.
PHP has final classes, and it is good practice to mark them so although you will see nearly no one do it. Subclassing does need to be designed for.
While it's not quite the same as one-on-one skype, there are plenty of online chat channels dedicated to programming (general, language channels and framework specific channels). I'd recommend taking a look at Freenode IRC and [ChatOverflow](http://chat.stackoverflow.com)* A quick google for "webdev freenode channels" turns up [a starters guide from TutsPlus](http://code.tutsplus.com/tutorials/irc-is-back-heres-your-starter-guide--net-31369) which may help you get started - Oddly they omit the PHP channel ##php (while on IRC most channels start with a single '#', on Freenode "unofficial" channels - which aren't run by the owning organisation - start with '##', but that doesn't mean they're any less helpful). .* Some channels on ChatOverflow do require you to have a minimum StackOverflow score
This might be a dumb question, but I don't know any better; Isn't it possible to install all the different dot versions of php 5 and allow some switch in the panel or something? Let the dinosaurs keep running on whatever their running, but also allow new users to have the latest and greatest? 
It is. Hostgator, for example, allows running multiple versions of PHP on their servers. But most hosts will opt not to do this because a) it's an investment and thereby a cost and b) they don't care enough to do this, they don't feel existentially threatened so they don't need to up their game. In addition, configuring several different versions of PHP implies maintenance of several different versions of PHP, and thus overhead and probably a bigger and/or more skilled team. It all comes down to them providing the bare minimum on which they can turn a profit.
I don't know what that gives you that the cli doesn't. Can you enlighten me?
That makes sense, I always am thinking in small scale. My server has all the versions, but then again, it only has one user 
&gt; Is there a recommended way to handle such a large database, with multiple users needing to have their own data in relation to each word? Again, perhaps there an out of the box solution, or some kind of template I can hack for this situation? You have a table of Users with primary key "id", let's say, and table Words with primary key also "id". You need a third table, with compound primary key [userId, wordId] and a third column for your number (and as many more as you want). When you select rows in that table, always select by the entire compound key, whether for reading, writing or deleting and you'll be ok. The userId should come, of course, from the current session user. In general when I have user-scoped data, I always include userId = $theCurrentUserId in my queries. Even when the userId is not part of the primary key, so just selecting by the primary key would be sufficient, include the condition that the userId matches anyway. Better be safe than sorry. By always including that condition you treat every user's data as if it was a separate table.
Excuse me, do you have the time to talk about our Lord and Savior, Taylor Otwell? 
Hi Penderis, I've just checked out Laravel, is it worth purchasing a subscription to their tutorial series, or is there enough documentation and tutorials online for free?
People love to hate on PHP because it is popular and has a couple well quirks/annoyances (needle/haystack inconsistencies). It also got a bad reputation back in the day because less-than-amazing weekend programmers picked it up and put out a bunch of shitty code out which people started to associate with the language rather than the developer. The truth is the language has evolved into a much more modern and secure programming tool. It now has truly amazing frameworks like Laravel to compete with the likes of Django or Rails, standards that are being accepted (PSR), and a much stronger base of seasoned developers who care about the quality of their code. TL;DR: There is nothing wrong with PHP. Your professor is most likely uninformed about the current state of the language and using steorotypes from the language's early days for cheap laughs.
&gt; I love the way it works as a preprocessor and can have pages of HTML with code embedded that get evaluated and dumped into the text. Start using a proper framework like Laravel and learn to separate your logic from your views.
Watch it though, Eloquent is a memory hog and will cause huge performance issues for larger databases.
They'll "present third party offers only ... where it is explicitly approved by the project developer, or if the project is already bundling third party offers."? So the cynic in me thinks that this means they can keep making people download the malware they've *already* bundled with projects! Whatever though, the time to avoid SF was a long time ago, and there's definitely no reason to go back.
I am sorry to see it fall from grace, but it got disrupted by github and a better freemium model and not using the BS download ads. So they kind of did it to themselves. Heck even Google couldn't compete with Google code.
Just use MySQL console :) 
As someone who actually runs a host.. our customers can always choose which host they want to be on. The PHP 5.4 or the PHP 5.2 server. They can migrate at will. We currently have &gt; 95% of customers choosing to use the PHP 5.2 servers. We've had many conversations with many customers and the short answer is they would take their business elsewhere before moving to a newer platform. So rather than slagging off hosts that "don't do their job", maybe people want to ask developers why their code is stuck on PHP 5.2. 
That's 32 videos totalling a tad over 26 hours. Have fun!
There's a free tutorial at Laracasts that is worth watching, "Laravel 5 fundamentals" it has probably every bit of information you need to start. Maybe later when you need the advanced materials you can buy a subscription.
Not only that, but the Git implementation leaves a lot to be desired, according to admins at the project I work with (Java-based).
And now, everyone is shipping / deploying their code using better tools. Too late, Google.
/r/phphelp is the best subreddit for PHP questions About the error, it is the same problem you had this morning, check the reference of mysqli_query: *Warning: mysqli_query() expects at least 2 parameters, 1 given in C:\wamp\www\test\new_user.php on line 10* http://php.net/manual/en/mysqli.query.php Oh, and people will hack your website if you don't satinize your data :) http://php.net/manual/en/mysqli.real-escape-string.php
Ok, replace the mysqli_query line with this one: mysqli_query($db, "INSERT INTO users (username, password) VALUES ('$user', '$pass')"); However, this code protects the query from *script kiddies* and hackers: mysqli_query($db, "INSERT INTO users (username, password) VALUES ('".mysqli_real_escape_string($db, $user)."', '".mysqli_real_escape_string($db, $pass)."')"); Edit: Something important about not storing your passwords in plain text, blah blah :/ 
Worked! thanks for extra info
You need 5 years LTS release. Just because if I write a PHP 5.5 application, I should be able to wait 5 years to upgrade it.
Oh btw isnt it better if i put "mysqli_real_escape_string" where i have "$user = $_POST["user"];" / password variable?
Yeah, but the important question is how well can a distro support any old software package that's no longer being supported upstream? Over time backporting security fixes must presumably become harder as the sources diverge.
Yes, it is more readable/tidy.
Is there any good reason why the guy hosting a site I work on ignores my requests to stick the php error log somewhere where I can clear it myself? Nginx server. It used to be apache so I was able to circumvent the problem with an .htaccess file. Now I can't. 
Because as far as they're concerned It Works. 
We pay for managed co-location meaning we have the benefit of there being someone on the end of the phone to fix issues 24/7. Due to the unfortunate reality that we have a lot of legacy client websites written in 5.3 that do not have the budget to redevelop, our server is running 5.3 - fortunately as you say Red Hat do back-port security related fixes. However what made me laugh recently was when the heart bleed issue became public, a lot of clients got in touch regarding it - when we got in touch with the man on the end of the phone to ask about if we had been at risk he replied with "oh, don't worry about that, your version is too old to have the issue." I started typing all this, and have now expended the effort, so I am going to click save even if its a ramble; for those interested we now develop for 5.5 and have been updating any 5.3 client work to 5.5 during spare hours so we can eventually drop that server in favor of aws. 
No. 2 when working for an agency - shit is always burning down...
how does drupal extend to be CRM , P2P ? i hear Drupal is a amazing operation system for PHP
Recently started working on a project with a smaller team who were not sure about which framework to use and left that decision until now. Their current approach is MVA (Model View Action?!) over MVC due to it being simpler? MVC you have a controller with all the actions contained within it and then view files relating to each action. Their MVA approach consists of EACH action being inside its own class WITHIN the view folder?! Does anyone have some links to MVA approach that I could read up on? I cant find much on it? So for example in their MVA approach if they have a "User" object. Their view directory would contain dedicated directories for each action (edit, add, delete). Inside that would be the actual action.php class AND the view.php file? Its actually confusing typing this out. They don't use a "controller" directory at all. Their controllers/action are kept within the view folder. Has anyone come across this before?
You might want to look into containers such as Vagrant, Docker or classic virtual machines. That's what I would do. Don't quote me on this but if you have something really small you might get away with [PHP's built-in server](http://php.net/manual/en/features.commandline.webserver.php) and SQLite which is bundled in PHP.
Why? What's so damn hard about running `apt-get dist-upgrade` once a year?
Let me stress the awesomeness of laracasts. You'll love it. 
Codebase is missing in the list https://www.codebasehq.com/
It's not really "their" tutorial series.. Jeffrey runs an unrelated business which happens to be producing *mostly* Laravel specific videos (though there are quite a lot of general topics there too). Worth it? I find it so, although you need to be careful about taking everything he says as the one true way. The docs were recently overhauled and are quite good now. There are also a number of resources available from many other people within the community which are free or essentially operate on the principle of donating if you find them useful.
There's a saying... if you're not paying for the product you are the product. 
Not used it myself yet, but was planning on using https://phinx.org/
Not much difference from Java.
If one of your machines is a laptop then using VMWare / VirtualBox is very suitable for this. Run the VM on your laptop, and then get a new IP address from your other site when you switch locations. I work like this - desktop in office, desktop at home, laptop stays the same throughout. I also use Gitlab to make switching between desktops as painless as possible. 
No offense, but why the hell are you still with such a shitty host? Any decent host should either: A) Allow you to select from a range of PHP versions per site - this is possible on shared hosting) B) Offered to move you to another of their servers, running an up to date version of PHP. The fact they did neither screams shitty GoDaddy/BlueHost/JustHost/HostGator type of hosting companies.
Reactive programming with PHP (Similar to Meteor framework), is it currently possible? 
I must be really fucking dumb, because I don't understand this. In Laravel, you can send e-mails like this: Mail::send('emails.welcome', $data, function ($message) { $message-&gt;from('us@example.com', 'Laravel'); $message-&gt;to('foo@example.com')-&gt;cc('bar@example.com'); }); How the hell does the send method access *$message* if you don't *return $message* inside the anonymous function? I tried reading the code and it didn't help.
It sounds like it could be called the MVP design pattern (Model View Presenter). Basically the Model is used to retrieve data from the database, the Presenter interacts with the model and converts data for the View to display. The View would have no interaction with the Model, only the Presenter. BUT all that being said, it sounds like there would be a lot of repeated code and very large class sizes doing it with each "Action" split out into individual files, but I am just guessing as I haven't used that design pattern before. Ultimately, if it works and you understand it, just run with it.
Having checked them all out, here is the list of the ones that aren't just a recap of stuff you can read on blogs or probably already know: * Gordon Skinner - Hexagonal Architecture in DDD * Jenny Wong - Integrating Communities * Bastian Hoffmann - Bring your PHP application to the next level with React.JS * Stephan Höchdorfer - The NoSQL Store everyone ignores: PostgreSQL These are the really good ones. Others not so much ( just recapping stuff that has been recapped to death e.g. "Building RESTful APIs with Laravel 5's Doc Block-based Controller Annotations" is just recapping the tutorial for the most part )
Without knowing what message you received when you tried to join the channel, it's hard to tell. If you get directed to another channel, read the channel topic (/topic) as this may help you) It looks like the channel currently requires you to be registered and logged in with Nickserv (some channels do this to reduce the amount of spam / undesirables they get). I found a guide to help you register at https://meta.wikimedia.org/wiki/IRC/Instructions
Simply: Objects are references. You can pass an object into a function, have that function modify that object and without that function returning $object it'll correctly have the modifications. See this: http://codepad.viper-7.com/Q6Ivcg Read more here: http://stackoverflow.com/questions/2715026/are-php5-objects-passed-by-reference
Do you have any alternative suggestion? I'm always open to new methods
I work for a large hosting company and this is exactly what we offer. We currently offer PHP 5.2, 5.4 and 5.6. I'm not sure why we missed 5.3. We generally end up deploying security fixes and new releases within 3-5 working days of release. This is mostly the time it takes us to build and repackage them before then deploying them across the hosting estate (hundreds of servers).
Weird. I'll keep an eye out.
Cynic? &gt; ... or if the project is already bundling third party offers. Dude, you just know how to read, that doesn't make you a cynic.
Nice list, thank you. I'm mostly only aware of Github and Gitlab and I'm not tied to either... any personal recommandations of other services? Any killer features I should be aware of?
Source: public function send($view, array $data, $callback) { $this-&gt;forceReconnection(); // First we need to parse the view, which could either be a string or an array // containing both an HTML and plain text versions of the view which should // be used when sending an e-mail. We will extract both of them out here. list($view, $plain, $raw) = $this-&gt;parseView($view); $data['message'] = $message = $this-&gt;createMessage(); $this-&gt;callMessageBuilder($callback, $message); // Once we have retrieved the view content for the e-mail we will set the body // of this message using the HTML type, which will provide a simple wrapper // to creating view based emails that are able to receive arrays of data. $this-&gt;addContent($message, $view, $plain, $raw, $data); if (isset($this-&gt;to['address'])) { $message-&gt;to($this-&gt;to['address'], $this-&gt;to['name'], true); } $message = $message-&gt;getSwiftMessage(); return $this-&gt;sendSwiftMessage($message); } The line `$data['message'] = $message = $this-&gt;createMessage();` is where it is initialized.
Alright, I finally get it. Thank you very much.
yeah ,just as you say , I want build a CRM tailored to my specific domain . I am a new to Drupal and I plan to taste it
If it's working fine... Don't fix what isn't broken. Now when you want to implement new features or change existing functions, this is a great time for refactoring. You can setup a test to validate the output before you do anything. Now you start your refactor/changeset. The unit test should tell you if you broke something. Rinse repeat. The more you do this, the more parts of your application gets covered. Start small and build out. A good starting point is this video: http://verraes.net/2013/09/extract-till-you-drop/
That definitely looks very interesting! Will have a look into this too.
Bitbucket allows you to have free private repos whereas on github they come at a price. So I use Bitbucket for my private stuff (.dotfiles, .vim, .tmux, etc) and github for public repos.
Did you miss the bit where I said an Enterprise product?
I would probably say 5-20 simultaneous web users would be normal. Would PHP's be limited only by load, or are there some missing features I should be worried about? 
The Drupalberries taste like Drupalberries! 
&gt; It "only" lacks automated tests - and was developed without consideration that we would write them in the future - as in: if the usecase for a method suggests it would be better off static - it's implemented as static and so on. Despite recent trends to the contrary, I'm suspicious of code refactoring *only* to make tests easier. Refactoring for tests may improve your code architecture (make it more modular), but it may also make it worse (make it too modular). I'm also suspicious of static methods (not all though). So it really depends, and you can give more specific examples if you want us to discuss them. BTW in PHP you can easily replace a static class for testing by simply defining it before it's loaded. Why you need to replace it for testing is another one of those suspicious things that you mention, but don't explain. **tl;dr** Share specifics, get specific advice.
Question was for an Enterprise product, not a public web page. 5-20 users would be max load in production
I'd like to point out that Test Driven Development doesn't mean just to have tests. So by adding tests on existing libraries, you're not learning TDD, you're just learning to write tests on existing libraries. Not that I find TDD particularly useful for a lot of what web development is. There are more cases when TDD produces bad results than good ones. One case when it produces good results is writing data transform pipelines, parsers, compilers. Hmm, and that's about it. But anyway, like I often like to say, don't use terms that you don't know the meaning of.
How would you go about building an ecommerce site (not a simple t-shirt store like most "demo" sites)? I am struggling to find a system (similar to magento for example) which is not riddled with bugs &amp; hacks to get around things that should be there in the first place.
&gt; Framework wise you cannot go wrong with ~~laravel~~ Symfony2 FTFY 
Good point.
My point was, the flow of TDD is to write a test, then write the code testable by it. This prevents a developer from writing code which is untestable. Which brings its own set of issues, but I won't go there. Practicing for this by writing tests for existing libraries is the exact opposite flow of that, and getting stuck on a piece of untestable (or hard to test) code is far more likely. 
~~Not always. According to the [documentation](http://php.net/manual/en/functions.arguments.php), function arguments can be passed by value (default), by reference, or default arguments.~~
Building an ecommerce site vs. using ecommerce packaged software, both are two different things. Are you looking for a pre-built CMS? Or do you want to learn how to build one from scratch. I assume you're looking for a CMS, and OpenCart does a pretty good job, however I'm quite fond of 3dcart
The host needing to see application-level errors (which PHP errors are) assumes they plan to do something about it. Except, it's none of their business to do something about it, but whoever has uploaded and is managing the code.
A factory. BTW, what kind of dependencies would a validator have?
Sourceforge on the web side is considerably slower and the user experience really has not improved that much recently.
I'll assume you mean long-running event-publishing applications that push updates to the client, instead of making the clients poll. It's possible, but it's not a very popular paradigm for PHP, so libraries like React.PHP just aren't as mature as they could be. Depending on your app and existing codebase, I'd offer different solutions. So what are you doing that you believe needs reactive programming?
&gt; I disagree with your opinion of what the flow of TDD is. It's not my *opinion* you disagree with, but the actual definition of TDD: https://en.wikipedia.org/wiki/Test-driven_development This is why I told you to not use terms you don't know the meaning of. The "Driven" in TDD refers to the fact test comes first, code second. No test, no code. If you don't have the "luxury" of implementing TDD the solution is very simple: stop saying you're implementing it. You have automated tests. That's good. It doesn't have to be TDD.
No, I'm not really developing an app that needs this currently using PHP. But, it would be interesting to see if such thing is possible. I will check out React PHP though
In this case I'll just add PHP can be part of a larger ecosystem, so you can have some code in PHP and you can have a push event-based system written in Node.JS (for ex.). I don't see it as an either-or proposition. That said React.PHP can handle a lot of tasks you throw at it, the issue is that it doesn't have a large enough community to create a rich asynchronous library ecosystem around it to match what PHP has in terms of synchronous libraries. Some components are present, many lacking.
PHP 5.4 had more of these changes, but the only one I was actually bitten by was the removal to call-time-pass-by-reference http://php.net/manual/en/migration54.incompatible.php PHP 5.5 had much fewer. http://php.net/manual/en/migration55.incompatible.php Of course, no host will guarantee or say if your codebase will be OK or not. But, its easy enough to get a VM with PHP 5.5 on it via vagrant or puphpet.com or phansible, and then you can test your code.
What's with the `'string'-&gt;toUpper();` example under Uniform Variable Syntax? Is it just a misleading example demonstrating the parser, or am I missing a huge new String class?
You can be one of those guys and just use Wordpress + WooCommerce haha.
&gt; Someone suggested the Decorator pattern before but I don't think that offers the flexibility you have here, where you can completely replace a function (HeaderPlugin) as well as simply adding a bit of code (FooterPlugin). Actually, that is more-or-less the whole point of the Decorator pattern. Your second code sample is a basic example of the Decorator pattern. Have you looked at a template engine, such as [Twig](http://twig.sensiolabs.org/)? Twig supports inheritance and block overrides out of the box, so you should be able to achieve this kind of system fairly easily.
It's demonstrating a new parser capability that is not, yet, utilized (for strings). But... let's say I know /u/nikic/ is itching to do it.
I guess learning can be painful. I've edited my post. You're right. Testing !== TDD.
I'm not sure where you were using eval before, but I don't see any reason why you would need to use eval. Yes, one downside of the decorator pattern is that you have to implement all of the methods, but there are ways around that. For example, you can create a passthru implementation that just proxies *everything*, and then extend that (in my example, I called it `ThemePlugin`). interface Theme { public function header(); public function body(); public function footer(); } class BaseTheme implements Theme { public function header() { echo '&lt;header&gt;'.$this-&gt;sitename.'&lt;/header&gt;'; } public function body() { echo '&lt;main&gt;'.$this-&gt;content.'&lt;/main&gt;'; } public function footer() { echo '&lt;footer&gt;'.$this-&gt;footer.'&lt;/footer&gt;'; } } abstract ThemePlugin implements Theme { private $theme; public function __construct(Theme $theme) { $this-&gt;theme = $theme; } protected function getTheme() { return $this-&gt;theme; } public function header() { $this-&gt;theme-&gt;header(); } public function body() { $this-&gt;theme-&gt;body(); } public function footer() { $this-&gt;theme-&gt;footer(); } } class HeaderPlugin extends ThemePlugin { private $sitename; public function __construct($sitename) { $this-&gt;sitename = $sitename; } public function header() { echo '&lt;header&gt;&lt;img src="..."&gt;'.$this-&gt;sitename.'&lt;/header&gt;'; } } class FooterPlugin extends ThemePlugin { public function footer() { echo '&lt;div&gt;Twitter/Facebook buttons&lt;/div&gt;'; parent::footer(); } } function applyPlugin(Theme $theme, $pluginClass) { if (is_callable($pluginClass)) { // If the plugin class is actually a callable, // we should pass the theme to the callable // and the callable is expected to return // a Theme instance. return $pluginClass($theme); } // In the simple case, just pass in a class that // accepts a Theme as its first constructor arg. return new $pluginClass($theme); } $theme = new BaseTheme(); $theme = applyPlugin(function (Theme $theme) { // We are passed the theme we need to wrap. This // let's us do things like send other args to // the plugin we want to apply. return new HeaderPlugin($theme, 'Awesome Site'); }); $theme = applyPlugin('FooterPlugin'); $theme-&gt;header(); $theme-&gt;body(); $theme-&gt;footer();
All right. Also, sorry for me being kind of a dick about it :D
Hopefully this change to number strings will fix one of the more annoying quirks of PHP in regards to strings. Hope this is for all strings that are numbers too. Such as strings that are binary, octal numbers and whatever '0e' is viewed as. I'm a firm believer that PHP should treat strings as strings, period. If your string is a number of some sort and you want php to view it as a number you should have to run it through a conversion function. Such as '234'.toInteger(), .toFloat() or .toNumber(). With the latter return a int or float as needed. Also anyone know what type of number '0e' is seen as? I would have said octal but all the talk only seems to talk about '0e' and not say '0a'. See this [Stack Overflow](http://stackoverflow.com/questions/22140204/why-md5240610708-is-equal-to-md5qnkcdzo) for what I'm talking about it you don't already know.
Nope I needed that. I definitely needed to be humbled.
&gt; Generally each one should run in sequence. Looks like Twig has its own parent command {{ parent() }}. What I was asking is, can you stitch a bunch of overrides together to make something like this? Sort of. Each child would have to extend the child to its left. Like this: parent -- plugin 1 ---- plugin 2 ------ plugin 3 Each plugin would have to call {{ parent() }}. In my opinion, requiring the parent call in the plugin is not the best idea. What if the plugin author didn't include it? Now your plugin chain is broken.
Ah, I inferred you were worried about your code breaking, because unless they are super-inexpensive, you can find other shared hosting providers that are on newer versions or even let you pick which version to run on a site. And VPSes are competitive too, if you don't mind doing your own maintenance and setup.
I'm not following the logic of your `applyPlugin` function. You're calling it twice with different parameters. Were you supposed to pass `$theme` as the first parameter? Also, does that let multiple plugins override the same function? Isn't the `parent::footer()` going to call through to `ThemePlugin::footer()` and not (for example) `SecondFooterPlugin::footer()` ?
It depends on how the code is going to be used and by whom. If it's guaranteed to be private and internal and you can freely refactor everything that touches it without affecting people outside your team, then just use a single concrete class because YAGNI. However, if you are creating an open-source library, or a module designed to be used by different teams, then you should hammer out the contract for an interface and design around that.
Thank you for going over this in detail for me. After p_barker's advice I had been doing lots of reading on relationships and lookup tables. Your explanation really helped fill in the blanks for the kinds of tables I need to set up. Also the use of including userId = $theCurrentUserId sounds very interesting, I definitely appreciate double checks &amp; extra security. I will give it a shot if I can get that far. At the moment I am struggling to set all of this up in Laravel though. I think I have set up migrations properly, but I can't get my head around models. All the tutorials I find are for older versions and seem to use different code for this. It seems in laravel 5 I need to use something like "use class Word extends Eloquent", something with Illuminate and something with implements. I am going through some laracasts to hopefully figure out this step! :)
Can anyone tl;dr me the reasoning behind choosing invariant return types over covariant ones?
While you can't get a sense of security from completing a checklist, there's still value in actually crossing things off a checklist. Each missed item in a checklist provides another path for an attacker to follow in the greater graph.
Pass by value is the default for non-objects, but objects are always passed by reference.
I actually just brought it up with my hosting company and it turns out they recently added a cpanel feature which lets me choose the PHP version I want with a simple drop down menu. 5.3, 5.4, or 5.5. Sweet. I like that feature.
Okay, that's what I was hoping (that it was technical). Thanks!
I suggest using decorators. I've build a library for these situations https://github.com/siriusphp/stratum It's still a WIP but I think the code is simple enough to understand the concept and build your system (or contribute to my library :) )
fuelphp : small but enough codeigniter: old lion :)
I like SQLYOG myself.
At my current job we deal with HIPAA and privacy-minded clients who prohibit us from using github or bitbucket. What we've done instead of set up self-hosted Stash instances so we meet all our contractual requirements while also keeping the benefits of a mature code hosting platform. You can go that route, or use something else like gitlab, gitorious, etc. Or, hell, you can just have a plain git repo on a private server if you're not working with a 3+ developer team. Github and Bitbucket haven't had any security breaches that I am aware of. Set up 2fa and you *should* be golden, unless either one of them get hacked. But then, what if gmail gets hacked? Dropbox? You have to place a certain amount of faith in this 3rd party services to use the, right?
&gt; Yes, one downside of the decorator pattern is that you have to implement all of the methods, but there are ways around that. *cough* __call() *cough*
It's the same as an email provider, so it depends how much YOU and/or YOUR CLIENT trust the 3rd party providing the service (private repos). I think, in general, Github or Bitbucket (and other private repository providers) are trusted parties. They don't care (=wont look at your data/code) what you push there and should have (internal)policies to assure your data is not abused (stolen) by their employees. And they make sure your data is safe for uninvited preying eyes. If you, or your client are still not sure, go for a self hosted solution like http://gogs.io/, https://github.com/takezoe/gitbucket or maybe https://about.gitlab.com/downloads/ Hope this helps.
~~That's a meaningless buzzword.~~ wait a tic: &gt; Question was for an Enterprise product, not a public web page. 5-20 users would be max load in production Ok in that context I guess it makes sense, though "Intranet" would be more accurate.
I've found HeidiSQL to be pretty reliable actually. I like that when it's working showing data and such you can actually see what the heck SQL it's using down in the logging area. Plus I like the table size being so obvious. Reminds me not to run too open ended queries on the big tables. 
No need to clear it out, tail -f is your friend! 
Have you configured your server to deliver those files with the correct mime type?
Gitlab is fantastic and since the switch from self compiled to omnibus you can have it setup and running on a self hosted server in less than 5 minutes. I highly recommend it. We run ours on a 8GB Digital Ocean VPS with over 300 repos.
Trying to use phpseclib to replace the SSH2 dll on my server so i can move to php 5.6 and up. I use SSH to log into Sonicwall firewalls and export configuration files. Logging in via SSH isnt like remoting to a linux box. Putty, for instance, asks for a username when you first connect, but the sonicwall ignores that, shows its welcome banner, and then asks for a username and password. I am able to connect currently using the following code: $connection = ssh2_connect($host); ssh2_auth_none($connection,$user); $shell = ssh2_shell($connection,'vt102',null,80,40,SSH2_TERM_UNIT_CHARS); fwrite($shell, $user."\n"); fwrite($shell, $pass."\n"); // etc I tried the following with phpseclib: $ssh = new \Net_SSH2('172.17.1.99'); $ssh-&gt;login("admin"); $ssh-&gt;read('User:'); $ssh-&gt;write('admin'); $ssh-&gt;read('Password:'); $ssh-&gt;write('password'); But something is getting hung up and i get nothing until my execution timeout hits.
That tends to be what I look for in a Junior position too so I typically gear my questions that way. I'll come up with a sentence and ask them to construct a google query that would find the answer without using any of the words in the sentence. I also like to know something they messed up, or could have done better, or some kind of bug and how it was resolved in their last project and what they did to fix it. I get really excited if they tell me about how they learned something and what they did to test that instead of just taking some ones word for it. Like, maybe indexes in their SQL database. Did some one tell them "Oh yeah just slap indexes on everything" or did they actually run some before and after tests? How did they do that? If there is some kind of casual talk at any point drawing attention to how you figured something out certainly can't hurt. If they do ask you a question you don't know the answer to ask them the answer after the interview when they ask if you have any questions. Also, yes ask them questions even if you don't have any. Ask about corporate culture or what they like to do for fun outside of work even. Really just know your basics as well as you can and don't sweat too much of the larger stuff. If anyone expects you to have seen all the stuff you're most certainly going to see in your career in just 2 years you don't want to work for them anyways. EDIT: Also don't get flustered if you don't know something, just be confident in what you do know and be aware there is a ton you don't know. Thats not a weakness, being aware of that is what allows you to grow and learn. They may simply keep asking questions until they reach the point you don't know the answer anymore. 
After the speed increases it's my favorite feature. Can't wait to replace all the old isset() ? : (isset() ? : ) shit spaghetti.
In my experience, interviewers vary wildly. You never know what the hell they're going to throw at you. The big growing trend I've heard of is FizzBuzz. There's a debate about how good a question that is, but regardless, there's a potential you'll encounter it. Honestly, it's pretty simple, and I'd be psyched if I ever got it. But Google it and be familiar just in case.
You are? I currently know of no plans to really do it. It was experimented with it, but there is no plan to do it in the future.
If you have $5 a month, digital ocean has ready to go gitlab instances, you can fire it up in minutes. 
 $result = curl($searchString, false); $result = json_decode($curlData, true); echo "AFTER SECOND CALL"; var_dump($result) Don't you want: $result = curlSearch($searchString, false); $result = json_decode($result, true); echo "AFTER SECOND CALL"; var_dump($result) ?
Yes but it does show that you actually understand fizzbuzz and aren't just memorizing it. Fizzbuzz and Fizzbuzzpop are not very hard because they test whether you can write simple functions not whether you are a good programmer.
So, this isn't a help subreddit. I believe that is over at /r/phphelp. But why not just a loop? Have an array of date days you want, then $values = ['first date', 'second date' ]; //Insert your loop mechanics. //for ($I = 0 ; $I &lt; 10 ; $I++) { $key = "my file $I.txt"; $rtn[$key] = $values[$I / 5]; //} I think if you pressed for an answer here, you would get a lovely OOP methodology using iterators or recursion. But without context, that's an outline how to do it. If you need more, check out the phphelp subreddit, or Google a tutorial on php loops. Also, sorry for formatting, and the I var being caps... I'm on mobile 
Thank you. And thanks for pointing out that my last name was actually butchered. Didn`t realize it :P
&gt; Is it correct to use a switch statement in the service provider to determine which class to register? I think there are better ways than using a switch statement. &gt; The abstract class is responsible for instantiating a Guzzle client The guzzle client is a dependency and should be injected in. Something similar to this is how I might do it: &lt;?php class SomeServiceProvider extends ServiceProvider { public function register() { $this-&gt;app-&gt;bind('github', function () { return new GitHub(new GuzzleHttp\Client()); }); $this-&gt;app-&gt;bind('bitbucket', function () { return new BitBucket(new GuzzleHttp\Client()) }); $this-&gt;app-&gt;bind(GitServer::class, $this-&gt;app-&gt;config-&gt;get('something.gitserver')); } } This obviously copied after Laravel, but whatever.
If you are looking to learn PHP, I'd recommend O'Reilly PHP books: they are a great resource, which I used at the start of my career. Regretably teaching someone a programing language is a mammoth task, but there may be classes at a nearby night-school / college, so I'd check that out too. Finding a teacher for free may be possible, but finding someone to build your website for free isn't going to happen. My bread and butter is building websites, and would expect payment for this kind of request. I'd recommend hiring a freelance developer for this. Sorry. Edit:spelling 
Using generators like phpmaker isn't bad in itself, as long as you still understand what's going on "under the hood". The biggest problem I usually see with generators (and this doesn't just apply to ones like phpmaker, but also html editors / generators designed to let non-technical people build their own sites) is that the code they generate is frequently a horrible, convoluted mess that is difficult to understand and even difficult to impossible to modify and maintain if you then want to change it in any way (and once you change it, you often can no longer use the generator to update it - it's all manual from there in anyway). So while they might be fine for simpler sites, frequently in the long run they are much more trouble than they are worth.
The Doctrine Docs explain anything and everything way better regarding DataMapper than I ever could. Why would you I try to condense in a few lines, what is in fact complicated and has several trade-offs associated with it? 
Oh god no
In the example they have a newline after the username and password, have you tried that? http://phpseclib.sourceforge.net/ssh/auth.html#noauth
That would be correct in most organizations, my (where I drive interviews) included. You are absolutely correct in that when I see that from a candidate, I debate whether or not that counts as a premature optimization, or doing something redundant. However, the reason I listed and the follow up question comes directly from Facebook's technical interview prep course. I'd expect similar trains of thought from other major social media companies, where some of the algorithm could be hit hundreds of thousands of times per second, and such kind of micro optimizations could result in savings of racks full of equipment.
Why can't a method return null if something else is declared as a return type? For example, if we have a method that gets user's data from database by id and returns User object if the user is found and null otherwise. Am I misunderstanding something?
at this level you should worried about your IQ level bro
&gt; I would be interested why this comment is downvoted. Yeah, those are my favorite. "I disagree. I won't tell why. Have a downvote." :D 
Although frustrating, sounds like it will help you improve your debugging ability by continuing to work on this project. Don't just quit (unless it really is destroying your soul) but nothing stopping you looking for the next step while plodding on through it. Have you asked your manager if you could refactor it as part of your involvement? Sadly not every job/project is enjoyable.
(ง ͠° ͟ل͜ ͡°)ง
I don't mind that it's frustrating. It's part of the job. I do mind however, that since I've been, I've learned nothing, and I mean nothing.
&gt; "fix" is not the exact word I'd use here. Rather make it less broken. I don't mind that I'm stuck on an old project, I do mind that I've learned nothing new in my time here. If you have the chance to upgrade a 4.x codebase to PHP 5.6 and refactor the worst parts of it to something better, that might as well be the most educational experience in your life. It's easy to keep starting over clean, it doesn't require skill. If you're given mandate to improve the codebase, it's an interesting challenge. If not, that's something else.
Not sure if I should trust you username or not. But really now, you make a fair point.
http://lmgtfy.com/?q=html5+video+mime+types&amp;l=1
Suck it up, bust your arse and prove you are ready for something better. Document, fix, rewrite, improve. Whatever, it's your opportunity to show what you got and you want to quit? Is there a reason you can't look at newer and more exciting approaches to bring back into this old code base? As a lot of the other replies state, as a programmer (especially php). Maintaining and migrating old code bases is going to be a big part of your future.
Easier, sort of, but is it correct? If a unit's responsibility is correctly communicating with BitBucket, and you test it against a fake HTTP client, you're still not testing this unit's responsibility. What can be done is fulfill this unit's responsibility by communicating with a local facade API that talks HTTP with BitBucket. The API will be separately *integration-tested* using a test account (the facade will change rarely so slow tests are irrelevant; accuracy is more important), and the mock the services will be tested with is going to be of that API, and not of Guzzle. In fact, many services provide such tested APIs for PHP already. You're less likely to mess up a mock of a PHP facade than messing up a Guzzle HTTP client mock that tries to stand in for BitBucket.
Thanks, I do understand that but I don't understand the route, what does this match exactly and what is "path"?
Pretty sure you've learnt how awful ancient apps can be :D
one man's trash is another man's treasure. Some of us are unfortunate enough to even find a job.
I'm looking at revising 4.x to 5.6 as well. Not too excited about it.
Thanks for the input, you see our problem is twofold, our team does not have experience writing tests and at the very least we're in search of an experienced tutor (which I believe I found already, we've already arranged a meeting) *and* the existing system has stability issues in its most complicated parts - when updates are made, something else breaks and we need to at least cover those places. Again, however, we need experience which we don't have to refactor these parts correctly *to be ready for testing* and not bite off more than we can chew. I will watch the lecture you linked, thanks again for pointing the way.
This. If you're allowed to do that (by your managament or whatever) it would be quite unique experience and you would learn a lot.
Thank you both for the surprisingly civil discussion **and** the insights. As I mentioned, I've already a meeting lined up with an expert that can hopefully give us hands-on mentoring and provide observation, but I want to find out as much as possible to ask good questions and foresee implications of suggested solutions.
one common misconception in the field is that junior devs get "mentored" and learn from "seniors". the reality i think is that seniors are just juniors peppered with years of experience dealing with all kinds of crap and problems thrown at them. the learning is entirely up to you. always think that every bad project that you get thrown in to is a low hanging feuit for you to pick by making things better. there's a lot of value in that. 
Thanks, we did some work with functional testing too and are also playing around with Selenium, and just generally throwing chaotic ad-hoc effort into improving the code base stability, but we simply lack any procedure due to frustration from inexperience and there's no one to guide us. It's just wasted resources and I'm striving to build real-world practices and guidelines for our workplace that everyone could follow effortlessly and am meanwhile looking for as much insight into this as possible, thanks for taking the time to help :)
First, upload the files to godaddy: https://support.godaddy.com/help/article/96/upload-files-to-your-website-ftp It might be easier to start on a local server that you can install with either [WAMP (Windows)](http://www.wampserver.com/en/) or [MAMP (Mac OS X)](https://www.mamp.info/en/) 
if you're not going to stay, find a different job THEN quit.
Maybe the OP can work in a place with a modern codebase and senior devs who can help mentor him. Better than staying stuck in the trenches with an ancient, legacy codebase with no peer support.
&gt; I wouldn't discourage PMA use, if used properly. Physically impossible given how insecure it is.
I use it on OS X and it's very buggy at times.
Hi, Exakat is a static analysis tool, yes. But focus on PHP good practices. PHP_CodeSniffer is more focus on coding standard. By the way, we have published a new release fixing bugs. 
ProcessWire. It's stupidly easy to use and is ideal for lots of different content types.
Maybe they want to see what you can do. It's one thing to hack away at your own code it's another to be able to fix code someone else has written coming at the problem with a completely different mindset. If you can't even do this or complain about doing it why would they put you on a more important project?
&gt; I thought the whole idea behind being a junior was to learn new things, not get stuck on a 10 year old project. You think they're going to put a fresh junior on their latest and greatest greenfield project? are you deranged? you learn from dealing with old, buggy, shit code how to be a good dev, then you get to play with the new shinies. Put your time in kid, take your lumps, you've a long way to go.
It matches everything that hasn't been matched by a previous route. `{path?}` is an optional route parameter. It's there so that it matches all URLs and catches them as a parameter (that may or may not be used).
I've seen some others' posts and I entirely disagree with them. "Stick it out" is not an appropriate mentality. That being said, I would follow some of their advice and identify ways to improve the code (refactor, redesign) and make those suggestions to your management. More than likely, one of the following will eventually occur: 1. let you try to improve the code base in some meaningful way 2. tell you it can't be done right now and hand you a list of bugs/defects/features they **need** 3. deny you outright and tell you that major refactoring of that old codebase isn't going to happen I'm inclined to believe - based on first hand experience in the same situation you're in right now - that eventually they will either pull a 2 or a 3. And when/if they do, start looking for another job. I suspect that the reason you're stuck working with an ancient 4.x application that might need so much work is because no one from the management level has allowed any significant improvement / refactoring work to occur on that project. That's a huge red flag for a bad, will-become-worse, work environment.
you're going to have a short career if you bail every time you need to update/fix/work on a legacy project.
I can't give you advice but I can share w you my opinions. IMO you should always be learning and if you're not you are wasting your time. Also, the point of work is to prosper, not be miserable. If you can't come up w a reason for being there then you shouldn't be there. Seriously - what is the point of you being there? Finding a place that is good is more difficult than you think it will be. You'll need to be more finite in your decisions in the future. Also, advice is personal. If you ask for advice from people you don't know about something they arent living then you'll get a bunch of opinions masked as advice. 
&gt; I could use some advice The real problem you face isn't that the current project sucks - it's that the company you are working for sucks. If a manager lets a project get to be that stinky, and then sticks junior people on it because the other devs refuse to work on it, that is a real problem that isn't going to go away just by moving to another project. &gt; Do junior usually get assigned to 10 year old projects. It happens at shitty companies, that don't care about retaining their junior staff. &gt; I'm thinking of quitting and searching for a new job. I don't recommend that. Instead: * start searching for a new job. * be aware (possibly even by repeating out-loud to yourself) that you don't care about keeping your current job, and so deliberately force yourself to stop caring about it. * do slightly more than the minimum required to not get fired in your current job. * try and improve the code base by writing a little documentation, a few tests here and there. Small improvements will make it slightly less awful to work on the code, and is good practice for improving any application. * don't worry about trying to improve the company. First it's not your job to do that, and second it is almost literally impossible for a junior dev to alter a company's strategy. * If you have left over energy for programming at the end of the day/week, invest that energy into your own projects, so that you have something to enthuse about at your interviews. The reason for this is that if a candidate comes to an interview and is just negative about the programming they've been doing, it's a real downer. But if they can say that they're not proud of the code they're doing at the company, because "look at this awesome thing I'm capable of doing which is so much more awesome than maintaining a legacy code base", it's far more positive and likely to lead to a job offer. In the worst case scenario you could get fired, but you're thinking of leaving anyway, so who cares? When you get offered a position at another company, you then face a choice of either: i. just leaving quietly. ii. ask to have a chat with either the CTO (or appropriate senior person) to tell them why you're leaving and why you're going to advise people not to work for the company. I've mentioned doing ii. in this sub-reddit before and apparently people think this is outrageous.....fuck that. Being a senior dev is at least in part a state of mind, not just a level of technical knowledge. Being able to have a non-confrontational discussion with people who run companies about what is wrong with the company, and how it could be improved, is just a fundamental part of being a senior dev. Obviously if the people who run the company are just ....not nice people, then there would be no benefit for doing so. But if there's a chance you might want to either stay there or be able to go back to the original place if only they'd improve things, then it can be worth it. It can also give you closure as you're able to say to yourself, that you tried to improve the company but they wouldn't listen. &gt; but I thought the whole idea behind being a junior was to learn new things, That's another discussion entirely....but yes, being stuck on a legacy project is not good for junior devs. 
Refactoring is a skill all in it self. People have written books on that.
I've been writing code for 3 months, I don't think I'm qualified to even read those books, let alone refactor such a huge site.
&gt; You could just as easily say its responsibility is to create request bodies and parse response bodies, regardless of the transport with which the requests/responses are sent. I get your point, concerns are subjective. But my example was separating protocol from API, which is a very good point of separating concerns, because you don't have to mock the protocol &amp; many APIs are available over multiple protocols. While your example is... just bad. &gt; However, for the sake of fast unit testing I will almost always have at least a few request and response bodies saved to the local filesystem to test against, and in order to do that I'll have to replace the HTTP client somehow. How would you compare if a sent request matches your saved request? You can have two different requests in terms of *text* which are equivalent in terms of the HTTP protocol. And you can have them be different in terms of the *HTTP protocol*, but equivalent API calls to BitBucket. You basically have two options for your mock: 1. Ignore the request or at best regex match some bits, and just give the next response in order, which means you're not really testing if the request is correct. 2. Match the requests blindly, and any difference would fail the test, like slightly altering number formatting, quoting or order parameter in a way BitBucket would consider equivalent. In the first case you see green in your tests, but since you're only pretending to test, the tests serve no purpose. This is basically "mocking the test". Looks like a test, reads like a test, produces code coverage like a test, but *doesn't test*. In the second case this is what I call "an implementation hugging test" - a test which is so specific, it tests circumstantial conditions of the current implementation, and any deviation might turn it red. Such tests test: "did the implementation change". You don't need tests for that, git will tell you. To make effective mocks, the mock should be for an object which has a focused, tight interface and clear behavior that reflects its responsibilities and nothing else. This makes it easier to mock the behavior of the actual thing, and not some broken approximation that tries to bite more than it can chew. Another good reason for using single-responsibility objects is that they don't change all the time. A class that maps API calls to a protocol will change only if the API or protocol change. And only *then* you'd change the code, so only *then* you'd have to re-test. But your saved HTTP requests &amp; responses would no longer be valid (because the API or protocol has changed).
I'm not on my own 'per se', there's me and another guy(senior I guess). I see the point that other people are trying to make, but on the other hand I also understand I'm not qualified to even dream of refactoring this site. I may be a slow learner, or just dumb to begin with, but I really do know when something is beyond my pay grade, so to speak. Assuming you're speaking truthfully in your reply, I'll take your advice into consideration.
Nobody expects you to do it in a few lines. In fact, you should explain it as thoroughly as possible, or at least provide direct links to the resources that do. You know that this is a complicated subject, so what makes you think a single link to a project's homepage answers the question? You even JUST said that there are trade-offs associated with using the DataMapper pattern. Why didn't you mention them in your original answer? Does the Doctrine documentation go over those trade-offs? What are those trade-offs? Are there any other articles that support this? And no, Doctrine doesn't have the best examples of how to implement the DataMapper pattern properly. Doctrine has the best examples of using Doctrine properly, and it just happens to use the DataMapper pattern. You asked why you're getting downvoted; that's my answer. And it's a lot more than a single link.
Wait, have you been writing code for 3 months...total? Or at this job? If it's the former, then this is a great place for you to start. I started by *writing* my own terrible legacy-ish code, then refactoring it as I learned more. If you are a trained PHP dev, this is a terrible waste of your time and, I don't think, as helpful as some optimists are making it out to be. Especially since the skills involved are much less likely to transfer to other languages and therefore job opportunities.
&gt; I may be way off here, but I thought the whole idea behind being a junior was to learn new things, not get stuck on a 10 year old project. You don't get to pick and choose at this point. There is probably plenty to learn on a legacy project.
My current employer is on cutting edge ASP.NET MVC stack and maintains bleeding edge on all tech in the office. That said, I am leaving this organization for a PHP/MySQL shop in desperate need of developers willing to slog through the thick of an outdated code base to make it better and update it. I am already established in my career and understand the value of making my way through other people's code (good or bad) in order to learn a thing or two to improve my own skills. As others have already stated: Do not quit this job. You just started your career and you have now gone from "green field" development of your own projects to a "brown field" project that needs some rehabilitation in order to bring new life to it. This type of development is why many developers get paid big bucks to work on legacy systems. Do take this opportunity and run with it. If your management team is favorable and you have a good report with them, or are at least working toward that, these are the intangibles that you may not find if you jump ship now. I've worked on project teams where the team has been awesome but the project has sucked as well as the other way around. I'd take a shit project with a great team any day of the week over a decent project with a shit team. A great team will allow you to bounce ideas around and share experience among your peers to make the shit project better. A great project does not have the same effect on the shitty team ;)
Vagrantttttttttttttttt
Another possibility is that they have been understaffed and hiring a junior to make sense of the mess is what they needed. I'm currently the sole developer at a company with a 4.x legacy codebase..... shoot me.
And you might be surprised how many people fail on such a simple addition. It is the difference between having memorized a solution and understanding the solution.
That's exactly what I see them doing. Have a low cost Jr. sift through the mess that they've reaped over the years by not giving a shit. 
If you're going to find a new job, do it before you quit. Don't job hunt while unemployed if you can help it.
True.. I don't actually know what fizzbuzzpop is, but I assume it just adds an additional dividend to test..
See, I would LOVE LOVE LOVE this job. I haven't done serious employable coding since PHP 4 but would love to get back into it. If anyone in Philly needs a PHP 4 code maintainer with Linux admin skills and a support background... 
Again, I've been in that situation before too. In my instances it turned out to be because they were a software company that didn't value developers... So we were always overloaded, didn't have enough resources, and often working long hours or in highly stressful conditions. 
Yea, this is good stuff. I like how it makes you think. I'm going to use some of this in the future. Thanks.
Are you one of my coworkers?
Not to mention their upgrade systems are awful.
Sure you're qualified to read those books. Nothing like working of a solid foundation. Sadly many php developers are notoriously known for lacking those, giving php in general a bad name. So read your books and do it right from the start.
Great advice, very professional, and should be top comment.
That's like learning English, and asking "which words should I learn". The best way is to be curious and expose yourself to an environment of peers who use those patterns and talk about them. Also watch plenty of presentations like on InfoQ.com, YouTube and Vimeo, where people share techniques and experience. You can, of course, check the (in)famous Gang Of Four "Design Patterns" book because it has coined many of the popular ones. But it's truly like natural language. We do try our best to use the same meaning when we talk patterns to each other, but there's no definitive list, no canon, no law: it's constantly evolving. The only way to learn it is to live it. I have to say, in the web developer &amp; scripting communities (not just PHP), you're slightly disadvantaged about learning architecture at depth, because people tend to have more superficial understanding about it all, and the use of patterns is more buzz-wordy, people like the way pattern names sound, so they use them to sound authoritative, whether they get it or not. This happens in all communities, but I do find it more the case with the communities of PHP, Python, Node.JS and Ruby. So one of the best way to get a good feel for it all is to also keep in touch with people who program in Java, C++, C#, Objective-C, Go, Haskell, Erlang, Rust and so on. No need to specialize deeply in any of those, but see what they think, how they work, what they know, and over time your brain will learn to tell apart true wisdom from B.S. **EDIT:** P.S.: The best way to learn patterns isn't to ask "which pattern should I learn", but to describe a problem, and ask people "how should I solve this". Patterns will naturally get involved in the conversation.
So far not - it's been very stable. But it's an experimental setup anyhow. I'm only running H2O for this specific site for stability testing / learning.
How do you plan to explain to wherever you want to work next that you quit a job after less than a few months because you got stuck working on some legacy code and didn't like it?
Do you enjoy your job most of the time? If no, can you afford to quit (as in, you and your dependents will be fine while you look for a new job)? If yes then quit else stick with it until you can afford to quit.
I find the pattern of starting a project and finishing it to be a great one ....sorry for the sarcasm, but really, you should focus on building functional, real-world applications or functionalities. This is the best experience.
So what's the purpose of this video exactly? "Those pattern names aren't that good, use mine, which I just came up with and only I use." Pattern names are about communicating code structure *and intent* to another programmer. Merging them because they have the same code structure, but different intent represents a gigantic missing-the-point of patterns. And coming up with one's own NIH name alternatives for familiar ones we all use represents another.
I'm all about character building and learning important but un-fun things. Still, let's not piss on OP's leg and tell him it's raining. First, /u/xtrategist is right on some things. Working on old codebases can teach you a lot of things you might not know and this might be valuable. You'll know best what's teaching you (and what you want to learn). If you were brought in to a company which needed someone to suck it up and was giving back to that someone in other ways (mentorship, pay, other opportunities), that's one thing. But hard things aren't good to do just because they're hard. And there's no reason to "prove you can take it" unless that clearly leads to an opportunity you want.
The main purpose of this video is to show, that patterns is just an communication tool. If you already respect SOLID and GRASP, then you (probably) already use all this patterns.
Management in a project with this kind of history will view such actions as nothing but a waste of time. I wouldn't be surprised if they didn't even let him bill for them.
I made some inferences from my experience and your description. I take it there is not a current ongoing effort to refactor or rebuilt the application. If there were you would be learning some more modern techniques, there would be more interesting work, etc. Given that situation, to suggest you take the initiative to rebuild/refactor the application means you would at least start that effort alone, although if you succeeded in convincing them they might all join in. If you could convince them of that it would be great, but this is what I meant by you doing it alone. In either case from the sounds of it, I would not be hopeful in regards to getting a new project started. If you weren't hired for the purpose of refactoring the application, they probably aren't going to give you the time to do it. They needed someone to fix bugs and do whatever it is your already doing - thats what they will insist you do. Others do have a point that you should make the best of your current situation. You should look for things to improve and better ways to do things where you can, learn what to avoid and how things got so bad. If you find something especially bad, do some research on how that problem can be avoided. Even if you don't get the chance to make those changes it will at least educate you. You can learn from the mistakes in this project - from the business to the management to the development team to the codebase itself. Try to learn about why this is the way it is, and why it can't be fixed. This can be a silver lining to a dark cloud, but it doesn't stop the rain. I suggest you take advantage of your situation to find a new job. Don't simply quit, but start your search while still employed. This will give you leverage if you wish to negotiate, and it will allow you to be more picky when accepting jobs, since your already employed you don't *need* the job. I know this isn't the case for everyone, especially someone who's new - and it of course depends on where you live. Just putting yourself out there doesn't hurt though. Worst case scenario, you dont find a new job and just stay there anyhow. Best case, your phone rings off the hook with new job openings. Like I said before, just remember to question your perspective employer (management as well as developers) about the work the team does, how there documentation works. Ask the developers who interview you what new interesting things they have learned or worked on while at the company, ask them what frustrations they face, and how they have been/are being fixed. In our industry we can be more picky than others, its a privilege not everyone has so take advantage. Remember in your next job search that its a two way deal - they have to want you, but you also have to want to work for them. Again, good luck.