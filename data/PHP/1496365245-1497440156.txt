thanks man
Sure, prefixing is hardly an issue. :P Yea, it won't appear beside the items as they are defined. But clearly the composer team is not going to allow that. So using `extra` is the best choice we have without making muddy JSON structures that could possibly end up causing broken things later. Or maintaining yet-another-file completely to do the task. It's simply the best option to get the job done.
Can confirm. Have just over a year of professional PHP dev experience and I picked up Twig solo in about an hour
Agreed.
Depends on the platform, but having a project specific to it that you manage is a great calling card. A package on packagist, a WP plugin, a Drupal module, etc. I don't think there are barriers even for any of these - just code it, publish it, and manage it well. 
This is a really cool idea 
It only guesses if you omit it. You can put the full thing in there if you'd like. `{{ user.name }}` and `{{ user.getName() }}` both work if you don't like it. 
&gt; We are designing our encryption system update to softly move from one method to another without having down time. Basically update the rows using the new function as it touched. Has anyone else done this? I can't go into the specifics of what I've done before (or, more importantly, who it was for) because that work was done under an NDA. However, I am a co-author of [Defuse's PHP encryption library](https://github.com/defuse/php-encryption) which uses version tagging from version 2 on, but did not include this feature in version 1. We designed the interface specifically to allow these gradual upgrades to be performed gracefully. I can probably do the same, or something similar, to help with your migration problem. My company's contact information is [here](https://paragonie.com/contact) (along with our GPG key) if you want to discuss solutions.
&lt;IMO&gt; A some [often good] employers: add meaningful automated test coverage and coding standards to those same projects. Most employers: write a book about code (self-published is fine), speak at a conference, start a SaaS app (doesn't matter if it's successful), quantify the commercial success of the projects you've worked on, quantify the amount of money you've saved the companies you've worked for. &lt;/IMO&gt;
And if that doesn't work, build something small. When your developing do you ever have to repeatedly do a task? Build a command line app for that. Build a command line app that adds an event to your Google calendar. Something simple with params. Then add the ability to query your calendar from the cli. Then the ability to add notes to an event. To move an event. Etc. Then on to once you have five or six useful features, build a natural language processor (or something that spoofs it like a chat box). Another idea, a command line app that queries composer to see what the most popular packages are for the day 
Sorry, I didn't see that you'd already built a few projects. But the idea still stands. Simple cli apps (artisan or just symfonys CLI) are so underrated because they are so useful. Most apps you have to go to a website or do something. You're already in the terminal all day so it's right there.
For your current requirement WordPress + WooCommerce combination is the perfect fit. Go with it. Or else you could start from scratch maybe with Laravel.
It doesn't. Not from **WordPress** developers. It does from some non-WP developers who are asked by clients to develop in WP. WP has a massive user base, and a huge ecosystem. WordPress as a development environment is highly opinionated. There most certainly is a WordPress **way**. It also has plenty of faults, mainly due to its high level of backward compatibility, and due to the quirks of its development history. Choose it because it gets the job done. Use something else if it would be better at doing the job. The irony is that PHP itself is harshly critiqued by many non-PHP developers, almost in the same dismissive way as WP is critiqued by many non-WP PHP developers. There's a lesson in that.
It's a behemoth of spaghetti code that's written like it's still 2005.
Php is a scripting language. Any app you can script, you can write in php (that's a lie but anything you'd do as a webservice you can write in php). https://laravel.com/docs/5.4/artisan http://symfony.com/doc/current/components/console.html They're the equivalent of click in Python and commander in Js/node. Most people who want to showcase php build a website they'll never use. It's better to build app that actually adds value. Therefore skip the HTML and write something you can run from the terminal. With php you typically concat it into phar script at the end so you'd run in like a normal command even though it's php. Laravel valet is a perfect example of a php cli app. Check the GitHub. It does use some bash for installation though but that's was exec is for. PS artisan is just a wrapper for the symfony component. You might as well use it as you can do anything in artisan you can do with symfonys console component.
Slow, insecure and has tons of annoying spam bots targeting it. But for a small shop it's good enough. 
Do not try to impress an employer. All employers are different, have different needs. What will impress one employer, another will not know that it's something they should be impressed by and have no clue why it's supposed to be special. You should develop something that pleases you, that you are passionate about. The quality of the work will be 10x better and when you speak about the project in an interview you will come across 10x better. Even if an employer has no clue how special your code is, they will always be able to pick up on your enthusiasm if it's something you're really enthusiastic about. What can you develop that will impress yourself? What kind of project really inspires you? Use that to build something and push your coding tools and standards to the next level.
Much like Windows, which indeed does "just work", the size does not imply quality. It's more like self-feeding vendor lock-in.
I have around 7 years of experience and started developing in wordpress like 2 years ago. While freelancing. The problem with wordpress is that it didn't evolve its elementary way of doing things. The benefit of wordpress is that it didn't evolve the elementary things. Advantage: it still works, all ecosystem of wordpress never lost community etc What am I talking about? Plugins, hooks, events. There is around 2000 of them. Those are magic words to attach a function, in some order. When reading a post a bunch of attached functions are called. When saving a post a bunch of functions are called. There is 2000 of these magic words this used to be done this way back in 2005 or earlier. But this is not a good way any longer. Use laravel and you will see. Events aka magic words and basically invisible functions are very hard to work with and create a huge mess. Woocommerce is an example of a very bad shop. Having said that, woocommerce is very famous and thus you will find stuff online
and yes an alternative shop I cannot recommend, I worked with aimeos and laravel and things were better. But: they have not a lot of plugins, bad documentation and things were buggy. Is it better than woocommerce? yes! will you get done your shit sooner than with woocommerce? most likely not. Not sure
My problem with WP isn't really the code but the functionality. It purports to be a CMS but it lacks many basic features that a CMS should have. For example just yesterday I was trying to figure out how to add a submenu to the sidebar. But you can't add anything to the sidebar in certain pages, it's all or nothing. You need a plugin. But even then, you still can't do a "submenu" per se, you need to manually add items to the menu, and keep it updated manually. Even Joomla manages to get this basic shit right. 
I look for tests, consistency in activity, and passion projects. All are pretty good indicators and haven't really failed me so far.
&gt; WordPress as a development environment is highly opinionated. There most certainly is a WordPress way. Can we please stop hiding blatantly poor engineering behind the word "opinionated". No experienced developer would look into WordPress and call it good code. 
As a PHP consultant, you understand that global variables are to be avoided at all costs and have no reason to be used. WordPress is full of them, and that only would be a reason to dismiss its code as utter shit.
Try to do something that impress yourself, every employer has different needs. Make something you like, make it good, and you'll probably find someone able to appreciate what you did. It will also help you to keep earning experience on the field.
As someone who recently got recruit via my Github, Just write anything that interests you, this will garner the best output for your project to impress. My Github is full of network stacks and automatic tasks, 1 task has 4 writes in a year. My employer says that as long as you demonstrate knowing the language and best practices. Not using a framework for a project that clearly doesn't need or benefit from one.
I look at candidates the same way. I never hire someone without having read their code. It doesn't matter all that much what it is, as long as it is good code.
&gt; WordPress is a blogging platform, not a CMS, but in any case it doesn't. From the Wordpress about page: "WordPress started as just a blogging system, but has evolved to be used as full content management system" &gt; That's not WordPress, it's the theme. How is it the theme? Menus and Widgets are native WP features, I don't think it's too much to ask that they work together. &gt; That's just because you know how to get basic shit right in Joomla, and you don't in WordPress. Not really. I figured it out in Joomla in 10 minutes. I've been working with WP on and off for years (and for several months with this current WP site) and I still have no idea. That's a failure of UX and/or functionality.
As a heavy command line user I don't see a benefit in it but for non-cm users it for sure is a nice addition to their tools set. 
It depends. For a small site/shop, it's the easiest/cheapest/fastest ( to be online) as you can get, in any language. If you want something bigger or lots of specific customizations, you are in hell.
Can you come up with an actual use case where this is ever an issue ? The only usecase for returning a new instance instead of the current instance, is when your concrete class is (or should be) immutable, in which case this seems expected behaviour.
Very good points. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
How about SOAP?
AKA "How to use security voters in Symfony"
_thousand yard stare commences_
Build a profile helping people, perhaps on Stack Overflow. Quality of posts is more important than points. I just spotted someone at 200 rep (i.e. very new) who is giving some really awesome help in SQL. Pick a theme/tag you enjoy working with. Only add answers that add genuine value - there are loads of rep-collectors on SO, and their contributions are often counterproductive (we have enough answers containing SQL injection vulns to last a lifetime). Communicating as a dev is pretty important. My helpful feedback now is that if I saw your above post as a potential employer, I would see the mobile-phone posting, missing apostrophes, incorrect casing and txtspk, and it would not aid your job application. People who make an effort to communicate generally are better at describing technical challenges. This is especially the case for remote positions, where an ability to articulate clearly in writing is even more critical. 
Just look at his code base and you will find why... Someone here has worked with cherry framework (wordpress theme "framework") ? how we are supposed to stay mentally healthy with those kind of shit!
I agree. Wrote that because while we will explain him with theories so long that why WordPress is hated he and his friend might have already got done with the e-commerce website for the flower shop. It isn't going to be a huge project, so since already they had almost decided over WP &amp; WC combination, why not confirm that they can achieve this particular target with it. 
Who said that ? Numerous big enterprises app are made with Laravel. Eloquent is perfectly efficient at scale. What's your use case ?
 &gt; active record [...] isn't efficient It's mostly about keeping concerns separated. Large applications need very strict separation, which is why solid design is absolutely imperative. The entire "micro-services" fuzz you hear around these days is because there are thousands of companies with unmanageable monoliths, and they hear "separation" as "omg, it's gonna fix everything!" (wrong, but whatever). In any application large enough to have, say, 15 people working on it, you absolutely want to keep clean boundaries, with framework and domain logic not leaking into each other. You have to think that every leak will be multiplied by the amount of people touching it without full understanding of what is going on. More people =&gt; more chaos. That said, I'm not touching the rest of the topic even with a stick.
Quite a few developers who I have worked closely with who are very skilled PHP devs. But I wanted to put this question to a larger community to get a few more opinions from different backgrounds. I don't have a specific use case, I was just talking in general. Have you got any examples of "Numerous big enterprises app"? 
I think there's a handful of reasons. There are definitely developers out there with a total grasp of their entire domain that make very logical decisions for choosing particular technologies, and they tend to be the ones writing good articles about the why. Then there are people (myself included) who have a good handle on things, but don't necessarily always do everything right, or always have the previous experience to think through all the implications of a choice when one is made. Then there are people below that. I personally think there are a lot of people in the 2nd and 3rd category that read one headline or see a few people espouse the same belief, and so they begin repeating it, because they've seen it said by someone they respect. Some of it is true in all cases, some of it is true in some cases, and some of it is true in very few cases, but unless you truly understand all the implications of a choice, it's going to be hard to determine which is which. There are also people who have a personal hate for some particular pattern (ActiveRecord being a good example) either because they've been burned by it, or they've seen people talking poorly about it. At the end of the day, you have to choose something that's right for you. It's easy to write bad code inside Symfony, CakePHP, Laravel, Django, and Express. It's easy to write bad Go, Scala, or Javascript. There are frameworks out there that do things the 'right way' and frameworks that do things the 'wrong way', and there are a lot that do things in the right way for some people, and not others. At the end of this, my point is - if your question is high level, you are only going to get high level answers. Why isn't Laravel suitable for enterprise? Short answer is that is not a valid question. I've built (and continue to build) a very profitable, enterprise application using Laravel. We use Eloquent, and I often go around it if I need to. I have always had to do this with every ORM I have ever used. I think there are better ORMs out there, but we chose Laravel because we needed to get the company off the ground rapidly, and it really helped us do that. The question you should really ask yourself is why do you choose CakePHP over Laravel when building your own, more complex applications? If there are no real reasons, try building an application in Laravel. Experience trumps everything.
I used to work a design firm that was set on using WordPress to power web applications and it was pretty much a nightmare. The expectations our boss had on us were rather insane considering the technology she would sell clients on. They used a React/WordPress REST API combination that I was not favourable to at all. CakePHP 2.x uses an active record pattern for its ORM very similar to Rails, but the new CakePHP 3.x ORM is kind of a hybrid DM/AR pattern with its use of Tables and Entities. I personally have come to really enjoy the CakePHP 3.x ORM and use it as my ORM when building APIs out with Slim. I have never used Yii, and have no real opinion on it. I don't see a real reason why Laravel can't build enterprise grade applications. It wouldn't be my first choice, but it is definitely a viable option.
Re 2) The ORM in Cake3 actually implements the Datamapper patter, but also includes some ActiveRecord ideas so you have to write less boilerplate code compared to Doctrine for example. It's quite neat: https://book.cakephp.org/3.0/en/orm.html
Laravel is the slowest popular framework I'm aware of, and its architecture makes many easily avoidable errors (like single global autowiring container, heavy reliance on dynamic/magic methods and properties, Active Record ORM etc.). That said, one enterprise app is not like another. It depends on your needs. In general, you shouldn't be coupling any enterprise app to a *web framework*. The web framework should serve as a thin front-end layer for the UI of your app (i.e. web site, web API), and not be intertwined with the guts of your business logic.
https://secure.php.net/manual/en/pdo.prepared-statements.php
&gt;2) Cake and maybe Yii also uses an active record orm CakePHP uses data mapper. &gt; Curious about some of the reasons for using wordpress to build apps. Not trolling just interested in your use cases I knew someone would ask about this, hence the brackets haha. Really, it's a case by case decision but the primary reasons are: * **Back-end** - It's easy to use and has built-in user admin. * **Common** - Widely used, many clients already have WP experience. * **Plugins** - Huge abundance of plugins means that we can add new functionality without having to build it. (Eg monthly billing or CF7 can work as a simple feedback form) * **Quick** - It's very quick to build apps (see above point), thus less cost for the client. * **Developers** - On the rare occasion that WP is a viable long term solution is it cheap for clients to hire in-house devs as they grow or for us to hire new devs if the project requires additional help Key point: We only ever use WP when we believe it's truly appropriate and I am aware that WP is NOT a good long term solution but in some circumstances (cash strapped startups or for market validation for a new idea) WP is the best tool for the job. I am aware that you can swap components of Cake and Yii but i was really wondering is there any glaringly obvious reasons why laravel isn't a good framework for building large scale apps.
&gt; From my discussions with other Symfony, Yii and CakePHP devs Laravel's active record ORM isn't efficient at scale compared to datamapper Datamapper by definition would be slower than active record out of the box. But datamapper gives you advantages that active record does not ( for example writing entities as "full" citizen, not just a proxy to db ). So maybe they didn't mean performance issues, but rather architectonic ones ?
The title of the reddit thread literally says "light weight build tool".
lol, we should definitely listen to someone who writes code like this: https://github.com/Ocramius/ProxyManager/blob/master/src/ProxyManager/Factory/AccessInterceptorValueHolderFactory.php
This is literally how I score a candidate profile \#1 Github Profile \#2 Test Projects that are complete on GitHub \#3 Test Projects that use OOD \#4 Test Projects that use PHP Unit \#5 Test Projects that use PHPUnit and have code coverage above 85% \#6 Open Source Contributions \#7 Test Projects that are complete and have a tagged release \#8 Released projects on packagist
It's good but in examples you're not using constants at all.
Feel free to find better naming for that class, without diluting its meaning: it's in my "list of things I named as best as I could".
There's an RFC for 7.2 for the purpose https://wiki.php.net/rfc/enum
Did you seriously go searching though his GitHub for the first sign of something wonky, then run back here screaming monster? Lol that is hilariously pathetic.
Laracasts is a very small website relative to an enterprise application.
Btw, I also wrote https://github.com/zendframework/zend-servicemanager-di/blob/541b3b3d165cec5a757afa0f005aea132513f48a/src/DiAbstractServiceFactoryFactory.php#L15, which is probably my worst-named class so far. I think this was 4 years ago.
The code smells but it's not as bad as people make it to be. My greatest issue is the plugin /theme ecosystem that comes with wordpress. There's some good plugins but many of them are just security holes ready to be installed. 
thank you for this, ton of value.
&gt; Laravel is the slowest popular framework I'm aware of If /u/utotwel wasn't a quitter, he would be here to tell you Laravel is more than fast enough for anything you would ever want to build!
I think there's a pretty major difference between Laravel being used by a major enterprise (which may just be for a small piece of a site or a simple API), vs. being used as a major enterprise's main enterprise application. I can't fathom any major enterprise would write their core app on Laravel. It's awesome if Laravel powers some big enterprise's website ... not quite the same as saying it powers their internal enterprise app that runs the core business. The two seem to get conflated in the marketing. 
At that level you have enough money to make absolutely anything work and it's cheaper/less complex than starting from scratch.
According to taylor otwell &gt; Symfony is a popular choice for enterprise and ecommerce applications, while Laravel is a top player in lightweight and social application development. Do you think this distinction hurts industry wide adoption of both Laravel and Symfony? &gt; Taylor: I don’t agree that Laravel is strictly a top player for “lightweight” application development. I don’t think there is any empirical evidence that this is the case, and I have discussed very large Laravel projects and deployments with a variety of well-known, enterprise clients. So it is ... according to him ... [source](https://www.cloudways.com/blog/taylor-otwell-interview/)
There is nothing wrong with Laravel. You can take it stick it behind vanish and handle pretty much anything that symfony/zend could. The long term question is how are you going to maintain it. For a start the abstractions are a little flakey, it's quite easy to stick pretty much anything anywhere are get it working. Debugging can be a real pain in the a- without a doubt laravel has some of the worst exceptions "local.ERROR: with message View::__toString() must not throw an exception" - yeah thanks. Over the course of 2 years with multiple developers coming and going and you can see why larger teams might prefer alternatives. 
NGINX php-fpm for sure! You can set it up in a couple hours following any modern tutorial. If you get the php-fpm pool size right and you will be cruising as far as accepting the connections.... performing the work in your code quickly enough is another question.
I definitely agree. For the most part, I am a Laravel fan and have used it pretty extensively. I advocated for my company to use Lumen for our API. We are mostly just using the router and a few simple middlewares.
&gt; I believe that there are even some employers that will think you won't be efficient enough at work because of your various commitments to OS projects. Sounds like an employer you wouldn't want to work for, anyway. If an employer doesn't encourage personal growth and open source contributions, that's a big no from me.
Ah didn't know that cake was using DataMapper now - they were using a rails style ORM in version 2 which is last time I used. Thanks for the detailed response. I feel that is a pretty pragmatic way to go sometimes, even if WP is not the most fun thing to work on.
My only advice would be to ask 'Why?' If you get a lot of generic statements (e.g. 'ActiveRecord is bad!' or 'XYZ doesn't scale!'), ask for specific examples of when someone ran into this problem, or some study/article that shows repeatable data. There's a hell of a lot of opinion taken as gospel in this industry. [Edit: Just wanted to say, I know this post is you asking 'Why' :) Just a general piece of feedback, as you can see some of the posts in this thread are of the 'XYZ sucks. Why? If you knew more, you'd know why' variety, which I always discard.]
There is one thing wrong with that file - it breaks PSR CS on line 59. If you think that this is an example of bad code then you are living in a dream
Why, because ... uhm ... well ... read their [coding standards](https://make.wordpress.org/core/handbook/best-practices/coding-standards/php/). They actually code like this and WP behaves like this, too. They use unnecessary complicated and weird syntax, they mix OOP and functional as they want, they have simple functions that only return a boolean, like, really, [this function does nothing more than executing `return false;`](https://developer.wordpress.org/reference/functions/__return_false) ... and they have functions [nested up to 7 layers deep](https://core.trac.wordpress.org/browser/tags/4.7/src/wp-includes/functions.php#L616). Plus: They have a shit-ton of concurrent, incompatible APIs. Most API calls are not "harmonized": some return arrays, some return strings, some accept strings only, some accept arrays OR booleans, sometimes you need to provide some sort of query string, sometimes they return, sometimes they print ... It's simply impossible to reliably use their APIs. Or themes: You can code ~~most~~ *all* of a plugins functionality into a theme. So something that should be a template for how to display the content can be used as coding platform to add all functionality you want. Oh, and their template System is so complex that there are multiple [complex](https://i.stack.imgur.com/c1UYR.png) [diagrams](https://developer.wordpress.org/files/2014/10/template-hierarchy.png) needed for explaining it.
I use `) : type {`, personal and doctrine-preference ;-)
&gt; Laravel is the slowest popular framework This is true because it bootstraps a lot of stuff for you like session creation. If you strip it all back or add everything in to the others and compare like for like there is hardly any performance difference at all
&gt; CakePHP 3.x ORM and use it as my ORM when building APIs out with Slim How is that working out? I always wanted to try using it outside of the full framework but never had time. Also it sucks that it has a dependency on 6 (I think) other parts of framework
&gt; but also includes some ActiveRecord ideas The main thing is that entities don't `-&gt;save()` themselves. Other parts aren't really part of AR vs DM discussion. It's more part of general separation of concerns inside your application. &gt; write less boilerplate code compared to Doctrine It's also a bit faster than Doctrine since it doesn't need to check property by property when saving
You don't need native support in order to have type-hintable enums, the only thing native support might achieve is less verbose syntax. That said... class Color { static function RED() { static $i; return $i ?: $i = new self(); } static function GREEN() { static $i; return $i ?: $i = new self(); } static function BLUE() { static $i; return $i ?: $i = new self(); } } function isRed(Color $color) { return $color === Color::RED(); } isRed(Color::RED()); // true isRed(Color::GREEN()); // false isRed(Color::BLUE()); // false With a bit of "magic", you can even save yourself the code and allow string conversion: /** * @method static RED() * @method static GREEN() * @method static BLUE() */ class Color extends Enum {} $red = Color::RED(); // Unique object just as before. $redStr = (string) $red; // "RED"
Yeah I don't have a good excuse at all, but all I can offer is this: I had just woken up.
Good to know, thanks a lot
So, they have enough money or they pick a technology because it's cheaper?
&gt; pick a technology because it's cheaper You are looking at it the wrong way. They have product, it's working. They have money, they want to improve it. There is very little reason to make something new from ground up, just to fix wordpress problems. Instead they can direct their money to adjusting WP to their needs/requirements. The same reason why Facebook chose to adapt PHP to their needs (and made Hack) instead of rewriting everything in C/C++
Laravel 'fanbois' vs Non-Laravel 'fanbois'... Almost... no... **definitely** as ridiculously narrowminded as Left vs Right in politics. 
I'm interested in seeing some code examples you wrote.
Yesterday I had a free day and I managed to review and merge some stuff, but that's about it. PRs need to be pristine to be accepted. Everything around new features needs careful discussion in the team, and that needs time and coordination too. It is a very slow project overall, since the core is extremely stable. Also, a mistake in the ORM usually has a lot of impact on the consumers, as the ORM often directly translates domain models, so we really check everything a dozen times.
Excellent comment. Well, it depends. From the time and risk standpoint, you're definitely right, RDS is the simplest option. But there are other factors involved: 1) Dependency on a single provider. Amazon is pretty much a choice that you are set with. You can't move to another provider (they will offer different setup). While if we go with DO, we can also move anytime to Linode, Vultr or any other VPS where we can host database server images. It's more complicated indeed, but not that much. On the other hand you have the flexibility to move OR have failover solution even with 2 different cloud providers. This problem is really significant to me and I'd rather not have this dependency. 2) Cost. Amazon is by far more expensive. However in most cases, the simplicity and 'forget about it' is worth the money. But not all cases are the same. In our case, we will be hosting a rather large number of free users as well. The main factor here is that the application is resource-hungry. Even free users consume a lot of RAM, CPU cycles and especially database processing resources. With Amazon, cost might go through the roof if we put all this into calculation. Also, EC2 instances are very expensive on traffic, database instances are 4-5 times more expensive than VPS option and I can't even think about comparing with bare metal ones. On the other hand, Lightsail is not expensive but it is too simple and limited. 3) Load balancer options. We need load balancing and failover. We can set up this with Linode and DO, however with Amazon we are forced to use the expensive EC2 instances (with even more expensive traffic) to have load balancer (Lightsail doesn't provide this). So this goes against the costs problem at 2). 4) Ping time (in a mixed setup). If we decide to use RDS only but not EC2/Lightsail (meaning we will host our Apache/PHP on a different cloud provider), we save a lot on cost BUT the ping time between cloud providers results in a far less pleasant experience with program interface. One of our sell points is speed. We're really keen on keeping that. We can improve by optimizing the program internally so less queries are used (each query adds up when ping time is significant), but this means a lot of work throughout the whole application. One over another, at this point I am going to do some more in-depth math and then decide accordingly, having weighted on all these factors. Not an easy one. 
&gt; new features This isn't really a new feature, it ~~doesn't~~ shouldn't affect prod at all. But I get what you mean. Glad it isn't forgotten
This is the best reply I have ever seen on this Reddit.
Since these constants are usually used in forms via dropdown list.
That's clever, but flaky. At some point, someone will use "==" and it then you get a bug that's a nightmare to track down...
Awesome. I always enjoy a good league package.
That's easy to accommodate. That string which the __toString() cast returns, i.e. the name of the constant, can be a private property in the instance. Then == and === will produce the same results, and === will be just a minor performance optimization. **EDIT**: Here's a quick take on the implementation, I also addressed the case of invoking methods other than intended: abstract class Enum { private $name; protected $allow = []; private static $enums; private function __construct($name) { if (!in_array($name, $this-&gt;allow, true)) { throw new \TypeError('Undefined enum ' . get_class($this) . '::' . $name . '()'); } $this-&gt;name = $name; } public static function __callStatic($name, $args) { $id = static::class . ".$name"; return self::$enums[$id] ?? self::$enums[$id] = new static($name); } public function __toString() { return $this-&gt;name; } } /** * @method static RED() * @method static GREEN() * @method static BLUE() */ class Color extends Enum { protected $allow = ['RED', 'GREEN', 'BLUE']; } And here's it in action: https://3v4l.org/aoPUl
&gt; ... I have discussed very large Laravel projects and deployments with a variety of well-known, enterprise clients. [Source](https://www.cloudways.com/blog/taylor-otwell-interview/)
True. I think NGINX would be the way to go after reading some of these comments.
Nice I didnt realize that but it makes complete sense now. It would have to bootstrap the entire php when nginx already had. 
Thanks pal!
&gt;internal framework Get out whilst you still can.
[removed]
So, basically you're saying "Hey i don't know how this works, but that's not my fault. It's the way the tool works that's faulty".
It's just Symfony devs being elitists and nit-picking tiny issues and exaggerating the problems it causes. Laravel is fine for enterprise grade applications. Eloquent is slower than a data mapper, but that's a cost you have to pay for convenience. Just remember that Eloquent is optional. You can use whatever ORM you want.
Exactly, Wordpress offers a great customizable backend in which your client is able to customize his/her website. Even though the code behind Wordpress looks like rubbish to people that have experienced the elegance of frameworks like Laravel. As a developer you bareley have to touch it anyway. Need to add extra functionality to the CMS, no problem just install ACF and make sure the json files are in git. Need some extra power in your theme development? Grab themosis and you can make use of everything laravel and have wordpress as your CMS at the same time! Want Eloquent aswell? corcel/corcel is your friend! Want to install Wordpress plugins through composer, HELLO WPACKAGIST.COM 
While I don't know the website very well, I'm assuming it has like 10 tables. Comments on videos are handled by Disqus (third party plugin Javascript). So there's not much business logic except a simple login/registration and subscription service. Simply scale up the RDS instance slightly, cache the videos, images, js, css on S3, put a box or two behind a ELB and you're done. That's definitely not enterprise.
Laravel is a pretty flexible when you use it wisely. You can easily change the structure which framework offers by default, and build your application like in "hexagonal architecture", "N-tier architecture", DDD way, or anything else you want. You can use dependency injection, command pattern, implement CQRS, etc, etc. But there is a huge "but". For all of these things you should defenitely know what are you doing. Because out-of-box (and in documentation) Laravel offers "monkey way" (oh, sorry - RAD approach), with static facades, global functions, messy project structure, shitty ORM (Eloquent is the worst ORM I ever worked with TBH. I'm sure first thing you should do when working with Laravel is replace it with Doctrine or something else. Not to mention Active Record itself is more like an anti-pattern). Actually the best thing in Laravel is it's IoC container, and this is what makes it so flexible (along with easy configuration). But since the new Symfony 3.3 I even don't know why you should want to use Laravel for high-scale business-logic rich enterprise application.
I was recently paid to review some code that happened to be written in Laravel. In general the code was clean and readable, and had no major obvious problems, except for one that I have seen repeated often in other Laravel codebases: No proper handling for the unhappy path. The application was written mostly assuming that everything would go without any issues. This really helped with the readability, though, as no branching had to me made in in the logic flow; but in reality it was very error prone. In fact, the reason i was paid to review the code was to figure out the reason for the constant regression and frequent bugs appearing in the app. Laravel is in my view a really interesting framework, but when I read the code I have the same impression: super clean, readable logic, but *seems* like no real thought was put in handling edge cases. I use CakePHP mainly for its ORM, most modern frameworks tend too look alike, so there are few features you can't copy from others by putting a couple packages together; but in general its integration with the ORM is a big time saver.
&gt; If you was building an API which multiple front facing projects where using (or anything with a high req/s), then out of the box the Laravel config is no good but with that being said you would remove a lot of the bootstrapping like sessions if you was building an API anyway. Lumen is great for this. It's Laravel, but geared towards services, with a lot of stuff removed and even more disabled by default.
You've got to give us something to work with if you want help. How's it broken? What's the error message? Is there anything useful in the logs?
https://stackoverflow.com/a/5438125/233286
You can modify pretty much anything with a plug-in in WordPress, which means you also do not have to touch any of the core files, making upgrades very easy. Wp definitely has its issues but it's also a very powerful and widely supported CMS. If you dig in the plugin and templating documentation you'll see you can pretty much control all aspects of it including the admin panels.
https://media.giphy.com/media/dOJt6XZlQw8qQ/giphy.gif
Article is over 3 years old. That being said, Magento is garbage.
Runs just fine on PHP 7 - it will run on old software though. That's not their issue if someones hosting provider runs old PHP though.
As I said: &gt; The irony is that PHP itself is harshly critiqued by many non-PHP developers, almost in the same dismissive way as WP is critiqued by many non-WP PHP developers. There's a lesson in that. And it's why I said it. The same PHP developers that turn their noses up at WP are themselves objects of mirth for C, Ruby, Python, etc. developers. Indeed, the popularity of PHP seems to fuel, to exacerbate, their disdain. Just as WP's does to non-WP developers.
So why are you developing in WP if it sucks so badly?
/u/HorribleUsername
CakePHP is "more" suitable for enterprise? They must have said that in their marketing somewhere... Not sure how much better it has got, but CakePHP was a mess which was only ever going to work with extensive caching. Doing something simple? Lets include a nest of 150 different files.
No it isn't because it advocates Laravel as a legitimate choice.
how about a composer library?
just imagine they do. public function enums() { return [ 'gender' =&gt; [ self::GENDER_MASCULINE =&gt; Yii::t('app', 'Male'), self::GENDER_FEMENINE =&gt; Yii::t('app', 'Female'), ], ]; }
I hereby `@license WTFPL` ([link](http://www.wtfpl.net/)) this piece of code. You make it a Composer library ;-) BTW it's possible to grab the valid values directly from the PHPDoc, thus removing the need for the `$allow` array. It becomes too magical for my taste, but it will be clean... **EDIT**: Damn, what am I doing with my life... [I improved it](https://3v4l.org/ZQhMn). What's new: - Now it reads valid values directly from the PHPDoc, so `$allowed` is no longer necessary, the class can be 100% empty. - Added Enum::fromString($name), returns enum instance by name. - Added Enum::getAll(), returns a map of enum names pointing to enum values for the class. Make it a package! :-)
I haven't downvoted you, but this is exactly the kind of feedback I'm saying to ignore. My team has built an enterprise application that generates 7 figures of yearly revenue using Laravel. Maybe it would've been 'better' to build it in something else, but it works. Give some real feedback as to actual, real world problems with something. It drives me nuts whenever I try to start a legitimate conversation about things online and people just spout soundbites about it. I'm always hungry for useful input from people as to how I can become a better developer, but I just hate the 'XYZ sucks' discussions, because they bring absolutely nothing to the table.
They have enough money to hire staff competent enough to build on WordPress correctly. The problem is that a lot.of WordPress sites were made by inexperienced devs or even designers just throwing plugins at a $25 template until it passes for the client.
I'm quite flattered that you checked me out like that. Well, I'm dynamic after all and since I didn't type hint myself I can understand why you had to verify me the way you did. And this whole thing is bullshit. Attacking people out of pure evil, mocking dynamic types, creating visual debts, etc. When will this stop? We can do better and we shall do better. This is my last comment in this website and in this evil community who is the dumbest among programmers. 
&gt; do you have github account? I have a github account but I don't want that there. I'd rather just use plain constants. I wrote it to see if I can make it work, as I was curious, and for whoever wants type-safe enums. &gt; and how about using [@enum instead of @method static] It's intentionally `@method static` because virtually all PHP IDEs will understand this (it's standard PHPDoc attribute), and show these methods during autocompletion and error-checking. This way the runtime and the IDE are in sync, and we avoid awkwardness between them. Of course you can easily edit the code to accept @enum instead, but IDEs then will show "undefined method" errors when using enum methods.
com.average.co.enterprise.ThingDoingThisThingInThisWayInheritingThisThingAndThisThingFactoryFactory
WFT CakePHP for enterprise, seriously??..Symfony with Zend are enterprise frameworks..with huge companies behind to support them..that is why they are chosen for enterprise projects..behind Laravel is 1 person..if he is run over by a truck..the framework might be as well as death ..for enterprise solutions you need more than just a good framework..that being said Laravel is great for large projects
there are performance issues..specially when working with huge datasets..DataMapper approach spares you a lot of memory..I had to parse huge excels with complicated logic into a db schema..and every active record I tried run out of memory..I was considering Java until Doctrine came along :)
&gt;That said, I'm not touching the rest of the topic even with a stick. Laravel fanboy confirmed.
there are many technical reasons to do so..just check out how many security issues are there with versions bellow 5.6 and they are not fixed..by supporting unsecure versions you support security holes
You should add a license file to match the MIT declaration in composer.json. 
WordPress is NOT a general purpose web framework - it is a pre-built *application*, which by definition means it has made strong assumptions and choices about what it is, what it should be used for, and how things should be built with it. That's the inherent nature of all CMSs. Because of this, it means you must work within the confines of those choices and assumptions. If the site you are building with your WP CMS application falls within the boundaries of those assumptions, then WP will have been the right tool for the job, and will have saved you and your client time and money. However, if the site you are building conflicts with a lot of those assumptions, then WP is actually *technical debt* - you took a shortcut to get a subset of required features done quickly (auth, basic content like a blog, maybe a theme), and now that shortcut is impeding your ability to build the remaining features. Now, here's the rub: WordPress does not actually ship with a lot of features out of the box. Auth, categories, one or two content types, a basic admin skin, and a quick way of installing a theme. If you need to start building a site with complex business rules, you have two choices: 1. turn to third party plugins, 2. write your own plugins. Both of these can be budget busters. Why? Because third party plugins may have crucial limitations or bugs that you might not discover until you've invested time into using them. You still have to do a lot of research and due diligence to select the right plugin. I once spent ~16 hours (2 days) of an 80 hour project just trying to find a plugin that would do what the client wanted. In hindsight, I could have built the feature the client wanted in 4 hours. It's a fallacy to believe the use of 3rd party plugins is always a time saver. Sometimes it's not. But then if you have to roll your own plugins, now you're diving deep into the guts of WP and all of its substandard features. It's DBAL is shit compared to modern frameworks. It's "hooks" system is a poor man's event system. Its "templates" are a joke. It's "router" is the still-born fetus of a Stephen King and M. Night Shyamalan hate child, and its database uses a horrid entity-attribute-value pattern which its DBAL is designed for. If you want to do actual relational data modeling in WP, you'll have to build that outside of WP, which means you'll have to roll your own boilerplate for autoloading and maybe using a dependency injection container. At that point, why not just start with a real framework? So basically, unless your application can be mostly built using the small set of features WP ships with out of the box, then you're going to be wading into a potential minefield of 3rd party plugin dead-ends, or a swamp of sluggish feature development using WP's substandard "framework" tools. Even moderately complex applications can be built faster, more securely, more stably, and more maintainably using a proper framework instead of WP (assuming you're a competent enough programmer). 
PHP's security holes are not the WordPress developers' problem though. What you are saying is equivalent to blaming Google or Apple for shipping software that can run on Windows XP. Supporting outdated platforms is not necessarily a bad thing because it provides options for edge cases where the risks might be considered acceptable.
I'm surprised you classy Node in that list.
I never said WP sucks. Read above: &gt; Of course, it doesn't matter if the code is shit, but it is.
Thanks for you help! I will google a little bit more about ORMs :)
&gt; who I have worked closely with most likely people he work with
Having `File` as type can be tricky, because it remains abstract only in the context of filesystem (copy, move, download, send, rename... etc). However, if you depend on file as a source of data/string then it's not a `File` anymore, not an abstract one - it may be `SomeFile` class, but not the type. `SourceCode` type would be much better imo. Leaky abstractions (revealing implementation details) like this tend to propagate up through object structure and now if I call external service/database/request object for the source code string directly, then components I have, while reusable for any string, will pretend to be specialized to work with files only.
Afterwards you can url_decode each individual parameter when you need to use it.
You will have to encode every parameter separately. So something like this: $email = urlencode($_REQUEST["email"]); $password = urlencode($_REQUEST["password"]); $urlparams = "?username=" . $email . "&amp;password=" . $password; Or even better. You would be able to use the http_build_query() function to turn a array into a url and have the encoding done for your: $data = [ 'username' =&gt; $_REQUEST["email"], 'password' =&gt; $_REQUEST["password"] ]; $url = "?" . http_build_query($data); It looks however that you are talking about getting the data from the url that contains the &amp;password=password123&amp;456 parameter. This is not possible. You will need to ensure that the url you get is already encoded and then decode it in the script called.
You should be posting a data array rather than sending it as a query string.
Better solution is to use headers to pass this information. The header should be in this format: `Authorization: Basic base64(username:password)` So on the app, you concatenate the username and password with a colon to separate them, then base64 encode that string. This is the standard way of doing HTTP authentication. Relying on the URL is bad, because the password can be more easily stolen that way.
&gt; I'm actually aware of this article, read it in the past (although lost until today, thanks). It shows ways to create several indexes as you can see based on the type of search (fuzzier). Uh, it didn't even exist until last week. :) Maybe give it a closer read?
Reported as spam. 
https://laravel.com/docs/5.4/releases#laravel-5.1
Heh, the web proxy that makes your requests disappear! `:=)` 
When we stop using frameworks.
The `mysql_connect()` function is not used in PHP7. Instead use the `mysqli_connect()` function.
How would they? Like you said, what about random encoded characters? I really doubt that you can't encode such a string in switft.
&gt; unmanageable monoliths If you follow [Michael Feathers definition of legacy code](http://www.goodreads.com/book/show/44919.Working_Effectively_with_Legacy_Code) (it is untested code) what you want is not separation for the sake of separation. You want tested code. Usually separation comes as a necessary by-product. If your monolith is fully tested at its boundaries, you can have any number of coders on a shitty spaghetti code: when someone does some change they know if they broke something fast. But you can have the cleanest code you can imagine a new dev doing something may break things without knowing about it. Entreprise code is code meant to be maintained and evolved by average and bellow average coders. You can't expect them to keep your code clean. But you can put enough checks through tests to be sure they don't fuck-up what you implemented.
Already worked on fully tested (also e2e-tested) unmanageable monoliths.
They have been talking about Jeffrey taking over..that is so nice and reassuring..so if they both go to a conference on the same plane..yeah..but anyway a company backing a framework means safety..thats one of the reasons I have not seen a single ERP made with Laravel..and I mean true ERP not mid sized projects people believe are enterprise
I agree with your first statement - people divide themselves into tribes and they almost forget what they are arguing about. However, your political analogy doesn't really work. Left/right are useful political distinctions (if a little blurry sometimes). But as long as a thing has a agreed definition between two people, then they are in a position to debate the merits of it. 
What is interesting about this naming convention is how each element becomes a modifier for the last thing. It's about accessing, no it's about intercepting an access, ah, it's a value holder for that thing, no it's.... `:=)` The rabbit hole goes deep!
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [slimphp/Slim-Http/.../**Uri.php** (master → 7ad2514)](https://github.com/slimphp/Slim-Http/blob/7ad25147bc5d9989ca14c53c4b291599d06adab9/src/Uri.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dieh5ko.)^.
Fully webscale!
It's fast, I'll give it that. 
&gt; Because PHP was never strictly typed, it of course does not have it to that level The typeness of PHP should not matter. We're talking editors here. If all types can be declared in docblocks, I think it would be perfectly possible for a deep introspection system to do what I have described. Your reply indicates that you believe Storm does not have this ability, and fair enough - I think that is what the OP was asking. I use NetBeans and it does not come close to this, but then I am of the view that the PHP ecosystem does not have this at all. 
I've worked with Smarty, Twig and Blade. For me, it's Smarty. It stays way closer to the PHP syntax, while adding the comfort and usability a template engine should. When writing PHP code, I really don't want to switch between too many syntaxes all the time. Never understood why a PHP template engine would prefer this: ``` { 'foo': 'foo', 'bar': 'bar' } ``` over this: ``` [ 'foo' =&gt; 'foo', 'bar' =&gt; 'bar' ] ``` The first one is an array in Twig, the second in Smarty. Note that the Twig version isn't valid JSON either. So its just one more way of creating arrays to remember. Another example would be the use of variable names: with or without `$` signs. Now there are a lot of opposers against Smarty. There are arguments I totally agree on. Eg. a very outdated coding style. But Smarty keeps true to PHP. That I find really important. 
Lol my bad no point in editing now *varnish
While that's true, OP will still have the same problem if they persist in their naive parameter assembly and parsing strategy.
On the APP, you encode each parameter as you assemble the URL. Not the entire URL at once, you go field by field. On the WEB side, you decode each parameter before beginning your application logic. The password encodes to "password123%26456", where "%26" is the URL entity value of the ampersand character. This will also save you from cases where the user enters an equals sign or question mark, which you haven't yet discovered also causes the same problem. "Cute" story: Back in the early days of the internet, I had a client INSIST that their domain name have an ampersand in it. The ampersand was crucial to their branding, their logo was basically a huge "&amp;", and I was obviously just being stubborn and probably lazy and stupid, telling them they couldn't have it. They fired my company over it.
Simply doesn't want to or cant because of the large and "complex" code base?
Thanks :) So its just the documentation. A bit weird approach it is tbh.
http://php.net/manual/en/mysqli-stmt.execute.php $link = mysqli_connect("localhost", "my_user", "my_password", "world"); mysqli_query($link, 'SELECT FROM BLABLA BLA'); The first parameter of most of the `mysqli_*` functions should be the connection (`$link`); In `mysql_*` it was like this mysql_query('SELECT FROM BLABLA BLA');
 Notice: Could not select database in ./public_html/htp/store/includes/dbhandler.php on line 70 Warning: mysql_set_charset() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 78 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Warning: mysql_num_rows() expects parameter 1 to be resource, null given in ./public_html/htp/store/includes/dbhandler.php on line 142 Warning: session_start(): Cannot send session cookie - headers already sent by (output started at ./public_html/htp/store/includes/dbhandler.php:70) in ./public_html/htp/store/index.php on line 74 Warning: session_start(): Cannot send session cache limiter - headers already sent (output started at ./public_html/htp/store/includes/dbhandler.php:70) in ./public_html/htp/store/index.php on line 74 Warning: Cannot modify header information - headers already sent by (output started at ./public_html/htp/store/includes/dbhandler.php:70) in ./public_html/htp/store/index.php on line 76 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Warning: mysql_num_rows() expects parameter 1 to be resource, null given in ./public_html/htp/store/includes/dbhandler.php on line 142 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Notice: Undefined variable: prods in ./public_html/htp/store/includes/dbhandler.php on line 647 Warning: implode(): Invalid arguments passed in ./public_html/htp/store/includes/dbhandler.php on line 647 Warning: mysql_num_rows() expects parameter 1 to be resource, null given in ./public_html/htp/store/includes/dbhandler.php on line 142 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Warning: mysql_num_rows() expects parameter 1 to be resource, null given in ./public_html/htp/store/includes/dbhandler.php on line 142 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Warning: mysql_num_rows() expects parameter 1 to be resource, null given in ./public_html/htp/store/includes/dbhandler.php on line 142 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Warning: mysql_num_rows() expects parameter 1 to be resource, null given in ./public_html/htp/store/includes/dbhandler.php on line 142 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Warning: mysql_num_rows() expects parameter 1 to be resource, null given in ./public_html/htp/store/includes/dbhandler.php on line 142 Warning: mysql_real_escape_string(): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2) in ./public_html/htp/store/includes/dbhandler.php on line 412 Warning: mysql_real_escape_string(): A link to the server could not be established in ./public_html/htp/store/includes/dbhandler.php on line 412 Warning: mysql_real_escape_string(): Can't connect to local MySQL server through socket '/var/run/mysqld/mysqld.sock' (2) in ./public_html/htp/store/includes/dbhandler.php on line 413 Warning: mysql_real_escape_string(): A link to the server could not be established in ./public_html/htp/store/includes/dbhandler.php on line 413 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Warning: mysql_query() expects parameter 2 to be resource, object given in ./public_html/htp/store/includes/dbhandler.php on line 103 Warning: mysql_num_rows() expects parameter 1 to be resource, null given in ./public_html/htp/store/includes/dbhandler.php on line 14
If I can send you the source files, would you be able to take a look and let me know an estimate of what you'd charge to fix this for me? While I'm not making any money off of this, it's for a very good friend of mine so it's super important that I get this back up and running for him, but I know absolutely nothing about MySQL, PHP, etc. :(
Knew var dump, totally didnt think / look / know about isset though TIL :c
Well it depends what you mean by php cli, if you mean application bootstrapped once and working in some event loop then yes, php cli will be faster. What i mean is project like https://github.com/php-pm/php-pm
Most of the documentation was written many years before PHP had return types as a feature, and so the docs copied C/C++ style declarations.
I would highly recommend that the vote goes towards the "always PascalCase" because it's more consistent, uniform and therefore easier for machine processing to transform. I.e. it's common that as identifier names cross boundaries, their names have to be converted from one format to another, for ex. corresponding "ClassName" for a given mapped "table_name", or a "fieldName" and a corresponding "CONSTANT_NAME". Some of the standards can't differentiate abbreviations (ex. table names and constant names) so automatic conversion can't possible preserve capitalization of abbreviations, i.e.: "HTML_MESSAGE" -- machine transform --&gt; "HtmlMessage" "target_url" -- machine transform --&gt; "TargetUrl" Likewise automatic conversion in reverse would be bizarre for the capitalized acronym names: "HTMLMessage" -- machine transform --&gt; "h_t_m_l_message" "TargetURL" -- machine transform --&gt; "target_u_r_l" This rule is also less cognitive load, because it clearly separate words in a name with a capital, where capitalized acronyms may cause confusion and ambiguities. Additionally "capitalized acronyms" will result in more inconsistencies and confusion, because sometimes people aren't sure what's an ancronym and what isn't. For example, people commonly think "id" (short for "identifier") is an acronym and you can see methods and classes like "getID()" "UserID". If we don't treat acronyms in a special way, people will be consistent in this case and write "getId()" "UserId" regardless of what they think about "id". P.S.: I would also highly recommend PHP stops using suffic "Interface" for interfaces. I know why DateTimeInterface needed a unique name, but overall this standard produces pointless verbosity and makes it impossible to do a class of refactorings without B.C. break (i.e. turn a class with a private constructor into an interface of the same name without B.C. breaks).
Hi, Apologies for the delay to answer your comment. This is a good point, however if you only need the bot you don't need to have a lot of unnecessary codes and libraries that normally come with a web framework. Cheers, Ehsan
And Fabien his follow up post two days later, where he kind of announced twig. http://fabien.potencier.org/templating-engines-in-php-follow-up.html Saw him do a talk page in 2010 telling the audience he was wrong in his initial thoughts about template engines in PHP and admitted there was value in using them over plain PHP mixed with HTML. 
Yeah, I will implement them as well, without RGBA, blending colors is meaningless. Thanks for the feedback.
&gt; PS: There is not Interface suffix standard in PHP. It is used only in cases like the DateTime one. We have Throwable, Traversable, … so no worries. This really warms my heart. :-)
Btw. this is a major argument for why variables and constants should be snake_case regardless of context. Namespaces as well as class and method names are case-insensitive, it does not matter how you convert them, they always work. However, variables and constants are not! Consistently using snake_case from DB, through PHP, to JS would also minimize the need to perform such useless transformations. Usually religious beliefs are the only reason why people cannot understand that. Tried to get snake_case as the standard at trivago, sadly my fellow developers voted against it due to an extreme Symfony/PHP-FIG bias.
Yeah, but that's what that kind of proxy does. There are shorter versions such as "ghost object" and "virtual proxy" for other types tho. Still, as a reader, they might be unclear. Also, I didn't want to invent my on façade :-P
What is a subject to change soon, BTW
Thanks! I just added
Just give it a try, I don't really fully understand what exactly do you want from it :) MY needs are covered, I always assign types to variables and make use of interfaces, so I usually don't have any problems with types and spotting mistakes is easy as IDE screams at me for that.
CamelCase is normal in SQL Server for instance. It is a totally valid approach, one has to choose one of both extremes to avoid this mapping madness. Most SQL engines treat things case-insensitively anyways. There are still arguments against using camelCase for variables, and I am looking and [PEP 8](https://www.python.org/dev/peps/pep-0008/) here. The casing directly tells what you are dealing with. This is not so important for inline variables that start with our dollar Sigil, but it helps with properties and methods. That being said, good syntax highlighting is usually more effective than such conventions. The only real argument for snake_case is readability, and there is actual proof for this argument from science. &gt; BTW, I have this little dream that PHP v8 or whatever will make all identifiers case sensitive, and remove the distinction between functions/classes/constants/variables, and put them in the same shared symbol table (as most languages do). I am sure this will not happen (BC), but there are also arguments why it could be done in the other direction. Aliasing by case is a nasty source of bugs. Always lowercasing and hashing over that would ensure that this kind of stuff is not possible because `TRUE`, `true`, and `TrUe` are always the same. It’s slighter slower though.
Thanks man :)
Use escapeshellarg - i.e. $str = exec("reg query " . escapeshellarg('HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall\VLC media player'), $input, $result); I don't use Windows but I think that will work.
Mate, worked like a charm. Thanks a lot! Must have have had the context wrong. Lesson learnt. Thanks again!
No problem! Glad that worked.
Could we not treat VSA's slightly different and have them follow always capitals, and standard acronyms follow only first letter? ID DB Http Rsa Ver Ref TP Edit : VSA - very short acronym 
As noted in the comments in the post itself, this is a cool solution to do this: https://github.com/yii2mod/yii2-enum
Ops. You're absolutely right. Good thing I wrote "...something like... " ;)
If this is planned from the beginning to NOT introduce new inconsistencies then I for one am against it. That's what keeps me employed.
&gt; I don't really fully understand what exactly do you want I'd like you to be nicer to posters, psihius - you were rather rude on the basis of the OP's age or experience. My intention is not to be rude to you in turn, but to encourage the idea that perhaps the answer to the question was not so obvious after all. Hope this feedback is OK - consider it like a code review `:-)`. 
&gt; can we then finally fix the default implementation of spl_autoload_register to work with capitalized file names? What's there to fix? spl_autoload_register doesn't do the autoloading - it just calls the function you provide to it. 
It will use spl_autoload if you don't give it your own autoloader. This sort of works like one would expect, searching for classes classes in your include paths... expect the filenames need to begin with a lowercase character, even when the class you're loading begins with an uppercase character. https://secure.php.net/manual/de/function.spl-autoload.php.
Is there any drive to make that optional? Basically, can we be C# now? 
One thing I'd like to add, HTTP, XML, etc, while officially abbreviations, we use them as words 
&gt; It will use spl_autoload if you don't give it your own autoloader. I thought there was an RFC to deprecate that. &gt; include paths There should be an RFC to deprecate that, also. 
That's fine too, then. I'd rather have no default than one that's broken.
I don't like the idea of a "Std/util" namespace, I mean maybe you have a single thing that doesn't fit an existing namespace, so you put it in Std, but then later you realize you want to make a couple of things related to the first thing, and they should all be in a new namespace, but you can't do that now because the first thing is already in Std, and you can't ever remove it because backwards compatibility, and so Std gets filled with crap. Better to just accept that you might end up with some tiny namespaces
i think this is a feature long due. 
I don't think this should be in Core at all. At least, not at this time. To many caveats and needles &amp; haystacks. I would suggest, start with an optional PHP library abstraction independent from Core. Then, after a few years this has stabilised you might consider bringing it into Core.
The reason that some people who are very knowledgeable/experienced espouse this point of view comes down to the 'S' in SOLID: Single-responsibility principle. You absolutely can keep concerns separated in Laravel if you want, however Laravel makes some aspects of understanding what sections have which responsibility harder to understand. Some of that comes down to an inherent design philosophy of ActiveRecord which Eloquent uses, and some it comes down to Fascades, and some comes down to the way the Laravel documentation suggests doing things. This opaque-ness of separation is done on purpose in Laravel, and that purpose is not 'to be bad'. Laravel is one of the best PHP frameworks for prototyping and rapid development. The design choices that make it harder to keep in like with SRP also make it easier to develop something that functions faster. In "enterprise-grade" applications, the value proposition of "develop faster but make it harder to maintain" changes drastically, because such applications are by definition longer-lived and more complicated. However, 90%+ of programs *don't* have those concerns (even if the devs *think* they do), because the vast majority of applications just don't ever experience the "enterprise-grade" problems. Don't think of "enterprise-grade" as "the-right-way", it's a particular set of concerns and goals, and not all developers or programs will share those concerns and goals. Just because Symfony is the better "enterprise-grade" framework doesn't mean it's the best framework for EVERY application, just the same way that not everyone drives down the road in big semi-trucks. You don't even consider going to buy a Freightliner or Peterbuilt truck for a personal vehicle, because while it may last longer, and while it might be more capable, it doesn't address your needs as a consumer. This situation is kind of like that. If you don't know the answer to this question, then you are unlikely to be in a position where the answer matters to you.
This isn't about changing the existing standard library; it's about creating standards for namespacing *new* core features. So I don't think it makes sense to "start with an optional PHP library abstraction" - this would mean that new core features would continue to lack namespacing, which only makes the current problem worse.
OK. Thanks. I probably misunderstood the initiative. 
Any reason you don't hold /u/LtAramaki's points to be important?
I've not seen anything indicating that. AFAIK people like 'function' being required as it makes it easier to grep/find the function within a codebase. 
No I agree with almost all of his points :) My main query is could we not treat the types of acronyms differently. I guess my example of ID ignores some of his comments, so that was a bad choice. It was more of a question XD 
Still got the same issue. It's pretty weird
"Last" 
Let your IDE handle it. 
you can get more error details by passing into the ctor ['settings' =&gt; ['displayErrorDetails' =&gt; true]]
It is in the communities and languages you know (which includes the majority of today’s PHP user communities). It is not in many other communities and languages. I am jumping around in different communities and languages. I have to write `camelCase` PHP at work and write `snake_case` PHP at home. I really don’t care what people use, but please do not, never, ever, write mappers (automatic or manual) and instead get your coding style straight. If you now analyze your own code bases and realize that you are mapping: you’re doing it wrong! Fun fact: everybody is writing array keys in `snake_case` in PHP, and everybody starts mapping around just to get that stuff straight again for their JSON. Why not `camelCase` for array keys in the first place?
&gt; It is in the communities and languages you know (which includes the majority of today’s PHP user communities). I'm not sure why you think you know what communities and languages I know or am a part of, but you don't. &gt; It is not in many other communities and languages. It doesn't have to be more popular within any particular context to be more popular *across more contexts*, which is the assertion that I made. &gt; Fun fact: everybody is writing array keys in snake_case in PHP, and everybody starts mapping around just to get that stuff straight again for their JSON. Why not camelCase for array keys in the first place? The casing of keys takes on whatever form the source (JSON, SQL, etc.) used for the most common uses of associative arrays. What case teams use when creating arrays manually varies wildly.
Developers completing personal projects. I guess that is a good way to filter down 1500 candidates to about 5.
From the [README](https://github.com/tuupola/slim-basic-auth#security). &gt; Browsers send passwords over the wire basically as cleartext. You should always use HTTPS. If the middleware detects insecure usage over HTTP it will throw RuntimeException. This rule is relaxed for localhost. To allow insecure usage you must enable it manually by setting secure to false.
Actually, I'm running over https but the issue still occurred. https://github.com/tuupola/slim-basic-auth/issues/12 `Slim checks the scheme in actual server. So if you are not running https in the actual server you you will get the error. Then you can use the "secure" =&gt; false setting.` 
It helps that I am also a maintainer of Slim ;) btw our slack is pretty much always active! feel free to join
Well that's not really the concern of type hints and return types. Their purpose is to make it clear what messages are legal to send to the return value, not what the state of the return value is.
I'm sorry for the typo, it should be Auryn.
The problem is most plugins are written by the worst developers. You have to code review anything you use. You then have your users who just install any old plugin which has a listed unfixed vulnerability and you are suddenly hosting malware a few days later.. 
Being technically correct is the best kind of correct
And Auryn is totally right to have that stance. However, there are a ton of packages in the PHP ecosystem that require `psr/container`. I want to be able to use those packages **and** use Auryn. :)
Yes, that's the general idea. You'll almost certainly need to write some glue that puts the pieces together into your final product, but avoid wheel reinventing.
What package uses psr/container? I've not run into one.
There are [232 packages](https://packagist.org/packages/psr/container/dependents) at this moment in time, plus another [477 packages](https://packagist.org/packages/container-interop/container-interop/dependents) that depend on `container-interop`. 
A lot of these look like they deal with dependency management in itself (factories, resolvers, etc). It's not clear why you would not simply share Auryn to itself and inject that in such instances. Auryn my preferred DI tool because it has the clearest sense of purpose (as a non-container) and offers features like `prepare()` (which I played a roll in defining). For example, I'm currently working on a new nano-framework that encapsulates dependencies in delegates. But the delegate may want to be the one that makes the decision to share that dependency. In order to do this, I need to inject Auryn so that the delegate can construct the dependency and then share it. Furthermore, PSR-11 suffers in that the $id is generic. Insofar as a container is being injected, you may have a common interface, but to get a usable dependency the $id needs to be known beforehand. So if I, for example, want to use my container as a service locator and get a logger out of it, with Auryn I may do the smart thing and alias('Psr\Log\LoggerInterface', 'SomeConcreteLogger'), but then it's dependent on the thing that uses the container doing `get('PSR\Log\LoggerInterface')` instead of `get('logger')` -- and if it does the latter, that needs to be defined somewhere. Lastly, if the container is being dependency injected itself wherever you are creating the thing that depends on it is already going to presumably have access to Auryn anyway, so why wouldn't you just use concrete dependencies? It seems rather pointless to have: public function __construct(Container $container) { $logger = $container-&gt;get('PSR\Log\LoggerInterface'); } When you can just do: public function __construct(PSR\Log\LoggerInterface $logger) { } The only reason for the former seems to be to abstract away the $id and obfuscate what is actually being injected.
It should be supported natively. Despite the existence of IDE's, PHP still added grouping use statements (`use \ns\{class1, class2}`). I don't think it would be a bad thing to add.
i now see php in different view. Thank you for your feedback.
&gt; Is this considered cheating ? Yes, of course it is. Glad you recognise the *correct* way forward by being lazy and using code that has already been written. Keep up the good work. &gt; Is this too good to be true ? You need to be aware of the licences used for each package, as they will have an impact on the licence of your finished product.
Exactly what I was thinking while reading :p Still a good article for people who use Sonata and aren't aware on being able to this.
It does appear that the `return false` function is there because they have a filtering functionality that I infer requires the passed argument to be a function rather than dynamically checking whether it is `callable`, or a boolean. I see what they were going for, but it seems like a straight up dumb way of doing it.
&gt; It seems rather pointless to have: &gt; public function __construct(Container $container) &gt; { &gt; $logger = $container-&gt;get('PSR\Log\LoggerInterface'); &gt; } No one's using it like this at all lol and if you are, then shame on you. Auryn + Service locator is best when you're tired of creating factory classes for passing dependencies around which auryn can simply reduce a ton of boilerplate for you without actually needing to pass around the container at all. While keeping your code in tact and testable. 
A proper employer will look at how you code, rather than what you code.
My bad, learned something new today!
It's complete BS. It's just pure developer laziness in not wanting to learn another framework. Laravel is flexible enough that you can pick and choose what you want from the framework, so, if your issue is one particular component, don't use it. Also, I tend to find that some developers throw around the term "enterprise-grade", but they don't have a good definition of what that is when you challenge them. It's just a loaded word thats lazily thrown out there - often when you don't really have the knowledge or experience to say anything about the other framework with any authority, yet you still have "an opinion". 
What do you mean no one's using it like this? Perhaps the better question is **how are people using it?**
Good code is hard to write. Popular libaries have had many eyes for many hours making sure they are high quality. Your code is not going to have as much time spent on it as those popular libaries, so it likely won't be as good. Spend your time writing the best glue you can for the best libaries you can find. If its a problem that's already been solved, why go and solve it again? Of course sometimes there is nothing worth using and you must create stuff yourself. That's why a language ecosystem is important. The only thing you want to be tackling is business domain problems.
It's not cheating insofar as using PHP isn't cheating. PHP is, after all, just a bunch of code to help you write websites. But in particular, they (the package authors) have authorised you to use the code under a license, and so long as you respect that license, and don't pass it off as your own work, you're not stealing it or plagiarising it or whatever. That said, if you've been tasked by someone to write a user registration system as an academic exercise or as training for something, and you simply use a package that does that for you, you're probably cheating at the task, sure.
The code block: for ( $root_path = __DIR__; $root_path != '/' &amp;&amp; !is_file($root_path . DIRECTORY_SEPARATOR . 'composer.json'); $root_path = realpath($root_path . DIRECTORY_SEPARATOR . '..') ); Could be written as for ( $root_path = __DIR__ . '/..'; $root_path != '/' &amp;&amp; !is_file("$root_path/composer.json"); $root_path = realpath("$root_path/..") ); DIRECTORY_SEPARATOR is not necessary because `/` works on Windows too. Also, starting `$root_path` one level up will save you a loop because it's safe to assume that the web server's document root will never be the same dir as composer.json, that would be a security risk.
Socket.io uses its own protocol on top of websockets. It will start with long polling and upgrade to websockets if the client supports it. It's possible to do with PHP using something like amphp/aerys but there currently isn't a php server implementation for socket.io. I started writing one and it sorta works, but most PHP apps aren't written for an async environment so they would probably want to use the redis queue anyway.
Check out Ratchet http://socketo.me/
Wrong. Just because the code written supports 5.2, doesn't mean that it was written TO support 5.2. WordPress' ecosystem is vast, they probably don't change the architecture because they don't want to break that.
In the symfony world I can vouch for https://knpuniversity.com/ 
Personally, I don't get the appeal of microframeworks. They're not a lot faster than full frameworks and having to remake all the little decisions like file structure and naming, what component to use for each thing, and where to put the configuration are a waste of brainpower. With full blown frameworks all those decisions were already made in your behalf. You also get consistent documentation and easily googleable solutions for common problems. 
socket.io uses Redis to scale horizontally. For a simple pub/sub with several thousand connections it's not at all necessary; pub/sub in the application is dead simple. Once you start to reach the limits of a single process/machine you'll need to launch another instance on another machine...but then you're faced with new problems, scaling horizontally isn't as easy as CGI's share-nothing nature. You then need to build process communication to see who's subbed for a channel that just got a publish. By making Redis a requirement from the get-go the socket.io people have made scaling horizontally less of a thought process for you the developer when scaling becomes a requirement. 
very true.
Well if WP was written in such a horrendous way that an internal refactor isn't possible because the ecosystem is dependent on internals instead of a well defined API surface... well there you go. What more evidence do you need that WP is shit to work with?
There are a few drawbacks to going that way. For one, imagine you have an app or website that uses a simple form with a few text inputs or selects in one spot, but very few other forms throughout. You need to do form validation for your one simple form. That is a thing you can find packages for, BUT the packages are going to have FAR more code than you will ever use because they are prepared for ANY kind of form and EVERY kind of form input. You may need a package to fill a glass with water but the package will include the kitchen sink. Another issue is that if you don't really understand how to write code to handle user authentication for example, then downloading a package to handle it may be confusing and hard to maintain, or you may have a hard time configuring it and not understand why. Where packages really help the most is on projects that many other people are working on, and or projects that will need to scale. 
That's what happens when the target audience is broad enough to include people who aren't actually web developers, and might only know a little HTML. Something else can be said about WP - it's the most often incorrectly chosen tool for web development. Clients insist on it because they've heard of it, but then have requirements that take 10x longer to implement in WP than in a proper PHP framework, due to all of the assumptions that WP makes, and bad tooling WP provides, that you have to fight against.
"you may have a hard time configuring it and not understand why." at the point right now. 
[ctrl] + [f] "n someFunctionName"
You can just disable the plugin panel within the admin?
Usually questions like this make me overwhelmed. Such platforms as Magento and Prestashop should be compared at all. Each platform implies its own functionality and features suitable for a webstore. In order to define which platform suits you, you should determine requirements to follow. For example, the size of your business, the quantity of items to sell, the way your webstore should look like. If you don’t have any ideas, try to find similar webstores and find out the platform they are based on. Or just address to a company which is responsible for [ecommerce website development](https://belvg.com) and they prepare everything your prospective webstore needs. 
Check out [Centrifugo](https://github.com/centrifugal/centrifugo). I used it on several projects as replacement of socket-io (stand-alone websocket server) and it's really cool to work with. Right now we are implementing chatting solution (something like zendesk + chats + webrtc) using it and we are really happy. Few years ago I used to use ratchet and it was painful.
Happy to see this post, I just had to script a ratchet server using a redis client from the ground up for a RTC app(never using PHP before haha), and it definitely takes a bit more work than the usual node + socket.io implementation. 
Validation in constructor is a seducing approach that we started using in my company. However, for some people, [exceptions for control flow are considered an anti-pattern](https://softwareengineering.stackexchange.com/a/189225). What is your opinion about it?
&gt; You can always call it DRY I think the correct term is "Don't reinvent the wheel" :D
I tend to assume that exceptions being thrown when guarding invariants indicates something disasterous has gone wrong and execution should not proceed. Basically; if you're not catching them you're not using them as control flow, you're using them as a way to guard against the system getting to an invalid state.
Is there any reason to still fall back to long polling?
I will compare Lumen and Laravel here... if you dont know why you need Lumen you should pick Laravel. If you need speed for specific processes and slim the bootstrap, Lumen will be a good fit. If you want a more general framwork with a lot of good stuff you want Laravel. For a beginner I think Lumen is more difficult since you need more knowledge about the framework, you need to add packages manually etc. Slim framework does not mean that is easier to develop!
It's generally considered cheating by new comers to programming but to a seasoned developer its often considered dirty not using something tried and tested. You do have to write the linking code to stick all the parts together still. It's fun and good for practice to write your own versions of things but in any client project I will always reach for the same few packages over and over.
it's not a simple case of the wordpress devs making it for php7, and it just happens to work on 5.2. They've gone out of their way to keep php 5.2 support, making the codebase a complete mess in doing so, and not taking advantage of things that would make wordpress on php 7 not only much nicer for devs, but faster for site users.
Great. Now what happens when that plugin turns out to have a security hole and needs updating. You either: A) lose your customisations B) manually trawl through the new version to find out whats changed That sounds like a pretty crap ecosystem to me.
Doesnt fix the fact that you're installing a back door every time you add a plugin.
[removed]
It doesn't take a UX expert to work out that this: &gt;The problem I have is when the client had a request I don't know where to add/fix/change it. Is it in the admin dashboard, theme options, plugins, theme template, plugin code/template, or some other place? Is an obvious user experience issue. I get that you're a massive wordpress fan and refuse to say anything bad about it, but come on.
Doesn't that still require you to write `Routes\bar` if you want to access bar?
#API &gt; Of course you can go even further and add separate value objects for every single value. $canvas-&gt;drawPixel( new Coordinate( new X(50), new Y(25) ), new Color( new Red(31), new Green(142), new Blue(255) ) ); Drugs are bad... It's much easier to either insist upon conventions for such things than to create a solid type to enforce red-green-blue ordering, or have language-level named parameter support (as python has) 
Relax and try to enjoy yourself. It's only a job interview. Not life or death. If you don't get the job, then it doesn't matter. You've got yourself some experience to handle the next interview. There are many more jobs available in this game than there are developers, so another interview could be just around the corner. Good luck!
&gt; Where you end up drawing the line is up to you and of course it also depends on the project that you are working on. If it’s a really mission-critical part of your application, then I would go much more fine-grained with the value objects compared to a less critical part.
As PHP is not strongly typed language hence it's vulnerability can be exploited by bugs. Typesafe array put a limit to it. Now It is very important for any PHP developer to be aware of proper Array Usage [jump into this article if you are still unaware about basics](https://www.singsys.com/blog/work-with-php-arrays-in-impactful-manner/) 
that'd be the bit I was missing from context, yes :P it's a behavior I prefer, however. the alternative would be an autoloader which parsed for hints to alias classes at runtime, which would get a little messy if it wasn't also accompanied by a composer plugin that rewrote the installed code to refer to uniquely-named aliases.
I agree with you, which is why I did not use it for the rest of the code examples. I just showed that it's an option which can make sense in some cases.
It was a great article, that was the only bit that niggled me. I Agree very few should have the need to, or be playing with mutable structures in an application language. Something I've just thought as I re-read is what a shame it is I can't have multiple constructors in PHP, although I suppose I'd just make an abstract type and extend per-constructor.
I don't agree with some parts of your code. The first issue is, you're always generating a `Color` by `RGB` values. It is a bit pointless in `Value Objects` because one of the benefits of using Value Objects is being able to `comparing the value` that is generated from different sources. For example, we cannot do `rgb(0, 0, 0) === #000` in typical programming, but we know they are equal. So you could do something like this: const color1: ColorInterface = new Color(new RGB(...)); const color2: ColorInterface = new Color(new HEX(...)); color1.value === color2.value // true Or more precisely, `new Money(new USD(1))` and `new Money(new EUR(1))`. Both of them are `Money`, you can hold them in real life and both represent a value, but their value will be different. Second thing is, your `Color` should not be validating `RGB` values. Color is color. It should be an object just like the objects in real life. You don't pass RGB parameters to sky to see it is blue, nor the sky is validating your RGB parameters. I would personally do it in factories if I had to do it during runtime, and rely on interfaces to do it during compilation. What we know is, a valid parameter for RGB is an `integer` between 0 and 255, which is an unsigned 8 bit integer. I would prefer creating an interface (e.g `RgbColorValueInterface`), create necessary typehints and make sure it refers to an integer value between 0 and 255. Imagine it like this. Can you put a `Truck` on top of an `Ant` to carry? If you do it like how you did it in your codebase, then you would need to put `Truck` on top of an `Ant` first because of your validations in the `constructor`. Then `Ant` would say: "Sir, I cannot carry this. It is too heavy!" but `Ant` would die. Your code should be smart enough to reject the idea of `Ant` carrying a `Truck`. We can easily create a Value Object called `Weight`. Give `Ant` a weight it can carry. Give truck a `Weight`. Then we can simply ask `Ant`: "Hey Ant, are you able to carry `WeightValueObject` weight before putting `Truck` on top of the tiny innocent creature. Thinking this way also helps with SOLID since your class responsibility is very clear and you cannot do certain things as a developer *even if you wanted to*. Also, value objects should be very tiny and should contain minimal functionality, preferably none. Continuing from my sky color example, we know the sky is `Blue` but that is actually not true. There are some animals such as dogs which see the sky as `Gray`. There are some animals which can see colors that humans cannot see. However, we can all agree that there is a `Color value` (a value object) in the sky, but different `Eyes` (or any other `Interface` that has ability to interpret `Color`, such as `Camera Lenses`, which is not an `Eye` but an `Interface` that can interpret `Color`) can interpret it differently. Actually, your code example looks more like a class/interface/RGB validator than a value object. Sure, it is a Value Object but that is missing a very critical point in my opinion. 
Yup, that's the point Microframeworks are for those who want to choose things by them self, not really about speed/performance
Regarding the concept, there are many versions of "minimal framework that glues together packages". I think when you are getting this low level, you don't tend to use a framework, but something optimized specifically per project. What you did is really cool, but I don't think there is a big market for it. In most cases, something like Zend Expressive or Symfony Flex (not released yet) provide the right balance of "bare metal"/performance to usability. With that said, I enjoyed reading through your code. Stuff like the for loop to "reduce" the path is interesting and something that never occurred to me before.
&gt; I think when you are getting this low level, you don't tend to use a framework, but something optimized specifically per project. I think this is true, but also an issue of semantics. While I may not use a framework, whenever I do work that low level I tend to always start with the same basic questions and needs: 1. What is my dependency injector (it's always Auryn) 2. What does my basic directory structure look like (usually the same, but this is undefined enough that it can be changed)? 3. What does my configuration look like (this has varied over the years, but that I want/need some kind of configuration is a given) 4. How am I organizing my bootstrapping? With respect to solving #3 and #4, I previously produced [dotink/affinity](https://github.com/dotink/affinity) -- this worked very well for awhile. But on my most recent project where I used it, I ended up with literally 1 bootstrap file because all the work got shifted to dependency injector delegates. In affinty, there was a method to basically require one bootstrapping file before another to make sure ordering was right, but with a recursive dependency injector like Auryn, this is inherent if you just take the time to create proper delegates. The only bootstrap left in that last project was doctrine, and that's just because the number of classes to configure/make delegates for was not worth the effort given the time constraints. \#1 is always solved (granted others may prefer something else). #2 seems somewhat irrelevant since it's easy enough to rename and reconfigure without losing the basic principles (a set configuration mechanism, DI, and a known interface for delegates/provider). For me it is that known interface for delegates/providers that matters. What this makes possible is creating small integration packages for essentially every library I might use. So even if I use two different libraries for two different projects, I then have those integration packages and I can re-use them in the context of the nano-framework with little to no effort except maybe tweaking a few config settings. In either case 1 - 4 essentially is my framework. I haven't used a "framework framework" in probably 3 years, it's always pick and choose from the best libraries that fit the project at the time. But with this, I now just have a common way to integrate them and, thus, re-use them.
what did you do :D ?
sorry for the question but how much faster is QB(DB::) than eloquent ?
Assuming that I can't can't install anthing on the machine me website is running, what do you suggest? I guess I could use crypt() but I know nothing about salts...
To what memory leaking are you referring exactly?
Can you implement the `Ant`, `Truck` and `WeightVO` the way you see it? I don’t think I understand your point here.
C++ doesn't have a standard garbage collection mechanism, every library essentially does their own thing, and almost without exception (no pun intended), the way most C++ code handles memory management is highly dependent on very specific flow of code execution. When an exception breaks the standard flow at some (semi-)arbitrary place, all kinds of markers, ownership flags, and reference counts get out of sync up the chain and result in memory leaks. For ex. if a constructor throws, should the destructor run? If it runs, it might try to free resources that were never allocated. If it doesn't run, it will fail to deallocate resources that *were* allocated. Neither is quite right. In PHP we don't have this problem because object clean-up is done by the engine, we rarely ever write destructors, but in C++ this is a must. Additionally, even the C++ compilers sometimes have subtle bugs around memory allocation and exceptions, that can lead to leaked memory in edge cases, due to no fault of the developers writing the code themselves. 
I'm not sure I like the use of separate classes on the permissions. This to me would make configuration somewhat convoluted. We wrote the following solution a couple years ago which has proven to be flexible enough while keeping the configuration easy to maintain in a config file that is just an array: https://github.com/imarc/auth
&gt; Second thing is, your Color should not be validating RGB values. It is true that a VO should not self validate, but we should also remember that they are responsible for keeping their state consistent, so I consider sanity checking a good practice. Coming back to your example of `Color`, RGB values and integers, I would design `Color` to accept integers and validating in the constructor that each is in 0 - 255 range, instead of using a factory. 
observers is listeners in laravel ? like if a user is activated send mail every 24 hours with latest post ?
Since you can also find the permissions by the ID and name you can instance the classes on the fly: ``` $role-&gt;addPermission(new Permission(1, "read", Permission::STATUS_ENABLED); $role-&gt;can("read"); ```
Agree with claran 100%. IMHO, the biggest advantage that validating the constructor brings is reducing checking throughout the codebase. In the example from the article, you can expect the Color object to be valid everywhere it type hinted in a constructor or function. I feel the trade-off of having to catch exceptions in the rarest of circumstances is minimal as compared to doing checks everywhere.
That's not necessarily the case. VOs can and should contain core logic that goes hand-in-hand with the value. They should just never contain *business* logic.
Yup. I would add that coming from using Smarty 2 on other projects, using version 3 was refreshing beyond template inheritance. A lot of Backwards Compatibility with the previous version hides a lot of improvements on much shorter and php-like syntax among other things (look for 'shorthand' and ensure you check the v3 manual, not v2).
And what causes that domain error if not constructor validation?
It's not like you start working with Drupal and you will be forbidden to choose another job for the rest of your life. If the incoming is really good, why not? If you dislike it so much, go for another job.
Services just receive other services or configs as ctor argument. Some services may throw an exception if, for example, given an invalid path when a directory was expected. Otherwise, just use the type system by hinting against your designated service interface.
My agenda?
This^ The only thing that guarantees my team won't hire you is if you're clearly lying about your experience. If you're a good developer, you're capable of learning new tech on the job and any ~~good~~ _halfway decent_ company knows this. If you lie about it, why would I trust you to write our software? 
Save yourself, avoid Magento.
&gt; It looks from afar that this microframework does nothing but provide configuration management for people who find pleasure in writing configuration :-). It's not for people who find pleasure in it. It's for people who don't find pleasure in it, but want to use a myriad of libraries without having to do it. &gt; Or does it also handle HTTP request, responses and so on? Currently there are integration packages for guzzle-http and relay. So in that sense. Yes. (https://github.com/hiraeth-php/guzzle-http and https://github.com/hiraeth-php/relay). But that's separate from the nano-framework. You are correct that it is not the responsibility of the nano-framework to provide that. All it does is provide a way for you to integrate libraries that do that. &gt; Or is it for CLI apps? Certainly someone could write an integration package for some CLI libs. &gt; The problem is the scope of the framework is not mentioned at all. Yes, I think that could probably be made clearer in the introduction. &gt; While I'm sure all the configuration stuff is handy in your particular workflow, for me it's not very valuable, because when I want something to take in a configuration, I just write a simple interface, ask for it in the constructor, and let the caller implement it. The larger component for me was abstracting the DI. Having a consistent config mechanism is useful, but only insofar as I make the config robust enough to handle varied uses of whatever libraries I integrate. 
&gt;C++ doesn't have a standard garbage collection mechanism, every library essentially does their own thing, and almost without exception (no pun intended), the way most C++ code handles memory management is highly dependent on very specific flow of code execution. When an exception breaks the standard flow at some (semi-)arbitrary place, all kinds of markers, ownership flags, and reference counts get out of sync up the chain and result in memory leaks. That's not a problem of poorly implemented exceptions, that's just the lack of proper conventions. What kind of change to the exception system would change this? By the way, if everyone was using RAII as their convention, this would not be an issue at all. &gt;For ex. if a constructor throws, should the destructor run? No, because the object has not been constructed successfully. &gt;If it doesn't run, it will fail to deallocate resources that were allocated. It shouldn't. That should be handled in the constructor and it should only handle one resource. If one class needs multiple resource, those should be encapsulated in RAII compliant classes themselves to take the burden from the constructor. &gt;In PHP we don't have this problem because object clean-up is done by the engine, we rarely ever write destructors, but in C++ this is a must. This doesn't change a thing. If you have allocated resources, you need to free them. PHP only saves you from handling memory as such a resource. RAII solves all those problems for *every* kind of resource, not just memory.
 $color = Color::createFromHex(...); $otherColor = Color::createFromRGB(...); if($color-&gt;equals($otherColor)) {...} You don't need a generic color that works in all possible cases, it just has to be a good fit for your bounded context.
That's not the definition I know. My understading (which is coming from Domain Driven Design by Eric Evans) is that the single difference between an Entity and a Value Object is that the VO may not have an identity (otherwise it is an Entity). Cite: "An object that represents a descriptive aspect of the domain with no conceptual identity is called a Value Object."
&gt; That's not a problem of poorly implemented exceptions, that's just the lack of proper conventions. What kind of change to the exception system would change this? By the way, if everyone was using RAII as their convention, this would not be an issue at all. Conventions don't ensure correctness. They are merely a fallback when the language doesn't offer the proper abstractions that prevent the problem in the first place. I probably shouldn't have used the phrase "poorly implemented", but let's say that exceptions, as seen in PHP, JavaScript, Java, C#, Python etc. are usable in plenty more contexts than in C++, because the abstractions of those former languages are more compatible with those additional contexts. That said, languages like Swift, Rust, demonstrate that you can be compiled at a low-level as C++, and still have a strong memory management system that doesn't fall apart during error scenarios. &gt; No, because the object has not been constructed successfully. I know what's the standard, but you still can have allocated some resources, and when you throw *in the middle* of the constructor, they won't be freed now, as the destructor won't run. We're not discussing what C++ does. We're discussing why what C++ does results in problems. &gt; It shouldn't. That should be handled in the constructor and it should only handle one resource. If one class needs multiple resource, those should be encapsulated in RAII compliant classes themselves to take the burden from the constructor. One resource? That's naive. But even with the restrictions you mention, an exception may occur after that "single resource" is initialized. As for RAII, that's basically what garbage collected objects ensure is the default case, so that's why PHP/Java/C# developers don't go around talking about RAII. &gt; This doesn't change a thing. If you have allocated resources, you need to free them. PHP only saves you from handling memory as such a resource. RAII solves all those problems for every kind of resource, not just memory. Uhmm, considering all primitives, arrays, objects (and therefore 99% of our code) is "memory" that still makes for a fundamental change of the effect of using exceptions. Also you're plain wrong, because PHP automatically cleans up resources whose ZVAL is garbage collected. PDO connections are closed, file handles are closed, socket connections are closed and freed and so on. I shouldn't explain all this, and the reason I have to, is the same reason why you seem unable to grasp why exceptions are used differently in C++ and PHP. 
This is my exact question: Where are WebSockets _not_ available?
HTTPS helps a lot there, and if a company's firewall circumvents + breaks that, fix the firewall.
&gt; It's not for people who find pleasure in it. It's for people who don't find pleasure in it, but want to use a myriad of libraries without having to do it. The problems is I can already use a myriad of libraries just through Composer. What problem am I supposed to have... that this framework solves?
&gt; The problems is I can already use a myriad of libraries just through Composer. Composer certainly lets you download a myriad of libraries. It doesn't wire them together for you though. &gt; What problem am I supposed to have... that this framework solves? Ideally you should not have any problems and no framework should be needed. All I can tell you is the problems which I have which this solves -- if you share those problems, it may also solve them for you. 1. The need to bootstrap new applications quickly with a wide variety of different dependencies. 2. Multiple configuration points and/or no clear separation between configuration data and runtime configuration (What's in environment? What's in config? What's in some if/else statement in the wiring?) These problems were actually largely solved by my previous framework, but relying more on the inherent/implicit ordering of DI became preferable to what I did previously which required some knowledge still of specific application components. This got rid of that one last thing. Hence abstracting the delegates as opposed to a container.
If objects's properties should be validated upon construction how do you go about complex validation? Like creating a new `User` from user-input data that should validate the email is not already used in the app, the country belongs to an accepted list of countries, the password matches some minimum security requirements etc? How about when mutating an object where 2 properties depend on each other (eg: state should be in a list of states from the corresponding country)?
Yes, each concrete object should have a weight. Ant is not supposed to carry an abstract number, but rather an object that contains Weight. I'm not a scientist but afaik everything has to have a weight. The point of Weight as value object as opposed to putting some integers is because of adding Gravity easily if needed, so you can compare a weight of iron in Earth to the weight of leaf in a black hole.
So I guess 7 levels deep code is ugly in WordPress, but [totally OK in Symfony](https://www.reddit.com/r/PHP/comments/692xzs/symfonys_code_quality/).
Magento is one of the few techs that are in my list of "not even if I was homeless".
I've had the "pleasure" of having to deal with clients who were already using magento twice... The first was a stupid simple issue that took way too long to solve the "magento" way... the 2nd turned into 2 years of hell supporting the system, my project manager is now instructed to take his quote and multiply 10 and split the difference with me if he takes on any new magento projects.
IE &lt; 10, Android &lt; 4.4 See https://caniuse.com/#feat=websockets
They let you trigger some kind of event when you modify a database entry. For example, I write data to elastic search when eloquent is used to update a model.
sure, I wanted to say that but typed DRY and then my brain kept going haha
&gt; Most frameworks ship with a ContainerAware interface and will automatically inject the container to the Controller if it implements this framework. And presumably anything else the user wants. And while a controller is not domain logic, IMO, this would constitute service locator. &gt; You have to construct the service from somewhere... Of course, but the lower down one can get the better. &gt; ...its generally acceptable to use the container in controllers to fetch the service that the controller requires... I'm not sure how you've come by this information. &gt; This is the default method for frameworks that relay on service locators (most of them). Seems a bit weird. &gt; Alternatively, you can leverage Auryn to inject the service directly. Most modern frameworks map routes to a callable definition that is your controller action, and have ControllerResolver and ArgumentResolver classes responsible for executing the callable. Right, which I would agree is the **better** way to do it. But this becomes essentially unusable for the `$container` paradigm provided by PSR-11 and we have to fall back to using Auryn directly. Because our container cannot just construct any old dependency, and it doesn't make sense to be wiring controller dependency injection for each controller. So this is exactly my point. What has `$container` done for us except encourage service locator? &gt; This will instantiate the Controller with it's dependencies, and then execute the method, also injecting method parameters. I'm aware, I use Auryn daily. But this isn't about why Auryn is great (I agree) -- this is, why on earth would you want to neuter it with some generic container injection? &gt; ...but having a strong understanding of how your framework actually works is a good thing to have. Given that I tend to write my own "frameworks," I'd hope I have that understanding. But this conversation seems to be moving away from why on earth I would want to convert Auryn + a handful of resolvers to a service locator container anti-pattern.
I just realized there's a couple classes that used underscores that were taken from elsewhere on the internet such as phpExcelReader https://github.com/derhasi/phpExcelReader/blob/master/Excel/reader.php class Spreadsheet_Excel_Reader. If that's the case, I'm assuming I'd have to start with PSR-0. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [derhasi/phpExcelReader/.../**reader.php** (master → 8d8bafa)](https://github.com/derhasi/phpExcelReader/blob/8d8baface615a0db28c6c5d1c73e85c82468819c/Excel/reader.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply diiog1g.)^.
Quick link to the demo: http://www.phpinternalsbook.com/
Are you sure you're asking the proper question? Multitude of variables aside, I don't see why anyone - senior or otherwise - would choose scratch when a pre-existing solution gets you 99% of the way there.
Which definition are you using? I was using the one espoused by DDD (or [this one](https://en.m.wikipedia.org/wiki/Business_logic), more or less).
Non-Mobile link: https://en.wikipedia.org/wiki/Business_logic *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^76725
`new Money(new EUR(1))` allows for extensibility. With god classes you're bound to whatever you have in your class as methods. You can do `new Money(new GrandmaCookies(5))` if you want, as long as you stick to an interface. Infact, that's how most of the popular drivers as implemented.
Senior developers, at least the good ones, don't prefer either by default. They first read the full project requirements, they discuss with their team, they may even spend an afternoon or two researching, prototyping and testing, and only then they start to prefer one or the other, on a case-by-case, component-by-component basis. The motto of every good developer is: "it depends".
Thanks for sharing..
I almost always favor going with an existing, well tested, idiomatic solution, whose maintenance and documentation is not my problem. For example your bank card number validator - I know a few things automatically, right off the bat: 1. I don't know the rules for bank card validation, thus I would have to spend time learning them. 2. I imagine those rules are not simple, so building my own solution, complete with tests, will be time consuming. 3. If I build my own solution, I own the maintenance &amp; documentation for it. 4. If I build my own solution, it means it's proprietary domain knowledge that a potential employee will not have used before, which adds ramp-up time (which is my goto argument against using home-grown frameworks in production, no matter how good they are). 5. This sounds like a common feature that a LOT of people have a need for, so I bet there's a solid, well tested solution available. So without even knowing what solutions are out there, those 5 things I do know inherently bias me towards favoring an existing solution, and thus making research into such a solution my starting point. Now, that doesn't mean I'm always going to use a pre-existing solution, because it depends a lot on those 5 factors. But *generally* I find that my default preference is a pre-existing solution, and that I need to establish solid reasons why I *shouldn't* use one.
I disagree that good ones don't prefer either by default. While I agree that it depends, the benefits of not reinventing the wheel are so substantial that you really have to justify why you should. A safe default pre-disposition should be towards using pre-existing solutions, and experience will you tell you how likely it is to find a solid pre-existing solution for a given problem space. From there you can decide how much you want to time box discovery or a research spike for going either direction.
Eww. No, it's not. Nesting deeper than three levels is a sign for bad design and should not be tolerated at all.
That is all true, but if you are making money from those users supporting those browsers is also a business decision, not just a technical one. Especially when the tools support a fallback out of the box.
&gt; the benefits of not reinventing the wheel are so substantial that you really have to justify why you should ...is a leading statement. And you're responding to a comment that says just that: justify before deciding a preference. Do I prefer not always doing work I don't have to? Sure. Is using a poor, existing solution more work than I have to do? Sometimes...
In symfony you usually interact only with api layer and dont need to go all nth layers into its code in wordpress you dont know which part is actual api and what part are internal functions.
Think of the dev that will inherit the project at some point. Using a few known or documented libraries/add-ons for common tasks will makes his life easier than having to comb through custom "from scratch" code.
Just put everything on github, It will act as documentation to what you have done during the years and what you have learned. It also helps to document your code, but i like to live with the rule good code shouldn't need documentation.
Depends if other projects incorporate what i need. If they do, Ill reuse it, why reinvent the wheel. If not, Well I have no choice but to create it from scratch.
&gt; (and be easily changed to Weight object "if needed") Then you have two different data types in your codebase that resembles into the same thing. Some of your codebase will work with `integers` as Weight, some of them will work with value objects as Weight. It is generally bad practice as it allows for mixed data types. May I ask why do you have to wait for your need of using value objects? &gt; $just_a_fkin_ant = new Ant(new Weight(new Gravity(new SpaceTimeCurvature(...)), new Mass(new HiggsField()))); Yes, it is crazy, but how would you code it when you wanted to do it with the same complexity? Please include `Weight`, `Gravity`, `SpaceTimeCurvature`, `Mass`, `HiggsField`. Maybe you can add Facades or Factories to hide the complexity a bit. At the end of the day, everything will be done somehow and the only difference will be using integers or value objects.
&gt;Conventions don't ensure correctness. They are merely a fallback when the language doesn't offer the proper abstractions that prevent the problem in the first place. It does. But the community is lacking conventions that mandate the usage of those means. &gt;I probably shouldn't have used the phrase "poorly implemented", but let's say that exceptions, as seen in PHP, JavaScript, Java, C#, Python etc. are usable in plenty more contexts than in C++, because the abstractions of those former languages are more compatible with those additional contexts. Fair enough. In C++ you can only use them when you are sure the code is exception-safe or rather when it was written with exceptions in mind. That's not an implementation issue of C++ exceptions, it is caused by the fact that exceptions were not part of the language from the beginning and hence did not become the standard way of error handling in many code bases. The same is true for PHP though. Throwing exceptions in code parts that don't expect them, can harm the correctness of the code, too. Or even make it crash fatally. Just think about the fact that you cannot throw in `__toString()`. This restriction stays relevant all the way down the function call tree. The only difference is that you can't leak memory with such errors in PHP. &gt;That said, languages like Swift, Rust, demonstrate that you can be compiled at a low-level as C++, and still have a strong memory management system that doesn't fall apart during error scenarios. Absolutely, because Rust was built with exactly this in mind. It took the good C++ conventions, refined them and built them into the language so that correct code is easier to write than with just a pair of constructor and destructor. Also, the developers could obviously learn from the mistakes that were made in other languages including C++. &gt;I know what's the standard, but you still can have allocated some resources, and when you throw in the middle of the constructor, they won't be freed now, as the destructor won't run. That's why I said every resource that needs to be freed must be encapsulated in its own proper class when doing RAII. That way the destructor of the containing class doesn't need to run, because the constructed object's destructor is run in the failing constructor. And even if you don't do that, you can place a try/catch in the constructor and free the half-way allocated resources and free them. In any case, the destructor should not and does not run and that's absolutely correct, because in RAII, if the constructor failed, the object never existed in the first place and hence there is nothing to destruct. &gt;One resource? That's naive. But even with the restrictions you mention, an exception may occur after that "single resource" is initialized. No, that's RAII. And I already explained the solution to the latter problem. &gt;As for RAII, that's basically what garbage collected objects ensure is the default case, so that's why PHP/Java/C# developers don't go around talking about RAII. True, but only for memory. That's one resource of many. ~~PHP~~/Java/C# have ugly try-finally patterns that you have to remember to always free those unmanaged resources, because the GC can only handle memory. Granted, C# got `using()`, which is kinda like the block-level destructor semantics of C++, but you still have to remember placing it, it doesn't happen automatically. Implementing auto-disposable patterns doesn't cut it either, because the resources are released with a delay due to the implementation of a GC. RAII solves the resource handling problem once and for all kinds of resources. That's why Rust adopted it instead of a GC. &gt;Uhmm, considering all primitives, arrays, objects (and therefore 99% of our code) is "memory" that still makes for a fundamental change of the effect of using exceptions. It's the most important one in everyday programming, yes. Still though, programs aren't islands. They need I/O, like files, network connections etc. Those resources need to be freed, too. &gt;Also you're plain wrong, because PHP automatically cleans up resources whose ZVAL is garbage collected. PDO connections are closed, file handles are closed, socket connections are closed and freed and so on. Reference counting can be easily implemented in C++, too. But nice to know, I thought they were only closed when the request has finished processing and the script terminates. After learning this I'd consider PHP even closer to C++ than to Java and C# in this sole aspect, because the synchronous reference counting semantics as the primary means of freeing resources are kinda similar to C++'s way of doing it. The GC just seems to be a fallback for reference cycles. TIL. &gt;I shouldn't explain all this, and the reason I have to, is the same reason why you seem unable to grasp why exceptions are used differently in C++ and PHP. Apart from the fact about garbage collection in PHP you didn't "explain" anything. You told me your view of the story and I told you mine. No reason to belittle someone here, I totally grasp why exceptions are used differently in C++ and it's not, like you stated in the beginning, due to a bad design of C++ exceptions. That was the whole point of this discussion, remember?
Symfony Bundle
I'd strongly suggest using Laravel in order to implement those features. You can use pusher with Laravel(just a configuration thing), with php artisan you can create the resource controller for User model which already exists within Laravel. For pagination $users = App\User::paginate(15); easy like that. Cheers
I think you kinda need to install PHP though.
I use the VR headset for programming in 3D. 
The `why` doesn't concern you, consumer. Unless there's something wonky/unexpected going on, the code behaves as a black box to be consumed only. The `why` can live in the inline comments in the code itself (not exposed by the docblock/reflection)
To get out an initial release, I wouldn't reinvent the wheel. Once you have results, see what the bottlenecks are and customize to your needs. Odds are: * You will contribute to an interesting project (always good for experience, profile, &amp; community) * Create something new (from scratch) specific to your improve requirements Not really odds are they?
... lol. All of these "features" are so complex there is no way you will find a stand-alone php package for them :) You will need to add those in as part of a framework.
Agree with this. I feel that if a piece of code warrants an inline comment, then it warrants being moved to a separate function with the inline comment included in the DocBlock.
I've made a [PR to support Auryn in zend-expressive-skeleton](https://github.com/zendframework/zend-expressive-skeleton/pull/161).
The following will not answer your question. From your feature set, a WordPress + BuddyPress install would take care of all that. Would take less than 10 minutes to get up and running. Then spend your time making the platform yours.
I would personally opt for using constants so that you can typehint them: `new Money(Currency::EUR, 5)` I'm not sure whether using a value object for the amount provides significant advantages in this instance, but a single file that defines all of the available currencies seems far more manageable to me, with little downside over using a class for each separate currency. The Money constructor would validate that the passed constant is a valid value for a currency.
&gt; they may even spend an afternoon or two researching, prototyping and testing If only most companies could afford to allow them to do that.
1. Front-end validation solves a different problem 2. What do you do when a user tries to change the email used for his account? Obviously you validate the user input, but what do you do about the entity's valid state? How do you implement `$user-&gt;setEmail($_POST['email'])` or `$user-&gt;populate($_POST)` (code simplified for brevity)?
&gt;I have implemented it tens of times why didnt YOU make a package for it then? :)
&gt; And you're responding to a comment that says just that: justify before deciding a preference Sorry but no. That's not what I'm saying. I'm saying *"have a preference for pre-existing solutions, and justify why you should deviate from that"*. That's not the same thing as "justify before deciding a preference". &gt; Do I prefer not always doing work I don't have to? Sure. Is using a poor, existing solution more work than I have to do? Sometimes... And as I said, experience will indicate when a problem space sounds like it will have a solid pre-existing solution, and when it won't. For most web problems though, there is usually a pre-existing solution, hence why looking for a pre-existing solution is usually my starting point.
&gt; How do you implement $user-&gt;setEmail($_POST['email']) Setters on value objects? Nope nope nope. Setters will make it almost impossible to maintain a consistent internal state especially if one property depends on another. If I need a user with a different email then I would make a new user object. And if I want to check to ensure that the new email was unique then I would do so in my ChangeUserEmail command.
So ... you're looking for a forum. People have done this before, here's a list: https://www.codefear.com/scripts/5-best-php-forum-bulletin-board-script/ You can build new features as module for those forums, I'm pretty sure most of them support this.
If your knowledge comes through you don't necessarily need a portfolio. I've never had any code I was able to show an employer.
Not really. At least on the break part. I've only had it happen once and it meant just a minor code change. Also, I would highly suggest WP Engine to anybody. Turk-key staging and they take care of core updates automatically. And honestly, you should be monitoring your site anyway.
I'm not even in the industry and I know how flawed that statement is. 
Surely you have an api of cpanel itself https://documentation.cpanel.net/display/SDK/Guide+to+cPanel+API+2 you need create a key and need ROOT ACCESS LEVEL TO THE SERVER. . But the problem i see is the security concerns. The safest way i can think is added as a parked domain, or in some cases as an addon domain if your system dont require .htaccess I have many domains actaully and use the api for check the name an quota of domains, but is good time if you play a little with addon domains and parked domains. Are very powerful for software development if u know what are u doing. My main problem with that were in a system the customer want in CakePhp, who itself put limits in .htaccess 
If I'm doing a personal project for fun, I like writing stuff from scratch. Helps you to get a better idea of scope and different problem solving things. But if I'm doing something I expect other people to use or for work, always *always* go with a pre-built, tested, and widely used solution. The only time it really comes into question is if there's a pre-built package that doesn't actually do everything I need it to, or it's got very little usage, or if it doesn't do exactly what I need and would have to work around the package. In other words, "it depends", but all things being equal and for a very high level overview, always go with pre-built.
&gt; neither how could be predictable http://www.openwall.com/php_mt_seed/
Tip for next time. Submit a talk. If it's accepted you get a conference* pass. If it's rejected, organisers usually offer you discounted tickets long after the schedule has been announced. Edit: *not specific to this conference.
Value objects, entities etc need to always be in valid states, that's the whole premise. I gather you don't have setters in your entities either and you only use commands to modify an entity? If that's the case your entities/vo are always in valid state. The validation in the commands are more complex than those in the entities so, again, doing the validation outside the entities should be enough.
I recently stopped writing PHPDoc for functions which show correct/complete argument and return types. Writing PHPDoc is in such cases just redundant. If I can tell what's in array, then I write the PHPDoc block :)
related post -&gt; https://www.reddit.com/r/PHP/comments/6emaik/composercat_graphical_user_interface_for_composer/
I'm not agreeing or disagreeing with this (I know nothing about Laravel), but why the down votes? A quick comment explaining why this is bad advice would be much more useful.
Agreed. (FWIW, I have been convinced that a Container is a Container, and can be used for DI from *outside* the object, or for SL from *inside* the object. The difference is in the use, and in the intent, not in the implementation. Cf. &lt;http://paul-m-jones.com/archives/5853&gt; for more.)
Regarding the section titled *Maybe Your Don’t Need It*, I believe the author made a false assumption that has led to a poorly designed object. The entire abstraction layer argument is an over blown strawman. Dependency injection isn't dependent upon abstraction or interfaces. `public function __construct(GuzzlHttp\Client $client)` is a valid way to inject your Guzzle dependency. More than that, it's possible to achieve what the author did while still providing the ability to inject Guzzle: public function __construct(Client $client = null) { $this-&gt;client = $client ?? new Client(); } If you feel that the defaults for Guzzle are good enough for your project, then roll with it. But if you want to configure Guzzle, a bit the above solution has no longer forced you into using a specific configuration for Guzzle. From personal experience, I wrote an app that downloaded a file off S3 using Guzzle. When S3 had their outage a few months back, I ended up ddosing myself. The FPM workers spent 30 seconds(php timeout) trying to connect to S3, which wasn't responding. By that time another request had come in and so on. Most if not all of my instantiated Guzzle Client's have a timeout option specified. The author's assumption that each Guzzle instance is identical or that everybody would want the same guzzle instance is incorrect. Take the following code for example: class DatabaseAbstractionLayer { protected $pdo; public function __construct() { $this-&gt;pdo = new PDO('mysql:dbname=testdb;host=127.0.0.1', 'root', 'password'); } } Would you use that? Most likely not, but all the same arguments the author made can be used to argue for the above code.
I'd still consider that installing something. You have to put it on the server. That's installing it. 
Generally it is considered a bad pratice to pass a container. I agree, but Controllers are a special case (if you want them to be) if they don't contain any business logic. Passing a container can actually be more performant (because autowiring is slow as **peeep**) and is also easier to understand at the beginning. PHP-DI "Best practice" guide says: Using dependency injection in controllers is usually where it is the most painful. This is the solution we recommend: inject dependencies in properties http://php-di.org/doc/best-practices.html#writing-controllers So now we have multiple possibilities: 1. The "pragmatic" way: Injection the container into the controller (anti-pattern, service locator) 2. The PHP-DI way: Inject dependencies in properties (breaks encapsulation) 3. The "academic" way: Constructor injection (slow, complex setup, hard to understand, not good for controllers) 4. Constructor injection with strongly typed structs (sadly not supported in PHP) 5. Factory (hardwired, not easy to replace objects for unit testing) 6. YAGNI? 
&gt; because autowiring is slow as peeep Only if you do your scanning and wiring at runtime. Symfony has what it calls a compile phase in which all the config files and what not are combined together and eventually written out as a cached container. So with Symfony at least, there is no speed penalty. 
It's funny, the conclusions here are basically the same as Tony Marston in his infamous anti-DI article, except this is reasoned and well-written instead of a condescending angry rant. 
You clearly hav no idea what Symfony is or how it works. Never had issues debugging it. There are no issues with yaml configuration files, easy to read, not too verbose to write. Dumpers, compilers, configuration managers etc.. do you even know what they are used for? You call it bullshit, I call it compiling stuff so you don't have to calculate it every request. I guess it's easier to bash something for not understanding it, than to actually ask what it's for?
Ok, i think exactly like you, thanks :)
You're replying to the wrong person. I was just answering his question as asked. He said he can't upgrade his PHP version, so he's probably using shared hosting and is limited by that. Lots of crappy shared hosting are still using old versions of PHP and don't allow upgrading. For versions between 5.3.7 and 5.5, the `password_compat` lib will allow usage of `password_hash`. Also, I personally think XAMPP is a bit crap and that there's better solutions - but that's just my opinion. Tools like docker or vagrant which allow for repeatability of environments is extremely important to make sure things work the same in development as in production. Never will you be using XAMPP in a production environment. https://box.scotch.io/ is a decent starting point.
The assumption is PHP is already installed, as stated by OP.
When you say "projects" I tend to think of like the "whole project". If it's something someone else wrote, I'm pretty much always going to want to write it "my way". Not saying that's a good or practical thing, but I just don't like having to learn someone else's code base that I'll see full of silly decisions that I wouldn't make right now... and by "someone else", I'm including myself in the past. I'm purely talking about enjoyment here. Your examples are quite varied though... * bank card number validator - by this I guess you mean like "luhn"? - small, but very important things like this I'll always use a library for * search and autocomplete field - are you talking frontend JS here? I'm shit at it, so my JS is 99% jquery libraries * e-mail templating - this one is a good question, so far I'm always written my own, because the requirements are pretty simple. This is something where I really should use a composer library though.
&gt; I can't believe people think configuration files in YAML or XML make sense Yeah this shit is so weird. I remember doing a contract gig years ago where the they just had the one PHP dev. He didn't have time to actually work on any of the client projects, because it was building his "awesome framework" that I doubt he ever finished. I got in and the got the client work done and got the fuck out after 3 weeks. He was just spending all his time fucking about writing pointless crap like .ini config parsers - super important according to him because ".ini is easier for a non programmer to edit if they ever need to"... when the fuck has that ever happened. Great priorities + logic. Another thing he was doing that he brought up in my interview... he asked how I sanitize data before putting it into the database, I just mentioned the regular methods that are handled by your ORM with named params n shit. Wrong answer! This wasn't enough for him "just in case that doesn't work"... his "solution" was to run all fucking strings through urlencode() and store it's output. Pretty l33t eh.
How does said "senior developer, at least the good ones" justify writing from scratch if there's a product which fits 99%? Well, I don't qualify for that title then.
&gt;&gt; the benefits of not reinventing the wheel are so substantial that you really have to justify why you should &gt; ...is a leading statement. And you're responding to a comment that says just that: justify before deciding a preference. No
Thanks for your input mate.
so I can take that you're saying that drupal is going to be around for a while?
In PHP you can `extend \GuzzleHttp\Client` and override everything, can't you? Not saying this is a great solution. Just that there are ways, this is not a blocking issue.
&gt; The performance impact with normal sized datasets is likely to be negligible This. With 5k objects the results are within 1-2ms difference (and my laptop is pretty heavy loaded with other stuff at the moment), but even 5k objects is... a bit too much. Doing stuff with that many objects would most likely be a cli/queue task, or something that should be refactored - let alone working with half a million of them.
Service Locator has it's benefits and by using PSR-11 (container interop) you can decouple yourself from the framework.
##Code smell Code smell, also known as bad smell, in computer programming code, refers to any symptom in the source code of a program that possibly indicates a deeper problem. According to Martin Fowler, "a code smell is a surface indication that usually corresponds to a deeper problem in the system". Another way to look at smells is with respect to principles and quality: "smells are certain structures in the code that indicate violation of fundamental design principles and negatively impact design quality". Code smells are usually not bugs—they are not technically incorrect and do not currently prevent the program from functioning. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove
YAML is exactly the same as associative arrays in PHP. The only differences are: 1. The syntax. 2. Only fundamental data types are supported/allowed in YAML. 3. Parsing is tremendously slow, especially when compared to native PHP or even JSON decoding. YAML is AIDS and may take a rocket out of this world any day now, together with CoffeeScript and all other "let's make programming available to non-programmers" nonsense.
SECTION | CONTENT :--|:-- Title | Matthias Noback - Hexagonal Architecture - Message-Oriented Software Design Description | Commands, events, queries - three types of messages that travel through your application. Some originate from the web, some from the command-line. Your application sends some of them to a database, or a message queue. What is the ideal infrastructure for an application to support this on-going stream of messages? What kind of architectural design fits best? This talk provides answers to these questions: we take the *hexagonal* approach to software architecture. We look at messages, how they cros... Length | 0:53:21 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
&gt; Then we need to wrap a Guzzle client instance into a wrapper Cool a wrapper around a wrapper which is actually a wrapper around the original C libary
Depends on how robust existing solutions are. In most common use cases for web based projects yes most defiantly, there are already robust packages. It will also depend on the project type: * If it was for a paying 3rd party customer then I would almost exclusively reach for packages for budget, deadlines, maintainability and support reasons. * Internal projects where budget isn't so much an issue and often the new project needs to interface with many different systems or various ages, languages etc then its normally a hybrid of home grown stuff and packages. * My own personal projects at home you can be pretty sure I have written from scratch an entire framework for each and every project, mainly to just learn and see the "bigger picture" its really helpful for that. At the same time that why my personal projects never get finished 
FYI: https://github.com/paragonie/random_compat
How appropriate. You fight like a cow.
Okay. I'm assuming you understand and accept all of the following? * mt_rand() is not secure * There are only 2^32 possible mt_rand() seeds * You can predict future mt_rand() outputs after leaking its internal state * CAPTCHAs generated with mt_rand() leak information about its state * Lazy attack: 1. Precompute: `for ($i = 0; $i &lt; (1 &lt;&lt; 32); ++$i) { mt_srand($i); generate_captcha(); save_sha256sum_of_captcha();}` 2. Reverse lookup of `sha256sum($captchaServed)`. * A clever bot can totally defeat your CAPTCHA by using this exploit * Even worse, it leaks your mt_rand seed, which makes any other places mt_rand is used predictable * Using `random_int()` (PHP 7 or random_compat) would prevent this attack I assume you have your own reasons for not using random_compat. What's stopping you from cloning its functionality into your own functions? It's rather straightforward. https://github.com/paragonie/random_compat/blob/634bae8e911eefa89c1abfbf1b66da679ac8f54d/lib/random_int.php#L41-L189
I'm not fighting, I'm observing. I'll help you further. Absolutely nothing I said suggests "writing from scratch if there's a product which fits 99%", unless you think there is *always* a product that fits 99% to everything. In which case that's one more reason you don't qualify.
Read about actor model. Then read more about concepts from structural programming (Coupling, coheasion). This will help you to break your system into actors. Learn about encapsulation of actors. Then learn about polymorphism and late binding, Open/Close principle and GRASP/SOLID principles. Also worse to read about design by contract (not use, at least read about it).
Hmm, those are not good examples of "smells". **Too many dependencies** This is proposed as a smell, because it doesn't look nice on a constructor, and because it violates Single Responsibility Principle. - You can combine related dependencies in a single SPI (service provider interface) to reduce their count in the constructor. - You can use setters to reduce their count in the constructor. - Taking dependencies in is not a "responsibility" for the taker. It's an initialization requirement. So the number of dependencies is unrelated to SRP. **Cyclic Dependencies** This is *100% true* for packages, as in Composer for ex. When package A depends on B, and B depends on A, you effectively always use both together, so you might as well have a single AB package. But it's *not true* for runtime dependencies (as is the case of Dependency Injection), because of polymorphism. A and B don't have to be A and B, but they can be "subtype of A" and "subtype of B", or in the case of interfaces (which should be preferred for DI), "some implementation of A" and "some implementation of B". Since the implementations/subtypes are not locked in, circular runtime dependencies don't result in the same problem as circular package dependencies. **Injecting Dependencies For Other Objects** I don't know where this is coming from but suggesting it's a smell is bizarre to me. If an object can't inject for other objects, it implies you should have a flat list of components, with no Adapter/Bridge/Facade/Module objects, where everything is low-level and interacts with other low-level components. Which would be a very strange outcome from eliminating a "smell". You might say the *outcome itself is a smell*. No, if you can create a simple object to represent a coherent sub-system, you should consider doing it. Once because it makes working with the sub-system simpler, but it also *reduces coupling to its individual elements*, which is an important property of proper abstraction and architecture. And if you'll have such objects, then you'll be injecting objects for which you take dependencies on your own. It's not a smell. **Maybe Your Don’t Need It** This is one I could agree with, but it's a bit of a straw man to suggest we inject everything. You can go over people's code and see they create plenty of objects directly. It has always been a balance of configurability and pragmatism. And the "APIs needs HttpClient" was not a good example. I would definitely inject the HTTP client in this case, considering I've used APIs in such different circumstances, i.e. through proxies and tunnels, to name a few. The Guzzle client does have a bunch of options that should be configurable, as well.
The simplest check of items in array in php is $items = (function (Item ...$items) { return $items; })(...$items);
I apologize if the questions seems ignorant, it might be because I don't use Symfony myself, but what would be the point of the certification?
It doesn't indicate how much you worked with Symfony, it only tests the knowledge. However, it's pretty hard to get the certification and understand all the topics without having worked with Symfony.
Yes. I understand implications. Cloning/simplifying could be a good solution for 2.0. Thanks.
In 15 years of working in this industry, nobody has ever asked me for a certification of any kind, so in short, I wouldn't.
That nobody has ever asked it, doesn't mean you'll not gain an advantage if you show it to them. People without certification can get jobs just fine in our industry, but if two the same people apply to the same position, and one has a certification that proves their knowledge, who would you hire? Edit: Besides this, it would be very weird to ask this, because you would list certifications on your resume.
Every job I've been interviewed for has included a test of my competence in PHP as a language. A framework specific certification is redundant in this situation and is utterly useless as a tie breaker.
OOP is not necessarily the right way to do things. In fact, you'll find that there's many different ways of doing things with OOP tools, but no underlying theory that says the way things *ought* to be done. An object with member variables inside and methods attached to it is basically a collection of partial functions. Interfaces allow you to specify the signatures of the partials, which can be useful for code organization. There's many ways to handle database interaction. Frameworks often suggest using their ORM, but I'm not a fan. I wrote [an article](https://royall.us/separating-database-interactions-into-distinct-objects/) on OOP database interaction a couple months back. Basically, you could have a `Users` class with a `\PDO` inside of it and a few public methods that return a `User` that you've selected by ID or email, or return a `\Generator` that contains a set of users. For the `User` itself, you may consider providing methods that pass its member variables into a provided `ExternalOperationInterface` to completely separate database logic from whatever methods a `User` has. In my opinion, the key principle of OOP is that an object should never return its members, only pass them down into a lower scope. Today, though, it feels terribly awkward, even if it was "clean" in a certain way. Now I'm writing my PHP with plain old functions that take a `\PDO` and return a dataset (or `void` for writes). The important thing with procedural code, as with OOP, is to make your functions single-purpose and short, with each function having only one or two control structures and only one side effect. If you can separate your DB and service interactions into their own functions and only invoke those near the outermost scope, you'll find that 3/4 of your application is composed of easily testable pure functions. Testability and readability are the most important characteristics of your codebase. People make messes in OOP just as much as procedural code, so don't expect it to solve all your problems. If anything, the inheritance and reflection features just open the door to greater confusion without putting any restrictions on the sort of problems you can cause yourself.
I've had an AWS developer certification and I've only had positive comments on that. Also, an exam (also for AWS) isn't expensive. So even if I would gain € 5 a month on my salary because of it, it pays off in 2-3 years. And learning for the certification will also help you just with developing. By making the list I've already learned new things about Symfony, and that's something I don't even need to have an exam for.
Thanks for the detailed answer, man :-) Really appreciate it! I might just stick to the good ol' functions as I know them and focus a bit more on cleanliness and structure.
Something that changed my perspective lately has been spending some time writing Clojure with its Luminus web framework. It's a much looser concept than frameworks in other languages, but it provides everything you need to get an application running. Clojure is the superior language, but I prefer the PHP deployment environment where I can put a dozen low-traffic applications on a server without worrying about any memory limit. As far as I know, this is not a good idea with JVM languages. I plan to write an article later this year on adding Clojurescript to PHP applications, since the frontend is typically where the real messes are.
&gt; unless you think there is always a product that fits 99% I do **in this discussion**, because that's OP's premise. At least that's what I was reading… but you know reading seems not be be one of my strengths. Wait, you did read more than the title, did you?
on the == vs === side attack. Thank for the information! Very good to know. 
I would quit if a company told me I could not prototype/research
Yeah, use [hash_equals](https://secure.php.net/manual/en/function.hash-equals.php) for stuff like that.
Depends on the 1%. 
&gt; using the DI Container as a Service Locator is one of the most infuriating anti patterns on account of the fact that all the symfony recipes and tutorials do it to keep succinct so a vast proportion of the symfony community are totally oblivious to the fact that it's not actually designed to be used that way. It happens because the way containers are implemented encourage it. If the creators of a container can't resist the urge to pass the container everywhere, what's left for everyone else? The real solution is to allow one container to compose dependencies from another container, thus allowing the easy and concise creation of smaller, focused containers for specific parts of the system. Symfony doesn't have this, and so people will keep doing silly things with it, because the container is poorly factored.
&gt; in 2 or 3 years, PHP will be a different language That's just not true. If you look at the last couple of years, you see things have improved a lot, but you can certainly not describe it as a different language. The Symfony framework is also extremely stable and the core features are unlikely to change a lot in the next couple of years.
3 years ago, we didn't even have PHP 5.6, are you seriously saying no major additions have been made to the language in that time? The LTS version of Symfony is coincidently 3 years as well.
I'm not saying there are no major additions. I'm saying it's not a different language. Of course things improved a lot, and it changed a lot too, but I wouldn't call it a different language because of that.
Perhaps I could have worded it better, but my meaning behind it is that even assuming some small advantage is to be gained from having this certification, in the 2 to 3 years you suppose it takes to pay for itself, it becomes redundant. In such a dynamic industry as web development, nobody is going to pay attention to your 3 year old certification when things have moved on so much. You would have to get re-certified every year or two.
I just made the € 5 up to show how quick it would pay for itself. Even if you only gain € 5 a month for it, in 3 years, it's payed off. I personally believe I gain more because of it, but of course I can't prove anything by myself. You would have to get a large amount of data on salaries to prove that. And yes, you would have to get re-certified. It will likely be every two years because of new major Symfony versions being released every 2 years.
&gt;The syntax. Precisely, this is what people use YAML for: its syntax... I don't see the parsing speed as an issue unless you want to parse a YAML config on each request which would be a dumb thing to do unless you really don't care about the performance overhead. Now stop over-reacting. Some people just don't like a plain PHP array for their configuration that's all. I don't really get how it's that big of a deal Also comparing it as CoffeeScript is plain wrong: CoffeeScript aimed at replacing JavaScript, nobody tried to replace PHP by YAML except for some configuration bits where really the language matters little and what you want is readability.
&gt; Please explain how you think an interview process without asking for a certificate is a waste of the candidate developer's time? I'm sorry, I could've been more clear. I don't think it's a waste of developers time to do a small/medium assignment. However, to make sure a developer has in-depth knowledge of (for example) Symfony, you can't do this without making a huge assignment, which would waste a developers time. As a developer, I wouldn't spend a week making an assignment for a possible job. If a company requires that, I would just look for the next company. &gt; It's a bit of a vague statement to me, since I don't know the contents of the certification, but if if the certificate can be obtained by merely answering multiple choice questions, I don't see any real value to it. I'm sorry you don't see the value because of the type of questions. It looks like it's easy to fake, but it's not. If you don't know Symfony, you will not pass the exam. The topics the developer has to know for the exam are described [here](https://sensiolabs.com/en/symfony/certification.html). &gt; If I need a developer to work on a to do app, it seems pretty relevant to task him this as a code assignment. &gt; Currently, the code assignment I give candidates is to deliver an RESTful API that provides a user and group management system. The task has some requirements as to what the users and groups should have of information and how they are allowed to relate to each other. &gt; The task has no requirements as to how to solve it, other than using PHP and have a database backend. &gt; Additionally the code should be delivered with a description on how to test it. &gt; This code assignment isn't doable in an afternoon (and that's not what I'm looking for). But this is my point. Somebody who is just starting with Symfony could make this for you, and easily allow the test. But then you don't know that he has knowledge of things like flash messages, or string interpolation in Twig. That's what the certification is for. It's proof that somebody has checked almost every part of Symfony and knows his way around every corner. Not just the basic corners to accomplish the tasks. For a simple RESTful API, the basic corners are enough, but there are enough applications where those are not enough, and you need a very deep understanding of the framework you're dealing with. You cannot test that deep understanding with an assignment that takes less than 20 hours. And anything more, and expert developers just pass you on, because they are not going to work more than half a week unpaid for a possible job. &gt; When the assignment has been delivered, they are (maybe) invited to a follow-up interview where we will discuss the code and the developers choices. &gt; We actually had a candidate with good looking educational merits who delivered his task in a Word document (pasted PHP code into a Word document and mailed the document to me). This is what I would expect. A certification is an addition to this process. Another way you could be sure the developer is the right choice. It is not a replacement for any of these processes. Also thanks for taking the time to write such an extensive comment. It's always great to learn about hiring practices from other people.
you've been programming for many years and you don't know oop
I actually have a separate server designed to handle automatic tasks and queues, many people think my setup is bad, buts stood the test. I have a gateway that handles the queues then sections them off into separate queues that constantly running php CLI apps are listening for. i have about 40+ of them running. then 1 massive task that runs every night to unlock rows from frozen sessions, clean up orphans (millions of them could be removed in 1 night) things like, Items, Characters etc. btw did i tell you this is for a online multiplayer game?
For some companies (agencies especially) it's a good way to show they have qualified developers and some clients even require a qualification of some sorts. Also for more junior developers, it's a good way to get started: it pushes you pretty far in framework/patterns/PHP knowledge. 
/u/zak10 is talking about the example in the blog, where this is not possible because Guzzle is not injected.
Adding a property to your class with a typehint is no more work than grabbing a service from the container. It sounds to me like the bit you are trying to avoid is having to setup your service config files while you are still building your classes which I understand. The answer is TDD with **test doubles**. I don't inject real dependencies until I've finished and ready to plugin to the application. My services are built in isolation in unit tests and their dependancies are created as test doubles using [Mockery](https://github.com/mockery/mockery). If you work this way then actually instantiating your services (whether you do it with config files or just in plain PHP) is the last thing you do only after you've built all the components and tested they all work.
[removed]
define: install in·stall inˈstôl/Submit verb 1. place or fix (equipment or machinery) in position ready for use.
I didn't know we were talking about equipment or machinery. Would you like to look up more modern usages regarding software? In every example I've found the usage of an 'installer' is used to mark the process of installing.
Change it to $field = get_field('product_size', get_the_ID()); if(!empty($field)): See https://stackoverflow.com/questions/1075534/cant-use-method-return-value-in-write-context
Didn't solve the issue. Hope I did it correctly :/
Converting a YAML to an associative PHP array on deployment - or when it's been changed - is fine. Performance with regards to configuration matters almost always takes precedence. However, you still end up with PHP - so why not just use PHP? I did not compare YAML to CoffeeScript. CoffeeScript is not a replacement for Javascript nor was it ever intended to have its own engine. It's a layer on top of it. But now that you mention comparison, YAML and CoffeeScript do have striking similarities. E.g. the whole Python-esque indentation significance (block delimiters), their less-is-more maxim, and their fair shares of debugging annoyances. I most certainly did not mention YAML as a replacement for PHP, either, which makes no sense. I'm not overreacting, but I must speak my mind when half-arsed implementations begin to overshadow the need for actual programming skills and etiquette. When exactly do I need an inexpert joker changing my configuration files? What executive person would be comfortable with a rookie, who cannot determine the impact and consequences of his fiddling around in YAML files?
I have 5.6. That can't be the problem
When you say the libs can be put behind a "layer" what does that layer is supposed to do to replace the need for DI?
it is the problem, there's nothing else in there that would trigger it... are you sure it's PHP 5.6? maybe the PHP on your commandline is 5.6 and the one that the webserver uses is &lt; 5.6
Laravel is a good entry-level framework. I've heard Laracasts are good too. Also, there are plenty of posts on stack overflow, so you should be able to find your away around.
&gt; If given two options "one giant factory" or "too many tiny factories", I might have to ask why are those the only two options. Yeah I'm not sure, I'd love to see other options though (as I don't know any, admittedly) if any exist or if someone comes up with something better.
Pretty sure that is the issue. `empty` can't accept a function return value, only a variable.
Don't waste your money on certs.
&gt; It can't cache the instantiation logic of the hundreds of controllers, services and so on which are given to it explicitly at runtime. So the speed penalty is still pretty much there. Not really. The compiled container is basically a big factory with a method for each service. The method already knows what dependencies are needed. Here is an example: protected function getGameImportControllerService() { $this-&gt;services['game_import_controller'] = $instance = new \AppBundle\Action\Game\Import\GameImportController( $this-&gt;get('game_import_form'), $this-&gt;get('game_import_reader_excel'), $this-&gt;get('game_import_updater')); $instance-&gt;setContainer($this); return $instance; } So for each controller you define as a service you end up with a new method. The real autowire functionality is just now appearing but basically it will scan all your controller and makes a factory method for each one. Still a work in progress so we will see how it all turns out. So no run time reflection, annotation processing or config file parsing. You get the same production container regardless of how you configure your services. And yes, even leaving out the controllers, you do end up with a lot of service definitions in Symfony. Easily in the hundreds. 
Thanks for the good well founded comment.
i could help you but im waiting your payment, if you pay me *i'll help you* 
My bad.
Yes. Should be OK.
I'll just leave this work-in-progress here: http://capsulephp.com/
If you want to learn about OOP properly you should go back to basics instead of launching into application development. I learnt OOP at college and we started by programming a zoo. Not a zoo application but an abstraction of a zoo. We modelled all the animals, staff, enclosures and attractions and considered how they needed to be able to interact with each other. This might seem pointless but essentially OOP is about breaking up your program into an abstraction of small components that interact with each other and that was the point of the exercise. Once you have a good grasp of abstraction you should look at SOLID principles and Design Patterns to understand how you can use OO to effectively solve problems. As others have suggested, when you get to a stage where you are actually engineering software with OO you will find yourself coming full circle back to frameworks but the foundation understanding will allow you to write better code and design better software solutions. Understanding this is the real difference between someone who just builds code and someone who **engineers** software.
well if your observing the conventions of OO it's bad practice for **any** of your internal properties to be public. You should keep all internal logic encapsulated within the class and expose only what you need on a public interface. Take a look at encapsulation: https://en.wikipedia.org/wiki/Encapsulation_(computer_programming)
Namespaces were introduced in 5.3, and composer is compatible with it.. so, you can start using the modern standards whenever you're ready . Also, your views on encapsulation would get you an F in any computer science class. Just sayin.
maybe for you as a person..but for an it company..if they try to get a project..showing that you have certified engineers is a real added value..and Symfony and Zend certification are not just framework specific..they focus also on PHP skills..so if hiring I would definitely prefer a certified engineer..although todays situation is that companies prefer any engineer..since people are so hard to find
I'm aware, yes, can create methods to manage the properties, but it's a bit much to add several extra methods for writing and reading to each of the properties. Regarding public properties and best practices, have a look at code from contemporary coders for widely used code in Wordpress, PHPMailer, and the AWS API. All of those have public properties. Amazon is less likely to, but there are some classes that do have public properties.
I would prefer someone who actually knew practical solutions to common problems and not the correct syntax to obscure global functions. Like I said, in 15 years I've never had anyone require I had this, and I've never seen a company trade on it, nor do I see how they reasonably could.
C'mon, this guy thinks OOP is some kind of beast and you're just filling his head with more buzzwords.
&gt; Wordpress, PHPMailer You've picked two projects there that are infamous for poor code quality Look I'm not going to argue with you about it. This is a long established principle in object oriented programming. If you don't want to do it then fine but if you're looking for examples of good object oriented code then for gods sake stay away from Wordpress.
start to practice making some simple sample php applications
honestly the best way to learn
&gt; This is literally shorter to write and faster to run in plain PHP. For simple things, maybe. For anything more complex, not so much -- and yes, I hand-write containers often enough to know. But my needs may not be your needs.
A certification tells your interviewer that you don't trust your skills enough to believe you would be accepted for a job without some additional proof which the certification provides. That is usually okay for entry level developers. When somebody comes and says: "Hey I don't have any job experience, so I decided to get the cert to prove I have skills" that's one thing. But if a dude with like 7 years of experience tries to use certification as a proof of something, that is just funny.
Looks like your semicolon is on the wrong side of that quotation mark on the end of the $dsn variable
&gt; maybe the docs have to be improved. I have no doubt this is true.
Yes 121 is the $pdo = new PDO($dsn); I just did a var_dump and echo on $dsn and it displays the variables properly. 
Totes McGoats! it works! Thanks for your help! 
Think of a problem you have, then design a simple solution for it and code it out. Maybe you need something that emails you once a week with a reminder, or a simple to do list, whatever it is.
WordPress itself is OK to work with _if_ you don't need anything extra (e.g. if you can get away with just a theme you're going to have a somewhat good time). If you need to install a larger plugin or override some core thingies shit hits the fan quite fast. Global scope pollution, spaghetti, some meatballs here and there, end-user-driven platform development, aversion to known good libraries and packages, etc. When you're processing a request and formulating a response in WordPress, you can never know what is going on. You have to double check things everywhere for no real reason and you need to make your own detours to make things operable. People will tell you that you can do _anything_ with WordPress _and with ease_! These people will also most likely be the kind of people who have not even touched things like Symfony, Laravel, Slim, and so on. Those people also constantly mix up _Composer_ and _Visual Composer_ (a WP plugin for building pages with a WYSIWYG). The developer community is large but consists mostly of wannabe developers and consults who can't tell if they're using MAMP or XAMPP or whether they should install a plugin to change a hero image on the site or not. Also, supporting PHP **five point fucking two** just to keep marketing numbers (number of active installations) up is fucked. There is literally no other reason I can think of why such old PHP versions are supported. The version constraint also limits the toolbox with which the core team could upkeep and enhance WordPress. All in all for a developer WordPress is a maze that has 25% of walls changing constantly. You can kinda learn it with time but it will _always_ be shitty to walk through. If you want just a basic CMS-backed website then WordPress is an OK choice. Disclaimer: I've used and worked with WordPress for over a decade now. I pay my rent with WordPress and attend local community events related to WordPress (we have nice folks there). I hope to pay my rent with something else as soon as possible. I've seen too many WordPress projects go to hell because it was used for something it should not be used for.
Do standalone PHP applications without any connection to a web server, a good practice? Or it shouldn't be done.
You missed the point..it is not that you need it..but if you have it it proves pretty strongly your skills and gives you certain advantages for certain jobs and projects..if you are a senior engineer, you will find good positions with and without it..but if you want to apply for a position in Sensio labs lets say..then I believe it will definitely have its benefits These certifications are great for up to mid level developers (by these I mean Zend and Symfony)..passing the exam requires a huge amount of knowledge and experience..so preparing for it really will push your skills and knowledge, I remember myself how much I have learned by preparing for the Zend certification a few years back
I can give you an idea of how I tackled a similar problem on my project. So, the database class. This is kind of open depending on whether you want to write raw SQL (in which case you really ought to use PDO) or use an ORM like Doctrine. I chose to use PDO for my project. My database class is really a wrapper around PDO. You'll want to have your config variables in an external file (some people use environment variables instead of .ini files). So, for my database class, I create a PDO instance and then pass that instance into the constructor of the database class. When I originally started, I was going to write all kinds of methods like insert(), update(), delete(), etc. but decided it made more sense to just have a general runQuery() function which took a query string and optionally a set of parameters. I also added functions for starting and stopping transactions (basically runQuery() checks if transactions are active and if they are it rolls back the transaction before throwing an error). For my database operations, all my raw sql is in Gateway classes. So for example, if I needed to use sql for a User class I'd write all the sql in a UserGateway class and then inject the UserGateway into the User class. All right, user class. There are many different approaches to this. I have a User class which is really just a dumb property container. I have a UserRepository class where you can check if a user is valid and also get a current User object by passing an email address (you may decide to use usernames instead). I also have a UserOperations class, which takes the arguments from the request. It has methods like login(), logout() and create(). 
Have you developed with Magento 2? I hear it is as unfinished and as buggy as you would expect from an alpha release. As for modern, it runs on a LTS framework that EOL'd last year, meaning it was essentially published with an unmaintained legacy framework under the hood. I've seen nice and well working webshops made with it, but from individual developers I've heard nothing but bad news and experiences. I hope it gets better as it seems to be the only mid-to-big ecommerce platform that has a chance when it comes to PHP.
Absolutely. Any script can be invoked from the command line, and in turn it can be scheduled via cron. 
I'm well aware it's not some sort of superpower in programming - I'd just like to have the option to use it :-)
mostly the additional features. HHVM (at least at the time of creation) is a super-set of PHP. Meaning you should be able to run all PHP scripts using HHVM (see https://docs.hhvm.com/hhvm/inconsistencies/introduction ). However, HHVM adds to the language. For instance, HHVM has generics and collections added to the PHP language. For more info see https://docs.hhvm.com/hack/ . While this sounds great, you have to be aware that as soon as you start using the additional features you will no longer be compatible with 'vanilla' PHP. So you have to keep that in mind if you want to deploy your code. Furthermore, not all packages are compatible with HHVM. Some were but are now dropping support due to the lack of interest and it's another platform to support. For instance, Symfony recently decided to drop the HHVM support https://symfony.com/blog/symfony-4-end-of-hhvm-support , and so did Laravel https://laravel.com/docs/5.3/upgrade#upgrade-5.3.0 which are the two major players in the PHP landscape. *EDIT: also added Laravel.*
You should return early: if (!is_array($locationDataArray)) { return; //code if (!$addressComponents) { return; } } But better yet use some well maintained lib for it: https://github.com/geocoder-php/Geocoder
My advise is to use https://github.com/geocoder-php/Geocoder which does all the heavy lifting for you
Yeah so it makes no sense to write the second if in the first one when there will be a return at the first point, since the other code will NEVER be executed.
this is another tutorial in details how can you do it via onsignal free service http://webeasystep.com/blog/view_article/Push_Notification_PHP_via_Onesignal
Your book seems to be exactly what I've been looking for. Right now I am learning using my first LAMP setup and ran into file permission issues (allowing www-data read and write access within its directory). Would your book help address something like that? I've just started reading the sample on my kindle and I like it so far.
Yes, the book handles permissions, why these issues happen, and avoids them altogether because the box (virtual machine) that's used in the lessons and in future tutorials is configured that way, ease of use first, but keeping the _"I'll know how to manage my own server one day"_ professional note. If you end up getting it, I'd really appreciate some feedback on what could be improved, what wasn't clear, what could have used more/better examples etc - either in private here, on the site in the comments, on Twitter or anywhere else really, just shoot. Btw a new edition is coming out soon (current version deals with PHP 5.6) but that's the only difference. You'll get notified (and given the new version free) if you buy the current one.
What IDE? Is there autocomplete? Constant are simple: const BODY = 'body'; and use it &lt;namespace&gt;\&lt;class&gt;::&lt;constant&gt; Try \GuzzleHttp\RequestOptions::BODY ? 
Alright! Didn't know about the GeoCode php implementation. Thanks to the people pointing that out! Nevertheless the question still stands on how to go about all these null checks. The GeoCode example was just that, an example :)
SECTION | CONTENT :--|:-- Title | PHP UK Conference 2014 - Mathias Verraes - Unbreakable Domain Models Description | Data Mappers (like Doctrine2) help us a lot to persist data. Yet many projects are still struggling with tough questions: - Where to put business logic? - How to protect our code from abuse? - Where to put queries, and how test them? Let's look beyond the old Gang of Four design patterns, and take some clues from tactical Domain Driven Design. At the heart of our models, we can use Value Objects and Entities, with tightly defined consistency boundaries. Repositories abstract away the persisten... Length | 1:03:26 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
laracasts phppandas phptherightway
The only downside is Java.
My 2 cents isn't really related to autoloading but I suggest you to run fixer to the legacy files before refactoring http://cs.sensiolabs.org/. Of course the result is far from perfect but at least it's less hurtful to your eyes (and calms your inner cry, if you have).
So when dealing with user input, input from APIs, from files etc, I use this handy `InputData` class https://gist.github.com/Petah/d90d7258d10e7334dbff Simply instantiate it with any kind of data like `new InputData(json_decode($someJson);` then you can do things like: foreach ($inputData as $location) { foreach ($location-&gt;arr('address_components') as $addressComponent) { if ($addressComponent-&gt;string('types.0') == 'postal_code') { $postCode = $addressComponent-&gt;int('short_name'); } } } Basically eliminates the need to do `isset` and type checks as it will do it for you and cast to your expected type. 
Or a fuller example: $locationDataArray = new InputData(json_decode($data['geolocation'])); foreach ($locationDataArray[0]-&gt;arr('address_components') as $addressComponent) { switch ($addressComponent-&gt;string('type.0')) { case 'country': $this-&gt;brochureForm-&gt;setCountry(Lead::COUNTRIES[$addressComponent-&gt;string('short_name')] ?? $addressComponent-&gt;string('long_name', null)); break; case 'postal_code': $this-&gt;brochureForm-&gt;setPostalCode($addressComponent-&gt;string('short_name')); break; case 'locality': $this-&gt;brochureForm-&gt;setCity($addressComponent-&gt;string('short_name')); break; case 'administrative_area_level_2': $this-&gt;brochureForm-&gt;setProvince($addressComponent-&gt;string('long_name')); break; } }
Have you looked into [JMS Serializer](https://github.com/schmittjoh/serializer)? It can parse json, xml and yaml into custom objects...
That sounds great the thing is we are using Kloxo-MR which I can't seem to find the API docs anywhere. but thanks now I know it's doable :)
PHP can namespace functions. Only problem is that it can only autoload classes. For this, I use static methods and wrap them in lambdas when I want to pass something callable
You attempt to put words in my mouth. You bring things up I never mentioned and use these with flawed logic (YAML = CoffeeScript, missing validation, etc.) to get your points across. I will discuss and advocate this matter passionately, thank you very much. We're done here. This thread is about DI anyhow.
Thats how you know its gonna be a fun day at the office *sarcasm*
I've done nothing serious with it to be honest. Mostly just set it up in a VM and poked around. I work with Magento 1 every day so in contrast I am very impressed with M2.
I plan on using HHVM for a PHP5.6 legacy application once PHP5.6 hits EOL. I'm currently testing it in HHVM and it seems to be a really nice drop-in replacement. Plus any changes or additions to the application can be done in Hack and I quite like that language.
I love me some CS:GO, but this doesn't really belong here. This subreddit is, as I've seen it, for the general discussion of PHP as a language and the surrounding 'ecosystem', not closed source project promotion.
Let's put the 4% aside, for a moment. The problem with HHVM isn't what it does or doesn't support. It's how much it stays in step with PHP and how quickly it does so. This issue had the potential to make apps not work. Yet PHP 7 has been out for a very long time. And the [issue related to this change](https://github.com/composer/composer/issues/5978) was opened in December last year. I would feel uncomfortable building anything I would have to support on the basis of this. Now, back to the 4%. The [latest composer stats](https://laravel-news.com/php-versions-stats-may-2017) indicate that; "HHVM usage is [...] at 0.36% which is a third of PHP 5.3 usage and really hardly significant."
it's "Create blazing fast hypermedia apis" and not "create blazingly fast hypermedia apis" :)
When I was still a PHP dev (&gt;2 yrs ago), every enterprise shop I came across was using Symfony. Currently, my PHP friends doing enterprise apps are using Symfony. So, may be a geographical thing? I'm in DFW. I agree, the firewall is a strange design. Learning to use it was a pain in the ass with a lot of copying and pasting from the docs without really understanding WTF is going on. It was a turn off for sure. 
...Probably an easy question for /u/sarciszewski to weigh in on.
Good question. We already attempted to use an external index with ElasticSearch sometime ago but we didn't manage to correctly implement all the features that were needed regarding permissions management. We summarized that in a [blog post](https://www.tuleap.org/elasticsearch-dealing-complex-permissions). TBH, I don't know if lucene (or recent version of ES) would be better at this game. 
I've been in a similar situation with an app written by a well meaning amateur who was learning on the job. The whole thing is a perfect example of the mess Paul talks about in his book (which I happened to pick up yesterday). One thing that has helped is that I've insisted that they install Homestead and use Sublime with phpfmt and a linter. There was a huge amount of resistance but when they finally gave in things were able to change. They could see lots of their old MySQL calls (in the middle of a PDO block!) were failing and at last worked with me a little more than against me. The whole code still stinks to high heaven but I think we'll eventually get to a stage where it's manageable much sooner than if they'd been allowed to continue to tinker with live code. Putting actual tests in is a long way off, but one day at a time... Good luck! 
No, I want the PHP side to be a stateless API. That is a cool lib though...
I didn't say that it's a silver bullet and that it is relevant for every use cases. It is relevant for many use cases. This cache system is for APIs with a high number of read operations AND a low number of writes. Fortunately, most REST APIs (at least, most of our customers' APIs) are in this case. If you have a high number of writes, you should consider using another programming language such as Go, and yes a reverse proxy won't help. As stated in the article, I'll post a detailed blog post about this feature later. Your approach is good, and I use it in several projects. The point is that our implementation allow to get fresher data for free and with no downside compared to yours. And it is already available, open source and already used in production for several high traffic websites. Your implementation... has to be implemented. It cannot be easier to implement than just turning on a config flag (yes, you can toggle on or off this feature). By the way, using memcache or a similar solution cannot be faster than using Varnish or a similar solution because with a reverse proxy, when a response is cached, the application server isn't touched at all. Even with PHP-FPM, booting the application to query memcache is in all cases slower than serving the request from Varnish or CloudFlare. The strategy used is similar (but not exactly the same) to the one described in this talk: https://fr.slideshare.net/JrmyDeruss/grce-aux-tags-varnish-jai-switch-ma-prod-sur-raspberry-pi You can find relevant (and not relevant) use cases as well as a benchmark in it. More on this in the follow up post.
Another trick is to fill out the missing keys with null in your function. That way the calling code doesn't have to check the key exists each time. Sabre/Uri is a better parse_url that does that and it's much nicer to work with. 
why would you need a hash for a token, why not use a UUID ?
That would be a lot simpler but I don't know if it's a secure approach.
Basically, you then want to return some sort of token signed by your server giving you authenticity of the payload (e.g. user id and creation timestamp) and eliminates the need of an expensive bcrypt hash comparison… (akin to JWT (JSON web token)). Also, re: no cookies. A cookie is just a piece of data sent to the server upon each request. Whether you put it in the query string/HTTP body or into a cookie doesn't really matter...
&gt; giving you authenticity of the payload and eliminates the need of an expensive bcrypt hash That's exactly what I want. &gt; Whether you put it in the query string/HTTP body or into a cookie doesn't really matter... Oh, right. Thanks for the help, by the way... :)
Alright. This seems like a question for /r/PHPhelp. Anyhow, if I understand your question right, this might be a solution: 1. You validate user credentials (username and password). 2. On success, you create a cryptographically safe token on the server-side (in PHP), which has no collisions, and you store this token (in database or cache), with a relation to the respective user (e.g. through an ID). 3. The server relays the token to the client, which stores it in browser memory. 4. On each request from the client to the server (XHR?), the token is attached (as a URL parameter or in the request payload). 5. PHP receives the token, looks up the token, validates that it exists and that it is not expired, and lastly determines the user. 6. If the user has sufficient permissions, carry on. You've mentioned "stateless API" a few times, but if it's an API with authentication, you must have some underlying storage unit, at least for storing the user information.
**Here's a sneak peek of [/r/PHPhelp](https://np.reddit.com/r/PHPhelp) using the [top posts](https://np.reddit.com/r/PHPhelp/top/?sort=top&amp;t=year) of the year!** \#1: [Is it necessary to use a PHP framework?](https://np.reddit.com/r/PHPhelp/comments/51g86f/is_it_necessary_to_use_a_php_framework/) \#2: [First time writing OOP can anyone check im on the right track.](https://np.reddit.com/r/PHPhelp/comments/65qzgl/first_time_writing_oop_can_anyone_check_im_on_the/) \#3: [Can someone explain what this php malware does?](https://np.reddit.com/r/PHPhelp/comments/5phn6r/can_someone_explain_what_this_php_malware_does/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
Thanks for the link - A+ info!
I used [deployer](https://github.com/deployphp/deployer) in the past and it's great. Although now I use a docker pipeline to deploy my projects.
&gt; This seems like a question for /r/PHPhelp. Wat. Thanks for the steps but really they weren't needed. I understand the process I need to follow, just not 100% sure of how to securely generate the token. There is state on the front-end, in terms of storing the token for subsequent requests.
Okay. You got me confused, because I already provided an answer for this with the link to zend-crypt. Actually, you may only need [zend-math](https://zendframework.github.io/zend-math/).
OAuth is the best way to handle authentication at the moment IMO. User uses credentials (email, pass) first time to request an access token. The response will include not only an access token but also a refresh token. The access token lasts for about an hour while the refresh token is long lived (like 6 months - 1 year or longer even). neither of these tokens have anything to do with the users salt, password, hash, or anything. You need a secure key (single is just fine) which is used to generate both the access token and the refresh token. The front-end once receiving the access token will use that to authenticate. Once the access token expires, the user will send the refresh token to request a new access token which on response provides not only the new access token but ALSO a new refresh token. Say the user exists your mobile app and doesn't use it again for 2 months. The next time the user opens the app, the access token is obviously expired, but the refresh token is good, refresh token calls server to request new access token, new access token is provides along with new refresh token, access token is then used to authenticate requests. In addition, should the refresh token have expired as well, the user would at that point be requested to once again enter their email and password. If you ever change the key, all existing refresh tokens become invalid. Forcing user to re-login. Should your key ever become compromised, generate a new key. Users passwords would not be affected unless your database is also compromised. Does this make sense ? 
&gt; It's not an "opinion". It's a technical rationale. If you're curious about the reasoning behind specific points, you're welcome to ask and I'll happily clarify. But waving it away as an "opinion" without trying to understand the point is not really okay. I apologise for waving it away. &gt; Okay, and have you also built stateful ones? And have you maintained both over an extended period of time? And do you have an in-depth understanding of where maintenance complexity comes from and how it relates to statefulness? And at what point it makes sense to use one over the other? Yes. &gt; "I've built many stateless APIs and they worked fine" just comes across to me like a lack of experience - you're not qualifying any of it, nor showing that you have an understanding of the complexities involved. You're just saying "it's fine" without clarifying what you're relating it to. That sounds like an attempt at justification, not a technical argument. Ok &gt; If you refuse to rewrite or fix a sample application because of a security risk (and generally showing practices that involve several footguns), then I would say that you're not making a legitimate effort to "not spread bad info". You have not proven that stateless APIs are a security risk or that building them is tantamount to making "footguns". I am asking for advice. That doesn't necessarily mean I'm going to implement everyone's suggestion. Thank you for your advice on stateful vs. stateless APIs.
OAuth is a valid option, yes. I will ponder whether or not to attempt and fully explain it in the book... &gt; Does this make sense? It does, and I appreciate the advice. :)
What are the environments like? I have two different php webhooks I made for Opencart, Im sure they'd port over nicely. Ill link Gists to them. What service do you use for your repos? [Github Gist: Webhooks](https://gist.github.com/hamiltonsw/6fbb23b99870e0186d6906163f377143)
Hah! I define it as any company who uses the app to run their business, or key parts of their business. This is not to say that Laravel couldn't, ... just that at least in my exposure, it was all Symfony (there could be many reasons for this, including Symfony being much more popular at the time the app was started). That was 2 yrs ago though. Maybe Laravel is the hot thing now. I defected to node. :) I just wanted to rebut his claim that it's all Laravel out there. That's horseshit.
Look into Jenkins / Blue ocean, I like it :D 
&gt; I apologise for waving it away. Okay, but apologising and then implicitly dismissing the matter again doesn't really change anything. &gt; You have not proven that stateless APIs are a security risk or that building them is tantamount to making "footguns". You haven't asked. I've written a rather extensive article [here](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) about why stateless tokens should be avoided - it talks explicitly about JWT, but really it applies to any kind of stateless authentication token. If you believe that there is a solution to those points, then make sure to look at the linked follow-up article first, since chances are it's already covered there. Now, stateless end user applications *in general* have some additional issues, especially in browsers - most notably, they almost inevitably introduce a requirement for client-side JS (which in many projects would not otherwise have existed), which is [a problem](https://eev.ee/blog/2016/03/06/maybe-we-could-tone-down-the-javascript/), even for the developer (because debugging and testing unknown environments is hard). On top of that, it's more difficult to persist state between operations, especially taking into account storage/bandwidth constraints on the user's end (what if your state is really big?). Generally speaking, anything that involves relying on the client environment is difficult, simply because there are so many unknowns about that environment. And besides *that*, there is an additional problem with designing "APIs" for things that really should be websites - you end up with a really inefficient representation of the data that the client-side code tries to obtain, because the API is designed to be generic and can't trivially batch up data in the way the view requires. There are some attempts to solve this like GraphQL, but that is very much designed for Facebook's requirements alone. Of course if you're building an *actual* API (as opposed to the data endpoints for an SPA, which for some reason is now popularly referred to as an "API"), that last point doesn't apply in the same sense. Now, combining all of these concerns with the total lack of actual, technical benefits for the majority of projects - which is something that you haven't disputed - that makes for quite a few nice footguns. When teaching people (and writing an example for a book counts as "teaching"), you should *never* recommend the thing with caveats; always recommend the safe default, and offer some additional pointers on how to deal with edgecases. For that reason, demonstrating a stateless application outside of that very specific "for edgecases" context is a very irresponsible thing to do. You will be teaching people to default to something that just isn't a sound technical choice for most projects. (And as before, if you have questions about any of those points, including about the "cut down on client-side JS" point, feel free to ask. I'm just referring to a third-party article to cut down on post length, but I've long been arguing the same thing independently.)
&gt; The front-end once receiving the access token will use that to authenticate. Once the access token expires, the user will send the refresh token to request a new access token which on response provides not only the new access token but ALSO a new refresh token. While this works for mobile applications, be aware that this is an insecure thing to do in browsers (because you need to manually handle the token in client-side JS, and therefore cannot set the `httpOnly` flag). This is explained more [here](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/).
httpOnly only applies to cookies and has nothing to do with data being passed around outside of cookies. if someone has access to your browser, you've already been compromised. 
Deploybot is good, does exactly what you are asking 
Totally, we have a load of devs in Eastern Europe. They love symfony and yii. We tend towards Laravel, but have rolled our own from Symfony bundles in a few cases. Right tool for the job. 
I feel bad for you. I got lucky, I span up a vm, refactored and proved to my boss it was worth it. Got go ahead and a pat on the back. 2 years ago
We are on Ubuntu LTS. So still 7.0.
With the performance improvements it's "easy" to sell to management. Talk about improved conversion rates based on better response times, faster future development, etc.
5.3? What luxury! I'm stuck with 5.2. Oh how I loathe WordPress.
The upgrade notes are available here: https://github.com/php/php-src/blob/php-7.2.0alpha1/UPGRADING
For most of my projects I'm using Jenkins to run the unit tests and then [deployer](https://deployer.org/) to actually push out the changes to the server. For my smaller projects I just have a very basic script that pulls down the changes (http://www.thisprogrammingthing.com/2013/automatically-updating-your-website-using-githubs-service-hooks/). That works really well until we add a second web server. 
Yeah, a $10m annual revenue "death's door." You're right... In seriousness, there are larger fish to fry for this app and organization before 5.3-related debt can be addressed. But it's impressive how you just analyzed an entire business and an application you know a single thing about based on an unfunny joke posted to reddit though ;)
Use the PPA: https://launchpad.net/~ondrej/+archive/ubuntu/php Its used by almost everyone who is on LTS but wants the latest php. Never had any issues with it.
5.4 here. Yay, traits!
Oh God, traits! I miss square bracket arrays most. 
This. So this. Sometimes business applications are stuck with a set of requirements. To the business, it does not make sense to take a few months doing under-the-hood work that has no visual/tangible business to anyone but the developers. I was on a product stuck on 5.3 for a year. It was hell. But fixing it to be able to use a more modern version would have been a huge undertaken, given all of the inline bits, copy/pasted code, deprecated mysql_* functions etc. The business was not willing to let the team do it. There are too many paying customers that want other features.
That was before namespaces and anonymous functions, was it? That's dreadful.
amazing work!
Now imagine this code in 5 to 10 years. Eventually, something is going to give.
Never mind that Wordpress is still using 5.2 as its minimum supported PHP version. 
Thank you =)
Yes. Namespaces, PHAR, closures, fileinfo... All features I've been waiting since late 2008 to use. Ugh.
Is there a learning sticky thread for those of us who would like to learn php / SQL.
How so? 5.3 isn't going to suddenly stop working. No it's not ideal and the developers would love to move away from it, but it's not realistic right now
My issue with legacy applications usually comes when they need to be moved to a new server, or even local development environments that are out of date. I've had new developers show up to work on a project that hadn't needed provisioning in a while, only to find that the `apt` repository doesn't support that version any more. Perhaps there are better ways around maintaining that sort of thing long term (open to ideas!), however I've found that the applications themselves are less of a problem than maintaining the infrastructure around them.
I didn't consider any serious software project would use shared hosting - and he was talking about code, so I assumed he isn't an admin of said shared hosting provider. But even with shared hosting, no one is using mod_php or anything anymore, right? You can have different versions per customer.
[According to wordpress.org](https://wordpress.org/plugins/nextgen-gallery/) our plugin in particular has over one million current installations. Around a year ago (or so, ish) we released an update with a 5.3 specific thing that we didn't catch in our testing.. quite a few members of the public were very quick to let us know how many of them were angry.
RHEL6 with PHP 5.3 is supported until 2020.
Have you checked their [issue tracker](https://youtrack.jetbrains.com/issues/WI) for an existing feature request or bug report? If none exists, then file one.
True story. And they can sue if me if they want, because this is 100% factual and verifiable. 2008: I was an hourly contractor for one of the Top 3 blinds ecommerce companies, which was running PHP 4.4. It was grossly miscoded in a way that made porting to 5.2 EXCEPTIONALLY difficult. I kept doing what you said, even the exact "Google 20% thing" but the CTO always disagreed. So working nights and weekends, off the clock, and without being asked, I ported everything but the credit-card order confirmation page (probably 20 hours of additional work) to PHP 5.2. I dutifully logged my time and used SVN so there was a good documentation trail that I had spent EIGHT HUNDRED HOURS (820+) of my spare time, for free, doing this. I knew for a FACT that PCI compliance from VISA was going to spot check them any random day and if they were caught on 4.4, they would be denied credit and debit card processing. I knew that would severely impact all 200+ employees. I knew that PHP 5 was the right path and I thought that by volunteering my time without asking, that I was doing something Very Just for the 200+ people, and the company. Plus I loved the project. So when I was sooo close to finishing, I went to the CEO. I said, "I have solved your biggest need as an ecommerce corporation and I have done it without being paid a cent. I truly have never heard of anyone ever spending 800 hours donating time to their company, and I simply do not know how much value this is worth to you. However, I will accept anything from nothing to as much as you want to give me. Just follow your conscience, because I am one of your most dedicated, hardworking and skilled employees." He said to bring in the code the next day and we would settle things. I left for the day. The next day, Legal, HR and the CTO and CEO were waiting for me, at my regular 8:30 AM clockin time. Legal accused me of quote-on-quote "blackmailing" the company, which literally took me by shock and surprise SO MUCH, esp when they threatened, right then and there, without me saying a single word, to sue me for "inappropriately working off of company time." The CTO then took the CD of the source code I had burned (this was before USB sticks were so common) and watched as the Lead Architect deleted the source code from my personal laptop. The CTO then asked the Lead Architect, "Have you run it on your local system?" "Yes. It is as he claims. Virtually the entire site except the credit card confirmation. Good job &lt;my name&gt;! It's really amazing" The CTO then asked, "Is this the only remaining copy of PHP 5.2 blinds.com?" I said, Yes. He said, "Good." Then, with the CEO looking on, and to my and the Lead Architect's horror and shock, the CTO *broke* the CD into two with his hands. "We're moving to Dot Net. Because PHP 4 is deprecated and won't fit our needs." So, I was promptly fired. No unemployment insurance, nothing. In fact, I was happy to go after that. A Dot Net engineer making 3x my salary was hired, and they proceeded to try to port the Entire huge app to Dot Net. It didn't work. More Dot Net people were hired. In the end, all the PHP guys lost their job, about a year later. The Dot Net migration cost so much dev effort that innovation largely stopped for more than 2 years. And the Canadian site, which I had created myself, wasn't ported to Dot Net for another 5 or 6 years. Anyway, that's what I think of when people recommend going above and beyond like that. I'm now the CEO of my own Multi-National Corporation (US, UK, Colombia, Costa Rica and India). If I ever found a guy like 26 year-old me, I would pay them as much as I possibly could. I'd treat them like royalty. Never found one as dedicated. I think we're unicorns. But most places? I dO NOT recommend it!
Good point, I didn't take into consideration of distros backporting.
Hey! I gave contributions to you guys in 2009 when I worked for Hearst Digital News! I rewrote like 40% of your codebase and donated a lot of that, by HDN's good graces, back, so Nextgen could support our 250 million+ monthly views... I have Nextgen on my resume, even ;-)
Neat!
What lol
Frankly just read the conversation yourself and be honest. If you don't want to argue then just don't reply, don't make up a poor excuse that's just rude really.
To be fair, most developers worth their salt give WordPress an F. It's kind of a steaming pile of crap. Also, commercial success is not an indicator of how well engineered something is. 50 million people can all be wrong.
Yea! VT100 support! Looking forward to all the new applications - let the revolution begin! (p.s. 1995 is calling and wants its terminals back)
Well done, I'm glad you left that shit behind you. Being under appreciated is truly demoralising.
If you're a RHEL subscriber: https://access.redhat.com/solutions/409673 - or a random discussion on Stack Overflow : https://serverfault.com/questions/632409/is-php-5-3-3-on-rhel-6-5-receiving-security-fixes
I would assume because if I was doing more than client sites (and worked with languages like PHP), I'd say I've been an engineer or a software engineer for 15 years. Web dev works specifically with websites, whether it's client sites or running your business's own site. 
&gt; By the way, using memcache or a similar solution cannot be faster than using Varnish or a similar solution because with a reverse proxy, when a response is cached, the application server isn't touched at all. I'm aware. I intentionally didn't mention Varnish, as then your response would be "but API platform doesn't require a separate caching server". Instead, you seem to be saying here that Varnish is a better solution than built-in cache like API platform has. &gt; The point is that our implementation allow to get fresher data for free and with no downside compared to yours. I already listed several downsides. The overhead of managing the cache like you do can be so big, as to make the system slower, instead of faster, as it turned out with MySQL's own coherent query cache. And a downside I didn't mention... it only works with Doctrine. I don't know about others, but my APIs have a lot more varied data sources than just mapping Doctrine CRUD to HTTP CRUD. And I realize that in theory more sources can be integrated. All this remains in theory.
&gt; Security support by the mainline PHP team ended years ago but enterprise linux vendors backport fixes for their supported versions. Considering how much PHP 7.x has changed, "backporting fixes" sounds like a very suspicious approach.
Just saying hello... from PHP 4.4 world. Fortunately I made an huge effort to refactor a lot of code to run on 7.0 but I still need to support 4.4 production :(
I wouldn't worry /too/ much. 7.0 is a solid branch, and it's got some time left on the clock yet. Even when upgrade time comes, your BC issues should be pretty trivial (assuming 8 isn't out yet).
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/phpsec] [The Future of Sodium\_Compat](https://np.reddit.com/r/phpsec/comments/6g69yy/the_future_of_sodium_compat/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Shit, rhel7 doesn't even come with __5.5__. RedHat can bite my ass.
You won't find another person like you because that kind of motivation, initiative, and foresight are qualities of entrepreneurs who start their own multi-national corporation. Good job!! I commend your ability to not be swayed by the injustice, and to focus your energy on yourself! Kudos!
7.2 `json_decode('{"foo":"bar"}', null, 512, JSON_OBJECT_AS_ARRAY) == array` Previously `json_decode('{"foo":"bar"}', null, 512, JSON_OBJECT_AS_ARRAY) == stdObject`
Yes the benchmarks was run without any caching library.
Ta
There is no "built-in" PHP cache. Our mechanism relies on Varnish (or Cloudflare). (We see API Platform as a stack). You're definitely right regarding Doctrine, but there is an abstraction layer, you can write an adapter for any other persistent system (but it should be written by your team). Anyway, Doctrine is very suitable for REST APIs.
 &gt; E.g. auto complete based on duck typing. There is? function foo($garbage) { if ($garbage instanceof Usable) { // this will autocomplete: return $garbage-&gt;canBeUsedEvenByPeopleWhoDontKnowHowTypeSystemsAreSupposedToBeUsed(); } return 'no dice'; }
that is not duck typing giving an example would take me too long. basically if the IDE sees you do this $unkown-&gt;foo() $unkown-&gt;bar() and there is a class defined that has foo and bar defined, but as well defines a function baz() if you do this $unkown-&gt;ba //autocompletes baz. Because it _guesses_ the right object. It will sometimes guess the wrong object though or fail to find it even.
What exactly is the purpose of this piece of code? public function __get($name) { return $this-&gt;{$name}; }
This is such a great plugin. I've recommended it to the people I work with. It finds a lot of optimisations, architectural issues, and other simplifications. I kinda wish I could tweak the non-annotated exception inspection, so that it is only warning on the method that throws the exception. It becomes a bit Java-ish to annotate exceptions all the way up the call stack (and then becomes harder to maintain if you change the underlying API). 
This also works via fuzzy checking, but it's pretty much limited, as it only works in the global context (view scripts, generally). What the PHPStorm engine will do is looking for things that get assigned to a global called `$unknown`, and then rely on that. &gt; that is not duck typing It's duck typing when you check if it quacks before you make it do an egg :-)
Phpstorm by jetbrains is always a good pick. 
PHPStorm and watch this free [Laracast: Be awesome in PHPStorm](https://laracasts.com/series/how-to-be-awesome-in-phpstorm) You have to learn (take your time) to use source versioning (Git). If you're a student, PHPStorm and most of Jetbrains tools are free: https://www.jetbrains.com/student/ 
Your CSV parser will crash with a memory error on a large enough file. You should think about an abstraction that iterates your CSV one line at a time. It may be a bit slower, but it will be a more resilient system. A CSV parser package I created for my company 5 years ago still in production today is used to handle files with millions of lines of data without a hitch. Just a suggestion.
If you can pick yourself, use PHPStorm. But most companies will have made this choice for you, keep that in mind.
vim
This hasn’t been mentioned yet — you could try PHPStorm.
i never said its not limited. But: function ($x){ $x-&gt;foo(); $x-&gt;bar(); //if there is only one object with these 2 functions, at this point it is safe to assume, that auto completing the other functions and referencing that object, will help the developer }
I would second this, and to give some reasoning: * When I used it, the PHP support in Netbeans / Eclipse always felt as if it had been hacked on to an IDE built for Java - it was often buggy and/or felt incomplete * Zend Studio is also an option - it was better than Netbeans / Eclipse and felt like a "proper" PHP IDE, but... * The fact that JetBrains make IDEs for multiple languages gives PHPStorm the added functionality and plugins that you'd expect for those languages - so you get help with your Javascript as well as your PHP (for example - PHPStorm has an excellent library of both first and third party extensions available) If you want to try PHPStorm beyond the free trial, I believe you can use the [EAP](https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Early+Access+Program) version without a full license - do note that the EAP version does require regular updating (every 45 days IIRC) and there isn't always an EAP version available. While it's not free, the amount spent on PHPStorm is easily returned in the productivity boost it'll give you. As others have mentioned, some companies will specify your tools, and many will provide licenses for the tools you want to use - ask your team.
Is there any Change log released for this?
This is a site that not alot of people know about but is a pletheria a source code you could look at. Its call [GitHub](http://www.github.com/)
Komodo Edit also.
I'm currently using Atom with the PHP Integrator plugins.
Personally I hope ??= will make it before the beta.
It's called a magic getter. It allows the instance to return the internal data loaded from the CSV as properties without having to write getters for each. This is useful and important in this case because these properties aren't known; they depend on the columns in the CSV file.
I agree, there are some methods that only exist in one class, when you CMD click the method it should open the source code or at least show you possible matches
Look again.
We didn't evaluate this solution back in time.
I personally just use Sublime text because I'm pretty careful about syntax issues and I prefer the speed and hotkeys. I hardly ever find myself in a situation where I need xdebug (and our dev environment doesn't actually have it set up currently).
Not entirely sure what your actual complaint is, but you can hide all of the panels and you can reconfigure the code hilighting and code inspections to suit your preferences. PHPStorm has both "distraction free" (which removes a lot of the UI, leaving a sparse, flat setup) and "fullscreen" modes.
I love PHP, have been using it for years, but reading large files it is not very good at. Yes it's got better with each version, but unless you are forced to use PHP, I would look at python. Definitely a case of the right tool for the job.
I think my complaint was pretty clearly stated. I don't dispute that these things may be configurable. I do know, however, that I don't want to have to concern myself with endless UI options/preferences in order to get something in the usable middleground between exposing enough information to be useful and too much information to be distracting. Most distraction free modes display too little (admittedly I've not tried PHPStorm's). PHPStorm's defaults are the latter. Obviously this is a matter of personal taste. But it shouldn't be difficult to imagine why someone might use something else when there are plenty of other capable solutions with different aesthetics.
I think the community should express their preferences for this feature, it's something that's being hard to be decided by the internals so any help might be useful. internal discussion can be seen here: https://externals.io/thread/911
I'm using it and I'm a beginner. Should I change IDE (or text editor) or remain with Vim?
`__get` is only called if the property in question is inaccesible. If `$name` exists it will work fine but if it doesn't that's a nasty edge case
That name tho
maybe the author does not know about $this-&gt;data[] = (object) array_combine($header, $row); //some much simpler of course if he works with a non consistent CSV document this will break just like his current code :)
Why do you think it is not well designed? I think it is one of the most intuitive applications out there, not just IDE land. I'm guessing you're a fan of Sublime?
You don't think the functionality it provides is worth the time you'd require to configure the display? Are you using an alternative with comparable features? Phpstorms distraction free mode shows nothing but code by default, not even line numbers. It also forces you to one open window which is pretty garbage, I'll admit. FYI the distracting sidebars and such can all be turned off directly from the "view" menu I believe (just a drop down with checked options).
Either Sublime Text or Atom both with addons of course, or PHPStorm.
&gt; Why do you think it is not well designed? By default. Excess number of icons and indicators (many of which I would say are non-intuitive), bulky panel designs, and the "java look" (not well integrated with other elements on my desktop). &gt; I'm guessing you're a fan of Sublime? No. My editor of choice is Atom, which although similar, does provide more features and a slightly less anemic UI.
Hehe\^\^ Everyones dick is super hard here for PHPStorm. I should try it one day. Until then: I'm (still) on [Netbeans](https://netbeans.org/features/php/index.html) which sucked hard back then (running it on a shitty laptop did not help) but since 7.* and up i'm pretty happy with it. I think it has all the features PHPStorm has and it's free and it's quite snappy and running well overall. 
&gt; eliminated the arrows eliminate h,j,k,l too Why and how? I love this combinations, I even use it in Firefox with VimFX, in Man and other applications. I'm also a beginner with Vim, I know some useful commands, but how can I learn to use it more in-depth? &gt; Combine it with a decent tiled windows manager (e.g. i3wm) I'm planning to move from Xubuntu to Ubuntu with i3 :)
hi @djcraze. thank you for letting us know. can you elaborate more how this will result to an infinite loop so i can improve it? thank you so much in advance.
&gt; I don't think it provides any functionality I want that I can't get elsewhere. You don't **want** them because you don't **know** them! Once you do, you can't go back
Depends of what your company uses. If they have a PHPStorm license, then use it. Otherwise... I use Netbeans.
Since php 5.5 generators were introduced and with the use of them you can parse milions of rows of files without loading them into memory, the only thing in memory is the current row and references to next or previous rows. Very effective.
thank you so much for this suggestion. it really looks much simpler. :D
It actually won't. I was wrong. See my edit above.
SECTION | CONTENT :--|:-- Title | Improving Vim Speed Description | A grab-bag of tips to speed up your vimming! For full access to the whole Weekly Iteration series, visit https://upcase.com and enroll in today. Upcase turns junior Rails developers into ass-kicking name-takers. We're not a bootcamp, we're a finishing school. Length | 0:14:54 SECTION | CONTENT :--|:-- Title | Openwest 2015 - Erik Falor - "From Vim Muggle to Wizard in 10 Easy Steps" (8) Description | Vi is more than just a text editor; it has become a way of life for power users who can get more done than their peers who use traditional pointy-clicky editors. In this talk you will uncover an unseen world inhabited by Wizards who effortlessly modify their text using powerful commands built upon surprisingly simple concepts. It is my goal is to invite you into this world and to arm you with 10 of the most useful Vi concepts, giving you the biggest personal productivity boost that can be had i... Length | 0:44:19 **** ^(I am a bot, this is an auto-generated reply | )^[Info](https://www.reddit.com/u/video_descriptionbot) ^| ^[Feedback](https://www.reddit.com/message/compose/?to=video_descriptionbot&amp;subject=Feedback) ^| ^(Reply STOP to opt out permanently)
**Here's a sneak peek of [/r/neovim](https://np.reddit.com/r/neovim) using the [top posts](https://np.reddit.com/r/neovim/top/?sort=top&amp;t=year) of the year!** \#1: [neovim 0.2.0 is released](https://github.com/neovim/neovim/releases/tag/v0.2.0) | [13 comments](https://np.reddit.com/r/neovim/comments/68rt5x/neovim_020_is_released/) \#2: [Neovim 0.1.6 released](https://github.com/neovim/neovim/commit/cc1ec959f1616b46d9a585efd02a56840cbb086f) | [20 comments](https://np.reddit.com/r/neovim/comments/59utv8/neovim_016_released/) \#3: [New UI for NeoVim (PR #5686)](https://www.youtube.com/watch?v=rzclz1seo0g) | [23 comments](https://np.reddit.com/r/neovim/comments/5fsccf/new_ui_for_neovim_pr_5686/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
Generators are awesome but PHP has always had the capability to read in a file one-row at a time.
I've tried both NetBeans and Eclipse, with their respective Symfony support. Neither of them come close to PhpStorm or IDEA. I really want them to, but they don't. The more glaring problem is that most of the code navigation doesn't work. Can't cmd-click a twig template string in a render call to go to the template file. Can't cmd-click service IDs to go to the class. (Occasionally works, but rarely.) Can't get argument hints or auto fill. Etc. I really, really wish there was a free and open source alternative to PhpStorm that handled Symfony as well as it does. Twice a year, or at major updates, I give Eclipse and NetBeans a shot. Not even close. :-(
When I started my current job using PHPStorm by Jetbrains was invaluable and helped greatly. After a few months and got more comfortable with the setup, I switched over to vim with nerdtree, vdebug, and some other plugins that made working on a local VMWare VM more convenient. The main pain point for me in working with PHPStorm was that I was constantly uploading updated Drupal PHP files over SFTP. If I could do it again, I'd setup a host only network interface and run X11 over the network then setup a local X11 server on Windows. edit: typos
How is the Symfony support? Code navigation with cmd-clicking classes, methods, service IDs, routes, or template strings? Argument hints and/or auto fill? Etc. 
I use PHPStorm at work as well but if you'd like something more simple and free to begin with I think Visual Studio Code has become a rather compelling text editor. Fast, enough out of the box features and enough available plugins, and only going to improve. I think they're releasing monthly updates with new features so that's a bonus as well. I think that Atom/Brackets/Sublime Text are a tad slower than Visual Studio Code. The latter just feels like a very solid all rounder.
Sorry, but none. That's my personal opinion, and i do see that others might find it useful - so as long as it doesn't change how code is written today, and just add to it, then i don't really care.
`var ??= expr` is the same as `var = var ?? expr` While this *sounds* really trivial, it's only trivial when `var` is a simple variable `$foo` when var is something more complex like: `$foo-&gt;bar-&gt;baz` we get into dangerous territory due to __get() and dynamic properties and other conditions which mean that the var expression could be indirect (and thus not survive across branching to the default expression) and multiple expansions could result in unexpected behavior (getting called multiple times). We could constrain the syntax to simple vars only, but that's the kind of inconsistency that gives PHP a bad name.
It is a highly available tool that is good to know-- I've seen some extremely proficient vi/vim people via plugins and configurations and macros and the built-in keybindings, certain people can do work. While I use vi/vim frequently enough, I am not one of the aforementioned persons as described above. So yeah, a good tool is a good tool, but PHPStorm is my daily driver and sometimes I just like being in a text editor with great search/replace tools like Kate and for large files I will open up a database dump in Sublime which seems to handle extremely long lines in extremely long files very well. For things that are just awful there is alway grep, sed, &amp; awk among other helpful low level text based command line tools. Thumbs up for good tools and lots of them good at particular things.
All mainstream PHP frameworks are more or less the same these days. It doesn't mean the way they approach the problem is the only way, rather we tend to copy each other and it creates a sense of cultural inevitability that there is only one way to do things. If you could have a framework designed just for you, what would you like to remove, add and change in existing frameworks? What bugs you in most frameworks and you wish to see in a new one?
Absolutely, success doesn't equate that something was done "properly", but at the end of the day, it's about completing work and getting paid. Time is money, and if the project isn't mission critical or well-funded, there isn't a need to go the full distance.
But provides basically no error or syntax checking.
https://www.reddit.com/r/PHP/search?q=IDE&amp;restrict_sr=on&amp;sort=relevance&amp;t=all
I'm looking forward to neovim, but I'm not a first adopter for products like that. I'm looking forward to v1 though!
I used to be as evangelical for Netbeans as I am now for PHPstorm. But PHPstorm was just better I finally conceded and never looked back.
I actually just jumped from PHPStorm to vim as my primary IDE. Even when I was on PHPStorm, I used vim keybindings with ideavim pluging for PHPStorm. I'm still getting used to the switch, and I'm running into some configuration options (e.g. I have an autocmd to load certain plugins when loading a PHP file, but it doesn't seem to be working as i'm expecting). Even then, I'm looking forward to some of the workflow improvements. Even templating out some common endpoint stubs will make it worth it for me. 
spf-13 (https://github.com/spf13/spf13-vim) vim user here, but project has died down since the maintainer got a job at Google. Can't imagine leaving the Vim ecosystem in general (every time I do I always end up going back), but I have heard good things about PHPStorm by some top notch PHP programmers.
Phpstorm is the IDE that I've been looking for. 
Not OP, but that sums me up well. But at this point, I'm proficient enough with it that using anything else feels incredibly tedious to use. And it's available on every machine I touch and I can configure it my way in about ten seconds with a git clone. 
Preferably neither. It just doesn't make sense to me to break consistancy for this, just to save a couple of characters. If you're going for the character saving, just `($x) =&gt; { $x; }` is better anyway
Hey fellow redditors, let's not downvote just because you don't share this person's opinion. It's neither off-topic nor factually incorrect. 
Sometimes it's just about building something useful rather than bitching on reddit.
yeah, 100% agree. My point was more that I would wait with buying a personal license if the company might have one or is using a different IDE.
[Here's a post of mine I made a while back on my favorite features I can't live without](https://www.reddit.com/r/PHP/comments/5n9bw4/i_plan_to_purchase_a_phpstorm_licence_and_till/dca5e3f/). But if I had to TL;DR it in to one feature for you, I'd say it's Remote Interpreters + PHPUnit + Debugging. The fact that regardless of whether my PHP runs locally, in vagrant or docker I can just write a Unit Test to target a specific thing while debugging something, click on the line number of where I need to be to see the values I want, right click the test method and hit debug and then I'm dropped right in to the execution in my IDE is great. The fact that I can then see variables and evaluate code to see how the result of certain function would look at that point of the code is amazing. And when I'm done, right click my test suite and just hit Run with Code Coverage, see a percentage in a file tree structure on the right and when I jump in to a file just see exactly which lines by an unobtrusive red or green in the line gutter to see if I haven't tested any code paths really helps. The main thing is that PHPStorm has so goddamn many features that work so damn well together makes it hard to tell someone else why **they** should use it. What some other people might consider features they can't live without, I might not even know they exist. Hell, I'm still discovering new features. Since that post I've ended up using the "Find Usages" feature so much more, as well as a plugin to let me use Vim keymappings. Not to mention the [PHP Inspections](https://plugins.jetbrains.com/plugin/7622-php-inspections-ea-extended-) plugin which is super helpful. Hell, even today I discovered how PhpStorm subtely lets you know what shortcuts you can use to stay to the keyboard if you want. Edit: Hell, still adding things. How about the ability to right click a folder, hit "Inspect Code" and see possible bugs or coding issues pop up, with some coming with automatic fixes for them? Just... it going through your code with nice Static Analysis to find issues for you
PhpStorm greatly helped me in my previous job as a Laravel dev. I am currently a JavaScript dev, and PhpStorm still makes my life easier.
Ah yeah, coding on the server is the best way to do CI! /s 
[It can be 'cleaned' up](http://i.imgur.com/S96PEP7.png) it's not hard really, you go to the "view" menu and uncheck the things you don't want to see. or just turn on "Distraction free" mode which hides everything but the menus and the code editor. An IDE is a tool, and like any tool you should choose the one that works best for you. but when you try a new tool that is made to conform to the user, and you don't take the time to set it up to your liking, you shouldn't really talk bad of it. Give it another go and take the 20 minutes to set it up the way you'd like to have it. You only need to set it up once! Also, just so you know, I haven't downvoted you at all. 
WinSCP HeidiSQL NetBeans
Additionally, PHPStorm does have the same basic functionality as DataGrip, so you can do DB interaction with it too! 
Yup. I'm parsing GB's worth of data a day (although most of the time it's in Go/Java) with files that are 25+ million rows. If it was in PHP and I used this library, I'd run out of memory really quickly, especially when I need to do a lot of concurrency where multiple parsers are running at once.
This is way more than I want my editor/IDE to do. 
&gt; SplFileObject How...have I never seen that before? Looks like I can finally retire my `FopenAsObject()` that just wraps the procedural functions in to an object. &gt;_&gt;
You were able to compile PHP 4.x on a modern system?
If you instantiate the object the constructor is automatically called
Just a few I love and use daily: * Proper code/parameters completion (based on project files, and even custom meta data files for when PHPDoc isn't enough) * Code refactoring (Renaming variables, methods, classes, namespaces, extracting code as property/method/constant/parameter...) * Zero configuration xDebug breakpoints debugging or even as I recently discovered, breakpoints debugging in unit tests that go through Webpack =&gt; Karma =&gt; Mocha =&gt; Chrome. * Search by Class/Filename/Symbol in all projet and/or dependencies, also search everywhere (Settings for example is so practical, I don't need to remember where an option is). * Customizable code generation (Constructors (select properties and it sets them), Getters, Setters, Override method, Implement method, Dockblocks). * Highly customizable automated code formatting. * Integration with all my tools (Docker, Git, PhpUnit, Karma, Mocha, npm...). I don't say all this is PHPStorm exclusive, but having it all together is (am pretty sure) not seen anywhere else. I was septic of PHPStorm a few years ago (I used Netbeans mostly), all those people preaching for it seemed fishy, but I tried it, and looks I am one of them now.
I second this too. phpStorm makes it easier to do the job but there is some learning to make. There are a lot of shortcuts that will save you plenty of time. If you can't buy it, Sublime Text would be my second recommendation, search for the best packages for php development in sublime text.
If you don't want to use PHP, why not look at Go? It would definitely be faster than python and much easier for concurrency.
What of this would you not want your editor to do and why not?
Thanks for the reply! I'll try to use VIM Hard Mode!
Yes, it's currently down. :(
It's a surprisingly light IDE, and you only get the lines specifically if you choose to do the code coverage and only as long as you choose it to be there. But hey, you like what you like. It sounds like you're not all that interested and that's fine
I have tried it too. I'm not one of them.
Yes, in lots of european locales, the regular comma is used as a decimal separator, so semicolon is used as separator in csv. 
Probably because people have language preferences and biases. I certainly do, that's why you should be using xsv.
There's a suspicious lack of blocks syntax variations :P I hope whatever we get, won't be crippled to an expression. 
&gt; It's doubtful because you never tried. I have tried PHPStorm. &gt; I'm not going to sit and reconfigure my IDE from the way I like it to get you to stop using a text editor. I never asked you to. &gt; I'm just trying to point out that you can do these things you're asking about, if you want too. Well if I had a reason to change what I was used to and knew that what I was going to wasn't going to make my eyes bleed, then I might be more interested. All my original comment was about was finding it odd that the person "could not fathom" that someone would use anything else. That seemed like a pretty stupid thing to say.
Yep.
Yeah, I have. It's pretty good but it doesn't play well with tiled windows managers. I mean there is no bug or anything, but I have established a workflow around terminals/Vim/i3wm which is pretty efficient and doesn't completely screw up my memory. By the way, that's another reason to learn how to use Vim: the bindings' conventions can be used in any IDE (c9.io also has Vim mode). 
f($x) $x
I disagree, actually that's the reddiquette everywhere. In fact I'm breaking the reddiquette right now by not downvoting you.
what issues are you facing preventing you from upgrading? I've been in a similar position and it mostly revolved around deprecated features that were removed. 
supposedly its not about biases though... his suggestion is for better performance: &gt;python performs much better reading large files than PHP
Fuck, this community is toxic.
I'd start your first day and see what they use. Especially as a junior dev, using the same IDE as everyone else will help them help you more easily.
&gt; all the reasons why symfony dropped HHVM support I've fixed composer, but 'all the reasons' isn't accurate: - phpunit definitely still has issues (https://github.com/facebook/hhvm/issues/7876) - I've not looked at symfony yet beyond the parts of it that composer uses - there's reasons other than compatibility I'm taking a break from my normal (not HHVM) work to try and help out with these for the next month or so.
I don't think you are fully correct. With plugins/extensions you can turn Sublime and Atom into a ice cream truck getting driven by an illegal immigrant if you want, but it can get a bit erratic and end up almost hitting some dude in a unicycle juggling some balls. edit: Glad a few of you got this reference. Thanks for the gold.
I mean my comment is a little sarcastic too. If you are going to learn a new language to do something, why not at least one that that's much more preferment and at least has different features. Python and PHP are so similar.
Sure it's a fine option. But how about PHPStorm?
Me four :(
&gt; I would really like to see Magento achieve some innovative and exciting things with the platform involving virtual reality, conversational commerce, and whatever the next fad is. ...that's the only mention of "virtual reality" and "conversational commerce" in that interview.
Dreamweaver .............................................. lol just kidding. Go with PHPStorm. Its awesome!
What would you recommend for a second, six figures salary, almost senior position in mid-sized startup?
Found a cool library that allows you to include files before the autoloaded files. For instance you have a private repo that has a definition files with a lot of if not defined definition clauses you wanted to override, by default composer loads autoload files in the order of required dependencies then your autoloaded files in your current project. https://github.com/funkjedi/composer-include-files Simple as: "extra": { "include_files": [ "./definitions.php" ] } Useful.
Looks really weird... But! So do namespace separators... So hell, why not add it to the suggestions?
Totally agree, but if it needs a prefix, fn would be the best imo
It plays just fine with tiling window managers. Used it previously with i3, scrotwm, and am using it currently with bspwm. Bspwm required a small non-reparenting window fix but after that it works perfectly. Vim, especially its key bindings, is fantastic, but PHPstorms ability to analyze static files (combined with its communication with FPM) is unparalleled by any extensions I've seen so far.
Bash or Fish shell with Vim8/Neovim.
It's at least unambiguous in the grammar. Many of the number of suggestions we've received on-list are not.
How2 looks really cool. Too bad it requires node/npm.
just going to jump on the PhpStorm train. i'd never used a fully-fledged IDE until three years ago (after developing professionally for nearly a decade) and it has 100% not only made coding easier but has straight up made me better at my job. 
What was the last version of Netbeans you used? That's all I use, and I love it. I find Phpstorm to be lacking. 
Definitly PHPStorm
Netbeans and/or Eclipse are really heavy. They have a bazillion features, can be incredibly slow (depends, but potentially), and a lot of the time they just get in your way. It will feel like your job is figuring out how to use Eclipse rather than do some real programming. I recommend staying lightweight. There is no inherent advantage to an IDE unless and until you are working on a project that benefits from it. Notepad++ is fine, but I prefer Sublime text as a programming oriented text editor. I think much more important than your code editor should be learning proper development workflow techniques. Uploading your scripts via FTP and testing on a remote server is a bad idea. Learn how to use Git (or another version control system) and learn how to setup a localhost development environment so you can test your code on your own development machine. Also learn how to work with your database. Phpmyadmin is terrible, honestly. Get more comfortable with SQL and interacting through an interactive shell, or with writing SQL scripts and running them directly. 
programming oriented text editor is lighter than a full IDE but a lot more featured than a plaintext editor. it's some kind of hybrid category and is probably closer to IDE than not. I would classify them as lightweight IDEs. 
I tried it but it looked difficult to easily access my GVFS (Gnome...) user space mounted filesystems like SSH or NFS.
Because typing `use ()` manually to import variables is *very* annoying and error-prone. Not to mention noisy to look at and read later on. Every time I have to write a closure with a bit more context (say `$db-&gt;transactional(function () use (....) { in transaction })`) I just dread the thought, because I know I'll forget half the variables I need to import and I'll have to fish them out of the parent context one by one after each failed execution with error. The idea of explicit closure over variables was wrong IMHO. So I'm hoping any new syntax addresses block syntax so we don't have to `use ()` for more complicated code anymore.
 When did the goal of programming begin to value less typing over readability?
What do you find lacking in phpstorm?
Another good video tutorial on phpstorm https://knpuniversity.com/screencast/phpstorm 
PHPStorm, It's a very flexible IDE, you can disable most of the stuff if you find it gets in your way. Also, at my company, the seniors that get 6 figure salaries barely do any dev work, they are affectively managers. if they do its building up a new project for the devs to build. The rest is more production quality, helping out low level devs (like my self :P) and getting us contracts to work on.
Been a little while since I used it. Had a lot of trouble with auto-complete, project scanning type stuff. Also found the interface clunky. Probably mostly just took getting used to, but a lot of commands I use regularly I could not find equivalents. I'm always up to look again, and I probably will. I just didn't see it when I tried it. 
Here are the general pieces of a closure: `function() use() { return; }` For closures that actually do something we are pretty much guaranteeing over 30 characters, few of which are really doing much. For an isolated closure this is not a big deal. However it's a much bigger deal when you have multiple of them in a row. Let's say we have 3 closures in close proximity - this puts us at roughly 90+ characters, most of it being boilerplate. This is the issue; those characters distract from the bigger picture. The shorter code *makes whole section more readable*. 
Looks like something broke on unsupported versions of PHP. Alas, I'll fix that and tag 1.0.1 as soon as Travis CI catches up. EDIT: https://github.com/paragonie/sodium_compat/releases/tag/v1.0.1
What's a little while? Because it's improved greatly in the past year and a half. I love the new 2017 version, and you can find a plugin for basically anything. PhpStorm is anything but lacking. You can also bind keys and customize basically the entire IDE.
My next go to then would be Emacs! Highly configurable and can do anything and everything.
I've switched my secondary editor to VS Code from Sublime Text, PHPStorm being the primary of course, especially when needing the full power of an IDE. My reasoning is that VS code is just as good now, if not better, and it has the backing of a much bigger development team. The development of Sublime Text has consistently gone in and out of limbo over the last few years. ST3 has been in beta for how many years now?
[removed]
[removed]
You should give it a try again https://www.jetbrains.com/phpstorm/documentation/ tons of online docs and videos to understand and learn about the vast amounts of features 
I'm really trying... the problem is always the same: client will not pay for the fancy code... 9 fucking years of experience and I have to work with php4... sorry, I had to vent.
Well, I've read that article too, but it doesn't say anything about errors or dropped requests. 
Too late I guess. Also, too many hacks required to keep HHVM working.
I don't say Laravel itself is written with "spaghetti code". I say that due to its ease of use, typical Laravel developer don't care about patterns, architecture and best practices. I've already explained why, [self-reference](https://www.reddit.com/r/PHP/comments/6eui3z/discussion_why_isnt_laravel_suitable_for/didl356/?st=j3r2ugk2&amp;sh=fd611682).
Are you going to update random_compat to use this polyfill? Since it suggests Sodium anyway.
&gt; I am treating a browser in the same as your phone. It should be treated the same. No, it shouldn't. A browser is a *very* different environment from a mobile application, with different security requirements and constraints. &gt; If someone gets your phone, and unless you have a device lock on your phone, you're pretty much compromised. I'm not talking about physical control over the device. I'm talking about cookie stealing through eg. XSS. This is a concern that exists in browsers, but not in (most) mobile apps. &gt; Storing an access token as a cookie sounds ok.. except where you are stateless. Then there are no cookies. All you have is local storage. These are two *completely* different things. "Stateless" means that the client is responsible for sending all state to the server with every request, including session state. Whether that is through a cookie (which is just an automatically-sent HTTP header in the end anyway) or through a request payload originating from Local Storage doesn't matter one iota. &gt; You can store your tokens securely in local storage.. but then you need a password to get them out of storage.. kind of defeats the point of what you are trying to do with tokens in the first place. You cannot, because anything that is injected into the page through an XSS attack can intercept whatever you are storing in Local Storage, encrypted or not. This is the whole idea behind the `httpOnly` flag for cookies - it makes it so that client-side JS simply *can't* access the cookie, no matter what. It can only be sent along automatically with requests by the browser. &gt; You need to literally drop cookies from your vocabulary and think of a solution without cookies at all. No, you don't. Cookies are the correct place for storing sensitive state that needs to be passed back to the server on every request - whether that state is a session ID or a cryptographically signed token containing the user's ID and such. I don't know where people are getting this idea from that "stateless" == "no cookies", but it's complete and utter nonsense from a technical perspective, and betrays a lack of understanding of what statelessness is about, how it is accomplished, and why you would or wouldn't want it. &gt; You can of course do some security by obscurity like use the device id or something to encrypt/decrypt your tokens into/from local storage. Obscurity is not security. &gt; I understand exactly what you mean WHEN cookies are available. Otherwise its pointless to talk about httponly when cookies don't exist. Every serious production-ready HTTP client supports cookies, therefore cookies are always available. Name me one that doesn't.
This is good stuff! However the application is done and only used internally by a few people. Upgrade from 2.5 to 2.9 seems like way more hassle than just changing the engine. Plus any further development that may be needed can be done in Hack, which is exciting.
&gt; Upgrade from 2.5 to 2.9 seems like way more hassle than just changing the engine. If you're composering in cake, you can just composer update and be done. If not, just nab latest 2.9, put in the lib directory and done. Unless you're doing something 'wrong', then it should be that simple :)
Thanks for the tips, still going to use HHVM.
Oh nice, will try that. Thanks!
&gt;Firstly, do you need oracle support? Firstly, I need to think twice before signing up for crazy tasks like this! :) Yes, my friend does need Oracle support, and is also using MySQL because you know, total mess. Yeah, I don't have those env variables set in my shell but I suppose they could be set for httpd service account. . . I'm slowly dissecting this setup. . . Yeah, recompiling is where I was thinking I'd need to go, trying to avoid it. I'm doing this on the dev box but the prod box is not set up exactly the same way. Fun fun fun. :) 
If you're brand new to programming, go for it. If your a seasoned programmer (even in a different language) there are free resources online that will give you all the same info
Thank you for clarifying
Thanks for your work, mate. I know you and I don't often see eye to eye, and that you get a lot of flack here; but this is a huge amount of effort and it's pushing PHP forward. :)
This looks really cool and is very inspiring. Thanks for building this :D
Awesome! I recently joined on as maintainer of Dokku to help fix bugs and further it along. I also am building a service on top of Dokku to bring a more Heroku interface feel to the system, shameless plug: https://www.stackforge.co I'd love to hear what you like and dislike about Dokku and what you'd also like to see come to Dokku.
Can I ask why? I don't know enough about this style of coding to understand. Is it just because of the lack of security audit?
It's good to learn syntax and beginning concepts if you're new to programming in general. It's a good start.
And 3. It's just a question of versioning your deps well (or leaving an ext or two out where needed.
You will still make the call if there is a man in the middle. So everything that is transmitted can be captured by an attacker.
It is important, as without it its possible who you are contacting may not be who you think it is. SSL certificates are about more then just simply encryption, its ensuring that the person on the other end is who you think it is and not an imposter.
Depends on what you're connecting to and how much trust you had in it in the first place. Connecting to an online banking system? Dangerous. Scraping data from a web forum about macrame? Whatever. 
And then let's add generics and enums. That's perfect language material here.
Same. I read CSVs from our data supplier approaching that size where loading the entire thing into memory is not going to work. I also have to be robust with how I read the file. I can't expect the headers to be present, and I have to handle rows with unexpected numbers of columns.
They may be off in documentation because of local development servers and so on. In production they MUST be on. The risk is man-in-the-middle attack.
Mamma mia, after some more head banging moments, I found and followed this and it worked: http://www.oracle.com/technetwork/articles/technote-php-instant-084410.html
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Yes, there is an option to upload file on save automatically. It can upload file on change, on file save, or disabled making it a manual upload.
I guess you could make a case for that. I would argue that as soon as you start adding language specific syntax auto-completion and built in programming language helps you have stepped out of the realm of "text-editor". But I concur with @metaphorm, it is more of a light-weight IDE, with the ability to add plugins and extensions to match a full-blown IDE.
I think the goal is to change one-liner functions for instance array_map($item =&gt; $item-&gt;name, $collection) // instead of array_map(function ($item) { return $item-&gt;name; }, $collection) But I still agree with you, I wouldn't change the current syntax for functions that require multiple lines. I think arrow functions are less readable in some cases and it's even more problematic in PHP since we already use "=&gt;" for arrays (It will be quite confusing for the new generation that will learn PHP). 
Yep, it will definitely shorten the syntax and it may speed up the composing time of these functions. The main issue i see is, like you said, readability. Not because of pointers per se, but because to me it's just an attempt at making one line, look a little less "bad". Personally, i'll always stick with the "old fashion way" of doing; array_map( function (Item $item) { return $item-&gt;name; } , $collection); Which to me, personally (which is very important to mention), will always be the most readable of them all.
[removed]
/u/AlexiaTC Show us the code - that's what matters. Currently it's just another bootstrap page with terrible UX.
The one by Larry Ullman is pretty good.
Self-signed certificates are just fine, you need to set correct CA bundle to verify against, see https://curl.haxx.se/libcurl/c/CURLOPT_CAINFO.html
It does. You either trust a single cert you signed yourself, or trust everything that comes your way by disabling verification.
And modified!
Yes, if you trust that certificate manually it makes a difference, but usually people just allow self-signed and don't manually verify it's the right certificate.
Tell him that maintan php 4 or 5 will require an addional fee from now on
I like that idea. C++ allows you to specify `[&amp;]` in front of a lambda to capture references. It also allows you to specify no capturing IIRC, or capturing by value.
&gt; Just as an example, consider an object that sometimes receives a file system connector and sometimes receives a network connector. The determination of which to inject cannot be made at construction time because it depends on a setting that cannot be resolved until after the object has been constructed. Inject a ConnectorInterface instance, that way your class doesn't care if it is a file system connector, network connector, or whatever connector, as long as they implement that Connector Interface. I'm bad at explaining, someone else might expand if you need. 
[removed]
&gt; Inject a ConnectorInterface You can't inject an interface. You need to inject instances of a particular implementation of said interface. What OP is saying is that you need to know which implementation you need before the injection happens. As others have mentioned there are solutions to that: factories, strategies, etc.
Small nit-pick. Functions that take functions are also true high order functions. It doesn't matter if it takes or returns a function.
OSMI raises awareness (via social media, awareness campaigns, conference talks, published guides, etc.) You can read more on their website: https://osmihelp.org/about/about-osmi
[removed]
It may look like anything to you, the important thing is if it has the drawbacks commonly associated with service locators. And it doesn't. So there's no reason to avoid it.
&gt; It is possible to see how this style of programming opens many possibilities over the more procedural or OO style often associated with older versions of PHP. On the contrary, this style of programming is more similar to OO than you think (and likewise has the same possibilities). Consider: class Writer { private $fp; public function __construct($fp) { $this-&gt;fp = $fp; } public function __invoke($contents) { fwrite($this-&gt;fp, "$contents\n"); } } // writeToFile :: string, string -&gt; (string -&gt; ()) function writeToFile(string $path, string $mode = 'w'): callable { if(is_dir($path)) { throw new \Exception('File must not be a directory!'); } $_fp = fopen($path, $mode); if(!($_fp &amp;&amp; is_resource($_fp))) { throw new \Exception('Error opening file!'); } return new Writer($_fp); } $writer = writeToFile('file_to_write_to.txt'); $writer('&lt;p&gt;First Paragraph&lt;/p&gt;'); $writer('&lt;p&gt;Second Paragraph&lt;p&gt;'); There's a saying, "Closures are a poor man's object; objects are a poor man's closure." Because a closure, beneath it all, is a class instance with a single method. Now, don't get me wrong, if an instance with a single method is exactly what you need, then function closures are a convenient and succinct way to express that, and I use them quite often. But their "many possibilities" are no greater than what OO already offered. I would say they're a simplified syntax for a specific kind of class instance.
&gt; You are constructing a service locator, while I am saying that you could just as easily use a dependency injector. What you have failed to state is which advantages a service locator has. What exactly would be the distinction between "service locator" and "dependency injector" in the code I posted? It feels like a very arbitrary distinction, when said like this without specifics. &gt; What you have failed to state is which advantages a service locator has. I didn't fail to state it - my solution is in response to the problem OP created this entire thread for. Namely, conditional use of dependencies. An object may *optionally* need some of its dependencies, and creating them all in advance can be inefficient. It may also be impossible, if the dependency has to be configured based on parameters the object knows only during its execution. Introducing the factory interface is a solution as then the object can request the dependencies it needs *on demand*, and efficiency etc. is preserved.
FP also forces a completely different style of programming and therefore thinking. I'm sure you could achieve much of the same with many different forms procedural coding. This example is just to demonstrate a different way of thinking. It is not my place to say if it is a rich man or a poor mans tool. It is simply an illustration of another technique. EDIT: You missed out the second half of the example. How would you tackle that with OO? (I can think of a few ways)
 &gt; I'm writing a library to which no MVC framework is attached. The point still holds though. If you can't know the dependencies without doing some work first, you need to have multiple steps of execution if you want to stick to pure dependency injection. &gt; soliloquy .......................................k.
/u/tech_tuna did you get this sorted? I've had the misfortune to have to install OCI8 on php7 about 6 months ago. If you've still got issues, let me know and I will see what I can dig up to help...
/r/phphelp
[http://symfony.com/blog/is-symfony-too-slow-for-real-world-usage](http://symfony.com/blog/is-symfony-too-slow-for-real-world-usage) Same idea, really. Not really going to comment on the sentance "Benchmark Breaking Speed" without given methodology, and even if it was given, chosing your framework over a benchmark showing 5% more requests would be a huge mistake. There is many things to considere when choosing a Framework, and speed is rarely one of them. 
If this was a project i was working on, I would say the exception should be only thrown in the model. A controller should only be passing inputs to models and views. If the model happens to hit an exception, it should be logged and pass a false or error code to the controller, which then passes that on to either a error page in the controller or an error display in the view, though id choose the latter. $data['student'] = $this-&gt;Student_model-&gt;createStudent($course); $this-&gt;load-&gt;view('student_view', $data); and in the view: if( $student ) { } else { //Print Some error about create student issue. }
&gt; EDIT: You missed out the second half of the example. How would you tackle that with OO? You don't have to do anything different. // change the mode to append $appender = writeToFile('file_to_write_to.txt', 'a'); // use the toAll function we made to apply to each element of the array toAll($appender, ['Functional', 'PHP', 'Rocks!']); // apply the string to upper to each element of the array, then apply to the appender toAll($appender, array_map('strtoupper', ['Functional', 'PHP', 'Rocks!']) ); `writeToFile` returns an instance of `class Writer`, then we pass that instance of `class Writer` to `toAll`.
&gt; This is the assumption baked into all dependency injection containers used by popular frameworks That's because that assumption is valid 90% of the time. Many tools we use have some level of assumption baked in. It's your job as a developer, to know when and how to use them. In your example, there are a couple of options: 1. Attempt to distinguish between those scenarios as early as possible, and delegate from there. 2. If that's not possible, then what you describe is a good candidate for the abstract factory pattern, where you need to construct different kinds of similar objects (i.e. same interface) which will have different dependencies. 3. In conjunction with #2, if the logic to decide which connector to use is sufficiently complex, that sounds like a responsibility in its own right. So inject your abstract factory into your "ConnectorSwitcher" object, and inject that object into the client code. Then just call `$connectorSwitcher-&gt;getConnector($criteria)` method, which will return an instance of `ConnectorInterface()`. Then the client code doesn't even have to worry about deciding how to use the factory, as it just needs to *tell* the `ConnectorSwitcher` to give it the most appropriate connector object. In both cases (#2, and #3), they work seamlessly with DI containers. A factory is a perfectly valid object for the container to resolve.
Seems it is just the intro - I would have at least touched on some samples of each, as this seems to early to be a part one in itself.
Thank you!
This. Knowing what is considered a best practice is the easy part of the job. Knowing why it's a best practice is the insteresting one, and recognizing when a best practice isn't one anymore is the tricky part. If you apply best practice blindly you are just cargo culting. It can only take you so far. 
not so much anymore as with symfony 3.3 it's really easy to automatically turn controllers into services. https://github.com/symfony/symfony-standard/blob/3.3/app/config/services.yml#L25 Of course that depends on if you like autowiring or not.
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [symfony/symfony-standard/.../**services.yml#L25** (3.3 → 59687da)](https://github.com/symfony/symfony-standard/blob/59687da627dec12a1378bba325c3c235c8992e9d/app/config/services.yml#L25) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dirno3k.)^.
Especially when having to read through the code of some library that you haven't written it is extremely useful to not have this feature, right? you don't wanna just jump into the implementation of some function, you prefer to do a manual grep search, then on the second function, on the third, and then decide which object it might be. Because you are a smarty pants and think you can make people write better code. Great fucking argument. "lets dump this useful feature to force people write better code at the expense of my own efficiency". "Lets not have this feature, because other programmers are dumb, ahaha THATLL SHOW THEM" hilarious, I honestly was laughing at this
the lack of php 7.1 support bugs me. Type hinting should be treated better. And facades like in laravel shouldn't be promoted like they are. Basically black boxing the implementation. Contracts seem the better way to go. and I have to disagree with you. The mainstream php frameworks are clearly not the same. There is a strong reason laravel is trending https://trends.google.com/trends/explore?q=laravel%20php,symfony%20php,yii%20php,django%20python 
And what is that reason?
the reason is they seem to do almost everything right. There is very little I can complain about in laravel. I say "ew the facades" but that is basically a matter of taste. laravel did everything right, and everyone likes it. There is no initial hype, then flatten out. Laravel is just steadily growing. And I wrote professionally symfony projects, slim projects. Symfony I didn't like. Slim is just very minimal. Laravel is the way to go. The creator did a lot right.
If you're using git, create another repo. When you make changes you like from repo A, you can merge the change to repo B.
Not sure what implicit closures are but you can definitely do the rest right now. At least as far as I can recall 
There is only one application, one codebase. Things that change are placed in config files or a package or something. Do not get in to maintaining two codebases for what is, essentially, one project. 
Create a fork. You could rebase from the original fork quite easily.
WordPress is a PHP program. So you can write a WordPress plugin in PHP and it can interact with the core WordPress program. So, yes.
Haha.. I built a website with squarespace and I have a ton of stuff added to it like Java stuff and I am starting to learn more about programing websites and I want to move to wordpress but I don't want to have to redo everything to put it in wordpress from squarespace... I know I can import and export, but I am not sure how much that will help and how much I will have to redo.
Neat! That's pretty clean. I like it.
This is great. I never fully understood how/where to start with LibSodium and this explains that.
Any improvement suggestions? Scrutinizer is complaining about too many conditionals..
I'm glad you found it helpful. I hope I didn't miss any other sources of confusion, but I probably won't know those until libsodium sees mass adoption. (sodium_compat may be a good catalyst here...)
You'll have to redo a lot. This is how Squarespace gets you.
To keep your code DRY Scrutinizer wants you to use methods at decision points, this means every time you have an if, loop, while etc you should break the code off into its own function so you can reuse it. Some of your methods have multiple ifs and it’s identifying that maybe you can reuse code within these blocks. If that’s not possible then leave it as it’s just a recommendation.
Idk if trolling or not... *Futurama meme here*
These are a complex and time-consuming task, Therefore its better to use a framework to achieve these task. Laravel is or Symfony is a great option for that. 
Just curious whether this is comparable to symfony/process, or if there is any obvious advantage that I'm missing. AFAIK, that component also uses pcntl to handle async execution, but maybe something in particular is different? Just curious, since this could be a decent abstraction for running multiple processes asynchronously, but synchronised at the end.
Exception messages are for programmers, not for users. As long as the message is not intended to be the one displayed to the final user, both can be valid.
A lot of problems linked to state and flow control. "Out of the tar pit" is a quite good paper advocating for it: http://shaffner.us/cs/papers/tarpit.pdf
symfony/process [relies on proc_open](https://github.com/symfony/process/blob/eab2bb8157ab08fecf97bd071e3f59ae00f53ff2/Process.php#L150-L152), which may be disabled. It's also easier to avoid POSIX-only functionality (or distro-specific, or non-standard binary usage) when using Process Control: given you never really drop out of the PHP env. On the other hand, I find it far easier to use the exec-likes than to use Process Control...
Implicit closures mean not having to specify the use statement when creating an anonymous function. It is a way to achieve brevity in your expressions. An example why brevity matters in FP. Here is a function to prefix all entries in a string array in PHP: function prefixArray(array $arr, string $prefix) { return array_map(function($t) use ($prefix) { return $prefix.$t; }, $arr); } While that looks nice and succinct for PHP, here is the same in scala: def prefixArray(arr: Iterable[String], prefix: String) = arr.map(prefix + _) Note the use of underscore to refer to the current parameter of the embedded expression, and the lack of need to specify either a use statement to capture external variables or of the function keyword to describe an anonymous function. In fact, the expression is so succinct that you wouldn't even define a function for it, you would just call the map() inline, since it is shorter than calling this predefined function. Scale this verbosity out across a FP codebase, and it becomes unwieldy. That's one of the reasons why you don't see much functional style coding in PHP. 
That "with minor changes" will explode like a milk-shake in an un-closed blender.
It's 2017. No-one uses Java on their websites nowadays.
&gt; Last Friday at Day Camp 4 Developers, I presented a talk Are you planning on releasing the videos at any point or are they staying behind a pay wall?
lol, not seeing public sites using Java since ~10 years.
I like your code, it's clean and a solid implementation. I wouldn't mind over Scurtinizer so much, but you could consider breaking down the wait function into multiple functions. When I looked into parallel coding in php, i wanted to use the pcntl extension as well, at first, but then i switched to the pthreads extension. Since it was a hobby challenge anyway, I didn't do that much with it. In your opinion, what's the advantage of using the pcntl extension with your own process implementation over the pthreads extension? 
Actually nothing. I'd much more prefer to use pthreads with shared memory for communication. But the pthreads and shared memory extensions don't come out of the box in many PHP installations. I guess process forks are also a bit more easy to reason about. I needed parallel process support in a project, and didn't want to rely on [amphp/parallel](https://github.com/amphp/parallel) because there is no stable release yet. So I decided I'd just use PCNTL for now, with a little helper wrapper around it. But now I'm also hooked on the whole parallel thing, and want to learn more about it :) So the next tryout will be with pthreads for sure. (looked into it shortly before). But as for you too, that will just be a hobby project :)
Tiny little nitpick for you - it's spelled "converter". 
Well I'll be damned! Carry on then, I retract my little nitpick :-)
If you are looking into programming for the web, be warned that pretty much all Content Management Systems are awful to develop for compared with the sort of frameworks designed more for web applications. Wordpress in particular encourages very poor practices. We use SilverStripe for CMS based projects at work which is the best of a bad bunch. I hear Drupal has improved a lot over the years.
I think symfony/process does give access to the buffered output of the script, but I'd need to check to be sure. It doesn't solve the communication problem any more than PCNTL does...
Not using laravel, but I'm in a similar boat, created a new repo where a lot of the same code is shared between two code bases as a private repo and use composer to load that and bootstrap the apps together w/ the features I need. I'm more concerned about maintaining templates across both projects.
Something I've done for calling commands in bulk where an exception could be considered non-blocking to the other operations in the batch; class UserRuntimeException extends RuntimeException { private $user; public function __construct(string $msg, User $user, ...$otherArgs) { parent::__construct($msg, ...$otherArgs); $this-&gt;user = $user; } public function GetUser() : User { return $this-&gt;user; } } $theseOnesFailed = []; foreach ($users as $user) { try { $someTool-&gt;doThingWithUser($user); } catch (UserRuntimeException $e) { $theseOnesFailed[$user-&gt;id] = $e; } } if (count($theseOnesFailed)) { // present failure/retry list here }
I disagree. If you're tying to save a user and their email address fails the validation in your users model (because it's an invalid email address) you should throw an expcetion with the message "Email address does not appear to be valid". You can then show that to the user. Why would you write a really helpful exception message and then hide it. Then write another message for the user... you're adding more code, complexity and work for yourself.
I think unchecked exceptions would be a great feature, but I think it would be nice if it were optional to declare exceptions of the dependencies that live outside of the method. public function index() { $this-&gt;checkAccess(); throw new ExampleException("example"); } protected function checkAccess() { throw new AuthorizationException("another example"); } In the above, I would prefer not to be required to annotate the `AuthorizationException` for the `index()` method... my reasoning is that, as soon as `checkAccess()` throws a different type of exception or I remove that exception altogether, my `index()` throws annotation is incorrect, and then all throws annotations become meaningless...
https://trends.builtwith.com/topsites/J2EE
Looking forward to see this develop. Keep it coming :+)
It has zero checking and error handling for e.g. child exits bcs of error master will fail with broken pipe and etc. it need way more of checking to handle socket pair communication.
That's out of my hands. I didn't record anything myself. (I generally don't like to record myself. For example, what was the last time you've seen a photo or video clip of me?)
True! Any good learning resources about error handling when runnen parallel processes?
Back In the days I was working on this topic with forking and inter process communication. But soon I just switched in using event-loops as my use cases was usually API calls and etc. I have even whole PHP Component framework based on this topic. This one is for Socket communication it also has SocketPair https://github.com/ThrusterIO/socket
Read up on [laravel service providers](https://laravel.com/docs/5.4/providers)
This is the server side. I wrote "on their websites" like, in the front-end. Not "for their websites" (i.e. server-side Java solutions like J2EE).
Your statements to the contrary notwithstanding, it has all the benefits and drawbacks of service location.
Isn't https://getcomposer.org/doc/04-schema.md#files the same thing?
isn't lemonade one of the worst performing micro frameworks? I think i saw a benchmark somewhere of almost all php frameworks and lemonade was worse then even full frameworks.
There are a lot more free resources online then someone would ever find in a book. I learned all I know online.
Not relevant to what i am doing.
https://wiki.php.net/rfc/libsodium Look at the second vote.
Tool? I wouldn't go that far. It's a coding standard, nothing more, nothing less. Don't be lazy. Call a spade a spade.
I think i might have not explained myself well enough. I don't want users to be able to install anything via a zip, I am asking if there is a better way of implementing what is known as "feature toggling" where if the user is paying for the time tracking "module" and a reporting "module" then those will be shown and work well with eachother, but if you also are paying for a project management package you will see relevant info about that module in the time tracker and the reporting module (user tracker 5 hours on project X in the time tracker", total time tracked on a certain project as a graph in the reporting module).
Good stuff! One problem I noticed is that the input order of processes will not match the order of output. I could be wrong, I only glossed over the code, but it looks like the first process to finish will take the first place in `$output`. I recommend making the orders match (similar to [npm's async.parallel](http://caolan.github.io/async/docs.html#parallel)), it will make it easier for a consumer to use.
Good catch. I'm actually not using the `$output` in my use case, but it would indeed not be the correct order.
I kinda wrote my own solution, using a bit of a hack with Events that trigger in various places, and only enable listeners when the feature is active. I then pass back data via a stdClass object or whatever in the Event model, to modify behavior such as query modification, displaying some UI conditionally (e.g. just echoing some HTML if you trigger the event in your views), etc. Not the cleanest solution, but it works for me so far.
You might look into how WordPress does it. Even though you don't want your users to install modules you can treat them like they were. Meaning, you have to have some type of hook/filter/trigger/listener type of functionality. WordPress has Shortcodes. Something like ``[some-functionality /]``. In your Admin, you save a list of active modules. During some early part of your request cycle you load the classes for active modules. From there your hook/filter/trigger/listener system takes over. In this example, if your module isn't active, the code behind ``[some-functionality /]`` is never ran because the code is never loaded so the system doesn't know what to do with it. If it is loaded, the right classes are loaded and the system now recognizes ``[some-functionality /]`` and runs the code attached. That's just one option though. 
&gt; Laravel is one of the slowest frameworks out there It is out of the box, with everything enabled, but it's not difficult to pare it back a lot and achieve very competitive speeds, even with minimalist frameworks (assuming you're using a similar set of features). It's certainly not an issue for the vast majority of projects with only thousands of requests per second or less and by the time Laravel is actually your bottleneck you should be able to invest the resources into isolating the most time sensitive parts of the application. I really struggle to accept this as a valid criticism of Laravel for the overwhelming majority of usecases. &gt;it makes a series of major serious architectural mistakes, which less experienced programmers can't understand Do enlighten us mere mortals. 
&gt; That's out of my hands. I didn't record anything myself. Shame, would have liked to have a watch &gt; For example, what was the last time you've seen a photo or video clip of me? Haha, I've honestly never looked, the only time I've seen a photo is on that Day Camp site today
Yes and No. For instance say we have a package that we want to include in our project and it loads a 'defines.php' file. If there are any `if(defined())` clauses setup in that file when you setup your autoload in your current repository the order of loading is as follows: - -&gt; all autoload packages -&gt; package/define.php - -&gt; yourapp/override_defines.php If you want to override any of those define's you need your file to load first. That package reorders the autoload files array to include your file first before all the autoloaded files in vendor packages.
Why does packagist/composer default to `http` when loading packages? I'm always forced to do this in my composer.json in order to have speedier composer load times: ``` { "repositories": [ { "packagist": false }, { "type": "composer", "url": "https://packagist.org" }] } ```
Username checks out.
Move up the ladder. Go directly talk to top management, you're losing your time interacting with middle management.
&gt; It is out of the box, with everything enabled, but it's not difficult to pare it back a lot and achieve very competitive speeds, even with minimalist frameworks (assuming you're using a similar set of features). And what kind of "features" do you believe make Laravel's snail pace acceptable? &gt; It's certainly not an issue for the vast majority of projects with only thousands of requests per second or less This is either a thick typo or you don't know what you're talking about... &gt; Do enlighten us mere mortals. I've enlightened people many times about Laravel, search my comment history. The further back you go, the more detailed my critique gets. And now... I just send people to my comment history. 
&gt; &gt; &gt; it makes a series of major serious architectural mistakes, which less experienced programmers can't understand &gt; &gt; &gt; &gt; Do enlighten us mere mortals. &gt; &gt; I've enlightened people many times about Laravel, search my comment history. The further back you go, the more detailed my critique gets. And now... I just send people to my comment history. I always see "I've already told people 100 times why Laravel bad" and "Well _real_ programmers think it's super obvious, but youngies cant see it" but I've never seen anyone actually explain it.
They understand the "we have 20% more conversion rate than with the old website and it has saved 400 manual forms processing, a win of 80 hours". Your work means money. The middle management wants the glory of it but will blame you for their incompetence.
You see, that's why it's so tiring, because no matter how many times I and others explain it, there will always be droves of newbies who will say "nobody ever explained it". Here's a short list: - God classes (Application combines around a dozen unrelated concerns like configuration, dependency injection, localization, routing, debugging, etc. etc. it has 100+ public methods last time I counted, it's **ridiculous**. Eloquent has 60+ public methods as another example). - Hidden global state, and encouragement of global mutable state (explicit: Laravel's static Facades which are encouraged throughout docs and result in spaghetti that destroys clarity and opportunities for code reuse; even when not using Facades, the application container is globally accessible via Application::getInstance(), which Laravel's own code uses in unexpected places). - Single global container, with no ability to modularize dependencies for modular application development. - Unawareness of the "composition over inheritance principle" (Application extends Container for ex. despite it can easily be an application property.) - Usage of the widely deprecated Active Record pattern for Eloquent, which tightly couples storage mechanism to entity business logic, and has much lower performance than alternatives like Data Mapper, due to inability to implement Unit of Work, batch processing, and results in common N+1 problems. - Rampant and unjustified use of "magic methods" which hurt API discoverability, error prevention, require special IDE plugins, breaks static analysis tools, and further brings down performance. - Laravel's author is unaware of basic terminology and is confusing his entire community (Laravel's "Facade" is absolutely not "Facades" as the rest of the industry defines them; Eloquent's "pivot tables" are absolutely not "pivot tables" as the rest of the industry defines them; and more recently he has used the terms "real-time" when he meant "run-time", and used "tap()" for an API which does something completely different than the "tap()" API in Ruby, which he supposedly modeled it after). Anyway, I can make this list twice as long, but for someone who's "never seen anyone actually explain it" that's enough homework for now.
Hi, I'm one of the OSMI board members. Certainly check out the website, but specifically what OSMI has accomplished to date is creating 3 handbooks around ADA law for Employees, Employers as well as taking over forums that give people a place to talk about mental illness. They've also made videos for C level executives to inform them on why they should be proactive with mental health awareness in their organization. OSMI also promotes many resources around mental health such as where to get help, where to find Mental Health First Aid Training and much more. They also do a yearly "Mental Health in Tech" survey and release all of the data for free. The "Open Sourcing" part of the name is because as much as possible the work is open sourced via creative commons license.
Put all the code in a composer package, import it, and put the custom config and binaries in each project root.
The poster clearly meant JavaScript, you can correct them without being a dick about it.
&gt; You are not a random, replaceable Java codemonkey. So in order to feel better as PHP developers, we need to put down Java developers. That's kinda sad.
I wouldn't trust an automated tool to do this. Say I'm used to annotating primary key input/output as "int" in my PHPDoc. But PHP int is not large enough to accommodate unsigned BIGINT columns in SQL, *even on 64-bit systems*. It's your work that's at state, so don't be afraid of using your head when maintaining it. It doesn't take *that* long to add typehints manually to code.
Well nothing special, everyone knows that symfony is one of slowest php frameworks and denying it is just stupid, but there is many ways to improve it like varnish and other cache layers.
I found [this](https://snippets.webaware.com.au/howto/stop-turning-off-curlopt_ssl_verifypeer-and-fix-your-php-config/). I am developing in a newer linux environment and I get no errors so I guess it has whatever it needs to check the certificates.
To me a conference is not real until there's some sort of scandal about a speaker booted out after someone complained they are racist and sexist.
Why thankyou. FWIW your username sounds like a crisp, refreshing Eastern European lager.
I really like squarespace, but I want to make a data base with a user login. I could use a third party for like $5 a month, but I wanted to build it myself.
Sorry. The word Java was a cheap shot. 
That really hurt! I'm sick and haven't eaten in two days!
I'm not quite following what you are actually suggesting, got any real world examples of this done in practice?
Tests as driving the thought process behind design is not immune to the conditions I mentioned above. What kind of unit test you'd write to drive the thought process behind your UI design? None. You need to test with people, which I mentioned above. Unit testing is not the only kind of automated testing. And automated testing is not the only kind of testing. And finally, testing is not the only kind of product/service feedback. Reducing everything to "must unit test everything" leads to poor outcomes and poor performance. We can generalize the thought you quoted above to the more correct formulation of "feedback drives the design process". But that's not very interesting because it still requires thinking how to design proper types of feedback for your team, while "you should write unit tests for absolutely everything" seems simpler, despite it's wrong.
Charge high, have things to show off your skillful portfolio and never bend to sales tactics or pressure. So often I find freelancers who bend to pressure for a deadline or charge so little they are so undervalued. I charge £90 an hour, about 20 less than my very successful peers. Because it lets me choose the projects and it sets in stone that I am not a cheap worker to be bullied. If working for a company I know and like I can chop that to £45 to make us both more money and If I know the client is going to be difficult or just unpleasant I will tell them I am too busy to take up their current project. A respectful way to turn down a project while making sure your reputation of high in demand is kept. 
Consider multi-threading, instead of forking. https://blog.madewithlove.be/post/thread-carefully/
It is actually more relevant than you think. Building a decent module system is quite a feat. All the ideas about using `if Modules::isActive('moduleX') {` work to some limits, but a solid solution, though more complex, is to use dependency injection and decent interfaces between modules. You will also probably need events and an event dispatcher at some point (but don't abuse it). And wiring all those thing correctly with a good IoC container is a good basis for the architecture.
Well, the whole multi worker deamon implementation comes from [shanehartner/php-deamon|https://github.com/shaneharter/PHP-Daemon]. an ex-colleague wrote just some workers that don't seem to consider their multi threading environment that much. In my hobby project, I fiddled with an implementation of parallel processes just like yours. Except that i wanted to created reusable workers rather than single result threads. I also worked with a json api via socket rather than serialized data for fun's sake, but of course, serialize is much better suited. I haven't uploaded any of it, because i din't go far with it. Maybe next vacation :D
1. It is a big problem. Invalid docs are worse than no docs at all. Exceptions that are not thrown should not be documented as being thrown. 2. Ok 3. Not under discussion It's much easier to notice that an exception is NOT documented (because you likely will not catch it in a meaningful way). It is near impossible to clean up a codebase with annotated exceptions which no longer exist. Yes this is somewhat an IDE problem, yes we are talking about an IDE plugin ...
You know we're talking about an IDE plugin right? And discussing the support of said plugin? Further to that, we're talking about annotations. The _documentation_ of our code. This _documentation_ should be correct. I'm suggesting that annotating dependencies is a maintenance issue that could potentially be addressed. 
Node has been going out of fashion for quite a while now, I wouldn't suggest starting it now to anyone who doesn't already have serious JS experience. By the time they get up to speed, those jobs will have dried up for the most part - the ones that are left will be underpaid because of the glut of people who jumped on Node as the "new hotness" over the last few years. If I had to start it all over again, I'd learn Java first instead of PHP, if only to learn proper OOP, proper unit testing, proper segregation of assets, and have a solid skillset that can port to a number of different well-paying languages. I wasted a lot of time in my early programming years with sloppy coding that PHP let me get away with, and it made it really hard to move into static typed OOP-only languages. I think I spent the first year of Java mostly unlearning "tricks" that only work in PHP and JS because of how sloppy the languages let you be.
Yes, add something to the project. If you deliver average work without thinking too much about the requirements, you may be doing what you're being paid to do, but you're also replaceable. Show your clients you can think with them, come up with good ideas, challenge bad ones, etc. 
To answer your title question: I would surround myself with other local professionals (freelance or otherwise), to keep myself from being too isolated and increase my network of both potential clients and outside contractors who could help me for larger projects.
I'd have stuck to laravel instead of trying to reinvent the wheel ever
Doesn't "Java on their websites" imply that I'm talking about Java Applets? The only one who brings server-side Java into this are you guys.
First of all, I won't downvote your comment, thanks for taking the time writing this down. I for one agree that PHP isn't the best choice when doing parallelism. The reason I think it's still good to share PHP documentation about it, is because many of us don't have the choice between PHP or something else. We're often building websites for companies who've made the decision for PHP long ago, working on existing projects etc. So even though PHP is not the best choice, we should make the best of it :)
Already read that blogpost :) Also mentioned somewhere in this thread that yes I will also take a closer look at pthreads, but PCNTL also has its advantages.
I am a bit curious on *why* you don't know what service you are going to need. I've had a situation at hand where I needed a file service for the situation the network service failed. I gave the network service a fallback implementation of the same interface. This way I could still build the instances at construction time.
I would figure out what kind of clients you want. It sounds like you don't have high quality clients. You have to ask yourself is that because: A) You aren't what high quality clients are looking for, or B) You aren't communicating well that you ARE what high quality clients are looking for. Think hard about A before moving on to B, because marketing yourself will only get you so far if you aren't where they want you to be. If you need to work on A, I'd say go find people out there who have high quality clients. I know the Laravel world better than the other frameworks or the RYO world, so in Laravel I'd suggest looking at people like Adam Wathan, Matt Stauffer, Chris Fidao, etc. Look at the way they talk about their work. Test Driven, Well organized, obsessively named, functionally fluent, etc. Learn all those things and practice them in your everyday work. It's not what PHP used to be, but it's what quality clients (I've done work for some fortune 100 companies using Laravel) want. If you've got A locked down, move on to B. How are you communicating to the world that you know what you know? Build open source packages. Blog. Blog a lot. Blog and tweet everything you learn, even if you think its dumb. Start a podcast. Build a SaaS app. Do whatever you've gotta do to get more of your thought process in public. Remember, you want EXCELLENT clients, and excellent clients USUALLY are super smart, connected developers or CTO's who are hiring the best devs they can find off Twitter and Github. Hope that helps. SOURCE: Went from being nobody to working for Excellent clients (albeit not freelance) by doing exactly what I said above.
When you do operations on a plain DateTime object, such as adding or subtracting days, those changes get applied to the object itself. and you practically lose the previous state. This is not always desirable, since you might want to keep a DateTime variable as a sort of reference date for something, and having to reset it after every operation/comparison can get really cumbersome. Instead of operating on the same instance, the DateTimeImmutable class returns a new instance of the DateTimeImmutable class, without touching the original. This way you can keep on using the old variable for whatever you need it, without fearing that the data in there will become invalid/wrong at some point.
I can't understand what the author is trying to demonstrate with his `UserModel` examples. What is this `cleanName()` method doing on the model at all? Why are names unset in `save()`? This aside, making small simple values like numbers, strings, datetime immutable is a no-brainer. But with larger composite values, we can see the other side of the coin. Have you thought why PSR-7 requests/interfaces are not broken down in logical components like Symfony HTTP foundation? Here's how you set a header in HTTP Foundation: $request-&gt;headers-&gt;set('Content-Type', 'text/plain'); In PSR-7, instead, all the methods are mushed onto a single object like this: $request = $request-&gt;withHeader('Content-Type', 'text/plain'); ... which is the only pragmatic way to factor it, because otherwise here's how working with PSR-7 would be like: $request = $request-&gt;withHeaders($request-&gt;getHeaders()-&gt;withHeader('Content-Type', 'text/plain')); Yugh. So as your immutable value grows in complexity, its interface explodes in complexity, compared to what a mutable version would be like. And sometimes keeping things simple isn't a solution: HTTP is inherently complicated, and PSR-7 has made bad compromises to keep its method counts under control. Things like lack of an API for producing and reading cookies (the only exception being reading the $_COOKIE array in ServerRequestInterface). Now working with cookies in PSR-7 requires third party tools. PSR-7 has also made another mistake: it tries to be immutable, without ensuring it can be immutable *in depth*. True immutability requires immutability in depth, i.e. everything that belongs to an immutable object should itself be immutable. But PSR-7 streams aren't immutable. So we have third strange Frankenstein which is semi-mutable and semi-immutable. The lesson here is that immutability is not always better. Sometimes we can make the conscious choice to model something as an *entity* and not as a *value*, and hence keep it mutable. Again, for the simple values, immutability is a no-brainer. But for complex entities with mutable elements, like HTTP requests and responses, going for immutability was a mistake. So don't go all "silver bullet" on immutability...
Thank you. 
I think everyone here has covered your question well with answers but I want to raise a point that most seem to have missed: &gt; The worst part is, people judge you based on how the front end looks This is something I've learnt over 10+ years of programming in a number of languages professionally. The end user (customer) really doesn't care how you get the result they just want it to work and too look good. I spent so much of my earlier career worrying about well if I loop like this instead of this I could save 100th of a millisecond, the customer doesn't care. They also don't care that your code follows strict OO standards and is fully commented they are only interested in the end result. Sure my own personal projects you will find constantly refactored code all trying to follow the latest and greatest guidelines and standards but for a customer project aesthetics and functionality is king. I know someone else mentioned it and got heavily down voted but with the way the internet its going into a single page architecture (a more 'app like' experience) learning JS is now vital for almost all use cases on the web, with maybe the exception of e-commerce, for the moment at least anyway. In my area at least, the number of jobs for JS is almost triple that of PHP so I would deferentially look at picking something up like VueJS, Angular or React depending on what's in demand in your local market.
$25?? Is it full of gold?
What happened to MySQL 6 and MySQL 7?
Not sure if this answers this but a good definition of FP is: "Functional Programming refers to the declarative evaluation of pure functions to create immutable programs by avoiding externally observable side effects." 
My guess is that they skipped v6 and v7 because MySQL 5.7 is very known as MYSQL 7 as a short. They might wanted to avoid the confusion and jumped all the way to 8.0. Just guessing here though :)
You should consider Lumen too. https://lumen.laravel.com/ Works well for small APIs, and it can grow however you like
https://api-platform.com/ No experience with it. Would love to hear those of others. It looks pretty nice.
Branch on git?
There's something to be said about a tool's DX design when so many tools exist that basically serve as simplification wrappers for it. The whole of the JS ecosystem is plagued by this, making simple things like extracting strings out of big blocks of text and optionally replacing them with slightly different strings into rocket science. Granted, YAML and XML configuration in PHP projects make me feel the same negative emotions.
Link to a site that presents an ad that links to another site that most likely shows more ads? No thank you, ain't clicking that link on google plus.
You are correct.
It's kind of a vicious circle. You can't write a slick API when you don't even know what you'll need. There are like 50 flavors of React applications alone. Not to mention a silly stuff like the choice of assertion library. I wager the root of the issue is that there are no strong opinion leaders in JavaScript community.
Like the idea of using webpack, don't like the idea of building a custom DSL on top of it. Webpack has a json-schema specification for its configuration format, and it works and makes auto-completion and error discovering a breeze: custom DSLs introduce a lot of space for failure and mistakes...
The community dictates the reality :)
I've used this, Drupal, and Wordpress. I find all three very functional. I guess Wordpress is best suited for smaller projects. While the other two scale to bigger programming teams easier? But I have not done a large project on Wordpress. 
https://apigility.org/ and https://docs.zendframework.com/zend-expressive/ There is new apigility in works that will be based on expressive ;)
CTE is one of the main reasons why I used PostgreSQL. Recursive queries allowed me to make a simple permissions scheme that allowed both group- and user-based access controls, where groups can inherit permissions from their parent roles.
This isn't an external DSL so autocompletion and error discovery are no harder. I think Webpack configuration is flexible to a fault: it's unusable most of the time unless it's what you do all of the time. 
You can set permissions on CTE?
One thing I like is that the max auto_increment value will be persistent across server restarts. A good thing when you want to set an offset on an empty table, that might not be used before next restart. (https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html#mysql-nutshell-additions)
I didn't know what that was either. I actually use it a lot in Sql Server, but didn't know it had a name, I guess. It's very useful.
Is MySql still being heavily used in the PHP community? It was all about MariaDB after Oracle tried to screw everyone with the MySql license and also PostgreSQL was getting a lot of attention 
I believe so. I know several companies still using them. also, they are ranked #2 after Oracle at this website (https://db-engines.com/en/ranking) - not sure how legit are they, but it looks they take many parameters into account when ranking the databases.
&gt; It is? You now have a builder for the same thing that had a declarative style... DSL does not mean "custom lexer needed" :-) By Martin Fowler's definition; internal DSLs are domain specific languages in the syntax of an existing language. Like this. External DSLs are in a new language syntax, which this is not. My point is that the same static analysis tricks work between JSON and JS (since JSON is a subset of JS). And the JS community seem more on top of language tooling than the PHP community where formatting, linting, and analysis are concerned. All these things in mind: your argument about the difficulty of tooling in the context of this internal DSL don't make sense to me. &gt; Did webpack for 2 days - works fine with the examples in the linked post I write a lot of JS. And from my own subjective experience: custom build chains are brittle, undocumented, and difficult to onboard people to. I don't think your "2 days" are representative of the difficulty developers have with understanding [well] how webpack works or how it can be configured to do the myriad of tasks front-end build chains require these days. In contrast, I only recommend Laravel Mix; because it never breaks, is well documented, and easy to onboard new developers. Perhaps Encore will be just as valuable to me. 
This doe's depend a lot on your architecture but coming into it blind I'm going to make a few assumptions and suggest an ACL layer would do here. I'm guessing you will have a 'master account' or 'parent account' which users belong to, set flags next to this master account to which modules they have paid for and are active. Then in each of your modules (probably a controller per module?) check for an active subscription flag if not deny access and redirect. Now probably more in relation to your original question, in your database store a 'module name' column with each of your modules. Then in your controller build the navigation menus from the database table referencing which modules the current user has active. I hope that makes sense? The tables would look like this: module: id, module_name user: id, .... module_user: user_id, module_id To build your UI you would select module_name from the module table after checking the module_user link table to see what modules the current user has active. This gives you the best flexibility because if you add a new module then all you need to do is add the user ID's and the new module ID to the module_user link table and all your menus would update to reflect this.
Look for async functioning for the libraries you are using and you will probably have more luck. For example mysqli and curl support async. I don't think theres an actual php native async syntax or at least not that I know of
Webpack *is* and wants to stay a low-level tool. It's only natural to have third parties build opinionated wrappers around it.
[removed]
[removed]
Why not just stick with Symfony if you know it already? An API is just a way of exposing your app, everything else should be the same minus the view layer. So just strip twig and you're good to go.
react?
Unrelated, but can I ask how you're handling the multi-tenant part of the application? I've been mulling over so many options for my own use and I can't seem to find one that truly feels natural. 
&gt; ...psst! While Bower is maintained, we recommend yarn and webpack for new front-end projects! https://bower.io/
1. I was targeting at a backwards compatibility concern here. Removing an exception that was previously thrown and annotated is not a problem. Callers might still be catching it, but they will not break because of that.
I know what we are talking about, but the plug-in is not to blame here, it's the IDE.
I think Guzzle does what you want: &gt;You can use the requestAsync, sendAsync, getAsync, headAsync, putAsync, postAsync, deleteAsync, and patchAsync methods of a client to send an asynchronous request. The client will return a GuzzleHttp\Promise\PromiseInterface object. You can chain then functions off of the promise. http://docs.guzzlephp.org/en/latest/faq.html#can-guzzle-send-asynchronous-requests
Hey, great question Khronickal! Anything that gets people thinking like your post does is great. To address your topic, I agree with some of the other commentors that for any complicated logic a factory would be the correct course of action. However, the software I work with has literally hundreds of classes, and running into the same type of problem you describe, I wanted a solution that didn't require me to have to add even more classes for simple cases. My solution was to design a new type of Container/Collection class that would be more flexible than existing solutions and also look sleeker when writing code. I've never advertised it, but if you want to utilize it here's a link and some usage examples below: https://github.com/joebubna/cora-container --- # One way to address the OP. This just shows applying simple logic to change injection resource returned depending on some runtime variable. Combine this with the next example to fully understand. // Initialization (registering resources) &lt;?php $container = new \Cora\Container(); $container-&gt;gateway = function($c, $connector = false) { if ($connector instanceof FileConnector || $connector == 'File') { return new FileGateway(); } else { return new NetworkGateway(); } }; // Usage var_dump($container-&gt;gateway); // Returns a NetworkGateway var_dump($container-&gt;gateway('File')); // Returns a FileGateway --- # Another general example showing nested dependency injection mixed with runtime provided variables: --- *Classes used in this example*: Class User { public $name; public $dependency; public function __construct($name, $someDependency1) { $this-&gt;name = $name; $this-&gt;dependency = $someDependency1; } public function test() { return $this-&gt;dependency-&gt;value . ' ' . $this-&gt;dependency-&gt;dependency-&gt;value; } } Class Dependency1 { public $value = 'Hello'; public $dependency; public function __construct($someDependency2) { $this-&gt;dependency = $someDependency2; } } Class Dependency2 { public $value = 'World'; } *Container Setup and Usage*: ////////////////////////////////////////// // Registering resources (setup) ////////////////////////////////////////// $container = new \Cora\Container(); $container-&gt;user = function($c, $name = 'Bob') { return new User($name, $c-&gt;dependency1); }; $container-&gt;dependency1 = function($c) { return new Dependency1($c-&gt;dependency2); }; $container-&gt;dependency2 = function($c) { return new Dependency2(); }; ////////////////////////////////////////// // Using the container. // Injection of the two dependencies handled for you. ////////////////////////////////////////// $user = $container-&gt;user('John'); echo $user-&gt;test(); // outputs "Hello World" echo $user-&gt;name; // outputs "John" There's a bunch more the library is capable of, but hopefully that snippet at least addresses the original topic. The powerful part about it is that unlike popular libraries like Pimple where you are locked into a $container['resourceName'] // OR $container-&gt;get('identifier') format, you can provide runtime input as necessary and have it affect the resource that gets returned to you using my $container-&gt;resourceName('optionalParam1', 'optionalParam2', ...) format. This can provide the same functionality as a factory, but without cluttering up your filesystem with unnecessary factory files for many use-cases.
Interesting... does PDO have some equivalent?
&gt; huh? What's the problem? The larger initial supporters of node have moved on to more stable backend technologies. Yes, there are still companies that run on node. Yes, there are quite a few of them. But, as I said "by the time they get up to speed", because let's be honest - if OP doesn't have much JS experience, it's going to be 2-3 years before they're ready for anything beyond entry-level, and by that time there will be far more node developers than jobs. Like I said. &gt; I earn almost 50% more since switching from PHP to Node and get hit up by recruiters daily for more That's nice dear. You don't realize it has more to do with your overall skillset than with node specifically. Believe me, it's not just "learn node and people will fall over to give you jobs". *THAT* is bad advice. &gt; JS isn't going anywhere. No one said it is. JS is a fine language to learn, and there's a lot you can do with it. But the question isn't "what do I like", the question is "what would do differently if you were starting over", and I would absolutely NOT start with JS *or* with PHP because both will reinforce bad coding habits and are restrictive in what languages you can easily move to. And I'm not sure how "learn a restrictive language that teaches you good coding habits and opens up many more opportunities" is bad advice. A Java or C-type developer will make more money for longer than a JS or PHP developer. Right now, in my city, companies are paying about 20% over market for good Java developers, which is roughly DOUBLE what I made doing PHP in the same city. But sure, learn node instead so you're limited on what you know, what you can do, and what your future offers. Have fun staying behind as the job pool dries up.
I'm looking at `shorthash` and I'm confused... Why would I use shorthash vs just sha256 and only using the first 64 bits? I've never heard of the SipHash algorithm, so my default mode is to not trust it. If the main goal of `shorthash` is a shorter, not `cryptographiicaly` secure generichash, why not use a more well known cipher?
Ah it's pseudorandom, interesting. How do you use a pseudorandom hash for cache lookup keys, and hash keys? You have to have use the same seed everytime?
Yes it is , many hosts using cpanel offer option between mysql and Postgre
I agree. There might be some benefit to an asset handler that can keep up with all of the fashionable JS build tools, but with the speed at which things are going in and out of fashion nowadays, I doubt that it will. You're likely to miss out on some edge-case configuration options too.
[removed]
[removed]
[removed]
[removed]
I wanted to introduce Chronos, and I feel that many people who might learn from this post are prolly using Carbon or Chronos in their projects via their framework (ex, Carbon bundles with Laravel) and so it would be a little more "real life" to them to see those used.
I have this [Quora answer](https://www.quora.com/Why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3/answer/Michael-Wolfe) bookmarked for sharing every time this topic comes up, it's that accurate an analogy.
I know this is probably blasphemous, but if you want asynchronous processing then use an asynchronous programming language (I.e. JavaScript on Node.js). If you're doing your front end in JavaScript anyway, then moving over to Node won't be a big deal. It's always about choosing the right tool for the job.
Wait, what? Is this recent? I haven't coded in five months
That unexpected complexity is a bummer though. Working with an API that won't let me control another session, only the current session created through posting out to create one. It led to a lot of unexpected complexity including creating a a really weird holding queue. 
That unexpected complexity is a bummer though. Working with an API that won't let me control another session, only the current session created through posting out to create one. It led to a lot of unexpected complexity including creating a a really weird holding queue. 
[removed]
[removed]
[removed]
[removed]
[removed]
Why I even learned how to count? That skill is almost useless!
Since RHEL7s release is when it really picked up. That was when pretty much all of the Linux distros dropped it from defaults and opted for MariaDB. You may not notice as the client tools are still called mysql-foo etc for backwards compatibility. Given the choice between Oracle and not Oracle, it's a no brainer for most.
That's the beauty of MySQL 8. [It's so intense, it skips over the other two](https://www.youtube.com/watch?v=0dZIutRz9hw)
[guzzle/promises](https://github.com/guzzle/promises) is a complete implementation of promises, like AMPHP and React.
I generally double my actual estimates. It's usually a good number once you allow for revisions, feature creap, and all the other usual bullshit that can and does happen.
##Salsa20: ChaCha variant In 2008, Bernstein published the closely related "ChaCha" family of ciphers, which aim to increase the diffusion per round while achieving the same or slightly better performance. The Aumasson et al. paper also attacks ChaCha, achieving one round fewer: for 256 bits ChaCha6 with complexity 2139 and ChaCha7 with complexity 2248. 128 bits ChaCha6 within 2107, but claims that the attack fails to break 128 bits ChaCha7. ChaCha replaces the basic Salsa20 round primitive R(a,b,c,k) b ⊕= (a ⊞ c) &lt;&lt;&lt; k; with the modified computation: b ⊞= c; a ⊕= b; a &lt;&lt;&lt;= k; The rotation amounts are also updated. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^] ^Downvote ^to ^remove ^| ^v0.2
Why don't you use some functions to separate the logic? Like one function to get the data from the xml and another one to store the data itself. I think it will be more readable and if you have to change one thing it will be easier to find it
&gt;I have this [Quora answer](https://www.quora.com/Why-are-software-development-task-estimations-regularly-off-by-a-factor-of-2-3/answer/Michael-Wolfe) bookmarked for sharing every time this topic comes up, it's that accurate an analogy. ...and bookmarked.
Not buying it, especially when you are estimating for yourself as the article states. If it looks unrealistic to responsibly estimate, then estimate what a proper discovery will take. Good software estimates are not only possible, but can often be pretty accurate. "Sometimes impossible" ? maybe if information is unavailable and proper discovery is not an option, but claiming good software estimates to be impossible is nonsense... a lot like that Quora analogy. If your job requires estimating travel time down the coast, and you don't know to consider the coastline twists, then you should reconsider your occupation.
Looking at the tests, I see a lot of cruft in your repository, while you only supply a bridge class with 3 tiny methods. Are you planning to support multiple database and storage platforms and is the cruft in preparation of that? You should consider defining the required PHP version in your package file as well.
Yes, I'm planning to support more type of databases in the following versions. But currently no plan for other storage platforms. I will update the composer.json for PHP version later. Thanks!
I think we could add at least possibility to configure the inspection: https://github.com/kalessil/phpinspectionsea/issues/354 //cc /u/meow247
Yes you can follow the docs that are pretty much straight forward. I often wrote on [Slim Rest API](https://www.cloudways.com/blog/twig-templates-in-slim/) and [Templating](https://www.cloudways.com/blog/simple-rest-api-with-slim-micro-framework/) 
It's not exactly what you're looking for but have you looked into if caching is feasible? As for why PHP is like this, there are ways to make PHP work like promises and event loops (like others have mentioned) but it is by design single-threaded and blocking. However, it is usually run with several threads to handle more than one request at a time. So while a single request can take 3 times longer because of the blocking calls, if you run 100 requests at the same time many of them will be handled at a time and your overall time to completion​ will be much more comparable to an asynchronous solution. Lastly, you can make asynchronous calls to the shell, so you can also explore that solution to add more threads to one request. Perhaps not ideal, but worth mentioning exploring with the length of db calls in question. Basically microservices.
At work (and I personally as well) we use Percona MySQL, which is based on Oracle MySQL. MariaDB seems to have a focus on "ooh shiny" over the focus on stability and performance that Percona has. They also seem to be headed off in their own direction with newer versions, which could mean that MariaDB is no longer a "drop-in replacement". Percona also has an excellent suite of tools and monitoring stuff, and while (most of) these work with both Oracle MySQL and MariaDB, they're always going to work that bit better with Percona MySQL. TBH I'd love to dive into Postgres, but I have a long list of other things to look at before I can put the time into that - and to get my knowledge up to the same level as I have for MySQL (which is probably when I'd actually be confident on putting it into production, especially for the main project I work on) is going to take a while.
At a guess I'd say he wasn't keen on having a class (abstract or not) only partially implementing an interface
Yes I understand how inheritance and abstract classes work. I was just trying to offer a suggestion as to why the PR was closed which is an entirely separate question from "will this work" or "does inheritance allow this"
You are welcome. :) I don't normally recommend the MS way of things but I think their ASP.NET MVC system has some wonderful ideas and concepts. Alas, CodeIgniter was a great tool in the beginning but it's just fallen behind the times. Maybe they will reconsider some of their patterns and rules in the next version... If the OP is familiar with CodeIngiter's way of doing things then I agree they should probably continue doing it that way for the moment. It is important them to ultimately make the switch to a better way of developing though! Hopefully this conversation will serve as a thought provoking read for others as well.
So if you don't have such an agreement you should just quit having backups?
The alternative is you could get an European-based VPS with a good amount of storage, and then rsync your backups across periodically. 
It's funny that you say that, but before the introduction of promises into the language specification, nothing in the JavaScript specification said it was async. It's all added by your browser or Node.
Fortunately, every ReactPHP library will work with the Amp event loop in Amp v2, which is going to be released within the next days, via http://amphp.org/react-adapter/.
It's great you built this, but **spatie/laravel-backup** does a TON more than this and uses flysystem, so it can be uploaded to various cloud providers. It's great to build things, but do extensive research on what do you want to build before you build it so that you are building something unique and not reinventing the wheel.
I think it is a great starting point. Good job. I might implement this on a personal project for statistics I am working on. Keep up the good work :+)
&gt; I've been wondering why PHP is fundamentally missing this kind of promise based execution. To make the comparison to JavaScript: JS is built around the so called "event loop". It's not part of the JS interpreter, but built into all browsers as part of the JS engine. This event loop is basically what the name says: a loop, listening for- and handling events. Promises are a wrapper around that event loop, enabling the programmer to easily reason about an asynchronous application. The difficult part is that code isn't executed right at the position you've written it. I'd highly recommend watching this ±30m video to understand the event loop concept a bit better: https://www.youtube.com/watch?v=8aGhZQkoFbQ . Moving on to PHP. PHP really can support that kind of asynchronous code, but it wasn't designed to write asynchronous code from its core, like JS. For example: ES6 supports Promises out of the box, which PHP does not. But the concept of promises can be easily written in PHP. A few examples were already mentioned in the comments below: - https://github.com/reactphp/promise - https://github.com/amphp/amp/tree/master/docs/promises - https://github.com/guzzle/promises Both AMP and react also offer an event loop implementation. (sidenote: "react" is short for "React PHP" here, which has nothing to do with the JS framework made by FaceBook). So now you have both the event loop and promises in PHP. But than what? You still need "things" you can do in an asynchronous way, things for the event loop to loop over (this is better explained in the video above). For that, there are a few options, built into PHP. You already mentioned pthreads, but there's also pcntl. Both are used on a fairly low level: the creation and management of processes and threads. Information can be found here: - http://php.net/manual/en/book.pthreads.php - http://php.net/manual/en/book.pcntl.php They are fairly complex subjects if you have no knowledge of operating systems, process management etc. But it's of course completely doable to learn; although I would recommend to first venture into the concepts of multi threading and multi processes, apart from PHP; before trying to wrap your head around the PHP implementation. The reason you see these messages about "not being able to use them into a web context" has more to do with the server PHP is run on, rather than PHP itself. ReactPHP for example can easily serve web requests in an asynchronous way, but you'd need to run Your PHP as the server, in contrast to letting Apache or nginx handle the requests. For the biggest part, PHP is about the quick, secure request &gt; response cycle. Each requests gets a new thread, executing the whole application for only that request. That's a very safe approach, because there's no chance of two requests sharing data, locking the same resources etc. But there is of course an obvious downside to always bootstrapping and destroying a PHP application for every single request: performance. So if you want to trade that security (and also ease of development) for a more performant approach, you could very well use PHP to do a lot more than just handle one request. But it's not that easy. You should also ask yourself if you really need that performance boost. Modern PHP, modern frameworks and server-setups are very fast, and can handle a lot of requests. So except for hobby projects and learning, I'd really think twice before using a whole other approach in production applications. 