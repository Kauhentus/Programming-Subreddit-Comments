&gt; The Symfony CMF project makes it easier for developers to add CMS functionality to applications built with the Symfony2 PHP framework. Awesome. 
"Interest in a talk on contributing to core PHP projects?" Start classes with topics including 1) Co-operation 2) Respect towards others 3) and a *will* to develop better software. ATM that's what php internals need ref: http://www.serverphorums.com/read.php?7,934285 http://www.serverphorums.com/read.php?7,927472 
This. PHP community is quick to crucify. It must be incredibly daunting to launch something expecting to be hated before given a chance.
I think your being harsh on us. I posted a legitimate issue. When I am installing something, and I don't have the correct dependencies, it needs to tell me everything I need, not just one at a time. I have even posted an issue on github. I am trying to help not hinder. I also pointed out I can't seen any content type system, which is a big issue for me, as content types are a pretty vital part of a CMS. If they don't want feedback, don't post it on reddit!
It has potential. But it markets itself different from what it is. It mentions about going back to basics on the website... yet content types are a basic element of a CMS. 
Unused code is *very* bad if left alone. It only serves to confuse, implies outdated practices (as usually it's been written and has not been changed for years) and if wrongfully removed, can be restored extremely easily with a CVS provided you push removal of whole methods/classes in a single dedicated commit. You completely misinterpreted what Joel was trying to say.
Until you've used it in any practical capacity, it's not fair to make that kind of judgement. Imagine the roles being reversed...
That's fair. "used it in any practical capacity" leads to a balanced opinion of it as a tool, to be used in certain situations. "I think it's bad because others think it's bad" is the mentality I am trying to warn against. It's not helpful. If you have balanced, reasonable objections then you're the kind of reasonable person I'm not addressing. :)
I think that depends on the CMS background you have. I don't consider content-types essential because I've not had to deal much with them. I hate to use WordPress as an example, but it's fairly popular (as CMSs go) and I don't think I've seen it much there. Certainly not as an essential aspect of use. I will concede that I am not speaking from a position of exceptional experience with CMSs.
Unused code is not dangerous just useless. Determining whether code is truly unused is complex given runtime calls. Again you are confusing easy to restore with safe to delete. You risk shipping regressions for no more reason than 'I couldn't understand the code'. For a new guy to come on a team, with no knowledge of the software and decide that just because a codebase is some arbitrary large number of lines some of it must be useless is just insanity.
Yes.
This thing is OSS and just stepped out from alpha to beta. If you have concerns or issues that you hope would be addressed before you use it, please file tickets, or submit pull requests. That would be more helpful instead of saying WTFs and OMGs and swinging your dick around.
In general, it's a bad idea to just assume that anything on the $_GET string can be used directly, regardless of where it comes from. You really shouldn't be looking for a way to accept possibly unknown values from a user-accessible input method. You should *always* know exactly what you're looking for and filter/validate it accordingly. Oh, and please for the love of all things security, don't use $_REQUEST :)
A few questions, if I may ... * Do all internals developers have beards ? * Will there be instructions on growing lucious beards ? * Also, will that Tony Ferrari guy be there ? :D
Relevant: - [Ben Ramsey's blog post](http://benramsey.com/blog/2013/07/contributing-to-php-core) - [Ben Ramsey's talk slides](https://speakerdeck.com/ramsey/contributing-to-core-my-journey-to-add-array-column-to-the-php-core-lone-star-php-2014)
Such turn of phrase. Have up arrow.
We were working on a JavaScript code and I was unable to find the getUsers function although it was working. I have asked my friend and he told me that he made it something like this "get + Users", I don't remember exactly. Is there something similar in PHP? Edit: By "I was unable to find it" I mean I was unable to find the location where the function was created.
It is. It is *assumed* that password fields will be obfuscated, so if someone happens to be standing next to you you wouldn't ask them to look away.
Boring! You just wasted 5 more minutes of your already wasted life. Unfortunate.
:( If I had any self respect I would've lost a bit there because of your mean nature, kind sir.
"get + Users" isn't a valid JavaScript function name, nor PHP. Both languages let you assemble a function name with string concatenation, but I'm not sure I can find something similar in PHP until you nail down exactly what it is in JavaScript you're trying to emulate.
What C64 users got into Pokemon? The time periods don't match up. 
OK, thank you. The page will only be getting input from an AutoIT script and a C program, both which I have the source of, is it still unsafe to use $_GET? Thank you very much, btw.
LMAO, brilliant!
Yup, that's basically all there is here. We can just put this in the sidebar and disable new posts.
inb4 downvotted. i agree pretty much tho
"Facades are the shit" is double, we'll have to deduct one point from your karmatrain
 if($me-&gt;canHaz()) $karma-&gt;nom()-&gt;nom(); You got a problem with braces, motherfucker?! ^^I ^^kid ^^but ^^seriously
Started as a CMS and is a CMS are different. You are right in how it got there. Still, people (developers like us) seem to do well with it, without the content types. That's my point.
What does this do that Laravel doesn't? Why would I use this instead?
I have a soft spot for CI. 
Very true. October may not be aiming to be the next Drupal. It looks like it's use case is not a tiered, multi-user type of CMS. More of a simple site engine. With that said, I do like the UI so far. I haven't looked at any of the code yet, but it does look pretty sleek.
I maintain an application that's more than a decade old and several hundred thousands lines of code - almost none of it has been tested in any automatic way ever. The application runs on an old PHP 5.1.6 server and as such we can't use PHPUnit very easily to test it. Most of the application is comprised of command line utilities with very little OOP. Writing actual unit tests for it is nearly impossible. Even using PHPUnit to write functional tests is difficult. So I spent an evening and wrote Throwback to test this thing. I think other developers that maintain legacy applications might find it useful. Check it out, what do you think?
Have you not learned that Laravel's facades are actually proxies?
&gt; Laravel is the OneTrueGod of frameworks. I know this is not going to go down very well at all, but I can understand why Laravel is regarded so highly. The framework literally panders to developers who don't know what they're doing. I spent a weekend researching it fully (I have to use it at work,) and my only conclusion is it is very weak overall. Great if you're an experienced dev and need to put a prototype up within a couple days, other than that I would never use it in a production environment.
Don't smart off, whippersnapper!
It's definitely a terrible idea for a new guy to do it, but when you're maintaining a codebase for years, removing isolated unused chunks of code helps to maintain sanity and not only speeds up development by not getting in the way, you no longer are distracted by deprecated functionality when browsing code (_what the hell does this method do?? why is it here? I can see an obvious bug here, should I fix it?_). You get what I'm saying.
Why?
Oops. Yes, that's what I meant. Thx. :-)
Laravel promotes very bad practices. If you start coding everything in Laravel you will quickly find yourself in a world far behind where you thought you were when you go for new job interviews. Yes, it is a great framework for rapid deployment, but rapid deployment is not always the goal, and it certainly should not be the goal of any project out of the prototype phase. If you have a production Laravel CRUD application you will find yourself writing the same code over and over, and your job will basically become copy pasting. 
not defending /r/php but your attitude is too damn high...
Laravel is the OneTrueGod of frameworks. [You're goddamn right.](http://i.imgur.com/iXOgo2A.jpg)
Yeah that was my first thought.
One of the things I mention in [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp), that came from Michael Feathers, is the importance of "characterization testing" on legacy apps. Essentially it's black-box testing of the legacy app *output* instead of its internal activities. When you make a change to otherwise untested code, you can at least see if the output is the same afterwards. Would you say Throwback is more for characterization testing, functional/integration testing, or unit testing?
What about this? $me-&gt;canHaz() &amp;&amp; $karma-&gt;nom()-&gt;nom();
This is more of an /r/lolphp post, almost. 
1. Store everything in UTC 2. Use [DateTime classes](http://php.net/datetime) not date() or strtotime() 3. ??? 4. Profit Example: $myTZ = new DateTimeZone("America/New_York"); $date = new DateTime("next Sunday", $myTZ); echo $date-&gt;format("Y-m-d H:i:s"); // get next sunday's date $date-&gt;modify("+2 months"); // add two months echo $date-&gt;format("Y-m-d H:i:s"); // echo the new date $date-&gt;setTimeZone(new DateTimeZone("UTC")); // convert to UTC echo $date-&gt;format("Y-m-d H:i:s"); // echo UTC time Shameless plug: The DateTime extension author wrote a whole [book on the subject](http://www.phparch.com/books/phparchitects-guide-to-date-and-time-programming/). 
that's hard to read, should be rewritten $me-&gt;canHaz() AND $karma-&gt;nom()-&gt;nom();
I use this: https://github.com/2072/PHP-Indenting-for-VIm It's okay.
Maybe its ok, but its OK to be paranoid and validate what you receive in $_GET is what you expect. That would help in the future if the input(s) suddenly changes and your PHP script starts throwing errors.
I usually stick to the Debian package for my php.vim syntax file so I don't have to worry about it too much. My [latest version](https://gitorious.org/jasonwoof/vim-syntax/blobs/master/php.vim) is from 2013 Aug 28 so it's pretty up to date and if I ever need anything in addition to that, I can have a custom syntax file in my config folder that extends it so it doesn't require a full rewrite. Which file are you using and what system do you use it on? What 5.5 features is it missing that you're wanting to have?
Possibly worth looking at [Carbon](https://github.com/briannesbitt/Carbon). It's a really nice library for working with dates and times.
I don't have the time to find code sources at the moment, but look at any Laravel app and you will see obese controllers and a mis-managed models directory.
I tend to use the repository pattern to control this particular problem. http://heera.it/laravel-repository-pattern
Yeah this is a basic thing in other more advanced frameworks, such as Symfony2.
I started coding last year. I had no idea how to go about it, so I installed a LAMP stack cause that's what the internet said. Then I learned Mysql and PHP cause that's in LAMP. Then I tried Drupal and Opencart and hated them. Then I heard the word "framework" and tried CakePHP, Zend, a few more I forget and finally found this "new and interesting" project called Laravel, and never needed to look back. A year later, I've moved on to clojure and other shit, but Laravel's concepts still guide me several times. I don't normally read this subreddit, so I was surprised that Laravel is so well regarded here it's being mocked! They must've been busy over the last year. 
Is this what you're looking for? https://github.com/StanAngeloff/php.vim
You're kidding, right? Who do you think all this Laravel worshiping is coming from, if not noobs? Those of use who have used at least another framework treat is as such: a framework. Not the second coming of Rails. 
Can someone explain to me why Facades are the shit, yo.
It's not a repository pattern if your entities are actually Active Record objects. Another term hijacked by the Laravel kindergarten group. 
*you bastard*
I had updated the issue. Did you get a chance to look?
From your definition, a combination of characterization testing and integration testing. You can use it to test the app output directly (exit codes for command line apps aren't supported yet) but you could also inject a database connection and check the database to ensure that the command actually did what it said it would. A simple example is that we might have a command named "import_products.php" in our codebase. Throwback can test that it fails when not given enough command line arguments, or when given a small sample data file, actually imports the data it says it does. Or fails if the file is corrupted. Lots of different options.
Please stop posting about Aura releases here...
Watch what the goal becomes after the first security audit. Depends on your motivation, your reason for coding in the first place. Some do it to make a buck, others do it becuase they love programming. If you love programming, Laravel makes your eyes bleed.
Specifically it was a response to this: &gt;If you ask a noob question here, you're just going to get downvoted. 75% of /r/php is noob questions/submissions, they aren't downvoted at all. In fact, whenever there's something remotely advanced asked, people don't respond because they can't. 
I've always felt Laravel is to 2nd gen PHP frameworks what CI was to 1st gen frameworks
&gt; Charge and encourage others to charge atleast 3x what they're worth, because fuck you that's why. If you can successfully charge 3x what you think you're worth, than you're worth 3x what think you're worth. #justsayin
But [other](http://www.reddit.com/r/PHP/comments/25kf9d/symfony_cmf_11_available_stable_release/) [release](http://www.reddit.com/r/PHP/comments/25mi1a/throwback_a_framework_for_testing_legacy_php/) [announcements](http://www.reddit.com/r/PHP/comments/25lw4v/octobercms_public_beta_is_now_live/) are okay?
Nice! My quick run-through of the README did not reveal examples; do you have links to any?
Someone asked about identifying unused code in a code base of 1mil lines. Many people responded plainly as 'phpstorm can do this'. Seeing it made me uneasy for some reason...
You should look into how PayPal is built. Do they work with a bank?
&amp;&amp; and AND ate not the same thing. It's not just a difference in readability.
Ah, reminds me of [this thread on GitHub](https://github.com/twbs/bootstrap/issues/3057). Good times!
It would be great of you can stop plugging the link to your crappy book and crappy framework every chance you get. I mean, take your marketing bullshit elsewhere. Everyone here is sick of it..
Hmm, I've never heard of PHPStorm before. After an quick look it does look like netbeans but quicker ( am i right? ). So why should I buy PHPStorm ( $90 ) instead of using netbeans / Sublime? 
That's what i'm using currently, and unfortunately WAY too many elements fall under the same syntax group, restricting my customization options.
It's only a difference of operator precedence in PHP.
We're currently using CI in our production app (working on rebuilding in Laravel) and I want to throw my grandmother into oncoming traffic.
Be better. 
[http://i.imgur.com/mXjL7a4.gif](http://i.imgur.com/mXjL7a4.gif)
Standardenplug for [Agavi](http://www.agavi.org)
&gt; The assertion system is much more modular (it's a separate library). Eventually the plan is to provide support for Counterpart in the core, but let users do their own assertions if they want. Does it shows diff's like phpunit does? I didn't get what you mean by 'support for Counterpart' in core. &gt;Test suites are more independent, they can have their own bootstrap files. The plan is to stick with this. No global test config, it's always up to the test suite. So how does it work, are each Test suites run by separate php processes? &gt; Test classes don't extend or implement anything, just use naming conventions. Why is this good? &gt; converts even unit test names into sentences. Not sure what the advantage here is. One need to be alerted of failed tests, even when there is no color support for the terminal. Right? Only reporting failures, as phpunit does, is better IMHO. 
Yeah, I am aware of that (used Doctinre for ages) ...tmy point is taht Repository pattern that OP argues , is not part of framweork per se, but ORM. You can have [Doctrine in Laravel](https://github.com/atrauzzi/laravel-doctrine) and have Repository pattern fom get go, or use it with Elqouent as /u/dont_man_me_pelase pointed out. Or use ORM abstraction and mix the two. I am not Laravel evangelist, but surley the mess OP is talkign about is coming from mediocore devs. Granted, Laravel allows you bad practices, but to be fair, php it self does that as well. 
You've just described why &gt;it's 2014 and all of these shopping cart solutions still suck terribly. It's because the clients are too cheap to pay reasonably for their ideal solution.
&gt; Does it shows diff's like phpunit does? Not yet. &gt; So how does it work, are each Test suites run by separate php processes? More like each as it's own configuration. Running them in separate processes is a good idea, however! &gt; Why is this good? It's not good or bad. Just different. &gt; Not sure what the advantage here is. One need to be alerted of failed tests, even when there is no color support for the terminal. Right? Only reporting failures, as phpunit does, is better IMHO. PHPUnit reports both success (with a `.`) and failures. Failures in demeanor show up as a read `Failed` word. The CLI looks pretty similar to what you see with JUnit + Apache Ant's test runner (which I liked and copied!). I would say the advantage is that it forces you to think about testing differently. `testSomeMethodName` is a terrible test name. It's not descriptive and it doesn't really tell the user what the test is really about. In a way, this shows my preference for [behavior-specific test names](http://christopherdavis.me/blog/improving-tests-one-name-at-a-time.html). 
Sadly only a very small number people tend to post about anything of depth, the rest are content to continue the circle jerk. 
&gt;Laravel is the OneTrueGod of frameworks. No. &gt;phpStorm is the only IDE No. &gt;Facades are the shit, yo. Yep, they're useful. &gt;CodeIgniter is a piece of shit Truth. &gt;Your (my) code sucks Often around here it actually does suck. There have been precious few times when I've been able to say "I got nothing, you did an amazing job". &gt;Everyone makes either 6 figures or minimum wage. No. &gt;You (me) have no fucking idea what you're talking about, go back to CodeAcademy. The PHP community at large tends to propagate ideas which are false or bad. Often these ideas are things that came from good programmers but were grossly misunderstood. There is a trend of parroting things without understanding them. &gt;Charge and encourage others to charge atleast 3x what they're worth, because fuck you that's why. Most of the people I see here aren't worth what they think they're worth, I agree. Some are though. That said, if you can charge more and the market will bear it...why not? &gt;Facades are amazing, yo. I feel like we've been here before.... &gt;Do you have time to talk about our lord and savior-Laravel? Yes, but only after you've made the appropriate sacrifices and burnt offerings.
Cool! PHPUnit is solid, but it's nice to see more new innovation in the field.
In my experience it depends of the country, but in France at least Symfony is all the rage (and that's fine by me).
I _know_ it's the preferred way to keep stuff outside of the webroot, but it's just not very practical, if you're providing and supporting an open source product to others. It's unfortunate, but a lot of people simply lack the write permissions and/or know-how how to do this. Add to that that you'd need something like assetic to dump the assets into the webroot, which undeniably makes the product harder to use and more complicated. Perhaps not for somebody like you, but you're probably more experienced with this than the average user is. By the way, do you know of _any_ relevant open source PHP project that puts the main files outside of the webroot? Wordpress, Drupal, Joomla, PHPBB, Magento, PyroCMS.. They all require you to put their files inside the webroot, as far as I know.
I think the main reason Symfony is so popular - in my opinion - because of TWIG.
Any good company won't care what frameworks you're proficient in, as long as you're a solid developer. You can pick up any framework if you have the proper skills.
That makes pretty good sense.
I spent a weekend playing with python. The next day I used "and" in php and whoops it turns out they're not the same thing. That was a really sucky bug to track down.
Thanks for posting here. I want to move away from our current CMS and am waiting for a Bolt release which I'm comfortable with selling to clients. Maybe this is the one.
&gt; read Failed word. red failed word? I was asking of the case when the terminal does not have support for colors..Even if the terminal has color, what if your failed test got scrolled past the passed tests that came after it? &gt;testSomeMethodName is a terrible test name. Naming methods is hard enough. But it is actually useful and improves readablity. But I don't think naming tests nicely is really worth the effort. If a test fails, one usually needs to check how the test failed. I mean, how the actual output differed from the expected one. Right? So not much use having nice descriptive names for tests. 
Good grief, it's the very first line in the file listing. Thanks for pointing out what should have been obvious. :-)
That's ridiculous. $50k could easily build a KILLER shopping cart and would need only 500 users at $100 a pop.
I'm testing it as we speak, but i'm curious what you guys think...
You are overlooking maintenance, support, etc. You offered to pay $10-20 bucks a year for updates. At your hypothetical 500 user base, this means they are earning $5,000-$10,000 per year to keep up with all major security issues... not even taking into account any support issues.
&gt; I was asking of the case when the terminal does not have support for colors It would still show `Failed` just with out color. BUT **you make a good point.** Needs some sort of summary at the tail end of the run. Thanks! And thanks for your questions -- this was the sort of feedback I was hoping for. &gt; So not much use having nice descriptive names for tests. Tests, in addition to being tests, are documentation for programmers. So in that sense it is useful. For what it's worth things like failed assertions do print out the actual value along with what was wrong about it.
You can currently move `/config` and `/database` out of webroot. (the latter is only relevant if you're using SQlite instead of Postgres or MySQL. It shouldn't be too hard to adapt Bolt to allow moving `/vendor` out as well. The `/files` and `/theme` folders contain assets that are needed for viewing the site. `/app` would need to be split into the parts that are purely code (`/app/src`) and parts that are needed for viewing the backend (`app/view/assets`, and the like). I'm not sure how much work this would be, but I'm sure it can't be done in an afternoon. :-)
so what framework do you use or recommend?
Nice! However I hate the use of public properties as Settings sometimes, I spent about 2 hours trying to locate the issue "Call to undefined method Illuminate\Database\Query\Builder::instance()", as a result I had misstyped "implement" as "implements" property in the class. Love to see how this expands.
I'm a picky anal bastard when it comes to my syntax highlighting :( Im sure it is fine to any normal, sane person.
It is beautifully done - price is not too bad. Only issue: you are amazon's bitch for rest of product life.
Fair enough. How much do you think a reasonable security/support/future enhancement team should cost? I suppose it really depends if you want to outsource or not.
phpStorm is not the only IDE, but it is the shit, yo
COTY. This needs to be upvoted to the top.
Well even 1 full time employee would make significantly more than the 5-10k. I would assume someone capable of making the security and future enhancement changes in the states would earn 35k+, a team of 4 might cost $140,000+, then a manager for them might be another 50-60k totaling $200,000+. Now, those enhancements and security updates come from somewhere, so now you need support people to deal with the customers directly who are reporting the issues... $25k+ I mean it gets expensive quick. This is why so many of these things are open source. ASPDotNetStorefront is a solution that is much more polished and has good support/updates... but is significantly more expensive. $800-5,000 up front cost just to get the software.
The only way I can think to do that would be with eval() but there are a few reasons to avoid eval(). However I would avoid that window[name]= pattern in general - you're defining (essentially) global symbols in order to call a function. Both JavaScript and PHP allow you to assign functions to variables and then pass those around. This is like the difference between using global variables and locally-scoped variable: minimizes disruptions from changes, reduces bugs and and improves reusability.
Aura is not great. It's weird how many posts there are for it on here.
Symfony2
PhpStorm is the reason I can still stand to work with PHP.
I'll tell you what I'm *not* looking for: current experience in a framework that still has PHP4 support. I'm looking at you, prehistoric Cake and CodeIgniter codebases! If you're still stuck using one of those, you're being limited as a developer. (Yes, I know that current versions of Cake and CI dropped PHP4 support, I'm talking about current projects still using *old* versions of the framework.)
I also work in SaaS / PaaS and I can confirm what he says. If your project takes multiple years of development with iterative release cycles you have time to learn from past mistakes. That helps a lot :)
For me, it's the speed and customization. For you, could be any number of features that match your needs. Or perhaps none. Glance through some of [Jetbrain's PHPStorm videos](https://www.youtube.com/results?search_query=phpstorm+jetbrains+tv) for topics of interest - odds are a few of them will make you say "Holy crap that will make things easier!" 
It's /r/php, what do you expect?
No, Unix timestamps can be problematic (before 1//1/1970 you have to use negative integers). If you're using MySQL store them as DATE or Datetime, see [this discussion on Stack Overflow](http://stackoverflow.com/questions/1116529/best-practice-for-storing-the-date-in-mysql-from-php)
I disagree. Laravel doesn't _force_ good practice sure. But I don't think it encourages bad ones either. Bloated controllers are architectural missteps made by those application developers, not Laravel as a whole. Part of the problem being that many think that all you should have is MVC. Rather than adding in your own business domain layer, using services, DI, etc. So they end up with bloated models. Or bloated controllers, because they have to put it _somewhere_.
Glad you got it solved, but man do I prefer the DateTime classes and its OO interface to dealing with `strtotime` all over the place.
Very nice! There are good examples for DatePeriod in the online docs.
You forgot to link to [PHP The Right Way](http://www.phptherightway.com/).
Our company looks for Zend. We use Magento which is based on the Zend framework. 
His name is Robert Paulson...
OK, I'll do that. Thanks much,I know very little about PHP best practices as I've never worked with it before...
Lithium is dead. 
&gt; Yeah, that's fair. What I realize in hindsight is that those things were software construction primitives, and for the benefits to be fully realized, you need higher-level abstractions that build on/use those primitives... if that makes sense. That makes perfect sense. I read some comment initially that knocked on the docs saying that the devs were trying to be too smart. This is why I feel a cookbook would have been very helpful - something that shows you how to unlock the cool features introduced by Lithium. Evangelize the primitives, in other words. &gt; One was started -- take a look and let me / the author know if you think it foots the bill. This actually looks very awesome. I look forward to reading it. &gt; (however, this is soon to change... check back in ~3 months). I look forward to seeing more, and am rooting for you guys. For me, Lithium has always had a "just right" feel to it - more than a micro framework, but you can adjust the "heaviness" through a robust library architecture. In addition, the cleanliness and PHP version requirements gave it a sense of dropping a lot of old fat and focusing on the future. Thanks for addressing this!
I must be the only one left still using vi for my IDE. Haters going to hate. Use what gets the job done. Specialization is for insects.
Browscap.org works fine for me (both the streaming link and the php_browscap.ini) - might be a firewall block? Alternatively, you can [build your own file](https://github.com/browscap/browscap) - the repository contains the data in a json file and builds it to an ini config.
I like you... wanna b friends? ಠ◡ಠ ^^^i'll ^^^code ^^^your ^^^regex ^^^and ^^^recursive ^^^functions ^^^if ^^^you ^^^want
I second the customization point. It was much easier to setup all my preferred key bindings in Storm than it was in ST2. Also, if you you find yourself jumping between IDE and terminal/CLI, Storm has it built in so that's pretty convenient. If you're still in school, I think they have a free license (I know they do for PyCharm from the same company). Settings can be imported/exported to their other products as well. In the end, it boils down to preference. 
Are those two unrelated thoughts?
I think it's also extremely important to show that you're aware of what libraries exist and that you can leverage other peoples libraries in your applications. 
Maybe I'm missing something, but what specific reasons are causing people in here to hate on Aura? I think /u/pmjones has made a great example of how to develop modular components using best practices and patterns.
See #1. All kidding aside, facades really kinda are the shit. Yo.
No, CodeIgniter makes me want to throw my grandmother into traffic.
Few months ago there would be Aura posts every day. People got a bit fed up.
alternative to ``isLocked()``: ``hasLock()``
Looks like he's moved the page to the root https://forge.laravel.com/
Thank you. The site is back online now.
Literally this guy \^
This isn't a help sub
""if(1==1){ echo ’Yes**’**, 1 is equal to 1’; }"" the problem is in the echo , after Yes, there shouldn't be a ' **working version** &lt;?php $name = "Alex"; $age = 21; if(strtolower ($age)=="alex") { if($age&gt;=21){ echo "You\’re over 21"; if(1==1){ echo "Yes’, 1 is equal to 1"; } } }else { echo "You\’re not Alex"; } ?&gt;
Don't take the approach to learning frameworks that companies like. Increase your skill, and pick for yourself what you like. Frameworks change; the best developers are the ones that can migrate from one to another with as little impact on current business operations as possible. 
Static is global. Doesnt matter that it uses ``__callStatic()`` internally to pull suff out of container - it is still global. https://github.com/phpspec/phpspec/issues/299#issuecomment-36681662
Preach it.
too late
Something as simple as this, i'd rather do it myself. Anything more complicated, i'd rather use puppet or ansible.
I kinda wish they would offer more options. Not everyone will be running on their same environment.
Well that's 20 minutes of life I wont get back; edit: semicolon
Phalcon ftw.
This post is so on point! I can't wait until Drupal 8 wipes the smug grin off all those Laravelists faces!
Are you using include_once() / require_once() with full paths to the file, or just relative. Always strive for the former as APC can get confused with the file you are talking about. This seems to be the case here being a redeclare error. Make use of the \_\_DIR\_\_ magic constant and dirname() to make this easier. &gt; Currently we're running eAccelerator but are planning to switch to APC as we upgrade due to vendor available packages. If you are going to the effort of that, might as well push for PHP 5.5 with OPCache - APC is pretty much dead in the water going forward, Zend OPCache was open sourced, added to PHP 5.5 and won that round nicely.
Surely... surely nobody still RUNS PHP4? Anywhere. Ever. I refuse to believe it
The code is inconsistent, and there are includes / requires everywhere :( This is a big old legacy app written by developers who aren't around too much anymore and was created back in the days before autoloaders were a big thing. Updating all the requires (including in the old version of ZF we're running) would be quite a challenge. &gt; If you are going to the effort of that, might as well push for PHP 5.5 with OPCache - APC is pretty much dead in the water going forward, Zend OPCache was open sourced, added to PHP 5.5 and won that round nicely. I wanted to do this as well however our infrastructure people wanted to stick with 5.4 because it's the vendor supplied and supported version (RHEL). We are considering zend cache as well. For some reason I thought APC was the one moved into core but apparently I'm wrong there...
/u/mnapoli I wonder if you don't write about a release how will people know about it ?
If anyone have not read, you can integrate Aura.Html with Plates.
Haters are more than contributors :) . But no issues. Learning is always a good thing.. Whether it is aura, symfony, laravel.... you name it.
I don't understand. I use MySQL, but I've been storing everything as datetime, inserting PHP dates in UTC.
i wish i was at Laracon to hear the keynote because I don't understand this. I feel like if anyone other than Taylor put this out people would say it's just a cash grab when there are open source projects like [puphpet](https://puphpet.com/) out. That said, more power to him if people will pay. Would really like some more specific info, like what "tuned for Laravel" means.
Depends on the project, but i usually tend to follow the symfony way of doing things....
yeah, i know. But people may (me included) like a different preset
agreed.
can u recoed mi regexpr? help plz `#^([a-z0-9+\-.]+):([/]{0,2}([a-z0-9\-._~%!\$&amp;'\(\)\*+,;=:]+@)?([\[\]a-z0-9\-._~%!\$&amp;'\(\)\*+,;=:]+(:[0-9]+)?))([a-z0-9\-._~%!\$&amp;'\(\)\*+,;=:@/]*)(\?[\?/a-z0-9\-._~%!\$&amp;'\(\)\*+,;=:@]+)?(\#[a-z0-9\-._~%!\$&amp;'\(\)\*+,;=:@/\?]+)?#i` ^(I'm kidding. I wrote this monstrosity years ago; I've never even used it in production code. It matches valid URIs, by the way.)
I'm sure some poor souls are. I can only hope that they know how dangerous it is to their site... and career. 
Because Hitler uses Laravel. You don't want to support Hitler, do you?
Writing your own in a mixture of C/C++ extensions to PHP itself, x86-64 assembly mixed with that, and PHP 3 syntax. For compatibility.
ಠ◡ಠ
They are usually beta testing a new version which is free for 30 days but then you upgrade to the new beta seamlessly. Anyways the [link](http://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Early+Access+Program) 
Sadly there are far too many shared hosts out there running php4
I'm going to third the customization. Coming from vim or sublime there's a plugin to map those key bindings so no trying to retrain those muscle memories. And I love the live templates, they have saved me so much time. 
This is very interesting to me, because I remember, at the time, that lithium was announced with a lot of fanfare. It sounded quite cool to me, even though I was a bit uncomfortable with the hype at the time. The fact that there's not a stable release yet, after all these years, can only mean that something has gone wrong along the way. Not to knock the current progress, or put you down or anything like that... I am very curious though what has happened... I imagine that when you started that you didn't have the expectation that you're still working towards a 1.0. Can you share a little bit about mistakes that were made? Would love to learn.
I mean, you do realize Taylor has to eat somehow, right? While I doubt I'll be using this over Puphpet anytime soon, this is actually a very neat product and it'll certainly help alleviate the stress of setting up increasingly complex PHP environments. I don't think your Taylor Otwell hate is warranted either, he's been nothing but great for Laravel.
I wanted to respond to this in anger at how someone could be so callous and assign malicious intentions to a person they don't know at all. But, I will just say it's quite hurtful to read things like these and they couldn't be further from the truth.
You guys are wrong! `FACADES are SERVICE LOCATION` https://twitter.com/taylorotwell/status/440958573510545409 :)
FTFY: [PHP The Right Way](http://www.laravel.com).
Well said. I wish more people understood this.
There's certainly a huge need for tools to make it easy for developers to use servers without needing to do the system administration themselves. And the PHP community is getting a lot of love with these nowadays. Now there's at least three: * [ServerPilot](https://serverpilot.io) &lt;-- my company * [PuPHPet](https://puphpet.com) &lt;-- /u/jtreminio * [Laravel Forge](https://forge.laravel.com/) &lt;-- /u/utotwel They each have different focuses and it will be interesting to see where each of these go and what other projects spring up. Some people appear to be wondering why you would want to use a service to manage your servers. It's true that many people could do it themselves. However, there are different ways people need to spend their time. And many people who aren't expert sysadmins feel it makes more sense to trust a service for configuring, securing, and monitoring their servers than to rely on themselves to do it.
What's wrong with `#^https?://facebook\.com/.+#` ?
Well I guess the problem isn’t just about what gets posted, but what people upvote, no ?
was your talk recorded? I'd love to watch and find out more of what forge is all about. The site is pretty sparse. From what i can tell it's a web interface to install software and manage services on your servers? 
That would be nice.
&gt;I must be the only one left still using vi for my IDE. I use gvim and I think there is quite a lot of vim users here. And really, I don't see the point of using something like phpstorm. Which ever language you use, you are ultimately editing code for most of the time. So use an editor that is THE BEST tool for editing text. Not the one that looks beautiful or the one with the most menu items. I mean, If you edit code and plan on doing so for a long time, learn and use Vim. There is no point in using anything else.
http://phalconphp.com/en/
I normally try to avoid such discussions, but this time I felt compelled to reply due to the level of ignorance. Having had the pleasure of knowing Taylor for many years now I've seen the amount of time and effort that he puts into all of his projects. His primary project, the framework is of course non-profit, and as a primary contributor he spends the majority of his time interacting with the community, trying to make their lives easier, and fixing issues. Taylor has put the same level of detail and love into Forge as he has in his other projects, and I feel it's well worth the subscription as a stand alone product. However, even if you feel differently, it's a fantastic method of funding his efforts to build the framework, and community, that I for one feel proud to be a member of.
symfony2. Laravel doesn't really have anything that catches my attention.
awesome, thanks. 
What about it? Only thing I see, if you're going for 'valid Facebook URLs', is that the '`.+`' at the end will match more than just valid characters. It will match characters not valid for URL encoding. Also, it won't match "facebook.com" by itself, since the '`+`' dictates there must be at least *one* character after the slash.
The joke is that his version is way too complicated and mine is way too narrow
You're absolutely right about the ignorance. I think there are still a ton of questions non-laracon attendees have about what exactly forge **is** and can do for you. For me, the site makes me have more questions than it answers. 
Tens of thousands of Laravel fanboys just came in their pants.
That said there are also conversations that keep happening because they keep needing to be had. You SHOULD be using composer. You SHOULD be using a framework. You SHOULD be keeping your PHP version up to date. You SHOULD be unit testing. You SHOULD NOT be using mysql_ extensions (or even, imo, mysqli_). You SHOULD NOT be using long slabs of include statements. You SHOULD NOT be combining your display code with your business logic. While PHP people keep derping, these conversations have to keep happening. 
It's neither. It seems to be a platform to facilitate rapid development using Laravel and other cloud based technologies. For a comparison, you could check out [AppFog](http://appfog.com/) which (I'm pretty sure) does something very similar.
It means some features are Laravel specific. For example, the automated configuration of Laravel queue workers, the running of Laravel's migrations, Laravel's environment variable file system, etc.
&gt; automated configuration of Laravel queue workers Is this something outside of php? &gt; Laravel's environment variable file system Can you please just briefly tell what that is? I assumed by 'tuned' you meant the server configuration is somehow tweaked to run laravel. Is that correct?
You can read about both of these things in the Laravel documentation. *Editing since original question has been edited* No, the actual server software installed is not really Laravel specific. What I mean by tuned for Laravel is some of the featuers in the Forge app are Laravel tuned, such as managing Laravel specific queue workers and environment files, etc.
after posting I glanced at the sideboard and saw that most help questions goto a different sub. Sorry folks - feel free to nuke if needed I've posted there.
Better: $me-&gt;canHaz() ? $karma-&gt;nom()-&gt;nom() : $fuck-&gt;you();
I ask myself the same question every few days when I undoubtedly see someone else shouting the praises of PHPStorm. I installed it and gave it a look, but I don't think I can be arsed getting used to it when I'm already comfy in Netbeans. The only thing of note seems to be that PHPStorm popups are lightning fast compared to Netbeans waiting half a second. That's really not a deal-breaker for me when half the day or more of my time is spent thinking about code, and not actually typing it. I can live with a brief pause while waiting for a hint to popup.
You do realize all frameworks are backed by money right? Sensio took $6.9 million in funding and Zend has a plethora of commercial endeavors. IMO Taylor is trying to go the more bootstrapped route where he wants to create great products/extensions that help developers. If you don't have a need for this then skip it. But I can guarantee this solves a lot of developer pain. 
I can't even process how people with your kind of attitude function in everyday human interactions.
I think the main reason is that they make unit testing easier because you can easily swap out the class with a mock class. That's pretty much it, no?
For those of us who might not be familiar with the "symfony way of doing things", care to elaborate?
and it puts a paywall in front of those developers.
queue up the many, upon MANY, of github comments showing how much of a dick you can be too.
queues are beanstalkd/ironmq/rabbitmq etc wrapped up in laravel, with a worker that runs off artisan. I *suppose* it could be used outside of laravel... the environment variable thingy... I think what this is, is when an environment is detected by laravel (using whatever means you decide to use to detect environments - get server name, look at an environment variable, whatever) it loads up config from a file called ".env.{environment}.php".. but I could be wrong.
Not the person you were replying to... but what is there to understand? You are already doing it correctly. If you didn't want / need the time part of your data you'd just store it as a DATE type in UTC, otherwise DATETIME in UTC like you are doing.
&gt; Laravel promotes very bad practices. I have no idea what this means specifically, but Laravel is all about encouraging SOLID principles, unit testing, avoiding globals, using facades, separation of view/model/controller logic, etc. There may be some valid criticisms of it, but saying it promotes bad practices isn't one of them. &gt; If you have a production Laravel CRUD application you will find yourself writing the same code over and over I'm not sure why you think that or what alternative you're comparing it to that allows better re-use of code, or whatever you're suggesting.
there is a difference between "wont need" and "useful". So many things in this world that you pay good money for are unnecessary - but they make your life easier. There is an air of open source entitlement going on here. Taylor builds a thing that may improve the quality of life for a number of developers who already live on razor thin margins and would love to reduce the costs of maintaining servers. He should be able to charge for it. What he isn't charging for is the core, or (so far) any laravel "addons". Laravel = free. Envoy = free. Cashier = free. I would love to of seen a "free for 1 server configuration" option on forge but I'm not going to go and make accusations like "its a cash grab", and "abusing trust for profit" because he decided not to....
Multi-vendor provisioner.
You mean *mine* is way too complicated? I'm the same guy who posted the big long one.
But how do you feel about having to pay for updates after a year? Sure, you won't feel it for that first year as you happily get updates, but then all of a sudden you can no-longer keep-up with the Jones' and are stuck with a legacy product. Personally that would really bother me. It's an axe hanging above your head the whole time, even after you pay for the upgrade license which just starts the timer off again.
For applications, I tend to use the following structure (using a theoretical e-commerce app as an example) : [framework directory] StoreApp/ Products/ (some specific context) ProductEntity.php ProductService.php Repos/ ProductRepository.php DbProductRepository Specs/ ProductInStockSpec.php ProductCanBeShippedSpec.php Foo/ Bar/ Customer/ Cart/ Order/ Support/ (framework-specific stuff and common classes) tests/ Packages (in this example, a fictional menu utility) : src/ MenuEntity.php MenuItem.php MenuItemFactory.php tests/ demo/
Ohhh CodeIgniter! I was thinking CI as in continuous integration and was wondering why that would make you want to throw anyone into anything.
I second this 
It's mostly a port of rails. I'm not a huge fan of rails either but it does provide a general architecture that encourages sensible separation of concerns. Compared to the ten year old classic php big ball of mud my colleagues work on, I think it is a godsend. Also, database migrations and eloquent is a decent active record implementation. Although, I do more than a little bare php as well. I like simple servers.
I couldn't figure out how to make it work with laravel in under fifteen minutes. I'll probably get back to trying it at some point. Jet rains makes good stuff mostly.
Or maybe because it's generally considered to be an excellent framework. Tons of people use sf2 without twig
the joke understand you must
I posted this on the same topic on /r/laravel: Whether Forge is going to be of value to you is going to depend on individual usage patterns. Essentially what this does is turn a cloud server, such as AWS or Digital Ocean into a PaaS, and facilitate deployment to specific hosting options. There's nothing inherently wrong with that. Myself, I like PaaS solutions. I've tried AWS and Digital Ocean, but I'm dumb as a box of hammers and had trouble with the "bare metal" vibe of AWS, also struggling with Digital Ocean's options. I want git based deployment, composer, stats, etc, easily available. I want to focus on dev, not devops. Personally, I make lots of small things. Being charged per application doesn't work for me. I need to be able to make a little thing quickly and get it online easily, and I'm not paying per month while I'm developing it. Pagodabox was a good solution, but started being awful. Fortrabbit was really great, but have practically ditched the free accounts, meaning a minimum of 10 euro per app which is not ok. I've lately been using Heroku, and have been really impressed with it. For some people (including me) Forge might lower the setup barrier-to-entry for things like AWS and provide a good way of going from dev to live. If it can match Heroku's CLI for elegance and efficiency then it may well be worth my $10 a month. Those who think this is a bad thing... don't think of this as some sort of premium Laravel feature. It's a side-project from Otwell, that (unsurprisingly) integrates well with Laravel. Surely he has the right to do that?
Yeah. I'm one of those latter people. There is only so much I can learn. I'm focused right now on front end. You have to draw the line somewhere and server admin is something I'm happy to consider "someone else's problem". I'm passable, and could probably get good. Or I can learn shit I actually enjoy.
Afaik, it's essentially something to turn something like AWS (bare metal and you're on your own) into something like Heroku, which is more user-friendly. I approve of the idea, though I'm not sure I'd necessarily use it instead of Heroku.
Call me crazy, but why not add composer, build a classmap, and then nuke all the includes? We recently did this with a 100k line legacy codebase (though we're also moving to psr4, so only using the classmap for 60%)
Ugh - RHEL, that and CentOS are always so far behind in PHP version land. Part of the reason I first picked Ubuntu years back when diving into Linux full time. &gt; I wanted to do this as well however our infrastructure people wanted to stick with 5.4 because it's the vendor supplied and supported version Don't get me wrong, APC is/was good - it just hasn't kept up the pace vs. OPCache - if you ensure all include()/requires() have absolute include paths, you are quite a way there right off the bat for any OPCache. 
zend, symfony, but hey... once you know one mvc framework, they don't really care if you know all the others, because you've shown that you can pick up a framework and wrap your head around it.
I think as many have pointed out, in general if they want a specific framework they'll ask for it. One thing that might be useful though is to check out what makes up a modern framework. A lot of frameworks are built on the same components so familiarizing yourself with commonly used pieces wont hurt your prospects.
An inhouse framework should never be used. Ever. Aside from quick deployment, two massive advantages of a framework are that a significant portion of your code comes battle tested out of the box, and new devs either know it already or have a wealth of documentation and community support to get up to speed.
You're looking to *human* interactions. That's your problem. Go to a zoo and watch the monkeys fling shit at everyone walking past. That will give you a better baseline.
In Belgium it is 1. Zend 2. Symfony 3. CodeIgnitor 
For your situation I'd make sure that the PHP application is running as UTC (using ini_set or php.ini). Be careful when using any date functions in MySQL like "NOW()" as, unless your server gets set to use UTC, the dates will not correspond to your application. My preference is always to set the server time to UTC, set the PHP application to UTC and store all dates as "datetime" in MySQL as UTC. From an application perspective, I let each user select their time zone using PHPs built in timezones and display the dates accordingly.
[$thisCodeIs-&gt;gaaaaaaaaaaaaay();](http://i0.kym-cdn.com/entries/icons/original/000/008/910/ultra-gay.png)
i just started using phalcon and seems preety powerful but is seems hard to learn
Well, luckily i got a lifetime license some how, but honestly, i wouldnt mind. As a developer, i make a decent sum of money. 
http://symfony.com/doc/current/quick_tour/the_architecture.html Probably the best example I can find. I try to keep code inside the `src` directory, and then the project itself depends on the code I'm writing. That link gives a few (imo) good practices though
AOP = Array Orientation Programming
 Based on the logic displayed in your comment it would probably be better if you did try and code with a bit of string... 
...and of course this will be down-voted into oblivion. Because it strikes a nerve with some. Which is the point. Down-vote-away!
I mainly use zend
I don't think you are fair. Yes there have been some Laravel dramas. Yes there are some people that trash it here on Reddit. But have a look at the link you gave: http://www.reddit.com/r/PHP/comments/25nte7/laravel_forge/ - the post (right now) has 17 upvotes and **only 2 downvotes** - every single stupid and trolling comment is downvoted to the point it's not visible anymore - those (unconstructive) negative comments have had constructive answers - there are loads of other constructive comments Yes there are stupid, uninformed and hurtful comments (towards Taylor for example), I'm not denying that. I'm just saying that the community is handling it correctly (up to now). So in short, haters be hating, but don't reduce the Reddit (or more global) community just to those trolls. Reddit offers them a place to speak, but the community moderates it relatively good. And also, remember that there are a lot of people not commenting (because it takes time effort, and "+1" or "great" comments are not really constructive) but happy with things: look at the votes.
I have downvoted your post for reasons I have explained here. Do not take this one -1 as "my feelings are hurt I hate you trololol".
Yes, it's not all bad. If you're a reasonable person, who thinks about what you say and tries to be constructive; I'm not talking to you. Unfortunately the worst part of the community is also the most vocal part of the community. Not having the time to give constructive criticism or stand against hurtful shit-talking is just as bad as supporting it.
Not at all. Reasonable discussion, and discerning thought, are the basis for my whole argument. You have those, so carry on. You won't be the only person to down-vote. You may be of a few that do so for good reason.
Fat Free Framework 
Laravel bashing on reddit? Where? Theres been a post about how much Laravel is overpraised just yesterday.
Not on this sub-reddit. You can't pretend that Laravel gets fair treatment, either. I have no problem with fanboys. That is until they start bashing some other framework/language/platform without reason or balance.
Why is using a signed int a problem? The problems with unix timestamps are mostly associated with the fact you really need a 64bit platform to have a date range that won't fall over due to your upper and lower limits. You might run into this problem anyways if you're manipulating the dates you get from the database using timestamps On the other hand a signed long should work and be portable to any database. Also it's a lot easier, in my mind, to understand storing and handling all your DateTimes as unix timestamps on UTC boxes.
&gt; Unfortunately the worst part of the community is also the most vocal part of the community. True. &gt; Not having the time to give constructive criticism or stand against hurtful shit-talking is just as bad as supporting it. And I think that's not the case. I see people downvoting and answering constructively the bad comments. I also see constructive (or a least "normal") discussions in the thread.
http://www.reddit.com/r/PHP/comments/25mdqi/10_things_i_learned_from_rphp/
Change it maybe?
I think silex is nice. 
You were the same guy who blasted people for criticising OctoberCMS. Whilst I agree the Laravel hate is ridiculous, you seem very thin skinned. The OctoberCMS was slated because it isn't that good. Simple. A lot of hype, but it under delivered. I don't understand the general slating of reddit. Yes it has it bad elements, but there is SO MUCH educational and good content on here: /r/todayilearned /r/worldnews /r/askscience IAMA etc etc. Don't let a few trolls cloud your judgement of all the good stuff on reddit (gonewild included of course :P) I do agree as the PHP community seems to think as it get's more advanced, it has the right to diss newbies. 
I am the same guy. I raged there too because a vocal minority were making unreasonable judgements against something their hadn't bothered to use. I'm not accusing the whole of Reddit. I'm pointing out a cancer, in the PHP community that needs to be cut out.
I think you misunderstand the concept of voting. Downvotes are to filter out poor content. I don't understand how this could be considered poor content, even if you do disagree with it. 
I was replying to mnapoli. I am saying that the downvote is not for content you disagree with, downvote is to stop poor content being voted down. So a poorly written piece should be downvoted e.g "plz help me mk a wbsite!!!" Where as your piece in my view should be up voted because it is well written and is a useful contribution to the subreddit. 
Oh, thanks. :)
This post talks about coding communities as if they're somehow different from the world that carries them. People are assholes everywhere you go. You just need to filter out the noise.
OK I'm taking it back then :)
Fair call. As someone who isn't doing this as a full-time job it's a bit of a different story. Actually, I just tried the trial for a bit more. I think I'm too comfy with the beans to change over. There's too much to re-learn and configure to get how I want things. For someone starting-out I'm sure it's the shit. I'd be happy if netbeans just looked a bit tidier and sharper in the UI like PHPStorm, and I might have to try and copy the Darcula colors.
just have a look at laravel/framework composer.json "php": "&gt;=5.4.0", "classpreloader/classpreloader": "~1.0", "d11wtq/boris": "~1.0", "ircmaxell/password-compat": "~1.0", "filp/whoops": "1.0.10", "jeremeamia/superclosure": "~1.0", "monolog/monolog": "~1.6", "nesbot/carbon": "~1.0", "patchwork/utf8": "1.1.*", "phpseclib/phpseclib": "0.3.*", "predis/predis": "0.8.*", "stack/builder": "~1.0", "swiftmailer/swiftmailer": "~5.1", "symfony/browser-kit": "2.5.*", "symfony/console": "2.5.*", "symfony/css-selector": "2.5.*", "symfony/debug": "2.5.*", "symfony/dom-crawler": "2.5.*", "symfony/finder": "2.5.*", "symfony/http-foundation": "2.5.*", "symfony/http-kernel": "2.5.*", "symfony/process": "2.5.*", "symfony/routing": "2.5.*", "symfony/security-core": "2.5.*", "symfony/translation": "2.5.*" There is so many symfony2 components inside :-)
I feel silly for wishing it was different.
What did I tell? &gt; "Can you please just briefly tell what that is?" I was asking about "Laravel's environment variable file system". Because that term did not make any sense to me. Do you think it was proper for you to respond by asking me to go read Laravel documentation? I am not trying to teach you good manners or anything. But please don't get fooled by all the people that support you in this kind of situations. Having people's support does not mean that you are right. Understand this, or you will end up just like that open cart guy. 
I like aura, and I think pmj is a knowledgeable guy with good intentions. But seriously, static e? Single letter method and variable references /names are awful practices to encourage. This reminds me of the bad old days of perl. Show stopper for me. 
Define "fair treatment". How should we treat a framework?
Your burying your head in the sand if you honestly feel Laravel doesn't get a lot a load of crap for very little reason.
As the reasonable, thinking people we claim to be. As a tool, to be used in the correct context. As the product of imperfect minds. As the selfless, open-source efforts of many. Are names like "OneTrueGod" used to describe ZF/Symfony? Are their leaders scorned for wanting to generate a sustainable income tangentially related to open-source projects? Are their proponents senselessly labelled fanboys? That's not fair treatment. 
What load of crap, Jesus? I've seen fair criticism of Laravel, yes. Is Laravel above criticism? It's frankly annoying that every time someone says something not entirely positive it gets labeled as "load of crap" by the 16 year old Laravel hall monitors.
Of course it isn't above criticism. However a lot of the criticism is unfounded and purely driven by people who don't back up their claims with decent arguments. 
Dude, I get that you don't like me. After all your are the guy who said that you have "tagged me as 'says stupid shit'", [right to my face](http://www.reddit.com/r/PHP/comments/1wnljd/should_moderators_remove_all_posts_pertaining_to/cf3rex0), without any sort of provocation, remember? So let me ask you pal, what right do you have to judge me? Where was your sense of humility when you told me that? Are you only bothered when some big shot like utowel gets insulted? May be you shows your ugly face only upon nobodies like me, good for you. But here is a piece of "HUMAN INTERACTION" that I have been saving for you from that day. FUCK YOU, YOU PIECE OF HYPOCRITIC SHIT.
The difference is, Chris, that no one gets personally offended every time ZF/S2 gets called something negative like monolithic, overarchitected, too complex etc. On the other hand, when someone says that the whole Facade thing in Laravel is promoting bad practices or that Blade is not the greatest templating engine etc. you have at least two people defending Laravel like it's part of their family or something. It's one thing to have a discussion about the benefits and faults of something (and this usually happens in the case of older frameworks) versus having constant overreactions from young, inexperienced developers. Laravel and the community surrounding it is on the right path to become the community around Rails: DHH is the god and everyone questioning his architectural decisions is a moron. 
Can you give some examples of this unfounded criticisms? I read this subreddit almost daily, I've yet to see this "whole load of crap" that constantly gets thrown at Laravel. 
I agree 100% with you that deification of management is dumb. When I said (elsewhere on this thread) that I have no problem with fanboys; don't think I meant that I support stupidity. I just don't see the harm in letting people get excited about something. I am against the culture of condescension, as it applies to people talking about Laravel. I'm not saying those are bad frameworks, or that Laravel needs some sort of special treatment. I just don't want to feel scared to post any Laravel-related thing here. I don't want others to feel like that. I don't want inexperienced guys to be put off by unreasonable group-think. 
Great timing! Two days after we shipped [Bolt 1.6.0](http://bolt.cm/newsitem/bolt-160-released) with a 'dev' version built in. ;-) (seriously though: congrats! Parsedown works like a charm)
http://www.reddit.com/r/PHP/comments/25mdqi/10_things_i_learned_from_rphp/ Take your pick
That's a criticism of /r/php actually. 
Indeed. I'm on here a lot and I say Laravel is held in high esteem among the majority of people in r/PHP. IMO, it is the claim of unfounded criticism against Laravel that is unfounded. 
Not to mention that the post points out how highly regarded the framework is. Religiously so.
&gt; I just don't want to feel scared to post any Laravel-related thing here. It's clear that you don't spend a whole lot of time around here. 
I have a tab to this sub-reddit permanently pinned, in Chrome. I read everything. Not sure how the opposite is clear...
I'm literally at Laracon and very busy and you think I basically owe you some kind of personal explanation of any Laravel feature you demand? What planet are you from? o_O
&gt; If someone merged /r/php with /r/laravel we wouldn't really notice. We disagree on this. I remember once being told to "take my Laravel shit, shove it up my ass, and fuck off". My fear of posting Laravel-based content on /r/php is very well motivated. Not worth fighting over though - you seem quite reasonable in response to the post. That's all I ask... :) 
With a lot of over the top criticism of Laravel. Read the content, not the title/sub title. 
I'm not saying /r/php doesn't have its fair share of bad apples. Just that the majority is not like that. We can agree to disagree I guess. 
[PitchBlade](https://github.com/PeeHaa/PitchBlade) or [Arya](https://github.com/rdlowrey/Arya)
Wow.
You can't understand why he is stressed? In the middle of the conference? Having just launched that stuff? I'm not going to argue that he's a saint. Nobody is. Doesn't mean we all have to devolve into apes and fling shit at the biggest target...
This is by far most beautiful laravel CMS.
Okay. My biggest problem was converting to Unix time for calculation. Timezones of the conversions would always be wacky. I'd always be an hour off somewhere. Do I need to convert to Unix timestamp for calculation in PHP or MySQL queries?
I too read everything that comes through here. If you think that Laravel is in poor esteem around here, you must have a cognitive bias. 
Thanks for the comments. I normally do that with a public folder and/or make sure server restrictions are working. But yeah, since this is public to whoever (if anyone) decides to try it makes a lot of sense to change that as you said; and actually will do it asap. Cheers
I put in a pull request to fix both the passwords and this issue, and they were merged in last night. Seems like they are very open to improvements!
That is good then. Good on you for doing the pull request. 
Tell me something. How am I to know that he is busy or in the middle of a conference. All I know is he posted a comment in reddit. When someone post something in reddit, is it not because he is willing to participate in a discussion, or is willing to respond to comments. If he is busy, he could just have responded later, or even, not responded at all. 
The conference is Laracon. He made Laravel. One would assume... ;)
That's why DateTime/DateTimeZone objects are a better way to handle it (i.e. let the DateTime extension deal with it). In line 6 of the example above, that's all it takes to convert from America/New_York to UTC time. UPDATE: Derick Rehans (Author of the DateTime extension) goes over all the pitfalls of storing dates in DBs, and even shows how relying on 'keep everything UTC' can still come back to bite you. See the original post [here](http://derickrethans.nl/storing-date-time-in-database.html) and reddit comments [here](http://www.reddit.com/r/programming/comments/tm8xl/storing_datetimes_in_databases/)
Read the Stack Overflow link, but basically you're making a whole lot more work for yourself and ignoring the built-in date handling capabilities of Myysql. Even if you migrate to another database, you'll want to use its native datetime types/functions too, so you're not gaining anything by sticking w/timestamps.
Well there was nothing in there that told me he was right there in the middle of that damn conference...As I told earlier, one would assume that someone posting here is willing to answer a query. One do not need to do some detective work to see if the said poster is currently busy before asking him something. Right?
I can't imagine you aren't following any of the hundreds of who have tweeted references to #laracon. Or that you haven't even heard of it via Reddit. You seem better informed than that.
Slim
What has Laravel to do with web server deployment? Looks like trying to start a whole new service under the same franchise for more popularity. Apart from the Laravel name whats good about this thing? We've seen all of that countless time before, and for free. Now if this is also a free service then I don't mind, if they make it into a paid thing, and then preach that it's the best way of working with laravel framework then its bullshit. **Coming up next: Laravel CDN, Laravel Domain Name service**
You raise many good points. Things we would all benefit from discussing. Another of the reasonable people the post is not addressing. I would like to talk about these things, but I fear I am under-qualified for many of them. Not ignoring you or calling you a hater. :)
Ok, I am a, very average programmer from India. I don't use twitter nor do I follow events such as this conference. I always wondered what is so big deal about a framework to have conferences about it..
http://youtrack.jetbrains.com/issue/WI-14172#comment=27-721248 Laravel support is coming for version 8 release.
an encoded space is %20 subjectID=Project%20Euler
My favorite framework is none. I prefer using standard components to build what I need for the job.
I downvoted the post because I hate this mentality. I happen to like assholes on the Internet. There is nowhere else in the world where you will get such brutally honest response. If you can't take the heat don't sit there whining about how you can't take the heat, get yourself out of the spotlight and get on with your life. Or even better **listen** to the responses you get and make a decision on whether they have some validity. Don't make the mistake of internalising the criticism. For example lets take this post in [/r/webdev](http://www.reddit.com/r/webdev/comments/25mulz/why_cant_i_find_a_web_development_job/). The first post is devestating, but you know what it's also 100% correct and personally if I were that person I would be more insulted by someone trying to sugar-coat it for me, as if I couldn't handle.
The original article is of poor content. He generalized the Reddit community. He says Laravel-bashing is pervasive on Reddit by linking to a post which expresses complaints to the contrary, that /r/PHP constantly praises Laravel as if it is the **only** solution to everything. The rest of the post reads like someone who's just started using the internet and is surprised to learn that trolls exist. And why? because there was *some* negativity towards Laravel recently which, in the author's mind, equates to pervasive bashing.
While I'm not one to support blatant negativity and unconstructive feedback, a lot of valid criticism against Laravel gets dismissed as nothing but "people being cunts". The way the Laravel core dev team (consisting of 1 person) Laravel handles said criticism could account for a lot of the negativity as well. I feel like I see more people blindly defending Laravel than blindly attacking it these days, but I guess it all depends on where you're looking.
Like this, ish: app/ : Files that tie components together to make the framework src/ : Project code Project/ Bundle/ : Bundles are tied to the framework and other bundles more ExampleBundle/ Controller/ DependencyInjection/ Entity/ Resources/ meta/ config/ doc/ translations/ views/ public/ Tests/ Component/ : Components should be libraries, i.e. framework agnostic Maths/ : Just an example Calculator.php web/ : Web root bundles/ : Public code from bundles app.php app_dev.php vendor/ : Composer stuff
I really appreciate how small, simple, and efficient this library is. Really useful for the in-house CMS i'm working on.
&gt; I've come out and mentioned technical and conceptual issues before (not generic things, but very specific points). What have I been greeted with? Not collaboration. Not discussion. But attack. I feel your pain here.
you could run it through [urlencode](http://us2.php.net/urlencode) function
Expected you in here much sooner. Busy day? :P
/u/recycledheart, believe me when I tell you that I totally get you here. Static methods are something I really do not like, and until now we have avoided them completely in [Aura](http://auraphp.com). But when you're staring at a PHP-based template file full of `&lt;?= $this-&gt;escape()-&gt;html($var) ?&gt;` you start to think there has to be something a little less verbose. Stating `use Aura\Html\Escaper as e` and then calling a one-letter static method a la `&lt;?= e::h($var) ?&gt;` seemed like a reasonable tradeoff in that very limited case (i.e., reducing verbosity when escaping). But again, I get you, and `$this-&gt;escape()-&gt;html()` and its brethren are still available as template helpers.
I thought you guys liked the idea of highly-coupled code?
Template helpers, in real-world use, are usually functional, not OO (look at Twig, Rails, and Laravel). In Aura's implementation, static is used to group together related functions without causing namespace conflicts. You're free to import "Escaper" as a longer name than "e" if that better helps you understand what "e" means in your template. Personally, I subscribe to the [Go philosophy](https://code.google.com/p/go-wiki/wiki/CodeReviewComments#Variable_Names): Variable names, especially local variables with limited scope, should be short rather than long. The further from its declaration that a name is used, the more descriptive the name must be.
[aura?](https://github.com/laravel/laravel/archive/master.zip)
Feel like you missed the joke there...
You're being overly dramatic. You don't have to *use* code to see if it is good or not - you have it right in front of you and as a programmer you can tell if it is good or not without having to execute it.
Sure. And as I've said (quite a few times actually), I have no problem with well-reasoned argument. Unless you want to appeal the point of this post with stupid ones, you're free to go about your business. :)
Hey, Thanks for the explanation.
I wanted to read all the comments before saying anything ;-) Meanwhile, see my Twitter DM to you, at your convenience.
Well said/+1/up arrow
My mistake. I see how out of place his terse response might then have seemed. :/
For a long time I taking part of developing web applications using this framework. And for a looong time it has not any english documentation and even github project page. Now it do. We have a really small community, basically consist only from few developers. But I pretty sure, it worse to look for others as well. Our main problem, that unlike from other frameworks we using xml\xslt for templating and there is not much developers, who are familiarized with this technologies. But in same place it helps us to have better separation of view and controller and BASICALLY there is no Controllers in Energine, which you use too in Symphony, CodeIgniter or xXxLARAVELxXx. I hope /r/php/ community would like to take a time and try to have fast look on it.
This is awesome. Very simple to use, very fast. Love it, thanks!
I use some Symfony components, some Zend, some stand-alone (like MonoLog). I've typically been using Silex as my front-controller/router, but I've also used other routers. Note that I'm not calling Silex a framework here. Because I'm not using its architecture component. I'm only using it as a glorified router (typically at least). Sometimes I've used Pimple, sometimes not. Depends on the task at hand. The reason I don't typically use full-stack frameworks is that they are either overkill, or simply not suited for my needs. Example: I've never really used Symfony's DI container system, because I feel it's needlessly complex for the vast majority of uses. Really, that's about it :-)
Taylor asked if it should be free or paid. I suggested he charged for it, and I'm glad he has. Successful open-source projects are _always_ backed by something. The money comes from _somewhere_. Would you prefer that Laravels only source of income is one company that happens to use it and lets him work on it on Fridays, or would you prefer Taylor got his own income and could do as he pleases? I'll take the latter. If he wants to make a CDN and call it Laravel CDN then whoopdeyfuckingdo, good for him. If people preach it's the "best" way of working with Laravel I'll tell them to shut u. If people say its a good way to work with Laravel then I'l definitely agree.
Unfortunately trolls keep upvoting threads like this that make /r/php look worse. http://www.reddit.com/r/PHP/comments/25mdqi/10_things_i_learned_from_rphp/ whi
[THIS](http://www.reddit.com/r/PHP/comments/25nte7/laravel_forge/chj92c3) is the link you should be tagging, conniving little bastard. 
ircmaxell, you're harping on about something else entirely - not that I don't agree with some of your points. The subject of this post is about ungrateful, entitled pricks who only want to benefit from OSS but do not want to contribute to it. Just because Taylor launched something that you need to pay for, they called it a scam and started attacking him. I get your beef with the guy, but the bottom line is that he HAS contributed massively to an OSS and at least deserves some respect for doing that. Attacking someone personally while hiding behind an anonymous username is cowardly. You're basically condoning that by coming here and saying "oh, but the Laravel community sucks as well". Two wrongs don't make a right. 
Solution: build something better. I'm just providing a solution I think is good for people. The market decides. I just provide. 
What...no that is not a solution. That's throwing up even more walls!
As you mentioned I got screamed at by fanboys who all wanted to know why I hate Laravel, ignoring the fact I've given multiple talks about how much I enjoy working with Laravel, one even literally called [Why I Love Laravel 4](https://www.youtube.com/watch?v=_ivIItoDCSI) If you say something positive about Laravel then its because you love it and its the one true framework. You say something bad about Laravel its because your an idiot/troll/CakePHP-lover who needs to be burnt at the steak. I've defended things Taylor has said or done multiple times and caught a lot of flak for it in the process, but if I say anything negative about his attitude or the framework then I also catch a bunch of flak in the process. WTF PEEPS? I know that haters gonna hate, but we need to be able to have a discussion without getting screamed at. I hope that changes soon, in /r/php and anywhere else in the Internets
In complete agreement. 
It seems your major problem with it is that you have to pay for it. If it's not useful for you as a paid service, then don't use it. I'm tempted to at least try it. 
I've personally never understood the problem with feeling my own product is the best. I mean that's pretty normal I think. If I felt there was something better I would use it. Paul Jones probably feels Aura provides the best decoupled components in PHP. I would think it was weird if he didn't honestly. I'm sure Fabien feels Symfony is the best full-stack framework option in PHP. That's NORMAL.
&gt; That's NORMAL. No it's not. I wouldn't be surprised if Fabien didn't think it was "the best" for certain use-cases. But I also know for a fact that he doesn't think it's the best for all use-cases. How do I know this? He built Silex. Why would someone build 2 frameworks (one full, and one micro) if one was the best option in PHP? Because there is no single framework that is right for all tasks. And many experienced developers understand that at a foundation level, as I'm sure with your experience you do as well. So to say, publicly, that yours is the best is either: 1. A Lie (as it's ignoring that different use-cases have different needs) 2. Marketing Speak. We don't need marketing in this community. We need truth. Why? Because of who you're targeting. Senior developers who've been around a long time can see through the marketing speak. They may like your framework and use it, but they understand that it's not the absolute best at all cases. But junior developers don't know that. They believe you when you say it's the best. They idolize you for it. And they learn that a single framework can truly be "the best". A lesson that will take years (if not decades) to unlearn. Paul and Fabien don't go around saying that they are better than everyone (even if they do believe it, I don't know). They don't go around saying abstractly that their frameworks are best. They may come out with a technical argument and point out a reason they think it's better. But it's exactly that. It's an opinion. And it's said as an opinion. It's not put out as a premise or a fact, as you do. Please. Show some humility. For your community, and for the PHP community. Play nice and be respectful. Realize that you're part of a bigger ecosystem. And join that ecosystem. Please don't become the next [DHH](http://codon.com/the-dhh-problem)...
OK, well that clarifies. Of course I don't believe Laravel is "always" the "best" option for "every" situation. I believe it is the best solution for "a lot" of situations, and I cater very specifically to those situations. Paul does a good job of catering to Aura's strength, evidenced by his work on his book, which Aura compliments nicely if you are gradually refactoring a Legacy app. A total re-write in Laravel is not the best solution in those situations. I've been on those kinds of never-ending, mass-rewrite, enterprise death marches. Perhaps we were talking past each other, because I do not feel Laravel is ALWAYS the answer to everything. I'm not trying to be like the next DHH.
has he not heard of 301 redirects? Quite unprofessional IMO to move a popular landing URL without even a redirect...
In PHP, "normal" is to hate yourself and everything you code. Please stop trying to be different.
Truly believing in what you've created is great! Drive, ambition, pride... those are all things that help make something even better (and help others trust in it too). There are plenty of ways of believing in your work while keeping a humble attitude, though. ;)
I commend you for all your hard work Taylor. I am surprised your still going to be honest, the amount of vitriol thrown at you. I would of given everyone the finger a long time ago and walked away. Good luck with your new project, I am interested in seeing how it develops. 
Hitler did nothing wrong.
I absolutely agree that the Laravel crowd can be defensive. I don't particularly like that either. But I'm not going to dismiss people with shitty attitudes as them just being trolls or not having their way with words. And yes, some nasty comments were deleted in that thread. &gt; Questioning (even anonymously) something is not trolling. It's a necessary fact of an open community. I agree. But the tone you use makes a huge difference - for both questions and answers. I'm more interested in understanding why you think a wall is being erected. There are plenty of frameworks out there and people are free to choose.
&gt; Of course I don't believe Laravel is "always" the "best" option for "every" situation. I believe it is the best solution for "a lot" of situations, and I cater very specifically to those situations. As I very much expected. You are talented and experienced. I never intended to indicate otherwise. But when you say (as you have many times) that your framework is "best" without qualifying it, a lot of people believe it. And a lot of people learn that there can be "one best". My suggestion: Stop referring to Laravel as "the best", but instead tout its strengths. Talk about the specific (or general) use-cases where it really shines. And talk about use-cases where it's not really well suited (The refactoring use-case is a great one). The reason I harp on this so hard, is that once you say it's no longer the best for all uses, it encourages others to look outside of the walls. It tears those walls down and encourages people to use other tools as well (languages, frameworks, etc). And by that, you get the boost in that people will better understand where your framework is really strong. And people will bring concepts from outside back in (improving your framework). And just as important, people will bring your concepts out to the rest of the community. Hence we all win. So my plea: encourage criticism. Encourage constructive discussion. Discourage defensiveness. Ignore the trolls, but realize that not everyone who appears to talk negative is taking a shot. Thanks for the consideration and discussion.
I followed the first two links in the article expecting to find a trove of Laravel bashing... but I didn't. The first about Laravel Forge only had a couple negative comment threads, with many of those comments deleted or buried by downvotes. There were a few comments questioning the value of the offering, but you'll get that in any new announcement. The second was the recent "10 things I learned from /r/php" post. Maybe I'm missing it, but I didn't see a lot of Laravel bashing there either. The OP there was actually voicing the opposite in some of the points: in their opinion /r/php had become a Laravel love-in. &gt; I realise Reddit isn’t the best example of open-minded, considerate collaboration. But then you need to ask the question; should there be popular platforms upon which people can be incomparable assholes? Reddit isn't a singular entity, it's made up of lots and lots of people. You get a good mix of personalities, from those that genuinely care and try to help to the disinterested and unimpressed and even some toxic trolls who seem to hate everything and everybody. &gt; I guess the internet has evolved into a place where speech is uncensored (though Reddit has a bad, albeit recent, record on that count). Again, Reddit is not a singular entity and issues with unnecassary censorship do come to light and are dealt with in time. I don't see how this applies to /r/php or Laravel, but maybe I have blinders on. The general opinion towards Laravel in this subreddit as I've seen it is positive. &gt; Why this kind of unreasonable hatred is so popular is the part that surprises me. Welcome to the Internet. Or really, any gathering of more than a few individuals to discuss any topic. &gt; Yes, Laravel includes many aspects which appeal to new developers. Is that a reason for hate? Should arrogant (read: unprofessional), experienced developers look down upon new developers, or projects which encourage their induction into programming? Of course not. There are a lot of reasons to dislike any project and/or its impact on a given community. That doesn't make those opinions invalid, even if they are somewhat arrogantly presented. Many criticisms to Laravel I've read have been very well thought out and articulated. Many others have not been. The community (and not just Laravel's) needs to learn to separate the chaff from the wheat and act upon those criticisms which are valid. I've not seen a lot of new developers being looked down upon here. I think the issue stems from new developers who are unwilling to learn development properly and use Laravel or any other framework as a crutch for bad habits. These are the types who tend to get lash back here. &gt; When did you suddenly submit pull requests to fix things, have them rejected (unreasonably), and thereby irrefutably gain the right to shit-talk the open, self-less and hard-working nature of others? I'm not sure what's being said here. If a valid pull request is unreasonably rejected and the discussion around it is toxic, then yes I think I have a right to voice my opinion on the matter. But really if the devs were truly open and selfless then these situations wouldn't crop up very often, would they? &gt; If you are not part of the solution, you are a problem. Be that in Ruby, Python, Java, whatever. Be that in WordPress, Drupal, Magento, whatever. Or, if I'm not part of the solution I'm an innocent bystander just wondering WTF I've walked in on. The author uses very strong language here but I'm still not entirely sure what problem I'm a part of. Is the problem that other people have opinions counter to those of other people? Or is it simply the way those differing opinions are conveyed? I'm hoping the latter. &gt; I am not above unreasonable hatred. I have my own problems. I am not and will never, in this life, be perfect. But what's the expectation being put forward for everybody else? Problem, solution, etc. &gt; But I can recognise when I am just being a dick. Sometimes that takes the help of others. Sometimes it takes removing myself to a safe distance so I can recognise my faults. Perhaps this is more about me talking to myself in the hopes that I avoid the poison seeping from the minds of otherwise capable developers. I'm sure lots of other people here have the same issue. Hell, I've posted a few emotionally charged comments which I later realized were incredibly dickish. I don't think it invalidates my opinions or feelings at the time though, it just means I should have been a bit more tactful in the delivery. But really, the self reflection here seems out of place and I'm a little confused. &gt; Perhaps this speaks to you, and you can take comfort in the fact that people will be horrible, for no reason, all the time. And there’s nothing you need to do to fix it. Because you’re not the problem. The author acknowledges that sometimes a troll is just a troll. However, I was under the impression that I was part of the problem if I wasn't taking a part in the solution. Maybe I'm being a dick here, but this is why strong language from earlier is dangerous. At this point I really don't understand the point of this article. &gt; Perhaps this speaks to you because you are the problem. And whether you fix yourself or not, your past actions and your current actions are hurting a community that can ill-afford it. These types of people don't care one bit if they're hurting a community. Going on to insult them is not going to be an effective means of bringing change. These issues exist in almost any community, and not just in the development world. The bigger issue is that some communities take up a martyr's pose and feed into the problem with a persecution complex. I'm not saying this is true of Laravel, but this isn't the first post I've seen in defense of the project from an attack I see little evidence of actually happening. People talk about drama in the PHP community, and lately every time it comes up I see Laravel in the middle of it in some form or fashion. Perhaps the community needs some more of that self-reflection and learn that haters gonna hate.
Thank you.
I'd rather take systems tuned for the needs of my application than a one size fits all. There is no comparison between a tuned cluster vs something like heroku except in the case of elastisity and even then, I'd advocate for a hybrid setup with a dedicated core and cloud servers that spin up on demand. Also take into account the type of support you will get in regards to things such as network connectivity, I'd much rather be speaking directly to a company like softlayer than talking about dynos or whatever abstraction these providers come up with. If you're prototyping or working on a new product, sure go and use these services, but I wouldn't take your company seriously if you had no one on staff who had any knowledge about how your application is actually running once you grew to a certain point. It sounds to me like you are arguing your point using the key term leverage. We as PHP developers leverage the libraries and frameworks of others to save us work and borrow their expertise. This is different because we could use our existing knowledge to learn these libraries if we chose too. Outsourcing something as key as your infrastructure with zero control is an amateur decision. There are plenty of successful companies running purely on cloud services, but this is different as they actually have the knowledge of what they are doing.
Yes...it doesn't matter where the content is coming from. If it's an internal service and the only requests are coming from your own sources, that reduces the risk but doesn't completely negate it. Good coding practices say that you should validate the information you're getting before ever using it. To do that, you have to know what you're getting and how to ensure it's correct. It's not "unsafe to use $_GET" in the strictest sense, it's just unsafe to use the data unfiltered.
&gt; I'm more interested in understanding why you think a wall is being erected. There are plenty of frameworks out there and people are free to choose. Freedom to choose is actually a wall. Why should I choose between them? Why can't/shouldn't I use multiple? Why shouldn't I go between them? leveraging the strengths where i can, and avoiding weaknesses where I can? Which is why I would never hire anyone that pitches themselves as a "Framework X Developer", even if we're internally using X. I don't want a framework developer. I want a developer who understands how to use frameworks (preferably more than one). Putting walls up, and encouraging people to ally around a single framework is bad IMHO. It's poison. The solution is to encourage cross-pollination. And that requires humility and encouraging cross-collaboration...
I'm going to agree with you on one of your points here...if it can be used with any framework out there and the only tuning that's been mentioned (that I've seen) is for the Laravel Queue workers, why limit it by putting it under the Laravel umbrella? If I were someone looking for an option for deploying my Zend Framework application quickly and easily and didn't know much about Laravel, I'm not sure I'd give Forge a second look. I'll be interested, come Monday, to see what the service is actually like.
The problem is I feel the guys behind Laravel are going to exploit the popularity of their framework for a chep money grab for a puphpet clone. Otherwise why not support other frameworks?
I don't necessarily disagree - but the progress we've made now is far better than even a couple of years ago. I would say things are getting better, not worse. Another point - the practice of calling yourself an "X Framework Developer" has been around for far longer than Laravel's existence. A person calling himself/herself a "Wordpress Developer" does exactly that and doesn't know much beyond Wordpress. And you know what, they're happy with it because they make a good livelihood out of it. I don't have a problem with that. Not EVERYONE needs to or has the ambition to be a well-rounded developer. It's not a fight you're going to win.
&gt; I'd rather take systems tuned for the needs of my application than a one size fits all. 6 months ago, I'd have agreed with you. But after seeing what I've seen in the past 3-4 months, I realize that I was completely wrong. And to be fair, I'm not talking about VMs running on clouds. I'm talking about systems like [AppEngine](https://cloud.google.com/products/app-engine/). Where even the VM is abstracted from you, giving you more scalability, reliability and performance.
Forge is different from Heroku or any other PaaS/SaaS because you don't buy storage, processors, memory, database and cache from Forge. Forge let you "Choose Your Cloud" server, installs everything (provision) and deploy your application into it. Imagine having a huge project hosted on Amazon and a side project on Digital Ocean and both of them professionally managed by the very same web interface. Are you sure you cannot see a value in something like that? If you choose to migrate your application from Heroku to AWS you'll have a lot of trouble to do that, right? Forge will probably transform that in a very simple task. Forge is not Laravel specific, it's PHP. It was made by the Laravel creator, so it has knowledge about the Laravel Framework and it will go a little bit far if your application is Laravel, maybe not much, but enough to make our lives even easier. If you like using provisioners, like Ansible, Pupet, Chef, Berkshelf or Saltstak, and you already have everything you need from them, you may not need Forge at all, but, still, how easy is to keep everything configured and updated even using one of those apps? I don't like Vagrant and I'm an Ansible lover, so I wrote this https://github.com/antonioribeiro/dev-box. It really helps me keep some sanity, all my local and remote boxes are managed with it, but I can tell you that managing all of them is still painful. So if I can have something that will do what Ansible does for me, which knows how to provision and deploy in many different cloud servers and also helps me manage domains, ssl, queues, databases, caches, etc., all of this from a single control panel, all of this unlimited?, gosh, **I would probably pay a lot more than just $10 for it**.
&gt; It's not a fight you're going to win. If we don't fight that fight, everyone will lose. I'd rather not win the fight, but win a few battles and help a few people along the way, than admit defeat and help nobody. After all, you don't need to help everyone in the world to make it a better place. You only need to help one person. If you can help 2, that's awesome. If 100, even better.
I know what you are talking about but you're only giving anecdotal evidence but then again so am I. There is a cold hard truth, services like app engine will not compete with bare metal servers that have been architected properly (that is essentially what app engine is doing and then reselling to you). Take any service that you run such as MySQL, it will perform better on a cluster of servers with RAID and SSD drives with dedicated cores and ram than it will on any of these services. After all, as you said, they are just an abstraction and that abstraction costs you performance. There is a bell curve in that, getting started is definitely better on these services but at a certain level when you become a "decent-sized" application. Creating your own setup will be cheaper, more performant and more secure with knowledgable personel.
Good luck (the proper kind, not the Taken version).
Props to you man ...
This is completely outside of the scope of /r/php. Ask in #centos on Freenode, they'll point you in the right direction.
Hmmm ... summary: developers expect to be paid for their time but they don't want to pay for other developers time. 
&gt; a power full toolkit for web-application development using XML/XSLT transformations. Yeah, I'm gonna pass.
It's also rarely true. Assuming you are looking at enterprise level jobs, not design studios, most "good" companies, will as for either Zend or Symfony. Usually Zend. Both frameworks promote good practice and standards, and are well supported.
I mainly work with ZF2, obviously. Second choices would be Symfony2 or Silex.
If you really like to point to aura, don't point the link to a laravel zip. If you hate aura, I am interested to hear what are the things you are not loving, or is it something you loved is not there. Interested to hear. For the people who don't know http://auraphp.com/
According to the Forge website, you can use it with any PHP framework.
CI is at best Braindead... It could only make success in a community with an absurd proportion of ignorant programmers...
Looks like it's down at the moment, and if I'm not mistaken, it looks like the Silex whoops page :)
I did some small apps recently with Slim and some Aura components. Worked great!
Yolo framework http://yolophp.com
Kinda obvious... But i'll stick with puphpet for my presets. Lot more useful at the moment
If you are going to use PHP to generate HTML which in itself is a bad idea Why not just use DomDocument and then your only dependancy is PHP itself ? Or if you must make your own class wrap DomDocument don't just create strings of HTML yourself
The first thing's I noticed were no namespacing, and no PSR-0/4. What were the reasonings behind this? Also why XSLT? XSLT is dead and is an extremely poor templating layer at that.
Look at his username.
&gt; which in itself is a bad idea It's not. What is a bad idea is throwing out things like this without thought for context. However, your mention of DOMDocument is spot on. There's no reason *not* to use it--this is a perfect case for it.
That one is tricky because arguably it falls outside the scope of a simple lock as you must maintain some kind of state outside the locking. There is one solution which is to simply use a lock id that relates to a specific event e.g. a daily import could use a lock key of date('Y-m-d') and just never release it. That way an import could only happen once in a day. 
Sure he did. He used Laravel.
PIP
Apart from asking you why didn't you use DomDocument I will ask you why would you make "type" property in Element class public when you are going to need it in constructor while creating an element. Say you created an element H1 you do not want it to be accidentally converted into h2, so, IMHO, type should be private to the class.
Is Symphony a good framework? I'm using Symfony here, but I'm looking for a better framework...
It sounds like the document root of your server is at projectroot/ when it should be set to projectroot/public/. Try updating that, restarting apache, and seeing if that works.
It would work like [Stash](https://github.com/tedivm/Stash), or like the new [Caching PSR](https://github.com/Crell/fig-standards/blob/Cache/proposed/cache.md) being developed.
Just left the office, will try that from home. What I did was go to wamp/www on the cli and then ran 'laravel new projectname' then I tried to go to http://localhost/proectname/ and just got a standard directory list that apache provides, instead of the default route. Does that sound like what you described? Or should I just build a virtual host with the public folder as the document root?
http://www.sitepoint.com/best-php-frameworks-2014/
The application should work correctly if you go to http://localhost/projectname/public/, so if you're fine with using that URL you shouldn't need to change anything.
Gotcha, I was following an install guide that used the virtual host but never mentioned it apparently. Makes sense now!
You can setup a virtual host but that's not mandatory. Typically, http://localhost/projectname/public will launch your application. Also, artisan has a 'serve' command. 'php artisan serve' will make your application live at http://localhost:8000 (You can of course use another port to your liking)
Don't do that. Forget Unix times exist at all. Using unix times are for people who also don't sanitize their database input and output, and other bad php practices that have long-since been put behind us. Read your UTC datetime out of the DB into some var. Use that value when creating a datetime php object. If you need to shift to a different timezone then after you have created your datetime object you use the setTimezone function to pass it a DateTimezone value for the timezone you need to shift into. e.g. $dbdt = ...some UTC MySQL db value you just retrieved... $mydate = new DateTime($dbdt, new DateTimezone('UTC'); $mytimezone = new DateTimezone('Arctic Circle/North Pole'); $mydate-&gt;setTimezone($mytimezone); now, the slightly cleaner way is to do away with some of that redundant shit, but it doesn't make much difference in the end... $dbdt = ...some UTC MySQL db value you just retrieved... $mydate = new DateTime($dbdt); // &lt;- new datetimes are by default UTC anyway so you don't need to specify this $mydate-&gt;setTimezone(new DateTimezone('Arctic Circle/North Pole)); // &lt;- you don't have to pass a timezone var, you can just create one directly inside the setTimezone function edit: had a stupid typo above I needed to correct If for some reason you have a date and time that BEGINS in a timezone that isn't UTC, then the only difference you need to make is when creating a DateTime object you must pass it the timezone you need to start from. $mydate = new DateTime("now", new DateTimezone('Arctic Circle/North Pole')); then you can translate the current time at the north pole into some other timezone. If you need to adjust the Datetime time values you can use the setTime function to pass hour/minute/second values, but the timezone stays the same. let's say you wanted to make 2 datetimes that represented a range for the whole of today. You'd create a datetime object with the timezone you needed it for. You'd call the setTime(0,0,0) on the first datetime and (23,59,59) on the second datetime. If you wanted to know the time in some other timezone you'd create a datetime object in the starting timezone then call setTimezone and pass it a Timezone object representing the timezone you wanted to know about. tl;dr use DateTime objects, creating the object with your starting timezone as part of the creation params and then shift it around from there. Once you have a DateTime object created with a certain timezone all changes to the timezone from then onwards will translate the date and time values around accordingly.
Click the link in the top-right for the "4.2 (Beta)" version of the docs.
Makes sense. I suppose someone with knowledge of the system could make a request manually. Thank you for pointing this out.
Laravel is [faster](http://systemsarchitect.net/performance-benchmark-of-popular-php-frameworks/)
Anyone know how to add syntax highlightning to it?
&gt; This is not your company's problem. They just want sites. They don't know or care about all of these issues. You need to make them care. It is the company's problem, but they are unwilling to pay for it. OP needs to find a new job.
Mmmmm steak. 
Something that i learned from /r/php, must of it users are noobs, including myself.
Who cares at this point? I am sure that Laravel's developers doesn't , and noobs that doesn't know what Facades are neither. :|
I actualy use Vim + eclim for php and java development, also the youcompleteme and the command-t plugin realy help to mitigate the pain at the time of development. I am about learning how to use Ctags in order to give it more push and see how it improve my workflow.
The sad thing is that version 7 is actualy very slow on Linux.
/u/gearvOsh yes I notice. But just want to tell him and to know why the hate for aura :) .
i was being a nitpick more than anything, and honestly I think it's because I am so used to you making design choices that I automatically agree with, that the 2-bit var threw me a curve ball. I'll just use 'esc' instead of 'e'. short sweet and obvious to me. No harm no foul, and I appreciate the reply. 
I am completely agree with all your points.
What are you talking about? I see more POSTS about how great laravel is than COMMENTS that make critiques of it in this sub-reddit. 
I don't know why you are negative in votes... Made me chuckle :D
&gt; The fact that there's not a stable release yet, after all these years, can only mean that something has gone wrong along the way. Hahaha. In a nutshell, I'm a perfectionist. Honestly, in terms of stability, we've been 1.0 for a long, long time. The core is thoroughly and rigorously unit-tested, and even in the times and places where we've broken BC, the changes were always clearly communicated in a form that could be searched/replaced easily. As far as why a 1.0 hasn't been officially released, there were some features I'd committed to myself that I wanted to implement for it that we'd just never got around to. And, of course, there's always the documentation issue. :-)
/me nods again We've all got our PTSD triggers to deal with /u/recycledheart . ;-) Tell you what: would you feel we covered all our bases if we pointed out, in the docs, that these options were available ... - `e::h($var)` - `$this-&gt;escape()-&gt;html($var)` - `$esc = $this-&gt;escape()-&gt;html(); $esc($var);` ... ? (And yes, seriously, all of those are supported right now, just not documented.)
Performace given php framework is out of my concern, since they are the slowest ones taking all other languages in context.
Agree, frameworks are mostly constructed to appeal a large base of situation and problem for the masses, including any for my projects respective needs, end up in a bloated kitchen sink that i REALY don't want to clean later. In some situations is better just to use your own build with some small yet powerful and stable libraries of you choice designed for the problem that you are trying to solve or the job that you need to get done. You end up with more ease in development, better performance, no bloat, and code that is easy to change later. Ofcourse, mostly this apply to people that know what they are doing, i am not againts using a framework is you realy don't.
No-- you can always set it up on any server and seamlessly just migrate your product over, it's basically a standard postgres setup (yes, it is a little different but it's totally compatible-- it's only difference is that Amazon doesn't allow you to login as "postgres" and instead creates a "sub admin" user that doesn't have certain features. As far as I know you cannot create additional tablespaces, and you cannot install modules that amazon doesn't support. So basically, you get a couple of more features by moving away from Amazon, but they require a lot more manual work.
 echo json_encode('València', JSON_UNESCAPED_UNICODE);
Been using it for a while, it's pretty nice.
hmmm, gives me this error on that line: Warning: json_encode() expects parameter 2 to be long, string given my first parameter is an array, but I don't think that should matter as it is looking for a long as the second parameter. Am I doing something wrong?
Then it's time to update to 5.4. This does work, [example here](http://codepad.viper-7.com/gkveDe).
I'm on shared hosting, I'll see if this is possible.. 
yeah I have used this once. I really needed to modify records as there were coming out an in. It will get you running up real fast, but probably in the long run it most likely not the way go as it is quite a pain to modify. So I would suggest for a consistent and simple code base, don't use it. But as Carlson_001 said, it does work as advertised. 
JSON_UNESCAPED_UNICODE was added in 5.4.0. PHP is being "helpful" in converting an unknown constant to a string. 
json_decode has no issues with the \u00e8 you are getting. It's valid json. 
I just updated and it works thanks so much!
Symfony 2
That's what Fork is for!
&gt; JSON array, I end up with a string like this: Val\u00e8ncia Why is this a problem? Is the client not conformant?
&gt; The reason I speak out against it is that I feel it's a poisonous community. They preach isolationism. You're not a PHP developer, you're a Laravel developer. I can't begin to express how dangerous that is. But there are deeper poisons than that. I'd say calling yourself a "PHP developer" instead of just being "a developer who uses PHP" is nearly as bad. Strongly coupling yourself to any single technology (or narrow range of them) is a horrible idea. 
...and there's mattaulamer, doing what he does best right under him. I'd like to be able to say I'm shocked, but really I'm not.
&gt;I've personally never understood the problem with feeling my own product is the best The key difference here is Fabien is working with a lot of different groups which have made **significant** contributions back to the php community itself. These contributions which you so quickly brush to the side have terraformed the PHP landscape for the better in countless ways. He encourages reasonable discourse, he doesn't try to make people think his shit always smells like roses, and he *most certainly* does not try to push symphony as the end-all solution for all problems.
Thanks for the explanation, that sounds like a reasonable cross-platform default. &gt;This works fine for a few hundred or even a few thousand pages, but it doesn't scale well beyond that. Are there any existing adaptors for Solr/Bolt integration? From what I've read Bolt does seem like it could be a perfect fit for what I'm looking for, I'll give it an install and try and build something in it.
I understand what this blog post is trying to point out, but the writer of the blog should consider proofreading his/her post or have someone proofread it. Also there's some information in there which is simply incorrect. 
&gt; Avoid using $_GET: &gt; There is a huge security risk if you pass data and quires via URL. Its not possible to ditch but whenever you can avoid using $_GET. wat, is that a joke?
I do. I think it's a good lesson too, for anyone who might be new to matters of object/variable scope, to see how it affects implementation and to understand that there is some flexibility there. I think new users take what's given to them and generally assume that these things are canonical, when in actuality they're implementation details, or style choices, not hard and fast rules. It also demonstrates nicely what's possible when you design a fluent interface, and implement method chaining. 
Holy fuck this this this a thousand times. 
You're all about being a disposable cog in the machine then, and you'll likely never understand why you should almost always use an in house framework. In house framework and road-tested components are not mutually exclusive terms. What do you think a generic framework comes from in the first place? Open your eyes and put down the ORM. Your statement is the definition of 'throwing the baby out with the bath water'. You've missed the lesson entirely. You may have worked with some lousy in house toolsets before, but this has misinformed you about what the end goal is. 
And just yesterday I sat thinking, when will the laravel backlash begin? I guess its now. KILL YOUR IDOLS. 
You did it wrong. Laravel is for minor (extremely small / freelance / prototype) projects, Symfony2 is for larger (production) projects.
welcome to /r/laravel if you want to insult laravel, please not here, this is /r/laravel get ready to be downvoted to oblivion !
This is /r/php
The main downside of Laravel is that it is very easy to write code that will need a lot of refactoring when your application grows bigger than the usual "todo list tutorial app". You need the discipline to not use the so called "Facades" in places where they don't belong, for example. Other than that, Laravel is still pretty good. I use it in a huge project and so far it has never failed me. I had some hiccups, though... I lost a week of refactoring when the scope of the project changed from "small app" to "enterprise behemoth". Another downside, I found out, are packages. They are awesome to start quick, but when the complexity of your application grows bigger than foreseen, you are stuck with third party code that can be closely intangled with your code (for example when you have to inherit some fonctionality). Count another week of refactoring to get rid of Ardent or Confide when you realize you need more control over your authentification and validation classes. I never used Symfony so I cannot compare. I'd say Laravel is pretty good for enterprise dev if you know what you're doing.
People keep asking me this question. I'm not much of a blogger but I'm tempted to write a piece explaining why Laravel shouldn't be used in a production world. Watch this space.
It's pretty sad that you cannot say anything bad about laravel in r/php in any context. I don't like his wording about laravel vs symfony but what he says is true, symfony excels for large projects and DDD and far for more suitable to laravel for this case. But this isn't relevent to OP.
Absolutely. We're all software developers or software engineers who happen to use PHP at the moment. 
php frameworks suck because php sucks !
That's the correct encoding, you should not need to change it. The JSON standard just encodes accents and other characters like that to increase compatibility.
&gt; You did it wrong So you suggest Symfony for bigger projects, that's great. For many years I did a lot of really shitty side projects duct-taped together for the moment. They turned out, much to my surprise, to be commercially viable and being used for years by customers. I eventually realized that I needed to do better. That's why I turned to Symfony. Starting small just to learn but with bigger things in mind. I think I'll stay with Symfony then. Thanks for the input.
Thanks for your reply. The project we're going to build is rather big, not so much in terms of concurrent users as in terms of data traffic. I take it then that for a big project it doesn't make much difference if we use Laravel or Symfony - that is, I might as well just stay with Symfony.
Fantastic library. I like how you've gone beyond "You should just use this" and actually provided benchmarks, tests and proved that it *is* better. Will definitely look into using this for my current projects.
Use get_object_vars() to get all of the object's variables in an array. Then you can access it. 
 $key = '/statuses/user_timeline'; $object-&gt;{$key} You should probably reconsider using `stdClass`
No need for $key: $object-&gt;{'/statuses/user_timeline'} The OP had the right idea in this third example, just the wrong syntax. 
By the way, about the all table should have ID thing... if you use MySQL with InnoDB, it's a good thing. In MySQL, every table should have an ID. Inserts and updates are slower when you don't.. even if you have the proper indices. It bummed me out when I discovered it, but that's just how it is. http://dev.mysql.com/doc/refman/5.5/en/optimizing-primary-keys.html http://www.mysqlperformanceblog.com/2013/10/18/innodb-scalability-issues-tables-without-primary-keys/ PGSQL not affected.
/u/pmjones: Thinking about it a little more, and without diving too much into your current code, why couldn't helpers be OO? &lt;?php $e = new Aura\Html\Escaper; ?&gt; &lt;html&gt; ... &lt;div&gt;&lt;?= $e-&gt;h($html) ?&gt;&lt;/div&gt; vs &lt;?php use Aura\Html\Escaper as e; ?&gt; &lt;html&gt; ... &lt;div&gt;&lt;?= e::h($html) ?&gt;&lt;/div&gt;
When I can decide (which I mostly can) I use postgres and avoid mysql. But that's good to know.
Dear JuicyORiley, What are you seeking in knowing PHP? From my experience, I have never actually "learned" PHP. I have just piddled around, although my experience has been more direct with the language. I have modified Wordpress plugins, I have used in a database course to make web interfaces in college (usually starting with some pre-made code and making it fit my purposes), and I have used in various ways on web pages I have made. I probably cannot do much from scratch, but I have not felt bad about putting it on resumes, despite not having the same degree of familiarity as languages I use for major projects. Have you done any other programming? I think what you are trying to achieve and how soon can tell a lot. If you want to have a greater degree of familiarity with PHP, just use it more and get some more practice before you start advertising your skill set. What you are doing is a good start in the right direction. Most coding I have done has begun with just playing around in a language. I wish you all the best in your PHP experiences. Warmly, friendlyletterwriter
That is helpful, and so are you, thanks!
I don't speak the language, just develop their projects. 
There is no right or wrong choice. You make the choice according to the situation. It sounds like Laravel has been very suitable for your site seen as you have made good progress. You will pick up PHP principles whilst using frameworks but you will pick up different things from different frameworks. Some parts of PHP you may never come across within or outside a framework. Most companies will require you to know the language itself with frameworks being a bonus. It's always best to read up on the language and keep up to date with it so you feel confident in any scenario and then you'll also know what's going on behind the scenes in frameworks.
&gt; and if i was given 'proper' PHP work i'd just fall flat on my face? Probably. It's kind of like how a lot of people toss around knowing jQuery but having no real experience with plain'ol Javascript. jQuery does a lot of abstracting and hand-holding. When shit hits the fan, they will be screwed. My other answer would be: it depends. Do you have other experience with programming, or is the 2-3 weeks of learning PHP all you have? If you're already experienced in another language, then it's just a matter of learning PHP-specific stuff. General programming theory still applies. In any case, you should start a for-fun project with no framework or CMS. Now that you how Laravel handles stuff, try to implement it yourself. You'll come up with all sorts of difficult problems very quickly, and learn a lot about how the underlying framework works. Once you're finished, compare your solution to frameworks like Laravel, Symfony2, Zend, etc. In my opinion, starting out with a framework is bad for learning. It makes it harder to understand what the language is doing versus what the framework is doing.
Hmm, not really sure what you want us to tell you. Do you know design patterns? Do you know good object oriented principles? Do you know the difference between imperative, functional, and object oriented programming? If so, then you'd probably be able to pick up these concepts pretty fast in PHP, or any other language really. Let's say this app you have goes live. It has absolutely terrible performance when it gets hit hard. Do you know where to start looking at performance improvements? What happens if you start getting a lot of complaints about random exception messages or PHP fatal errors? Do you have the logging in place to figure out the root of the errors? Someone's account gets hijacked using a cross-site forgery attack. Do you know the origin of this attack and how to fix it? There's a lot more to being a good developer than just knowing the language (although it does help a lot in certain circumstances). I'd say a well-rounded developer who really knows the consequences of their actions has a better chance at a job than someone with specific domain-knowledge, but can't look at the full picture. &gt; Am i right to feel like i'm cheating and if i was given 'proper' PHP work i'd just fall flat on my face? If you can't answer some of those questions above, then I would wager yes. Especially in large, complex applications which don't always follow the basic CRUD-style. Edit: I guess it also depends on how you define 'proper' PHP work. If we're talking about staying in Laravel projects, if you learned Laravel pretty extensibly then yeah, you'd be fine. But don't count on a lot of Laravel specific things to be common knowledge in other languages or frameworks.
Because old and slow.
Uh, yeah. Array casting worked OK.
I hate to be a downer but there's not much structure to it. Everything exists in one file, there's not a namespace and some of the methods do too much and need to be refactored. The `lines()` method is about 100 lines. It's a good starting point though and I do like the amount of whitespace you used, the whitespace makes it easier to read IMO.
You should expect to fall flat on you face given the amount of practice you've had. It also sounds like you chose to make a simple website and used a framework to do it. If you want to learn more PHP and less Laravel you might want to try rebuilding your website with your own MVC framework. Or even just rebuild your website procedurally so you can get some practice with PHP. Maybe do more difficult tasks. Try using a relational database if you haven't already, try multiple file uploads, try authentication against LDAP or AD, try creating a shopping cart, try creating a REST API, the topics can go on and on. A simple website is just that, a simple website so you can only learn so much by building one.
I've heard the "you're not a PHP developer, you're a Laravel developer" thing before. As a matter of fact, I've heard this same exact argument used consistently for years about other communities. It appears that it's a method for attacking people from a point of superior morality. But, it feels like double-speak. I hear the same sort of exclusion and moral positioning that is being espoused. If you genuinely want to be inclusive, then this sort of behavior is counter-productive. I've been discussing this sort of thing with many people in PHP who are "less visible" and it certainly appears to many of us that this type of behavior is becoming more common. Can you blame people for wanting to be members of smaller, friendlier communities? Communities are good things. They give people a chance to be helpful, make connections, and grow alongside others. One person might find that they are better able to contribute in (for example) the Laravel community than they would be without it. I personally know many people who feel thankful for the community and its inclusiveness. Just because someone says that a wall is erected doesn't mean that it is. It's easy to over-simplify someone's message and turn it into an example of something that you personally are on a crusade against. But, perhaps it's too reactionary and too self-serving. It is my opinion as someone who has been deep in the Laravel community since the beginning that it's VERY open to other people. If the advice is "there are groups of people who troll, get past it" then please accept that some times when someone says something that doesn't sound good to you, perhaps there's a contextual barrier and maybe they're actually still decent people. I wonder if the greater PHP community will be able to get past smaller communities having a good time and being good friends.
I think if this is your first jump into a programming language then starting with a framework isn't always the best solution. That said it's still PHP. Whilst you are writing it within the confines of someone else's framework there is still plenty to learn and pick up. A suggestion is also to not just focus on what you're trying to build, look at what is around in the community and see what they are up to, it can teach you an inspire you to learn things and follow different paths. E.G. https://laracasts.com/ is a great site for not only learning laravel specific stuff there are also a range of general programming principles that can re-inforce your knowledge. A good example would be the series on the solid principles. Yes they can apply to laravel but they can also apply to general PHP. If you still feel like a fraud you can always step back and start going through php tutorials that don't use frameworks. Good luck!
Let's face it, the website you made in 2-3 weeks is probably nowhere near as good and feature complete as WoWhead is. It might look so at first, but there probably are a lot of listtle things missing. Also, how will your website behave when visited by 100, 1000 people at the same time? Most probably there are a lot of choke points the aren't obvious after working with it for 2-3 weeks. Yes, using Laravel lets you make simple, or even more complex app pretty fast, but it's not always perfect. 
I've been actually reading on the DateTime classes. I may be doing some code upgrades again in the near future.
You just need more experience/practice/exposure, in 12 months you'll be dreaming in your language. Take the time to put together common websites and programming patterns. The PHP and Laravel documentation should be fully familiar to you. Eventually no part of the language or its use cases will be unfamiliar and you'll know so much more about the world you don't know but should learn JS and its frameworks, CSS and LESS, Bootstrap, NodeJS and WebSockets, Grunt/Composer/NPM, Linux and its distros, MySQL/Postgres/Percona RDBMS's, MongoDB/Redis NoSQL's, graphicsmagick/ffmpeg for images/video, Apache/NGINX for web serving, REGEX, SQL syntax, sharding/clustering/scaling/optimizing everything you've learned, Polymer/Web Components, HTML5/ECMA6 and other emerging standards, computer science and cryptography basics. If you're doing it right you should be feeling like you know less and less about more and more.
hahahahahaha wut It took me less than a week to understand Laravel 4 in alpha when there was no documentation and features missing. Did you try being better?
After only a few weeks your knowledge should be pretty tiny... Even when you learn the basics of PHP there is so much more to learn, like how to structure applications, how to grow applications, how to properly test applications, etc etc. I've been doing web development for 15 years and sometimes I still feel like a fraud sometimes, it's not uncommon. Heck it's even a [well known phenomenon](http://en.wikipedia.org/wiki/Impostor_syndrome). Now what you really need to watch out for is when you start feeling like you know it all. With software development, the more you learn the more you should realize how much you don't know. If you start feeling like you really know it all, that's a sign that you need to expand your circles a bit and discover people and things you don't know about and keep pushing to grown and learn. [Here's a nice article to read too](http://jangosteve.com/post/380926251/no-one-knows-what-theyre-doing).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Impostor syndrome**](https://en.wikipedia.org/wiki/Impostor%20syndrome): [](#sfw) --- &gt;The __impostor syndrome__, sometimes called __impostor phenomenon__ or __fraud syndrome__, is a psychological phenomenon in which people are unable to [internalize](https://en.wikipedia.org/wiki/Internalize) their accomplishments. Despite external evidence of their competence, those with the syndrome remain convinced that they are frauds and do not deserve the success they have achieved. Proof of success is dismissed as luck, timing, or as a result of deceiving others into thinking they are more [intelligent](https://en.wikipedia.org/wiki/Intelligent) and competent than they believe themselves to be. &gt; --- ^Interesting: [^Dunning–Kruger ^effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect) ^| [^List ^of ^impostors](https://en.wikipedia.org/wiki/List_of_impostors) ^| [^Elizabeth ^Harrin](https://en.wikipedia.org/wiki/Elizabeth_Harrin) ^| [^Dan ^Nainan](https://en.wikipedia.org/wiki/Dan_Nainan) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chkfep0) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chkfep0)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
What you're saying is that knowing Laravel is not knowing PHP. Well you're right. Try writing something in PHP without the use of a framework if you want to better your understanding of PHP without a framework. 
The theory is that the composer.lock file is as good as a complete snapshot of the /vendor folder. So if you version your composer.lock file, it is as good as versioning your entire vendor folder. Running composer update on production server is pretty much forbidden. I use something like this. 1. Run composer update (giving the package name preferably) in your local machine, (preferably in a VM and after a --dry-run to review the changes that are going to be made) and manually verify the changes in the lock file. 2. Then commit the lock file and push it to production, where you can run composer install. I hope you have seen [this discussion](http://www.reddit.com/r/PHP/comments/1ygk20/composer_downloading_random_code_is_not_a/). 
To add to your rant of sorts: Everyone seems to think it is okay to use dev-master versions in required packages since the general practice is to commit the lock file.
I don't know if I like you or not. But it sure is interesting to read.
Don't listen to that guy, probably has never touched Laravel and has no idea what he is talking about. Symfony has its place but there is very few situations where it will be the solution over Laravel. Either framework you are writing the code, it is your own code that dictates if the application can handle a big project.. not the frameworks.
Yep - that's why he runs `composer update` on local during development, and `composer install` (which will read the lock file if present) on production. All the same, I think personally I would run `composer install` on a staging server rather than production, run tests, and then use rsync to deploy to production from there. Composer is too reliant on the sources being up (I'm looking at you, github), and I can't risk that when the client wants their site up that some third party server being down will block my progress. For that matter, I often use rsync to deploy the entire site - not just the vendor folder - but depending on your application structure this might not work for you.
web developer here with 10 years experience. I always say laravel feels like a cheat. For me, this is a great thing because it saves so much time. For you, if you really want to learn "proper" PHP. Dive into laravel to find out WHY it works so well. Try and recreate your own framework(just for fun, don't use it for anything real). You'll learn more, and it sounds like you "get" programming, so it really shouldn't be that hard.
The real question is, do you like using 3rd party code? The answer is yes, to some extent, because you don't write your app in assembly. But just *how much* code are you going to install / include / require before you start ""controlling"" the stack? And once you have decided to use 3rd party libraries, where are you getting them from? Ignoring everything below the PHP level (web server, os, kernel, etc.), Composer is a pretty great dependency manager. If you like to use a significant amount of 3rd party code, and that code is available via Composer, then it's a great tool. PECL / PEAR have been around a *lot* longer and are a *lot* more stable and also *really suck* in terms of configuration and usage - but they are definitely still viable dependency management options. Specifically regarding deployment - I do frequently use the "git push... ssh ... git pull" method of deployment, but I really don't like it regardless of composer. I don't want to be dependent on a git remote being up to deploy my code. But since the remotes are so rarely down, and it's really easy to do it, I do typically use this method (especially for non-critical deploys). If I want to know, confidently *know* that I can deploy some code any time I like, I use good old-fashioned rsync. I know. Neckbeardy, right? But as I said in my reply to /u/SurveySaysFuckYou, I don't use composer on production. I use rsync from my staging server. So if I'm not rsyncing the whole damn application, I'm at least rsyncing the `vendor` directory. I trust Composer as a _dependency manager_, not as a _deployment tool_. Regarding version control and Composer, I definitely prefer that composer dependencies *not* go into my repository. There's a simple reason for that: it's not my code and I do not maintain it. I maintain the dependencies, and the only code I need to commit to do so is the composer.lock file. If I ever need to know what changed in my dependency stack, that file will be my starting place. Bear in mind that all the dependencies managed by composer are themselves version controlled repositories - at least if you're sticking to the stuff provided by packagist. If you need to know what changed between vX and vY of some dependency, you can look that up using the vendor's repository - it'll be better anyway because they'll likely provide you with a read me, a change log, and all the commit messages between the two revisions. That's way better than you just committing one giant mess of "all the code that changed in my `vendor` directory" - unless you're intimately familiar with all the code in all your dependencies, that commit is going to be _meaningless_. My philosophy is that I want all the commits in my repository to be *my* (or my team's) code. That will keep it cleaner, and when the dependencies change the composer.lock file will make that obvious.
I agree with the rsync from a staging/ci server. GitHub can go down, you can overspill your API limit, and there's always network errors that can happen. Also helpful when your .git folder gets a bit too big :)
Wait wait wait a sec. You started learning PHP *3 weeks ago*? Dude, you do *not* know PHP. It takes a lot longer than that to really learn a language. On the other hand, it definitely isn't cheating for you to use a tool to accomplish your task. If you can do something that would normally take months in a few weeks, you may not have learned as much, but you got the thing done, right? You should be honest with yourself about your skill. Just because you can make something nice doesn't mean you've attained a high level of understanding, especially when you have good tools -- a good tool makes it so that you don't *need* a high level of understanding to do things. On the other hand, you *can* say that you know "a little" PHP. I don't know what the rest of your programming background looks like, but "a little" of a language could be enough for some things. But most importantly, 2-3 weeks is nowhere near enough, and this means that you should not stop studying and working to improve your skill. Branch out into other frameworks, maybe, or write using bare-bones PHP, or whatever you need to do, but don't give up! Trust your instincts!
"Laravel is basically WordPress" I'd probably start by examining that thought :)
What part are you stuck on? The general idea of MVC\* or something else? Laracasts has a really good introduction to Laravel that might help: http://laracasts.com :-) Laravel is pretty much the same as all other PHP frameworks, if you understand one you should understand them all, so you could start by learning something with better documentation and a more established community (for example symfony) then move over to Laravel (if that's what you want to learn). This book is aimed at Laravel beginners: https://leanpub.com/codebright
Yes of course, you're supposed to write everything from scratch! And don't ever use PDO for your databases, only mysql_*! Okay, seriously, if you ever feel that you're cheating in programming - you should feel great about it, it means you just used something properly and avoided unneeded work, you saved someone money and your time. I'm not talking about stealing someone code and selling it like its yours though, but i'm sure you understand that. 
Not sure really. I've done OK with codeigniter, and zend (inside and outside of magento), but laravel didn't instantly click. That said, I haven't spent long on it, and have bought an ebook from packt which I'm sure will get me over the hill, when I get time to read it.
&gt;you'll likely never understand why you should almost always use an in house framework I certainly won't if nobody explains why. You haven't said a single meaningful thing. In fact you've just made coherent discussion even harder by conflating toolset, component, and framework. 
You are a "color-by-numbers" artist - nothing wrong with that - just don't go looking for a job painting murals. And yes, you would fall flat on your face with Laravel. If you want to be a programmer learn PHP first and a framework second. However, if you just want to get a specific site completed there is nothing wrong with only knowing the tools you need for that one site. 
For what its worth Synes_Godt_Om, robclancy is one of the biggest trolls on the internet. Also, rob, that whole post was just inherently not true.
"it introduces a huge reliance on code that I have no oversight over" This is the crux of the OP's arugment but it's kinda silly, no offense. You run your code on hard you have little oversight on, you run on an OS you have little oversight on, you run on a language you have little oversight on. If you can trust these based on merit, you can trust your PHP libs based on similar merit.
AND YOU ARE! but the secret *^is ^to ^look ^professional, ^experience ^comes ^with ^time...* wtvr;DR
&gt; A better analogy may be electronic circuits. If you know to solder two wires, you can theoretically build any circuit. Right? But doing so without any sort of planning or design, you will end up something like [this](http://3.bp.blogspot.com/_EiXSzg_8b5w/TPvUSrhQJrI/AAAAAAAABDw/i01-iAkT_VE/s400/Breadboard_complex.jpg). The circuit shown in that image may work work. But if I ask you to make a small change, you will have no clue regarding which wire to pull, because it is all jumbled up. And If something is not working, you will not have any idea regarding which connection or component to check. and that is with colored wires... now imagine all those wires are black.
If you want to do it for a living and not be a crook, sell yourself as a junior.
You honestly believe that all PHP libraries, operating systems, and software are equal? That they're built universally by the same class of developers with the same interests and motivations?
It's up to you to choose the correct package. I'd trust Symfony's console package over rolling my own. 
&gt; The real question is, do you like using 3rd party code? Yes. After proper review and/or research which takes time. I do not run bleeding edge software in production environments without a damn good reason. &gt; Specifically regarding deployment - I do frequently use the "git push... ssh ... git pull" method of deployment, but I really don't like it regardless of composer. I don't want to be dependent on a git remote being up to deploy my code. But since the remotes are so rarely down, and it's really easy to do it, I do typically use this method (especially for non-critical deploys). If I want to know, confidently know that I can deploy some code any time I like, I use good old-fashioned rsync. I know. Neckbeardy, right? This becomes less of an issue if you host your git repositories yourself. &gt; Regarding version control and Composer, I definitely prefer that composer dependencies not go into my repository. There's a simple reason for that: it's not my code and I do not maintain it. I maintain the dependencies, and the only code I need to commit to do so is the composer.lock file. If I ever need to know what changed in my dependency stack, that file will be my starting place. Fair point. &gt; Bear in mind that all the dependencies managed by composer are themselves version controlled repositories - at least if you're sticking to the stuff provided by packagist. If you need to know what changed between vX and vY of some dependency, you can look that up using the vendor's repository - it'll be better anyway because they'll likely provide you with a read me, a change log, and all the commit messages between the two revisions. That's way better than you just committing one giant mess of "all the code that changed in my vendor directory" - unless you're intimately familiar with all the code in all your dependencies, that commit is going to be meaningless. I could argue that you're relying on someone else's commit history to be available to you in the future, but I think that's belaboring the point. Good reply though! Thank you. 
Are you running rsync from the command line? Can you post your command or script or whatever? I'd like to see how you're compensating for config files, deleted files, etc. Things you don't necessarily want to be in sync.
I think it's safe to say you "know php" if you can, say, design and program a CMS for an extremely application-specific purpose in it. Otherwise, I guess you can just call yourself, "know how to make &lt;insert your goal&gt;".
1.) use composer install, not composer update on your staging server. 2.) use a staging server. purpose is to run tests (automatted and otherwise), do QA before release. 3.) rsync from staging to production. 4.) write a script to do it all, (sh, make, phing, ant, gradle, whatever) 5.) ??? 6.) profit. 
For what it's worth /u/Synes_Godt_Om, /u/robclancy although one of the biggest trolls on the internet, is 100% correct in the fact that your framework choice does not dictate if your app can only handle small status or enterprise status. Your own code does. The framework just enables you to get mundane stuff out of the way.
Please, enlighten us, because you're so very wrong. We use Laravel in the production world and it works great. 
Ok, so what you're saying is that there is no obvious pros/cons in choosing one over the other. That makes sense, I take it they are different but not in a way that warrant a switch if you already know one of them. My main concern was that maybe there would be some good reason not to continue with Symfony and instead switch to Laravel.
List "some PHP experience, building a site similar to WoWhead on Laravel" on your resume. There are a lot of jobs out there who would love to hire exactly that. In the meantime, don't stop learning. Try more small PHP projects on the side, do something with a different framework, take a swing at contributing to some of these frameworks (you can usually at least test and confirm other people's patches), etc. When you next interview, say "I loved how much I got done with laravel, it felt almost like cheating because I didn't need to know much PHP and honestly I felt weak in that area" -- it's fine. I'd hire you.
Jquery is not the end-all be-all that everyone thinks it is. It's basically just a lazy/convenience wrapper. It's good for some basic functionality; maybe a couple animations or effects. But when you start making a JavaScript-heavy application, it quickly falls on its face. I'm not trying to bash jquery. I use it a lot, and it works great for what it was intended for. I'm just trying to say that just because you can hack together some jquery plugins doesn't mean you know JavaScript.
What's the point of knowing PHP? If you can get the job done without knowing an ounce of PHP, then you've succeeded. Don't be a programmer. Be a person who builds great things. Some time ago I bet there was a person who felt like a fraud because he wasn't writing binary. WGAF.
&gt; I've personally never understood the problem with feeling my own product is the best. That's pretty good indication of a psychopathic personality, for starters. "I am the best" is a feeling reserved only for people who have no goddamn clue what "best" is.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Impostor syndrome**](https://en.wikipedia.org/wiki/Impostor%20syndrome): [](#sfw) --- &gt;The __impostor syndrome__, sometimes called __impostor phenomenon__ or __fraud syndrome__, is a psychological phenomenon in which people are unable to [internalize](https://en.wikipedia.org/wiki/Internalize) their accomplishments. Despite external evidence of their competence, those with the syndrome remain convinced that they are frauds and do not deserve the success they have achieved. Proof of success is dismissed as luck, timing, or as a result of deceiving others into thinking they are more [intelligent](https://en.wikipedia.org/wiki/Intelligent) and competent than they believe themselves to be. &gt; --- ^Interesting: [^Dunning–Kruger ^effect](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect) ^| [^List ^of ^impostors](https://en.wikipedia.org/wiki/List_of_impostors) ^| [^Elizabeth ^Harrin](https://en.wikipedia.org/wiki/Elizabeth_Harrin) ^| [^Dan ^Nainan](https://en.wikipedia.org/wiki/Dan_Nainan) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+chko3z5) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+chko3z5)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
There are actually a great number of reasons why you shouldn't use jquery (or rather WHAT you shouldn't use jQuery for): * highly responsive applications. Anything from AngularJS to Knockout would serve better. And no jQuery experience will easily translate there * back-end JS coding (NodeJS) where jQuery is wholly useless * front-end application programming. Unless you're doing simple slideshows, or moving elements around, jQuery will be only in your way. That being said, jQuery is pretty great for lightweight front-end interactions. 
&gt; **WHAT** you shouldn't use jQuery **for** Great distinction there, kudos for mentioning it
BEAR.Sunday is new to me. looks good
It's not psychopathic for Bill Gates to feel like Windows is best. It's not psychopathic for Elon Musk to think Tesla is best. Get a grip with reality.
More like "watch" than read :) Will do! Thank you!
&gt; In my opinion, starting out with a framework is bad for learning. It makes it harder to understand what the language is doing versus what the framework is doing. Disagree. Using a well designed framework (e.g. Symfony 2) teaches you important things. Things like separation of concerns and strong overall application architecture. It also brings a lot of protection from common noob issues such as injection issues and authentication fuckups, as long as you colour between the lines. It lets you concentrate about what is important about your application while you are learning instead of the infrastructure which is, rightly these days, commodity. Knowing that, for example, $request-&gt;getParameter() is actually fed by the global $_REQUEST variable, gives you nothing and is really just an implementation detail that means nothing outside of PHP.
New version is supposed to be easier
I mean within my site, not the php code to display in a post. I want sites to display in my own site like stumbeupon 
That's no way to speak to people. Now go away, hopeseekr, you've spewed enough vitriol in this subreddit to last us several lifetimes. 
That was so insulting what he did it didnt even bother me. Kind of like a surprise slap.
&gt; I could argue that you're relying on someone else's commit history to be available to you in the future, but I think that's belaboring the point. True, but you can spin up your own packagist or satis in order to ensure you always have those available. In fact, here's [a vagrant demo](https://github.com/chuyskywalker/vagrant-salt-composer-satis) on just that I tossed together a while ago.
&gt; PHP libraries, operating systems, and software are equal? That they're built universally by the same class of developers Yes -- and all those developers are bad developers too. :) [Heartbleed](http://heartbleed.com/)? Weekly Adobe/Java updates? Windows patches galore. [OSX case statement fails](http://nakedsecurity.sophos.com/2014/02/24/anatomy-of-a-goto-fail-apples-ssl-bug-explained-plus-an-unofficial-patch/). It's all bad and you depend on every last bit of it, but I guarantee you don't audit 99.99999% of the code that you depend on. It's just a fact of life as a computer engineer -- we're all idiots.
&gt;highly responsive applications. Anything from AngularJS to Knockout would serve better. And no jQuery experience will easily translate there That's.... what I said. &gt;back-end JS coding (NodeJS) where jQuery is wholly useless Why would anyone even consider using jQuery for serverside? What a strange thing to say. &gt; front-end application programming. Unless you're doing simple slideshows, or moving elements around, jQuery will be only in your way. Uhh, not really, no.
Yup. I passed on so many applicants who would list "jQuery" but when you start talking debugging, writing a plugin, or any other framework - they were lost and confused. Too many developers say "JavaScript? Use jQuery!" And move on. It's done great things, and horrible things, for JavaScript. 
The OP should consider creating a value object to ease working with this insanity.
I'm not saying that a frame work doesn't help you learn - because they absolutely do. But jumping into a huge framework with no prior experience is going to do more harm than good. You'll likely be relying on tutorials and copying/pasting other people's code, rather than learning how to code. I've helped a lot of people who tried learning by just jumping in headstrong like that. They lacked a lot of basic instincts, which should have been ingrained already at that point.
Plenty of time to learn about that as you gain experience, and in the meantime the framework provides a base level of security for your app to help you not get owned. Also, once you do learn about the depths of common security issues, you're still going to use the framework provided mitigation like output escaping, csrf protection, probably the auth*n framework and safe data layers. Edit: a quick note to say that a lot of security issues simply do not exist/are incredibly rare today because the implementation details are abstracted away and the programmer doesn't have the chance to fuck it up. Managed languages and memory corruption flaws, for instance. 
Well, to be fair, it can't exactly get harder can it?
No. This is unequivocally a bad idea, and should never be done under any circumstances.
Just saw this so sorry for the lack of response. We didn't migrate to anything, the vast majority of OC was simply replaced, and once I was done with that I switched jobs. The place I work for now has a completely home spun system, which honestly I vastly prefer to anything else I've had to work with. It does just what it needs to do, no excess baggage to haul around. When we need to extend it it's as simple as dropping in a new controller. If you have the budget, time and experience I would strongly recommend rolling your own. But it is a huge time sink. When I started my job they had been suffering though a system written 10 years ago in classic ASP. It was a massive pile of dog turds and spaghetti code. They wanted me to extend it and I told them we needed to start over. Thankfully they understood that the technical debt was massive and agreed. It took a bit over 6 months of development time just to replace the back end. And that didn't include any of the management systems which were thankfully completely separate from the site. We're just now getting to revamping the front end and I've been there two years now.
I've been programming for 13 years. I still feel like a fraud, some days.
Yes he owns the dumb
&gt; Are there any existing adaptors for Solr/Bolt integration? Nope. not yet, I'm afraid. Should you decide to make one, We'd be interested too. :-)
Pro: You get to call yourself an "artisan" Con: You get to use static functions a lot
Then don't list PHP but do list Laravel.
Personally I say no to this, though I realise that it's a widely debated topic. What you have there is your controllers with a dependency on the container rather than explicit dependencies. Ideally you should pass the router in to the controller as a dependency, and use your DI to ensure that properly constructed objects are passed in to the constructors. So your controllers will often look like this. class Controller { public function __construct(Router $router, Templating $renderer, Connection $db) ........ } That way you can test your controller code without needing to know anything about containers and only the specific dependencies.
Yep, sound could've been better :( I'm sorry, I can't really listen to such quality of sound
Meh, I use dev-master all the time, because most of my stuff is hobby projects rather than mission critical stuff. If there's a 20 minute window people can't read dick jokes about funnel web spiders I think it's going to be ok. I'm just saying not everyone has the same needs for stability and reliability.
Pity I noticed this at the very end. When I tested my mic it seemed ok, but Camtasia did some weird stuff to it. I promise the next episode will be much better =) Also, I'm open up for suggestions on what to try next =)
Woosh.
Let me recode that... filter_var($url, FILTER_VALIDATE_URL)
Made a video of me trying it and OctoberCMS here: http://youtu.be/3kfOB2bFNFE
Nobody mentioned http://nette.org/en/. Guys really did great job on translating docs to english and now it's "english-first" framework.
Actually it will be nice to record an interview with creator of http://bldr.io EDIT: Really? Downvotes everywhere? This person here trying somehow to be part of community, people.
I'll try getting a hold of him
Besides my indent script I've started a fork of the current VIm syntax file for php where I've fixed several problems: https://github.com/2072/vim-syntax-for-PHP Do not hesitate to post issues regarding keyword classification. What is this old 5.3 syntax file with the 200 matching groups you speak of? 
&gt; and in the meantime the framework provides a base level of security for your app to help you not get owned. Sure, you should use frameworks or CMS's for your production stuff, especially as a noob. But I am talking more about learning, and just messing around on dummy projects. Hopefully someone with 2-3 weeks of experience isn't solely responsible for production apps. &gt; Also, once you do learn about the depths of common security issues, you're still going to use the framework provided mitigation Absolutely, I'm not advocating that you reinvent the wheel. I am advocating that you reinvent the wheel *for learning purposes*. You learn a hell of a lot about a wheel if you build it from scratch. In my opinion and experience, it is better to start small and learn the language itself. Large frameworks like Symfony2 all have slightly different approaches or syntax. It would be difficult to differentiate that from the core language constructs if that was all you knew. Going back to my other example, this is extremely prevalent in Javascript/jQuery. If you ask a lot of newer "Javascript" developers to implement XYZ feature of jQuery, without jQuery, they'd probably shit their pants. 
Silex. Cakephp seems decent.
&gt; es. After proper review and/or research which takes time. I do not run bleeding edge software in production environments without a damn good reason. That's fair and great practice. But I'd argue you're judging Composer because a lot of tutorials say "just use dev-master". Which is akin to judging PHP because a lot of tutorials say to use mysql_* functions. If you're doing your due diligence on the installed packages, then you can easily use Composer to specify precise versions in `composer.json`. That's encouraged and advisable. Composer's just helping you resolve the dependencies and autoload them into your project. You still have the control to determine which versions get installed of which libraries. It's also then trivial to fire up a test project (or git branch), update your dependencies, and run tests, with no harm done. Since Composer operates local to the project, there's a 0% chance that you'll install dependencies somewhere that could affect your production app until you choose to. Regarding git deployment - I actually do host my repositories myself; I use gitolite for personal projects, and we use Stash at work. And that definitely takes some of the concern out of using git as a deployment tool, because I control the remote and can do something about it if it's down. All the same, git _is not_ a deployment tool. It's a version control system. If I've got something critical, I'd rather write a deployment script that makes use of rsync, because rsync will fail _obviously_ and _hard_ and git can and does fail silently (in that it doesn't fail from its own perspective, "I just checked out the files, boss", but fails for the purposes of a deployment).
Wish: granted! &lt;https://github.com/auraphp/Aura.Html#escaping&gt;
Believe it or not, they are already OO. Each helper is an object instance stashed inside a HelperLocator; you can grab the helper object itself by injecting the HelperLocator and using the get() method.
Thanks for quick response. Sorry for the confusion here. just updated the code above. It is not Router or Database connection specific. Yes all controller can auto resolving the classes via constructor or property injection can be done. That feature already exists. My question is - Which is better way to access core classes inside controller ? Should I be accessing core classes as above case i or ii or iii ? Suppose if we need 15 or more classes into our controler and everything we are type hinting for auto resolving, then it will look messy. Right ? So only few needed class we can inject via constructor and for remaining ? 
Don't then. It works great, it's got a set of Unit Tests, It doesn't need to be in more than one file, and by overriding the element() func you can tweak the HTML output to your hearts content*. If you really want it to be in a namespace in your app then it would take you 5 seconds. Top marks, 5 stars. https://github.com/erusev/parsedown/pull/147
No idea, but by extending it and overriding the element() func you can tweak the HTML output, so that's a good place to start? I'm using that to rewrite some links and tweak some header styles. https://github.com/erusev/parsedown/pull/147
I started with Symfony years back, and felt everything was an uphill struggle. I got a good understanding of it, and it introduced me to some great concepts. But ultimately everything was an uphill struggle. I switched to Laravel due to my company, and at first I missed Symfony, and tried to do things the Symfony way. But I soon realised how Laravel made things so much simpler. Laravel is a joy in my life, and I feel I get so much more out of it from using Symfony first. I'm glad for the comparison of these frameworks, but also glad that all my projects are now Laravel.
Just come from posting a comment praising Laravel, this is soo true!
if you know how to manage a server properly digital ocean provides pretty good options, i generally host medium sized apps and websites in digital ocean and they work really well
Basically what the video states is that as long as you don't have complex relations in your DB, Mongo is great (e.g. reddit), otherwise it sucks pretty bad. Interesting video in my opinion.
Cool in theory, but I might be a little nervous about putting my code through it if it's not already open-source. 
1. where did you say that? This isn't high-performance coding. It's regular front-end application coding. Nothing "high performance" about it. Unless I misunderstood. I took "high performance" to mean: super hardcore optimized to use native functions vs. using libraries 2. -.- seriously? I was saying that jQuery IS useless for this application and thus you DO have to know JS and thus you DO have to snub jQuery. And yes, yes you would consider using jQuery in limited applications (for instance, working with DOM on the server side in scraping applications) 3. oh yeah? So what would you use jQuery for? Any extensive applications using jQuery would end up in stupidly unorganized and overly complex code that could be simplified by using vanilla JS with objects, prototypes, and everything else JS comes with natively.
Yo, I read "am ready to launch it". Do you even have the users? Don't waste your money on the biggest instance on amazon if you only have a guaranteed 10 users. With that said, I like Linode. Amazon is unstable with the lower ends instances, but I'll probably have to switch to it one day. 
&gt; This is going to be a rather short video 33 minutes. =|.
Give Google AppEngine a look as well. They're [free up to certain quotas](https://developers.google.com/appengine/docs/quotas), which is great while you're in development, and they scale automagically. I have a few apps on there. Nothing huge, they serve 5000-8000 daily visitors each, but it's really nice not having to worry about scaling. And because they have data centers all over the world, load balancing, caching and geolocation is taken care of as well. All you need to do is build the app, publish, and Google does the rest. They're a bit pricey when you do get huge, but at the point where that becomes an issue, you should be making more than enough money to pay for a group of specialists to set up your own network (to give an example, Snapchat is considering moving off GAE to conserve cost). 
http://pygments.org/ offers the same features for more languages and is downloadable and open source.
Well I kind of got carried away =))
I've only ever heard good things regarding Digital Ocean. Two of my work colleagues have recently acquired their hosting with them and could not speak more highly of them. Set up is really fast and the userbase offers loads of tutorials and support. I'm definitely going to be moving to them once my current hosting is up.
Not URLs, [URI][1]s. Even things like '`tel:+1-816-555-1212`' and '`urn:oasis:names:specification:docbook:dtd:xml:4.1.2`' work. [1]: http://tools.ietf.org/html/rfc3986
If price and performance are important to you, you only have one option: root server instead of cloud server. Example: You can get a small dedicated server with 128GB RAM for $175 per month. If you want comparable performance/specs from a cloud service, you'd pay well over $10k. It would be absolutely insane to use AWS and co for larger applications. 
It's worth noting that reddit uses Cassandra and not Mongo. Mongo sucks at far more than just complex relationships, and it would be extremely challenging to make it scale to handle reddit's workload. 
**ConfigServiceProvider** Information: Author: yosymfony Description: A configuration service provider for Silex with support to Yaml and Toml Main Language: PHP Number of Forks: 0 Number of Watchers: 4 Number of Stars: 4 
When I joined my company around 16 out of 20ish dependencies (not the dev dependencies) were dev-master, right now it's 12 out of 30.
make sure, laravel programmers will be there cuz, no laravel = no php ;)
A schema where inserting a new record on his tree made the rest of the tree have to change is a pretty crappy way to do it. This is what recursion is for. Then you just have parent child relationships that are dead easy. Worst case scenario if he wants to keep the numbering simple and human readable he should leave gaps in the numbers to leave room. But this moving everybody over one looks like it just asking for the whole system to come apart transactions or not. On the mongodb part. I tried using it but I found that they were telling me how I should do things while trying to tell me that I had complete freedom. This reeked of when XML was trying to take over the world and people were saying the same thing. Use XML however I want as long as I use an ISO schema. I much prefer the new way that Postgres is going. Use relational for the relational and NoSQL for the stuff that doesn't fit relational too well. I have been doing it this way for years using blobs. 
To use the example of sorting things in your house that is still where I like to combine NoSQL with SQL. So I might have a table with an ID, a location, the owner ID, and other things that all objects have in common and need to be quickly searched. While I then have a blob with the JSON that contains the details of each object that tend to be object specific. Sometimes I even get a bit dirty and denormalize it a bit with say the name in both places but I try to avoid things like that. This is ideal as I don't need to have the worlds most complicated table structure and adding new objects is a dream. But doing things like bringing up a list of objects in a room would still be rocket fast and dead easy. Select ID, NAME where ROOM_ID=3; 
this should work for laravel and its blade templating if it's not, then it is no use :)
I love digitalocean. Give them a shot!
 function isBufferEmpty() { return (!count($this-&gt;insertBuffer &gt; 0)); } Four. Hours.
you should learn [this!](http://laravel.com/docs)
who are you trying to stop people doing their own thing? **mind your own business.** they are not doing illegal thing. it is their own right to make money. If you like it, you buy it, if you don't, just shut the hell up :)
There's probably two things here. If your dependencies have factories for instantiating objects then it's fine to use them, for instance of you use Doctrine, then your repositories and entites are handled via an EntityManger instance so you only need to pass one dependency in. Ideally though you should explicitly define your dependencies in the constructor, just if your class has 15 or more dependencies then maybe you need to think about refactoring your controllers to have a smaller footprint. For instance here's one of my controllers which runs one part of a fairly hefty app and these are the dependencies... public function __construct( Twig_Environment $renderer, FormFactory $forms, EntityManager $em, MailService $mailer, PaymentService $payment, Router $router) { But you'll notice that several of those are services or managers that can provide other objects eg... $this-&gt;em-&gt;find(.....) or $form = $this-&gt;forms-&gt;create($type, $entity); Hopefully that makes sense.
I fixed the sound for the next video I posted. As for video planning, I kind of plan what I'm going to do, but I named the channel "PHP lets try" in the spirit of "lets play" channels, so the idea is not relaying the news, rather recording my experience as I try stuff. I'll try the news/tutorial approach in one of my next videos, perhaps you'll like it more =)
That's right. You can also override the methods that handle a specific type. You can find an example at https://github.com/erusev/parsedown/pull/111.
I guess you realize this now, but for others: Never use isset() to check for a value. It's better to use empty()
Is there any way you could add Perl support?
It does make some pretty looking code. I like it.
I second that. Been using it to upgrade a very old non-object oriented website. I like not using Static functions all over the place. 
Because `empty()` will report `true` for anything "falsy or nullish", it's one of the most common sources of the same kind of frustrating gotchas that the OP is referencing (e.g. `empty("0") === true`). Always do explicit value checks.
Still wouldnt hurt to throw a 301 redirect, he reads reddit
You're right, whenever possible do explicit value checks. empty() is still better than isset() when checking for falsyness. Honestly if I was working with code where I wanted to check if I can actually use the return value from a function, calling if (!empty($value)) { Would be sufficient. If $value happening to be the string "0" I would still consider that falsy. Edit: I don't expect you to agree with this style of programming. But if I check the exact return value, such as if ($value === false) and the $value actually is `null`, that would be a bug in my program that would also be hard to find.
Their product portfolio and lack of features makes other hosts more attractive, but for sheer price, It's a good host.
Pulling down code from a github repo or from packagist as a ZIP is no different from downloading a ZIP file from sourceforge or installing a PEAR library, and that got us by for years. A dependency literally means relying on other peoples code, right? &gt; "php composer update" on a production server seems like a HUGE leap of faith for me. Is that what you guys are doing? NEVER FUCKING DO THAT EVER Just dont. You probably never really want to `composer update`. You probably want to run `composer update some/package` but updating the whole lot in one go just means you're updating a lot and are inviting breaking changes into your app, regardless of how stringent your composer requirements are. With that out of the way.... &gt; Am I supposed to run composer to update production machines? That doesn't seem right. No. Composer install on anywhere that isnt develop. &gt; What's the deal with every repository .gitignoring itself? Is version control for my project not supposed to track changes from repositories? Not sure what you mean here. You probably dont want to be installing your dependencies from git anyway, check out the --prefer-dist option. &gt; Update packages with composer on my dev environment &gt; Follow the workflow above &gt; Jump on production and update with composer again &gt; Cross my fingers and hope. Fuck no, that sounds awful. 1. Composer install locally, or composer update for everything, or specific things if you're feeling lucky. 2. Run your tests. 3. Click around and go look for any "report credit card information to china" code that you feel like might be lurking. I generally only install code from folks I trust, but might be worth checking now and then. 4. Commit the changes to the composer.lock file, which will now contain lots of new checksums of the new package(s) you've updated. 5. Deploy and run composer install, which will ONLY deploy the EXACT versions listed in composer.lock 6. Every dependency on production is identical to the local version. Composer will let you install drastically newer versions of code than are on dev, if you tell it to, but you should not be telling it to. :) I've been meaning to do a "Advanced Composer" article for a while to cover exactly this. Maybe I'll shove it up on PHP The Right Way.
If you know beyond the shadow of a doubt that there are no gotchas possible in your particular use of `empty()`, then that's fine. But I've found that, more often than not, developers use it without considerations to the edge cases it has, and that's how you get bitten. Here's a good example: if (empty($_POST['number_of_children'])) { $errors[] = 'Number of children is a required field.'; } This bug is non-obvious for a good number of developers. After all, it expresses the *intent* in an accurate, semantic way. "If the field is empty, report an error."
Mee too. I often just make name spaced functions and only sticking to oop when needed. 
Actually, I used array_key_exists I guess it depends in the situation. I used isset in the beginning because a) it was the first thing that came to my mind, b) I thought it would be faster than array_key_exists, but actually it looks like the later is faster than the former.
Just when I was going to try silex later this afternoon
What do you mean by large? How many simultaneous users? Digital Ocean are great though, assuming you're happy managing the server(s) too. 
Look, we disagree. Doesn't mean I've not worked with jQuery. Most likely different style of applications than you. You're welcome to enlighten me with the usage cases that you're referring to. 
You're a jackass, obviously.
So... is the code example you give a case of good use, or a case of bad use?
Cool, I already got the time settled with Bldr developer. Perhaps you could join us, that'd be awesome since your projects are trying for the same goal. Are you available tomorrow 2pm PST?
Why would you care about downvotes here?
always true, right?
Why don't you just detect key presses and color code in real time? Also sublime ftw.
if $_POST['number_of_children'] is 0 the if statement will return true
I find codeigniter pretty lightweight and simple enough to use.
What's happening to igorw/ConfigServiceProvider ?
I know, and I actually used ===, the thing is that the operator never executed, because I first checked if the array index was set. This is necessary if I don't want to get an undefined index error when I call the validation method. This was afterwards passed to a validation method (notNull) that implemented the === operator.
I was passing in some parameters to the gd library, and getting no image whatsoever. I assumed I hadn't set something up properly, eventually realised that I had mispelled the parameter $width as $widht. PHP evaluated $widht as a null value, then passed that null value into PHP, meaning I got no image back. But no error messages, no warnings...
If we have a thread of task runner authors, I should post http://robo.li here as well )
Features like what
Nice! M
This is a cool idea, but it looks like it does some non-formatting code edits. I entered: &lt;?php echo "lol wat"; 1 = 3; if ($lol) foo(); class unga extends \bunga { /** * @type string */ private $nope; public function __construct(array $hahaha = [], $things, $otherThings = 'yeah') { $this-&gt;nope = $hahaha; } } $things = false; $things = [ 'true', '1', true, new \stdclass, ]; syntax error, right here! and it returned: &lt;?php echo "lol wat"; 1 = 3; if ($lol) foo(); class unga extends \bunga { /** * @type string */ private $nope; public function __construct(array $hahaha = [], $things, $otherThings = 'yeah') { $this-&gt;nope = $hahaha; } } $things = false; $things = ['true', '1', true, new \stdclass, ]; syntaxerror, righthere! ?&gt; Note the treatment of the syntax error at the end and the addition of the closing PHP tag. The click-to-highlight added two line breaks before and after the formatted code snippet too, which will interfere with code that tries to output headers. It'd be nice if you could specify which coding standard you'd like to format to (PSR-[0-2], Symfony, etc.). Edit: formatting.
I'll try getting a hold of those guys too =)
You can do (isset(x) &amp;&amp; x === y) it won't attempt the comparison on the right if it doesnt pass the one on the left. edit: if youre going to downvote my code how about offer a better solution? Yes it won't work if you were checking for null with y = null but in that case replace the whole thing with is_null(). 
Use if (strpos(...) === false) instead of if ( ! strpos(...)) to determine if the substring occurs in a string because strpos may return 0 (substring is at the beginning of the string) which is a falsy value.
 There was a lot of other code masking the 'bug' and technically not a PHP gotcha but: class SomeClass { private $dbConnection = null; function __constructor(DBConnection $dbConnection) { $this-&gt;dbConnection = $dbConnection; } function foo() { //Spend two hours here wondering why $this-&gt;dbConnection is null } } Took a couple of hours.
Right, and if x is set to null, that will terminate at the isset because isset returns false when the var is null.
 if (!function_exists('not')) { //sadly, I can't use not() here function not($boolean) { return ($boolean === false); } }
Assuming you didn't turn error logging off, there was most likely an error message similar to this in your log that you missed: &gt; Notice: Undefined variable: widht in /path/to/your/script on line X
&gt; I thought it would be faster than array_key_exists, but actually it looks like the later is faster than the former. This is pretty much the definition of premature optimization. Not to mention the fact that if the performance of either of these is a problem in your application, you've done something *horribly* wrong.
I liked Linode until they exposed my credit card number.
When you're in the "I need 128GB of ram to handle all this traffic" bracket, you'll need more than just one server. At this point, spending a few grand more to avoid having a single point of failure becomes necessary: * 2+ web servers * 1+ database servers * 1+ load balancer * 1+ backup server * 1 guy to maintain the network infrastructure, willing to wake up and drive to the data center at 3am to fight fires if necessary. And if you're not making enough to pay someone to manage all of this, AWS and GAE should start to look real attractive.
Just yesterday I spent 3 hours only to discover I had an if statement that was using a single equals sign not a double :(
Where might one find a colo deal like that?
wont really work between two variables, but if you're comparing a variable and a constant or literal, write it like yoda &gt;if(5 == $variable) That way, if you accidentally use only one =, it will throw an error
The brackets around the outside are pointless still? 
Pretty cool. Are you reusing code to parse this stuff or did you write it yourself?
[One might follow this link and start to pity those who use AWS](https://www.hetzner.de/en/hosting/produktmatrix/rootserver-produktmatrix-px)
I have seen that before but never really considered doing it because it never kicked my ass before, thank you for the reminder I will definitely make it a point to do that from now on haha
That's a valid point. The only reason I would consider is a gotcha vs. just bad code is because, intuitively, I would expect count() to error out when given something like a boolean. EDIT: The code I meant to type did not have a comparison inside the count function. 
Going from JavaScript to PHP, I will often leave off semicolons without a second thought. Which normally would be simple to discover, but in this case I didn't have error logging on and "couldn't be bothered" to turn it on. Spent an hour pouring over the logic of my code, only to realize it was a syntax issue. 
Not sure why downvoted. If x is null then it cant === y so it doesn't matter what isset returns for null. If you wanted to check for null theres always is_null.
AWS is a stunning achievement in virtualized computing that powers sites like Amazon.com and Netflix, what does your 'citation needed' German provider have to offer, besides being distant from this person's user base?
I think /u/scottchiefbaker means that he wouldn't refactor its code if it's unsure on how it's done
What is the difference to casting it to an Array type?
Why're you leaving out semicolons in JavaScript?!
Both use semicolons, no? I sometimes accidentally add semicolons in VB.NET when hopping around between it and PHP/Javascript
Bad habits.
I've always heard good things about his site, but it just feels like a gigantic ad.
Kohana! http://kohanaframework.org/.
jshint and uglify your JavaScript on save using a Grunt/gulp watcher and you'll never ever forget again!
Don't forget Linode (https://www.linode.com/) and Google Compute Engine (https://cloud.google.com/products/compute-engine/) Personally I use Linode and I love it and highly recommend it.
Yeah this is a case of the wrong error level or using @
And broccoli is green. But that's also besides the point. And latency is no issue either. You'd use a CDN regardless. And for the staff that can't be cdn'd, you use Varnish and Memecache. And since you have lots of RAM, all your hot data actually fits into cache. Since it seems you couldn't care less about money, feel free to send me lots of Amazon vouchers. Want to give your users a newsfeed like Facebook? Too bad, your small but expensive AWS instance is too weak for that. Want to give your users a nice UX and add great search functionality with Solr/ElasticSearch? Too bad, there is no budget for that either. Want to hire employees, grow your business? Or actually not go broke yourself? For cloud server you're paying 25-100 times as much as for the service I suggested. Go ahead and multiply a few numbers by 25-100. I'm sure you can come up with several ways to put that saved money to better use. It's like buying a house with budget X. You can either buy a small house but with no interior at all but with golden walls (which a few of your dev friends might find stylish) or you could buy a large house with great interior (swimming pools, golf course, etc) but boring plain walls. My guess is that your wife, kids and all your other acquintances might prefer the second option.
Any particular reason you believe that?
http://martinfowler.com/ and Here are couple of things I wrote, but please don't take them too seriously. I may be wrong. [About using objects instead of arrays for representing data](http://imakesnowflakes.com/programming-why-you-should-use-objects-instead-of-arrays.html) [An OOP architecture for php applications](http://imakesnowflakes.com/programming-why-you-should-use-objects-instead-of-arrays.html) 
ok I'll bite. What's wrong with this? I can't see it.
Ah of course. Now I don't feel so bad. That's the type of thing I defer to the IDE to fill-out for me and is the sort of mistake I would also make.
But why would you not just use REST and the lovely [restangular](https://github.com/mgonto/restangular) (angular-specific) for that to work?
Whole night and a case of beer. PHP's database API returns only strings, I've had it explained to me before computationally why, but *why*? One person said it had to due with how C handles datatypes but that fell apart when I mentioned that Python's written in C and it's database API actually returns integers as, *gasp*, integers. I really was beginning to think that my code was possessed or I was losing my sanity.
I didn't even know what that is until I saw your reply and looked this up. Who knew ignorance would help me learn something new today :)
Yeah, this one is tricky to get used to, many implementations of strpos in different languages return -1 if the haystack dosen't contain the needle.
IPV6, Floating/additional ip addresses. Lack of a hosted load balancer solution. etc
sprintf() was returning empty string when input was copied from Word with some invisible character. Too bad I was in a hurry to fix it and never taken time to find out what the character was.
php &gt; $wtf = ("any string" == 0); php &gt; var_dump($wtf); bool(true) 
From your article: &gt; A common mistake.... (etc) This is so true. I didn't really fully understand the difference between instance methods and class methods until I started working with Python. That's when it really clicked for me: mixing of instance methods and class methods indicates poor separation of concerns and thus poor design. It makes object usage ambiguous. Am I instantiating/injecting this object because I have a hydrated version of its data I want to work with, or am I invoking a dry object just because I want access to some bag of functionality? Ambiguous responsibilities lead to ambiguous usage contexts, and that's going to cause confusion for other developers, or even yourself down the line. This is also what I dislike about Eloquent. When I inject a User model into a controller, it immediately feels dirty to me even though dependency injection is good. It feels dirty because it's not technically a User at that point - it contains no data pertaining to a user entity. Instead, it's a kind of repository. And then what about this? $User = $this-&gt;User-&gt;find(1); Now I can do $User2 = $User-&gt;find(2) to find a different user using what should be just a simple User object. This makes my skin crawl for some reason, it's so weird that a User *instance* is also a *class* for finding and making other users.
ok, I'll stop.
30minuts isn't enough im my opinion to do something more for people who don't know laravel.
Amen
Well, how else would php be supposed to compare a string and a number than to convert one of them? Since it's a number you're trying to compare to, it converts the string to a number which results in 0. 0==0 is true. "Any string"===0 equals false, since the data types are different. No error here.
If you're doing this today, and you have not prepared yet, then you're running a bit late :) Laravel and the three big PHP CMSes are really two very different species. If your customers are looking for off-the-shelf content management, without any custom functionality, then Laravel will have a hard time competing. If you're trying to win over the developers, I would demonstrate how Laravel makes the developer's life easier and how it makes PHP development fun again. For project managers I would try to reassure them that Laravel is a safe and good choice. You could base this on the size of the community, popularity of the project, how it makes a developer's day fun again. You could also show how Laravel stacks up to the shortcomings of WP/Drupal/Joomla. For instance code quality, quality of extensions, lack of core frameworks, security concerns, etc. What it really comes down to though, for those who has the deciding vote on this, is "will Laravel earn us more money than WP/Drupal/Joomla?". 
If y is null then x === y. It's counterintuitive that if I SET x to null that ISSET would return false.
I asked the same question 2 months ago [here](http://www.reddit.com/r/laravel/comments/1zymow/will_introduce_laravel_to_our_company_where/) and I have 2 weeks of preparation instead of 30mins.
That's not helpful.
Wow, that is awesome! Thanks!
Exactly the reason why I started calling myself a software engineer instead of a PHP developer some years ago.
For those who haven't read the article, there is a satire piece behind the title.
I think you should really be comparing the code you can write yourself vs the code you'll find in the libraries and not qualifying them based on other levels of the stack. However, I'll bite: Yes &amp; No. There is no reason that a C system lib is any better than a PHP lib programmer. They skills require different domain knowledge and there are good and bad people doing both. Obviously there are long established C libs that are happily consider more trust worthy, but you also have a lot of code established code bases like openSSL being caught with their pants down. Alternativly it should be easier to write safe PHP code but our community isn't exactly the most mature in the world and we're picking random git code, not code audited by a distro so it requires a little bit more effort to filter quality components. 
Yes thanks. What If we inject the container itself inside controller and by doing this we are just injecting one object which will be responsible to create object of any core classes. For example - namespace Apps\Controller; use Cygnite\Base\DependencyInjection\Container; use Cygnite\AbstractBaseController; class UserController extends AbstractBaseController { private $container; public function __construct(Container $container) { $this-&gt;container = $container; } public function indexAction() { $form = $this-&gt;container-&gt;make('form'); $form-&gt;addElement('text', array()); $form-&gt;createForm(); // your code goes here $validation = $this-&gt;container-&gt;make('validation'); $validation-&gt;addRules(); $validation-&gt;validate(); $this-&gt;render('userlist')-&gt;with(array('form' =&gt; $form)); } } Is it the best solution to access objects as you explained above? or base controller can be used to get the object. something like below which is also short and simple. $form = $this-&gt;get('cygnite.libraries.form'); You can see in the second case we don't have to know how object is creating, just accessing all object via Basecontroller. Am I correct ? Can you please suggest? Thanks
Always add product variants (like size or colour) as a new product with optional parent_product_id field. It will simplify your data and design. You can optionally use suffix in id (like all products end on 00 - 1234500, 9877600 - and then you will have 99 optional variants) for ease of presentation (sort by id).
I would have thought Phpstorm would, must be a setting somewhere I could turn on
Couldn't you just reference the user in the comment rather than caching his details in the comment entity?
Yeah, to be clear, your unit tests should be able to run on a box that is completely isolated with no database, etc, available. Outside dependencies are not your code's problem in this context. Your unit tests make sure YOUR code works.
You could. But those references are resolved using additional queries, which is not efficient and basically reinvents SQL
&gt; how else would php be supposed to compare a string and a number That's the point. It shouldn't. This should spit out an exception/error.
I haven't used NoSQL before, but I kind of imagined it being used for both nested entities, and having entities of different types reference each other in many places. Apparently that's not the case then, or at a great speed cost?
They don't really recommend referencing if it can be avoided
However, his code could/should handle the situations where the internet connection is not available by some other means than just crashing. 
[This was posted recently](http://www.reddit.com/r/PHP/comments/24shpn/php_in_inherently_insecure/)
What is?
Then you test your code by passing "good" data (when connection IS present) and "bad" data (when connection IS NOT present). 
ITT: People assuming strong type comparison while using explicitly weak typed comparators.
You mustn't know who hopeseekr is. 2012-09-04 is one of his many sock puppet accounts. He has a history of spewing vitriol and damaging the community (and that's not mentioning his more unlawful activities). In my opinion, he's *not* welcome here, no.
Thank you for shedding light on that, so much bullshit in there. Here is a good sum up by Andrea Faulds: &gt; It negates months of hard work performed behind closed doors in secret (phpng), compared to lots of hard work done in the open (64-bit patch).
&gt; You can't blame a thing for not being designed fit to your wishes, especially if it offers a reasonably easy way to get just what you want. If PHP would not offer the typesafe comparison operator, your point would be kind of valid. No, PHP **does not** have a typesafe comparison operator. It ***only*** has a typesafe *equality* operator. So yeah, I can do "1" === 0 instead of "1" == 0, but how do I compare for stuff other than equality? What is the strict equivalent of "0" &lt; 1? Remember, there is no such thing as &lt;===. Also, don't downvote because you disagree, downvote if somone a) does not contribute to the discussion, or b) violates reddiquette. 
And Laraval Facades™ are not actual facades but proxies. Something important to remember when working with Laravel while not completely ignoring the correct definitions of software design patterns. Something I wish the Laravel community was a bit more receptive to rather than defend this practice of bad naming to the death.
I don't understand exactly how PHP works well enough to understand what the hell's going on, so I'm staying the fuck out of this
I agree with everything you've presented here. Let me point out one use case in particular that I believe MongoDB is a good solution for, that I ran across in real life. I was architecting a system that had to be able to very rapidly import job posting data from the Internet and from electronic feeds. Think of it as a single central repository for raw data similar in content but different in structure. What MongoDB gives you in that situation is the ability to store what we called "envelope" data, which was basically metadata that we generated about the source of the posting and the time at which it was imported, etc., as well as the *structured* data that we retrieved (which is extremely useful later when you need to do some transformation on it) without worrying about all of the sources having different structures. The RDBMS solution to this problem would be either: * Create a new table for each data source (lots of administrative overhead, sources can be added and removed *ad hoc*) * Create a table with lots of "data1, data2, data3" columns (almost always a bad idea) * Store the envelope data as columns and the actual feed data as something like an XML or JSON blob in a single column The last option is probably the right one for RDBMS but you get very limited insight into the content of that blob without doing lots of queries or manipulation in your app. With MongoDB, you can query into that blob easily and although performance may not be great and you need to index carefully, this works great for a backend import system that live users aren't hitting. Short story: MongoDB is an excellent choice for very specific uses and any type of web app is very unlikely to be one of those uses.
While you're right that === is an equality operator, why would you need a type strict comparison between two different data types? You really want to know if "foobar" &lt; 12 ? In your example of "0" &lt; 1, "0" would be cast to integer, resulting in 0, the comparison would return the correct result. What would be a usecase for a strong typed _comparison_ between two data types?
Great example =) I'll remember it =)
can we have some dignity here now please
As others have mentioned, you're not testing whether or not your data sources are functional, just that your code is. With a test, you supplement a real data model with a faked up model that will test all your code's boundaries and ensures unexpected data is handled appropriately. Usually what I do when I have code that works off a database (for example), I'll write up several fake records in JSON or XML (depending on the case) and have that data go through as my arguments. Its all the same stuff, provided you write your test correctly.
The best I can guess (Read my above comment, I don't know what the fuck happens with PHP under the hood) is that one group of people want to use int or long or something similar for data structure thingies, and another group does not want to. Those that don't want to use it are the one's developing phpng (a new php engine that's in testing that's meant to be much faster) because they say that it'll slow down phpng's performance gains, while those that do want it say screw phpng, and don't like that phpng was developed "behind closed doors" or some similar stuff, and therefore is worth less? Oh, and the people who are pushing for a no are apparently the major contributors to php core, and the people pushing for yes aren't nearly as involved? If that matters? That's my take on it. I have no opinion as to who's right and who's wrong. I just don't understand enough about the mechanics of it all to make judgement
Yeah, I gathered that much from reading the emails, I was hoping someone would tell me which side to cheer for hahaha. The last Zeev email is pretty clear though &gt; The voting RFC was written with language functions, features and processes in mind. Not implementation. &gt; I didn't even dream that we'll have RFCs that deal with low-level implementation up for vote. If I did, there'd be a separate dedicated section for it.
Gonna be honest, I'm inclined to maybe side for phpng. Or I would be if I had any say in the matter. And was technical. I dunno, phpng sounds really promising in so far as performance gains. And I'm kind of addicted to shaving off as little as 50ms to my load times (I once worked at a company where their main product took 2.3s to load a page. I reduced that to 1.3. Since then, I've used PageSpeed on every site I work on). Then again, the other side sounds like they might have a point were I able to understand it. So...
Searching all of the googles for "authors of phpng" doesn't turn up much to help me understand which side to root for here. From what I've read so far, phpng is a branch of the Zend VM ("engine") that reduces its overall memory footprint by as much as 8%, although support for numerous important extensions (including "mssql" and others) doesn't yet exist because those extensions need to be physically converted to use the phpng heap design. Meanwhile, another group has been working on adding 64-bit support to PHP, and because that changes the data type and memory utilization of a bunch of variable types, it would: 1. Require a lot of work to factor into phpng, and 2. Potentially reduce if not completely counter the heap size benefits of phpng entirely. As more of a casual observer, it seems to me that the 64-bit support patch would be more generally desirable by a larger number of people, being that memory is cheap these days and optimizing other parts of PHP might provide a better overall value to PHP users. If phpng's new approach to variable storage makes sense for PHP's architecture as a whole, it should and will be adopted. If the change affords only a modest memory efficiency in 32-bit deployments, maybe it isn't as important as they're making it out to be. I, personally, would like to see better threading or pseudo-threading support (like python's threading module) before either of these two patches.
I'm in the same boat. I think stuff this low level is above most people. And citing that PHP is an open source project means nothing. A lot of OSS projects are developed in a lot of ways, I don't know of other cases where RFCs would cover such low level additions. 
I dunno, I think when talking about scalability memory becomes important. Sure, memory is cheap, but if you're looking to scale huge 8% can be a nice save. I'm not entirely sure what use 64-bit support would be, I haven't encountered an issue where I could need it, but that's just one of the reasons I don't even consider jumping into this &gt; I, personally, would like to see better threading or pseudo-threading support (like python's threading module) before either of these two patches. I have to agree on this. So much
It also restarts apache or php-fpm incase the service is down
The community worked on the 64 bit thing for months, which for many reasons seems to be a good thing. The problem is that 64 bit thing has a performance impact on phpng, the refactoring that was made on the engine for (probably) PHP 6 to make it faster. The thing is phpng was kind of built in secret, and now it's been public for a few weeks and Zend wants to throw away all the work on the 64 bit thing because of phpng (which is not even in alpha, it's barely usable for now). All this could have been avoided if phpng has been public from the beginning, or if at least the people working on the 64 bit patch had been warned and consulted. So now we have: - people voting YES to merge the 64 bit patch, and saying "phpng's performances is not the priority, it's not even in alpha, it has to be fixed/improved later" - people voting NO because phpng should be the priority (mostly Zend and all who worked on phpng) - Nikita who suggests a reasonable compromise in-between the 2 sides
Thanks for sharing. Its a bit difficult to read on a mobile :/
mnapoli's summary is pretty spot on, plus Zeev who is one of the Zend team that worked on phpng is now suggesting that the rules on RFCs should be changed to prevent people who don't work on the core being able to vote on features like the 64bit RFC.
&gt; What would be a usecase for a strong typed comparison between two data types? Strong typed comparison would tell you - correctly - that you are comparing apples and oranges so you can fix your code. It seems innocent when it is `"0" &lt; 1`, but what about `array() &lt; 3`? Or `new stdClass() &lt; array()`. PHP *explictly allows* these comparisons and it silently accepts them without even a warning. This is done in the name of "beginner friendliness" but all it accomplishes is broken, hard-to-debug code.
But why would you want to compare oranges to apples in the first place? Edit: why would you want php to handle something like array&amp;lt;3 for you correctly? In which language does this example make sense? You're implying that php should know that you either want to reduce the whole array and compare its numerical value to your number or you'd imply that php compares the length of the array. Same goes for the object vs array comparison. It's not the language's fault if your logic is faulty. It'd be surely a nice gesture of php to warn you that you're comparing different data types but that's not actually its concern.
The is one thread in a bunch of inter-related discussions revolving around php-ng and the rfc for true 64-bit support. Unless you're following all the discussions on the list, you're going to only get a small portion of a larger picture. ---- I've been following the discussions on the public lists on this and here's what I believe to be the current case: Zend devs recently announced 'php-ng' which is a branch they've been working on "in secret" for the past few months. Designed to bring performance improvement and stuff blah blah blah. It's probably what will be the base for PHP-$NEXTMAJORVERSION (whatever that may be!) At around the same time an RFC was posted for a branch that other developers have been working on for "true 64-bit support". This was apparently openly announced some months ago. The main issues are: * The patch proposed in the RFC is not against php-ng, and numbers quoted for increased memory usage don't take it into account. * The patch goes above and beyond what is actually necessary, making some values 64-bit that don't need to be. This unnecessarily increases memory usage (for example, supporting arrays with more than ~4 billion indexes) * The Zend engine developers don't agree with the patch as a whole. They want amendments made before any RFC is accepted. * The RFC proposer wants to accept the RFC, then make amendments. * A lot of the people voting on the RFC are not core engine developers, and aren't directly affected by the issues that the core engine developers have raised. Nikita posted the following on the 64-bit support issues: http://thread.gmane.org/gmane.comp.php.devel/87143 ---- Also note that this situation is continually evolving - discussions are ongoing. They are also not much more than heated discussions as I read it. There really isn't that much of a big deal going on here as far as I can see. When this all blows over (probably, like, tomorrow), as far as everyone is concerned, PHP-Next will contain the products of both php-ng and large parts of the proposed 64-bit support patch.
For these sorts of questions your best bet is always to google the question first. Something like "PHP redirect page" and usually the first stackoverflow link will give you the answer you're looking for. It sounds to me like you're trying to do a simple redirect. In that case, using PHP you can do a redirect by using the [header function](http://www.php.net/manual/en/function.header.php) header("Location: contact.php");
I've down-voted this post because I don't think it's useful or helpful to either the PHP developers or the community at large. This is just one of a number of inter-related discussions (some more heated than others) that are going on and doesn't even really give any kind of useful view on either part or whole of the entire situation. For cases like these an article summarising the entire situation and weighing up the pros and cons of all sides should be used. At this point, as far as users are concerned, PHP-Next will ultimately almost certainly contain both the products of php-ng and improved 64-bit support (large parts, but not all, of the 64-bit RFC).
In a loosely typed language, boolean(true) casts nicely to integer(1)... hence count() not being bothered
AWell its a Quad-Core with about 6GB ram, so I don't think that's the issue. I have PHP 5.5 running over there. It's not that it doesn't work fine, it's just really slow when it comes to enabling editing mode.
Must be a pretty shitty shop if they're too cheap to pay the pocket change for a legitimate ad on this site. But thanks for the warning never to do business with you!
It's not empty. It did load after a couple of second, I just closed it really fast. https://www.youtube.com/watch?v=3kfOB2bFNFE#t=2406 Alos 1.8s to load the page is still kind of a lot to be honest.
Awesome!
&gt;Don't waste your money on the biggest instance on amazon if you only have a guaranteed 10 users. yup, pretty much this. just deploy on some server and switch to another setup when you need it. but if there's no need, why even bother?
I did not communicate very well lol. I have 1 week to prepare, 30 minutes to do the actual presentation.....
count() can return 1 in certain situations where you pass in a non-array/non-Countable-object. Weirdly, count(false) === 1, count(true) === 1. Took forever to figure out why: if(count($dbresult) &gt; 0){ // Process the dbresults } would fail trying to iterate over $dbresult. If $dbresult === false, count() will return 1.
K, I will
Thanks and really sorry about that. I didn't know that it was messed up. Have fixed it now.
I'll be posting a video screencast of my Laravel forge test drive later today. What I'll do is: * Deploy to DigitalOcean using Forge (yes, I don't mind paying 10$ for the sole purpose of a test drive) * Try to replicate the setup using free PuPHPet * If there is time left, I'll try to give some tips onimproving the setups This is going to be a blind test drive, meaning that I've never used none of those things before, so it might be useful as a tutorial also =) **EDIT**: Here is the video: http://www.reddit.com/r/PHP/comments/260tqp/video_test_driving_laravel_forge_how_does_it/
Kind of off topic, but I'd like to point you to SOAPUI for testing soap services. (It's for developers of soap web services)
I've used monit for a couple years now. It's brilliant!
Cool! Should note you will only be replicating the bare provisioning portion of Forge, which is only a small part of it. It handles "push to deploy", queue management (starting, restarting, stopping queue workers), SSL configuration and switching between installed certificates. Installing and uninstalling Github repos with migrations, etc.
Not by default. However, you can customize the deployment script however you want. If you're using Laravel you can wrap it in `php artisan down` and `php artisan up`.
Curious: how did this bite you? Since PHP duck-types everything, getting strings back usually isn't a problem. AKA: # php -r 'var_dump("123" + 1);' int(124) 
If your bucket has 0 drops of water in it, it *is* empty. ;)
Well: * PuPHPet is kind push to deploy * queue management. A centralized GUI is convenient, but it's not something that you tend to do every day. Easily done in the shell too. * Auto SSL install is kinda cool, but still easily done by hand. Swithcing SSL certificates is something you'd use really rarely * Managing github repos is really trivial, and you can configure a git hook to run whatever you want on update. ---- Quick question: since each user can install as much stuff as he likes, is there something preventing account sharing?
When I see something like this, I generally look to Derick Rethans or Will Fitch and see which way they are going, as I know both of them, had beer with both of them, and respect both of them and their opinions. They don't necessarily always agree, but they are good initial barometers for me.
there's an audience for that?
I'm adamant the strict type checking of `in_array` should be on by default. This has caught me out a few times.
Where will you be posting this?
Here on /r/php
The point of cloud computing is to be flexible, not cheap. If you don't need to spin up new servers on a five minute notice, you shouldn't be using EC2.
The fact that you've been upvoted this much for explaining the 'bug', makes me feel not as bad for falling victim to it when it was obfuscated by lots of other code.
Me too, then I talk to my coworkers or even better go to a conference and feel all better.
Or look under the hood and try to understand what Laravel is doing for you.
Can vouch for Hetzner. They have been in business for many years, long before AWS was a thing and VPS were still on whiteboards. I know of at least 2 businesses, 1 in South Africa and 1 in SE Asia running on Hetzner.
I do all my development and version control in a linux vagrant box on windows. I still have git installed on and usable through the command line, but that's primarily so my IDE can use it, not me.
Working on Windows PC. phpStorm IDE + localhost LAMP + 3 types of browsers for testing and everything seems to be ok. Of course you need unix server for some platform specific tests. 
Congrats on this. What a massive undertaking! I haven't dug into it yet as I'm planning to let Jeffrey Way do that for me. But I'll probably start using this for freelance projects, and from what I can tell I'd say there's a good chance we'll be adopting it where I work.
Very cool. I went through and deployed a server. Worked as described. I really, REALLY like it. A couple of questions / comments. http://forge.besnappy.com/laravel-forge#sites-1261 Does that mean I can only deploy from Github? There's no repo on the server itself I can push to directly? I couldn't find anything that said one way or the other. Scaling How do I scale a server or can I only do that from my provider directly? Contrast Perhaps my laptop and external monitor are both a bit shit but some parts of the site are of such low contrast that I can barely read them. I found myself straining a lot to make out text, like on the tabs under "Server Details" and other places.
currently, I am using ubuntu 14.04 for development, and have been with it since 10.10, so far has no problem with it. all tools is stable enough to be used for development, the console as far as I know is similar to OSX since it come from *nix family
Well I use a mac, but if was stuck with windows I would buy and install VMWare and install Linux (Ubuntu 14.04 or Debian 7) on it and use that. You may even be able to install mac os x on it if you can get hold of the os on disc or USB. Check this: https://www.youtube.com/watch?v=_dHOvA5wWkU
Last time I tried, about half a year ag), Windows and Vagrant didn't got along very well. Maybe I should give it another shot. (I use Vagrant at work)
Ubuntu. Personally I'm still on 12.04 but any LTS release should work well for you. The entire thing will feel more familiar if you're coming from OSX. Re: Productivity - I used Windows for years and felt horribly unproductive until Windows 7 came around. With 7 I felt like I was very productive but required a ton of hacks to reach that point, git bash, mingw etc.. I eventually realized that I was spending so much time in my IDE and linux shell style Terminal that the rest of Windows was basically irrelevant, made a hard switch to Ubuntu and won't ever look back. I had used Linux server side for years so I had some familiarity with things but the initial learning curve with going to a full linux desktop was still pretty steep. Just getting nvidia drivers properly installed and stable took quite a long time. Drivers, drivers, drivers are a pain in the ass. I'm very glad I forced myself to really update my skills though, I find now working with everything is very much 2nd nature and I've reached that Nirvana where I boot up (fast) and can be productive within a few minutes.
I don't doubt the stability. It's just the user interfaces looks like an afterthought. I know it's superficial...
I use console2 as a terminal. I have installed git for windows (although I mostly use Mercurial), so a lot of linux programs, ssh included, comes with it. I use vagrant to create linux virtual machines and I have a shared folder where files will be shared between the virtual machine and the hosts machine. So I can edit my files from gvim in windows, and run them in linux in virtual machines. 
Although I have 8 gigs of RAM, running a full blown Mac in a VM looks pretty hefty. Resource wise. I'm gonna try it.
Please note that I am actively soliciting civil, considerate comment and criticism regarding the [Action-Domain-Responder pattern](https://github.com/pmjones/mvc-refinement), especially if you are already doing some or all of what the pattern describes.
I'm inclined to believe that this comment is the most reasonable of the lot. This just feels like a big troll.
I used to be a huge Linux guy, mainly Gentoo. I just don't know if I still have the energy for it. Even tho that was years ago, I still remember 40% of the time in Linux was just fixing issues. Chances are that that's all in the past now.
Install mingw. I use mingw + komodo for development.
Run a Linux VM. Set up Samba.
I think I'm probably gonna adopt this strategy.
I don't think so. They never had complete control (no matter how much marketing said they did). In fact, for a long time, they were looked down upon by a large segment of the community. They were (and still are) very significant contributors. But that doesn't mean they have control (lots of companies and individuals contribute)...
Wouldn't it be easier to just use Vagrant at that point? (Honest question) 
I've always used Windows as a development environment as has pretty much everyone else I know. I personally use WinSCP/Putty &amp; Notepad++ and just work remotely from whatever Linux server I'm working with at the moment. If a Linux console is something you absolutely must have you could give [Cygwin](http://www.cygwin.com/) a try.
Am I the only one more concerned about the absurd `&gt;` `&gt;&gt;` `&gt;&gt;&gt;` `&gt;&gt;&gt;&gt;` `&gt;&gt;&gt;&gt;&gt;` quoting structure of that attrocious 1995 forum than I am about the drama over this RFC? Please, I emplore you, if youre site uses `&gt;` `&gt;&gt;` `&gt;&gt;&gt;` Or Re: Re: Re: Re: Re: Re: Delete it from the internet and start over :(
I've run into some issues with it too - weird permission problems if you run VirtualBox as an admin one time and not the next, stuff like that. But it beats the hell out of developing natively on windows.
How do you like Unity? I know there is some great controversy around it. Have you checked out Mint? 
&gt; Please, I emplore you, if youre site uses You do realize that this is a mailing list we're talking about, and not forum software...
Someone recommended http://simplecartjs.org/ but it is js and am unsure about what is best for this either js or php.
I just saw your updates to the README. It looks like your way ( $h = $this-&gt;escape()-&gt;html; ) is even better than the approach in my parent comment. Very nice, I like it!
Check out Gnome 3. Personally I feel like it's the most productive DE I've ever used.
&gt; You're implying that php should know that you either want to reduce the whole array and compare its numerical value to your number or you'd imply that php compares the length of the array. Same goes for the object vs array comparison. I'm actually advocating for the exact opposite. PHP *shouldn't* allow me to write such a comparison in the first place. Yet it does, and it does so without a warning and as a result it does the *wrong* thing.
Haven't checked out mint though I am aware of it. I'm more of a consumer than a power user on linux. From what I can tell of mint, it's back into the "Ohhhh this theme / custom build looks awesome!" kind of desktop environment and that feels like the old days to me. I can't help but get the sense that this kind of thing is just begging for bugs. I'm probably being unfair and should give it a shot, just haven't yet. I just want something that looks pretty and works. For me, Unity works great. A lot of the things I've read about it feel a bit contrived and rooted in legacy.
So we have a sales and marketing guy from some unknown company [that just so happens to be a PHP host] giving a sales pitch on the virtues of PHP, and yet somehow managing to avoid any actual technical details? No thanks... /u/macinnis23, you're spamming; please see [reddit's wiki on self-promotion](http://www.reddit.com/wiki/selfpromotion). 
I use Cygwin and run mintty as a Terminal within windows. I have everything else I need installed via Cygwin.
You sure post a lot of your own stuff.
Sounds to me like you're not really interested in learning PHP, but rather wanting a step-by-step tutorial for creating a shopping cart. There isn't such a tutorial, and even if there is, **don't**. Building e-commerce software is not something a complete newbie does or should do. Going that route is begging for trouble, both for yourself and whomever happens to use the service. I'd advice you to hire someone with experience in the field to do it instead. 
Yes and no. I prefer to manage my own VMs and I'm not a neanderthal so VirtualBox is way better than Vagrant.
I don't remember specifics now. Debugging drunk probably didn't help. 
From my point of view the Jedi are evil! Other than that, you're right, it should not allow that.
Same here. When I used to dev on Windows, I just used vagrant. You get a GUI, and all your command line Linux tools. Best of both worlds. I ran Vagrant on Windows 7 and 8 without issue. It's what I use on OSX as well. I don't even remember the before time without Vagrant. I assume it was awful.
You could use a recursive function that take the key and values of the array a concatenate them on the final result, or use php std [recursiveiterators](https://php.net/manual/es/class.recursivedirectoryiterator.php) to get what you want 
The book "Effortless e-commers" by Larry Ulman has a nice tutorial about how to build one.
&gt;Deploy to DigitalOcean using Forge (yes, I don't mind paying 10$ for the sole purpose of a test drive) You are going to use $10 worth of DO VPS service in the span of a few hours? That's worth watching by itself.
This post kind of made me realize that the $$ I spend on a JetBrains license might not just be for ease of use. It may be actually paying for itself in time that I would have otherwise lost. (not saying there aren't free IDEs that can autocomplete "__construct()" but you get my point) 
Your could start doing the presentation to us starting by telling, how exactly Laravel is superior to "WP/Dupal/Joomblah", giving that they are very different beast on their respective context? You are saying that your company is a CMS-heavy shop, Laravel is not a CMS is a framework, are you are planning to make your team build their own CMS solution with it, or they will start using the framework to selling something else?. 
Laravel Forge costs 10$/mo to use
To expand a bit, Vagrant has a concept of "shared folders", which are accessible to both the host OS (Windows) and guest OS (Ubuntu probably). So your folder at c:\users\bob\projects\mysite\www can be accessible to the VM at /var/www. That way, your Windows programs can edit your source files that are being run on the VM.
quick and dirty : https://gist.github.com/chadicus/6e29f8441340924420b9#comment-1231271
Your confusion is understandable, but the content comes from the internals mailing list. That site is just wrapping it forum style. http://news.php.net/php.internals/74268
Yeah I read its illegal Thanks
srsly?
* [PuTTY](http://en.wikipedia.org/wiki/PuTTY) * [CMD](http://en.wikipedia.org/wiki/Command_Prompt) * [List of DOS commands](http://en.wikipedia.org/wiki/List_of_DOS_commands), I don't think that you will need these commands * [Composer](https://getcomposer.org/) * [Notepad++](http://notepad-plus-plus.org/) * [Aptana](http://aptana.com/) * [Eclipse](http://www.eclipse.org/) * [Git](http://git-scm.com/) * [FreeBSD](http://www.freebsd.org/), as server * [EasyPHP](http://www.easyphp.org/) What else you need?
Yeah, developing for LAMP on Windows is like developing for .NET on Linux. Well, not quite that bad, but you get my point. People who are developing a web app on Windows are usually going to use .NET. And if someone is going to develop PHP (or Ruby, Node, etc.) they will usually be on Linux or OS X. So if your new machine is a dedicated development machine I would strongly recommend dual booting Ubuntu or something.
&gt; queue management (starting, restarting, stopping queue workers), Does this include the new `--daemon` switch in 4.2?
I can't agree with this more. Every programmer I have ever worked with used Windows as their main OS. The only Mac's where I work are in the art department. 
If you're trying to scale big enough that you need an 8% memory reduction, PHP is the wrong tool in the first place.
vim + tmux + zsh + SSH. On windows I use Chrome Secure Shell.
If you need to work in node.js, then the shared folder thing might not work for installing packages using npm. And if you have to run apache from the virtual machine, you might want to disable sendfile option for apache. It can be done via a EnableSendfile Off in .htaccess or from the httpd.conf file.
Bare in mind that you can theme everything to do with it. My Ubuntu looks pretty epic if I do say so myself. But that's the beauty of Linux, you can modify it to suite your needs perfectly. Besides which, for productivity Ubuntu absolutely kicks the figurative crap out of Windows, IMO anyway.
I could not agree more with this. I'm quite shocked by just how many people are saying they use Windows and work around with loads of extra software to make it... act... like Linux.
This entirely depends on what software you're trying to use. What distro did you pick? What software are you using? What specifically feels unfinished (I totally agree that sometimes it is the case)? Maybe some people could suggest alternatives that are more mature or stable then.
Sounds like you're asking for about 50% or more of how this application works. To save, you're going to need some sort of backend. The most common backend you'll find for what you're asking is a database layer (commonly MySQL), which saves each "task" or "entry" (whatever you want to call it) in the database as a row. These rows can then be accessed by the row ID, username, date, etc. (whatever unique identifier you assign to each entry) to display said information. There are other ways to do it, such as flat text files somewhere on a server, but either way you'll need a backend to handle the various entries you'll be receiving. PHP is absolutely one (fairly simple) way to handle this backend, as it handles HTML forms without much additionaly knowledge or logic. Either way, you are opening yourself up to a much larger pool of information and technology regarding the safety and security of what you're building.
Thanks !
Thanks for your detailed reply
Sorry, should have mentioned I do generally run Debian. I was just proposing something I use on my Windows partition. 
Yes, completely agree...
I was the same as you and I switched to Ubuntu because...well Windows is awful. I love my setup. I highly recommend switching over to Ubuntu 12.04 I do enjoy the command line parts of ubuntu tho, don't be afraid to get stuck in. 
Well for one thing, using a tool for it's intended purpose isn't a workaround. If you work in a programming capacity 100% then sure using Linux exclusively works great but if you also, design, write reports for a company that uses a mix of Windows and Macs and have to support windows software then you'll end up using workarounds 9 times out of 10. That said, I'm entirely comfortable with my setup.
I like the narrative, but I think that "windshield color" is over-exaggerating the impact of what's being discussed. A more appropriate analogy could be tires (racing slicks vs all-weather tires). Or possibly fuel (racing fuel vs super unleaded). Meaning that there are non-superficial tradeoffs being talked about. It's not a pure bike-shed argument (there are technical merits being balanced).
If you work at a college or university then you're probably familiar with the frustration that the fucking Preview causes when it decides that it'll go ahead and open every file regardless of whether or not it supports advanced features of that format or not. And of course there's got to be like 5 or 6 people on campus who use macs exclusively.
Ouch. 
I don't happen to work for a college. Though I went to one. And they used Windows based PC's. The digital art department used Mac's though. I am not sure what you mean by "Preview." Do you mean preview in Windows? I am not sure I have come across this. I usually specify what programs I want to do what. And if a file isn't associated, I usually just tell it to use Sublime text since I have had good luck with that. 
That's an excellent point. It does frustrate me a lot not having things like Office and Photoshop on Linux. But for me I do rarely end up using them as my job is purely a developer role, so in my own time I don't tend to practice the use of those things. Very good point.
I've found Linux Mint to be great. It's stable right out of the box for my current PC. I switched from Windows years ago and I haven't looked back since. TBH I've found every Linux distro to require some command line fu, but Mint has always proven the least cumbersome for me. Also, I don't know that developing on a Mac is the standard. I know a lot of folks do but standard, no. Many people develop on Windows or Linux boxes. The Mac is a good platform for designers, but for a PHP developer I'd personally recommend Linux.
[The Mac App, Preview](http://support.apple.com/kb/ht2506), it's both great and terrible. It's great in that a non-tech suave mac user doesn't have to worry about updating Adobe PDF Viewer every 3 minutes but it's terrible in that it'll go ahead and open a PDF with advanced fields and *look* like it's working but it'll either be non-functional or simply won't render the PDF properly. Then I get blamed for it not working :/
I'm on Fedora using Gnome 3, been my DE for about a year now. I never really did any 'real' development - so I was getting along just fine with Sublime Text in Windows. As the work started racking up and becoming more complex I realised I was going to need things like Git, Composer and Node etc and it was obvious a *nix environment was going to be better, and I've never looked back. I did originally try out [Elementary OS](http://elementaryos.org/), however it's based on an older (although still very much supported) version of Ubuntu. Only reason I couldn't get along with it was because I'm one of those people that needs the latest versions of software, which I sometimes found I couldn't get with a few things. If that wont be an issue for you, you may find it suits you. While some call it a Mac OS ripoff, it holds its own quite well and has an actual ethos behind it's design rather than to just look like a Mac - basically to get the interface out of the way so you can work. I'll certainly be checking out Isis when it comes out. 
Use cygwin + mintty for command line stuff. Do all development in a vagrant box. Development on Windows is a giant pain in the ass. Using those 2 will help lessen the pain.
I'm going to suggest a Windows-based PHP IDE that I have used and really enjoy; I will promptly be downvoted however. I use [Microsoft WebMatrix](http://www.microsoft.com/web/webmatrix/). I primarily develop on Windows machines, and quite possibly migrated from coding in notepad++ to using WebMatrix since it's first version. It has syntax highlighting, intellisense and code completion, and links to the PHP documentation when you hover over a standard function. It utilizes IISExpress 8.5 with supports URL Rewriting for MVC frameworks and have used it with various MVC implementations, including Symfony. It manages PHP versions for you so you can hot swap versions from 5.3 to 5.5 in an instant. Plus, the Find-in-Files functionality operates just like in Visual Studio (I am currently employed for C#). When I need to run the site, I just hit the Run button and WebMatrix will run the site in any browser I have installed like Chrome, Firefox, ie and safari for windows. It integrates with Git so I see in the file directory structure which files are checked in. It has everything I wanted for an IDE and nothing I do not need. Bring on your downvotes. 
Right, he could be developing for a WAMP stack but I was using LAMP here as a shortcut for all PHP stacks (he could be using nginx, some other kind of DB, etc.)
All I got out of this is thank God for /u/nikic, who seems one of the few programmers left who will approach a problem based on its technical issues and actually attempt to harmonize the disparate approaches.
I'm on a MacBook air running OSX but I spend 99% of my time in a virtual machine running XUbuntu 13.10. I've chosen XUbuntu for it austere desktop environment [1]. On my main machine at home I run XUbuntu 14.04LTS. I do not understand how people can work on OSX. [1] http://i.imgur.com/BK2leWF.png 
http://www.reddit.com/wiki/selfpromotion
I do Java and web development on Elementary OS. It's built on top of Ubuntu, so it has all the great features of Ubuntu/Debain, and also has a beautiful user interface and a great file manager. I am currently running Luna on my development machine, but I have a beta version of the new Isis update that's coming soon on my laptop, and it's 100 times better. They are always improving. [Here's a picture.](http://i.imgur.com/Vfx8HVT.png)
Right click the file, click "get info", find "open with", and change the it to adobe reader then click "change all". Now pdf's will always open with adobe's pdf reader. Do this for any file type that needs changed. 
That was the confusion, because the "L" in LAMP stands for "Linux".
I stumbled across these PHP training's and remembered this post. Advanced PHP Tutorials - https://www.youtube.com/playlist?list=PLGJDCzBP5j3wAb2JwheEyf8uep7CXUaD- PHP Programming: Design Pattern Tutorials - https://www.youtube.com/playlist?list=PLGJDCzBP5j3xGaW0AGlaVHK2TMEr2XkP9
Working for me now, thanks.
I'm glad you took the time to explain, it helps me decide. I'm still leaning towards staying with Symfony. I like yaml and the idea of services. I specifically like how Symfony obsessively decouples everything. In my experience it makes it a lot easier to work on one single aspect of the application without interfering much with other things. All the configuration also has the advantage that non-programmers can configure the application - well sort of, maybe. Any way we'll have to evaluate thoroughly.
It is a setting. I have it enabled eventhough I use the single equal sign pattern often for subjective readability. I don't mind phpstorm underlining it in case I did not intend for it.
Practical case: only update a record if the input contains changes, and set updated_at to NOW(). What do I do: I strictly convert the input to an integer. Then I strictly === compare it against the record's value, a string. Result: change is detected every time, and record is updated every freaking page load.
Agreed. Been on Ubuntu since 10.04 and just upgraded all my machines to 14.04 Ubuntu GNOME - well worth the upgrade. Also nice to have the same development/production environments (first reason I really got serious about Linux as my desktop) - but now, going back to a Windows machine (which I used for years) really does feel weird/wrong.
So true - you have to treat your application layer as "disposable" servers will come and go at will and your application needs to be architectured in a way that can deal with that well.
Thank you! I still have a great deal to learn!
Indeed.
Give XUbuntu a try. The XFCE desktop that ships with XUbuntu today is very similar to the Gnome 2 desktop of the Ubuntu of the past. This is a screen shot of my XUbuntu 13.10 desktop but my 14.04 looks pretty much the same: http://i.imgur.com/BK2leWF.png 
I've been writing what you're calling actions for some time, but just call them controllers, or focused controllers as per http://www.jonathanleighton.com/articles/2012/explaining-focused-controller/. 
Figure i'd post these... The tools: * http://bldr.io * http://taskphp.github.io 
I tried using another email address yet the problem persisted. Regarding PHPMailer, I;m instructed to use it =/ I'm using biz.ht webhosting. Could it be that the problem is from their side. And bdw now I'm getting this error: "SMTP ERROR: Failed to connect to server: Unable to find the socket transport "ssl" - did you forget to enable it when you configured PHP?"
I mainly use windows at home and for personal use. At my former job I used mac to development and stuff. In this new job I'm stuck with a windows laptop. Indeed it's not the same, but i've managed a little to make it a little less painful. This is what I use: * [ConEmu](https://code.google.com/p/conemu-maximus5/) * [Git for Windows](http://msysgit.github.io/) * Downloaded PHP from http://windows.php.net/ and installed composer with it's [installer](https://getcomposer.org/doc/00-intro.md#installation-windows) * Installed node with [installer](http://nodejs.org/download/) (for bower/gulp/grunt/etc) Now, with this installed, I used [this SO post](http://superuser.com/questions/454380/git-bash-here-in-conemu) to make msysgit my default shell on ConEmu With all of this I'm able to use git/vagrant/node/php/composer/ssh from console. Still missing some commands I'm used to, but thanks to this post I've found http://sourceforge.net/projects/unxutils/ and I'm trying them right now. I'm still thinking on installing a linux distro alon with windows, but since I'm not the laptop owner and don't want to mess with it a lot, probably not oging to do it.
I've been using Action classes for quite a while. If you don't, you end up with fat controllers which is not what you want. It's the controllers job to distill information from the request and pass that into the action. The great thing about using Action classes is that they can be instantiated from different controllers, which is especially handy when you build a REST API where a resource might be available at /customer/payments but also at /payments. You might be able to solve it with routing but having a route pointing to an explicit controller makes it easier for other developers to trace the flow of the application and since controllers are super slim anyway...
PhpStorm has a built in terminal as well as Vagrant support. I actually don't mind working on Windows for PHP.
Before getting into this post, I know it's not strictly related to the topic of this post. But I would like to address the things you have said in your reply properly, with some real justification. I understand not everybody has the same needs, so, some of this post may not apply to your use case. --- &gt; I use phpstorm, console2, php, apache and git installed locally. They all work like charms, and I don't have to do anything special other than install them for it to work just fine. That's fine, though I am curious as to what you use these things for; i.e. is this for personal use, or for use at work? The thing is, a lot of these things 'provide' parts of the functionality that Linux offers. You augment Windows to support these features. Linux comes out of the box with great support for it all. Hell, you can setup a LAMP stack in a single command! On top of that, there are some differences in PHP when used on Windows compared to Linux, one being that Windows is case insensitive (e.g. file and folder names). This isn't a problem if your production environment is also Windows, but for PHP that's usually not the case. --- &gt; I don't see the need to run a virtual install of anything to be honest, it works for me quite well. This is actually something that can cause a frightening amount of problems. Consider that your development environment is your machine (as you've said it is currently). * What happens if it breaks? *You have to reinstall all of the software and reconfigure it... probably.* * What happens if there is some kind of problem in some software you've installed? *You have to rollback, or reinstall your system.* * What happens if you want to update your system, but it would break some part of your code? *You wouldn't be able to!* Here are some advantages for using VMs: * They are disposable if designed correctly. Take a VM configured with a CM tool like Puppet or Ansible, manage it with Vagrant, and you can delete it as many times as you like, and it should make no difference. You could make a new machine and have your development server set up in EXACTLY the same way in about 10 minutes, if that. (Also, another advantage of using Vagrant and a CM tool is that you can version control your development servers too). (ALSO of note, you can use those same CM configurations to configure your production servers if you do it right). * They are transferable. In a similar point to the above, you could copy and paste a VM to a new machine and it'd work fine. * They are replicable, and networkable. You can make 2 or more VMs and network them, on one machine. If you install software natively that would be impossible. This makes it easy to replicate a more complicated production environment. If that alone isn't enough, then consider if you were to work in a team. Also consider you have a production environment that is running a specific version, of a specific OS, that's configured in a specific way: * What happens if one developer in your team *HATES* Windows, or Ubuntu, or Debian, or Mint, or OS X? *They end up either being forced to use whatever everyone else is using, or they use whatever they please.* Well, that doesn't sound too bad right? Wrong. It is very bad, your development environment should be as consistent as possible with your production environment (i.e. same OS, same kernel if applicable/possible, same software, same configuration). It is the best way of being able to tell if you application will run in your production environment. If you were to use what I had mentioned above (Vagrant and CM tools / equivalent) then ALL of your developers would be working in a consistent environment, and they would get to choose any OS that worked with those tools. No brainer! To keep your developers happy and your application running properly, VMs, or similar methods of encapsulation are incredibly useful tools. --- &gt; If I switched to Linux I would have to "work around" the fact that I can't run a foxpro application native and can't run office native.. while I don't have a -lot- of work with those, I do need them from time to time (office more than foxpro).. enough so that I would have to make allowances for it in linux. not worth the effort when everything works just peachy under windows. I have had problems with this in the past, I'd have liked to maybe use Office, or Photoshop; but can't on Ubuntu natively. While this is occasionally a pain, it's not something that really bothers me 99% of the time. I am a developer, I develop, I don't deal with office work usually, and I'm not a designer so I don't need Photoshop most of the time. I solve this problem by using SSDs and dual booting. It wastes almost no time (maybe 30 seconds?) and I get the best of both worlds. This completely eradicates all essences of 'work-arounds'. I get the massive benefits of Linux and the use of any Windows software I may need from time to time. (I mean, seriously though, GIMP is good and all but the Adobe offering is just so far superior). --- Apologies for the essay, just wanted to ensure I properly addressed the things you've said.
Have used Mint and Ubuntu, but currently on Ubuntu. I really like Mint, but there's just something about Ubuntu that makes me go back to it. Not a huge fan of Unity, but you get used to it after a while, I suppose. For dev, you can't go wrong with either. Both are really easy to setup a lamp stack on, as well as most stuff you'll need for development.
Yii Framework, Symfony
Verify you have the extension enabled by using phpinfo() in your script. Find this line in php.ini: ;extension=php_openssl.dll Uncomment by removing the ; and reboot your server. Have you ensured you can communicate using another program/service through SSL? AKA, is it blocked somehow?
Well I'm using biz.ht as a web hosting and it doesn't show that their anything blocked...
By not anything blocked, you also mean the extension is enabled? If not, you'd need to contact them. Otherwise, I'm not sure then. Your best bet would be to open a ticket with them and see if they can verify things on their end. Your code looks good, worst case, try and test it on another web host if you have one and see if it works there.
In the voice of Bon Jovi: &gt; You give PHP... a bad name!
So does this mean that SSL is enabled? Also, try using Mandrill to send out emails. Still requires SSL but tends to work easier then Gmail. Also, try a different web host. Not sure about biz.ht but you should get a configuration to change PHP and restart services. At least with shared hosting. 
Are you kidding me? From the trenches, I see Hiphop and Hack making PHP largely superfluous in the long-run for the majority of applications. PHP will drift to the likes of script kiddies and Pypy; applications more suited to neophytes, pragmatics who don't care about elegance or readability, and tasks well-suited for interpreted languages. Zend Core, after decades of stagnating and decision-after-boneheaded decision, will have to adapt or die JUST to stay relevant. I've already started porting my core apps to Hack, and I frickin love it! And on the PHP side, I support Zeev and whomever else frickin forking PHP and going their own route. This, and other issues, are definitely worth forking over, and I generally abhor forks.
&gt;I've always used a Mac for development, as it seems to be the standard. Say what? That's complete bullshit. Macs are not the standard, they're just a preference. If there's something holding you to running windows on that computer, just [use a virtual machine](https://puphpet.com/). Then you can have all the power of Linux without having to worry about what your host operating system is. &gt;I know this is a stupid thing to say, It's very superficial but it just feels like every program and tool is still in beta. You're right, that *is* a stupid thing to say.
So similar to what I did to your mom last night then?
&gt; I see Hiphop and Hack making PHP largely superfluous in the long-run for the majority of applications. Good luck with that.
I use PHPstorm but recently found out you can fairly easily set up PHPcs and PHPmd as plugins for Sublime Text 2/3, and they can alert you about stuff like this with squiggly red underlines so you can nip them immediately in the bud (and not feel paranoid re-reading your code over and over again checking if you made a typo somewhere).
some people argue you should almost never put semicolons in your javascript code because it's optional 99% of the time. I'm not one of those people.
well yeah it would be a big developer error if he's using empty() to count something.
Heh, I feel my productivity is down now that i work in a place that has macs. Ubuntu Gnome Remix is still my favourite environment. I guess the lack of a decent UNIX CLI on Windows is a bigger hurdle, though. I'd try to set up an ubuntu virtual machine and talk to it through Putty for your CLI needs.
That port is probably blocked. Talk to your host.
I'm glad to see someone finally doing this. Veterans like me may not need this, but I would have killed to have a resource like this when I was getting into programming. This should be a common practice for OSS, the best way to learn is to tear it apart and see how the thing ticks.
I'd see their side more if i trusted them as stewards of the language.
Cool thanks. I for one like that you have more code than commentary in your articles.
Perhaps this is a question for another thread but what's the difference between Vagrant vs a regular VirtualBox install? Vagrant uses VirtualBox if I'm not mistaken and all it add is some package management? I know it's all the rage but I guess I just can't see what the fuss is about if as a dev you know something about the linux cli. I've read through some tutorials on their site but it still doesn't strike me as anything super special. Edit: typo
That's great! Speaking of `--daemon`, is there a way to use it without bringing the application down (i.e `artisan down`) everytime I need to restart it? Can I somehow signal the process (e.g by using [pcntl_signal](http://www.php.net/manual/en/function.pcntl-signal.php)) to stop accepting new jobs from the queue and exit as soon as the currently running jobs finish?
Bookmarking to check it out tomorrow, thanks. I personally have done most of my PHP coding in vi through whatever terminal is most handy. The disadvantage is that I've never had the features of a fancy IDE; the advantage is that when I was on vacation, camping in the middle of nowhere, and there was a crisis at the office, I was able to fix the company's servers from my Android phone with an ssh client.
Define "complex". Seems to me "more than one way to view data" pretty much hits it's limit.
What exactly is your set-up for developing? Do you use Sublime Text as an editor? What do you find is the biggest issue with the Terminal? Is it the MySql side of things or just file management? I would think that PHP development is about as simple on all three main operating systems. 
This thing may be useful, but I would not want to host my apps on a platform that is provided by a Framework author. Because I don't like that the platform has an incentive for making sure that Laravel apps run smoothly and don't care that much about the rest. Apart from that, the only criteria for using a framework, or rather, the only criteria that decide a frameworks popularity should only be how good of a framework it is. With things like this, Laravel is going to get an unfair advantage over other frameworks. People will think like, "We will use Laravel, because Forge". And I think that is really bad. Think of git and github. git's popularity is widely attributed to github. We don't want the same thing happening here. Do we? Now, I am not saying that Laravel is good or bad. I just don't like the possibility of it being judged on basis of an orthogonal factor, that is availability of a hosting platform catered towards hosting apps created in it. 
Wouldn't want developers to have an awesome and easy development experience now would we? :)
Vagrant is a tool for building an environment inside of a VM. It does so by wrapping the command line of a given VM provider (default: virtualbox, but vmware and docker are both supported as well). Basically, Vagrant lets you build exactly what your production environment will look like in a reproducible way--that's important for debugging production problems.
Well, thanks, but I understand that much. That's not what I meant by saying I don't know exactly how PHP works. I meant that I don't know enough about the source code for PHP and the engine to determine if 64-bit would be better or NG would be better. It's the actual technical parts of the discussion that cause me to stay out of it. Frankly, I simply can't make an informed opinion on who's right in this case
Awesome thanks!
I think the key thing to remember is different developers have different levels of devops experience and thus different use cases for Forge. Some things that you say you can do "easily" doesn't come easy to a lot of us. I'd rather spend time coding then manually installing SSL certificates and setting up queue management. Anyway, looking forward to your comparison.
3 or 4 years back, "awesome and easy development experience" was provided by things like codeignitor. Two days back I had two work in something done in Codeignitor. Oh the..Horror. The point is, "easy development" is not everything, and people who still think that it is everything and do not try to see other aspects of the solution or problem are probably amateurs. and people who promote that idea are bad for the development community as a whole, IMHO. 
So what exactly are the main advantages over Xampp? Is it that you have more access to the nuts and bolts? Is it more a toy for sysadmins than web devs?
Is it not (generally) better just to have a test build on the production environment?
If you're comparing Laravel (or any other modern framework) to Codeigniter then either you're being unfair or you are not knowledgable about how modern frameworks have evolved beyond Codeigniter. &gt; Two days back I had two work in something done in Codeigniter. Oh the..Horror. This is the developer's fault, not the framework's. Plenty of shitty code has been written in the history of PHP regardless of the framework. AND, plenty of awesome code has been written regardless of the framework. Laravel doesn't magically make you write awesome code - people write crappy code in Laravel too.
A "test" on production? Hell no! You should have a developer environment, a staging environment, and a production environment. The only code that should ever touch production is code that has been validated through your staging environment, and you should do your development *only* against your development environment. Anything else is craziness!
Different apps require different software to run. For eg, one of your app may be running in live on a php.5.2.17 and mysql 5.0. So you better develop locally using the same versions. Another of your app may use newer version of the same. Another app may be using php and postgreSQL and yet another may be using php, MongoDb and MySQL, and yet another may be using node.js and Apache cassandra. You can easily see that having and managing and more importantly, safely switching between multiple versions of multiple software in a single machine is not easy. So using a separate virtual machine for you different apps catered exactly towards running that particular app make sense. If you want to know why matching the versions of software with the live environment is important, it is because if you are running a newer version of, say mysql you may end up depending on some newer feature that is not present in the old version running in live. You won't know till you try running it in live, at which point you will have to undo a lot of your work based on the new feature you used. If you work in windows, and your app runs on linux you will have additional problems to worry about, like path separators being different, some php functions not being available in windows, or work in slightly different manner.. What vagrant does is this. Vagrant can read some settings from a configuration file and create a virtual machine with those settings correctly configured. For eg. If you want your virtual machines ip addess to be 192.168.1.10, you can put it in that configuration file and vagrant will take care of correctly setting it up. I don't know the specifics of how it does it, but it does it pretty well. Vagrant depend on software like Oracle Virtualbox to actually create the virtual machines. If you keep a virtualbox gui open you can actually see the Vm's being created by vagrant. 
&gt; If you're comparing Laravel (or any other modern framework) to Codeigniter then either you're being unfair I am just pointing how perceptions can and will change. So we don't want to get tooo tied up with anything. Of cource if there is a HUGE advantage in doing so, then fine, let's get tied up. But in this case, I don't think there is. &gt; This is the developer's fault Have you seen how it (CI) load 'libraries' using prefixes and stuff?
/u/i_make_snow_flakes Just came to know you are from Kerala. Can you ping me on twitter @harikt ?
sorry, i didn't mean exactly on the prod itself but more as you say a "staging" environment. Would your point above be that Vagrant is well suited to act as a staging environment?
&gt; I am just pointing how perceptions can and will change. So we don't want to get tooo tied up with anything. fair - so don't get too tied up with anything. Use forge if it makes sense to you today. If in 3 years time....or 3 minutes time it doesn't, then stop. &gt;Of cource if there is a HUGE advantage in doing so, then fine I don't see a "HUGE" advantage here, but I do see something which saves me a not-insignificant amount of work. And if it turns out that I'm wrong about that... what's the harm? 
If you're gonna be a back end developer you should dive in and just install Linux as your main OS. Aside from the tool set just being better for development, you'll learn your way around and be way more comfortable setting up/working on prod boxes. It's a pretty blury line between sysadmin and dev when it comes to LAMP.
I flipped it and switched to running Linux (Ubuntu and it's flavors) as my primary OS. Then I run Win 7 in a Virtualbox VM when I need to use Photoshop and a few other Windows preferred tools that I have to run.
If you are developing in an exact duplicate of your staging environment, it reduces the failures that happen when you *do* go to staging. Additionally, if you have several developers working on something, you hand out a Vagrantfile and everybody now has an identical working environment. And by identical I mean every pecl module, every php.ini setting, everything in my.cnf, bash variables, versions of packages, every single thing that can go wrong between developement and production. It's so so so much cheaper to write some code, run some tests and instantly see it break because you were expecting some module to exist when it doest, or to have that pecl module installed locally and not realize it might not even be on production/staging. 
&gt; so don't get too tied up with anything I was actually referring 'tied up as community' not as a single Individual. Suppose there were a similar service for CI during the time of CI. I am sure that half or more of the Laravel projects started during that time would have gone with CI, because there is a hosting provider catered to running CI apps. Right? So it means, we will be dealing with a lot of CI projects today than we have to deal now. That is what I meant..
Really, really good answer. I have but one upvote to give. 
Since laravel is built upon symfony components you're eventually going to examine these?
Don't listen to this guy, there is nothing wrong with any host OS choice, Windows Mac Linux... Doesn't matter. However as others have said, running your dev environment in a vm is crucial and works on any platform. 
I don't think you give the community enough credit. If Laravel turns to shit, I'm reasonably certain that developers will leave it in droves regardless of how many shiny productivity tools it has. It might be that any future "son of Laravel" projects need to have similarly shiny tools in order to gain meaningful traction but this is a good thing as it drives us forward. If frameworks were not innovating we'd all just stick with old stuff. 
This may not be the best answer - you'll know when you need it. If you're happily coding away on basic sites and CMSes like Wordpress on a local XAMP/MAMP server and SFTP-ing onto live sites, you likely won't care about Vagrant. And maybe you don't need to. But one day, you might be working on a more complex PHP app. Everything works fine on your machine, but things break when you run them on the server. Upon investigating further, you find that a PHP extension on your machine isn't installed on the server. Or maybe an apache module hasn't been enabled. When that day comes, you will probably go "dammit, I wish there was a way to have the EXACT same LAMP environment on my machine and the server" That's when you need Vagrant. 
 foreach (array('Event', 'Exception', 'Routing') as $name) { $this-&gt;{"register{$name}Provider"}(); } Really? That takes more lines than splitting it out would have taken.
Why run Win with Linux inside it when you can just run Linux? Personally I think having a dev VM that exactly matches prod is OTT, and practically impossible if you consider multiple web/db servers, caching layers, load balancers etc.
I'm going to be deploying my first Laravel app in the next few months. I was thinking about using DigitalOcean. So this product might be of interest to me, but I'm not sure I understand what I'd be getting out of this. I'm already using PuPHet, Nginx and HHVM, but those are a one time setup anyway, so that sounds like little value for a recurring fee. What does "Push to deploy" mean exactly? You pull from Github (which I don't use), and... and... what? Anything else? I might want to run `composer install` and my `gulp` script. Maybe one or two other things. Those I'll have to manage myself regardless. The rest sounds like fluff. If it this saves me time on a monthly basis I'll be happy to pay $10/mo for it, but I need some more to go on here. Show me the backend. Give me a video tutorial displaying all the features you have to offer. Compare and contrast it to what doing it by hand would look like.
I'm actually one of those few people that likes GNOME 3 :) So stock Ubuntu GNOME 14.04LTS is perfect out of the box. I do hear good things about XFCE though.
One good use of Vagrant is when you have more developers and may be they are not good system administrators they can boot a system so easily and start working on the exact same environment. ( Think about more than PHP installed, like a workers and things like that )
Definitely create a non xampp installation, either in a VM or on your Linux install. &gt;but as of yet I haven't found any major advantages with using Linux tbh If you're using it like you use windows then you wouldn't, I guess it's mostly the power of cli. 
knowing php is important in this case, because knowing the basics is extremely important. if you don't know the basics then it is destined that you will fail. it is just a matter of time when it will happen. also by knowing the basics, you know how it works, how you can improve it and make it better. i am a computer science graduate and we had a course computer architecture. the teacher told us that, the point of the course is not to make us into the designers of microprocessors, but it was to give us an understanding of how the system worked. when we face a problem, we should not just throw out the system and get a new one. we should know where the problem should be able to fix it. suppose i write a program, and i learn that it is processing at not the speed that i want. what i would do is that i would look at the specifications and see how is it that i can make my program faster. it is similar with php, and laravel. we must know php in order to understand how laravel works. just building things is not enough, we must know how our actions affect others, or we will hear more of systems being hacked and how the developers are not doing anything about it.
You caught me installing some new stuff on the server - it should load faster now.
You're welcome to use the code, I've written to host this, for that. I write the articles on Medium, and this app has a command which pulls them from there, cleans them up somewhat and writes view files. It also converts that to Leanpub markdown so you can send it straight to there for generating e-books. I want to blog about the process - it's write interesting. Especially converting the HTML to markdown...
Because this follows the DRY principle, it's scalable, and readable. Clean code isn't always about the number of lines.
I agree on the article, but still i would not recommend a beginner programmer to build his/her projects from scratch, its going to fail hard. The reasons its going to fail is most likely that basic stuff every application needs can be hard to get right, even by professionals. (Think security, auth, xss, sessions etc.) Thats why i would recommend to use tools that exist but learn PHP when you go. Using something like Laravel or Symfony lets you see the FW code and learn from it. Building basic composer packages, and learning how to re-use your own code in your applications is also a very good way to learn modern PHP.
I run Linux as my main OS, but my development machine has newer versions of PHP and Apache than staging/production. This is annoying, as I develop code that passes my unit tests on my machine, but fails in staging. Having Vagrant running the same versions as the target environment sounds like a nice solution to me.
Now the frontpage seems to be up, but the links to the chapters gives an error.
Great, now its working. Good job!
It goes both ways. For some, learning the best practices early on through training wheels (your framework) works great for them. For others, focusing on the language first works great, especially for those who want to know what's going on in their applications. I would say though that launching a from-scratch application, and seeing it break, then going through the frenzy of fixes is the best way of learning not just PHP and any framework, but of web development and deployment in general.
You do know /u/pmjones is rather active in this subreddit as well. He's not just spamming with his own content. He's actively contributing to /r/PHP with his OC.
Fair enough, thanks for taking the time to reply. :) It is just interesting to see the differences in environments and requirements. 
It's now also running on Forge.
Thank you. Looking forward watching this interview!
Still broken for me when clicking on chapters
Probably not the best time to learn how to use Forge. :D
I actually use Vagrant instead of WAMP/LAMP/XAMPP etc now because the configuration is generally a lot easier I find. Especially with tools like Puppet. Plus the beauty of being able to easily share set-ups it great. It's really good if you're building environment platforms as well, say if you're using Redis, MongoDB PHP and Nodejs for example. Once you get into the habit of it, it's little extra effort really.
Just curious, what sort of issues do you get? I can only think of a couple of instances where I've had unexpected behaviour across different versions of PHP (ignoring new features, obviously).
I wouldn't necessarily agree that it's for familiarity. There's a fair bit that you can do in Linux out of the box that you can't do in Windows out of the box in terms of command line tools at least. I think the reason they're used is because they're amazing tools for any developer.
The only thing that you cant replicate from one environment to the next is resources. Functionality and Environment can be identical. you could set up a vagrant vm that is running docker, and have a container for each web/db server, caching layer and load balancer all wired together using something like maestro-ng. You'll never be able to replicate the utilization and saturation issues, but thats what sysadmins get paid for, resource management. They really ought to not have to futz with packages and applications.
Do you have some examples relevant to development? The only thing I can think of is Composer and git which you can do in Windows.
Thanks! Not had much contact with them on account of Laracon and all. I think everyone's still recovering... :D
&gt;The great thing about using Action classes is that they can be instantiated from different controllers, which is especially handy when you build a REST API where a resource might be available at /customer/payments but also at /payments. I'm pretty sure many developers already use Action classes, but simply don't know they're called that way, or maybe even that it's a "known" pattern.
Years ago in high school I did this exact thing in C++. 4 hours later I had learned an interesting fact about semicolons.
Not really a DRY issue. The main problem with code like this is that you can't use an IDE to find usages of those functions.
I didn't write that code, and I agree that it would have been cleaner to write out the 3 lines. Perhaps in a later version of the framework...
Not sure I agree that it's more readable or scalable. And unless you mean SLOC, it would have been shorter to write them out...
+ 1 for this. Managers often have a lesser knowledge of programming, and only see the UI side. When they are blind to the mess ive seen in the backend i totally understand why so many shops are drupal, or wp shops. The truth is that these systems are very hard to maintain in the long run, both because often the programmer is a beginner that only has some months of experience, and because many people build on the same site, often without proper communication. Systems like Drupal saves alot of non-content data in the db, making version control is impossible. How many times have i seen a drupal project with zero documentation from the original auhor. Its a mess of php arrays and semi working jquery callbacks. In the end a cms is basically sql queries and a crud interface. You could built a skeleton for your company and build your projects on top of that, making development as fast as with a cms. The other thing i always feel with cms's like drupal is the reverse engineering aspect. You haveto modify the existing functionality to get the result you want, and sometimes a really simple thing like adding a div with a canvas element can be really complex to do, just because the cms does not support it from the box. Both drupal and wp have thousands of modules/plugins but most of them are really bad and unmaintained. And now with packagist and composer the packages you can use with any framework is wide (theres over 30000 packages on packagist).
Or when it tries to tell you what it does and why to use it, but absolutely fails at being relevant to anything by trying to be relevant to everything and as vague as possible. This is from the Vagrant Docs: &gt; Why Vagrant? &gt; Vagrant provides easy to configure, reproducible, and portable work environments built on top of industry-standard technology and controlled by a single consistent workflow to help maximize the productivity and flexibility of you and your team. Man, I might as well read [randomly generater mission statement sentences](http://www.lotta.se/mission-statement-generator/) or... the AngularJS Documentation. &gt; Why AngularJS? &gt; HTML is great for declaring static documents, but it falters when we try to use it for declaring dynamic views in web-applications. AngularJS lets you extend HTML vocabulary for your application. The resulting environment is extraordinarily expressive, readable, and quick to develop. Yeah... but why AngularJS?
We're talking about dev here. Dev runs in debug mode, with profiling on, with caching mostly off, with live editing of files and no deployment procedure between save and f5. This isn't a replication of prod by any means.
remember that you are there primarily because they are looking for a person who fits their team. this advice may sound strange but i think this is more than often forgotten. also bring some knowledge with git with you 