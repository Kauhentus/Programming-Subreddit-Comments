Nothing compares to register_globals. 
Removed. We try to remove this type of garbage as soon as we see it. Reporting it would bring it to our attention faster.
&gt; saying .0 is a BETA release were corrected because that's not how software works http://e.lvme.me/pzv5j7l.jpg
At the company I am working at I am the only WebDev, so I am more than free to choose whatever way I want to go. I started 10 years ago and built apps from scratch. That went well, but was a pain in the ass to maintain. I started making apps using CodeIgniter a few years ago, and when I have to fix something or add a new feature it is still a cinch. Recently I started developing with Laravel, and I must say that it is my framework of choice. You can build so much in so little time, it is amazing. I thought doing stuff with CI was fast, but using Laravel I can do stuff even faster, and having an Auth system built in takes a lot of my plate when starting a new project. Eloquent and relations are a cool way to get data, Blade templates are ok too I think (I've never used templating engines before), RESTful routing is superior to CIs capabilities when using CRUD. Migrations save me from playing around with phpMyAdmin...TL;DR yes, you should use a framework and Laravel would be the one I'd recommend. 
&gt; I'm really curious what problems aren't solved by Symfony First of all, business layer isn't symfony's concert. It provide you a way to use it's infrastructure to build one on your own with good old plain php. Also, symfony covers only the most common problems of infrastructure (and this covers almost 90% of all web applications needs) and allows you to replace/add some other components or implementations when you need to. Look to all this ecosystem around symfony. But sooner or later you'll have an need of your own solutions for some infrastructure problems and you will be able to easily integrate it into framework. Or even build your own framework on top of the symfony components optimized for your workflow.
It can be a little annoying but in reality it often just weeds out the poor programmers from the pack. Most people bashing php have either: 1. Never used the language 2. And/Or did a helloworld tutorial once and think they are above it because they now use nodejs and drink freshly ground coffee You do occasionally get some more experienced developers bashing it which I have no problem with, if you actually understand the language and understand it's shortcomings then fantastic, feel free to air what you don't like about it but these people are very different from those who run around saying "lol php sucks!!!" because they can actually explain the reasons behind why they don't like it. Overall though just use what you want and what is the best tool for the task. There are idiots in every corner of language debate and listening to them is just a waste of your time.
I'm starting to find this out the hard way, got a few models that have multiple relationships and it's becoming nightmareishly slow and i'm having to go through and rewrite large chunks of code. The problem is they make it very easy to setup/write but you pay for it in the long run.
I find there's a trend among the most critical people of PHP I've encountered. It's not all of them, but many of them have never actually finished a single project, ever - they've kind of just coasted along with dozens of abandoned, half-built projects. They only seem to be able to take on making changes to a mature project, and always need to be propped up by someone willing to do the dirty, hard work. The real finishers seem to care a lot less. They leave me in peace and don't constantly whine about things.
I think it's because the entry level is much lower so there are far more people using php so there are countless easy targets. To write something in php all I need is notepad and ftp to upload my index.php to the web. To do the same in node/python you need to be able to setup a server to deploy the application, sure there are some tools that can help you out but in terms of getting started there is nothing easier than php. 
If you can't explain a framework, then how do you expect to build one? To any employer, its cool that you made your own framework, but unless you're the sole programmer, you're not going to be using it. I don't see a time where a client would be asking you about frameworks unless it was in a team of people that are already using one.
It's not something I pay attention to at all; I don't care about whatever programming language I am using on any given day, only that it suits my needs. The last thing I would ever care about is what someone else is using or even less, what they think of what I am doing. Also, I find a great benefit of choosing solutions to my projects above the scope of what language will be used to implement them, the whole idea of favoriting a technology arbitrarily is silly.
Complains from JavaScript programmers about how "bad" PHP is as a language is a complete joke. 
Could it survive being open-sourced? If you think it would then congratulations, you've just contributed to PHP community!
Thanks. I appreciate the response and good luck to you also
I wrote a php program that parses and decodes pcap files, ethernet frames, ip headers and a few others to populate a mysql table with stats. The server was capturing 200gigs of data a day and the php could only handle about 20 gigs a day. I optimised the fuck out of the code and still could only parse about 40gigs. I had to abandon the project because of the performance issues. An ignorant person would conclude " php sucks" A experienced person would point out php wasnt the right tool for the job. A fun person would ask to see the code and would talk about how intersting the project was.
Let them talk. I'm too busy making 6 figures a year to even care.
In fairness, both nodejs AND freshly ground coffee are great. Really though there isn't a language I've used that I can't criticise. PHP's quirks are kind of endearing and really most of it comes down to inconsistent names and that ternary operator thing. PHP still has the benefit of being designed specifically for the web.
&gt;When in doubt, check the manual! Bullshit. The manual is wrong for even most basic of things. https://www.reddit.com/r/lolphp/comments/2md8c0/new_safe_casting_function_rfc_casting_10_to/cm3dpdj https://www.reddit.com/r/lolphp/comments/2md8c0/new_safe_casting_function_rfc_casting_10_to/cm3e156 
I'll have to wait even longer for an MSSQL driver. 
How did i not know about this? I sure hope i kept the code...
Or even PHP 7
Out of curiosity, did you complete the project? Which language did you end up using? I've never had performance issues with PHP (never done anything that would hit a limit like you did) and I'm just curious where you go from there. Node? Java? Scala?
3\. Enjoy jumping on bandwagons. I've seen so many people just shit on PHP with no idea what they are talking about. They just parrot back things they've heard online to sound smart.
I would be interested to see that if its something you can post. Always interested in how people use php to accomplish odd jobs quickly then optimize when it becomes a concern. 
I can't believe the amount of energy you've wasted to a losing battle - you're not going to win them over and they "all" (hyperbole) have made up their mind about you.
&gt; It's easy to get started It is easy to get started in any langauge. For example, in python you didn't even need apache to start web programming. It was only recently Php got its own web server. &gt;as with any language - hard to get good at. Only in php, it is not the good kind of hardness. The hardness does not come from having to acquire a depth of understanding of concepts, but from having to understand numerous pitfalls and gotchas that resulted from poor or lack of design from the beginning. This end up mostly useless outside the context of Php, and even worse, harmfully hiders the learning of better practices in some cases.
&gt;I love it when people go out of their way to invent contrived examples like this Those are only contrived if you lack sufficient experience and does not know how 'contrived' can bugs be when they manifest.
There's a point you hit where you realise the code is not the product. Once you make that distinction you can just get it done. When it's time to extend it, you go back, make it more flexible and keep moving forward again. The most beatiful code in the world is useless if it's never run.
Today I discovered strtotime("first day of previous month"), after 8 years coding many different apps How can anyone not see PHP is bliss?
&gt; What EXACT "pit-fall" are you referring too Please take a look at /r/lolphp for hundreds of them or read the fractal of bad design article or take a look at phpsadness.com. Those are just the tip of the iceberg, and only one reason to not use the language. A toxic community that actively reject all criticism, incompetent developers working in the core are some some other. I have 10 years professional experience working in the language. I am not a passive bystander. Like you I once loved the language and thought that it was fine. But my own experience have changed that. So when I say that If you like programming, quit php asap, I say it from my own experience. If you are only interested in money, then sure, go ahead, for now. 
Yes, that's the reason why you should use "Laravel" (placeholder for frameworks) etc only as your I/O channel and not for your actual application. (see: S.O.L.I.D) unless your application is small, crappy or you do not care at all. I believe that people who put their logic into a framework and don't abstract that they don't care and don't value their time.
"PHP is dying" - 15 years ago
What about the "python interpreter"??? Or is it installed by default on windows nowadays? 
Anecdotes are worthless. Unless you've got a credible study showing .NET having more vulnerabilities per line of code than whatever else you're implying it's less secure than, you've said nothing of value.
Thanks for posting. Now [all my comments](https://www.reddit.com/r/lolphp/comments/3xkhvk/the_kind_of_thing_that_gets_upvoted_in_rphp/cy7cgm9) have been downvoted people from here. Also you haven't replied to my [this question](https://www.reddit.com/r/lolphp/comments/3xkhvk/the_kind_of_thing_that_gets_upvoted_in_rphp/cy9fxwn) &gt;This is what I said just before you replied about whitelist. "What if there is a typo in the parameter array key". Now how did you took that to mean to be a typo in values when I clearly said "array key"? And use it as a justification for trying to ridicule my argument calling it a "nonsense". 
Was that using DOM or SAX-type parsers (just curious)?
Come join us on /r/javascript we're too busy to worry about OO
PDO, dblib, FreeTDS. MSSQL is just fine. 
sqlsrv_*? I thought the drivers only went to 5.5?
Yes. * PHP pays the bills. * Our clients come to us specifically asking for their projects to be built in PHP. * PHP is nearly always the right tool for the projects we work on, but when it isn't, we use something else. * I deal with crap PHP code built by shit developers regularly, I never blame PHP. * I deal with crap code written in other languages too because no language is immune to idiocy, obviously. I sometimes use PHP for quick proof of concepts (sometimes just written sequentially), even if PHP isn't going to be the final language for the project. I'm tired of having the same arguments. It's like telling me that my Nike trainers are totally rubbish and I should have bought Adidas trainers instead. Go away, they fit comfortably on my feet and allow me to run a couple of miles when I need to. If I need to run 100 miles, I'll consider some of the other options first. Please tell me again why you're attempting to scaremonger me from your high horse?
&gt;PHP is the language of MVPs. Not any more. Not in times of when you can get a Digital ocean droplet for $5 per month. 
Looking for any newhires?
Is that 6 figure value a string, or an int, or a float? (It's OK if you don't know yet, you can decide later, like PHP does) disclaimer: I've used PHP for over 15 years and I love it, but the lack of strong typing and the computational overhead this creates is frustrating. edit: a word
Yeah I run production php code all over, so I'm definitely not saying its not for production. I just think the language is really not that strong but everything surrounding it is what makes php the tool of choice for "get it done". If you're literally only judging on literal language I think it's hard to argue that php is one of the better ones. But I don't know any other languages with the sheer amount of libraries, reference code, tools, etc. 
on its own, PHP7.0 is ready for production. for your application, it depends if all your dependencies are already php7-ready/compliant -- these could be php c extensions, or pure php dependencies (eg. from packagist).
I don't suppose there's any other functions that get run when the objects are built, where I could use a different name other than __construct? Or somehow write into the parent object a way to call a child function if it exists (like, add that to the parent constructor, and then just use a different name for the child "constructors")?
Well, good as in it can be up to about $90000ish with some companies ** not sure why this is getting downvoted. I'm just pointing out the average php dev salary in my area. Not trashing the language, I already pointed out above that I enjoy it.
Please explain.
And if they do you can still use the existing code, fork it into your own and continue development on a battle tested framework used by thousands of real applications instead of your snowflake framework used by 1.
Rails is one of he best web frameworks and to see laravel doing similar things is amazing
Php is a beautiful, strange and at times f'ed up langue. But it is such a glorious and misunderstood language that leads people to abuse it. Then those same people with there lack of experience attempt to complain, they ignore the other people around them and forget what a beautiful language PHp is
I would always say use a framework. Never try and go it alone with out. The security vulnerabilities that are created with out one is unspeakable. Testing alone is another topic. If you don't like current frameworks then I'd say use symfony components to build a small framework that is lightweight to have at least a scaffold
Good point, but surely you aren't saying there is still no decent framework for PHP? What's the use case that Symfony can't meet? 
No. Documentation is not enough, community is essential. 
Right, type system is a great tool in design(haskell is an eye opener), I'm glad php7 is making this tool more powerful, you can have expressive and constrained API, and convenient scripting. so, it's about weak typing language, not phpsonal.
Of course. I just generally see that the "real" engineering jobs (not maintaining WP installations) tend to skew towards Python and Node, with some Ruby and Java too. I just declined a very well paid role that would have been Rails and Python (probably Django); I'm pretty sure FB is my only option if I want a similar offer using PHP (well, Hack). Note: SF Bay Area. Not a language fault, it's just not as common in engineering-first companies. I've hired many people that didn't know the language we were using because they were solid engineers. Didn't matter once. You learn syntax fast if you know the core concepts. 
&gt; You do occasionally get some more experienced developers bashing it To be fair, they bash literally everything. Complaining is one of the perks of being a developer.
http://symfony.com/blog/new-in-symfony-2-8-symfony-as-a-microframework It's not "heavy", and it's not slow. If that is your concern you might be better to look at golang or something, the huge advantage you get by using symfony for everything is that you only have one framework to worry about.
It _might_ be as fast a middleware based system. It's still not how I want to architect my app. :)
I have drank the rightway koolaid long enough to see that those are poor workarounds for the shortcomings of the language.
Because if php did break bc, the next version will be dead on arrival. 
jQuery and node.js
We used a full stack system with our own linux distro, drivers, capture hardware, and software. The low level and high performance stuff was written in c, that pushes the packet meta data into a Postrgres DB. There is a Java layer which aggregates and filters the data coming out of Postgres. PHP is used for the web interface and API. And angular front end for rendering. Our best appliances to capture an average of 20 Gbps written to disk. Even with 100TB of storage it would on average only be able to store about 2 days of data.
You don't *need* to learn anything else to sustain a solid career. If you want to open more prospects, learning a JS framework like Angular would be helpful. Yes, I said Angular--in the business world, Angular is still more widely used than React, and therefore has more job prospects. But the technologies you've listed have been solid for a long time. PHP has remained one of the most popular server languages, even as others have come and gone. Everyone is jumping onto the Node.js bandwagon, but in 5 years that may be replaced by some new hot thing. Meanwhile, as PHP has withstood the trends of programming languages, and despite the hatred reddit has for it, PHP is likely to maintain a significant portion of the developer market for some time to come, and you have all the necessary frameworks and technologies that a successful PHP developer needs to know. Therefore I would focus on strengthening what you already know. Learn PHP more in-depth or learn some frameworks for JS/CSS like Bootstrap and Angular.
Can you explain that further? I'm still relatively new to PHP OOP.
hey, I'm glad to see your classes with SQL featured the exact same behavior as a datastore like Doctrine, you got lucky in that and it's always a good feeling when it happens. The problem is generalizing that, unfortunately it doesn't work that way. Had you tried to replace it with something that uses more of an active record pattern, for example, you would have ran into a lot of pain. You realize how even the interfaces you drew up depended upon certain patterns of use that the new library just can't work with, or can't work with well. For every nice, smooth transition because the patterns lined up, there's the 100's of others who had a nightmare transition because the patterns didn't.
Swing and a miss. Six digit salary doing PHP dev work with Drupal 8 here. It's not uncommon.
I'm tired of people who through blind ideology characterize a language as the tool for all jobs, or the tool for no jobs. People who are unwilling to acknowledge either the merits of a poorly designed language, or the flaws in a useful language. Often these are people who only really know a single language with no interest in changing that. They invest a great amount of their personal self-worth in their language choice and so take everything said about the language as a statement about them personally. PHP is a poorly designed language because it was never really designed. It's full of ugly warts, inconsistencies, and plain old bad decisions which are retained in the name of backwards compatibility. Its low barrier to entry results in a community that is unable to stamp out the horrendous dated practices of the past. Its also an extremely useful language. It is ubiquitous and performs well. It has an extremely low barrier to entry but scales well into larger projects. Most of the language issues are only problems either in contrived situations or are created more by bad tutorials and 3rd party documentation than the language itself. I see a lot of other comments here that are suggesting that people speaking negatively about PHP just don't know PHP. The exact opposite is the case. If you can't explain why your language of choice is a worthless piece of shit that nobody should use, you have no claim to know it. This applies to every language currently in existence.
Come on, for a community SO is a worst can of worms. There is a Room 11, but its participants never show up on the main site, and for a reason. For Q&amp;A in PHP SO is worse than reddit. Don't even try to ask a question unless you have enough rep to put a fat bounty on it. 
Whenever there's a benchmark involving HHVM there's someone commenting that [repo authoritative mode](https://docs.hhvm.com/hhvm/advanced-usage/repo-authoritative) should be enabled to make HHVM as fast as possible. So this time I'm this guy: you should try with repo authoritative mode enabled, that's maybe what was used in the benchmark you are comparing to.
&gt; Those are only contrived if you lack sufficient experience Been programming in PHP for over 10 years, in a variety of environments. At what point will I gain the experience necessary to know that this is not a contrived example? $foo = "0d9"; print "$foo\n"; $foo++; print "$foo\n"; $foo++; print "$foo\n";
Wait, what's wrong with the ternary operator?
Not just blogspam -- it's just quoting the [linked Quora question](https://www.quora.com/Why-hasn-t-Facebook-migrated-away-from-PHP?share=1) without adding anything else of substance -- it's *hella outdated* blogspam - February 27, 2012.
I don't know. By sufficient experience I didn't mean length of your programming career. It seemed that you have a naive view regarding how vauge and hidden bugs can be and how they manifest in the most surprising ways. 
Yeah, I'm not doubting that in fact I'm glad to hear that considering I really like the language and want to continue learning it. I'm just saying in my recent job searches the salary has been averaging less than $100k.
He he. Exactly.
Yeah in 10 years I've never encountered a bug and have no idea how obnoxious they can be.... Here's the thing. You know what causes the overwhelming majority of bugs? [Human beings doing weird shit with weird code](https://www.destroyallsoftware.com/talks/wat), rarely ever the language itself. What is weird shit with weird code? The above example is a perfect illustration. Who writes actual, real-world code even remotely similar to that? Nobody. So instead, all we have are CONTRIVED examples like the above, in some stupid attempt to blame the tool, because there aren't any actual, meaningful examples that can be given.
https://en.m.wikipedia.org/wiki/%3F:#PHP People always bring this up when slagging off PHP
phpfreaks nowadays doesn't seem that good. Seen some mod responses to questions that are questionable and dated, though I haven't read the forum in a few months, but that's at least my experience recently in comparison to how it was years ago.
Getters and Setters are methods that are used for retrieving and setting properties on an object. So if you had a variable called "email" you could have a getter called "getEmail()" and a setter called "setEmail($email)" on the parent, and then the child class just wouldn't define them (or if it did define them, it might invoke parent::setEmail($email) before or after doing its own processing - that's how inheritance is supposed to handle this) Then, if you called "getEmail()" and email hadn't been configured with a default yet, it would configure it at the time it was called.
&gt; Php encourages you to do "weird shit" PATENTLY false. Not sure how you can even remotely come to that conclusion.
Ah, that's something I was wondering and hadn't tried yet... if a parent class could somehow call a child function. I haven't learned the "abstract" term yet. It looks important for this to work.
&gt;PATENTLY false. Lol. Well, what do you think the type coercion in php encourages you to do? Oh. and another one https://www.reddit.com/r/PHP/comments/3y0db6/is_anyone_else_tired_of_the_constant_negativity/cy9vhw8 
Org-mode for Emacs. Only reason I have Emacs installed.
Oh nice. Curious to know why not something like Todoist or Wunderlist?
If you're on windows, [get ToDoList from Abstract Spoon](http://www.abstractspoon.com). I have used it for 10 years or more and use it extensively to plan everything through daily shopping lists, programs, and projects and to keep simple reminders.
Aah! Thanks for the suggestion, /u/darkhorz. 
Wow, this explains some things. I've had a few cases where I had to use parenthesis to make it work but didn't know why. I actually started using parenthesis by default just to be on the safe side. Now it all makes sense. Thanks!
And I thought I was the only one weird enough to abuse PHP in that way! I also wrote a pcap dissector, just for fun. Never bothered to check performance; I just assumed it would be awful. The most painful part of the process was having to unpack everything manually rather than just fread into the appropriate struct. It started to feel like rather than writing them by hand I'd be better off designing a pattern-matching DSL that actually compiled to the required PHP code...but then I lost interest. If I were to actually do this in production, I'd just use tshark for the low level stuff.
Simply because it's built right into the OS - one less thing to download and learn. If all you need is an itemized list, a simple text area has you covered. You can even type this into your browser address bar and the entire browser window becomes editable, letting you create an ad-hoc "notepad" that you can easily discard by closing the tab: `data:text/html, &lt;html contenteditable&gt;`
It's actually past the planning stage IMHO, but yeah I use comments to build tests before programming anything serious. I don't know that it makes me more productive, but it makes me control a lot more mistakes. Still it's not so good that I advocate everyone copies me as I'm not into prescriptive workflow at all. In fact I hate people that are, we are all different, we are not machines, we all have different preferences
Which is really a non-issue, because anyone who does ternary chaining, when they really mean to use a switch statement, should be slapped, and their computer taken away from them. This is a classic example of what I mean by people doing weird things with weird code, and blaming PHP when their weird code gives them weird results.
If this is correct, you could make the parent constructor call an init function and simply override that for the child
&gt; whislt our framework holds together - it isn't anywhere as slick as the "hip" frameworks such as Laravel Is this a project requirement? "Must use slick framework"? &gt; We can't just "turn on" xx feature - we need to code it. My manager gets really picky about the smallest of details, so this approach has worked well as we have total control over everything. I'm just wrapping up a WordPress project that has about a gazillion half-broken plugins installed, which got added because the previous developers just wanted features to "turn on". Half of them are abandoned and not compatible with the current version of the core. Now I not only need to maintain custom code, I need to maintain custom code written by a gazillion random people who can't write code, who made those plugins. And I have no one to ask for help if I don't understand why some crazy stuff is done in the middle of the source code. Authors are long gone. And the plugins themselves... I have no idea how or why, but when I disable a Social Sharing Button plugin that's installed, but which *the site no longer uses*, the jQuery script import shoots to the bottom of the list, breaking my Contact Us form. So any tweak to the plugin set requires a full re-test of the entire site, and at least 4 plugins are left in because their removal breaks the site in mysterious ways. I thought I'm pretty good at debugging after nearly 20 years in this industry and dozens of very big custom-written apps, but I've met my match. A medium-size web site written in a bad framework, configured with tons of poorly written modules. Heck, coordinating fail tolerant, eventually consistent distributed services is easier than untangling this mess. So be careful what you wish for. The degree to which you use custom functionality depends on your needs, so we can't judge if your manager is choosing well or poorly. If he/she needs *more control* and not *less control and faster velocity*, then what you're doing at your team seems quite well aligned with that manager's goals. Honestly, it seems like you're working at one of the better PHP companies out there. Too many fall into the "let's slap some shit together in off-the-shelf framework X and put some plugins on it". The result is a project that gets put together faster, and you mostly have no damn clue what's going on in the codebase. Might as well be magic. Maintenance involves prayer before and after any changes to the codebase. A lot of "oh our framework can't do that" is heard when new features are requested. It's fast and fun at first, and then over time it becomes tragic. Kind of like doing drugs. &gt; We also know exactly how everything works and what to change if we need to. It also gives us a good chance to learn principles &amp; design of processes (which I happen to enjoy) - rather than just learning framework syntax. Good, good. :-) &gt; Most job adverts want experience with frameworks - obviously I have none. Whichever route I decide to go down, I want to get a couple of side projects under my belt first and am really struggling with which approach to take. I get the benefits of frameworks (ie saves time, probably more stable &amp; secure etc, good support communities) - but I'm used to having total control and really enjoy designing &amp; understanding / knowing exactly how things work under the hood. Well what you're doing right now is a lot more beneficial to you as a developer. If you want to pick up Laravel or whatever, you can do so over several weekends. It's really not hard. Those mainstream frameworks are designed for developers who just want to get-it-done so they're intentionally made simple. Are they useful in actual projects, depends entirely on the framework and the project requirements. I'm disappointed in responses I see in this thread "in 2015, you must use a framework". This is not an engineering argument, this is just peer pressure into adopting something because the cultural trends are in its favor. Things that are trendy get out of favor even faster than they've become popular, so keep that in mind.
&gt; The divide between 2.7 and 3.x is growing, and more and more people are sticking to 2.7. Care to give examples? New applications being created only for 2.x? New libraries that support only 2.x? Influential people who decided to stay with 2.x? Companies that declared using 2.x past it's upstream support? I certainly don't see any divide growing, but maybe I am looking at wrong places.
Learning a non-web language may help give you some perspective when developing web apps as strange as that sounds. Something like python is easy to learn but helped be quite a lot with learning PHP. I guess by learning the differences, I learnt what PHP _is_ and what it's not.
&gt; they are above it because they now use nodejs and drink freshly ground coffee I don't think JS is the most negative community by far, but stuff like this is kind of funny to me, seeing as we just did a WordPress-based client project for npm themselves. :)
I had a lot of time on my hands waiting for the test suite to run. And I actually turned a few heads. It's good to show I have some logic to my claims and aren't just saying IF YOU DONT LIKE PHP YER DUMB
PHP 7 sorts out inconsistencies in the parser, tokenizer and underlying engine (yaaaaay) but does not solve the inconsistencies in the standard library (boooo).
Nope! It's a great way to generate a comic when I [don't have any better ideas](http://cube-drone.com/comics/archives/php). Some people will say that PHP is not bad. Some people will say that they are too busy making bank to notice how bad PHP is. Some people will say that PHP is bad, but it pays the bills. Some people will say that modern PHP is much better than ancient PHP. I have been, at one point in my career or another, all of these people. I defended PHP! I argued in its favor! I fought the good fight! And then I didn't work with PHP for like five years. I worked in Java, and Python, and Ruby. I did some configuration management and experimented with build tools. I did some shell coding in bash. I built a legitimate honest-to-god Windows desktop product using C# and XAML. I didn't even know that people still BUILT Windows desktop products. I spoke to the holy men on the mountain, put on the monadic robes, and smoked the pipe of the Haskell people. I think I'd still rather program in PHP than Haskell. I guess I would work with PHP again, reluctantly. I don't think I'd ever intentionally greenfield a project in it again. Why would I? I don't write software for overcrowded shared-server hosting environments anymore. Even Javascript with it's asinine prototypal inheritance and [constant needless evolution](http://cube-drone.com/comics/c/relentless-persistence) has got some selling points that would make me consider it for a new project. PHP is my first car. I'll always have a fond place for it in my heart - it got me where I needed to go when I needed to get there - but I'm past the point in my life where I want to drive it on purpose. 
That.. that wasn't an invitation to find more examples. It was a rhetoric.
I've heard this a lot and even implemented it, buy why? Why no sanitise on the way in? Just curious.
IMHO, employers put too much emphasis on framework knowledge; I've seen people marketing themselves as "laravel/symfony professionals" just because when put in front of an empty directory they can start writting routes, controllers and input validation. But after you put a project in their lap, the hell breaks loose. From my experience, even when using a framework, some companies may decide to implement things in a certain way. I worked at a company that was using ZF2 and a custom datamapper. You may have knowledge on Propel but the team manager doesn't like the ActiveRecord pattern or you may know Doctrine but the team manager thinks it's too heavy. There are only a few framework components (eg: routing) that are guaranteed to be used by any project using that framework; the rest may differ from company to company so there is no sure thing that learning a particular framewok will get your "dream" job.
Yeah, large XML files are a bit of a nightmare memory wise. Doesn't help that there's like 3 different API's with their own pros and cons (usually a trade off between ease of use and performance).
Here's the link to PDO connection in the PHP manual: http://php.net/manual/en/pdo.connections.php 
I think your skills already look fairly well rounded. Just sharing from personal experience I think one of the best things I ever did for my programming career was really learning how to use a JS framework (first Angular, then I learned Vue). Being able to fully prototype a modern web app by yourself is incredibly empowering, and gives you a lot of career options.
&gt; "Proprietary" has nothing to do with being secure or not. Open source software -&gt; I disclose to the vendor. Proprietary software -&gt; I sit on the exploit (unless they're a client).
In my case I have to wait until doctrine/mongodb library and the ZMQ extension support it. For some blogs I'm hosting (with WP), I've already done the change and it works perfectly, without problems (and faster ^^)
All the poking at PHP used to bother me, but it makes me decent money on the side, and at this point it's just another tool in my web development toolbox, but it's still a very convenient and easy to use one.
Can you make the constructor final?
I went to that sub. Almost every bug/issue reported there that I looked at had a redaction or correction admitting that it wasn't actually a bug or that the poster just didn't understand how something worked.
I don't disagree with all your points, but in my experience json_decode works well.. Null on error, object/array for any valid json... What case are you talking about?
What looks like a well paying job in SF is probably not after you factor in cost of living. If you're near Atlanta, Mailchimp is a well known company that primarily uses PHP.
I'm with you here. I've been working with it for over 6 years and have the same thoughts as you. I'd imaging you have some more experience in other languages than the people here. The more new languages I explore, the less I like php and the more I recognize its flaws. Every language has it's downfalls, it's kind of silly this sub refuses to even acknowledge them. They take personal jabs and say you aren't doing it the right way, hilarious. Nobody here is making actual comparisons, just saying it's good enough for them, and questioning your credibility because your thoughts don't match theirs.
We have an email service worker that polls some db tables and uses Amazon SES to dispatch. We also use SQS for feedback reports that we poll as well. It was a fairly large project to pull off and without having lots of time I'd likely not attempt solo. Mind you it works great, costs nothing since we use AWS for our hosting. I love the feedback.. Let's us blacklist bad emails, generate reports, and even schedule emails to be dispatched later. The same service we built also dispatches SMS via twilio and push notifications for GCM, QNX &amp; APNS. We normalised our db tables to be Message/queue/details/receipt. Queues point to details, details point to message, and the receipt is for each queue item.
You could make more money using a language people don't complain about as much :) http://www.indeed.com/salary?q1=PHP+developer&amp;l1=&amp;q2=Ruby+developer&amp;l2=&amp;q3=Python+developer&amp;l3=&amp;tm=1
There's actually a shit ton of php jobs in Atlanta. It's kind of amazing. And the user group is pretty excellent. Chris and the group do a great job running it. 
There's blade and twig, two of the big ones I know of. 
I'll create a README of what the system or application is suppose to do at a high level
I say you need a framework. You should always use a framework even if it's components cobbled together from symfony. 
Blade is based off of Razor (notice the names). The author used to write .net apps so when he moved to php he wanted to write something akin to Razor.
IMO The problem I have with composer is that it's rough-around-the-edges bundler. The problem I have with Laravel is it's trying to be PHP-on-rails, even where that doesn't fit how PHP works and makes for some weird, hard to test code. These tools already exist with more maturity and user-friendliness elsewhere. It's annoying to me to be hoping that tool x or language feature y make it in to PHP soon, after other developers have been reaping the benefits for so long already. Being 5 years behind other languages and tooling is no fun. I'm not a maniac, I don't think you should abandon old trusty for the new hotness every time but I don't want to be stuck working with PHP forever either.
The Atlanta tech community as a whole is pretty awesome. I regularly attend the Python meetups run by Doug Hellmann - kinda sad we're not gonna be at Manuel's the next few months but we're being hosted by Mailchimp (Jan, Feb) and Kabbage (April, March, also where I work so it'll be a thirty second walk). I'll check out the PHP group though. I've been taking a lot of inspiration from the wider community lately.
I'm doing the talk about lumen at the next atlantaphp meetup! Hope to see you there!
It's just a matter of what do you want it to be, like in any other language. 
I've noticed a lot of the asp.net guys like to poke fun at php. I remind them its a tool, like any other language. It has its place and its advantages like any other tool in the toolbox. Besides, asp.net has quirks like any language.
I totally agree with you. You should use a well known framework with a good structure, docs, etc. but I just think if guys only learn (lets say) Laravel helper functions and they dont know how PHP works then they won't be able to abstract things, write classes without laravel, etc. in the end the framework is just a input &amp; output channel, the app should reside outside of the framework. so my original question was if it is enough for me to just learn the framework helper utils, structure etc., even tho I have no idea how the helper functions etc. have been implemented. Hope you understand what I want to say =) Merry christmas to you.
I'm not even defending "our tribe" I'm pointing out that their opinion is childish and inaccurate. They think I'm 100% PHP FOR LIFE just because I point out their minutia not mattering is not a PHP apologist tactic but a legitimate argument. Meh. That and chatting to these apes is less stressful than handling the family over christmas. :D
I guess I know what you mean now. And you're right, I know a lot of PHP developers who didn't know how to create classes and autoloading them without a framework. Most of the time (like 95%) it doesn't matter. You must use other classes/functions even when you don't fully understand how they work. That's an important part of programming. So, it's enough to work as a developer if you don't know how something works. However I personally do like to learn how that class/function works and why they were built because it gave me ideas to how to solve future problems. Thanks and merry christmas to you too!
Worked in a couple of metro areas and the two big shops I've seen are c# and php. Ruby is all but niche and Python is cool but very few companies are using it outside of scripts.
Mind if I ask what is the deal with needle-haystack?
You could bypass the string stuff by directly converting to a number. I am typing this on my phone without testing, so take this only as a step in the right direction: $arr = array(false, true, false, true, false, true, false, true); $num = 0; for($i = 0; $i &lt; 8; $i++) { if($arr[$i]) $num += pow(2, i); } That should work fine.
lol. Python is super-niche outside of SF. I dig the language, but that's not a realistic one for most of us.
Totally agree! I'm way outside the bay area, but I've looked around the country for opportunities and agree that SF isn't exactly a hotbed of PHP activity. Here in Detroit, Quicken Loans has a pretty big PHP shop. We're not entirely, or even mostly PHP, but there is still a lot of it, and no shortage of other relatively well-paid opportunities. So come to Detroit! The weather (this winter at least) is great!
Can you have an abstract function inside of a regular class? In my case, the home page would be initiating the parent class and inner pages would have child classes of it.
There is a Razor View Engine for Yii Framework, it has templating syntax exaclty the same with Razor's. It may not have as many features as Razor though, given its release date was in 2010-2011. Blade is enough close to Razor too, but Twig is not(which is more similar to Django's view engine). https://code.google.com/p/yii-razor-view-render/wiki/GettingStarted
Improve it?
Are you working with filemaker?.. Or is that just describing your issue you ran into?
You can use generators to reduce memory consumption (and also write to non-blocking stream) function convertToIntArray(array $data){ $result = 0; foreach ($data as $i =&gt; $val) { if ($i % 32 === 0) { yield $result; $result = (int) $val; } else { $result = $result &lt;&lt; 1 | (int) $val; } } } foreach(convertToIntArray($data) as $int) { // write them all }
A few years ago I ran a service that sent out around 3000-5000 emails per day, every day. It was a hobby project, so I needed it to be cheap. I ran Postfix on my server, and just had PHP submit the messages to Postfix directly, and let Postfix handle the queueing/delivery. I wouldn't worry about queueing in the db/php since that's kinda the MTA's job. Setting up Postfix wasn't exactly easy, but it was a learning experience so I was glad to go through it. I had to configure it to be sure it wouldn't be an open relay. I had to set up SPF and DKIM so my messages were less likely to be flagged as spam. I had to catch bouncebacks and process them so I wouldn't continue to send messages to addresses that no longer accepted mail. But it was my own mail server, and it worked pretty well. Using a third party, if you can afford it, is recommended. They handle all that stuff for you, for a price. Just determine what volume you're looking at, both today and potentially later, and pick a vendor. Then just shoot them emails as fast as you generate them, and let them worry about queueing.
Is this benchmark just running normal php? I use HHVM but I also use HACK with its specific types (MAP, VECTOR, etc..) I do not see how one can benchmark the two if the code running on HHVM is not using any HACK specific features that were designed to be faster and more efficient. HHVM does a great job running pure php, but if you optimize it for HHVM it gets a lot better.
No you cannot. "Classes defined as abstract may not be instantiated, and any class that contains at least one abstract method must also be abstract." - http://php.net/manual/en/language.oop5.abstract.php 
If you don't want to leave PHP completely, it's new cousin [Hack](http://hacklang.org/) is quite nice. It's HHVM dependant but that makes it very, very fast. It's name is unfortunate in that it is basically un-Googleable. A major downside is that the community is not very active or supportive, but it's built by Facebook so it's got some strength behind it. Double-down on JavaScript with Node? Get into [TypeScript](http://www.typescriptlang.org/)! Take your current knowledge of the language and warp it a bit. If you want to break your mould a bit but stay within web development it's worth considering Clojure/[Clojurescript](http://clojure.org/clojurescript). There's a web framework called [Hoplon](https://hoplon.io/) which is very good. Everything is a function and it's pretty rad. It's a niche language at this point, but it is very fast and very cool. The community for Hoplon/Clojurescript/Clojure is stellar. If you want to get away from JavaScript you could consider adding Python to your list of credentials. [Django](https://www.djangoproject.com/) is a good choice, as you've no doubt heard. I've looked at [Swift](http://swift.org/) now that it's open source. It's cool, I like it. The syntax is [a lot like Scala](https://leverich.github.io/swiftislikescala/). Apple has thrown a lot of weight at it, and it's available for OS X and Linux with ports coming to other OSes very soon. This would obviously be a divergence from web development. A small caveat is that it's likely to [change a bit](http://arstechnica.com/apple/2015/12/craig-federighi-talks-open-source-swift-and-whats-coming-in-version-3-0/) in the next version which is set to come out in Fall of 2016.
SES is intended (and priced) for transactional emails like confirmations of purchases and whatnot, not continual mass emails like newsletters.
&gt; Array functions ask for needle, haystack. Not always. Compare `array_map` with `array_filter` or `array_reduce` or `array_walk`. Compare `array_search` or `array_key_exists` with `array_column`.
Can you explain your question in more detail?
Use mandrill. It's smtp relay is straightforward to use and it's api is very powerful for capturing open metrics and calling webhooks.
Blade is awesome
Honestly the main difference is the full rearchitecture on top of Symfony and with an OOP-based framework instead of the Drupalish 'hook' system. Drupal 8's raw performance is a bit worse, but some of the new caching and layout tech in the system will be able to make end-user perception of the performance be even better than D7. Plus, if you're fronting both with Varnish, it'll make little difference regardless :)
Also Sendgrid 
Yeah that's the rub here. Would need a constantly updated list. Just countries and a city input is simpler and far less page load for the end user.
Thank you for this suggestion. I benchmarked the suggestions in each of the responses in the other replies and yours was by far the fastest. With php 7.01 I was able to convert around 10.5 million boolean values per second to bytes using a modified version of your function (compared to about 3.8 million per second using my original function). Here's the function I used in the end: function bool_to_bytes($bools){ $binary_data=NULL; for($i=0;$i&lt;ceil(count($bools)/8)*8;$i=$i+8){ $binary_data.=chr($bools[$i]*128 +$bools[$i+1]*64 +$bools[$i+2]*32 +$bools[$i+3]*16 +$bools[$i+4]*8 +$bools[$i+5]*4 +$bools[$i+6]*2 +$bools[$i+7]*1); } return $binary_data; }
Well... thinking about this... maybe it would be better to use little endian to store this kind of data? In this case all data will be stored as sorted array of bits, and it will be more easily to load this data by chunks.
Have you ever finished a web project in another language for a company that makes money? Just curious.
Eh, I don't know, man. It sounds more like "Yeah man I drove a Toyota as my first car. They were okay, but I'll never do that again - Honda only from now on." Maybe it's more of the language not being something that you grok very well, and it does things in a way you wouldn't normally think to do. I can see that. Lots of people tried out Haskell and decided it wasn't for them, not too big a deal.
Could you show me an example of composition?
There are API limits and you never know when Google will decide to shut it down, plus it's a third party you're depending on.
I think it is a good to see how well one engine vs another will run an application. But, If I had a pure PHP app that performed extremely well on the HHVM engine as opposed to the PHP engine, then I would not only switch to HHVM but also make use of the features unique to HACK/HHVM. It is just my opinion, but if I were making decisions based on benchmarks then I would also want to benchmark my code using features that would yield even more positive results for the engine I choose. Why go half in? Or why not convert your code over time. Hack/HHVM lets you mix and match. The PHP vs HHVM benchmarks are always one sided to me because HHVM is a drop in replacement for PHP but PHP is not a drop in replacement for HHVM.
Then you simply make an abstraction/wrapper library of your own on top of it with strict interfaces. In the unlikely event that Google's API is discontinued, simply match your abstraction library logic with a different, up-to-date API. Nothing wrong with using reliable, well documented, well tested third-party software.
I can't see anything in ECMA-404 which supports your claim. 
The data set that Zend_Locale uses is pretty good.
Do you have any suggestions for an efficient reverse operation? ie, bytes to booleans? 
I have tried a fair few json validators and they appear to all not support the 'value' part of the spec, from my very ghetto research on my mobile, it appears this was a change in the spec. I would assume then that it relies on the library php uses to feed the json functions, perhaps this would make it platform dependent dependent what version of the libs php was built with... I honestly have no idea about that. Now aside from that though, say you're right and its valid json, then it still seems to work as intended.. Null represents the concept of nothing, so if you pass nothing in, then you get nothing back. I know this is kind of a simplification, but it can return us to the original question... Which I would ask, why is passing null in, and getting null back... A bad thing? What would you expect instead?
[Razor and Blade](http://i.imgur.com/XVQ6pDR.png)
They are slow, but I don't see how this data shows it.
I think having *no* framework to worry about is better by that logic.
Wouldn't using a language's native constructs be faster rather than reinventing them (hooks)? I think the more likely answer is that in the five years it took to make D8, they overcooked it. Varnish is great until you have dynamic content to serve. I worked nearly full time on Drupal 6 and 7 projects for over three years. Thankfully, I've moved on from Drupal but I'm still curious about its future.
I run a free web service that emails people alerts based on filters/triggers they've created - Mandrill has been amazing. I've also used Mailgun and Sendgrid. I, personally, would recommend them in the Mandril &gt; Mailgun &gt; Sendgrid order, though all were totally capable and worked great. Sendgrid's UI leaves some room for improvement. 
In that case, the answer to your question is something like "when you're ready for it".
I think the most efficient way would be to use division and modulus. function byte_to_bools($byte) { $return = array(); for($i = 0; $i &lt; 8; $i++) { $div = pow(2, 7 - $i); if(intdiv($byte, $div) == 1) { $byte = $byte % $div; $return[] = true; } else $return[] = $false; } return $return; } Should work, I think?
&gt; It's name is unfortunate in that it is basically un-Googleable. Not entirely accurate... those who use it generally refer to it as 'hacklang' and it can be googled at that, in the same vein as go and 'golang'.
It's basically wrapping your own class around another class. class A { public function foo($p1) { // DO INTERESTING STUFF! } } class B { private $a; public function __construct() { $this-&gt;a = new A(); } public function foo($p1, $p2) { return $this-&gt;a-&gt;foo($p1 + $p2); } } This is just a stupid little example, but it should show the possibilities that composition offers.
That was frowned upon 10 years ago, deprecated 7 years ago and fixed 5 years ago so I'm not too concerned about magic quotes. Here are a shitload of inconsistencies that were fixed in PHP 7: - https://wiki.php.net/rfc/context_sensitive_lexer - https://wiki.php.net/rfc/phpng - https://wiki.php.net/rfc/abstract_syntax_tree - https://wiki.php.net/rfc/uniform_variable_syntax - https://wiki.php.net/rfc/engine_exceptions_for_php7 - https://wiki.php.net/rfc/internal_constructor_behaviour Stop harping on about old shit. :)
I do too, as part of the code base I work on, but in my personal experience, I've found that using [factory functions](https://medium.com/humans-create-software/factory-functions-in-javascript-video-d38e49802555#.ioj31ibdw) with nested functions for actual private "methods" is a much more elegant and natural way to construct and use objects in JS. I also follow John Papa's "[accessible members up top](https://github.com/johnpapa/angular-styleguide#accessible-members-up-top)" style and define an object's public API as the object I'm returning, while keeping the implementation in the form of scoped functions below it. Then any methods that should be private to the object, are simply not included in the object being returned. But because of closure in JS, that object you're returning can still internally use those private functions. So whenever I can, I avoid using any and all forms of `this`, as it's just not needed in JS unless you really, positively, absolutely need to do inheritance (which should be rare). Despite my PHP background, I've found that the classical object model doesn't fit JS very well, and I almost never bother with `new`, `this`, or by extension, `bind()`.
Without caching and the best your app performance can be is 40 requests/second? That's pretty bad IMO.
&gt;I'm not even defending "our tribe" Lol. That is exactly what you (and most others in this thread) are doing. Others can easily spot it. &gt;and chatting to these apes Well, you are the ones who still refuse to come down from the trees....
Good practice for OP though. 
And add caching to it so each time its used its not calling directly to Google which will help with the API limits
Spam Assassin. 
I'm not sure what you mean. Are you talking about the formatting of the code or something else?
Because sanitising destroys content, and you don't know what you may want to sanitise in future. For example, maybe you strip all tags. Then later down the line you realise you want to allow *some* tags. You've now lost the tags from all your saved content.
Yes it is a coincidence. Some of the stuff was already fixed when the article came out, much of the rest was already known (from phpsadness) and was being worked on.
Ah, yes. I was mostly thinking of lower-level languages.
So, what do you do when unpacking? What if you had a number of bools not divisible by 8?
Ah, yeah. I was just making a case for how not hard it is to begin expanding your experience once you've gotten you foot in the door. I think a lot of people are scared off because they see so many options and don't know where to start. When the reality is it almost doesn't matter (to a point, some languages clearly have different focuses and will better teach you certain things).
Except caching in ingrained in the rendering of everything. 
They do give plenty of lead time so you know when it's going to happen. Although i'd personally prefer to use a local database for stuff like this too.
According to my experience, only basic and duplicated questions gets answered. While anything of moderate complexity is left unanswered, and only a bounty can get things on the move.
I decided to cache my google places api calls... it saved our asses multiple times when we were approaching the month limit on api calls. beyond the free limit, how has the $10,000 is takes to sign up for the "google for work" or whatever the hell they call it. I love google, but really, what kind of of a small company can afford $10k a month... come on now.
Hell, Hack wasn't even out yet iirc.
Where is this posting talking about Wordpress? Drupal 8 has cache keys, tags and context built into all render arrays. This is very common in programming highly performant systems. You have no idea what you are taking about. If you are not using any caching then you are doing it wrong. This is a fact.
https://github.com/robrichards/xmlseclibs
The fact that you lump Drupal and Wordpress together shows you have no fucking clue what you are talking about. They aren't comparable. They aren't built remotely similar and they aren't targeting the same purpose. It's not black and white. You are talking about how opinionated the frameworks are, every framework is opinionated. Wordpress being one of the most opinionated. Drupal being less so and then code frameworks being even less so. Who cares about the 1 single user on your system with no caching? No enterprise piece of software gives two shits about that scenario. Only dumbshit egomaniacs trying to reassure themselves that they are following the right path do. I've used Drupal with a clients getting millions of requests a day with no issues. It's built to scale to that exact scenario and makes use of caching to be highly performant, big fucking deal. The one cache miss is the least of my concerns.
I would do something along the lines of: function bytes_to_bool ($binary_data) { $arr = array(); for ($i=0; $i&lt;8; $i++) { $arr[$i] = ($binary_data &amp; pow(2, $i) ? true : false); } }
This may or may not be helpful for you but, I did something similar recently and finally ended up using C for encoding and dumping to redis. But then used redis bit reading operations in a php lib to efficiently read the data as needed. 
If you have no framework then you ave to worry about building one. If you have many frameworks, you need to worry about maintaining them all. If you have one framework, you are in the sweet spot.
Yes. This makes it explicit how you intend the abstract class to be overridden.
You need to be outputting the array keys for the header rather than referencing an index that doesn't exist
Depends what the test platform is I guess. And, depends how the cache works. Does Drupal's cache produce stale content when it's on, or is it transparent? I'm not sure. If it's transparent, disabling it is not very representative for a real Drupal install. Turn off your CPU cache and your computer will slow down to a crawl as well. Likewise if you turn off your browser cache, web sites will low really slow all the time. PHP without op cache is also much slower. And HHVM can't even be run without cache. Everything is cached. The question is, is the cache transparent.
&gt; You can have no framework k &gt;and put together reusable components that work you mean a framework? &gt;regardless of framework ??!? &gt;But to an architect, this approach is only a hindrance. Gotcha. You know better than fabpot, beberlei, kriswall, jms, jordi, etc etc, sorry to disturb you my lord PS: &gt;You don't have to have a big monolithic framework. Symfony can be configured as full stack or micro, or anything in between. My point is that a full stack framework is not inherently a bad thing as most assume it must be.
&gt; Don't tell other developers with more experience what they need. I'm not telling anyone what they need, I'm attempting to clear up the misconception that a modern PHP framework like symfony is somehow "bad" ("heavy", "monolithic", "slow", "whatever"). &gt;Relax and either try to discuss things like an adult, or I'm done. Cool: what use case does symfony not fit? why do you need to build another framework (ie something that ties raw components together)? Please don't use analogies like bike wheels, if you don't have a specific example then you might want to rethink your argument. PS: &gt;Let's take Jordi. Any thoughts why Jordi specifically designed Composer and Monolog to be framework-independent components? Why aren't they just Symfony components? I'm saying, is it possible, Jordi knows well enough, but you don't? The symfony components are framework independent too. All components are, that's what makes them components.
&gt; I'm not telling anyone what they need, I'm attempting to clear up the misconception that a modern PHP framework like symfony is somehow "bad" ("heavy", "monolithic", "slow", "whatever"). You're doing a poor job of clearing up that "misconception". You're just attacking me like a common zealot, with emotional arguments and insults. &gt; Cool: what use case does symfony not fit? The question isn't "what use case Symfony doesn't fit". I didn't borrow money from Symfony I couldn't return, so I don't owe them any favors, like trying to fit them to my use case. With enough effort, time and money, I'm sure I can fit WordPress to do air traffic control, but is WordPress providing any value here, or are we merely tolerating it? So the real question is "what value does Symfony provide". And it does provide value depending on what you need. But once you understand architecture in your bones, you don't need Symfony "the framework" anymore. You start seeing flaws in it. Limitation. So you drop the Symfony framework, and you start using the individual Symfony components, HTTP message abstraction, router, template engine etc. The way Laravel is doing, for example. But the Symfony components are simply not that compelling considering the ecosystem. They were, but not anymore. Compare Symfony's Routing with Nikita Popov's FastRoute. Is it a *misconception* that FastRoute is a fraction of the code, with a fraction of the config, and runs in a fraction of the time? It's quite objectively not a misconception. You can measure it with numbers. How about comparing Symfony's HTTP foundation with a PSR-7 compliant message? Same deal. PSR-7 is simpler, faster, smaller and requires less configuration. Symfony deserves respect, but it doesn't deserve pity. Just like Symfony 1 looks horrible today, to some Symfony 2/3 looks like a dated approach already. There are better, simpler, more focused solutions to specific problems out there, I named a couple above.
What I learned is never tell /r/programming that you are making money via PHP. They hate that.
Indeed. However, mapping the world I bet isn't in any danger any time soon.
Well, that's a classic conundrum, then. By allowing people to enter free text, the margin of error goes up due to typos. An address might become unreadable or plain wrong. OP specifically asked for a drop down/select feature. That's what I'm basing my answer on. It's up to him, then, to determine or ask whether a specific approach is desirable in terms of manageability, usability, and performance.
It's christmas day. Go and drink some sherry or something. That's my advice.
I guess that's the reason I'm asking this. :)
you can use lumen
I use Laravel for backend restapi. Frontends are AngularJS and iOS app. Works well.
There is no output. It just prints the list of details. Here is the page in pastebin. http://pastebin.com/0hmLi6Er
Thanks man. I've heard about Slim but never about Lumen. I'll give them a try.
Thanks, I've only heard of Slim. I'll have a look.
Hi! I am a huge fan of "named" constructors, and then you can mark the parent __construct class private final, something like this: class User { protected $username, $hash, $email, $createdAt; private final function __construct($username, $hash, $email) { $this-&gt;$username = $username; $this-&gt;hash = $hash; $this-&gt;email = $email; $this-&gt;createdAt = new \DateTime(); } public static function register($username, $email) { return new self($username, md5($username), $email); } } Then you can use it like `$user = User::register("richard", "hello@world.net")`, and you can't overload `construct`, so when you wan't a new object, you **have** to call `new self();` somewhere. Something like this: class SuperUser extends User { private $someVar; public static function register($username, $email, $someVar) { $self = new self($username, md5($username), $email); $self-&gt;someVar = $someVar; return $self; } } And then call it `$superUser = SuperUser::register("Richard", "hello@world.net", ["super"]);`
You can remove this functionality from the middleware like [here](https://github.com/microweber/microweber/blob/master/app/Http/Kernel.php#L18) 
It is fine asking here, but creating a new thread would substantially increase your chances for a reply. :)
Thanks for this, it looks good and I will try it and benchmark against other options. I think the only tweak I'd make is to pre-calculate the powers of 2 and store them in an array so I don't have to keep calling the pow() function.
since /r/php is trying to avoid to advertise bad php practices and crappy tutorials. Is xammp/wamp a good practice? It should be recommending vagrant or docker ? Just asking. 
You can simply replace the php subfolder in the xampp directory with the new PHP 7.0.1 files (but keep your PHP.ini) EDIT: This only works for the XAMPP7 version, do not use this method for lower versions to upgrade.
thanks.
thanks. 
Please, use print_r($row) ( http://php.net/print_r ) after line 42. It will help us out with better debug. Btw, what is your header information? Is it rep_id ?
It appears to work now. I replaced the print_r($row) with the following: $repname = $row["1"] . " ". $row["2"]; print_r($repname); And now the first row reads Walter White, and is followed by his list of projects. Thank you very much for the pointer, I was going crazy, and this is my first php project in 10 years!
I'm sorry if this is a noob question that I should know the answer to but what if my web server is using Windows?
&gt;I'd like to emphasize that one really should use an email service provider to send transactional emails. The reason being that it's necessary to do so these days in order to deliver emails into the inbox of users and not just into their spam folder. What makes you think that? It takes about an hour to set up a well-configured postfix instance with DKIM and SPF records. There's no magic about sending mass mails. 
I'd consider Node.js as it is really great platform once you "feel" it.
Task scheduler is almost as cool as cron, but comes with a graphical interface that by itself makes PHP and IIS pretty awesome.
&gt; I wouldn't feel comfortable introducing character and ASCII operations to the mix for a number of reasons. Care to elaborate on why you do that? It's a work in progress and I'm open to suggestions. But accessing the nth character of a string by treating the string as an array is something that PHP facilitates. eg: $s="hello"; echo $s[1]; prints out "e", but I haven't benchmarked to see how the speed of that compares to other methods. edit: I've done some pretty extwensive benchmarking and surprisingly it seems like referring to the bytes using $binary_data[$b] is about 20% faster than explicitly unpacking them into an array. The alternate function I used was: function bytes_to_bools_v2 ($binary_data) { $bools = array(); foreach(unpack("C*",$binary_data) as $b=&gt;$int_temp){ for ($i=0; $i&lt;8; $i++) { $bools[($b-1)*8+$i]=$int_temp&gt;&gt;7-$i&amp;1; } } return $bools; } I also tried many other variations but the fastest was the bytes_to_bools() function I listed in [this comment](https://www.reddit.com/r/PHP/comments/3y3dcr/fastest_way_to_pack_an_array_of_boolean_values/cyazmww) earlier today. I was able to gain a little extra performance by unpacking the bytestream as 64 bit integers (20% faster than unpacking bytes) but that came with a loss of generality.
I did, but I never had the discipline to delve too deeply into it. My problem is that I'm too familiar with the way things are done in PHP - I know at the back of my hand what packages to go to get certain functionality, I know how to troubleshoot stuff when things go wrong, I don't need to relearn how to implement authentication, how to use another db library etc. And when I have tons of projects on hand and want to have a life, it's hard to master another framework.
http://www.reactiongifs.com/r/2013/10/DF2DFhS.gif
[CIA World Factbook database download](https://www.cia.gov/library/publications/download/). edit: I am an eejit. 
You can try geonames database. It's huge, contains everything, but it's all raw unpredictable ceased data that you n ed to string together yourself. Cost me a few days of work to get a useful country - state - city list out of that, but then again, it contains *everything*
In my case when I started I installed apache and php in linux, then I try using Windows plus wamp, it was easy to install but things don't work as in linux, then I created a debian vm with apache php and a ftp server to upload files, it was better but hard to configure. If someone would told me that A vagrant image include all of this and more the same for docker I would used that time on learning good php more than devops things. Just saying. 
You could also consider caching the array with a 30 minute expiration. This way you don't need to set up a scheduled task or a cronjob. The only downside is that every 30 minutes, some user would have to wait for the dynamic creation of the array,, but for the rest of the 30 minutes or until the cache expires, the rest of the visitors would get it directly from cache. There's tons of cache alternatives, xcache, acpu, memcache, just to name a few.
You can even cache it as a serialized string in a file on the filesystem.. $array = my_array_generator(); file_put_contents('cache.oki', serialize($array)); and to read, you would do something like: if (check_age_of_cache_file()) { $array = unserialize(file_get_contents('cache.oki')); } 
Have you looked at DreamFactory for your RESTful API? https://www.dreamfactory.com/features
Very nice article and covers everything on a high level. Well written and concise.
Yeah it sounds like a slightly different use case then. I only needed to be able to read a few bits at a time with PHP (it was a simple API), thus Redis was a good fit. It ended up working out quite well. I did have an early version of the encoder in PHP (using a technique similar to above) and the speed wasn't totally outside the realm of acceptability. I just used it as an excuse to dust off my rusty C skills.
Hahahahaha oh fuck off. What language are we allowed to use buddy? R? Scala? Rust? 
&gt; Ignore them. They're daft. Thanks for proving that the word of PHP devs like their language is full of shit.
That's not English so I'm not sure what you're saying, props to you if this isn't your first language but if it is then you messed something up. Anyhow, here are my thoughts a little more in depth on the 0.006% improvement https://www.reddit.com/r/lolphp/comments/3xkhvk/the_kind_of_thing_that_gets_upvoted_in_rphp/ You literally don't know what you're talking about if you say PHP 7 is only a 0.006% improvement on 5. That's definitively false in any metric you want to use. You need to read up a little before making nonsense claims. You might as well tell me that grass is made out of cheese and the President of the United States is a salt and vinegar pack of Pringles. 
If you read the left side you can install yourself both Apache and PHP. http://windows.php.net/ And then you can install MySQL, there is MySQL installer in their web site.
&gt; It takes about an hour to set up a well-configured postfix instance with DKIM and SPF records. There's no magic about sending mass mails. It might not take long to do that, but some email hosts will simply reject email from unrecognised IPs.
&gt; I'm not sure what you're saying Shit. The most recognizable word for a PHP dev, and all of you are full of it. The fact you don't even follow your own advice is proof of that. Care to ignore the rest of this comment to prove me wrong? &gt; That's definitively false in any metric you want to use. No shit Sherlock, improvements are not measurable, that was a figurative comment of my part. No matter how much new syntax not how much "improvements" you dump in this pile of shit, is still going to stay like that...shit. No sense of design nor direction, life is too short to deal with this crap. &gt; You need to read up a little before making nonsense claims. Back up your own claims, in what sense the language have improve? Name one reason why would anyone should choose PHP instead more robust platforms than the convenience of cheap share hosting and what I call "PHP lifespan" AKA Wordpress (since if it wasn't for that shit, the language would be dead by yesterday), enlighten me? &gt; You might as well tell me that grass is made out of cheese and the President of the United States is a salt and vinegar pack of Pringles. This screams a change to a more healthy diet.
There are a lot of ORMs for PHP already. They aren't just as popular as the ones you mention. For example [Paris](https://github.com/j4mie/paris) (and [Idiorm](https://github.com/j4mie/idiorm/) it's built on) seem quite similar to what you're describing. That being said, nothing stops you from creating a new one.
I can agree with this. Just skip to Vagrant / Ansible.
Either use a cron based script or every 30 minutes one page request generates the next array (the array could be then cached in the filesystem and time could be recorded by filemtime() on the file that stores the array)
We use smarty an basically this is how it works: * We allways pass a $message template var. * We have a custom block in smarty that defines $message-&gt;subject with its content. * After parsing we chech if $message-&gt;subject is set, if so we use it as the email subject. All of this is possible because we added a layer over email sending, so basically we use something like $email-&gt;content_fromtemplate("emails/hello.tpl", $data); and all the magic happens. No the most elegant solution, but works pretty well and transparently. Basically ou message looks like that: {subject}Hello World{/subject} &lt;p&gt;Hello world !&lt;/p&gt; &lt;p&gt;Have a great day.&lt;/p&gt; EDIT: formating and example
Deceiving your customers by selling them subpar products of course. Your forgot that last part. 
As a maintainer of large projects, the continued prevalence of static access in ORMs really irks me. Eloquent's "facades" are one example of static/global ORM state, and this is another. Doctrine's tendency to embed configuration statically onto entity classes via *annotations*, yet another (though to a lesser degree). If the database host and sign-in are set statically via ORM::setDatabase() this automatically means this ORM is useless when I have multiple databases, or I want multiple modules in my projects to have independent ORM settings for themselves without clashing with other modules. We should finally learn that globally shared mutable state is a deeply flawed approach and it should be avoided, if not entirely eliminated, from our codebases. As a secondary remark, ActiveRecord also couples classes with persistence mechanism, which also limits flexibility of handling entities that may be persisted in different ways. ActiveRecord is an outdated approach, that's only suitable for small projects that will stay small.
I like this idea. Thanks! I may stick with calling parent::construct(), but this does do what I was looking for it to do. If I was to use your idea, I'd also make the __construct a final as well to avoid the child from overwriting it.
Something to worry about later on after they've figured out the basics of PHP using a very beginner-friendly setup. Baby steps.
**Re: [PHP-DEV] INDRECT in arrays causes count() to become unpredictable** &gt;I agree with Zeev here and I had a chat with Anatol about this tonight. This is a .0.0 release. Nobody is going to take a .0.0 and push it straight to production. And it is not going to part of any sort of LTS distro either. It's not like LTS distros don't pick up point releases. There is no way we will go 2 weeks without finding something for quite a while still which can drag things out indefinitely. The question is whether this is significant enough to postpone further. Personally I don't think it is. Let's get 7.0.0 out the door and get ourselves on track for regular point releases without any of this "perfect-release" stress. &gt; &gt;-Rasmus 
Rather than requesting the webpage from a scheduled task, have the scheduled task run the PHP script using the [CLI](http://php.net/manual/en/install.windows.commandline.php) API. When run as a command, it usually doesn't have the same execution timeout limits that a webserver-spawned process does, and it won't tie up webserver processes with the request either. Note that you'll need to save the array it creates somewhere... a database, memcached, a file, etc.
PHP should be out of that list.
Probably, but not that I'm aware of.
Bootstrap is pretty good is you want something dirty and quick (also is the most pupular). Foundation is other very good option but is more bare bones than bootstrap. If your app is not going to be a SPA, please restraint yourself of using a js framework like Angularjs (I wouldn't even recommend it even is your were going to do SPA). Another idea if you really want something fast is to go to themeforest and buy a pre-created site template or admin template, there is a lot that use bootstrap and popular js libraries. 
Really, I just want the ability to create CRUD screens most of the time. If I can find a UI builder that does most of the work for me, from the html to error checking input, that's what I want! The database is just a configuration file for the app code itself. I'd like to be able to build a new feature in the app, throw a screen together, have the frontend builder create, say, an email field, and the builder auto-generate valid-email checking code for me in the presentation layer. What's the best option for this?
I don't need anything fancy, e.g., Node.js.
So you just come here to troll? 
Instead of a text editor, I like using [Google Docs](https://www.google.ca/docs/about/). Does everything the text editor does, with a little bit more formatting sugar, especially ability to [add links to stuff related to the task](https://www.google.ca/docs/about/) (which I often do). The gdoc is also available on all my devices so if an idea hits me while I'm on the go, I can add it via my phone and it'll be there in the gdoc when I look at it later on my laptop. I also organize my list of tasks in a pseudo-Agile way. I'll have a few short lists for "Sprints" with names like "Now", "Today", "This Week" (changes as appropriate) and a big list called "Backlog". I'll cut&amp;paste from the "Backlog" into a sprint list as I start planning to do the task.
&gt;I simply linked you to the RFCs which showed the amount and the quality of the changes I am not sure how you measured the 'quality' of changes. I just pointed to you how one choice made is absolutely noobish, and you completely ignore it and continue say that it is ok, because there are other valuable changes. Which is sounds utterly stupid to me. Imagine saying to a client that he should not be pissed off at a bug that makes the front end lay out a bit messed up because you have done such a great work on the back end. It is not about the bug itself and how big or small it is. But it shows the 'unprofessionalism' in what you do. &gt;Now give it a rest you absolute muppet. Lol. You want to give it a rest? It is easy. Stop responding.
You don't know what you are talking about. PHP is suited for all kinds of applications and experience is not a reason to switch language.
In theory. In reality, few people with the qualifications if any are going to spend thousands of hours auditing large, open source projects for free.
OK bro.
Isn't this what [NotORM](http://www.notorm.com/) is?
I wanted to build mine on top of `doctrine/dbal` which I consider a fantastic and well-maintained library giving a thin layer and abstracting difference in SQL. I've seen many similar solutions and approaches to mine. I absolutely love the ORM and other parts of [Flourish Library](http://flourishlib.org) but I've not seen any which are reasonably well maintained and popular in my research so far. I could be very wrong. Maybe that's also a sign that these things don't pick up enough traction to see enough users to continue to drive development :)
If I start with a large-enough use case and aim to cover a lot of use-cases I'll just end up re-inventing doctrine, and will do so poorly. There are still a lot of people out there who just prefer to use PDO or even `mysqli` and that's fine. For a lot of people an ORM is just a better way to access a database, but for larger applications it's a valuable tool in encapsulating business logic and making things maintainable. I simply felt there's a sweet spot in-between a full-blown ORM with full customizability and features, and also writing the queries yourself.
eh, node.js is not frontend framework, he mean frontend js framework
&gt; Like component weight and entanglement You're saying the components are too heavy? &gt;poor performance compared to alternatives I've listed ??? http://labs.octivi.com/handling-1-billion-requests-a-week-with-symfony2/ performance is one of their key focuses, holy shit, sensio just built a profiling tool most likely born out of the need to profile symfony &gt;such as bundles &amp; controllers using the DI container like a giant service locator that's the code you write, not symfony's problem, just don't do that &gt;i hate events ... Bit of a rant there. That pattern is fine, but it's open to abuse like anything. &gt;It's endearing you feel like you need to defend Symfony, but don't sell it as the smartest solution to everything, because it's very far from it. It's a solid product, and for some teams it'll be a big step up, but for some teams (like mine) it'll be a big step down. https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect
&gt;There shouldn't be a blatantly obvious bias towards "it's my stuff, so it works only with my other stuff". too funny also, yes, I too strive to keep the bloatware that is doctrine/commons out of my code :|
Thought it might be interesting to reread this, your first line of reply to me was this insult: &gt;This line of thought is more about lack of imagination and experience than anything else. You finish up that post with a god delusion: &gt;The problem is when we discuss what's good and what isn't it's unclear how advanced is the developer I'm talking to. The PHP community is essentially 80% juniors, most people know just basics. ... But to an architect, this approach is only a hindrance. are you from the matrix? then you open with another insult &gt;You seem so resigned to your inability to put together independent components, you automatically defer any architectural task to mean "a framework" which, again, only betrays your level of experience. you even tell a story to illustrate how stupid I am &gt;"I can ride a bike." "You mean, you put training wheels on it?" "No, I don't use training wheels." "Huh, so you made your own custom training wheels." followed by more god delusion and assumptions about me that are unfounded &gt;I don't want to be nasty, but you're making this conversation really nasty. If you don't get what I'm saying, if you really need the training wheels, have 'em. Don't tell other developers with more experience what they need. HAHAHA this is gold &gt;We've all gone through this and felt like we need something to lean on because architecture is hard. But with time, it becomes easy and obvious, that's what experience is about. Where you're going, I'm coming back from, and **you might want to be less arrogant in your assumptions**. now you accuse me of insulting you ?! &gt;The only thing you can put in your favor is insults and appeal to authority. followed by a childish threat &gt;Relax and either try to discuss things like an adult, or I'm done. this just goes on and on &gt;You're just attacking me like a common zealot, with emotional arguments and insults. but I'm bored, so GL with shit n stuff, bye
ah engineering, sorry, I thought it was stuff, or architecture you were great at that post is addressing your inability to have a discussion, it doesn't much matter tho cause you're a genius!
That may be true, but we're also starting from use-cases first, as starting from the API of your ORM leads to harmful patterns instead. For example, you may just implement a small TDG-based mapper, which is something that currently only `Zend\Db` implements, as far as I know (heck, you may even base it on `Zend\Db`). In general, if you think that building a micro-orm may be useful, and that you will be able to keep it micro, I think that you are under-estimating the surface of attack of such a wide problem space. 
Sorry, but it's pretty hard to take seriously anyone who needs to resort to expletives in order to format a sentence that attempts to validate their own opinion. If you believe strongly enough in a subject you need to be able to have the patience to actually argue your actual point. At the moment, your just blowing hot air.
Look into [Admin-LTE](https://almsaeedstudio.com/preview) if you want a true shortcut. It's a great admin theme built with Bootstrap (so all Bootstrap functionality inherited) but enhanced with some common admin dashboard styles, layouts, widgets, and more. It uses less instead of CSS, but you can get around the NodeJS bullshit and avoid it altogether if you use PHP tools to build the assets: [example](https://github.com/Swader/diffbot-dash) and [introduction](http://www.sitepoint.com/look-ma-no-nodejs-a-php-front-end-workflow-without-node/). I've used this in a few projects so far, and it's a real treat to work with.
I guess he was joking. Why you guys so serious?
others dont have the bandwidth or computing resources. Xampp rocks.
It depends on what type of API. If it's just something simple I usually won't employ Laravel. I do sometimes use Lumen, but most of the time for smaler projects I'll use [FlightPHP](http://flightphp.com/).
There's plenty to reuse even if you don't use a monolithic framework. The problem here isn't whether to reinvent or reuse, it's what exactly is reusable, and what isn't. Most frameworks don't know where to draw the line and they corner you with premade choices that are harmful to your specific needs. The way to avoid this is to be able to create your core around 200-300 lines of wiring existing components. Reusing, not reinventing, but also not deferring to a framework to do your job, which includes architecting the app you're doing.
I haven't looked at the code or anything, but I'd guess the reason is the ability to have other implementations of SessionStorage depending on where and how you want to store the session data.
 * Session is about the session handling (creating/destroying/identifier/etc) * Session storage is about the data in a session (scopes/key-value access) Note that the fact that we consider a session as a big array of stuff is just a PHP thing: a session identifier doesn't necessarily lead to to a map-alike structure on the server side.
Meta question here: Where can I ask for code quality review/opinions of my open source application? I attach great importance to OOP (at least I try) and it would be great to read some quality criticism about it :)
That's in reference to... ?
 WordPress accounts for 25% of all websites. WordPress is also the fastest growing system.
Haven't checked the numbers, but could be. It's like a virus. It's also one of the key sources of business for me. Moving WordPress sites away from WordPress, I mean. I feel dirty, but someone has to fix those clogged toilets.... the_horrors() I've seen. 
Laravel already makes generating slugs dead easy, so an entire package for generating them seems like overkill. Plus, is saving the slug to the database a good practice? I'd much rather generate a slug dynamically (with an ID prefixed) than worry about storing it in the database.
WordPress is a starting point for many companies. It's just their very first thought "we need something and it looks like a site? Let's use WordPress." What I move them to depends on what they've turned their site into. Shopping site, news site, company site offering specific services, various other functionality they've slapped on it. It's highly specific. The only common thing between all my clients who move away from WordPress is that none of them really run blogs, which is what WordPress is. At best, they have a blog-like section which isn't the focus of the site. That's the first thing I don't like about it... the fact it's a blog platform and it's used as anything but. With enough work I can turn a paperclip and some chewing gum into a calculator, but it's not the best experience or most efficient approach. WordPress is *not* designed or capable of doing what my clients expected out of it. As a result, the developer velocity working on such a site is abysmal, and moving away improved that significantly. Again, solutions vary depending on the client. Second the WordPress codebase is written with PHP4 idioms and the API is atrocious. No encapsulation, everything thrown in globals, nonsensical naming (even more so than PHP's own APIs). Check the difference between is_single() vs. is_singular(), for example. Or check the difference between get_content() and the_content(). It's not just where the result is returned or echoed. Those are just basics, I don't want to get into details, or I can write a book in here, but it's just as if it was designed by a dozen monkeys jumping on a keyboard. There's no logic or rhyme to it. This also translates to the community. Most WordPress developers my clients hire have made atrocious changes to the code. No concept of basics, even proper nesting. Lots of plugins, most of which are very low quality and most installs I deal with use a ton of plugins half of which are in a state of disrepair. Abandoned, buggy and incompatible with WordPress version that's being used. A good portion of the WordPress sites I've dealt with were also infected. No need to comment further there. And even as a blog, WordPress leaves a lot to be desired. It doesn't enforce some semantic structure into the blog posts and I commonly see random HTML inline styles pasted into the post content. It's impossible to tease apart inline HTML styles, plugins, shortcodes and so on crap from the actual content the authors were trying to express. As such it can't be called a CMS, because it's not a system for managing content, it's a system for managing HTML blobs intertwined with that specific WordPress install, config and its plugins, and some fields of metadata slapped on top. The "content" is somewhere in there, but it's not distinct, it's merely sprinkled around the database and codebase in an amorphous form. Fixing this requires a lot of manual labor.
- Rails is practically the only framework for Ruby, while Symfony is one of many for PHP. - Symfony is, so to speak, a "framework for frameworks", its primary goal is not only to be the framework for end-users but also to be a building material for custom frameworks, which everyone is encouraged to build upon. - So Laravel is one of such offspring frameworks, and you can give half of its votes to Symfony as half of Laravel is Symfony. - Laravel is HUGELY advertised
http://www.indeed.com/jobs?q=laravel&amp;l= ( 700 ) http://www.indeed.com/q-symfony-jobs.html ( 500 ) 
PHP7 added an AST one of whose goals is to allow features like async. PHP has started with a lot of burden, just like Python, by the way (Python was total crap in its first few years), and it's had less time to get rid of it, as a *younger* platform than Python. But PHP is moving with great velocity, I'd say greater than Python. PHP7 is a great step up, and lots of exciting things are coming in 7.1 and after. And unlike Python, the PHP community is not split between two major versions. PHP7 adoption has already started and no one is objecting to upgrading to it. There are plenty of opportunities to be cynical when it comes to PHP, but what you said isn't one. PHP7 almost has async, BTW, check the additions to generators in 5.5 and 5.6. Async is implemented via co-routines and PHP has co-routines. Additionally async is not a panacea. I write async code in the backend, but it's rarely needed in the frontend, where PHP's place is.
&gt; You can give to Symfony half of the Laravel's votes as half of Laravel is Symfony. I've read some pretty silly stuff on this sub, but this is one of the silliest. Using the HTTPFoundation and a few console packages / utilities doesn't make Symfony "half" of Laravel, not by a long shot. Laravel puts its own abstractions/wrappers around most of the Symfony components it does use, so very little of Laravel's popularity can be attributed to Symfony directly. Nobody using Laravel is going "OH MAN, I REALLY LOVE THIS SYMFONY COMPONENT API! THANK GOD LARAVEL USED SYMFONY!". So that leaves the only other argument you can make, which is "Laravel wouldn't exist if the Symfony components it uses didn't exist", which is obviously a ridiculous argument. Taylor came from the .net world, saw a need for a modern framework for PHP since PHP was wallowing in the dark ages at the time, and his goal was to build Laravel. I sincerely doubt he was going to be like "Oh well, looks like there aren't any HTTP abstractions for PHP, guess I won't bother with my idea"... FURTHER, your argument basically boils down to a "framework is only the sum of the dependencies it is built upon", which is quite a silly point of view to have in the open source world.
[SRP](https://en.m.wikipedia.org/wiki/Single_responsibility_principle). :-)
&gt; There are plenty of opportunities to be cynical when it comes to PHP, but what you said isn't one. It is. The push toward changing PHP to support more complex abstractions and redundant syntax, makes it look like a future where PHP is a less comprehensible language (back to Perl). &gt; it's rarely needed in the frontend, where PHP's place is. This sentiment is part of the problem. PHP is a general purpose language and continues to be used as such. For how much longer? It doesn't help that the /r/php is like most language subreddits, where you see a majority of bootlickers, who wave their hands and say everything is fine. It's not like there's no hope. It will be years of incremental improvements alongside the institutionalized changes, so I'll be long dead before the language falls completely out of fashion. The game of "keep up" as a preferred introductory language would require a different set of priorities. Right now there's a glut of "fix old, duplicate old with sugar, and help frameworks add more indirection so we can test smaller parts in isolation". That's just an opinion. I do really like the interpreter improvements :D 
Well in my case I get lost on laravel app directory, while in symfony bundle structure more easy to understand 
&gt; I agree with you. But an expert WordPress developer can customize WordPress according to the client requirement. There many major websites and blogs that successfully running on WordPress for years. As I told someone else recently, using WordPress is no one's end goal. WordPress didn't loan us money we couldn't return, so we don't owe WordPress any favors. Therefore "an expert WordPress developer can customize WordPress according to the client requirement" is not any client's goal, if that expert WordPress developer doesn't actually derive any value for the client out of the fact WordPress is used for client's goal. Client's goal is something else, like running a high quality, performant site cheaply, efficiently, flexibly, and having full control over how their content is described, stored, managed and presented. If WordPress can provide value to a client, they'll keep it. If it doesn't, they won't. Most people keep using WordPress past the point it provides any value out of pure ignorance or lack of expert advice. I don't know what the "major websites and blogs" case is, without specifics it's hard to make any conclusions, but WordPress is not well thought out and I only see it provide value to people who are not developers and need some blog up quickly with no effort and skill. It's useful in that case. It's the opposite of useful in most other cases. Also I hope we're not going to mix WordPress.com with WordPress.org, those are two distinct things.
Oh, so storage and sessions are inherently two different responsibilities? If the session requirements change, the storage can remain the same but session can be changed to adapt to the same storage?
*Disclaimer: I don't use either much (a handful of apps in each), but am more experienced in Laravel. I usually build my own apps from scratch with various packages, so my perspective might be a bit skewed against large scale frameworks* --- Because it's ridiculously more difficult to use. It takes longer to get warmed up in Symfony than it does to make an MVP or prototype in Laravel from scratch, given zero experience in both. The docs, while extensive and much improved with their new DX initiative, still don't cover things well because every component has a veritable book written about it and still isn't fully described. Every component also takes three types of configuration (yaml, xml, and PHP arrays) of which each can have the configuration keys at different levels. Just look at the sample configuration for the new Guard component [here](https://symfony.com/doc/2.8/book/security.html#b-configuring-how-users-are-loaded), which is [hailed](http://www.sitepoint.com/easier-authentication-with-guard-in-symfony-3) as something revolutionarily simple in the Symfony auth world. If they're so intent on making everything easier to use, why not allow programmatic configuration in a boostrap file instead of forcing people to learn the config structure? Just make good config classes or setters for the components which can help with autocomplete in the IDE, and the mess linked above disappears. 10+ levels of yaml won't help anyone be productive. It's neither readable nor writable (same for XML and PHP arrays, when so many keys and nesting levels are in question). People say "you shouldn't have to change your source code to change configuration". Really? And config files don't get committed and pushed alongside your code? **Everything** is source code. That's just the config gripe, and the first major hurdle for most people I've talked to about their opinions on Symfony. There's also the insane difficulty of building bundles (a dozen files for the simplest hello world bundle) and the lunacy of having to write [4 classes](http://symfony.com/doc/current/cookbook/bundles/configuration.html) just to extend a bundle's configuration (i.e., a bundle has a default config value, but if defined in the main app's config file, that value takes precedence). There's a whole lot of these little showstoppers which, when you're a solo dev or in a small team or working on a prototype or anything that doesn't have a 10+ year lifetime guaranteed just isn't worth the effort or money, when you take hourly wages into account. Unless you get Symfony vets on your team, chances are there'll be *days* (at a minimum) of wasted time before everyone gets in sync with one another and the team becomes productive. With something simplicity-oriented like Laravel, that's just not true - people will be able to dive right into the logic of things almost *immediately*. I still prefer a no-framework approach with well defined standards and rules, though. My 2¢..
&gt; Also you cannot compare it to Rails, ruby is arguably less shitty than PHP. You really should believe in yourself and your PHP more. Ruby is cleaner, but PHP has key features that matter enormously in larger projects, like type annotations, real interfaces and properly encapsulated classes. Ruby code is prettier in a slideshow, but PHP is doing a better job of being *a language*, even considering its Frankenstein of a core API.
I just went through a project where I wrote it all from scratch. What a waste of time. Ended up writing my own weak orm and having to sanitize all of the user inputs. Had to bootstrap everything that just works with a framework. Maybe do it for fun but when time matters just use the framework and existing components. Yes you should be aware of modularity and what has which responsibility but you don't need to write everything from scratch to be considered serious.
Well this makes your recent comment history of sitting on PHP's subreddit and trolling every thread with the same PHP hating remarks even sadder, doesn't it? Did you get fired and being bored right now? Plenty of PHP jobs out there, try to get one.
Don't pile frameworks and components together. If you think I'm just against code reuse in general you've missed both mine and OP's point. I do contribute to FOSS FYI. If it looks confusing what I have against frameworks, as I've said, I've not found a way to succinctly convince someone over a few sentences about the benefits of a modular architecture over using one of the popular large monolithic frameworks. On paper, especially to a manager, frameworks only have benefits. This lesson is learned through time, pain and experience.
&gt; I just pointed to you how one choice made is absolutely noobish, and you completely ignore it and continue say that it is ok, because there are other valuable changes. Which is sounds utterly stupid to me. You sound like you don't know what words are. I said in an RFC which restructures entirely how the tokenizer and parser works, not adding a guard clause to a single new arguement doesn't seem like enough to say "THIS DID NOT IMPROVE THE LANGUAGE" as you have done. Sure I pointed out that not all arguments like this in various languages are checked for misspelling, but I also acknowledged that IT WAS A PROBLEM. Just not big enough to justify your ignorant sweeping statements. &gt; Imagine saying to a client that he should not be pissed off at a bug that makes the front end lay out a bit messed up because you have done such a great work on the back end. Those are two different products. It's more like talking to a customer that has zero mobile support after designing their website and saying "oh this one page has a bug on the Kindle but all other devices and all other pages have perfect support." If you knew more about PHP, internals, RFCs or the changes at hand, you'd stop making such fucking daft conclusions and using such awful metaphors. I stopped responding to you a while back but you're trolling around Reddit looking for new threads to twat off in.
I've linked to this so much in this thread that my V key is getting worn down. https://www.reddit.com/r/PHP/comments/3x9wqn/why_do_people_keep_saying_php_isnt_used_for_the/cy63du3
&gt; PHP refuses to break, and so it implicitly refuses to make some things better because it can't. What would you change?
&gt; Also a note, there is not any evidence that type annotation are actually influential in software quality and craft, so your point is pretty much irrelevant. Oh, boy, you do have a lot to learn, huh.
Using a framework doesn't count as programming in my books.
Why the hell would you write your own orm, don't you know SQL?
I though you were going to ignore me? So much for the word of a shit languages extraordinaire. Also the only thing I get from the thread was: "We are adding thing that this shit would have if it was a properly designed language". "Oh, look now we have a proper AST, I heard about those while using others properly designed languages". "Look how many ways we can call a variable now, not confusing at all.". Which are minimal and others so pitiful, pretty much what you would be defined as sassy patches. Still no generics, unusable, broken and subpar standard library (that nobody use btw), type coercion is shit, core function names are shit, variable scoping is shit, the repl is shit, no design, direction nor convention, inconsistencies in behavior and arguments order across all the language. None of this are going to be repaired, not in 8 not 9 not 10 and so on. At this point I believe that shit like JavaScript is more forgiving. Doesn't help that the syntax is more ugly than C neither. You didn't answer my question above by the way. 
or I could just use Laravel .. like I did do
&gt;That's already the case in PHP7. It isn't unless the docs are wrong - many stdlib functions claim they return something to return an error, not throw. &gt;Fatal Errors are now exceptions, and you could always map warnings/notices to exceptions via an error handler (the exception gets the full stack from your location of error). Sure, but it's really annoying to require boilerplate. If you're making breaking changes anyway take the opportunity to do something better. (And other suggestions of mine, even in the 'definite want' category, require breakage) &gt;That was a quick dive from errors-as-exceptions to irrelevant nitpicking, I think. Yeah, check the heading I put it under. &gt;Do you realize that Python added optional type hints in 3.5, and TypeScript is a popular layer over JS adding interfaces and optional type annotations? Do you realize Python doesn't enforce type annotations? Read the PEP, it's meant to be inlined documentation. (And the unspoken reason they did that is to let alternate Python interpreter choose to break from PEP standards and enforce them without needing any modification of the code between CPython and other interpreters.) Even with the annotations Python still doesn't have interfaces. Interfaces only make sense if you're ready to support a *compile time* enforcement, because if you wait until run-time to evaluate it as an error condition then you may as well save the wasted effort and let the operation that will fail in the function cause the failure. In a language without strict typing you necessarily can't catch most mis-matched interface situations until run-time, when it would fail visibly for you anyway! &gt;If anything, other languages are becoming more like PHP, wat? Python adds some unenforced type-hints is now 'other languages becoming more like PHP'? &gt; while you're asking PHP to make a 180, because... reasons, I guess. How's it a 180? I'd classify all I suggest as refinement of previously existing ideas and pardigms. Removing interfaces is removing cruft from the existing duck-typed runtime-enforced language PHP is now. &gt;What is your list demonstrating? That for some reason you demand PHP meet your list of semi-arbitrary pet features, or it sucks. Do you apply the same standard to other languages? It demonstrates what I'd want changed personally, and I even put headings in to make clear what I just prefer vs what I think is a hard problem in PHP - and you addressed **none** of the things I actually called a hard problem, only nitpicked against the things I stated were my preference but not per se reasons I'd avoid PHP. You asked for this list. You got it. &gt; Do you apply the same standard to other languages? Do I have things I dislike about other languages? Of course. Do I have hard dislikes that make me avoid some languages in some contexts? Of course. Python 2 has some, and Python 3 has far fewer because it broke and fixed itself up a lot. PHP could do that same. That's my point. &gt;Do you think, probably, some of this might be kinda subjective? Check the headings on my sublists. &gt;Optional typing is by far one of the most powerful features a dynamically typed script can support. What do you mean by 'optional typing'? Because I specifically said I'm in favour of duck-typing for PHP if that's what you mean. If you mean the type annotations what did I say that removes that from PHP? 
Yep, you got it. Though, in my experience, the reverse is more likely to happen in practice.
&gt; No seriously, did you read the headings? I even bolded them. I saw the broken version before you fixed them, if you want to know. Anyway, have fun. BTW in PHP7 arrays that conform to an actual array will be an actual array internally.
&gt; I've read some pretty silly stuff on this sub, but this is one of the silliest. I agree with much of your response, but. . . &gt; Taylor came from the .net world, saw a need for a modern framework for PHP since PHP was wallowing in the dark ages at the time, and his goal was to build Laravel. Silly indeed. 
One use case is hosting internal applications. Sometimes a company just wants a ticketing system or wiki for its employees. Using an *AMP package on an existing network is both cost effective and fast. You just need to make sure to do the proper security legwork.
Why are your mappings not indexed by the element class?
The author's first example about why Yoda statements are confusing is incorrect: if (true !== is_numeric($var)) { } // vs. if (is_numeric($var) !== true) { } These are the same; both predicates will evaluate to true if `$var` isn't numeric, furthermore, it would never make sense to write such a predicate in such a way. `is_numeric()` is always going to turn a boolean value in itself, so this would be better written as `!is_numeric()`. The author seems to miss the main point regarding the "*yoda*" style, it becomes a useful safe guard *when comparing against constants*. No, you're never going to be able to stop `$a = $b` from happening, but you can stop `$a = 2`. Any decent code guidelines will dictate never do assignment in conditionals (albeit, I do it out of convenience and conciseness in personal projects.) - but that doesn't prevent you doing it by accident - i.e the root issue here. It's true that automated linting will most likely fail such code, as would stringent code review, but unfortunately not all projects have automated linting in place and reviewers are humans who make oversights and have lapses in concentration. Yoda conditionals are just another safety check. As for the argument about it being more readable - that's largely a matter of preference and opinion, much like many other topics - ident size, brace style and naming conventions to name but three - that people spend **far too much time focusing on**.
Not sure why you were downvoted, you're open to the fact you're biased and experienced in only one of the options - but despite this, *you actually demonstrate (first hand) the kind of reasoning* behind people having a tough time with Symfony. Those tough times can ultimately lead to people going the Laravel route, as you demonstrate.
I like to avoid `&gt;` completely and like to always use `&lt;` for inequality checks. That way I'm always consistent in my code in that when working with less than operators, it can always be expected that the leftmost value or variable will be expected to be the lowest value, and the rightmost one expected to be the highest. This especially looks very readable when checking if an int is between two numbers: if (3 &lt;= $var &amp;&amp; $var &lt; 10) { ... }
The main value I see in Yoda conditions is the case where you *want* to assign inside a conditional. Namely you can write while (false !== $pos = strpos($str, $needle, $pos)) { ... } while the reverse requires parentheses: while (($pos = strpos($str, $needle, $pos)) !== false) { ... } For someone following a minimum-parenthesis philosophy, the former code using Yoda conditionals is preferable.
I do notice straight away if there's a greater than operator. It's just that if I don't see a greater than operator, I understand the expression much faster.
"Advertised" -&gt; praised
I tried that. I don't think it's compatible with 3.0 =/
&gt; Some people are just too religious about these things.... Including yourself from the sound of it.
Personally, I think the former is less readable, and requires the user to explicitely apply order of operations to an if statement, rather than just hold "yeah, parens go first". YMMV though (I personally like assignments in conditionals for certain cases) :)
+1 for dreamfactory
as for slim 3, it just works for me without issues or I got lucky, not sure.
Well if you mean, "I'm" as meaning you specifically then sure. If you mean, "I'm" in the sense of "people" then that's what I was talking about.
Wow, I would be strongly against the first variant...
I write a lot of code for a living and do you know how many times I type if ($i = 21), hardly ever. Does this happen for anyone else enough to make a big deal out of it? Personally I hate Yoda conditions, it makes me think backwards to the natural way I speak (and form thoughts).
That you think Cake and Codeigniter are the only frameworks relevant to mention when Laravel 3 was released simply reveals your ignorance. Zend, Yii, Slim, Symfony, SilverStripe, Kohana, Solar, Prado, Lithium, Aura (Solar Redux), FuelPHP, Typo3 and numerous other frameworks were being used in production at the time. Of course, they all had their warts of nuances, but so did Laravel (and still does, at least in the eye of some). In late 2011 we even had the first release of composer which many of us were using immediately, even integrating it into existing frameworks we were using (e.g. SilverStripe which was the framework I was often using mostly because it had the best CMS at the time IMO). I'm not trying to shit on Laravel, it's great and I'm glad it exists and that people are productive with it, but people were productive with other frameworks in PHP before it, and we were in no way "wallowing in the dark ages". EDIT: Also many of these frameworks offered "proper" autoloading too.
Using inverse logic is almost universally frowned upon. $one = 1; $two = 1; if($one !== $two) { //bad logic echo "true"; } else { echo "false"; } if($one == $two) { //better logic echo "true"; } else { echo "false"; } The first example could arise linear problems with logic later on. Using `$one` and `$two` purposefully, you would expect `$one == 1` and `$two == 2`, but as the example shows, that's not the case and they both equal `1`. If you write code with the expectation for only one outcome here, you could be really screwing yourself later on. I see it all the time with Jr developers. My advice is that inverse logic for small things in small projects is no big deal unless its system critical, needs to be maintained, or is going to be used by others; but you're still going to get dirty looks. 
I don't try to speak for others.
Hmm. Maybe it was an environment conflict or something. I'll have to try it out again. Thanks.
Ok
Exactly my feelings. This silly stuff is a last thing I would care for. 
The author's example is just an example. It's not real code, and probably doesn't follow his process of using is_numeric() in an if statement (don't get hung up on it!). The author makes a valid point in the article which should not be overlooked because of one code example that you might not agree with. The point is that instead of making code that's hard to read, why not use linters that prevent the unwanted assignment mistake in the first place? It's a valid question that I would have of a project or set of code as well. I know that you didn't get through the whole article though, because if you did you would have understood that he knows that Yoda conditionals are an extra safety measure, but you would have seen that they were pointless if you linted your code properly.
Are you referring to Wordpress.org's showcase displaying Nike and other companies? Also keep in mind wordpress offers a VIP service which is fine-tuned for larger enterprise companies. Always keep in mind the devil is in the details anyway.. So if wordpress accounts for a quarter of all websites, what can you do with the other three quarters in your pocket? The 75cents..
Absolutely 100% spot on. I used to call that the problem of expected values. I never called it inverse logic. I shall call it that from now on! Also, All hail the === operator! 
symfony*
PHP 6 doesn't exist. Technically, 5.3 is 6. It was a mess so they never released it. They just skipped to 7 to avoid confusion with the PHP books that had been published for "6". You can buy books on it because they were published before it was released - or wasn't released.
Thanks for the explanation, didn't know this aspect. I'm by no means doubting the usefulness of the setup, I'm sure the people in charge had good reasons for everything, all I'm saying is that despite having built real apps in most of the major frameworks, I find myself unable to configure Symfony by heart; I have to keep coming back to the docs in order to make sense of the YAML staircases even after having used a component several dozen times (often in the exact same way). It could be I'm old and slow and my brain just won't learn new things as fast as it used to, of course. On the other hand, you have Laravel, which is so meticulously documented even in the code, you always know where to put which config value and why - you keep developing and stay in the code, without having to go back and forth through 20 tabs of multi-page documentation for every single component that's included by default. That's a major speed boost and helps people power through the learning curve. Then again, if you're a Symfony vet and end up on a Symfony team with a pre-configured project, it's like you're born with superpowers. Each has its perks, neither is (imo) better than the other. If I compare the frameworks to girlfriends, Laravel is a warm, open, communicative one - she insists on talking everything through and is willing to compromise. She'll tell me exactly what's bothering her and how we can work on it. She's a little childish and tends to change her mind about things often, and people tend to hold this against her, but is very easy to get along with. Symfony is a serious girlfriend, no time for fun and games - ready for a long term relationship and wants to move in right away, but her preferred way of communication is crossing her arms, turning her back to me and pouting until I either guess what's wrong or ask others who know her better.
Russian, Greek, Persian, Romanian, Turkish, Finnish and probably others. All these languages have no strict word order.
Damn autocorrect. Going to the symphony should be more popular too.
Gin-higugma ni Bob hi Alice. (Waray language) Higugma = Love
&gt; every second language I learn has words in different order. Programming languages are no different: deal with it. Your argument is very flawed: We are not talking about ANY language. Not sure if you are a programmer yourself, but for code in 100% of all cases it is English (code itself, comments, docs, ...). English therefore is (doesnt matter if broken or not) *the* reference. What your mother language is is totally irrelevant, as are any other languages.
&gt; Also, All hail the === operator! Indeed, in the above example !== is strict whereas == is not strict (!= would be the equivalent for ==). Big difference :) Better always be strict.
That information was new to me. &gt;Also keep in mind wordpress offers a VIP service which is fine-tuned for larger enterprise companies 
Thanks for the reply's! I am new to the language and just wanted to gather information and some things to look out for in the future
Just google, you will get a long list. Here are some examples bbcamerica.com, sonymusic.com, mtv.com/news/,beyonce.com etc.
While I agree with the video I don't quite agree that jQuery is a framework, looks more like a library to me. You just call a method of the jQuery object when you need to do something, I don't see how jQuery controls the flow of an application.
I don't have any LINQ experience but doesn't ORM's to it with a little help from functional programming? $orderedUsers = FROM $user IN $users ORDER BY $user-&gt;getUsername() SELECT $user; // If you want to make the order in SQL $orderedUsers = User::orderBy('username')-&gt;get(); // If you want to make the order in PHP (e.g you have a mutator on getUsername method) $orderedUsers = User::all()-&gt;orderDesc(function ($user) { return $user-&gt;getUsername(); }); Am I missing something?
Kind of. The difference being that LINQ isn't for databases, it's for items already in memory. If it were ever implemented, I'd prefer it to be implemented so that you can hook it to a DB or in memory, but that's not how I learned LINQ, and it's kind of optional. The idea behind LINQ is that you already have a list of users in memory. Or you have a list of whatever in memory, and you're using a query language to run through that already loaded list. The benefits are that since it's built in as a language feature in C# it's faster than doing these things in loops, and since it's a fairly human readable syntax it's simply more expressive, compact and readable than having your own functions, all while being quite powerful. Of course, it's been a many years since I've used LINQ, C# isn't my first language it's just what I learned for a bit. To be honest I can't think of many practical use cases for this, it's the kind of thing I'd want to filter on the SQL side, but the idea of having a Language-Integrated Query for in-memory items is just cool. Plus, imagine if it was implemented in such a way that the abstraction from the database or even the ORM was built in? So you could plug in your own Datasource, whether it's in memory, CSV, a database or anything else in to the LINQ query? Or if the feature was built so that you could hook this in to an ORM, and instead of using the ORM directly PHP just passed the parsed version of the query off to the ORM, and let the ORM handle the actual DB part. I love the idea of decoupling the query from the ORM and the Datasource directly. Hell, maybe this has already been done and I don't know it, or maybe it doesn't even make much sense from a practical standpoint, but it's fun to dream about
https://wiki.php.net/rfc/named_params
I'll keep that in mind the next time I write a Python webapp. To he'll with Django and Flask and Pyramid, I'll implement right on top of Werkzeug or even just handle WSGI myself. Believe it or not, frameworks tend to grow organically out of code. And they're at their best when they stay out of the way and only provide a gateway to what you're communicating with - the web, GUIs, external processes, etc.
 &gt;Frameworks are small piles of code that someone wants you to think are a way to structure your app. I find this comment really interesting. Taking from your tone, you sound like you are against using frameworks. I'm curious to your thought process and reasons behind your assertion. &gt;Prefer libraries. Frameworks want to be your bread and butter, and even whichever language you're in at the time is barely good enough for that. To be pedantic, everyone who builds anything of substance—including you—uses a framework. A framework is nothing more than a collection of structured and organized code (i.e. Libraries) that offers some sort of reuse. Some frameworks are not open-sourced (custom/home-grown), while others are open sourced (Zend, Symfony, Laravel, etc). Whatever framework you use, the idea is to do it the framework's way. Otherwise it can be likened to spitting into the wind—which is always a bad idea, unless you like spitting on yourself. Now I will go out on a limb and say not all [open source] frameworks are equal, or good for that matter. I personally find several frameworks to be lacking: * Zend Framework: over-engineered and difficult to use. There are too many "cooks in the kitchen" as far as I'm concerned, and could stand to simplify a lot of their code * Laravel: uses too many bad practices, such as how their database models promote the is-a relationship versus a has-a relationship (much preferable to be has-a to support abstraction). They also promote the use of public properties instead of accessors (data hiding). * Wordpress: (yes, this is a framework) this platform has promise, and should take a page from Drupal's book and rewrite their code base. It's a bastardized hybrid of functional and OO, and should pick a side and run with it. * Symfony: I don't have as much experience with this framework, but I do like how everything is modular. Some components could be further broken down, for example the dependency injection and its directory/file loaders would be great as a component by itself. I could go on, but I'm more interested to see your thoughts. 
JIT. At this point, I don't think php is lacking anything significant but more performance improvements of any kind would be amazing
You're not wrong. Serving plain HTML files should be noticeably faster on any hardware. However don't rule out a caching proxy like varnish or cloudflare. That might give you the performance gains without altering the "standard" model.
I don't necessarily thing "advertising" needs to mean that it was paid for. There is such a thing as free advertising (which is what laracasts is for laravel)
&gt; If they're so intent on making everything easier to use, why not allow programmatic configuration in a boostrap file instead of forcing people to learn the config structure? Check out the new MicroKernelTrait Also, creating a simple HelloWorld bundle is literally 2 php files: - HelloWorldBundle - Controller - HelloController.php - HelloWorldBundle.php 
my personal preference for personal non commercial projects. [HighMaps](http://www.highcharts.com/maps/demo) if you wanna use this in commercial projects then get the dev licence 
Downvoting because some of this stuff is factually incorrect.
You don't need it. 
Sure, I can agree with that.
 &gt;There are times at which I use them, either because they're the right choice This is good that you recognize that there are times to use certain tools and times not to use them. All too often I feel like programmers get so caught up in hype that they end up using a framework for the sake of using a framework. &gt;You're attempting to assert a definition that is not real. I will admit I double-checked the definition of "framework" to be certain, but the definition of a framework being structured and organized is very real. It's also not limited to its use in programming, but applies to any system that is organized and structured (i.e. Construction and politics). &gt;If you ask most practicing programmers whether the language itself, which fits your definition, is a framework, I think you will find a near-zero yes rate. As for "most practicing programmers", I can't speak for the community, but I do know the programmers that I know personally, and they all define a framework the same way that I do. We hopefully will see what Reddit thinks and can go from there. &gt;I generally don't. We can agree to disagree, but as I've stated, yes you do—regardless of what you'd call it. &gt;I feel like you're too busy arguing with what words mean in ways that most people would not agree with and representing your beliefs as reality for that discussion to be productive or enjoyable. Words and their meaning are important. As for arguing my beliefs, that is how discussions are born. You have an opinion, and o have an opinion, and we discuss those opinions. I would posit that if you find this discussion non-productive and I enjoyable, then you should take a long look in the mirror and ask yourself why. &gt;Besides, I'll just get mass downvoted for politely stating an opinion some more. This sub doesn't want participation. I'm here trying to have a reasonable discussion. I don't care about what gets up voted or down voted. The fact that I responded to your hidden comment should show that to some degree. So you have a few choices: you can continue with your negativity and I will give up trying to have a discussion with you, or you can meet me in the middle and continue discussing the merits of libraries and frameworks. Either way, have a good one and thank you for the insights you did give. I genuinely enjoy learning other people's points of view. 
Generics/Templates. I don't like have to manhandle the reflection all the time. Seems like un-needed boiler plate overhead that I'm sure the interpreter could do better/faster then myself.
Laravel isn't hype. Laravel is epic
You don't need any of the features you mentioned when everything is an object. Interfaces are not needed in ruby and encapsulation can be done very easily in ruby.
I think you do, there is no actual proof that annotations aside from documentation are beneficial. Look at doctrine, it makes a mess of things and over complicates things.
React all the way
Are you fucking kidding me
Feed feed feed the troll row row row your boat, gently down the shit stream 
Why do you need it? I really want PHP to be strongly typed but not static. Also we just need to add type hinting for object properties and typed arrays and we will have all needed information about types.
You already have interfaces for for objects composition and traits to reduce code duplication. What are the usecases that you want to solve with multiple inheritance?
Like in python?
Some times, I believe, It would be nice to say: this user has these properties and those properties. With PHP you can only do class x extends from Y and implements A, B, C. Multiple interfaces on a class makes what I call a god class. too many methods. I like multiple inheritance because it allows me to say a user class does login, logout. It then extends Roles to assign roles and reset password to reset its password. I am a huge fan of abstracting things into multiple specific classes, that may or may not only have one or two specific methods. Interfaces are ok for type hinting and dependency injection. But multiple inheritance is good to extend the base with a few additional sugar treats if you will.
&gt; The fact that I responded to your hidden comment should show that to some degree. The fact that you responded to a comment that says "I don't want a discussion with you because of your tone" by pointing fingers, lobbing insults, and attempting to continue a discussion at great length? That shows something, yes. . &gt; So you have a few choices: ... or you can meet me in the middle and continue discussing the merits of libraries and frameworks.
&gt; this user has these properties and those properties I solving this problem via value objects. &gt; user class does login, logout Your example break single responsibility principle and also interface segregation principle. Or i missed something. Does your `User` class has methods `login` or `logout`? &gt; I am a huge fan of abstracting things into multiple specific classes You should abstract things into multiple specific interfaces instead. This is called [Interface Segregation Principle](https://en.wikipedia.org/wiki/Interface_segregation_principle)
Framework Vs Library: Libraries you use to design or do tasks. Typically (not always) the rely on functional programming paradigms. Example: jQuery and Underscore. Frameworks use you. Typically they force you to use a specific convention in order to get them to work and you have to design around them to make things work. (they are the scaffolding) Examples: Any MVC framework (angular, backbone etc), RequireJs and Handlebars/Templating libraries 
&gt; it'll be fairly easy to have other developers come onto a project, because there will be less "explaining to do". Convention over configuration 
You are welcome =)
I disagree with his definitions. Libraries are usually used for some specific task. And frameworks could be considered collections of libraries, functions and classes (code reusability). See how Bootstrap is a framework and fails to comply with his definition of framework. 
IMO, Symfony has the best documentation around php frameworks.
Main difference between a library and a framework is that a framework is using Inversion of Control. With a library you have a control, while with a framework it's in control: the flow is defined already for you, you just hook into it.
Null safe operator .. https://wiki.php.net/rfc/nullsafe_calls
Even jQuery homepage claims to be a library.
That is a neat pattern. As you say, it makes the entire condition more readable. I will probably start using that style! Thanks!
&gt; My point is that getting downvotes should not drive you away from participating to the community. It doesn't. I've been in the reddit PHP community for about eight years, and the PHP community proper for about twelve. You've been a redditor for seven months. . &gt; This is how communities work You've been a redditor for seven months. . &gt; not everyone is going to always agree with you but that doesn't mean you shouldn't expressing your personal opinion. I don't understand why you're trying to give me psychoanalysis when I keep clearly expressing boredom and saying "have a good day."
I generally think of a framework as a set of libraries that work together in a consistent way and are aware of each other.
Yeah, like that, or even like Java - some standard wrappers for the primitives would be nice, and would have reduced the need for type hinting these as well, once they can be classes instead. MyString.contains(), .toUpper(), etc would be so more readable!
Context would be helpful:/Why develop a news/media site in php, when so many exist already? Give Drupal 8 a shot if you want something more flexible than WP, and you'll get exposed to some Symfony compomemts in the codebase too! If you really need to roll your own, then performance for news/media is not that hard, and best practice, as you said in a mother reply, is to do smart caching at various levels. As others habe replied, Serving static pages a la WP super cached is more properly implemented in proxies or CDN, although I'm sure you could implement something similar in Symfony if you really wanted to. Also, check out the Symfony content management framework, http://cmf.symfony.com 
I more like idea of some sort of syntax sugar rather than making strings as objects. &gt; and would have reduced the need for type hinting these as well If you want `MyString` type you already can write simple wrapper. And this doesn't eliminate need of typehinting. function foo(\string $str) : string{ return $str-&gt;substring($str-&gt;indexOf('foo'))-&gt;toUpperCase(); } This code could be transpired on the AST level into just usual function calls. Maybe this event [can be possible in feature](https://wiki.php.net/rfc/parser-extension-api#future_scope) via userland implementation. Anyway I don't even know is it possible currently to make some types of objects to be passed by value internally. if something like immutable structures/objects will appear, then yes. 
"Type annotations" are not the same as "annotations", young padawan.
You call a library. A framework calls you. A framework is a specific type of a library where "inversion of control" is extensively used at points of extensibility. Both have their use case, but frameworks are certainly overused, and unfortunately the impression has settled in that you *have* to use "a" framework, which is nonsense.
Named parameters https://philsturgeon.uk/php/2013/09/01/named-parameters-in-php/
Many see Jquery as a framework because how you write in jquery is different than normal javascript for building and manipulating page elements. It feels like a framework, but is a library.
Generics... SplStack&lt;Object&gt; plz
I'd love to see PHP 4-style value type objects again. Perhaps with a different keyword.
How would your user class not be a god class in your example? Classes are supposed to model objects, defining supported behaviours is what interfaces are for.
It's cool, I'm that guy too. Having to wrangle php to do anything asynchronously is shitty as hell
here is a cool use of linq. var twitterCtx = new TwitterContext(auth); var searchResponse = await (from search in twitterCtx.Search where search.Type == SearchType.Search &amp;&amp; search.Query == "\" justin bieber \"" select search) .SingleOrDefaultAsync(); if (searchResponse != null &amp;&amp; searchResponse.Statuses != null) searchResponse.Statuses.ForEach(tweet =&gt; Console.WriteLine( "User: {0}, Tweet: {1}", tweet.User.ScreenNameResponse, tweet.Text));
Ah, like for a forum stats-signature? I'd just set the cron-schedule to once every few hours.
It isn't too bad with things like http://github.com/icicleio/icicle 😁
classes should be as small as possible, IMO, and only contain specific methods to do exactly what the class states, ie: user class is too generic, userSignIn, UserProfile, RegisterNewUser all have very specifics methods. My argument is that these could be, in theory, inherited by some class called: User. this then allows you to test very specific portions of your application.
Nope like ranked score, when i play the game i need to check every minutes match are very fast, and when i don't play its useless
Not bad, but my own preference is to use [middleware like this](https://github.com/oscarotero/psr7-middlewares/blob/master/src/Middleware/FastRoute.php) or [this](https://github.com/sparkphp/spark/blob/master/src/Handler/DispatchHandler.php).
Generics, proper hasmaps and keywords, and destructuring would be nice, I believe is a better solution than named params.
Not to say I disagree with the rest of your post, but "this speaker" would be the guy who invented PHP. That being said, I agree with very little that he has said in the past 10 years. 
It's just a small component of whole system :) HTTP Server + micro service "framework" :)
I've been working with WordPress as my full-time job for a few years now - I don't know how I'm supposed to interact with a database without it. Is PDO still en vogue? mysqli? I ordered the book "Modern PHP", so hopefully that'll give me some valuable insight.
PDO and mysqli are still both used--I prefer PDO, personally. You'll hear others chime in and mention ORM layers such as Doctrine, Eloquent, Propel, Spot, etc. etc. etc. Most, if not all of them, use PDO/msqli as a backend.
Sorry, that was the auto correct on my mobile phone rewriting what I was typing. Anyway, geonames is afaik the most complete DB out there, and free, but I had to write a special importer for it to get something useful out of it
&gt; It doesn't. I've been in the reddit PHP community for about eight years, and the PHP community proper for about twelve. Says the stupid fuck who claims not to care about karma and shit like this. Fat lying fuck.
It's so easy to misread PSR-7 as PHP 7. We should have just named the latter PHP 8.
i agree, it's entirely impossible to differentiate falsiness from false. if only there was a strict equality comparison you're right about the execute once. oh well `:)`
PHP's performance is really [pretty good](https://benchmarksgame.alioth.debian.org/u64q/php.html); the main thing dragging it down in real-world performance is the stateless nature of PHP; other languages can do the basic framework code only once when the server starts, but with PHP it's on every request.
Well, look at the aspects of *behavior* and *control flow* in something like jQuery's $ajax. You define the behavior in your callbacks and jQuery takes care of the flow of control in how those behaviors are called on... $.ajax( "example.php" ) .done(function() { alert( "success" ); }) .fail(function() { alert( "error" ); }) .always(function() { alert( "complete" ); }); There is clearly an **inversion of control** design here. While many may refer to this as a library, including the jQuery website itself, I see this as a framework (*looking at it purely from a software architecture perspective*).
I think (hope) this will see much less usage in future since we have proper catchable errors now.
To build your own queries and other database interactions, i recommend you to use PDO, because you can easily change your schema if it's needed and you don't have to change your queries. Read the docs for more information, and good luck (: http://php.net/manual/pt_BR/book.pdo.php
Also, a better FFI (Foreign Function Interface) story, so that bindings to external native libraries wouldn't have to be C extensions and you could write plain PHP to call native functions. That is one thing that has hindered PHP from becoming a solid general purpose programming language.
So you read `$a = 'b'` as `A equals "b"`, right? Not `A is assigned the value of "b"`? (just an example) What I am showing is just that there is impedance between programming languages and real languages. Yes, we do DDD and all that stuff, but a programming language is a DSL for machines to understand that is a trade-off between what a machine understands and what we understand. My point is that the argument of "because that's how I read it in English" is moot, because machinery does not reason in English, nor your brain while you read the code: you are tuned to read the programming language that you mastered over years of continuous usage. It's a different language, treat it as such: I don't tell you how to write in English based on my knowledge of the Italian or German language. As long as the reasoning behind a sentence (in English, Italian, German, PHP, Java or Scala) makes sense, we're all fine.
Yeah, that was what I was getting at. 
I agree that that this is a partial form of inversion of control, but as I said just a partial. Unlike regular frameworks jQuery doesn't provide you with a code structure to built your application on top of it. Just having a couple of methods that expect a callback as an argument doesn't make jQuery a framework.
I beg to differ. jQuery does provide structure. From making things like event handling/registering consistent across different browsers, through a uniform interface, to providing an API that makes writing extensible plugins universally portable, jQuery provides plenty of this structure you're alluding to. Certainly there is varying degree of program execution control flow that different frameworks provide. I think this is probably where the line gets blurred and the *exceedingly vague* differences become the sole focal point of the discussion. Exceedingly vague differences such as "*code structure*" and "*bundle of libraries that cooperate*". I think that we each mean different things when we describe frameworks and libraries in this way and so no one truly has a clear grasp on what the other person means. It's much simpler to just look at it from the stand point of "*this calls your code*" and "*this gets called by your code*". Of course, some people will try to mince these words to draw an indefensible argument to this simplistic description. Though simple things are intended to be built upon. Not necessarily draw nearer to familiarity :)
I personally prefer using ActiveRecords as it is implemented in CodeIgniter; even if it's a smaller program that does not need the entire framework I still use it for prototyping so I can utilize the profiling functions for debugging; but PDO I would imagine is still very active as I still get a slap on the wrist on StackOverflow from time to time when I mention using anything else. 
Regular reminder that [Telegram is not secure](https://eprint.iacr.org/2015/1177) and your conversations are not private. * Encryption is not turned on by default. * Even when it is, it's not IND-CCA secure. Further reading: * https://tonyarcieri.com/all-the-crypto-code-youve-ever-written-is-probably-broken * https://paragonie.com/blog/2015/12/let-s-re-think-security-trade-offs
I have no idea. 
s/reply's/replys ;-) 
&gt; Haha, you PHP devs don't cease to amaze me ummm... why are you even here? 
s/replys/replies/ ;-)
&gt;which is precisely where it works better Bullshit.
Catching has nothing to do with handling. There was no more reasons to use @ in the pre-PHP7 code than now. To get @ from the code you need education, not catchable errors. 
Reddit is a social platform, right? I would say symfony already has a good external social platform for developers. If I had to guess the other languages have more subscribers on reddit purely because it offers more social outreach.
Enums! There was a RFC for it. Would make dealing with web services with types much easier. So many string warnings!
Eh, Windows (and DOS before it) uses it for paths, it's not so bad.
Well this was not about Telegram's core platform but about a bot inside their platform. Even if it's not secure, At least it still offers way better features than WhatsApp and other similar services and has some level security compare to their competitors.
&gt; and has some level security compare to their competitors. Their security level is the same as "effectively plaintext" because they can access it from the server (even if they claim to not store it). It's cool that you wrote a bot framework for Telegram. I just wanted to take the opportunity to remind everyone that it's bad security-UX and even worse homebrew cryptography and **don't trust it with anything sensitive, ever**. The current state-of-the-art for private messaging is Signal (but I also think it can be done better). I'm going to be working on making Signal integration possible via [Halite](https://github.com/paragonie/halite) in version 2 (but it's GPL and version 2 requires PHP 7 + libsodium).
An informed decision is intrinsically better than an uninformed decision.
I'll bite. You have 10 implementations of the same API, say 10 cache drivers (memcache, shared memory, Redis, Mongo, MySQL, SQLite, file, etc.). In Ruby, how do you ensure the object you're given implements the same API? Not just some of the same method names, but the same exact API you expect. In other words, how do you ensure the developer would have to at least be *aware* of the required API to implement, and *declare* it's implemented by their object, or the IDE and runtime would produce an error. What's the clear, short, formal way to document a public API with many implementations in Ruby? Where's the place to put that? What's the clear, short, formal way for a method to say "I need a cache" and for the caller to say "here's a cache", and for the cache to say "I'm a cache, all right"? Not just "I need some object", "here's some object" and "I'm a random object". But a cache.
My point is simply: Just because you're aware of a fact doesn't mean the rest of the PHP community is. Telling people about the insecurities baked into Telegram only ensures a broader awareness and harms nothing.
C# style property accessors as described in [this RFC](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2).
Inline object declaration with sugar. e.g. instead of casting an array via the very ugly (object)[] or new \stdClass; $myObj2 = new Obj( prop1 =&gt; "val1", prop2 =&gt; function($t){ return $t*2; });
[It could have been worse ](https://wiki.php.net/rfc/namespaceseparator). 
Do you have a PayPal account, I want to send you some change. You seem unemployed.
PDO is a *least* possible solution. You could use it but consider to get yourself to another level. Modern PHP is *frameworks*. No book can teach you modern PHP if it teaches you PHP only. And almost every framework, save for micro ones, has a distinct tool that dramatically improves database interactions - an ORM. And to learn an ORM should be your goal.
Generics, GettersSetters, NumericString, Threads, Proper Namespace Implementation, Proper Closure Implementation, Datastructures in StdLib, Annotations, Variable Typing [Gradual], Enums
Not a problem at all to do this in userland: https://github.com/amphp/amp Only advantage of a native implementation: everyone would use the same underlying system instead of multiple incompatible libraries.
&gt; Fuck you sir. Maybe you should learn to program. So your bar for "having learned to program" is "to use a framework". Do you realize this makes no sense? Let me ask you, if given the time, can *you* create a framework from scratch like Symfony? Do you know how every part of Symfony works? Do you know why every part is designed like how it's designed? Using a framework is easy. Especially using it poorly. But understanding the thinking behind it and how it works, and being able to critique it, improve it, or even create a new one, and all the thinking that goes into this process... It's another thing entirely. It separates the boys from the men, as the saying goes. Here's an interesting fact, by the way. You insult OP, you call them incompetent, and you're declaring their code *you've never seen* to be "spaghetti", for no other reason, than they suggest we don't immediately jump to an existing popular framework for our projects. Do you know who else did the same as OP? The folks at Sensio, who *created* Symfony from scratch. Symfony was their home grown framework. They didn't just untar an archive with CodeIgniter and setup their little project in it, no, they created their own framework. Do they not know how to program as well? Shouldn't you tell them "fuck you, learn how to program" as well? The irony in all this is framework users are nothing like framework creators, but you talk about yourself as if you're in the same team with the creators of Symfony. "We" this, "we" that. There's no "we", here. You're a framework *user*. Using a framework can be a viable shortcut for some projects, and there are frameworks which are good, and there are frameworks which are suitable for a specific type of project. But don't try to wear the fact you *use* a framework as a badge of honor, because it's not. Using a framework proves you can program just as much as having a meal proves you can cook.
I'm aware of it, but I felt it was too heavy for what I wanted to do.
&gt; *The difference being that LINQ isn't for databases, it's for items already in memory.* As I understand it, the idea of LINQ is to provide a common syntax for querying various data sources. There's LINQ-to-objects which indeed queries object collections in memory, LINQ-to-SQL to query databases, LINQ-to-XML to query XML documents, LINQ-to-LDAP to query Active Directory...
I'm that guy too.
Meh, I would still probably prefer `:::` or `..` to `\\`
Some time ago, I was writing a simple "few routes only" REST API as a side-project for one of the other apps I am working on. My first choice was Slim (however I considered Silex and Lumen too) And indeed, over the last year, its size increased a lot. Because of the dynamic changes in the project requirements, during that time I had to add the packages to handle the views (with support for Twig), things like Ratchet, helper libraries for some 3rd party APIs etc. And to answer your question. I don't think that the micro frameworks are suitable only for the small (minor) projects, even more, I think that at the start point they're often faster and more scalable than the "bigger things" like Zend, Symfony or Laravel. And so far as it utilizes composer (or something like that) to manage the dependencies, it's quite simple to include new packages and to make it suitable to basically any requirements. Because, at the worst case scenario you can always use the parts from the big brothers like Symfony Components etc. Of course at the other hand, there is a cost of a lacking features and possibilities, but it's always something vs something. 
I also find it kinda fun, I have to hunt different components and I get to read on various implementations and solutions to the same problem and evaluate whatever fits best instead of sticking to the default solution. Of course this has the frustrating disadvantage of figuring out a proper solution to every problem, sometime as simple as sessions (which I'm trying to figure out at the moment).
References?
Multiple incompatible autoload functions ([__autoload()](http://php.net/manual/en/function.autoload.php) vs [spl_autoload_register()](http://php.net/manual/en/function.spl-autoload-register.php)). I know spl_autoload_register is the preferred way to autoload, but it would be nice to see __autoload officially deprecated.
Function renaming/interception/events - perhaps a bit like Wordpress's actions/filters - so I could : * intercept/check/catch/log the full stack trace for calls to mail() (useful when hosting many sites on one server) * intercept database/xmlrpc/soap queries and add logging for time taken/results returned etc. Hopefully without having to modify an application's codebase. 
Why do I need to remove the "$" when i want to set a private value inside a class? class My_Class { private $a = 0; function set_num($b) { $this -&gt; a = $b; } }
Did you take a look at Cake 3? it is usually very fast to pick up and has really good documentation. [Check the quick start guide](http://book.cakephp.org/3.0/en/quickstart.html) to get an idea of how it works.
Small frameworks are small tools, you can build a house with a hammer but wouldn't you rather use a nail gun? It's all reliant on the skill of the Application Developer and their ability to Engineer good code.
Thanks, I heard about cake php will look into this. Good documentation is a major plus in my book. 
I always accept offers, but I have my own dignity. I don't want your filthy money, product of deceived customers and the selling of subpar products. Stop your mafia.
Your second two points make perfect sense to me. But the first idea, that Django is simply too much... What do you mean? Why does it matter if it's too much? Too much what? Is there any answer to this other than the points you made in your second and third paragraphs? 
After reading the other solutions provided i searched for an alternative, if you want to trigger a process from the loading of a page and still don't affect the current page loading, you can use curl_multi to load a *"concurrent"* script ...usually you put a waiting loop or a callback function, but in my scenario you can simply forget about it. The *(almost?)* next time you load a page you *should* find the content updated. Flags and implementation up to you to find out.
It's mostly because of the latter points. But Django's also gotten big enough where "there's the Django way" and "the Python way". So odd or poor choices aren't called out, and even if they we're they can't be fixed (easily or without backlash in the community). Take routing. Say what you will about regex patterns, but the actual declaring your routes. You create a file called urls.py, declare urlpatterns in it and fill it with these odd strings and it just automagically works. Need to mount another part of your application here? Use this magic `include` function and point it at another urls.py. I don't like big frameworks because they resist change in the worst ways. 
Where can I read more about future features of PHP 7.X and what's planned to be deprecated in the future to improve the language overall as a whole?
Pick anything PSR-7 middleware compliant: you will see the difference in 5 years, and it will be worth it.
In summary: Make PHP it's own thing instead a cheap copycat of Java. I agree.
I sometimes get the feeling I'm loading a lot more things than I need to. I needed to create a simple application which showed a few iframes based on the user's request, the iframe's sources were loaded from a configuration file. For that I don't need any of the Symfony components except Router and Twig, why load them?
Yeah, suppressing the unnecessary emission of warnings/errors is the only reason I ever use the `@` operator, and that's also my answer to the question of what feature do I wish PHP didn't have. Another example is that `ldap_bind()` will always emit a warning if it fails to bind. Why? What's the point? Is this not what `ldap_errno()` and friends are for? It's mildly infuriating.
Reasons why I don't use large frameworks: 1) Internals are messy. [ laravel ] 2) Big platforms have big attack surfaces [ joomla ] 3) Big platforms have larger base response times [ you can look it up ]. 4) Most of the time the ORM/DB Layer that is packaged with the software is not the one I want / need to use. 5) Larger packages are much slower to adopt new changes 
Who?
why is it bad?
I love the way you access multi-dimensional data, may try this in my current [config library](https://github.com/G4MR/Configs) which has a similar idea. I like this approach better though. Maybe you should rewrite/update it using interfaces so it's easily extensible with other configuration types that aren't just YAML.
Found via this post: http://danielpocock.com/the-easiest-way-to-run-your-own-openid It is being rewritten currently for a 2.0 release.
Yeah I know, "loading" was the wrong word perhaps. It's more of a preference thing? I'm not sure how to explain it, it's just it feels heavy with all those components being there when I don't need them to be. Plus I prefer the mix-and-match approach as I go along, using some other DI container with Symfony's DI being already there feels wrong. Also, Symfony does load it's bundle and autoload configuration which slows things down a bit (see [this](http://symfony.com/blog/new-in-symfony-2-8-symfony-as-a-microframework))
To see the granular changes, check the release notes: http://us3.php.net/ChangeLog-7.php The migration guide gives an overall look at the changes between versions: http://us3.php.net/migration70
[SlimPHP version 3](http://www.slimframework.com/) has just been released. I've used v2 and it was wonderful. 
&gt; everyone would use the same underlying system instead of multiple incompatible libraries. Exactly why I would want it native. Also, even better performance optimizations could be made.
[removed]
Here are the RFCs that have been implemented for PHP 7.1 already: https://wiki.php.net/rfc#php_71 Here are some ideas for PHP 7.1 from engine developer perspective (most of the things here are internal concerns, not user facing): https://wiki.php.net/php-7.1-ideas As to deprecations, I've created this [deprecation RFC](https://wiki.php.net/rfc/deprecations_php_7_1) today to collect stuff that should be deprecated. If anything comes to mind, do tell :)
We built [Bolt](https://bolt.cm) on Silex. The main reason for using Silex instead of the "full stack" Symfony, is that we're a bit more flexible when it comes to the structure of the project. 
Wait, wait. Let me guess. You don't like PHP.
Thanks &gt; Nullable return type: function foo(): ?int; (returns int or null) RFC or Union types (and add null as possible type) RFC Was just thinking about this :)
Different symbol tables for constants, functions and classes/interfaces/traits. Similarly different tables for class constants, properties and methods.
It's definitely a preference thing and a microframework might be a good solution depending on the project, I wouldn't assume that a microframework will be faster though and as you said in your original post it's easy for the project to outgrow the microframework. When you say "heavy with all those components" I still don't see what you mean as you'd only ever use those components which you need, same as with a microframework.
Because I normally need only a few features the full framework provides and you spend a lot of time either removing or disabling stuff especially if you use any sort of scaffolding tool.
You need to look at the tags: https://github.com/xdebug/xdebug/tree/XDEBUG_2_4_0RC3
Scalar object syntax in the core: https://github.com/nikic/scalar_objects Cleans up needle/haystack inconsistencies, allows chaining of methods and encourages very readable code.
https://github.com/nikic/scalar_objects + https://github.com/rossriley/php-scalar-objects for OO syntax on functions around scalars.
Most PHP users will not run in repo auth mode. Heck, I consider it a good day if they have APCu active. The big news here is that PHP7 comes optimized, more or less, right out of the box with no real work needed to use it. It's a very low resistance path. In contrast, HHVM is a really different experience. It's built by a company that has there own needs. Right or wrong, it adds mental burden, via differences with vanilla, that most devs won't bother with. When you add that the speedup is going to be a small fraction above PHP7, then it's a complete non-starter. There are significant differences between HHVM and PHP. I know, I've worked with both. I prefer classic PHP, warts and all. However, I love HHVM because without it, we would not have gotten the speed we got in PHP7. So, big shout out for HHVM and yay for PHP7. :) 
Lowest still supported version. 
Large frameworks are slow. Large frameworks have a crappy unit testing experience. I don't want to learn your large framework testing strategy with it's special built-in mocking and faking library bullshit because the controller/router/response portions cannot be easily and, more importantly, obviously isolated. Large frameworks provide allot of wrappers for what is already present in core PHP. I love OOP. However, I also find it really useful to call out to the PHP standard library without worrying if I should be calling the framework to do the same thing that core provides (e.g. basic validations, password hashing, etc). Large frameworks take time to learn. Large frameworks take time for new hires to learn. Large frameworks cannot be swapped out with something better. For example, I'm stuck with Zend Framework 1 forever in one of my projects. Uggh. I can't swap it out with something better because it is a framework and not a library. That same project also uses Doctrine 1. Doctrine 1 sucks, but it is a library. Guess what, I am slowly removing it. That's good. I wonder if in 10 years my successor will be able to maintain the Zend 1 app. Will the documentation still be available? I guess we will have to write our own security patches by then. In other words, we are going to have to own the framework. I don't want my company to have to own Zend 1 ten years from now because it is EOL. On the other hand, I can't see my company doing a rewrite either. So, yeah. I guess that means I get down-voted because I'm not a fanboy of the flavor of the month framework. After doing this for 11 years, I have found that large frameworks (e.g. Zend, Symfony, Laravel, etc) are all about the makers of said frameworks being able to stroke their big epeen. I'll pass. The only tools I need are Composer, core PHP, unit tests, S.O.L.I.D. OOP, and some good architecture fundamentals. 
My guess would be because it's the latest 5.x.
&gt; Yet another PHP app being benchmarked on HHVM without porting the code to use any of HHVM/HACK specific features. If it did use Hack-specific features, then it wouldn't be a PHP app, so you couldn't benchmark it against the Zend Engine. And it's not like Hack-specific features necessarily make HHVM run your code faster. They aren't there for performance reasons. &gt; The fact that HHVM/HACK can do so well while handicapped is a statement in of itself. HHVM is not "handicapped" when running PHP code rather than Hack code. It is a dual-language runtime. It is designed to be able to run unmodified PHP code performantly. &gt; Take the time to utilize the engine for its full potential and see what happens to PHP7's dominance.... Probably won't do much to it, because Hack code isn't PHP code so you're closing yourself off from the PHP ecosystem.
I would never write code that ties me to HHVM only. That path only leads to darkness.
We write all of our code specifically for hhvm using hack. I can tell you that your "probablies" are unfounded because our "real experiences" tell a much better story for optimized hack code vs the php code. If facebook decided to pull the plug on hhvm/hack we could always come back to pure php. They two are very similar.
A framework is your master because it calls you. A library is your slave because you call it. Frameworks can feel oppressive. Libraries feel freeing. Frameworks are like North Korea. Libraries are like living in a totally free country. Libraries can be decoupled and isolated. Frameworks get all up in your business. I guess the choice is yours. 
Not only that but completely incompatible with some fairly standard things.
I doubt hhvm will ever get close to the marketshare of php. When we first started playing with hhvm we were just running the pure php code in it like this benchmark. When we started using hack features like Map and Vector in place of php Array we started to get more and more performance. My only complaint with hhvm/hack is the documentation started out fairly terrible in my opinion but it has gotten better. We also stay with the LTS releases for production. 3.11 was not kind to us in dev. edit - hhvm version 3.11 not 3.12
I totally agree. However, there are two camps here. There are the people like you and I that deal with this mess all day long at work. Then you have the FOM framework fanboys.
We added a script (`hhvm-repo-mode enable /path/to/root`) in recent releases to hopefully make it a single command where it does work; though yes, it just doesn't support some features, almost all related to dynamic programming, eg the problem here is: class_alias with non-literal parameters is not allowed RepoAuth make optimizations that require it to know your code ahead of time; `class_alias`, `eval` and so on make that either impossible or impractical depending on the code base. Fortunately, they're rarely needed in modern projects, but agree is completely fair to benchmark without it if it's unsupported. In general we'd recommend avoiding them anyway as they make code harder to debug/reason about, but they're a fact of life for old code.
Why did you feel the need to re-iterate the same point 4 times in the same thread to the same person?
TL;DR: Performance is not a good reason to pick Hack. Features are - and for others: no, [that's not just 'types and performance over PHP5'](https://docs.hhvm.com/hack/). Unless you're porting from synchronous code to async and using the native async functions, porting to Hack will not make HHVM execute your code faster than it executes PHP code that is consistently executed with the same variable types. Porting from another async system to Hack's async is also unlikely to give you much of a speedup (though will usually give you significantly cleaner code). You can also get a small speedup by using [`HH\autoload_set_paths()`](docs.hhvm.com/hack/reference/function/HH.autoload_set_paths/). Also, you mentioned the collections in a comment (`Set`, `Map`, `Vector`) etc: we do not consider them to be (and have not seen any evidence that they are) faster. The benefits are the OO API (`-&gt;map()`, `-&gt;filter()` and so on are really nice once you're used to them) and the well defined semantics of a specific collection instead of "everything's an array". Object passing semantics (sort-of by-ref) are considered an advantage too by some, but we're [now considering that a mistake](http://hhvm.com/blog/10649/improving-arrays-in-hack).
You're really pissed about this. I was offering an opinion on micro vs macro frameworks, and why someone might choose a micro framework. I didn't come here to start a language flame war. I actually really don't like Django but it pays the bills. So I use it. As for your other point about why you should care about Python (and other languages) and it's libraries is the same reason I care about PHP and it's libraries: it's important to look outside your bubble and see how other people approach the same problems. Sure, you probably can't use the specifics (Python has metaclasses and descriptors which don't exist - to my knowledge - in PHP), but you can look at the techniques and learn from them. One thing I like coming out of PHP is the big push to use DI, which I find sorely lacking in the python community. So I learn from your community and apply it to mine.
Flavor of the Month I've seen a ton of them come and go. It's like watching a parade of cargo cults.
&gt; It's more of a preference thing? I'm not sure how to explain it, it's just it feels heavy Your instinct is not wrong. Listen to it. 11 years ago, I used to listen to them too. Now, I know better. Libraries = YES, Frameworks = NO. I need lots of libraries. Core PHP is the only framework I need. 
Point taken. But then again, spaceship operator. ;-)
Potentially almost all of them, eg if something like this exists: if (class_exists('SomeThingDefinedWithClassAlias')) { SomeThingDefinedWithClassAlias::doFoo(); }
I'd love to hear about your preferred framework/library/IDE/tool/favorite color. I bet it's amazing and completely immune to critique and fits every single person's use cases perfectly. 
Hopefully you just mean the misnomer, and not the actual feature.
Just a small correction: 3.12 does not exist yet, so I guess you mean 3.11? We're still looking into the issues with 3.11 - some are fixed in the nightlies, but others we've not had a way to reproduce yet :(
Very true.
See. Sometimes you have to support (or implement) some solutions, just because there are specific project requirements, or other people, like frontend developers, that have experience only with specific tools. And if you need them to work on the project, and to make them to learn things quickly, you can't just force your opinion. Anyway, please don't compare Smarty with Twig. It's like comparing a massage chair with the electric chair. I mean, you can use both of them, in the pretty much same way, but because of the differences inside the project, design and specification, only one of those might be used to relax, and the other one is deadly thing. Smarty was terrible, indeed. But Twig, although not perfect, is a way more "developer friendly" than Smarty ever was.
Hopefully one day we'll all be as enlightened as you. Until then, you can keep setting us all straight from way up on your high horse. 
[K](http://i.imgur.com/nOXVdJZ.gif)
I wish it was not so easy to circumvent the call to the base constructor parent__::construct()
You can't leave a comment like that without explanation! What do you find so dreadful about CakePHP?
Hi, thanks for your reply. &gt; Perhaps it's trying to load extensions and failing? Possibly - but it works from `cmd.exe` so that's what's confusing me. Also, I'm using the stock php.ini, no modifications or nothin'. &gt; Though I should perhaps ask why you're using the official Windows build of PHP in Cygwin Only because that's what's worked before - Cygwin is good at allowing you to use Windows or Unix stuff. You can use Windows executables from the command line, or bash utils, and they all "just work". Well, mostly. But thanks, that's a good idea, I'll try compiling the Unix PHP and see what happens. I just wish I didn't have to worry about Windows at all. But hey.
It's actually very easy to migrate from one framework to another. Just use a URL namespace and rewrite it to the other framework's front controller. Iteratively port your endpoints over time, and sprinkle in redirects where necessary. Eventually your whole app will be in the namespace and you can drop the old framework and either leave the URLs or move them back.
New programmers will make mistakes regardless. It will be a learning experience for them, like it was for us. I don't think diminishing the language is the right action. This kind of thinking is what leads to features like magic quotes.
I'd prefer a template library/engine/thing is used because : * they can be configured to automatically escape data making XSS harder/less likely. * they generally have a number of useful functions (e.g to create dropdowns) * it makes it harder for PHP code to appear in the 'view' layer. * i prefer the syntax of e.g. smarty's {if $blah} ... {/if} over a PHP style &lt;?php if ( blah blah ): ?&gt; ... &lt;?php endif; ?&gt; 
I personally feel more comfortable writing plain PHP (oldschool) in views, but pure php is not the best option for bigger websites when you need layouts, partials and other features like that. Inside my team i'm solving this issue by using template engine which is optimized more for frontend developers (html friendly) but all control code are written on php.
To me, the primary service of a templating system such as Twig is it provides constraints around what your view layer can and can't do. Here's a few scenarios where a templating system with constraints may be useful: * When the developers who work on the project may be changing often (such as at an agency or dev shop) * When non PHP specialists (front ender) may be working with views directly and benefit from the reduced complexity There's other benefits you can argue that are more specific to a given templating language, such as: * Being more expressive/readable than plain old PHP * Having built in security for things like string escaping * Having built in functionality for extending or reusing existing view code 
There's nothing wrong with pure-PHP templates, but you have to understand when to use the right tool for the right job. When you need the templates to be modified by end users, having the templates in the database in an effectively sandboxed language is *way* more sane than exposing PHP to those users.
Was curious with loads under concurrent users, and any bottlenecks through infrastructure.
As I said in another comment: &gt; It's cool that you wrote a bot framework for Telegram. I just wanted to take the opportunity to remind everyone that it's bad security-UX and even worse homebrew cryptography and don't trust it with anything sensitive, ever. I think your project is neat. I don't want to take away from that at all. I just want to remind people, as often as I can, that Telegram is crypto snake oil and actively harmful.
Oops. Definitely having the problem with 3.11 not 3.12 as you pointed out. 
I don't think that's feasible at this point, as we don't have any real alternative. The only other way to both get the response body and headers is to use fopen() with stream_get_contents() and the wrapper_data in stream_get_meta_data(), which is rather cumbersome. We should first provide some more better way to get at the headers. (But I'd love to get rid of it!)
We don't allow constants in traits.
Which orm would you recommend for php then?
&gt; Most of the internet is using 5.5.9 (from Ubuntu 14.04 LTS) Citation needed.
Agreed.
I've never worked with Symfony 2 directly (just Laravel) but doesn't it still bootstrap every controller? I thought this was the reason that all S2-based frameworks have much lower TTFB then some of the 'leaner' frameworks.
A conversation about pros/cons of "big" frameworks isn't relevant to someone who writes php? What does the number of frameworks that I mentioned have to do with anything? 
CI uses DataMapper, but they (incorrectly) call it ActiveRecord.
I knew there was something different about it but wasn't sure of the specifics, definitely adding data mapper to my list of stuff to look further into.
Why does loading a page without caching take *four seconds?* Am I missing something there?
&gt; Proper Namespace Implementation Could you give an example?
There is also static classes like `DB`
&gt; Phinx Any source of code to learn? (seriosly)
There is no reason why plain php can't do layouts and partials
I use twig. I have used it for everything for a while now. Same way as we use SASS/Less on the front. Yes it's another layer but it simplifies the task of creating more complex layouts. In it's cached state it renders to normal html/php so meh. Biggy: It enables me to create child themes which can easily be swapped/changed without needing to touch the underlying components themselves. Then you have the auto escaping easy access to filters/custom filters... 
But I think it is an issue with the frameworks - most if not all actively encourage tight coupling between the framework and your own application code. - "Create a model class by extending our abstract base" - "Pick up your db connection by requesting our singleton instance" - "Your controllers need our DI container to access model instances. Here's how to do it" - "To render your content, pass the template file path to the framework's own view instance here" The current state of play is that if you develop on top of a particular framework, you're kinda tied to that framework and a migration will entail a rewrite. Granted, a talented team will be able to develop a framwork-agnostic model layer, and possibly a corresponding service layer but that's realistically the best that you can currently hope for. 
&gt; If migrating requires a rewrite, you are writing heavily coupled code. Welcome to most frameworks.
Actually I think large frameworks are the best option for small projects because small projects will usually never have to worry about performance bottlenecks and there is usually a high value based on getting them done quickly, also they tend to be run of the mill CRUD apps which most frameworks basically have 70% done for you. It would be on a bigger project that I would want more freedom architecture wise.
It should also be pointed out that [HHVM suggests you warm the cache up with 12 requests per path](https://github.com/facebook/hhvm/wiki/performance-tuning) while the aforementioned benchmark warmed the up once and then did three runs. There's no way HHVM had a warm cache at all for the tests. 
I like Twig. * Context-sensitive escaping becomes very easy. * Twig syntax is reminiscent of Django development * It's extensible; you can create custom tags, functions, filters, etc. (I exploit the hell out of this!) * Support for caching, etc. baked in. Is it a bad practice? Well, I don't care if it is; I enjoy using it and it doesn't make my applications less secure.
&gt; Welcome to most developers' naive usage of frameworks. Couldn't agree more. ;-)
A framework is nothing but a collection of components that just so happen to have the same vendor. There are some frameworks that take it to a higher level and actively encourage using it for everything, but it's not par for the course. Most that I've used stay out of your way, and while they all offer everything and the kitchen sink *if you choose to use it*, it's basically up to you as to how well or poorly you design your app, and how coupled it is to your vendor code. That goes true for both frameworks and libraries.
The GO AOP creator has a laravel example. https://github.com/lisachenko/laravel-aspect/blob/master/aspect.php Create an `AspectKernel` then load it up after including the composer autoloader. That's basically it. Take a look at the docs, they're really good. http://go.aopphp.com/docs/initial-configuration/
zend-expressive, slim 3 and symfony 3 are all compatible, as far as I know. The implementation of PSR-7 is not that relevant, but your app should be able to deal with the interface.
&gt; Agree, as PHP, Nodejs is just another shit, less shitty of course. Tell me, o' wise one, if I were to make a cart website from the ground up to sell chewtoys, which technologies should I use?
&gt; cart website from the ground up to sell chewtoys That falls in the category of cheap context for subpar software, which is fine to use PHP, since there are already pre-made solutions like "prestashop" and such. You don't need to do it from the ground up. 
because if twig templates and the DI container aren't cached, you're gonna have a bad time.
most of the internet is still using a 5.3 or 5.4 version (security patched by distro) or panel provider like cpanel
&gt;subpar software Not sounding elitist at all there. Anyway... Okay, let's say I want to create a piece of software which will accept user's gift preferences, and find prices across Amazon, eBay, AliExpress, etc. of it, and also present alternatives based on keywords and image similarities. What then?
Not directly PHP related, but... Anyone got any experience in funneling poachers? There are a few that want to try to get me as an employee and I'd much rather convert them into consulting clients through [my employer](https://paragonie.com). I'm trying to be as direct as possible without being rude, but so far it just kills off the communication. Would I be better off ignoring them?
1. Static page caching, however sounds impressive for the noobs, is seldom used in real life. There are other means to speed up a site. 2. It is hard as hell to implement as well. In reality, there are always dynamical parts, like ads, snippets and such. No to mention such sites like Reddit where content is changing every second. 3. At my last job we served a million hits to dynamical pages a day. Although several chaching mechanisms were used, nobody had an idea to make static pages. 
I'm not sure what you mean by "colour mode", but it sounds like you want to convert between different representations of RGB colours. I don't know of a library for it. For my last project where I needed to do HSL-to-RGB conversion, [I converted some C++ code line-by-line](https://github.com/TazeTSchnitzel/PictoSwap/blob/master/include/graphics.php). I think there being a package for this in PHP would be quite useful. The basic conversions are very simple to implement (you can look up the algorithms on Wikipedia!), but not having to do them yourself means less work and less bugs. Colour (at least outside the simple world of sRGB) also can have many subtleties in reality (it's a complicated thing much like time and text are, below the surface), so having someone competent implement it is helpful.
Again, caching is a two-blade sword. Everyone is talking about caching but never even mention *cache invalidation*. While stupid cache can be irritating. I hate when I see the new questions on Stack Overflow from AJAX notifier, but when I reload the page, I can't find them until cache rebuilds. Beside your nice workers you have to think of a cause that will make cached pages to rebuild.
Looks somehow dodgy to me.
Oh, I get. Your business plan was: 1. Troll PHP community. 2. ??? 3. Profit by offering PHP services. Are you looking for venture capital? I'd like to invest in your company.
/me shakes head A clever retouch, but yet it is true: most (if not all) of the large frameworks encourages, promotes, and rewards "heavy coupling" in different ways. Doing so inside the large frameworks is not "naive" in that sense; it is the framework-author's *recommended and preferred* way of using that framework.
I thought it did years ago. 
I listed `global` because it's redundant with `use` semantically. I'd rather PHP only had `use`, and `global` just went away completely: &lt;?php $bar = 123; $foo = function () use ($bar) { /* ... */ }; function foo() use ($bar) { /* ... */ } class A { public function foo() use ($bar) { /* ... */ } }
This is a legit offer from Microsoft. Check it out before saying anything.
Outlook is a Microsoft's email service. If you're using Windows, you may have an account already.
&gt; I trust these sources but sometimes I like to sit on youtube and watch people build stuff. Huh. I'd been hesitant to record any of my coding antics precisely because I thought nobody did that. &gt; I feel like the PHP community is struggling to move forward but the bulk of work done is still stuck in the past. Well, I've been [cleaning up old, popular, and insecure answers on Stack Overflow](https://paragonie.com/blog/2015/12/year-2015-in-review) for the past year almost. I can't do much about the high-ranking Google search results outside of SO. If you, as a newcomer, feel that my time/energy could be more effective if applied elsewhere, I'd love to hear it. (I recently submitted two libraries to phpclasses to try to reach a wider audience, but they haven't been accepted.)
There are only two points about templates that makes them really great: 1. Auto-escaping. 2. Template inheritance All other points make very little difference. Say, most of commenters stress on preventing PHP users from writing spaghetti in templates. **Just look at those users' application code - you'll see HTML all over the place.** If one don't understand the importance of separation of concerns, no template engine will make them do so.
Sorry for the dumb question. I refer to code of any proyect. I look in Phinx and is awesome.
&gt;There are other ways. Say with actual dependency injection, if a template isn't given a MySQL connection it can't use one. Problem solved. The problem is it's executed PHP. If the framework can construct a database connection so can the template. &gt;And you have to admit it'd be rather unlikely for someone to plop a full connection sequence right in the middle of a template. That would be outright a cause to get fired, to be so incompetent. This is more about the third-party template market. Unfortunately you can't fire an independent designer selling a template at ThemeForest. It's anecdotal of course, but I've seen terrible stuff like this over and over again. It's why I've changed my mind on the subject.
Probably discovering/interpreting Symfony configuration files and writing the fast cached copy (big hunk of generated PHP) for next time.
&gt;Just because something is rarely used, does not mean it should be removed. I didn't intend to make that argument. What I'm trying to get at is it should be removed for the same reason it's rarely used: it's [confusing and bug-prone](http://paul-m-jones.com/archives/6072). Bracketless conditionals hurt readability because of the style clash with the rest of PHP, are easy to accidentally create a bug with while being difficult to debug, and all for the meager advantage of not having to type two characters. &gt;The groups who vote for PSR's aren't bound to follow it, because its just a suggestion. It carries no authority. I agree. No one is bound to it. But it *does* show a consensus among some of the biggest names in the community. The issue was voted 16-to-3 against in the [PHP-FIG code survey](https://groups.google.com/forum/#!searchin/php-fig/Style$20Guide$20Survey$20Results/php-fig/vGm-0nqUSTs/uPH_jHsBOb8J).
Did you ever try it? Say use mysql without LIMIT or auto_increment?
&gt; colons or full stops for namespaces instead of backslashes [bikeshedding](https://en.wiktionary.org/wiki/bikeshedding) &gt; ternary operator associativity had been fixed for PHP7 Yeah, I would have loved to have to review every ternary in our legacy code. PHP7s much slower adoption rate would have totally been worth it too. I'm glad you're not in charge of what goes into PHP releases.
I am of the opposite mind. I love PHP arrays and think that they are one of the reasons the language is so attractive. I find their flexibility to be extremely important and really easy to work with. What the language should do is add all of the things you talked about but keep the current arrays as they are 
I made a small one a couple years ago for someone: https://github.com/sathoro/color-tool
From a quick google: https://github.com/hasbridge/php-color https://github.com/mikeemoo/ColorJizz-PHP 
[ColorJizz](https://github.com/mikeemoo/ColorJizz-PHP) can convert Hex, RGB, HSV, along with other commonly used formats.
Use a database. Aside from your primary key, also have another int column for 'list_item' which you use to group your rows. 
Go to a PHP Conference. They're expensive, but the knowledge, book recommendations and community feel you get from there are priceless.
Well, when you don't want to compile your templates to get max performance or flexibiliy - yes, native php can do everything. But i'm always caching partials (a lot of partials) and layouts, so templates are compiled for 400-800ms sometimes but invoked in runtime for zero cost.
Things I would like in PHP: * Return type declarations - "$this" to be supported (I can provide a class or interface name - not ideal if I want to rename a class - or "self" which means "the interface/class this is declared in" - however, I want to indicate that this method always returns the currently declared object) * Return type declarations - support inheritance (if a method says it will return "XYZInterface" and class "ABC" supports that interface - but has additional "items" - then I ideally want to state that returning from that method will be a class of ABC. At the moment, the return types need to be equal on inherited methods) * Arrays to implement "ArrayAccess" and other similar interfaces. (I don't actually care if method X is passed an actual array or an object which implements ArrayAccess - I just want to be able to access it like it was an array) * All objects to inherit from a base class OR for the "object" type declaration to be supported (again, some of the time, I just want to receive an object and I don't actually care which class it is from) * Multiple types to be accepted in method parameters (for example "string|object") * Internal PHP functions to have return types and parameter types declared to match the documentation. * Relative namespacing (i.e. "use ../ParentClass") * Traits to support interfaces (I have a "common" trait which implements ArrayAccess, Transversable, Serialize etc which many of my classes want to use - I really want to indicate that by using this trait it automatically means those interfaces are supported). * Properties to support type declarations. 
&gt; The problem is it's executed PHP. If the framework can construct a database connection so can the template. That's not how dependency injection works. Either you're given a connection, or you're not. If you're not, then chances are it'll be non-trivial to reproduce the chain of dependency that leads to you obtaining the connection, because you have no direct access to the container. You're quite correct many frameworks don't get that right and they allow practically global access to all their services. But those frameworks don't implement DI correctly, if at all. DI is quite powerful when done right, and it helps enforce architectural boundaries within a project. &gt; This is more about the third-party template market. Unfortunately you can't fire an independent designer selling a template at ThemeForest. I'm not aware of people selling Twig templates at ThemeForest, are you? They're WordPress, Joomla and so on. &gt; It's anecdotal of course, but I've seen terrible stuff like this over and over again. It's why I've changed my mind on the subject. I've seen terrible stuff too, but I've not been in a situation where I can enforce usage of, say, Twig, for a given site, but I'm unable to review the code that'll be used. Some of those template engines come with a "sandbox" mode which is intentionally made secure for untrusted themers, but many don't. And many don't *by default*. In fact, many allow PHP blocks through a special syntax by default.
For php7 you could use a anonymous class.
Without question THIS. The best of the best teaching you the good stuff. You can learn (or touch upon) 10 books worth of knowledge in 3 or 4 days depending on the conference. I've never had a bad conference experience, and I always walk away with tons of new tools, new people to follow, and a renewed desire to make cool stuff. If you're not hitting up the conferences that are even somewhat close to you, you're cheating yourself.
I agree its not proof of its awfulness. And you're right, thats kind of what I was trying to say. I love PHP. I think for many use cases it is the best choice. However as things stand now if you come across someone who's first and only language is PHP then the odds are they are not a good programmer. You say regarding "PHP being a first-language": &gt; it's very common for people wanting to learn back-end web design And thats the problem. What you are describing is a graphic designer who is trying to teach themselves programming. I have yet to encounter a graphic designer who taught themselves PHP who wasn't rubbish. Its very hard to learn to be a good programmer like that. There is a reason we do 3-4 year degrees to become programmers. And a designer trying to teach themselves and then competing with me in the job market is frankly insulting. People like that demand lower wages and undercut the skilled programmers out there. I know that sounds snobby, but I invested a lot of time and money into my training. As have many others. They are actually really bad for the industry and for PHP. Employers hire them because they are cheap, and then complain about the lack of skilled PHP programmers out there when they don't perform. This phenomenon of people self-teaching themselves PHP as their sole language and then going out into the job market is the reason for the two biggest problems with PHP today. 1. PHP programmers are seen as not as highly skilled as other programmers. 2. PHP programmers in general get paid less than the programmers of almost every other language. I'm not saying people cannot be self taught. Only that PHP as a sole language generally does not give someone the overall understanding of programming concepts necessary to consistently solve complex software architecture issues. I find invariably that people like that write software simply to get things working, with no thought of whether its the best way to get it working. They think having the software work at the end of the day is a success. But then when it has to be extended/integrated/maintained, and I delve into their code, we end up having to re-write most of it. And then explain to the client why it costs so much and takes so long to add simple features to their applications.
YouTube video's take hours to produce unless they are verbatim live recordings. Verbatim live recordings are always less polished, and really hard to do well (hat goes off to anyone that can off the cuff deliver value). Heavily produced content in any form, tends to not be updated so often, it's expensive to produce and it will always suffer problems. The same problem exists with popular growth-heavy systems. I don't want to tiddle on anyones bonfire, but you cannot be the scale of facebook and deliver value. In the end you'll end up peddling noise to morons because it helps you talk about velocity at some talk. &gt; What are some good sources to watch PHP in action with and without frameworks and libraries? As for "frontrunners", I think this is part of the problem in modern programming. Everyone wants to hit the spotlight and be the next faceache, zuck, etc... It's lead to a culture of celebrity where popular "frontrunners" talk absolute twaddle about auto-incrementing id's being a security risk... I am not saying these people are not clever, or incredibly good at their jobs; the danger is not from them; it's when a community fails to recognise they are human, and everything that they produce might not be gold plated. The culture of celebrity encourages many to blindly follow advice without engaging brain. I think this is actually more prevalent in some circles and it's definitely not PHP specific. &gt; How would you define the PHP community: Mostly using it correctly, split, mostly using it incorrectly with the frontrunners trying to change it? Anything significant; if given long enough will likely become incorrect... What you need, is to spend less time coding at this stage (arguably at the other end of the spectrum too when you are really great), to set up thought processes, procedures that you may revise in future to help you. We are not rocks, and I really wish people would not think in such static terms, or get locked in a cycle of repeating what has been done already to try to progress. &gt; Would a site be useful that people could vote on sources and discuss their usefulness? Or maybe a subreddit?
You're right, the README.md doesn't include HSV in the list of supported formats, but there is a [HSV](https://github.com/mikeemoo/ColorJizz-PHP/blob/master/src/MischiefCollective/ColorJizz/Formats/HSV.php) class, and the other color formats include a toHSV function.
&gt; I'm starting a new project, client have decided basic functionalities, I'm looking for a framework that will let me add features in the future and it will make easy keep coding as the application grows. I should go with a framework? microframework? just add some libraries? Is this a question, or a template for a question where you forgot to replace all generic stuff with specific requirements?
Clutch find, bro.
&gt; Troll PHP community. I didn't do such thing, just saying my opinion which happens to be 100% true. &gt; Profit by offering PHP services. Lol, what? I would never contribute to the proliferation of such abomination, not even for money. &gt; Are you looking for venture capital? I'd like to invest in your company. As I told previously, I don't want your filthy money earned by deceiving customers and the selling of subpar products. Stop your mafia.
Do you realize you're one step away from running on the streets naked and screaming that lizards control the world by peeing poison in our water supply?
Lumen/Laravel combo is pretty solid. You get the advantage of a micro-framework with Lumen and if you need Laravel features or want to rewrite the whole app in it, it's compatible.
The lest release? Don't you mean the last release?
I've used this before. Saved me so much time.
I preprocess them. My autoloader supports sending the code to a preprocessor when the extension is not just ".php", but, say, ".tpl.php". There's also, as usual, file cache so preprocessing happens only on source change, and the ability to compile your entire project's templates to a plain PSR-4 class tree, so preprocessing doesn't happen at all on the production server (the entire engine doesn't have to be present if that's the case, the templates become normal PHP classes). It is a template engine, sort of, but I thought "fine, I want like 2-3 basic features in PHP to make a decent template engine: escape, and content blocks /can be used for "inheritance"/, that's all. Why invent a new syntax I need to maintain by registering custom functions and plugins for everything? No need. So I just upgraded PHP into a template engine.
Well done! I love this approach a lot.
&lt;?= $json #raw ?&gt; You can always relay on comments in tokens_get_all as it parses string.
I believe not using a templating engine bad practice (if you are generating html). The reason is security. Twig does contextual xss escaping by default. This really is how you want to secure your software (not via odd xssclean functions and such). And it is too easy to simply forget a call to htmlspecialchars in your PHP template. If the templating engine supports automatic contextual escaping, then it is good and you should use it. If not (smarty for example), then it should be avoided at all costs. The only thing worse than no security is the appearance of security when it is not there...
Misspelling a public property on a class silently creates a new property. No error here.
SOAP gives me so much pain and suffering.
You beat me. I still think that the goal (to keep PHP as a template engine at any cost) doesn't worth the hassle, but this trick looks plausible.
Almost every existed template engine converts DSL into plain php, it's only a better controlled shortcut. Obvisouly this approach should't be used in cases when templates can be modified by "end user". 
My frontend developers working with twig. They have all application running locally via vagrant or docker. And this is kinda best practice.
That one is also new to me :) But after quickly skimming the documentation, I'd say it does exactly the same, and probably has more features. It seems to be a bit harder to get started with though. The package in the OP only requires two lines of code, and then you have all your classes.
That's a really good tip!
Laravel doesn't follow SemVer ... *shrugs*
Give them and isolate environment where they can work locally without to much hassles, use Git, do code reviews regularly. 
Makes sense. I hadn't heard of it but after browsing the docs it sounds perfect for your use-case.
Even the mention of SOAP gives me anxiety attacks
&gt; Why do we look up to these people? I don't, they are just as your average developer with the difference that their code is public and acclaimed by the masses, but average to not say more. &gt; do you create your own framework? Any composition of code is a framework per se, is your code is very composable (with simple functions or libraries) and is reused through your application, you already build your own framework. &gt; So if you are not a god, should you create your own framework? or should you use the ones the gods handed down? The thing with frameworks is that they are made to appeal the **masses**, they are trying to be everything for everyone, but maybe at most 20% of their API is related/use to what your are doing, which make the other 80% bloat. Another thing to consider if that frameworks promote an opinionated architecture and conventions that you must follow in order to work with it effectively, which take away a lot of flexibility from you. Also if we are talking about frameworks for the web, they tend to abstract most common patterns that do not concern with your business logic (like auth, form validation, migration, templates, etc) but you could do the same by using single purpose libraries while retaining a lot of flexibility. Popular framework are like blue print for starters, if you know what you are doing and you don't want to abide yourself to a framework, then you are welcome to build your own for your specific needs, even on top of others frameworks and libraries.
&gt; Why do we look up to these people? I don't think it is a case of looking up to people like gods, but more of a culture of respect. For me, it is not just the framework "gods", but also package builders/maintainers. Remember these are open source projects. If Potencier or Otwell say jump, question them in order for you to understand more than anything. They started the projects and are still heavy contributors, but there are plenty of other contributors of *all* these projects. Anyone that puts their time into something that can be used by the community should never be sniffed at, even if to certain people, the framework/package is wrong in some form or another? At the end of the day, anything you write is going to be legacy/technical debt in some form. If you do not learn by someone with "lesser" knowledge than you, then you need to rethink your attitude (in my opinion). &gt; do you create your own framework? From symfony or zend? I would say to build a "framework" to the extent you need. I was, and still am a Symfony Framework user but, have been using [stackphp](http://stackphp.com/) to put my own stuff together to get a better understanding of what goes on under the hood. What you build it from is up to you? Start with a fast-route or something and then add on as you need it. (Don't forget to document it for the ref point when learning, if you want that it.) I used [this](http://fabien.potencier.org/create-your-own-framework-on-top-of-the-symfony2-components-part-1.html) from Fabien Potencier which is now obsolete and updated [here](http://symfony.com/doc/current/create_framework/index.html). All I will say, is that using a Framework does not make you a bad programmer or not having the ability to know how to program as at the end of the day all a programmer is, is someone who uses a set of tools to build "stuff". A framework is a tool, and can be a very good one for rapid development or relying on something that has been well tested/used/abused. If you want to get an understanding on how things under the hood work, I would suggest build your own out of any of the fantastic packages/libraries out there from Symfony/Laravel/Slim along with AuraPHP or the php league.
Who'd win in a wrestling match, DHH or God?
God, because DHH doesn't do tests anymore as he is so good, and that would be his failing. ;)
Color Jizz???? That's not a library I could freely discuss in dev meetings. Might as well call it Graphicowank
In the year 2011 I decided to develop my own PHP framework. The goal was to to develop a more performant and flexible framework then Symfony and Zend. So I began to analyze all my existing projects and merged the most important functions and classes. I learned a lot about architecture and modern OOP concepts. One day I used travis-ci and examined the code quality. I was not very satisfied with the result. So I started with a complete refactoring. The refactoring went so far that I replaced my own classes by other libraries. To my surprise, I realized that my classes and functions where almost identical to those of symfony. Luckily it is possible to integrate specific Symfony components via composer now. Then I replaced the SQL query builder by Doctrine DBAL. But soon I realized that Doctrine can't handle null values for queries. Thats why I and replaced Doctrine DBAL (after a long search) with Laravel Illuminate. I've heard that Doctrine will no longer support the migrations. Quickly I have decided use Phinx for writing migrations. For performance reasons, it was important for me to use a native PHP template system. The winner was "Plates". For the UI (frontend) I use jQuery and Bootstrap. Only for assets and JSON-RPC support I have developed by own libraries. The hardest part was to combine all these parts harmoniously together. The result is a framework with the best components of the open source community. I've learned: - It was a very hard and long way. - It is possible to combine/replace any components/libraries for your requirements - Symfony is a framework for frameworks. I never would use the full stack symfony framework. - Composer is the "glue" between all libraries - You never stop learning. 
What's wrong with the music from Star Wars? http://starwars.wikia.com/wiki/Jizz
even if that frameworks components add that layer of security you end up missing in custom hand rolled frameworks?
you're right you do not stop learning. Would you ever use said framework for actual projects released to the wild that are built by your company?
people tend to have a negative reaction to hand rolled or cobbled together frameworks because of one reason or another. if you rolled a framework tomorrow from symfony components using composer why do you think the reaction would be not as welcoming as say laravel, which is the same boat.
Don't trust a single thing sent from the client. Sanitize all the things! When you don't have layers upon layers of abstractions, it's not really as hard as you'd think. You access the data via $_GET or $_POST, and you make sure the very first thing in your framework's runtime is to validate the shit out of anything being read from those two variables. Pair that with PDO prepared statements, storing files outside of the document root, configuring Apache appropriately, etc., and you should be in pretty good shape ;) But seriously, validate and sanitize the shit out of your GET's and POST's!
I would use urlencode to properly encode the url (in the same way an HTML form would encode it): http://google.com/?id=James+%26+Conner&amp;vi=38293
One of my co-workers worked on the project, where they took HttpKernel, PHP-DI, Doctrine2 and FastRoute instead of symfony fullstack. The reasons was: - fastroute is faster, and we don't need much from router. Symfony/router is an overhead for them. - php-di is more easy to use. symfony di, without autowiring and with more verbose configs also seems to be overhead. - httpkernel - as an abstraction layer around HTTP. Also stack-php was used (as i can remember). - Doctrine2 - as the best ORM available. In persistence ignorance we trust. They didn't used symfony/validation. OptionsResolver was used for simple assertion of HTTP requests. Also no any serializer, no other things. Just plain old PHP and some other third party solutions for their own needs. This custom framework will work **only for this particular project** and didn't took much time to build it (thanks to composer and PHP-DI).
You'll have to write your own parser to parse $_SERVER['QUERY_STRING'] in a manner thats suitable for your input
&gt; Theres been a lot of talk around the community of "if you use a framework you don't know how to program" and "we need to stop using frameworks" even some saying "frameworks for life yo!" (obviously not exact words, but you get the point). No. I don't get the point. In which communities are you hearing this? Because I haven't heard this anywhere in any reputable development communities, PHP or otherwise. &gt; We have a tendency to say Taylor Otwell, Fabien and even Andi Gutmans, Zeev Suraski (Zend Framework) are gods. Who's "we"? No, "we" don't. Taylor, Fabien, and especially Zeev are arguably under FAR more scrutiny than the average developer. "We" just happen to leverage the tools they provided, and "we" try to contribute towards those tools as well. &gt; Based on this when some one comes along and is like "look at my awesome framework hobbled together from symfony" if you are not Taylor, you are shunned. You are told to stop re-inventing the wheel and to, essentially, GTFO. Where are you even getting these ideas? If a framework is written - and written well - then it doesn't matter who you are. If the tool you're providing addresses a specific issue that you feel other tools fall short, then the only thing people will care about is how the tool was written: * Does it use modern PSR standards? * Does it leverage modern tools (like Composer)? * Are there unit tests? * Do the unit tests achieve - or come close to achieving - 100% code coverage? If the tool that you've put together can at least meet this (VERY basic) criteria, then you're far more likely to receive constructive feedback. Where I think you're confused are the fairly common cases where a user will come in saying "**LOOK AT MAH ROUTER**" - or some variant - and link to a zip file on their Wordpress site containing an .htaccess file and a Word Document with poorly written instructions. It's THOSE cases where you'll see a more brusque - or even outright hostile - response. &gt; So if you are not a god, should you create your own framework? or should you use the ones the gods handed down? Even if your language is deliberately dramatic, thinking this way is absurd. There are no "Gods" in any reputable community. Anybody who says either a given author is infallible or worthless - both absolutes on opposite ends of the spectrum - will be rightfully treated as an imbecile. Where you're also confused is how a given author is actually treated in their respective community. If an author has earned the respect of their community by not only writing and maintaining a well-accepted library, but also contributing to the libraries of others, *then they will be treated with greater respect within that community and their opinions will hold greater weight*. They aren't treated like "Gods". They're treated like experts in their respective fields among their peers. **tl;dr;** Taylor, Fabien, and Zeev didn't win the lottery. They didn't just show up out of the blue with their frameworks, and everybody treated them with reverence. They have spent considerable time and effort contributing to their communities, and adapting to modern practices. #Edit: If you're referring to [this discussion](https://www.reddit.com/r/PHP/comments/3y9ibp/grow_up_and_learn_how_to_program_yourself/cye8khr?context=3), let's address some things here: 1. OP was downvoted to hell, because - as mentioned earlier - he was more interested in denigrating people he deemed his lessers than actually contributing something worthwhile. This is not reflective of the community, and the vote system was used effectively to remove it from the front page. 2. /u/Coltrame doesn't speak for the community. Neither do I, for that matter. This post is almost a direct response to his and your comments, and you seem to be more caught up in your emotions than actually reading into what he and other users are actually saying. The community speaks for itself. And that discussion was rightfully squashed, because it was stupid to begin with.
If your API is JSON based, it is very simple. Each service point of the API, be it a route to a controller / method, or an individual php script, is going to query your data source based on the parameters of the url, put the results into an array, and then use the json_encode function to convert the array to a json object. You can echo this out or return it as a response to an http abstraction layer, if you're using one. Most of the stuff that shows you how to make a database driven php app should help you here, you just need to know that rather than echoing html, you'll put your results into an array and use json_encode. http://php.net/manual/en/function.json-encode.php http://php.net/manual/en/function.json-decode.php
Same with php, you execute `php file.php` in terminal or configure your IDE accordingly. IDE you're looking for is PhpStorm, kind of industry standard at least in my filter bubble. You get run configurations, proper debugger, etc. For the REST API, I'll save you a few hours of search and point to [Lumen][1]: a lightweight framework for building REST APIs based on Laravel. [1]: https://lumen.laravel.com/
I second Lumen. I would put Lumen in the same category as Slim and Silex. I would choose Lumen if I needed something more like Slim but with a full fledged ORM. I *really* like Eloquent.
With plain PHP templates it takes 1 millisecond to render a nested layout with a partial on my quick test: https://github.com/Petah/micro-template/blob/master/
Ah. With more explanation your point makes way more sense. I think an important question in any interview should be "what languages do you know", and see from there. If they name off 2-4 that aren't HTML or CSS, and can probe a little deeper into the libraries they've used (such as jQuery for JS) then you probably have someone who can do a job. If they just say PHP, or any one language, then you probably have someone more like me, who is self taught and doesn't have a lot of useful experience or wisdom to bring to the table. Anyway. I get it. PHP is, in terms of languages you can try to self teach, I think easy to learn. And a lot of people "know" it and give guys like you a bad name.
Try running it through [phan](https://github.com/etsy/phan). I would say it's bad practice to call a static object via an instantiated object. Static methods should be called as static methods.
could you create a 'wrapper' method on the class that can then call the method statically? That way if the (i really need to learn some terminology) dynamic method eventually needs to rely on the object properties, it is easy &amp; separated to change
This. It is fine to go from static calling to object calling as you won't get any problems - doing the change the other way around would go against what /u/zarandysofia said, breaking the application. Still this should only be done for legacy reasons and not on purpose.
I think so if only because it makes your code less understandable. I see `$foo-&gt;method()`, I think "this is a method that depends on the object's state" I see `Foo::method()`, I think "this is a method that doesn't depend on the object's state" 
Is not. 
I usually have around 40+ partials per template and 3-4 nested layouts, in a past it's been pretty inefficient :/
&gt; I think so if only because it makes your code less understandable. &gt; I see $foo-&gt;method(), I think "this is a method that depends on the object's state" All right. &gt; I see Foo::method(), I think "this is a method that doesn't depend on the object's state" I think more accurately you'd think "this method has no state". And many methods and functions have no state, for example all the array and string processing functions. Why would they have state? That would be counter-productive. A stateless method is not less understandable. In fact, it's often easier to understand than one with state. But state happens, hence why we have objects. It doesn't mean *everything must be objects*. A more accurate statement would be that static methods are bad when they hold hidden state, when the expectation is that they're "static" (stateless).
&gt; if anybody ever tells you this, walk away, because this person has serious issues and may stab you right in the face. no one has the right to dictate another's level of expertise based solely on the tools they use. I'm that person. First, to correct that quote, because I'm being misquoted here. I didn't say "if you use a framework you don't know how to program". I said that using a framework is a practical decision that can save time (depending on the project), but many wear it as a badge of honor, as if using a framework *proves they can program*, while they claim that *those who don't use a framework, can't*. What I said was that using a framework proves you can program just as much as eating cake proves you can make one. It doesn't prove you can't. It also doesn't prove you can. Second, this goes both ways. If "no one has the right to dictate another's level of expertise based solely on the tools they use", then I can object to people telling other people that they're *incompetent*, because they *don't use a popular framework for everything*. So, FYI. One thing about people who "can program" that I can say, however, never mind what they use, they can critique it. They know the benefits of it, but also the *drawbacks*. The majority of framework users, unfortunately, don't know why, for ex. Symfony was designed the way it is. They can't speak in depth about the benefits and problems of the decisions made in it. They just trust it. Blindly. That is certainly a sign that those people have more to learn.
It is corp policy to use an emulator and not a vm?
Re-read my comment.
Regarding __autoload() not allowing chaining, I'm unsure if globally available free-for-all chaining is a benefit or a drawback here. An autoloader trying to load a class and failing can be an expensive operation and doing that in a chain for every class means slow, expensive autoloading. Making the operation easily accessible in global scope, rather than explicit promotes this problem - every library tacks on their monstrocity at the end of the chain (or sometimes in front, which SPL allows and which is highly annoying, and leads to unexpected behavior and slow downs which are hard to track down). Interoperability can be done in other ways, for example libraries can contribute to a shared autoload map that a single autoloader reads from. This is essentially what happens when you use Composer's autoloader (especially with option -o). One autoloader to rule all. And chaining is still possible, through explicit delegation, for example: function __autoload($class) { // Explicit chaining that the developer is aware of and can be easily traced in code. if (!some_autoloader($class)) another_autoloader($class); } If people want to use the SPL API for chaining autoloaders, I'm fine with that. But deprecating the faster, simpler option for those who don't chain in this way, and need the performance of a lower-level API (__autoload doesn't have SPL's hardcoded internal logic that's impossible to disable and often unnecessary for some autoloaders), I don't think so. I hope this is reconsidered. As for the other two, I'm surprised those are supported yet, so good catches.
One of the features of Hack is relevant here: [XHP](https://docs.hhvm.com/hack/XHP/introduction). In my opinion XHP is the best way to properly escape input, create well-formed and valid HTML/XHTML/XML, and not lose the power of a programming language. It also does not have to be compiled to achieve decent performance (this always bothered me about Twig specifically). Given PHP's roots as embedded HTML I'm actually surprised that HTML/XML fragment literals haven't been added to mainline PHP.
Holy fuck. You really need to not care about this billionth of a second shit. Spend time learning about faster algorithms and forget this micro-optimization time waste.
Same thing the article said, by the way.
&gt; Again. It is not about particular figures for particular stupid test. It's about stupid approach in general. The difference is negligible already, you don't need no stupid tests to tell that. You should practice being less angry. Micro-optimizations don't matter in many cases, and they matter in some. People can use or ignore advice like in OP's article to their discretion. Nothing is "general" enough to dismiss, unless your experience is limited enough so you never had something contradict your "general" approach. For example, as a library developer, the accumulation of micro-optimizations in certain hot parts of the code can yield significant improvements in application performance. Read this, it might be educational: http://permalink.gmane.org/gmane.comp.db.sqlite.general/90549 Additionally, those tests confirm an intuition an experienced developer would have about comma/dot. That it's cheaper to have a single output call if the strings are short, and that concatenation becomes slower for larger strings, with the overhead being significant enough to outweigh the multiple output calls. Little things like that, you might not use them day to day, but they train your intuition, and one day you might use this intuition to optimize an I/O operation at a higher level, say SQL queries, because the same dynamics are at play.
It's not a superstition if the benchmarks confirm it with hard numbers, is it? Dot and comma do completely different things, and produce different, distinct performance profiles. Does the delta matter day to day? No. But it's there.
Full-blown denial mode. Take a deep breath. It'll be all right.
Not worth my time reading, moving on.
I always preferred [phpmig](https://github.com/davedevelopment/phpmig) over phinx, always felt easier to get up for me personally.
&gt; $a-&gt;bar() What do you think? Is it clear that you call a static method, or may it lead to confusion?
There are only couple cases when -&gt; is acceptable for static methods: * you call -&gt; against interface * bar is abstract Then late static bind taking place and needed implementation will be called. In regular code using -&gt; for static methods invocation is a bad practice.
Your statement is categorically false. Sure, this single test shows negligible performance gains. But what happens when you combine several of these micro-optimizations in a large code base? PHP may not be the language used where extracting every optimization counts, but having the knowledge and skill to develop great code is apparently a lost art. 
&gt; *I could also really use that password_verify function.* Have you looked into https://github.com/ircmaxell/password_compat ?
here we go again
A static method can easily have (static) state.
I'll bite, what is so bad about Smarty? Since version 3 it has (some form of) automatic escaping (http://www.smarty.net/docs/en/variable.escape.html.tpl) The syntax is much closer to PHP: &lt;ul&gt; {foreach $myColors as $color} &lt;li&gt;{$color}&lt;/li&gt; {/foreach} &lt;/ul&gt; {$name='Bob'} The value of $name is {$name}. Javascript (if you really have to embed it) works ok with single braces, as long as there are spaces. I'm working with Twig a lot and i like it, but i don't know if following another language's (Django, Jinja) syntax was such a good decision. To be honest I kind of like the idea of Thymeleaf (http://www.thymeleaf.org/, JAVA) recently, where templates can be properly rendered without any backend code (yes, i know there is PHPTAL).
Indeed. A friend of mine killed his site multiple times because every page load was parsing the database and ranking items manually. Once he understood that he could rank items just by adding some conditions to queries, items were ranked in real time without needing to parse the whole table with hundreds of thousands of items. Make your code smarter, not benchmarked.
DO benchmark your code - this is how you work out where the slow / greedy parts of your code are. Once YOU have benchmarked YOUR CODE in (as close as you can get to) its production environment, you then use this information to work out what parts of the code you should concentrate on optimizing. Yes, once you've started learning common problems you can quickly spot them in existing code and/or avoid writing code like that in the first place, but unless you benchmark your code it can be hard to know where to start and/or where you might make some real gains.
Benchmarking should be sections of code, not so much single lines of code. It doesn't help you find a problem in a loop running longer than it was supposed to if you're only checking code inside the loop. Knowing what to benchmark is far more critical than benchmarking in of itself. So I dunno, yeah benchmarking can help narrow down a problem, but really, the most it does is tell you there's a problem. 
Micro-optimizations are developer resource expensive - they can often mean spending large amounts of time, changing large amounts of code (often making it less readable), with absolutely no guarantees of any real world gains. Yes, micro-optimizations can be a legitimate consideration, but only after you've got rid of all the macro optimizations - which the vast majority of projects haven't done. You need to combine a lot of micro-optimizations to get an equivalent boost that a single macro optimization can give you. The PHP language is also constantly improving, meaning that micro-optimizations can often stop being optimizations because PHP starts performing the same optimizations itself internally (and with the improvements such as AST in PHP 7, this is highly likely to continue). In commercial work, in most cases, I'd even go so far as to suggest that it's probably a lot cheaper to simply upgrade the hardware / add more servers than spend any time on micro-optimizations.
I think you meant *profiling*, not benchmarking.
I wrote my first "framework" 6 years ago. It was insecure, had no standards, hard coded passwords in the code base and coupled so much it was terrible to maintain. That was for my dads website. It was for his pubs, nothing amazing but gave the me chance to learn, with a real world example. It lasted 6 months. So, throw away code. It was one of the best lessons I ever had from the self taught angle. I look at it now and would like to go back in time and slap myself. Move to now and I am 60% more confident in my abilities as a developer. I am building another "framework", but again, I am still learning. The concept of rolling your own is dangerous, but for progression, I would say it is more dangerous to just use everyone else's frameworks. I would advocate to build your own, if you are not comfortable then use another existing framework like Symfony, Laravel or Slim and break it. Explore the code base, contact the contributors and ask why they did x that way? Build one from the ground up with packages like the Symfony HTTP Foundation, look at using StackPHP for the foundations of your framework. However you do it, just ensure you adhere to [best practices](http://www.phptherightway.com/) and get involved with the fantastic community that PHP has. Hang out in the IRC channels [#phpc, #phpmentoring, #phptownhall, #php.security to name a few] and find a local user group. If one doesn't exist then create one. If you want to create a website ready for production, then I would suggest using SlimPHP [IRC #slimphp]. It's lightweight, the people behind it are great and you can get something built and then, providing you have kept decoupling in mind you can swap out SlimPHP for your own if you really want to? In terms of the "giving a hacker your personal info" comment, providing you take security 100% serious then you shouldn't have much of a problem, but then I am taking this as a lesson type exercise. Hope that helps...
It is not. Opcodes are quite evident for the results: dot involves number of concatenations followed by one IO, while comma makes consequent IOs only. But even being different in codes they are still the same in timing from the end-user point of view. It always makes me wonder why PHP users even bother with these nanosecond matters, being so tightly clutched to .htaccess, which involves additional **disk IO** for the every directory in the path serving the request. Which is (although still negligible by itself) incomparably slower than Net IOs.
I agree
It took me a time to realize.
&gt;I did a quick survey of the FIG members ... You linked to documents not code, that doesn't prove anything. But I will concede as to not waste anymore of your time. If you feel this strongly, why haven't you written a rfc to get this implemented yet? Out of curiosity, do you accidentally use braceless when you meant to use braces? 
[Erm...](https://www.reddit.com/r/coding/comments/3yruug/get_thousands_of_courses_to_learn_laravel_php/)
You should try /r/forhire, also no possibility of remote work?
Redditor for 33 minutes. One post. This link.
Thanks! I don't think I understood you right, sorry... How does `ContentHash` strategy save HDD space exactly?
Yes, it's micro-optimization, but I would like to comment : You did it wrong, because, you used buffering ! "echo" with comma, when you dont use buffering, is equivalent to multiple "echo" (extra CPU).
Oh, did you mean `md5_file()` function?
By the way, another suggestion is to apply base36 conversion to the hashes. It will slightly (by 6-7 letters) shorten filenames and at the same time will widen the number of directories involved, almost three-fold. E.g. 947145A1D650E859DEBBEDEAE5F87772 =&gt; 8SDG332ALAJ58F1KIS0XPAOHE Although for the case-sensitive filesystems it could be even base62, but for compatibility reasons it is not advised.
Oh, now I see... Nice idea BTW, thank you!
Well, PHP lets you add properties ad-hoc, which can be useful (with `StdClass` particularly). You can add a `__set` to make this an error if you want.
It is indeed weird how we have `use` for closures and `global` for functions. I'd also like to see `use` work on functions, if only so you can capture globals without them being references.
*can* be use useful, but also can be a source of very frustrating bugs when you have a class and don't expect to add undeclared properties to it.
Phinx is amazing!
Yeah it's dead. Good thing none of us are forced to use PHP versions as early as 5.3.
I'm also in favor of a native implementation instead of a PSR.
&gt; I'm struggling to see why this is relevant. Some applications have the info available through globals. Others can get the data through including a settings file. It can even be piggybacked through an existing connection. It really doesn't matter. If your framework has the resources to open a database connection so does any PHP file. Yes, the question is, as a themer I'm cooperating with, I give you this interface. I don't give you the name of my globals (of which I have none, but anyway), or my setting files or my connections and what they contain. You're talking about an application without architecture, where everything is globally available and known. And I'm talking about an application with architecture. Architecture is about interfaces and scopes, in a nutshell. This is not about bullet-proof security from hackers and other malicious parties (and neither is Twig, BTW), it's about enforcing architectural boundaries in your team of developers, where some are more experienced, and some less. Most PHP developers haven't experienced an application with any well-formed architecture, hence why I'm throwing that in, so it's known it's an option. A custom parser is not the only solution to enforcing boundaries. &gt; Again, I don't really see how that's relevant. It's relevant because I'm being told template engines like Twig are nice when some unknown third party makes templates for you and you want to constrain them, yet there's no marketplace for Twig templates. How is it not relevant that the given use case doesn't *exist*? &gt; What trust? There's generally no vetting of skills in third-party marketplaces, developer or designer. Envato doesn't even require that you support customers. What exactly are you saying dude. You hire someone to make a template for you, and you plan to not review the code for basics, but blindly rely on the template engine to protect you? Is that it? Do you realize Twig is not sandboxed by default? And even when it is, don't you plan to review that your untrusted themer doesn't link to a login-stealing JavaScript or something? Twig won't protect you from that. Heck I can even install a Bitcoin mining script on my Twig if you're THAT blind to what you run on your server. I can do a ton of damage to you even through Twig if I want. &gt; You can't restrict what code someone else can execute. It's a scary notion from a security perspective to even think that. Where did you pull that scenario from. Is this the real world? You don't trust your template creator and you don't review their code? What is this? Are you guys managing your apps "headless chicken" style, walking blind and committing code to your app from anyone? I just... the pain.
Let me rephrase, There may be some remote work you can do, the it is classified as an on site position. Meaning, theres remote work that can be done, but I wouldn't consider anyone not in the greater Orlando area. 
Whatever, it's interesting.
Right. I'm just letting you know, if you're not open to fully remote (modulo the occasional company meeting maybe once or twice per year), you're going to face an uphill battle. The most successful teams are fully distributed. Most developers are aware of the benefits to working remotely, and you will have an easier time acquiring remote developers than geographically isolated developers. Additionally, you open yourself to a wider pool of potential talent than whatever grab-bag of "people who happen to live in this area" can offer. (As for me, even though I live in the area, my last commute nearly killed me so I'm not in a hurry to travel downtown if I can help it. I'm also not looking at the moment. I just wanted to share some info that might make your search for talent more successful.)
Community is a big place. Your going to hear a lot of stuff that sounds widespread but may only be the opinions of a few. Frameworks can help you structure your code better and can save you time. They can also make it easier for another developer to jump into your code. To get stuff done you don't need to know what's going on behind the scenes, but eventually it could help you expand your understanding. I'm not into hero worship but these guys have created tools that help people be more efficient and make more money. So life lesson, If you want to be popular, help people make money.
Well, in a highly dysfunctional company, the fact you use PHP 5.3 is the least of your problems. Using PHP 5.3 long after it's EOLed is just one of the symptoms.
This is PHP. Trying to micro-optimize when you're at such a high-level is a losing proposition because if you actually cared about speed you wouldn't use PHP, and you can easily make far, *far*, **far** more significant gains by rethinking your algorithm slightly rather than caring about this.
&gt; __autoload() has no extra logic on it. It doesn't check if the class that should be loaded is loaded, and it doesn't maintain a list of autoloaders. It just directly invokes the single user function __autoload, if it exists. While SPL has that extra logic. So implementing __autoload() via SPL means... you'll just slow down __autoload() instead of speeding up spl_autoload_register() which is just "let's make __autoload slow so we can deprecate it". I don't get why you're so obsessed about performance of autoloader invocations. When considering autoloader performance, the main overhead will lie in stat calls, copying from SHM and class binding. I have very strong doubts that the performance of the actual *function call* to the autoloader is a real, measurable problem in any kind of realistic scenario. But be that as it may, when we merge the spl_autoload_register() and __autoload() mechanisms, both will be more efficient.
Probably the wrong word - profiling can :) Under PHP or HHVM: look into XHProf Under HHVM, you can also use the standard linux 'perf' tool - when the JIT's warmed up, this is really handy: if you're just looking at the HHVM process, it shows where time is spent in your PHP/Hack code *and* which parts of the C++ builtins; you can also tell it to look at your whole system, so eg it can tell you that you're spending your time in your DB wrapper, which is spending its time backing onto the C++ mysql client functions, and that's slow because mysqlserver is doing a bunch of stat calls, and that's slow because the kernel's crazy and using spinlocks to check auditd feature flags.
I tend to trust eg '95% code coverage' more than 100% - 100% is often the result of setting it as a goal and working towards a goal of "the tests run all the code" rather than "the code is well-tested". This can lead to a load of tests that only actually assert irrelevant stuff just to keep it at 100%. This is a general problem with setting something easily measured as a goal - as another example, if you set 'number of fix-now tasks' as a goal, this incentives people to file tasks at a lower priority than they should, often instead of actually fixing the root cause, then everyone celebrates because the number's gone down.
What is the best way for me to promote my site?
This. I was just about to write this, so thanks for saving me the trouble. This allows for dynamic dispatch, but is both visually and syntactically distinguishing that it is a static call. Best of both worlds. 
Finally someone posting here what should be obvious. I think the PHP community in this sub-reddit has been taken by "patterns" by storm and it has been trying to implement the most complex of them even for the simplest apps. Having a real domain driven design is actually quite difficult, time consuming and requires true understanding of the domain. This understanding is something that is rarely there, specially when starting a new business where the direction is still not clear. Striving for 100% code correctness and purity is in those cases a common cause of a mismatch between the business people and the tech people, and could easily lead to failure.
Yeah. Another quirk of `global` that's resolved by `use` is that it can't be used to import from parent scope inside nested scopes.
Here are a few well-intentioned criticisms: * The standard symbol for the metric prefix kilo- is `k` not `K` (so `kB` for kilobyte, not `KB`). * `B` is the standard symbol for byte in all cases. `SUFFIX_IEC = 'iB'` isn't a thing. The IEC *prefixes* are `Ki`, `Mi`, `Gi`, etc. so the `i` belongs with the prefix, not the suffix. * "Precision" is the total number of significant digits in a number (e.g. for `1.234`, precision = 4, not 3). What you're using it for (decimal places) is usually called the "scale". * The library is missing a way to "lock" formatting to a given prefix. For example, sometimes it's preferable to format 1500 bytes and 1500000 bytes as 1.5kB and 1,500kB, respectively, instead of 1.5kB and 1.5MB. This is mostly useful when being able to tell large variances at a glance is important (e.g. Windows does this for file sizes in Explorer).
You'll want to use [`hash_file`](http://php.net/hash_file) instead. Even though it's hard to create a collision in MD5, it's still possible. Use of a sane default like SHA-256 would be better.
See also this article (whole series really) from Mehdi Khalili: http://www.mehdi-khalili.com/orm-anti-patterns-part-4-persistence-domain-model/
We have to wait until NEXT YEAR for a new version?!
if that's the metric, they should have used PHP4. So biased. /s
In some ways it's about whether your objects are primarily concerned with data/archiving versus rules/execution. If your application is something like a blog, maybe a data-focused approach is better. Conversely, if it's a workflow tool that has to incorporate rules and approval processes from fifteen different corporate divisions, consider a domain model to help keep a lit on the insanity.
&gt; I think the PHP community in this sub-reddit has been taken by "patterns" by storm Isn't this more of a side effect given the "framework culture" in this community? 
Huh? Both `global` and `use` take variables from the containing scope.
`global` only takes from the literal global scope, not containing scope: &lt;?php function foo() { $test = 'test'; function bar() { global $test; var_dump($test); } bar(); } foo(); Output: NULL And if you move the assignment to the global scope: &lt;?php $test = 'test'; function foo() { function bar() { global $test; var_dump($test); } bar(); } foo(); Output: string(4) "test"
`function` inside a function doesn't declare a function-within-a-function, it just declares a global function. Thus the scoping rules.
It's trivial to manufacture a collision with MD5, actually. People do it for fun.
&gt; RFC: Array separator : [-]-[-] &gt; RFC: Parens separator: (.)v(.) &gt; RFC: Underscore operator and separator: \_|\_ 
Who is free typing enough large numbers to the extent that this would be beneficial? (Curious on the use case where this is a better approach over constants/statics on a "magicNumbers" class). I guess this is more of a "why not" kind of feature, the downside which stands out to me is that it makes typing magic numbers more manageable, which doesn't seem like a good idea. **EDIT:** The comments below highlight benefits which definitely outweigh the weak argument of "because magic numbers are bad" it seems useful for formatting libraries. For other code which requires typing big numbers, seeing `1_000_000` instead of `1000000` is much easier, at a glance; to see what number it is (useful for getting up to speed with new codebases)
Honest question: Why do we need this? Aren't big magic numbers often frowned upon? Why'd we add features (purely cosmetic at that) to support something that most people want to avoid? I must not be thinking hard enough, but I can't really think of situations where I want to key in a long sequence of hexadecimal or integer value into the code directly.
Did you read the whole proposal and note the other languages that have implemented this feature? It may be arbitrary to the way you use php, but to some people, this makes a huge difference.
I don't understand why people continuously bash PHP. PHP7 is actually very fast and there is allot of upward potential. The OOP syntax is clear and straight forward. The object model is simple and fairly obvious. PHP arrays are the best thing since sliced bread. Most of the bad parts of the library are being, or are already have been phased out. The platform is easy to set up and robust for most needs right out of the box. Pretty much 80% of the internet runs on it. PHP servers are rock solid. The non-PHP sites are using ASP.net and J2EE. So those are the realistic alternatives. Other tech is in the single digits (i.e. noise) market share. The haystack/needle thing of yore is eliminated by modern IDE's. No garbage collectors! Yay! No memory leaks! Yay! I see features being added to ES6 and I sometimes scratch my head at the unneeded complexity. With PHP, every feature they add is awesome, obvious, and easy to use. PHP bashing used to be cool. But, I haven't heard a really compelling reason for the hate in a while. Concerning the RFC. It's a great idea. I'm all for taking awesome ideas from other langs. Love it or hate it, but the PHP Internals drama actually results in really good ideas. There is something weirdly organic about it. For example, scalar type hints are amazing. Null coalescing operator? Brilliant. Spaceship operator? Yes please! 
&gt; Did you read the whole proposal and note the other languages that have implemented this feature? Most of them are other shit and rest resemble other shit, yeah lets follow what other shits are doing, nothing could go wrong. &gt; but to some people, this makes a huge difference. PHP devs don't do/know math ;) 
Don't forget that most photo formats aren't just the raw image data, they're complete structured containers with sections for arbitrary data. Hell, I think you can still just concat a JPEG and a zip file together and have it be a legal version of both files. I'm sure you could create two image files that have radically different contents (ignoring whether or not the images are visually similar or even identical) but the same MD5. I wouldn't want to try and to this myself, mind you, but I'm sure some enterprising soul could pull it off. Remember, it's not the normal users you need to worry about. There are people out there that will intentionally try and break things.
I would prefer to type 1_000_000 instead 1000000. It doesn't happen allot, but it would be useful. It's not crucial. Instead, it's a developer happiness thing. I would use it more often than I would use yield or generators. Just saying. 
&gt;You linked to documents not code, that doesn't prove anything. The majority of the links go to contributor guidelines in the repos. But I'm not sure what you're asking for. To review millions of lines of code for something that, if it does exist, is likely an accidental rarity?
&gt; Most of them Also the fact that I love something doesn't mean like most PHP devs, I'm gonna go in defense mode and cloud my eyes from its faults.
So no, you did not read the whole proposal. Thank you for answering my question instead of throwing together a nice strawman. You're right bud, cause no php dev has ever taken a math class. It's not like people go to school for that.
&gt; Who is free typing enough large numbers to the extent that this would be beneficial? You don't have to type a lot of numbers for it to be useful. I've wanted it recently when writing a benchmark script that did 1000000000 or so iterations (I can't, tellingly, recall the exact number of digits), and found myself re-counting the digits multiple times when adjusting it.
Here we go, its time for another good idea bad idea. Good idea: follow the http specs and properly encode your input data ie see everyone else here Bad idea: not firing your client for giving you boneheaded requirements. Assuming you can't fire your client (you really should if he won't let you actually follow specs) &gt; parse_str(strtr($_SERVER['QUERY_STRING'], ['&amp;%20' =&gt; '%26%20']), $_GET); That little bit of code will fulfill your wildest dreams and then one day randomly break something you never expected, but hey bill the client for it as you had to do that as a result of his boneheaded requirements. edit: formatting fixes because i am boneheaded.
&gt; Andi Gutmans, Zeev Suraski (Zend Framework) I would have thought Andi and Zeev were better known for writing the Zend Engine.
At the very least, yolo and Silex use Symfony.
&gt; why are you expending the energy to object it. Why people are expanding energy in cosmetic features in such already horrible language is beyond me. Writing things is never the problem also this don't make the code exponentially more readable, more syntax to be aware more and overhead for the interpreter.
&gt; PHP arrays are the best thing since sliced bread. There goes all your credibility. Php arrays are one of the worst features of the language. But a novice programmer would love it. It 'saves' him from learning about the different types of data structures like different kinds of lists and dictionaries and their properties. and more importantly which one to use for a given situation. You can use it without thinking much. That would have been great if it was without any pitfalls. But that is not the case. For example, you can see special cases where a library function behave certain way when the 'array' contains numeric keys or string keys....And that is just the tip of the iceberg. &gt; The haystack/needle thing of yore is eliminated by modern IDE's. But you need a language feature to make big numbers legible for you! Why not depend on the 'modern IDE' for that? Lol. &gt;No garbage collectors! Yay! No memory leaks! Yay! Just Restart the program at every request. Yay Yay Yay!!! &gt;For example, scalar type hints are amazing. Null coalescing operator? Brilliant. Spaceship operator? Yes please! amazing, brilliant..Do you even know what those words means?
I just do `for ($i = 0; $i &lt; 1e10; $i++) { ... }` 
Oh, you. Always making sense.
You missed the string keys 'automagically' getting converted to numeric keys...so $a['1'] ends up being $a[1]. If you follow the "good practice" and use === to compare the key you just stored, you are fucked.
&gt; Acts as a clear and unambiguous delineator between digits (unlike the comma or period) Why is a comma/period ambiguous? I mean, aside from locales which flip their usage, isn't that pretty much a global practice? 1,000,000 1,000,000.254,856 I'll grant you that the second one there is a bit odd, but no more so than tossing an underscore in there. Why not use comma as a throw away character? It'd serve the same purpose and, in most cases, be more parseable cause that's how you see numbers everywhere else.
Was all of that a confusing way of saying your PHP model classes should mirror your relational database tables? Or am I completely missing the point? :/
http://www.edx.com http://www.pluralsight.com https://www.udemy.com/ 
Your link is dead.
Come on, show me a real life collision, not a manufactured one. It will make a big hit on Reddit, or even on media. Don't miss the opportunity. All for a price of having one of billion shitty images confused. *In practice*, it was many times when we showed a wrong image. It was never caused by the MD5 collision but always but the stupid error in the code. You have to understand that in matters that aren't connected to security MD5 is still all right. It's fast and reliable. No need anything else. 
It's optional to use and doesn't break BC and increases readability. Go for it.
That sums up my feelings as well. I can't think of a single time I've ever needed this, but if there are people that need it and it doesn't hurt anything, sure why not. Kind of like GOTO support.
Ada allows 10_000_000 (base 10) or any base 2..16 in the form of say 10#123_456_789# as a numeric literal.
&gt; mbstring.func_overload Thank you, didn't know about that directive. Would you please provide alternative to substr and strlen for cryptography? I don't plan to work with cryptography, but it would be great to know.
DDD is to rule complexity, it doesn't help you with simple domain. &gt; Heaven forbid you try and do something non-trivial in an ORM like aggregate functions and 12 joined tables ORM is detail of implementation, your persistence layer. It also doesn't mean anything for DDD. You could use whatever you like. Be pragmatic. I have such queries only for read-only operations. I don't want to get entities, i want to get immutable DTO. That's why I just have simple services which uses DBAL (orm ORM, it doesn't matter) and map query result directly to DTO. And this covers 90% of my usecases for complex queries. &gt; I just need to add a new REST object [4 routes] You are implementing DDD through UI? All this controllers, actions, routs and stuff is UI of application. And you should start from domain layer, then application layer and just then you can even generate your controllers from some DSL. &gt; Then you quickly realize fuck, I need to generate another 12 classes to satisfy it all then write test cases for those 12 classes and still write acceptance tests on them too. Are you really do DDD or just trying to implement layered architecture wrong? Why do you need this 12 classes? Is this some kind of magic number? For example i have single class for single usecase, and class per buisness rule + DTO objects to separate application from UI (to make it easy to prevent my API from BC break, this is important for mobile apps) &gt; Don't get me wrong, DDD is great in theory Can you summarize the basic principle of this theory? For me DDD is [Ubiquitous Language](http://martinfowler.com/bliki/UbiquitousLanguage.html). It allows me to understand what I need to implement and why. All this patterns, layered architecture and other stuff is just to reduce technical debt, reduce coupling and make application changeable. But you can traid of this arch stuff to development speed. You should be more pragmatic.
Agree. And in addition to that, we can always comment the code. $circumference = 40075160; // earth's circumference is 40,075,160 meters
I think this is a nice little addition that could make life easier to many people. Although the actual use case seems to me to be somewhat limited (as someone else pointed out, how often do you actually happen to manually write such large numbers?), nevertheless it makes reading a big number so much easier, that I see no valid reason why we wouldn't want this proposal to become a reality. Also, it causes little to no trouble to those who don't want/need to use this feature.
Yeah, exactly - I'd say this is a 'Why not?' type discussion - I'll probably use it once or twice, maybe it will be helpful, it won't hinder me though if it's added.
Other languages use `_` for this, it's a convention that is familiar in other places.
5.2?? I use 5.3 at work and we have namespaces
Not all numbers are powers of 10.
&gt; Everyone else Actually IME most people use commas - 123,456,789. But it's a programming language, you can't use spaces for this due to ambiguity.
1. Quit slacking and mess around with Xdebug. 
I'm still trying to figure out most of this stuff myself, but: - I haven't touched mod_mpm, so it is the default - php-fpm is running as the same user as the virtual host that it belongs to. My virtual hosts each have a home directory of which they are the owner, which contains their domains (/home/user/domains/domain.nl/public_html) - I'm using unix socket, I do not know how this is any different from tcp - mod_apache is still enabled (or do you mean mod_php?). I have two different parts of Apache config for php-fpm. One which declares the fpm fastcgi handler and one which tells the vhost to use it. Check my guide to see how. - Again check my guide. - Until now I haven't had any trouble with permissions - I'm still trying to figure this out
&gt; You have no idea how much money I made my company with PHP. Again, filthy money out deceived customers and the selling of subpar products. &gt; The code is beautiful. Modular, readable, testable, well documented and performant. Impossible. Stop your delusions. &gt; I write in about a dozen languages, and PHP is just one of them, but it fits its role as a server-side frontend language really well. Irrelevant, all the language you tried are shitty imperative crap. All you do is subpar CRUD apps and Wordpress crap, you don't even master PHP. The language doesn't fits in anything, you just repeatedly smash it by force until it get into the slots. &gt; So far in all your comment rants you've listed not a single deal-breaker of a problem in PHP, you just repeat "oh it's shitty", "crappy", "gross", "horrible", "stupid". The level of intelligence of your critique is like a 4 year old who doesn't want to eat their veggies. PHP is far from being healthy, is the cancer of the industry; the less payed, the worst platform, the worst workflow, no design no direction, is not simple, inspire the proliferation of bad code and practices from the beginning, doesn't work as a teaching tool, the worst culture, filled with a bunch of delusionals that only see pennies and don't know how to make anything else than subpar CRUD apps. &gt; You've given no coherent argument against PHP, so there isn't even something tangible you've said that people can object to. You just can't shut up about how generically "bad" it is. Is not like I am not the only one. This is again another example of this common thread that's share among PHP devs. &gt; There's a saying: "a poor craftsman blames their tools". No in this case, your tool is poor and so your craftsmanship. &gt; I'm dumbfounded by your lack of self-awareness. And I am perplex out the lack of self-respect you have your while using this crap and the lack of self-awareness you have by not noticing your selective hearing and delusion. &gt; How come you're willing to embarrass yourself again and again in this subreddit with these childish comments, for no apparent reason? How? Is a disposable anonymous account, and again my comments are 100% true. All the downvotes are product of delusion and the selective hearing that I already told you about, they don't affect me. &gt; Life is short, man, before we know, we get sick and die. Yes, even you. You first than me is you keep using PHP, that's for sure. &gt; Don't waste your short time on bullshit. I am just writing comments in a forum, how is that different from what you are doing? &gt; Don't reduce yourself to the online equivalent of a person flashing their junk to strangers. You are already at the very bottom by using PHP, don't have the right to preach anyone. 
Hey - you should find something that makes you happier. Being a troll is a waste of your life :(
If you are skilled in software architecture you can dissect Symfony and tell why one or another thing was done, the pros and cons of it. If I gave you a piece of code, 100-200 lines you can probably comment on the code formatting, comments, variable and method names, logic of the method, etc. and have a rough idea of how advanced the programmer is who wrote it. You don't need to go somewhere to read a dissertation about the programmer writing the sample in order to know if the code is good. Instead you can see it with your own eyes, and you can critique it. So asking "where does one find out" is the wrong question. And just like analyzing code can be done on the merit of the code alone, analyzing a framework is the same, just at a higher level. You can critique a framework on the merit of what it is. Code, tooling and documentation. If you're not a good programmer, you don't know how good a piece of code is. And if you're not good at software architecture, you don't know why frameworks do what they do.
&gt; How? Is a disposable anonymous account It's anonymous but I already know a lot about you. I kind of hoped you're in your teens, but more likely you're in your 30s-40s. You're unemployed, lonely, probably living with your parents, probably a virgin, and you have trouble connecting with people. You probably take medication to control a mental problem. And also you're not very experienced as a programmer, because your focus is on superficial bikeshedding, with no depth or insight. I'd say self-taught, junior level, but you estimate yourself to be on par with Linus Torvalds. You could probably get a job as a code monkey somewhere if you shave, go take shower and buy yourself better clothes, but you won't do it. Happy new year in advance, by the way. Loser :-)
What he say is true, though. Not sure if you should label people with different opinion as "Trolls". I mean, I am pretty sure /r/zarandyasofia really believes what he says, and not really doing this to simply provoke anyone. 
[removed]
Happy new year :)
&gt;and posting garbage... May be he doesn't have anything good to say about the language. So he should shut up? If there are newbies lurking around here, let them understand the true nature of Php, before they waste years working in it and learning completely useless stuff.
I think we should not forget that PHP owns 80% of the websites. Most popular CMS such as WordPress, Magento , Drupal are based on PHP. Similarly Ecommerce platforms like Xcart, Opencart are still on PHP.
&gt;He won't use or probably ever see the feature Big assumption. But it is ok since it serves you, right? And even if that is true, that does not make him a troll. He [gives reasons](https://www.reddit.com/r/PHP/comments/3yu3ub/rfc_number_format_separator/cygy4yx) for his belief when asked.
Perfect! Rafael you are an amazing Speaker. I totally agree with the need of readable code otherwise after 3 months it really sucks :)
You too :D.
I think Composer, Adobe Dreamweaver, Notepad++ are the best :) 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [You are a loser if you don't like Php.](https://np.reddit.com/r/lolphp/comments/3ywwna/you_are_a_loser_if_you_dont_like_php/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Well if your aim is to save HDD space when downloading price lists with photos every day (as is the original theme of this thread) you are gonna strip everything down and keep only the raw image data. Which will make creating a collision a bit harder. Not sure but that might also improve compression ratio. However **I am NOT advocating using md5 or arguing you cannot manually create collision**, I am just asking out of curiosity if it is humanly doable to go outside with a camera and take two photos of different things with two same hashes of raw image data. Andrea's *People do it for fun* made me ask this question as I can imagine someone bored enough to try it. 
This doesn't touch the syntax, but that's nitpick.
what do you mean by mess around with it?
Sorry, should have said to use it. Haven't ever set it up yet.
&gt; A fresh memory space is created, but all of the byte code and what not sticks around. Sorry. What?
What?
Problem solved!
It is more like going into someones house and telling them their house is weakly built and might fall down and kill them if they don't move somewhere else..
1. Fully learn some JS framework 2. Learn making apps with REST
I cover a bunch of this here: https://serversforhackers.com/series/lamplemp 1. Any module except mpm_prefork will do. mpm_prefork must be used with apache's PHP module, but we can use the better mpm_worker / mpm_event. I cover the differences fairly extensively in the SFH book (sorry, I know this is pretty much an advertisement, but there's good info from when I had the same questions!) 2. PHP-FPM will be configured to run as an appropriate user when instsalled via a package manager. This is usually www-data on debian/ubuntu or apache on centos/redhat. These users are created as system users (no login available) for the purpose of running web applications. THey're generally OK to run as, unless you want to intentionally not allow nginx/apache to run as the same user as php-fpm 3. PHP-FPM can run as either tcp or unix socket. Unix sockets are available only on the local file system, so it's more secure in that sense (no network access). Unix sockets are a little faster as well. TCP sockets are great for when you need network access - Apache used to only support network connects, but can now proxy fcgi requests over a unix socket (I believe as of 2.4.9 or so, but I don't remember exactly) 4. Apache modules on centos/fedora/redhat are typically added by adding a configuration to an autoloaded area, such as /etc/httpd/conf.d. Disabling/enabling usually involves adding module config files into such a directory and restaring apache. Here's a link with an example: http://www.cyberciti.biz/faq/howto-disable-apache-modules-under-linux-unix/ 5. Where ever makes the most sense for you. I typically put it within &lt;virtualhost&gt; directive as it's typically site-specific instead of global to your apache install (it could be either, it's up to your preferences/needs) 6. Enabling it for all hosts probably means putting it outside of a virtualhost block, but I believe this depends on how set it up and what proxy module is used 7. You'll get error messages in your apache/nginx log if it can't proxy over to the php-fpm socket. If you're using a unix socket, then you'll get permission errosr related to user settings. If apache runs as apache and php-fpm runs as apache, then they'll both usually "just work". However if they run as different users, they'll need permission to speak to eachother, just as if a user was trying to read/update any other file on the system. Unix sockets behave just like any other file in terms of user permissions 8. These are common to anything in linux - network access (firewalls), unix sockets (file access). Nothing too special here. How are you installing php-fpm? Usually the defaults "just work" on redhat/centos/debian/ubuntu. Having trouble with these feels like you might be building/configuring it manually? 
1. Make some library that's PHP 7 only to get more familiar with the new hotness. 2. It's 2016. I really should finally build a site in Rails. 
The FIG falls in-between #2 and #3, as IMHO most successful open source projects do. They are building something for themselves primarily, and if they do it well enough others will contribute. There is no obligation to following the PSR's, but there is a long-term risk of being left behind if the greater community adopts them in mass, which it appears to be doing at face value.
Absolutely - the slowest part in any of my projects has been related to SQL queries. I recently changed my approach for a large query that was previously using AR and just queried the database directly without any query-builder nonsense and it speed up that part of the application significantly (2 to .7 seconds on older hardware). I haven't bothered making all of the capital TRUE/FALSEs to lower case or changed " to ' which I think I've heard makes some difference that doesn't matter, but I will be re-examining all of my queries.
The Earth's circumference doesn't change particularly often. 
When you do, install the Firefox / Chrome extensions, it'll help tremendously.
Have less bad thing to say about the language and its developers, a tough job I know, no guarantees :D
Thanks for the tip!
About advance Javascript can I recommend you this books? They are great for advance stuff, highly recommended: [1](https://leanpub.com/javascript-allonge), [2](https://leanpub.com/javascript-spessore), [3](http://shop.oreilly.com/product/0636920028857.do)
I think we were all there at some point. So long as you are using an IDE though, it is so worth it. There are three main things you'll need to do, and if they go smooth it can easily be done on a lunchbreak. * Install and configure the xdebug module on your local server. Most local servers have the mod available and preconfigured, often times it is as simple as a few clicks after googling how to set it up. * Input a few settings into your IDE so that it's looking at the right port and using the right session name, the ones found in your xdebug config. * Grab an xdebug extension for your browser. This allows you to start a debug session with a click. In your IDE you first set your debugger to listen, and anytime you tell your browser extension to start a session your IDE will open up the debug window. And now you can start playing around with it. Throw a breakpoint somewhere in your IDE just to see how it works. Then start a session in your browser and visit a page with that breakpoint. The page will pause loading at the breakpoint, and in your IDE you can see all of the variables and scopes right there in the debug window. No more need for var_dump. To let the page finish loading just hit the continue button in the IDE.
Yeah, I know some people who swear by debuggers. Unfortunately I came across this talk several years ago and have tried to avoid them ever since: https://www.youtube.com/watch?v=WVTWCPoUt8w&amp;feature=youtu.be&amp;t=4360. That being said, debuggers do seem a lot less annoying than putting print_r's everywhere, but maybe reserve their use for only the hairiest of code bases.
There are other numbers that exist.
This looks a lot like the built-in [authorization and policy routines](https://laravel.com/docs/5.2/authorization) that Laravel introduced in 5.1.11.
I was hoping for a Silex way (using OO) that would take an ini file, parse it, and make it available in the Pimple container. But yes, when all is said and done it should use the native PHP function. It sounds like I will have to roll my own. 
What sort of difficulties are you running into? Regardless of if you're writing scripts that are run on command line, or scripts running through apache outputting HTML, or through apache outputting JSON, the PHP functions are the same. php.net has decent documentation. You can go and read through the string functions, array functions, etc. With your experience you'll have no issues with PHP. Think of it this way, get the data into the object you want and then run `json_encode()` on that object to get your JSON. If they're running within some framework, you may need to learn that specific framework. Lumen/Laravel make REST APIs very easy to create.
What issues are you seeing? I've been using it for over a month now and haven't noticed anything?
* Update my resume to say 2 years PHP7 and Symfony 3 experience.
That's what she said 
- Figure out a hexagonal/onion architecture I like. - Figure out a way to use event sourcing as part of an architecture (where it makes sense) - Finish that Evan's DDD book - Finish that ElasticSearch book - Learn more about requirements engineering
thanks!!
It's not been forgotten. I have a handful of RFC's I work on and have to prioritize some things over others. Soon (maybe even tonight) I'll be officially submitting an RFC for [native enums](https://wiki.php.net/rfc/enum). However, I do not expect we will see a vote on nullable types soon. It may still be voted on for PHP 7.1 but realize we have months before a PHP 7.1 feature freeze would be in effect. ----- tl;dr Not forgotten but not much progress either.
Cool story. Nobody cares.
I appreciate you responding to this! I think that native enums would be incredible! And I did not think about how far off the feature freeze is for the next minor release.
My new years resolution? Stop developing in PHP and MySQL. Actually, for 3 months have not developed a single line in PHP and for MySQL haven't touched that turd in 6 months. Go, Postgres and front-end JS are my future. Looking forward to a sane 2016 and not having to deal with shitty broken systems!
I got a third of the way through Allonge and I was a bit frustrated with it. The examples are not applicable at all. I understood scoping a little better and how functions and fat arrows are meant to work but still. Do the patterns get better? I am looking for something with a bit more practical examples. 
I think it's inconsequential whether the method is static or not when you have an instance so either call syntax is fine. I tend towards using the proper static can syntax but there are cases where it makes just as much or more sense to use the instance and it is not an antipattern to do so. 
Vim. Initially because I spend a lot of time logged into remote servers over ssh and so proficiency in a text mode editor that is guaranteed to be there is incredibly useful. Then I started to appreciate how fast it was to start, for those quick one-off edits. But once I discovered text objects, I wondered how anyone could live without them. It's also useful as a text processor - a few commands can convert some barely formatted text into a valid CSV, or a SQL `IN(...)` clause etc.
What?? I use the windows php build and it works great. You dont need to compile it your self just download the binary. You seems to make this much more complicated than it is. A wild guess is that all you need is to install wamp server.
&gt;Looking forward to a sane 2016 and not having to deal with shitty broken systems! ... &gt;front-end JS Yeah, about that...
From my current understanding of this RFC, enums are explicitly meant to not have an associated value. So database storage would only be possible through serialization, i.e. essentially not feasible within the bounds of this RFC.
Uh, that would be inconvenient. Is there a good reason for this decision /u/MorrisonLevi?
Dracula is a default theme of PHPStorm just so you know. Select it through the preferences, and on your first start up you can change keybinds/editor theme/text theme (dracula is a built in for both). enjoy
brackets.io :)
That's Darcula, I'm looking for [Dracula](https://zenorocha.github.io/dracula-theme/sublime/). It's the only color scheme I can comfortably use. I'd also like to use the custom Seti UI theme someone made but it doesn't support PS10 :/
+1 for VIM. Been at it for more than 15 years now, I'm in too deep at this point (and I like it). Edit: Words on mobile. Missing. Sucks.
Pay me £50 and I'll make the theme for you, no sweat ;-) 
I'm stuck on PHPStorm 9 forever, apparently. At least until the language evolves from out from under me. No way in hell am I leasing monthly for a critical tool. But it doesn't support Hack Lang, and I've been dealing anyway. 
[removed]
Just wait until you inherit 15 year-old out-sourced code with this "_" in it.
I've been using atom lately. It's lightweight, easy to navigate, and is highly expandable.
I used textmate for years and just recently fell in love with atom. It took awhile to find/install all of the packages I needed but now that it's done I'll never use anything else.
you know they changed their terms right? http://blog.jetbrains.com/blog/2015/09/18/final-update-on-the-jetbrains-toolbox-announcement/ &gt; You will receive a perpetual fallback license once you pay for a year up front or 12 consecutive months. Edit: don't down-vote the guy, he probably didn't know about the change. Better to inform than leave someone behind.
Eclipse on windows, gedit on Linux.
Sublime because it's fast and sharp, VIM because it's everywhere, Atom for React stuffs.
theres also licenses for opensource projects.
PHPstorm is, without a doubt, king.
I don't speak for Levi, but my understanding is that the trade-off for having enums &lt;-&gt; values as part of the RFC is not that fantastic a one for PHP. The cost of not instantiating from values is that users would need to write a trivial function to do that, which is not a high cost. Against that when enums can be converted to and from values as part of the language, there are far more things that need to be considered, (more than would be needed for static typed languages such as Java). * What scalar types can be used to define enums? Some enums are clearly strings, others are numbers. Do we need restrictions in place? Do we need to define an __toEnum __fromScalar magic functions? * Are mixed scalar types allowed inside one enum? * What behaviour happens when 'incorrect' values are tried to be converted to enums? This can happen when programmers make mistakes or when the enum definition is changed, and the program tries to unserialize data from the previous definition. * What happens in weak/strict mode when an enum is passed to a function that is expecting a string/int/float? Thos things are trivial to do in user-land, and people can decide exactly how the edge cases should be handled in a way that is appropriate for their use-cases. Implementing it in a single way in core PHP is probably going to be wrong for at least some use-cases. That would be annoying as that code that gets into core is probably going to be there for at least ten years. Unless there's a massive downside to not having it in the core PHP, (and I don't believe having to write a function to translate enum &lt;-&gt; scalar value is a massive downside), I don't think it should be part of this RFC. Or to put it another way, we need to provide the building blocks for building a language, rather than trying to create the 'perfect' language: [Growing a Language, by Guy Steele](https://www.youtube.com/watch?v=_ahvzDzKdB0&amp;list=PLl4o-nsEmg3neGcl5nYYRjY-HTBbTN5iS&amp;index=41) 
Komodo IDE. Because it's only non-java PHP IDE for Linux with good xdebug support. 
I am guessing I'll be alone with this one: [Coda](https://panic.com/coda/). I've tried them all, but I keep going back to Coda due to IMO the project management and UI. Pair that with the terminal and Sequel Pro (nightly), it has been a solid workspace for me for years.
Never need a mouse; that's part of the beauty of vim. You can get it to work, but generally it slows you down anyway. If you get really proficient with vim keybindings, you won't want to use the mouse at all.
Do you do debugging with Vim? PhpStorm's debugging tools are what keep me hooked.
first time i've seen a vimer convert to emacs. no M+rsi yet? on a serious note that might make me want to try emacs. though i've been using phpstorm for php b/c of the debugger + code completion being pretty decent.
I should probably switch to PHPStorm as I've just been using VSCode lmao
Evil Mode gives you all the Vim bindings in Emacs so you don't need to use modifier keys for the majority of stuff. I've gotten used to using some of the Emacs-style key chords for certain things, but they're things I do less often. When Emacs packages provide a bunch of features I want to use regularly I just remap them onto Vim-like key combinations or leader keys.
I know it's possible, I'm just not sure I want to.
+1 Vim, because it's exactly the same when I use it on the desktop and on command line when I ssh into a server.
Totally going to be overlooked, OOP is the norm in PHP.
I totally agree with you that FP is not by any means common in PHP - let's change that :) Functional programing has been too verbose in PHP - too much boilerplate to use it effectively and a high bar of entry for newcomers. The goal of Pramda is to alleviate these pains and allow the PHP programmer to reap the benefits of this paradigm. 
Making no comment on the relative importance of different features, I agree that return types are currently less commonly applicable than I would like, for three main reasons (in no particular order): * No support for `void`. * No support for nullable types. * No support for covariant return types. Thankfully the first point is already resolved in PHP 7.1 and I hope that at least the second one will be as well.
This is cool to see. It may not be taken to being that the PHP community heavily advocates OOP but I can see the value in functional programming in PHP for certain things. I will be watching this.
My suggestion would be to switch to PDO if possible. It would solve your first issue for sure. As for your second issue, you're fetching the first row before the while loop.
I like the examples you gave, but it doesn't help me understand how I would architect a large web application, which is mainly what I use PHP for. What does domain logic look like in FP, and how would I get from routing to domain?
&gt; throwing a BlogPostNotFoundException is much better http://programmers.stackexchange.com/questions/189222/are-exceptions-as-control-flow-considered-a-serious-antipattern-if-so-why
PDO? I found reference on the php page, but i'm supposing I'll need a book here. Any suggestions?
PHPStorm normally, I love tools it provides, static analysis, refactoring, xdebug, etc Sublime for editing a few files due to the speed of launching
IntelliJ IDEA (phpstorm on steroid) its super powerfull, extensible, customizable, easy to learn AND master. I purchase my own copy and its the best money I ever spent. Get the trial and bother to learn the shortcuts and you wont ever go back.
I haven't honestly dabbled too much with a solid debugger. That's actually one of the nice things about phpstorm that almost have me reeled in.
Thank you very much for the suggestion! I am open to changing it to that way if there's enough demand for it.
&gt; As it's exceptional set of circumstances, throwing a BlogPostNotFoundException is much better Is it? It might be reasonable to leave it up to the receiving code to decide whether or not it is exceptional.
And you realise this thread is about how to run PHP under Cygwin, right?
Certainly. However this means that you can't simply move a return type from a docblock to be a proper return type. In this case I prefer to keep the more specific docblock type. Especially if it happens to be `self`, I think specifying some super-class is a significant loss of information.
There's a console you can open inside phpstorm. You can always have vim ready as a fallback.
I do realise that, but why would you want to do that when, there are native windows binaries of php?
I use it because it works the same on Windows / OS X / Linux.
I've been testing it out lately and it seems to be making some really good progress.
The creator of Laravel gets -2 pts? This could be PHP blasphemy folks!
I was not aware of the group import ability as I have not made the switch to PHP 7 yet, thank you. Does it also support something like: use function NamespaceA\* so that the user would not have to explicitly type each one he will use?
PHPStorm runs circles around Eclipse and at the same time manages to do better code inspection.
It doesn't, which is unfortunate for your use case. You could alias the namespace, though. IIRC you can do `use Pramda as P`.
That's what I originally intended to do but unfortunately, namespaces in PHP are not perfect. So I ended up using a class with static functions in the global namespace. use P\P; $lessThan = P::flip(['P\P', 'lt']); // Works $lessThan = P::flip('P\P::lt'); // Works $lessThan = P::flip('P::lt'); // Nope! 
PHPStorm, best mix for refactoring and code quality tools and an editor.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/functionalprogramming] [Practical Functional Programming in PHP with Pramda • \/r\/PHP](https://np.reddit.com/r/functionalprogramming/comments/3z271o/practical_functional_programming_in_php_with/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
makes sense. i listened to your whole talk and it was very interesting. i might give emacs a try. the whole thing about the ecosystem actually resonated to me a lot, and it was a good point that the existence of neovim is a bit oif a tell. feels like emacs dev is way more alive than vim development in general. i might give it a shot
There is hardly a paragraph about PDO on this otherwise brilliant resource.
You are correct, I think your article is better.
Netbeans, free, multiplatform, open source. For fast editing Sublime Text.
you can still use php that way without cygwin. Install php windows binary and babun shell. 
if you really want to use php under cygwin, try babun it is a pre configured cygwin env with a package manager.
Pramda is heavily based on [Ramda.js](https://github.com/ramda/ramda) which is in turn inspired by Haskell etc.
Thanks, I will look into it. I have a pretty good environment already set up, though, and `apt-cyg` combined with the Cygwin package manager has been great so far. I'm not hopeful it will work unfortunately, because if it's just a Cygwin environment, then I'm afraid it might have the same issues stock Cygwin has - stock PHP binary worked before, doesn't work with PHP 7. I guess I'll find out.
I know I was being sarcastic.
I like it. It's clean and organized. Entirely in laravel meaning no frontend framework?
Cheers!
I usually donate money to free software projects that I like. License and money are two different things.
Have you seen functional - php before? It's in composer currently, maybe merge efforts ?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/test] [phpsucks](https://np.reddit.com/r/test/comments/3z3jrw/phpsucks/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Build a twitter feature for my site that allows me queue up tweets to be sent to twitter, Work with third party APi's like github and imagur 
:)
&gt;That weird P::unary that wraps strtolower? That's because P::map always calls the supplied function with 2 parameters (value, key). FWIW, I think (key, value) is generally better than (value, key) - otherwise it's an interesting library.
it can't 
Other factors which distinguish a framework from a library are contained in the Wikipedia definition at https://en.wikipedia.org/wiki/Software_framework where it says: - A framework has a default behavior. This default behavior must be some useful behavior and not a series of no-ops. - A framework can be extended by the user usually by selective overriding or specialized by user code to provide specific functionality. My own framework matches this description because it can take the definition of a database table and generate the basic CRUD transactions without the developer having to write a single line of code - no PHP, no HTML and no SQL. Each of these basic transactions can then be modified by the developer by either extending or replacing the standard behaviour in order to produce a more complex transaction. I have used this framework to create an enterprise application which I now sell to multi-national corporations all over the world, and of the 2,000+ transactions contained within it some are very complex indeed.
That's great, thank you for letting me know! I would like to avoid the use of Reflection wherever possible so that's why I opted for curryN instead of a generalized curry - although definitely an implementation like you did is much more elegant.
Cheers! I find it very interesting how PHP has native functionality that allows its users to gradually evolve their style (another such example would be the SPL).
So, with the way you are using your version of curry at the moment, you can simply replace it with my _curry function and just manually provide the arity yourself.
Wonder if we will see PHP taking ideas from functional programming such a haskell and getting more scala-like in version 7 onwards. Should be interesting where it's heading.
&gt; I quite like the ES2015 shorthand map notation This is a little bit different feature. For example: $jsonResponse-&gt;equal($expectedValue, ['at' =&gt; 'foo/bar', 'excluding' =&gt; ['id']]); This is realtife example that I use for asserting JSON responses. Names parameters will add autocompletion support, which is the main benifit of this feature. $jsonResponse-&gt;equal($expectedValue, excluding =&gt; ['id'], at =&gt; 'foo/bar') This feature also allows developers to simplify some DSL and API. Especially things like query builders.
Certainly! I will probably do that at the 0.10 release - I'll ping you with an issue on Github. Thanks again!
The issue with named parameters in this RFC is that they're not distinct from positional parameters. Instead every parameter can now be passed both by position (if name is not specified) or by name (if name is specified). This means all code where the reasonable assumption is you can change the name of the parameters as long as you keep their order, will now break its callers if you change the parameter names in your signature. And conversely, if you have 5 parameters: $a, $b, $c, $d, $e and you want to refactor to make $b optional, you can't do it, because you can't re-order the parameters to put $b last (so it can be optional), in case someone is passing them positionally. In short, your arguments, as a part of your public API, will be now bound both by name *and* by position. This is not more flexible, it's less flexible when it comes to maintaining and refactoring APIs. To go around this, in the current PHP, I've always preferred assoc arrays or parameter objects in key, complex, heavily used APIs, because with those two I can either actively ignore parameter position (arrays) or there isn't any order to maintain semantically (objects). And if named parameters are introduced the way this RFC specifies, I'm afraid I'll have to keep using arrays and param objects, because the RFC doesn't solve the main problem I'm trying to solve: to remove "param position" from my API contract, so I can be free to evolve my APIs by adding params, removing params, making required ones optional etc. without breaking the users, and *without* being limited by parameter order. In other words, yes, for the method caller it's handy to be able to specify a name to make the call more readable, but we're missing an opportunity to solve a bigger issue: which is enabling the method to refactor itself flexibly over time without breaking its callers. Which requires *removing* position as a semantically meaningful calling convention for certain parameters, if we choose so. Not to just complain, I have a proposal. Named parameters could be explicitly specified in the signature, and they can't be passed positionally: function foo($a, $b, named $c, named $d) {} foo(1, 2, $c =&gt; 3, $d =&gt; 4); // Valid. foo(1, 2, $d =&gt; 4, $c =&gt; 3); // Valid. foo($a =&gt; 1, $b =&gt; 2, $c =&gt; 3, $d =&gt; 4); // Not valid. foo(1, 2, 3, 4); // Not valid. This way we can design how our APIs are accessed, instead of enabling everything for every parameter. Yes, it means all the legacy APIs won't be able to use named params automatically, but trust me, that's a good thing. Positional parameters have never made sense for the modern programming world anyway. They're good for very simple functions, and ideally, everything needs at most 1-2 parameters, but truth is there are calls which require more complex input, because not every function performs operations as simple as summing two operands, or walking an array etc. Methods that describe complex business domain operations have a lot of arguments that evolve over time. Go check if you can find any popular public API where parameters are taken by position (say in a JSON array) versus by name (say in a JSON object). Or by both position and name. You'll find none. It's all by name only.
There are various great FP libraries - the difference is in the style, what the library author choses to focus on and how the library is structured around it. Check out this one for example: https://github.com/mtdowling/transducers.php 
Thanks for writing this out. I usually come into these problems when setting up dev enviroment on my PC. I tried using Vagrant, but foudn it to be just another "layer" of problems to work with. I prefer to the apache as myself (may be a bad habit), because I have a lot of projects, tests going on and cba to run `chmod` and `chown` every times I extract/create a file. So yeah, this probably where it all started, trying to set up a dev enviroment. Through this a was a good opportunity to digg deeper and maybe establish some rules/requirements for choosing/setting up productions servers. Unfortunately our "sysadmin" does not have deep knowledge of linux servers, so there's no one to consult with :(
I know it's a different feature. Sorry if I didn't make that clear in my first post. I was referring to the simplification of DSLs and APIs. That goal is common to both named parameters and shorthand map notation. The latter gives more control because it leaves the function signature alone by only requiring 1 slot that gets destructured. For the auto-completion goal, I strongly doubt whether the function **signature** is the right place to add these explorative playful dynamics to. It makes testing and mocking these functions unnecessarily complex. In fact, it makes these functions complex internally as well. Functions with many parameters = anti-pattern. I'd rather prefer dynamic setters, both as library author and user. And I don't always recommend this, but there are OOP patterns that deal extremely well with use-cases like query builders (using dynamic setters that return $this). Those support explorative auto-completion too, but on the class-level, keeping function signatures and invocations predictable by leaving them static. In short, named parameters feels like a fix for the many-parameters anti-pattern that also encourages/strengthens the anti-pattern. When one really needs to pass in tons of dynamic parameters, the shorthand map notation provides a more controllable solution.
*Edit* It was already mentioned in the previous discussion, but was dismissed. I still think it sounds like the correct approach to getting named params in at all. http://markmail.org/message/yhtrefvpsndqfm34#query:+page:1+mid:2wrkmlgnu6hoqtmo+state:results ----------- &gt; I have a proposal. Named parameters could be explicitly specified in the signature That's a really interesting idea. You should propose it on internals email list. Personally I don't think having it per parameter would be the correct choice. Having it just by function would solve the problem more cleanly, without having to faff around with individual params, and means that there is only ever a single way to call a function, either by position or with names. named function foo($a, $b = 2, $c = , $d = 5) {...} foo($a =&gt; 1, $b =&gt; 2, $c =&gt; 3, $d =&gt; 4); // valid. foo($d =&gt; 3, $c =&gt; 4, $a =&gt; 2); // valid. //Anything without names, invalid foo($d =&gt; 3, $c =&gt; 4); // invalid - param $a has no default. That can be explained to junior programmers in less than 5 minutes....having to explain individual params being named or not would take longer... &gt; Yes, it means all the legacy APIs won't be able to use named params automatically, but trust me, that's a good thing. That's actually the blocking feature for named parameters, how to deal with the mass of internal functions , where the param names aren't actually consistent with what the manual says they are called. Separating them out into named and position gives a clean implementation without all the nasty edge-cases.
I'm glad you liked my talk! Thanks for the kind words. I can't live without projectile and magit. Flymake is also very handy, and I use it to run PHP_CodeSniffer and the built-in php linter. I think I tried ac-php once, the challenge that I face (as I mentioned in the talk) is that our project at $work is 20,000+ PHP files and I can't use phpctags, it's just too slow. I use GNU Global for tags, which uses a Berkeley DB backend and is much faster to index and look things up in. Unfortunately it doesn't generate as much context in the tag data as phpctags. I'm in the unusual spot of working on a very large project in PHP and I know that this case is uncommon.
&gt; ideally, everything needs at most 1-2 parameters, but truth is there are calls which require more complex input, because not every function performs operations as simple as summing two operands, or walking an array etc I'm unconvinced. Every function can be composed from operations as simple as summing the operands, or walking arrays, etc. If we use something like this: $f = Foo($a,$b)-&gt;C($c)-&gt;D($d)-&gt;Query(); instead of this: $f = Foo(array($a,$b, c=&gt;$c, d=&gt;$d)) we can get a lot of assistance from our tools; our IDE, (mock) testing scripts, and in-line instrumenting, all of which have nothing to do with the business task and can thus live outside of our program, while the latter forces us to implement all of that logic for every business function, *inside* every business function. &gt; Methods that describe complex business domain operations have a lot of arguments that evolve over time. Go check if you can find any popular public API where parameters are taken by position (say in a JSON array) versus by name (say in a JSON object). Or by both position and name. You'll find none. It's all by name only. One of the reasons you see named-parameters in RPC is because it facilitates documentation and debugging, however a huge number of RPC use positional parameters *not* named parameters e.g. every REST call that uses the PATH in preference to the query string does because when the API is public, you can't evolve it anyway. Take a look at [twilio](https://www.twilio.com/docs/api/rest) as an example.
&gt; Functions with many parameters = anti-pattern Ok. Look at this method signature. string htmlentities ( string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ini_get("default_charset") [, bool $double_encode = true ]]] ) There is no "many" parameters, but we have several default arguments. And to specify "$encoding" I must also pass "$flags". What if in next PHP release defaults will be changed? As for today the only way to handle this usecase it to make wrapper around this function. With named arguments I can just call htmlentities($raw, encoding =&gt; 'UTF-8') &gt; but there are OOP patterns that deal extremely well with use-cases like query builders Yep, but this makes API very verbose. Look at symfony/config as good example.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/test] [php keep sucking](https://np.reddit.com/r/test/comments/3z52dk/php_keep_sucking/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Per-function makes more sense to me, too. Though personally instead of a 'named' keyword I'd prefer something like function foo([$a, $b, $c=1]) or function foo({$a, $b, $c=1}) Assuming that's not ambiguous. Having said that, I'm not *entirely* convinced of the problems Coltrame posits. Python manages just fine using both.
I wonder if PHP users will ever stop "optimizing" their code this way - without *any* real life effect and without any real life reason.
http://www.colinodell.com/blog/2015-11/optimizing-league-commonmark-blackfire-io
&gt; I'd prefer something like &gt; function foo([$a, $b, $c=1]) Meh. I don't like having symbol do different things based on context. function foo([array $a = [], array $c=[]]) On the same line, some brackets mean an array, others mean 'this function must be called with named params. 
&gt; I'm unconvinced. Every function can be composed from operations as simple as summing the operands, or walking arrays, etc. If we use something like this. Your example is just a fluent API factoring of a call with named parameters. I.e. it's emulation of named parameters, but with a lot more code and effort than a native support would require. Your IDE might automate it, but it's still a lot of boilerplate you wouldn't have to generate, commit, maintain and load at runtime if PHP can express it. I use fluent APIs in my designs myself, but I remain likewise unconvinced they're as good, minimal, or clear, as native named parameters would be. "We can already do this in a heavier, more loose and verbose manner" is not a good argument. &gt; One of the reasons you see named-parameters in RPC is because it facilitates documentation and debugging, however a huge number of RPC use positional parameters not named parameters e.g. every REST call that uses the PATH in preference to the query string does because when the API is public, you can't evolve it anyway. This particular modeling of REST parameters as path segments is a confusion in the industry that'll pass away with time. Nothing in REST requires this, and it suffers from the same issues that normal positional arguments suffer, so this is why I don't follow this specific trope in my HTTP APIs. But whether you realize or not, this practice of positional path segments + named fields in POST/PUT/PATCH etc. is precisely my proposal: allow us in PHP to specify what's positional and what's named. Don't make a soup of both. In the Twilio example you're linking to, the bulk of the information is *not* positional, it's sent as named parameters in the HTTP message bodies (as JSON or XML). Only the resource name is specified in a positional way. 
Having it at the function level is also fine, I think. But it would mean it's impossible to extend existing functions with named parameters. This pattern is increasingly common in both userland APIs and core PHP APIs: function foo($pos1, $pos2, $pos3, array $named = []) {} foo(1, 2, 3, ['the' =&gt; 4, 'rest' =&gt; 5]); Allowing named parameters at the end of every function, right after the last positional parameter, could make this pattern more natural and have less overhead (no arrays must be created). The rules would be, you can specify parameters in this order and none other: - Zero or more required positional params. - Zero or more optional positional params. - Zero or more named (optional or required, doesn't matter) params. Having the named ones only at the end would help readability and avoid confusion. BTW, I don't participate in the internals list right now (lots on my plate), so anyone who likes this idea, please feel free to propose it yourself.
&gt; But it would mean it's impossible to extend existing functions with named parameters. Yes, that is actually the main benefit! There would be so much work in cleaning up the internal functions to have consistent names, and so be callable by name params, that a solution that excludes the internal functions is about 5% of the work that one including internal functions would be. 
&gt; If the function is 'named' you don't have to name everything. At least, I assume that's what Danack meant. I actually did mean "name everything or don't name anything". Having separate function types means there's less confusion about how functions should be called, and people maintaining libraries of code can reason more clearly about what is a BC break for functions. * For named functions - changing the name of a param is a BC break, but param order is not part of the ABI for the function. * For positional functions - changing the order of params is a BC break, but param name is not part of the ABI for the function. Also, congratulations on getting into a downvote war with jindrap; that's always fun for everyone else to watch.
About ac-php - I'm not sure that you miss out on too much. I just recently started using it and I'm not super convinced yet. It seems to work better with auto-complete than company, sadly, because ac is more annoying sometimes. 20000 must be a hell lot of work to take care of, and I can totally see why ctags would be too slow at that point... I think it's slow on some of our bigger projects (a layer of sshfs doesn't help...). So if GNU Global provides enough data it would be cool to use that as backend instead. I mean, it would probably perform better for small projects as well. 
One problem with named parameters that bothers me personally is that it might encourage poor function design. If your function has so many parameters, or such a confusing signature, that you need named parameters, perhaps it should be rewritten or wrapped. Of course, there are also well-designed functions that benefit from named parameters.
&gt; It is just my assumption, perhaps wrong. Assumption based on what? You didn't give a single reason why.
&gt; The mistake is a lot of people implement these routines as simple setters that return $this (aka the "fluent api" nonsense), instead of actually returning new objects which is how all of these benefits are realised. To bring this conversation back to reality, PHP is a glue language, and as such a lot of the surface-level public APIs in your application are consumed remotely. The drawback of your highly granular approach, aside from mere object churn caused by creating and throwing away a dozen objects for a single API call, is that it's too chatty to call remotely. If there's a single transaction, it's typically in its essence a single call. If you want to reuse logic, you can simply reuse it in the body of a method by calling other methods and objects. You know, programming 101. While sometimes this technique may be useful for code which is intrinsically local, you don't have to fragment the API by adding indirection and asking people to construct object-constructing-object-constructors in order to make a simple call in the general case. And anyway, the discussion of complex value objects passed as parameters (which is fine) is entirely independent of the discussion about named parameters, so try to stay focused and don't try to divert the attention to arbitrary subjects. You can have named parameters and some of those parameters can still be value objects. The problem is the positional parameters at the root of the call, which should be eliminated for certain types of APIs so they can evolved easier over the long term, and they can accept a longer list of parameters than is practical to take positionally. Yes you can just always accept a *single param object* and ignore the support for a second, third and so on positional arguments, but this is just a lot of code to emulate something PHP can offer natively. Names for parameters, which is the goal here. &gt; You were so wrong about this, something that you now admit is actually very common. You're either very loose with your words, or you're very uninformed. So I guess at this point you're giving up the thought of a civil debate and reducing this to trolling? &gt; &gt; In the Twilio example you're linking to, the bulk of the information is not positional, &gt; Wrong again. All of queries use positional to identify a resource. Almost all of the updates use a single dictionary object as their argument (that is, the entirety of the POST content). Ok, pray tell, is a dictionary an example of "positional parameters" or "named parameters"? &gt; This allows the dictionary object to be verified and validated independently of the method, something which is made much more complicated when using your proposal. That, I think most people would agree, is a nonsensical statement. You're mixing up distinct issues. Whether you can verify something "independently" is not a result of whether it's a tuple or a map. If you want to reuse validation etc. logic, nothing can stop you to reuse it, no matter how you accept your arguments.
I use Visual Studio (not code) for almost everything, but for minor development I turn to Visual Studio Code =) IIS-Express-runner-thingy-extension https://github.com/warrenbuckley/IIS-Express-Code
Then personally, you're already ahead of the curve. If you have a Github? Good. Add to it. Doesn't really matter how trivial the project is, just _prove_ you can do work and people will be impressed. If you don't have a Github account. Get one.
&gt; The reason having that many parameters has been classically considered a bad idea is purely because languages couldn't handle it well No, it's because if you have a lot of parameters your function is probably too complicated.
As a counter point, what does `someSort($myArray, True)` mean? Calling it like `some sort($myArray, reverse=True)` makes it much clearer. 
you could try with this: in Settings | File Types | Twig and add .html
The only use case I can see for named parameters would be for those functions that accept an array of configuration values. Named params would now allow for strict type hinting.
Why? What about many parameters leads to over complication?
This is what i could find: http://php.net/manual/en/language.oop5.static.php
it means that the function is poorly designed. Why does it even matter if it is reversed or not? (hint: array_reverse)
You don't really need all those fancy features though ....
Stop using Atom then, you don't need any of its features either.
Instead of making one big mess, try building small boxes that each contain a mess. Don't worry too much about the mess inside, focus on the box.
My first development job, the place had interviewed dozens of college graduates who claimed they knew PHP on their resume. Not a single one of them brought code samples or could actually *demonstrate* they knew it. They just took a "programming course" in college which introduced them to a score of different languages, so they "knew" PHP as well as they knew any other (that is to say, they could probably write a Hello script). I was a self-taught hobbyist with no degree, but I was the only one who brought a laptop and actually showed them my projects and the code behind them. I got the job. :)
On first look, I like it a lot. It will definitely be great to get rid of the quotes and that certainly outweighs the "ugly" in the class. I will write some test assertions to make sure there are no problematic edge cases and will go ahead with it on 0.10. Thank you very much - fantastic suggestion!
build something you want to build, for yourself. Do it because you want to, not because you have to. This will put you ahead of 95% of your competition. Whatever you make doesn't have to be perfect, and never let the fear of not writing perfect code be a reason to stop you from starting :) Also, even senior developers are noobs in some aspect of development. It's a huge subject. You will never know everything. 
&gt; I was a self-taught hobbyist with no degree, but I was the only one who brought a laptop and actually showed them my projects and the code behind them. I got the job. :) I come from the same type of background. When I first entered the field I found that I had huge gaps in my knowledge when it came to PHP, but my proven track record of being able to actually _make_ things paired with by ability to learn in a working environment got me to where I am today. Totally agree! Also, good for you for being proactive.
Use your own judgement when it comes to Frameworks. There are a lot of evangelists out there who will imply that you ***can't*** work professionally without being reasonably familiar with this or that Framework. They definitely have their benefits, but don't let anyone strongarm you into learning one because they say it's what you're "supposed to do." (Unless they're your employer and they use that Framework. Then it'd be a pretty good idea.) **TL;DR:** Anyone telling you you ***can't*** write professional PHP applications without using a Framework is being a ninnymuggins.
I had the exact same opinion as you, said it was bullshit, got told that's how Debian packages are going to be hence why Ondrej's packages are like that, said that's bullshit no one would ever want it that way, then got given this link: https://www.dotdeb.org/2015/12/04/php-7-0-0-is-available-for-jessie/ *This new naming convention and packaging method will help to produce future php7.x-** *packages more easily. And you could even install several PHP 7+ versions on the same server without any conflict!* Basically the way I read this is a call has been made that'll make life easier for shared hosting and dev environments, but in every other situation it'll suck.
You're welcome. This approach should also work if you decide to use a namespace and just regular functions in the namespace, as you can define constants in the namespace.
What exactly is the goal for PHP-GTK? What is it supposed to do?
This. Contributions to open source projects and creating them is a sign of a mature developer. You code because you're good at finding problems and solving them, and you have the humility to let others use it and expand upon it.
I think this case is solved better with meaningful flag names or an enumeration. Booleans are overused at the expense of readability.
In a similar position, so I'm going to hijack this thread rather than starting a new one, quite a few of you recommend to read 'books'. Are there any 'Core' books that you believe every "good" developer should read? 
&gt; PHP-GTK is an extension for the PHP programming language that implements language bindings for GTK+. Pretty straightforward. They're updating the extension for PHP7 and GTK+ 3.
 htmlspecialchars($string, default, default, false); // vs htmlspecialchars($string, double_encode =&gt; false); I think that this example describe me well what named parameters advocate to but also let me a feeling that this is more of poor patch (forgive me there, please) for something that I find in more powerful in convention. I find that's the only cases where they would be useful would be in functions with large sets of parameter (more than &gt;= 3) which in my opinion proliferate poor practices and wrong API design from the gecko. &gt; Using an $options array is not much more verbose at the call-site than named arguments, but it has several drawbacks which make it a lot less practical than actual named args &gt;&gt; The available options are not documented in the signature. You have to look into the code to find out. A propose for this take into account something that is already implement in other languages like array/map destructuring, This would solve the documentation issue and also can be use for plain array as well. Also fits perfectly well with the already established pattern in PHP community in using assoc arrays for optional data. &gt; Something like $options always needs to be explicitly implemented, whereas named arguments always work. Hmn, this where things get a little bit of a bitter/sweet taste on me: * 1) Named parameters could solve partially some of the problems (even is the signatures are enforced) but only in scenario where the API suffers from complex parameter signatures, which again I believe that such functions are product of poor, unfriendly APIs design. I personally don't advocate solutions that solve problems which in my opinion should be the least common denominator. * 2) My proposal could very plausible if arguments order follow some sort of conventions like a language as Clojure for example (`data structure -&gt; function -&gt; collection`).
My problem with shapes is that all fields are required when passing the shape in, which is usually not the case for array configurations.
Build, build, build... then build some more. Either do this via work, personal projects or help out with some open source. The latter being the best option as it can also be something to actually promote yourself with. If I could go back 15yrs that's what I would do. Also nothing wrong with trying lots of languages, but make sure you keep focus on at least one and master it. Sure you'll learn new things from trying other bits out but still make sure you've got one trump card! 
Still you should look into prepared statements. That stuff should absolutely be standard in every single application since 2005 onwards.
Myself, for training around this, I tried 2 projects. One using laravel as a framework, and a core piece of the code for that project I wrote as a standalone library, which i then pulled in via composer. Its reasonably simple to setup a composer package, and it helps give a decent understanding of various design patterns. From there, I bridged the two together and you can show that you work well with and without a framework.
PHP for dekstop applications
&gt; Calling it like some sort($myArray, reverse=True) makes it much clearer. You can do that already in PHP: sort($myArray, $reverse = true); you don't need named params to be able to document inline what the param means.