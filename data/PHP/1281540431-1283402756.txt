Really? You're attempting to charge for a few lines of HTML?
it's not hidden, but my first &lt;1 second impression is "whoa", and my eyes are then led to the colourful "Share images. Earn money" banner. While that's an important message to convey, it's not what the user is immediately concerned with. Contrast with [imgur.com](http://www.imgur.com) where you literally cannot fail to see the main message, which is "we allow you to upload images".
&gt; The compelling reason one day might be traffic and load yes indeed. But you won't reach that point until you make it big. You can spend time worrying about "when we hit 100k users can it scale?" or you can rest assured that your out of the box setup will handle 10k users just fine, and concentrate on building the service that will get you the other 90k. When business starts looking up, re-examine your architecture, and yes, maybe even rewrite the whole thing from scratch to support the level of success you now enjoy. Which would you rather have - "hey boss, our system can happily handle facebook level loads but we have no users", or "hey boss, we invested in getting the product service right and are enjoying amazing user growth, but if it continues at this rate our system will grind to a halt in 3 months"
[XHProf](http://github.com/facebook/xhprof) Facebook's custom profiler, has a simple HTML based user interface.
different bussiness model, "share images, earn money" is as important in this case as the upload. Either that or replace it with an giant upload button that takes to you to a clean page.
&gt; "share images, earn money" is as important in this case as the upload unless you're trying to attract a new breed of image sharers who do it purely for cash, no it's not as important. Who are 80% of the customers going to be? a) people looking for innovative ways to make money online b) people who want to share images. I suggest it's (b), and that the "share images, make money" is secondary.
Big is subjective depending on the cost, use and traffic patterns the site. Its never a bad idea to be prepared to scale a site rather than just saying this will work and I'll fix it later. Premature optimisation is never a good thing but it looks like the site is up and he is asking wether or not he should investigate using an alternative to apache. for an image host the quicker it can server images is the most important thing, so his choice of http server makes a difference. 
b) are more likey to use an established service that doesn't currently charge. Unless you have a disruptive service or offer something far better than what is currently available it will not be taken up by the majority of standard users. So i would agrue that a) is probably the demographic you are likely to get.
&gt; it looks like the site is up and he is asking wether or not he should investigate using an alternative to apache yes I agree, it does look like he might be at the sort of stage where it's OK to start thinking about architecture. &gt; Its never a bad idea to be prepared to scale a site rather than just saying this will work and I'll fix it later Also true, but if he's asking this sort of question it suggests that he doesn't have the in house technical expertise required to really know what the best approach is/are - eg talking about "my host", well, really if you're planning to essentially become a net user's cdn you'd want your own servers with layers of caching etc. Choosing the webserver (singular?) is only a small part of that process. Just switching to litespeed over apache won't magically fix scalability issues, it's something that, like you say, has to be tailor made for his individual issues. But it'll all be useless until he hits a certain mark, so my advice would be: just forget about it until you start to grow out of the single server level. If you already know a fair bit about writing for scale then you can indeed design with that in mind, but if you don't then it's not worth your time worrying about it until you need to.
I'd say it's the ideal pattern for any application with a complex user interface, where there are many "modules" of content unrelated to each other. A "dashboard" immediately comes to mind, but there are more trivial (and common) examples. Want to add a category tree to the right-hand side of all your pages, pulled from the database? No problem, just go into your layout and insert a sub-request to category/tree. You don't muddy up any of your other controllers with logic related to categories. Basically, any part of your layout that isn't directly responsible for displaying the data indicated by the request route (e.g. posts/index, users/profile) can be put in a sub-request to keep your controller logic simple and separated, even if your rendered view contains a variety of other information. This modularization then allows you to implement AJAX features without re-writing or duplicating any controller logic at all... since making a request via AJAX is essentially the same as making a sub-request in any of your other views. This also allows AJAX to degrade gracefully without any additional work from the developer. EDIT: As for Kohana, my experience with it is very limited, but I didn't really like their implementation of HMVC from what I've seen of it. It looked rather hacked-together. Also, because of how Kohana handles redirects, a redirect in a sub-request will result in your entire script being redirected instead of simply the current request.
&gt; that doesn't currently charge imgzzz doesn't charge as far as I can see. &gt; i would agrue that a) is probably the demographic you are likely to get. He needs to push that much harder then, imo. At the moment it looks like the message is "you can share images, oh and hey you can make money too". I'd rebrand it as "affiliates login here" and give it a much more "serious web application" feel. The same kind of feeling you get going into google analytics or your registrars domain manager page. Conceptually splitting the two actions into two types of user; "viewers" see an image sharing site, "uploaders" see a tool.. So yeah, if you're right and he's going after a), then it *sort of* makes sense that that banner jumps out. But I still don't think it's done right. edit: because, revisit my question: why are users loading that page (assuming they're not viewing an image). Because they have a need. What is that need? a) I want to make some money b) I want to share an image I don't think the a's are going to say "I want to make some money. I know, I'll find an image host that lets me take a percentage, find some good images, share them and make money". I think the idea is that the b's will say "I want to share an image. Oh hey, I can make money with this one too, I'll use them in the future".
I think a) is the only sensible option. I doubt you would beat imgur at the image sharing game. To be fair he's probably got some good advise in here that a consultant would have charged thousands for.
Which frameworks do it right, then? Even if it's outside of PHP?
&gt; I doubt you would beat imgur at the image sharing game. I agree ;) I'm not a fan of the business model myself. I think you're right - the only sensible way to go forward (unless you're just a "me too" on imgur) is to go after the a) market. And for that I think you need to make it drastically clear that that's what differentiates you from the competition. You're not an image sharing site, you're a revenue tool. And yes, +1 on the good advice :) Great discussion, thanks :) I'd love to see a subreddit for this kind of analysis.
Not HMVC, but the same thing can be accomplished with components. As far as I know Symfony and Yii have components.
r/ihaveagoodideapleasedestroyit
I'm the IT Director for SparkFun. I was brought on years ago as the only IT guy after freelancing with them to do minor maintenance on the site. All development is now homegrown right here in our shop as I'm not a huge believer in contracting major development projects out. Congrats on getting an order through on Free Day. *That* was interesting day to be working IT here. =)
haha ;) 
For now, Kohana is probably your best bet. Of the existing frameworks, it's the only one I've seen attempt HMVC in the core. I don't really have much experience with frameworks outside of PHP, so I can't speak for other languages. On a side note, I've written my own general-purpose framework that is built around HMVC, but it's still in late-development, early-documentation, and early-testing phases. I'd post a link to its GitHub, but since there's not even any basic tutorials written for it yet, it's not going to be of much use. My estimate would be 2-3 more months before it's ready for public release.
no no no. He's attempting to charge for a few lines of HTML *and* a few lines of PHP.
Some points that I'm pretty much assured to get downvoted for. 1. I try not to be a spelling/grammar nazi, but when you type and ask questions in AOLbonics, it makes you seem very unprofessional and I, personally, and several of my colleagues that I've talked with are less likely to give you the time of day. Compare "ok i c. thank u so much :) really appreciate your suggestion, a little off topic question if u don't mind. u have seen the site www.imgzzz.com wht shud i change or improve to make it somewhat usable and easier liek imgur. (big goal right ? :D )" with "Okay, I see. Thank you so much; I really appreciate your suggestion. I have a question that's a little off topic, if you don't mind. The site is www.imgzzz.com, what should I change or improve to make it somewhat usable and easier, like imgur (it's a big goal!)?" Which one sounds better, more professional, and dare I say, intelligent? 2. The biggest mistake that I see in the PHP world is the assumption that PHP developers are also designers, frontend engineers, UE engineers or some combination of the three. This isn't true unless you're one of a very, very few and you should design your workflow to reflect this. Find a good UE engineer or designer and partner with them, so you can focus on writing good PHP and not dealing with HIGs. 3. Litespeed is a pile of crap. So is Apache, for 99.9% of PHP projects, for that matter. If you want to modify your server architecture, build PHP with FPM (it's in the official distribution since 5.3.2 or 5.3.3) and use nginx as your webserver. It's a steeper learning curve, but there is no faster way to run PHP. 4. That said, this is something that you shouldn't be worrying about now. Fundamental infrastructure changes take a lot of time and work. If you don't have to do it now, don't and rather spend your time working on something that needs work - adding features, fixing the site itself, etc. Don't worry about dealing with 100,000 hits a day, worry about getting the site large enough that you have to deal with it, then deal with it. 5. Frontend performance is much, much more important than backend performance. There's no excuse for a mostly-static site like imgzzz to have less than perfect YSlow and Google PageSpeed scores. This is something that the frontend person should be mostly responsible for, but also you have to supply minified javascript, the correct server configuration, etc. Frontend performance isn't about scaling out to a billion users, but rather the perceived performance of your site and it matters whether you have 1 user or 1 million. 
Would you mind posting it, or pming me the link? I completely understand it's not in a user friendly state, but I'm curious to see how your HMVC differs from Kohana's.
all great points imo. Especially 1, 4 and 5.
&gt; build PHP with FPM and use nginx as your webserver. Also, nginx is very good at serving static content, which your image hosting will probably need.
Yes, I would like to know as well, for a CMS what pattern would you recommend instead?
Apache is the best for PHP, but not the fastest. Stick Varnish in front of PHP and you're ready to go =)
I'd honeslty go with Zend Framework over anything else if I had to choose one. It's a lot less intrusive than any of the other frameworks that I've seen, yet does more for you without getting in your way.
Look into Code Igniter.
Absolutely not. Kohana is in every way superior to CI (aside from the docs). If you're suggesting it, that means you've never used Kohana. Go do it now.
I'm looking for an actual framework though. Zend Framework is more of a framework framework. I do plan on using its components though regardless of what framework I use.
I haven't used Kohana for a real application yet, but I have used Symfony. Symfony tends to be more oriented towards large applications used in web app businesses. The one thing I like from Symfony over Kohana is that it uses multiple 3rd party ORM's like Propel and Doctrine (more Doctrine now since Propel stopped development). I believe Kohana uses its own and I like how Symfony is setup and the admin generation tools. It looks like theres more plugins for Symfony too. Going with the ORM idea, though Symfony allows you to define the DB in YAML or XML format and then generates the queries to generate it for you along with sample data (you can work backwards too). Looking at Kohana's ORM, it doesn't seem to do this. The benefits in my opinion of that, is that you can recreate the database in a new environment rather easy or if you screw it up.
Mmm.. I've used both, but stuck with CI purely because of the superior docs. Forgive the ignorance, but what is there in Kohana to make it worth switching? Admittedly, it's been a while since I looked at Kohana..
So you did *look into* Code Igniter then, so you could reject it with authority ;-)
&gt; It's a lot less intrusive than any of the other frameworks that I've seen, yet does more for you without getting in your way. Couldn't be further from the truth. Zend is terrible.
CI still supports PHP4... Enough said.
You might know Kohana well, but it takes a while to learn (crappy docs, few demos, inconsistent/bad names in code). That is going to slow down other developers in your team. I've worked at a place where developers starting learned Symfony on their first day, it's that intuitive and easy to use. I'd go with Symfony 1.4. It has lots of plugins (avoid sfGuardPlugin and write your own, because it sucks) and is very extensible. Doctrine is great too. Don't touch Symfony 2.0 IMO because the developers have totally ruined the framework in that version.
We use symfony at my work. It is definitely robust and every new developer we hire seems impressed with the built-in stuff it does. I've always been able to find answers to my questions, either in the docs, or in the Symfony forums. I can't compare the two because I've never used Kohana, but I'm definitely willing to cast a vote for Symfony.
I believe Kohana 3 changes the game substantially in a number of areas, including PHP namespaces. Haven't looked into it myself, but people I have been talking to say development in Kohana 3 is a lot faster and smoother than 2.
I've been looking at 2.0. We briefly considered using it since by the time this app is finished, symfony 2 will be final. We ultimately decided against it due to lack of sufficient documentation right now. But what makes it so bad? Is it because much of the magic is gone?
Sorry, I should have said that. CI was actually my first framework.
I've really liked using CakePHP. Somewhat similar to Rails, conceptually.
I work almost exclusively in Kohana (when I use a framework) I like it because it's really scalable, dynamic, and it keeps everything organized really well. If you're starting from scratch, I'd say Kohana's a good one.
Just curious, what does an "actual" framework do that Zend does not?
I have to disagree on SF2. It is exactly the reason I started using Symfony. Out of tens of frameworks this is the only one: 1. That has clean, logical file structure (./source - code/system; ./web - public/css; ./myapp - private/logs). 2. That does not have 'intrusive' objects names. Zend_*, Kohana::*. (yahoo! for namespaces) But on the dark side I've to admit, that I'm not a fan of CLI, just yet. The Documentation for SF2 is lacking aswell (however being in alpha, it's rightfully so).
The absolute fastest way to serve up php: http://interfacelab.com/nginx-php-fpm-apc-awesome/
This is my issue with PHP frameworks as well - special suffixes, prefixes, their own magical template's languages, configuration files (YAML is at least cool. But INI?), unnecessary abstraction (interfaces? Wasted time &amp; keypresses). Ended up with reinventing the wheel &amp; writing my own framework, that just works. Should take a look at CI now probably. 
&gt; I believe Kohana 3 changes the game substantially in a number of areas, including PHP namespaces. I'm a regular Kohana 3 user and this is false. It doesn't support PHP namespaces. However, 3.1 might.
I evaluated symphony a while ago now but I really didn't like it because of the hassle it took to get it installed and the use of yaml files everywhere. It also ran slow and felt chunky. The documentation however was excellent. Kohana on the otherhand is incredibly easy to install, feels very snappy and fast. Kohana documentation is not good, but I normally read the code anyway (which is excellent). I've since created many applications including large ecommerce sites with Kohana and I have to say it has been excellent. I highly recommend it.
Hopefully, if developing professionally you won't screw it up and not have some form of either backups, or ability to reset it in a scripted way (for testing...? Maybe?)
I've developed many web-apps on Kohana 2.3 and am moving to Kohana 3.0. It's simple, light, and covers most of the things you'd need in a framework. Symfony was bloated, slow and over complicated last time I looked (v1.x). However it did do a lot for you, though I'd guess that in a real app you'd have to change most of it anyway. At the end of the day, if it's a massive app, you should at least try both or even a few others too - just to see what you and your team feel fits best if they are this close.
Drupal is too much (overkill on 99.999% of projects), Joomla is a rat's nest, Pegboard might be almost as bad. Oh, you have to pay for Pegboard? Ahahaha. Out of the three, Drupal is probably the best choice. That said, I wouldn't pick it.
When I use Symfony, I generally chose 1.1 unless I need something in a later version. The biggest draw of Symfony is Doctrine. That's really the only reason to choose Symfony (but it's a huge one). In my opinion, the newer versions are overengineered. That said, I'm actually looking to switch to Kohana soon.
How does Kohana approach ORM/RAD? How often am I going to have to be writing raw SQL?
I don't know why this is getting downvoted. While not a front-runner, Cake is a *very* solid framework. Super super lightweight, and while it's nothing near Symfony or Kohana, you could probably save time on 75% of your projects by using Cake.
Parts of Zend are terrible. Parts of Zend are awesome. If you understand what the Zend Framework is, it makes quite a bit of sense.
What Can I do with this¿?
does it watch the MCP too?
they have an ORM, you never have to write sql if you don't want to
I presume that you can administer your virtual machines just by connecting to the host (dom0) IP. Really cool project, dunno if useful but I believe it was/is a lot of fun to make.
ok yes ur right about that :D thx 
&gt;"you can share images, oh and hey you can make money too" yes you are very right. there should be a well developed affiliate area to give it a serious web application view! thx
*point 1: Yes, i agree. *point 2: On it, you are right i don't have much sense in designing but am a developer. *point 3: I see, i wasn't aware of that. thanks as in link stated below [http://interfacelab.com/nginx-php-fpm-apc-awesome/](http://interfacelab.com/nginx-php-fpm-apc-awesome/) i think that would be a great option 
Kohana is an offshoot of CodeIgniter and I've used CI for a few projects. One was fairly large and complex. I also attended the CodeIgniter conferences this year. Great things in ver2 (which you can grab now) and the documentation and community support is the best I've seen. I can't speak on Symfony but I've had discussions with other devs. "Harder to get the ball rolling but a lot of features" is what I've gotten back. Personally, I find 'getting things started' the biggest mental hurdle so CI is a natural fit. Oh, and even Rasmus (PHP's creator) said CI is the 'framework' he likes best. (I have the link somewhere but I'm too lazy to go look for it.) Stay away from Zend Framework at all cost. It's a black hole.
Downvoted for punchline in the title.
Why is cake nothing near Symfony/Kohana. I've heard someone say this in the past, what is it that cake does not do? 
Defending Symfony... length of install? Extract zip file to lib/vendor/symfony symfony generate:project reddit symfony generate:application frontend symfony generate:module comments Ready to start coding your comments system... The command line interface makes everything super quick. It may seem confusing at first but there are only half a dozen commands you regularly use and need to remember. For example, to completely rebuild the model (from the schema), re-create the database and insert the fixture data, one command: symfony doctrine:build --all --and-load I personally find the YAML files useful, but they are optional - can all be done through PHP (or .xml or .ini) Did you have a PHP accelerator installed when you tested it for speed?
A full framework provides a set format for building your application, Zend is a collection of helper modules, and expects you to deal with the whole MVC approach yourself.
seems like a lot of work to avoid typing VBoxManage XXXX
VBoxManage is great, but I think this is a good step in the direction of VMware server, which comes with a full web based management interface. One thing that the CLI doesn't do well right now is easy snapshot management.
If you dont mind doing a little bit of coding to get it working, [fullCalendar](http://arshaw.com/fullcalendar/) is the most decent Ajax calendar that Ive come across. Functionality and look wise, its pretty similar to Google Calendar. Its based off of jQuery, so adding to it or modifying it should be pretty straight forward. It even has some built in hooks to pull in data from Google Calendar.
Kohana provides a "native" ORM. Symfony gives you the option to choose either Doctrine or Propel. Theres nothing stopping you from using Doctrine or Propel (and disabling the Kohana ORM) in your Kohana application. Defining your schema in yaml or xml is a feature of the ORM, not the framework (http://www.doctrine-project.org/projects/orm/1.2/docs/manual/defining-models/en#defining-models). 
I hear ya, there's a real need for a very good calendar system in the wild. 
CodeIgniter has a fairly good calendar system built oon.
http://sourceforge.net/projects/phxeventmanager/
Fair enough. I was only repeating what I was told, so I'm not going to argue :-)
Spurred on by this thread, I am looking into Symfony to see if it will fit some needs. One thing that concerns me is trying to find projects that use it to see what it looks like, the kind of functionality people build and what the code looks like. Most of the examples I have found are old, often dead, projects and many on domains that have long expired. So - can anyone point towards a decent, and preferably open source, project or two that will knock my socks off, or at least impress me enough to look into it further? That would be much appreciated. And yes, I am still looking, so don't worry if you don't have any to mind :-) Edit: What I am looking for ultimately, is a decent framework with enough modules to knock up a CMS fairly quickly, but one that excels at data structures. Between a rock and a hard place: most frameworks leave the data structures for the developer to invent all over again, and most CMS that handle data structures well are not flexible enough to extend much beyond their primary functionality. Kohana is the former, and Symfony seems to promise more in the way data is handled. Okay, a few nice active projects: * [Steer CMS](http://www.steercms-project.org/index.html) * [qdPM Project Management](http://qdpm.net/) * [VeeVid](http://www.veevid.org/)
Because it uses PHP 5.3's namespaces. Every developer who cares about PHP's future should be boycotting the namespaces until the \ delimiter is changed to something else.
This is pretty fucking sweet, thanks!!
I suggest you go through the list and try the demos. http://sourceforge.net/search/?type_of_search=soft&amp;words=php+calendar
Still uses PHP4...
The only experience I have right now is with Symfony, and therefore my point is going to be biased. I have been using Symfony for a year now. I started off last August by simply reading the manuals. It was my first real approach to MVC. I have been using Joomla for an intranet at work, but never really hacked into it. Symfony's documentation was clear and made me learn a lot. Not just on PHP itself, but on good conducts and programming approaches (RAD, MVC). My first application was a hub where users who bought PDF documents off our website could download them. So just a simple form where people login and download their documents. A simple cron jobs synchronize the sales every evenings. I did not have much trouble here as it was a pretty small project. After this project, I convinced my employer that it was time to change his database. They had been using Filemaker for the past decade or so for their invoicing system (orders, *soumissions* in French, do not know what exactly it is in English, invoices, clients, products and warehouse inventory). I managed to build a complete scope statement and I got the budget to start working on it. The initial estimates where of ~ 300 hours. Ended up at ~ 350 hours. IMO, Symfony wasn't the best choice for this kind of project, but I'd say that the entire 40 000+ lines of codes are almost equally representing by : jQuery calls to take care of the AJAX, Propel code for the model, sfForm classes to validate the data. After this 6 month of full time symfony, I started a new project for another client of mine. It is going to be an e-commerce website. Half of the code is almost done, and I don't think I would had been able to do it that quick without symfony. Although this project isn't over yet, all I am thinking of right now is how well symfony fits my needs. I am starting to think that deciding between a framework is just like deciding between emac and vi. Once your first choice is done, you start to learn the power of it and will never trade it for another one, ever. Learning a framework is a real pain in the ass and it does involve a lot of time working on it. I don't think that I'll trade my 6 months worth of training with this framework to try and learn a new one.
It's a bit less OO than Symfony/Kohana, less bleeding edge, but it is also a looser framework, more for putting up a small website than building a multi-site application installation. What this means is that, a lot of times, writing the app in Cake will be faster than Symfony. As the size of the application grows, the advantages of Symfony and the limitations of Cake become more apparent.
Oh, please. I asked because I wanted to hear a rational argument, not some nonsense complaint. The namespace separator works fine.
&gt; It may seem confusing at first but there are only half a dozen commands you regularly use and need to remember I tried out symfony once and quickly got confused trying to remember all the commands. Which commands do I need to know?
You say you don't want to use Google Calendar, but it's really the best option.
How would you say Symfony compares to other frameworks that you've used?
I hate how thrown around the word "enterprise" is. Maybe you should be more specific about what particular properties of your software are lacking? Portability? Scalability? Modularity and organization?
Your header says "Driod Mill".
&gt; what particular properties of your software are lacking? Portability? Scalability? Modularity and organization? All of them ? 
Thanks, Need to get more sleep.
Yes, Zend is a component framework; however, it does MVC stuff too - and it's extensive. More so, IMO, than CI or Cake (I've never used Symfony or Kohana).
Aeroplanes 100 years ago worked fine. That doesn't mean people should have sat around and never tried to make them better. "Works fine" is not a good reason for ignoring a huge problem in the language.
Zend Framework seems an obvious choice.
Ok then, I'll bite. Explain to me how using the backslash operator is bad for any reason other than aesthetics? My main problem with your argument is I asked why you think symfony 2 is "ruined", and your response was an issue with the language itself, not the framework. You're going to have to get used to this, or you'll end up "hating" all software developed for 5.3+.
I'd rather use MODx or SilverStripe. But out of the 3 you mentioned, I would only consider Drupal.
I hate to say it but all of the above especially extensibility and portability. 
It is bad because: 1) If you connect an external keyboard to a laptop, most of the time the backslash key doesn't work (some USB adapters and laptops are lucky and it will work). Then you need to lean over to press \ on the main keyboard. 2) It is ugly. My issue *is* with the framework. If you use Symfony 2, that is creating yet more code using the horrible \ for namespaces. People should be totally refusing to use namespaces until \ is changed to something nicer.
You say that your issue is with the framework, yet your issue is really the fact that the framework is using the new namespace feature. That is a language complaint. I don't know what you think is going to happen here. The namespace symbol will not change. PHP 5.3 has been out for quite some time now. It's not like it's a release candidate and can just be changed overnight. Changing the namespace symbol a year after it was introduced would be more embarrassing than it even being used in the first place.
Setting up a project: generate:project &lt;project name&gt; configure:database "mysql:host=localhost;dbname=&lt;name&gt;" root &lt;password&gt; While editing a project : generate:application &lt;app name&gt; generate:module &lt;module name&gt; cache:clear Rebuilding model/database and loading fixtures: doctrine:build --all doctrine:data-load Or both of those combined into one: doctrine:build --all --and-load For anything else, if you just execute symfony without any parameters, it will list all of the commands, and they're all pretty straight-forward. You can use "symfony help *command*" for a more detailed explanation of each.
I'd look at some of the bigger more maintainable and popular frameworks like CakePHP or Symfony. They have a lot of the functions you need. If you want something lighter, look at CodeIgniter. But you'll have to write a little more code by hand
If by portable you mean need to be able to run on many versions of php, like version 4+...then i would recommend [Codeigniter](http://codeigniter.com). It is very lightweight and easy to get into, so thats a bonus. It does not do as much for you as some others like Symfony and Zend (but those are not as portable, only run on php5+). They also have a (much) higher learning curve...especially Zend because the docs suck from what I hear (no personal experience with that one).
I agree, as someone who has tried all the major ones without having vast experiences in any and then having to pick Zend Framework was by far the best choice. Good code, good people associated with it, solid documentation (but could use more examples), and if you know php and really jump into how it works you can make it very powerful.
&gt; I'd look at some of the bigger more maintainable and popular frameworks like CakePHP or Symfony. They have a lot of the functions you need. I would too, but if CakePHP is an example of bigger and *more maintainable* then you should probably take a step back and re-evaluate your suggestions.
True, but the main problem is it just gives you pieces. "Here you go, make something MVCish with this". Other frameworks have a general application directory structure for you.
academicearth.org Built on CakePHP 1.2 and MySQL... if I had my druthers I'd go back now and redo some of the search code, but all in all, it was a fun project.
I guess I could word it a little better. Maintainable was the wrong word. I meant the CakePHP project isn't defunct and there is active development going on. Good documentation, community etc. So in the long run you wont be left stranded with some old crappy framework that isn't being maintained.
If you are looking for something that is portable/compatible in working with different server environments, databases, and PHP versions, I'd recommend checking out [Flourish](http://flourishlib.com). This is a project that I've developed over the past few years. It doesn't have the mind-share of Zend or Symphony, but has a strong focus on security, portability and compatibility. It is somewhat like Zend in that it is modular and not a full-stack framework. There is also extensive documentation about all of the classes.
Right, and I know it is. However, I am trying to get my information OFF of the Internet, and putting my schedule on it wont help that goal. Additionally, I want the calendar to be my browser's home page, for quick and easy reference. However, google calendar takes too long to load for it to be useful in this situation.
Oh that looks promising, and its jQuery too! I think I may be in love. I will have to check it out tonight, thanks!
Ill check it out, thanks!
That looks decent, I will have a look at it tonight, thanks!
I will, thanks for the input!
It has a steeper learning curve than most, but once you're there with it, it's awesome and extremely flexible... and also better documented than anything else I've seen.
Uh, why don't you make your own?
&gt; So in the long run you wont be left stranded with some old crappy framework that isn't being maintained. Yes, you will. Ignorning the fact that CakePHP in its current incarnation is already considered the pinacle example of a shitty codebase, core developers have abandoned CakePHP to work on [Lithium](http://lithify.me/) which is being unofficially referred to by many as a spiritual CakePHP v3.0. [Compare Nate Abele's commit timeline from CakePHP to Lithium](http://www.ohloh.net/accounts/nate). tl;dr: Symfony is a well maintained and documented and supported framework. CakePHP is a horrible mess that is in the process of being abandoned in favor of Lithium and in both the long and short run is a horrible choice for a framework.
Not that proficient in PHP unfortunately. I fare well modifying scripts but... yeah :-/
[Thumbs Up!](http://codecanyon.net/item/thumbsup/50411) might work for you. You can find the Photoshop files on graphic river.
Some people like to say Zend Framework is the "obvious enterprise solution" because it's built by the "the php guys". In my opinion, ZF is more unwieldy, less accessible and has poor documentation than most of the other frameworks out there. Sure, there's a ZF "cert" you can get and that looks impressive but in the real world, perception does not equal reality. We're PHP devs for christ sake. We use what actually works, not what looks best on paper. (otherwise we'd be java or ruby devs right?) Check out codeigniter. (and before anyone asks, no I don't work for them.)
That looks really good actually. I just wonder if you'll be able to sort by the highest voted..
Plus one for Zend Framework. I'd recommend writting a few mom &amp; pop apps first using Zend Framework before refactoring/re-writitng your enterprise-app. Like all frameworks, there's a learning curve to Zend Framework.
Funny that the Lithium site is run on Cake... What evidence do you have that it's being abandoned? (not flamebait, genuinely curious)
Wow. Do you have anything to actually back that up or do you just enjoy spewing bullshit out of your keyboard? I've been using Cake professionally for the last 5 years and have seen none of this "spiritual CakePHP v3.0" crap you are espousing. Lithium is a completely different take on how to build a framework that if it *had* been CakePHP 3.0 would have been 100% backwards incompatible and would have completely abandoned the existing community. Instead, a couple of the developers decided to "scratch their own itch" and strike out on their own, leaving a highly capable set of people to continue on developing. Nate's timeline shows him leaving Cake and working on his own project. So what? Nate and Gwoo != CakePHP
So by Enterprise you mean your code has unit tests, you have a robust QA process and a carefully managed release process? Just because you built an address book in PHP and call it a Customer Relationship Manager doesn't mean you have enterprise software.
Lithium runs on Cake because Lithium doesn't do anything yet. There is no abandonment, the community is still very active.
I guess that's sort of true if you don't use Zend_Tool, with which you must only type this to create the directory structure: zf create project Then you're set. http://devzone.zend.com/article/3811 
Best way by far is to use prepared statements with bound variables. If someone tried injection they would just write nonsense to the field. It also increases performance. http://devzone.zend.com/article/686#Heading10 http://www.php.net/manual/en/mysqli-stmt.bind-param.php 
Is there a reason you're being a prick?
The best way is to strict type your variables if you can. For things like search boxes, text inputs, etc this is a real pain but for everything else scrub it as best as you can before your stick it in your DB. Phone numbers should only allow numbers, +, -, (, ), and space. If it's a number input, check to make sure it's a number. Is it a stock number that you know is always 16 chars and only letters and numbers? Well then check to make sure that's what you're getting. When I was in college I had an instructor who used to say: *Never trust your users. Users are stupid and do not follow instructions. When you ask for a number, they will enter "pancake". Be ready for that.*
Sheer inertia will keep CakePHP alive for a little while longer. Here's the scary part, [CakePHP **still** hasn't reached their 5.2+ branch milestone while Zend Framework and Symfony are in active development of their 5.3+ branches](http://cakephp.lighthouseapp.com/projects/42648-cakephp). With [PHP 5.2 being removed from active support](http://www.php.net/archive/2010.php#id2010-07-22-1) it becomes an even bigger deal. I see such a sharp decline of activity outside the community (it's a bad sign when a community becomes insular and outreach goes away). I used to see CakePHP all over my newsfeeds, now I see an article once a month at best on what is supposedly one of the big 3 PHP frameworks.
&gt; I've been using Cake professionally for the last 5 years Hit a little close to home, eh? &gt; Do you have anything to actually back that up or do you just enjoy spewing bullshit out of your keyboard? Why the hell is a supposedly good, well maintained framework STILL in the process of becoming 5.2+? The other same-class framework have not only made this leap a long time ago, they're all working on their 5.3+ updates. ZF 2.0 has hit its first milestone and is now in active proposal-and-development phase. Symfony 2.0 is pushing full steam ahead. Lithium ([which was formerly Nate's Cake3 branch, hence the spiritual successor bit(http://dblog.com.au/web-development/lithium-released/)) is 5.3+. It's damned frightening a "supposedly" actively developed enterprise grade PHP framework of CakePHP's size can't release a 5.2+ version, especially when the core team just [ended active support of the 5.2.x branch](http://www.php.net/archive/2010.php#id2010-07-22-1). Sheer inertia will keep CakePHP pushing forward, but the writing's on the wall with how far Cake has fallen behind the times that 2 major developers would rather fork and jump ship than push forward Cake3.
If by "Enterprise" you are also looking for commercial support for the framework then I am going to +1 the Zend Framework route, hands down. Plus they have a backend server that is optimized for it's framework and other products you can continue to integrate with the framework. 
Best way to do it is to use an abstraction library that takes care of this without you thinking about it (and gain a lot more in the process as well). Look up [Propel](http://www.propelorm.org), [Doctrine](http://www.doctrine-project.org) , [ActiveRecord](http://www.phpactiverecord.org), and [others](http://lmgtfy.org/?q=php+orm)... Most all frameworks these days include some form of it by default, but you can generally integrate whichever you prefer...
Most of the answers given involve using a complicated and bloated DBAL libraries for such a task (Propel, Doctrine, etc), while others suggest typecasting. These aren't bad answers, they just don't address the question directly. The best answer I can give is use a DBAL provided by PHP; [PDO](http://php.net/pdo), where the [page of particular interest regarding this topic](http://php.net/manual/en/pdo.prepared-statements.php) goes over the benefits of utilizing prepared statements (in addition to providing examples of it's usage). Be wary of anybody claiming any performance issues relating to PDO, they have no experience with tuning a web-server or writing a scalable application.
Yes, prepared statements handle the escaping and ease the execution of queries multiple times in a row (inserts for example). I've found PDO to be excellent in this regard. Just remember, not all versions of all database engines support prepared statements (I'm looking at you, MySQL...).
The mysqli module is ponderous for doing prepared statements, use PDO instead.
PDO will silently emulate prepared statements for underlying drivers that don't support them. In fact, you even even force emulation for drivers that do support them, if you'd like.
Interesting. Because I just started a web project on Cake (dormillo.com). I'm not sure if I want to really start over (project is probably about 40% done at this point with about a month of work done). My impression that it's very active (I'm going to CakeFest in Sept, pending budget approval...). I use it for a few isolated projects at work. But I've been able to find plugins or code samples for nearly anything I've needed (like tying in Facebook auth to the bundled Auth system) I tried symfony before going to Cake, but just kept getting frustrated.
Well I gave the directory structure as an example, but what I really meant is it's just a bunch of loose tools and it's up to you to figure out how to use them. Most other frameworks provide much more structure. Read this chain of comments, it's explained much more fully here: http://www.reddit.com/r/programming/comments/cvitp/more_recognition_for_this_whats_wrong_with_php/c0vlha3
Right, which is why I was asking for evidence. The community seems really active to me, I've been able to find whatever help I've needed
I just do .replaceAll("DROP") /troll
&gt; Hit a little close to home, eh? It's a framework I use at work, not my pet dog. Point being, I use it for a living and am more active in the community than simply reading about it on Nettuts or Reddit. I know it's warts and I knows it's strengths based on actual use as opposed to "i didn't know what the fuck i was doing and omg this full stack framework was so much more complicated than this simple routing framework! durrr." &gt;Why the hell is a supposedly good, well maintained framework STILL in the process of becoming 5.2+ Because unless you you live in a perfect world where you control your own hosting environment 100% of the time, PHP4 is **still** a painful fact of life and having a framework that works with 4 AND 5 is hugely beneficial when dealing with clients who have system that are, 3, 5, 10+ years old. Also, support for 5.2 (not 5.2+) has been in CakePHP 1.2 since [2009](http://bakery.cakephp.org/articles/view/clearing-up-some-confusion-on-the-release-versions-of-cakephp). Just because there is backwards compatibility to old *but used* versions of PHP suddenly makes the project shit? That doesn't make sense. If you don't use PHP4, and support for PHP5 is built into the framework, why the hell do you care? The current development branch of [Cake2.0](http://bakery.cakephp.org/articles/view/gearing-up-new-repository-and-2-0-development-branch-available) will be 5.3+ only and the roadmap for this process has been explained and understood as a "good thing". It's called a "planned transition", where they don't just abandon their existing users because it's fashionable to use PHP5.3+. Those of us who are stuck supporting hundreds of legacy systems and sites as opposed to 1 that can be updated in a week, we appreciate it. &gt; Lithium ([which was formerly Nate's Cake3 branch, hence the spiritual successor bit(http://dblog.com.au/web-development/lithium-released/)) is 5.3+. [sic] Yes. And *SURPRISE!* Nobody is using it. It's as if they alienated almost an entire community by rewriting everything and switching to the bleeding edge version of PHP which a lot of webhosts were hesitant to switch to because of the backward compatibility problems caused by deprecated functions. Also, who the fuck is "Dave" and how is he an authority on the subject? How about some [actual perspective](http://rad-dev.org/lithium/wiki/blog/and-were-baaaack) from Nate himself where he explains he's taking this as an opportunity to refresh and reboot a separate project instead of breaking the existing framework and leaving their entire user base scrambling to rewrite everything to work with an unproven code base developed on a couple of developers whim. Dedication to their developer base and dedication on behalf of the core developers will keep CakePHP pushing forward.
There's no reason to start over. Your application will be launched and put into archived maintenance before anything gets truly serious. However, for the future you will want to reconsider. Using Cake means tying yourself to an outdated codebase that is required to still support PHP 4 (meaning they have to do all sorts of work-arounds and can't take advantage of the ability to slim their codebase and use more advanced features), it means no flexibility (good luck trying to use Doctrine instead of their clunky ORM, or use your own authentication system), and it means completely tying yourself to the community. Symfony and Zend Framework do code shares all the time, no such thing usually happens between CakePHP and other frameworks. The upside to a framework that does everything is you get off the ground quicker. The downside is your fucked if you want to do anything special and doubly fucked when they can't keep up with the rest of the PHP communities momentum.
Yeah, that's the only thing, I was hoping for a good opportunity to just dive into 5.3 and all of its features. But once I put everything together, Cake came out on top for RAD and just ease of use with everything, if it's done the Cake way. I had no problem with that, I have deadlines to meet. Even for symfony, I did not want to invest into it just yet until 2.0. Cake 2.0 seems too far off on the horizon The PHP 4 support built in kinda sucks, but, with 1.3 and 2.0 hopefully they are doing away with alot of it
What does unwieldy and less accessible even mean? You're going to need to be more specific there. Codeigniter is PHP 4, so I wonder if "unwieldy" and "less accessible" stem from the fact that ZF is coded for PHP 5+. It wouldn't be the first time someone has come down on a framework because it doesn't suit their skill set. My company has built many complex sites and command line tools with ZF. So it *actually* works, believe it or not. 
One simple rule: if you don't filter **all** external communication through the appropriate functions given to you — `PDO::prepare` (no, escaping strings is not good enough), `htmlspecialchars`, `move_uploaded_file`, `filter_input` etc. — it's going to crash and burn sooner or later.
&gt; Also, support for 5.2 (not 5.2+) has been in CakePHP 1.2 since 2009. Oh holy shit, 2009? 5.2 dropped in November of 2006. The 5.x branch has been great about maintaining backwards compatibility with the 4.x branch. The issue is not "can I run cake on 5.2" it's "does cake get with the program and actually utilize 5.2" and no, it doesn't. It can't without breaking 4.x support. &gt; Just because there is backwards compatibility to old but used versions of PHP suddenly makes the project shit? No, what makes it shit is the fact is the fact that they cling to it so desperately despite the fact that the core team not only end of life'd active support, they end of life'd bug fixes. Nearly every single other project with the exception of CI from then on said "no more new releases with 4.x support. If you want to run 4.x, use an older release of the framework." But you know what, that's fine, the question remains that it's halfway through 2010. They haven't even dropped 4.x support and the core team just dropped active development on 5.2.x. &gt; The current development branch of Cake2.0 will be 5.3+ only and the roadmap for this process has been explained and understood as a "good thing". Where does it say that, cause everyone on the lighthouse app claims Cake2.0 is 5.2+ and my skim through the codebase showed no use of namespaces or closures (a sign that it would be 5.3+). If I missed something please point to a page where a ctrl+f for "5.3" returns something. Though understand I don't consider the fact that Cake isn't 5.3+ only a bad thing. I run code on 5.2.x servers and have no 5.3.x servers at my disposal, so I depend very much on the fact that ZF still actively maintains their 5.2+ branch. It's bad enough that Cake is essentially telling the community "We have nothing prepared for the future," but even worse when they have nothing prepared for now. PHP 4.x installations may still be prevalent but they are not active devleopment installations by far and large (they are legacy servers that do not require actively developed frameworks). 5.2 is the current leader in both sheer numbers now, as well as in active development, so why is Cake unable to take advantage and provide to me the benefits of 5.2? I get this with Symfony and I get this with Zend, but Cake seems completely unable to provide the same? And Cake is telling me that when 5.3 finally moves into the mainstream and I can hit the ground running if I want to take advantage of 5.3's features I'm going to have jump ship to another framework? That leaves me with very little confidence. ZF 2.0 and Symfony 2.0 aren't finished yet, they're still alpha level software like LI3, but at least they'll be ready when PHP 5.3 installations hit the sweet spot and they still maintain their 5.2+ branches at the same time. Why can't Cake do this? Cake is supposed to be professional, cake is supposed to be enterprise, but they can't pull their heads out of their own asses enough to finish version 2.0 which is supposed to just be 5.2+ version of 1.3, even at a time when 5.2.x is EOL and will soon begin to see declining growth in favor of 5.3 adoption.
The best way is to use something that already does all the thinking for you. Because you are going to forget at least 1 thing.
No. Do not scrub. Ever. Scrubbing is bad. Use prepared statements.
Scrubbing is bad? I don't see how insuring that you data is correctly formatted is ever bad. Care to elaborate on this?
Wow, lots of stupid overly-complex answers here. You don't need an abstraction library to prevent SQL injection, you just need to escape your goddamn strings. And by escape, no, I don't mean str_replace('"', '\"') or addslashes(). If you're using PDO, prepared statements take care of this for you. If not, use your database engine's escaping function (e.g. mysql_real_escape_string). That's really all there is to it. Don't bother manually escaping quotes or doing anything else security-related when inserting. It's not going to add any security, and only risks introducing holes because of the added complexity.
Scrubbing leads to error. Error leads to security vulnerability. When programmers "scrub" sql they just get it wrong; ask any pen tester. Prepared statements.
&gt; Cake came out on top for RAD and just ease of use with everything, if it's done the Cake way. I had no problem with that, I have deadlines to meet. Be careful with that line of thinking, that's what catches most people. RAD is great until feature creep sets in and you have to start shifting directions in your application architecture halfway through your project (sadly these things are inevitable). It's the reason why ZF has become so popular and the reason why micro frameworks are becoming so popular in the Python world. &gt; but, with 1.3 and 2.0 hopefully they are doing away with alot of it The ticket tracker says only 2.0 is getting rid of the, and I quote, "php4 hacks". 1.3 is meant to be a bridge release and still retains PHP4 hacks.
&gt; Some people like to say Zend Framework is the "obvious enterprise solution" because it's built by the "the php guys". Many of the naive ones yes, though even the developers that aware enough of how little Zend itself contributes to the community (and how badly they fuck us over sometimes) recognize that Zend Framework is great because it's presided over by [Matthew Weir O'Phinney](http://weierophinney.net/matthew/) and completely IN SPITE of the fact that Zend stamps their name all over it. Much of the support comes from people like me and dhastings who also replied to you who use Zend Framework in production (as I have done for going on about 2 years now). The architecture is clean, decoupled, and would make the Gang of Four proud. I can swap in and out Zend and my own custom components at will without breaking or unnecessarily loading anything. But like dhastings I have to ask, what do you mean by unwieldly? A framework that doesn't hold your hand? Less accessible stands for a framework that doesn't do everything for you? No, Zend Framework doesn't do any of these because it's built for people who need flexibility. And in order to get flexibility you're going to have to get your hands dirty. ZF provides the spade but doesn't dig the dirt for you since only you know how big and deep a hole you need.
Create or use a database engine that let's you do this: $SQL-&gt;query("INSERT INTO foo VALUES (?,?)",$foo,$bar);
Maybe on long strings, but on something like a social security number where it's ###-##-#### why not scrub? IMHO anything that can be patterned matched should be scrubbed.
I prefer to just pass the arguments using the exec() function. Something about binding variables bugs me. 
Cannot upvote this enough. MySQLi's way of binding things is fucking annoying, PDO also offers a level of driver abstraction.
Prepared statements don't involve escaping strings. They make string escaping completely unnecessary by first parsing the SQL logic and then sending in the data separately.
PDO is sexy in this regard: $sth = $db-&gt;prepare( "UPDATE blah SET moo = :moo, meh = :meh WHERE x"); // Dont care if this is correct right now $sth-&gt;execute( array( ":moo" =&gt; $shitty_unsanitary_string, ":meh" =&gt; $other_string )); Sort of a shortcut (you can bind variables more complexly) but still a valid way of making clean, readable, secure code.
Yep exactly. I have a very set piece of requirements (basically a three person startup, me and two friends), so going with RAD seems ok. Overall, I am happy with it. I've also did www.vacentral.net using Cake. I've coded a "micro-framework" myself (with literally two files - a dispatcher and loaders, and maybe doctrine for DB, usually PEAR), which I've used in alot of projects - but I figured I'd try out a "real" framework. I've worked with Zend in the past and did not particularly enjoy it. I liked the stuff in Cake like Auth and the Facebook plugins, and the ORM (which sucks how it uses arrays so much, but alas, PHP4).. the Bake functionality was a real time-saver too
Yep, it's basically the same thing, but designed for bigger queries. Either way it's a lot easier, safer and readable than manually escaping, although there are some cases where you need to manually escape that like when generating SQL, but that's a another story I assume PDO can do that too.
As i said, it was a while ago and from memory I had to install pear (which I generally do not use or have installed) and there was something else which meant it didn't just "work". But your suggestion brings up another point. I am not a fan of auto generating crud and code (I also don't like it with rails either). In regards to speed, no I did not have a accelerator at the time. Perhaps I should try it out again. I am a fan of the lead dev - http://fabien.potencier.org/ he's a smart chap.
There are at least 4 ORM's (probably more) that plugin to Kohana.
ye Gods!
Agreed I switched to PDO and never looked back
 CodeIgniter is a pretty cool framework, however its still supporting php4 (to its detriment). 
We've actually switched to Kohana for this very reason. It is PHP5+ only and is an actual spin off of CodeIgniter. Aside from the fact that the documentation is entirely lacking in version 3, this is a bad ass framework and we love it. 
Validating data is fine, but always use escaping prior to using it in a db. Easiest way to achieve this is with prepared statements (eg. PDO).
That's exactly the way I do it.
Yes, it really is THAT simple. (not even being sarcastic), People who inject sql queries aren't sneaky, they just figured out that programmers are lazy. To be fair, MRES is a rather long name for a function...
I can't imagine the nightmare of the free day. Any plans on doing another? also, sounds stupid but if you ever need an asterisk admin, pm me :)
Question that maybe you could answer: I know you can do bindparam() like so: $sth-&gt;bindParam(':var1', $var1); $sth-&gt;bindParam(':var2', $var2); but is there any different to just doing it this way: $sth = $dbh-&gt;prepare('INSERT INTO table1 (field1, field2) VALUES (?, ?)'); $sth-&gt;execute(array("$var1","$var2")); Do they provide the same protection? Why would I use one rather than the other? 
Isn't this what Zend does? (I've never actually looked at it).
death to sssssssssssssssssssssssssssssissssssssssssssssssssssis
Zend ties an idiosyncratic naming scheme to file and directory names, and then uses a "smart" autoloader to find the classes you need based on the class names. All this does is save you from having to figure out the correct include path for some of your libraries. Given that this comes at the cost of a rigid filenaming scheme, it doesn't really solve the problem of relative path includes. Zend simply forces you to use a particular naming convention.
I just started using CakePHP and I am loving it. I was able to create a blog system in minutes and I yet to create any SQL statements.
Once upon a time when I was bored, I whipped up a class to replace all those inconsistent string functions. I never actually used it. It probably sucks when it comes to performance, although the Unicode thing might come in handy. It's on Github along with other useless hobby projects, in case anybody wants to see. $str = new String('Hello World!'); $str-&gt;setEncoding('UTF-8'); $str-&gt;replace('Hello', 'Buongiorno')-&gt;trim()-&gt;toUpper()-&gt;escape(); **EDIT** Hey, it looked fun, so I went ahead and spent about an hour writing another class for files, too. Just put it up in a new repository. [Here's the class](http://github.com/kijin/phpobjects/blob/master/classes/file.php), and the [Documentation](http://github.com/kijin/phpobjects/blob/master/docs/file.txt).
As per my knowledge, both are same in terms of protection. Advantage of first method is you can bind variables in any order. You can bind var2 first then var1. When you use anonymous way(2nd method), we should be careful about the order if query changed anytime. 
The difference is that with the first solution, you can then do $sth-&gt;execute() without inserting the variables every time, as they are bound already. Also, there's no sense in writing "$var1" and "$var2" (as in, what do you think the quotes do there?).
I've never heard of a snippet that would do that. Let's hope it's in the future for PHP.
In a PHP 5.2 world, Zend's naming structure might be seen as overly verbose, but the intention was to make the best of things until namespacing became available in 5.3. Compare how Zend_Json_Decoder was changed from ZF1 to ZF2: * http://framework.zend.com/svn/framework/standard/incubator/library/Zend/Json/Decoder.php * http://github.com/zendframework/zf2/blob/master/library/Zend/Json/Decoder.php
That's great. It's exactly the kind of thing I'm looking for ... except for *every* PHP function.
But it doesn't directly address the namespacing issue, it simply creates a convention and then *ties it to the filesystem* in a way that will only ensure maximum resistance to change once real namespaces are in place. In other words, Zend has created a legacy system that isn't going to go away.
Our software is used by our government almost 75% of all municipalities in this country. By indexing Audio/Video, Votings, speakers, resolutions and written records of meetings and hearings. We have hundreds of web editors working with it. over 40.000 h ours audio/video for over 12.000 meetings and 2.7mill articles. Everybody here can see and read exactly what their elected city council is up to. We started out small but it's getting big! Oh and we do have an address book yeah and thats exactly why I am asking this question because our "Address book" Isn't a simple Address book anymore.
This right place to do this is in the [Standard PHP Library](http://www.php.net/spl) which is implemented in C as an extension. For example the [SPLFileObject](http://www.php.net/manual/en/class.splfileobject.php), shown in use [here](http://eide.org/2008/07/17/splfileobject/) does exactly you example. Implementing libraries like String etc. in PHP is a bad idea IMO because the cumulative performance overhead is too high.
Huh? You didn't have vast experiences in what when?
Oh, dude. Can you update this to 5.3 please? I think me and my IDE may love you forever :) If you renamed String to Str, then had a static factory method called 'ng' that returned a new Str object you could: $str = Str::ng('Hello World!'); which is silly but fun :)
But without writing and profilling the code, that assumption may be incorrect. The bytecode may optmize all the cruft out.
Then you don't need a framework, you need a plan. And I'd say you don't have one, because "Ask reddit about PHP frameworks" is not a plan. You might try documenting the systems you have. You might want to audit your code and calculate the risks / benefits of rebuilding various projects. Oh, but you won't. Instead, you'll put together a crack team of young guys who know all the latest tricks, and they'll huddle together for six months, decide to build it in python, and then half the team will quit for some other company. You never get to rewrite enterprise software.
It ties the class name to a directory and file name, which is useful to force plebs into actually naming everything in a standard way. No matter who has coded something, just from the class name you have a good idea that you may actually be able to find the source code. Comming from a project where each directory in the 'includes' tree has a 250Kb 'funcs.php' file in it, I can see what ZF is trying to achieve.
Best answer here. Shame the vocal newbs are voting each other up. What is it with re-inventing the wheel and ignoring code reuse? Bah.
I think someone needs to fork PHP and fix all this kind of stuff. Either that or the PHP guys need to bite the bullet and say that PHP 7 will be a complete rewrite that isn't going to be totally backwards compatible, like Apple did with OS X. 
If the company aren't utilising you to the extent that you are worth $35k a year to them, then leave, you deserve more, in London I was earning about ~$70k and USA salaries are supposedly way higher. Start looking for a new job, you will find one very quickly.
[This guy](http://code.google.com/p/php-chainable-string/) implemented a String class, and found that it's 2-3x slower than directly calling PHP functions. My class is probably even slower, due to the Unicode stuff. Whether that overhead is "too high" may be subjective, though I'm inclined to say it's pretty high. SPLFileObject is OK, but it seems like the devs just took all the file functions and put them into a class. IMHO it doesn't make much sense to have all the methods start with an **f** when they belong to a FileObject class. 
For mid-level developers in Germany, contractors earn about 400 euros a day, employed you earn 35-60k euros. Rails contractors can get up to about 500 euros a day contacting 50-70k a year. in London, PHP contractors get £250+ a day, employed £35-50k I don't know about Rails in London because I've never done any Rails work there.
I could do namespaces too, but the biggest problem with this kind of implementation, apart from the performance hit, would be this: $str = new String('Foo'); $str = $str . 'Bar'; // Damn $str is no longer an object! After all, [PHP is not really object-oriented](http://michaelkimsal.com/blog/php-is-not-object-oriented/).
I've compiled code to tainted CSS before. Big mistake.
And they could say goodbye to their market share. They have a hard enough time as it is getting consumers to move to newer versions of PHP. If it was not (mostly) backwards compatible, they would never convince people to upgrade their servers, unfortunately.
So you're basically saying that PHP's market-share is purely down to it being the status quo because people are stuck with it just like Windows? Because given a chance if they were given a choice of a rewritten PHP 7 or a different language, they'd always choose the different language? Who cares about market-share anyway? Is market-share more important than a creating an intelligent, forward thinking language? It's not hard to get developers to move to newer versions. It's hard to get crappy $2 a month hosting companies to move to new versions, everyone who runs a serious website can quite easily update their version of PHP anyway. There are also plenty of PHP projects and frameworks which require 5.2 and they're thriving (Magento, Kohana).
No, that is not what I'm basically saying at all, but thanks for putting words in my mouth. I never said their market share CAME from backwards compatibility, but simply, they would lose market share by ditching backwards compatibility. No one wants to re-write a legacy application because of a breaking update. I never said, given a choice between a non-breaking PHP and another language, that they would move away. What I was implying, was that instead of moving to the new version of PHP, they would simply stay on the old version, as many consumers have for a VERY long time. Why do we still have so many PHP4 websites and servers, even though PHP5 came out **six years ago**? Because people dont like to upgrade, and if they loose backwards compatibility, even fewer will make the leap. I dont know what dream land you are in, but it is very difficult to get developers to move to new versions, when it comes to something like a serverside language. Sure, open source developers will take the leap fairly quick, as will joe nobody working on his private website, but I can tell you from experience, companies with large codebases in a language will not budge if the next version is not backwards compatible. It would cost them too much time and money. Lastly, I enjoyed your comment: &gt;everyone who runs a serious website can quite easily update their version of PHP anyway. I like how you think that "serious websites" are the only ones that matter. The vast majority of sites using PHP, are not "serious websites" by any definition, but are just people running a bulletin board or blog. These people make up the majority of the PHP market, and if they don't move to a new version, it makes it difficult for any projects to move to a new version either. Look at the whole [GoPHP5](gophp5.org) movement for example. The developers had to basically force their users into upgrading, which is a sad state of affairs.
So (I'm gonna put words into your mouth again here, sorry) PHP basically panders to the lowest common denominator and is just for crappy blogs and forums? Do you think Ruby or Python design their roadmap based on how many crappy crappy emo blog developers they can retain in their user base? This is the backward-thinking attitude that makes PHP the laughing-stock of web scripting languages. There are people out here who use PHP in enterprise environments who are sick of the inconstancies of PHP, and most of us are moving away to other languages. And yes I do live in a dream world, I live in a dream world where I run a PHP based site which receives 500,000 uniques a month, which I have covered on here before. PHP fails in so many respects, it has some great qualities, but it is currently a big steamy pile of shit mess that really needs fixing, any decent developer will tell you that. It isn't difficult to get users to upgrade, as I said, just difficult to get shitty $2 hosts to upgrade. All websites which receive serious traffic are on dedicated servers, upgrading is trivial.
Seriously it is fucking mental isn't it?
Aye, generated SQL should not really have any user input, and purely be done for things like for loops or within controlled circumstances, though. Searching is a PITA but there are plenty of libraries that can be adapted (eg Sphinx or Lucene) for this.
You're mixing input filtering (as part of input validation) with escaping output. They are separate concerns. Input filtering / input validation is used to prevent users from entering garbage, but it's not for handling output. Now it may appear that you've filtered enough to think that it'll be safe to just throw that at the database as-is, just don't count on it. When outputting anything, you should use the proper context specific way to escape/quote data. For outputting HTML that's htmlentities() or htmlspecialchars(), for outputting to databases it depends on the database and how you're accessing it, with prepared statements being the absolute most recommended way. I've seen people store text in a database escaped via htmlentities() with ENT_QUOTES, so the single quotes wouldn't cause issues. ಠ_ಠ
Esoteric languages you say? Go and make one for [Whitespace](http://en.wikipedia.org/wiki/Whitespace_%28programming_language%29)
Interesting. Not.
In general I agree with you on profiling but this case is an exception; wrapping foundation apis in an additional layer of PHP carries a high likelihood that you end up calling those apis very frequently, multiplying that overhead into something that will hurt. For example the site I work with, profiling http://www.local.ch/q/bern/restaurant.html I see 349 calls to str_replace, 174 to strtolower, 126 to strpos and 121 to substr - that's a lot of calls to have to pay an additional cost of a userland PHP method call to the wrapper. &gt; The bytecode may optmize all the cruft out. There aren't really any tools in PHP that do smart stuff with bytecode - most are just caching to eliminate parsing overhead. Hence facebook write something like [HipHop for PHP](http://wiki.github.com/facebook/hiphop-php/)
The problem is (in my opinion) the 'correct' answer isn't a direct one. ORM libraries are the best route for taking care of this problem because you get so many side benefits from them as well. Yes you can simply use prepared statements with PDO, yes you can just use mysql\_real\_escape_string()...those are the 'direct' answers...but are they the best way? In my opinion, unless you are just starting out in PHP or don't care about re-inventing the wheel, you should be looking into some sort of DBAL. The ones I listed in [my other post](http://www.reddit.com/r/PHP/comments/d0hc6/best_practices_to_combat_sql_injection/c0wmoyu) are the ones I would recommend.
Brainfuck. (or C, then it'll be recursive)
Source: Haskell Target: PHP Goodluck and Godspeed.
PHP, similarly to [PyPy](http://en.wikipedia.org/wiki/PyPy).
ASP.NET
C, try to compile the latest PHP source code.
Write the first _ever_ compiler for Snow! http://code.google.com/p/php-snow/ :)
Stay tuned for tomorrows article: How to Tie Your Shoes Subscribe to our RSS feed!
Perl 6. (I was thinking of doing this one myself actually)
Ook! http://www.dangermouse.net/esoteric/ook.html
Personally, I prefer [SASS](http://sass-lang.com/) for creating style sheets. It is more mature and has a large user base. Also, it has had the 'compile' feature for quite some time, as that is how it works in essence. Also, see [Compass](http://compass-style.org/) for some added goodies included along with SASS. Watch the [video on the docs section](http://compass-style.org/docs/), it explains the awesome that is SASS pretty well.
LOLCODE!
With LESS? Or with another system?
Write it in PHP. I will be impressed.
Nor does it consider octal numbers.
If you need to filter data for some other purpose, that is a different discussion. But *do not* do so thinking it will protect you from SQL injection.
Check out the official [LESS repository](http://github.com/cloudhead/less.js); it's being developed in JavaScript now so you can either compile it in the browser (good for development) or use node.js to compile it into a file. The code for the lessphp library is a mess :(
I played with it for a few hours. The code is very clean. It looks like they're aiming for "what if CakePHP was re-written for PHP 5.3 strict?" As a fan of CakePHP, I like it. But its not quite-yet ready for prime time, and the documentation is severely lacking.
Python is having a big trouble getting folks to adopt Python 3. GVR gave library developers 5 years to migrate, if not longer. That sounds comparable to the situation with PHP 5 (6 years since release). Backwards-incompatible changes to the language core take a long time to get adopted, period. PHP 7 (or 6.x or whatever version might be next) could introduce some new classes as part of SPL, and introduce new syntax such as "string"-&gt;substr(), without removing all those inconsistent global functions. The classes would be in their own namespace, so that people who have been using classes named File or String don't need to rename them. In a later version, PHP could stick E_DEPRECATED on global functions. Then, many years later, they could finally remove them. In the meantime, most popular applications will run just as they do now. And nobody stops you from running an outdated version if you really want to. Look at all those folks still running insecure PHP 4. Many web hosts even allow you to run PHP 4 and PHP5 at the same time.
&gt; Other than being incredibly nerdy it's not bad... No, its worse than bad. It's terrible. 
Looks good! One question though, What's the advantage of the ob_start() ... ob_end_clean() rather than $args[$i] = var_export($args[$i], true); ?
A little late, lessphp has been out for over a year. But it would be better to just use the ruby implementation.
Looks like there's no advantage. After all, not many people are aware of the fact that var\_export() can return the result instead of printing it. var\_dump() and print\_r() on the other hand can't do that. Oh I love these inconsistencies! Another issue, microtime() without the argument returns the string "msec sec", which is not suitable for the $time = microtime() - $start; operation. You should use microtime(true); Edit: escaped underscores.
Try Java. Oracle will sue you.
I know about the javascript version, but what will you do if the visitor has javascript turned off? That will automatically kill any styling done with CSS.
Good tip! I missed that second argument.... I'll update the code. Thanks.
Done, thanks also.
Maybe you could contribute to this project: http://phpjs.org/ 
That's why I said the browser-js version is useful for development, then use the command line to compile before deploying. Requiring any javascript for a site to run is lunacy.
I wrote one once in just one line! Problem is it compiles everything to hello world. 
French.
Well if you filter it to make sure the input is what you're expecting, then escape it when you put it into a DB it's safe. if you're asking for a value in the format of ##-#### and you verify that the value is correct there's little to no chance they can inject something via 6 numbers and 1 dash. Regex is good for this stuff.
I agree that this is exactly what PHP *should* do. Not sure what the chances of them doing it are, however.
My biggest is also my first serious PHP project which is a Web Comic CMS. I'm learning everything as I go and as I implement features and fix bugs. I'm certain the PHP is a nightmare but the user experience for admins and guests will at least be solid.
Are you: * (a) a seasoned developer who has [written]/[contributed to] a compiler before and has way too much time on his hands * (b) average or intermediate PHP programmer who is trying to explore the process of building compilers and not give up when things get complicated If you're (a): go ahead and my suggestion is the [brainfuck](http://en.wikipedia.org/wiki/Brainfuck) programming language If you're (b): Writing a compiler is (IMO) not a "fun" thing to code so my advice to you is to keep things simple and pick a language that is simplified for the means of education. Go to the library and pick up a book named "Modern compiler implementation in Java" (there is also a C edition) written by A.W. Appel - the book covers every step of implementing a compiler in great depth and it's wrapped around a very intuitive language: (* fibonacci *) fun recfib(n:int):int = let var f:int; if n==1|n==2 then f=1 else f=recfib(n-2)+recfib(n-1) end in f end; fun main():void = let print_int(recfib(10)); print_char(' '); print_int(itrfib(10)); print_char(' '); print_char('\n') in none end 
print\_r _can_ return its result to a variable instead of stdout
Your advice is akin to advising people to not wear seat-belts but instead just drive really really carefully.
So checking to make sure the data is properly formatted and escaped before inserting into the db is like not wearing a seat belt? That's a new one to me.
Oops, forgot. Thanks for pointing that out. PHP inconsistencies Grrrrr!
CodeIgniter is more about Rapid Application Development than Zend Framework. That's accessibility. CodeIgniter has a more predefined mvc structure out of the box than Zend Framework. Zend Framework projects can become more unweildy unless the dev(s) already have a good understanding of design principles. My "skill set" isn't what forces me to use CodeIgniter, it's what helps me see the advantages in doing so. Oh, and CodeIgniter v2 is PHP5+ and Kohana (an offshot of CodeIgniter) has been PHP5+ for over a year. (Let me know and I'll send you the url's.) I beleive ZF works, it just doesn't work for me.
thanks, it's a great site!
Well said and maybe my criticism of ZF was a little harsh. My initial experiences with ZF were terrible. Buggy code and bad documentation. It's matured in step with php 5.3 and I'm currently using ZF in a pet project. I do have "enterprise level" apps running built on CodeIgniter and I know there are enterprise level apps running on Symfony, CakePHP and even Smarty {shudder}. In the end, it's about the architecture experience of the developer which, I fell, comes more slowly than programming experience. Zend Framework, in my opinion, is too "loose" for most PHP devs to jump right into. When asked about frameworks by php devs, I typically recommend CodeIgniter and Zend Library so that they don't get stuck right away and can pace out those "ah ha" moments when the see why things are done the way they are. Side note: The gang of four would probably laugh at all of us and tell us to use Java or Python so we don't develop bad habits.
I would say b) but a seasoned developer. Never done compilers but I know my shit when it comes to PHP. Will look for the book.
I definitely agree with you that Zend is really more for the experienced. I'd blab on more but I hate typing on my phone.
I might just do that. Don't see the point of the whole project but meh.
Half-assed Lisp should be easy.
If you're looking for books I would suggest the [Dragon](http://www.amazon.com/Compilers-Principles-Techniques-Tools-2nd/dp/0321486811/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1281739883&amp;sr=8-1) book and [Constructing Language Processors for Little Languages](http://www.amazon.com/Constructing-Language-Processors-Little-Languages/dp/0471597538/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1281739941&amp;sr=1-1-spell). Both of these were very helpful to me when I did something similar to what you're doing. Shockingly enough the experience I gained trying to write my own compiler has been extremely useful in other areas, so I personally think this is a great idea. You may want to check out some projects that already go this- [Twig](http://www.twig-project.org/), for example, is a template processing language that compiled to native php.
http://www.reddit.com/r/PHP/comments/d0cvb/need_help_php_enterprise_framework/ http://www.reddit.com/r/PHP/comments/cq6iu/hey_php_whats_a_good_framework_for_beginners_who/ http://www.reddit.com/r/PHP/comments/cpcex/rphp_can_you_suggest_a_php_framework_for_a_django/ http://www.reddit.com/r/PHP/comments/cojpk/hi_rphp_please_try_out_my_framework_swiftlet_be/ http://www.reddit.com/r/PHP/comments/cl3xw/what_frameworks_should_i_learn/ http://www.reddit.com/r/PHP/comments/bx28q/ask_reddit_which_php_mvc_framework_work_best_with/ http://www.reddit.com/r/PHP/comments/a2m3v/lithium_the_new_php_framework_on_the_block/ http://www.reddit.com/r/PHP/comments/a2j0v/thoughts_on_the_akelos_php_framework/ http://www.reddit.com/r/PHP/comments/9iuup/maintainable_php_framework_clean_and_elegant/ http://www.reddit.com/r/PHP/comments/9k4pn/help_me_choose_a_right_framework/ http://www.reddit.com/r/PHP/comments/90jnu/madeam_php_mvc_framework_interview/ http://www.reddit.com/r/PHP/comments/8xftf/minimal_mvc_php_framework/ http://www.reddit.com/r/PHP/comments/88zrq/new_recess_php_framework_release_v012/ http://www.reddit.com/r/PHP/comments/88ibo/getting_started_with_code_igniter_php_framework/ http://www.reddit.com/r/PHP/comments/8o7ce/roll_your_own_php_framework/ http://www.reddit.com/r/PHP/comments/8nsd3/a_php_micro_framework/ http://www.reddit.com/r/PHP/comments/77bvh/getting_started_with_symfony_a_php_framework_part/
have you ever use bind param with mysqli?
Re-usability is probably one of the main things about them that is beneficial. While having a lot of code pre-written is nice you will find that most Frameworks apply an object-oriented environment which will take your re-usability to the next level (plus some other advantages, but I'm new to it as well and I don't know them all). Also frameworks mostly aren't hard to move and they aren't that large, plus I think some of them allow you to have more than one site on the same framework. I recommend playing around with Codeigniter because the documentation is good for beginners. After a while you will likely want more and switch to something that takes more advantage of PHP5 like Kohana.
you should instead try to implement some sort of event-driven php version, or threading ... :( 
Frameworks are especially useful in PHP because there isn't true separation of concerns out of the box. For example, there isn't a templating system built into PHP like there is in ASP.NET or Ruby. A framework like CI or Kohana organizes your application into layers which, in theory, will make development easier. If you work in a team where you have designers who don't mind coding HTML but balk at anything more, it's a lot easier for them to do their jobs. If anybody new joins your project, if they're familiar with MVC or even MVVM, they'll know exactly where to find things. I was wary of going to a framework but now I'd never go back. It may, however, make you wish PHP was more like Rails.
A framework is like a martial art. You could invent the martial art yourself, but the framework provides ways of doing things that are proven to be effective. Frameworks also tend to take care of things that are mundane to code yourself, leaving you with the higher level, more creative stuff.
Good code is usually broken down into the following components, in order from most-&gt;least important (the ordering is my opinion, anyway): 1. Success and usability: the task at hand if and how well it performs it 2. Maintainability: how easy it is for you to come back to your code or a stranger can read and maintain/modify your code 3. Re-usability: how much you can take from your code and use it elsewhere without major modification 4. Code quality: while closely related to #2 and #3, but separate; things like separation of concerns, modularity, etc. 4. Performance: well, let's be honest here; PHP performance doesn't matter to your application and if it, you'd be using a different language (not trollbait, PHP is one of the worst performing languages, period, but it gets away with it because its domain execution speed is largely irrelevant) As far as what a framework does... it gives you a set of tools and conventions with which to use them. Nothing more, nothing less. The price you pay is a lack of flexibility in how you design your application within that framework, but that comes with some advantages. Regarding the points above: 1. Greatly decreases time to production by giving you a set of wheels, so you don't have to invent your own. Whether that's routing your application, a templating layer, etc. the tools are there for you to use. 2. When you follow the conventions and use the tools in a framework, you're following (hopefully) well documented procedure, so in a few months/years when you forget how your code works (or if someone who's never looked at your code before), you have readily available documentation of what piece goes where and how it works - to an extent. An extent that's usually enough for you to figure out the rest. 3. Frameworks tend to force abstraction on the developer. Force is a bad word to use because it implies that it is a bad thing; in moderation (and most PHP frameworks this is done in moderation) abstraction is a good thing. So when you build your Zend Framework (for example) module that handles memcached based sessions, you can take that same module to the next web application you have to build. There's very little in most websites that is truly domain-specific, so you can over time build up a tool chest of code you've written that does everything you need to do (where the framework doesn't already do it). I know a few PHP developers that bang out freelance gigs a mile a minute because all they wind up doing is glueing together framework components. More anecdotal evidence: the shop that I used to work for had a 1-2 week turnaround on most sites we did because of the plethora of pre-existing, modularized code to draw upon. And then my boss decided to migrate frameworks and everything went to hell. 4. Code quality is measured in too many ways to properly enumerate but abstraction, separation of concerns, drawing upon a common design/architectural pattern, and encapsulation are enormous deals that, off the top of my head, I can guarantee you that a framework will help you adhere to because of the conventions that it enforces in order to be functional. 5. Performance is a fun topic in the PHP land because a lot of people are really obsessed with how well their frameworks perform on a language that's inherently crippled from performing extremely well. That aside, writing within a framework will usually help to improve your PHP's performance when you compare it against something that you might roll from scratch that is of a similar quality and level of abstraction. All in all, to summarize, I would say that a framework puts your code in a domain that enforces some good practices, while making it incredibly beneficial to follow others, on top of which giving you a set of common use-case tools so that you don't wind up reinventing every wheel you need. Not Invented Here Syndrome is a bad, bad thing in a developer. I might also mention that all of the prices of using a framework would wind up being spent any way - at some point you're going to have to decide how to architect your framework or what database layer to use or any of the other 10,000 decisions you have to make - but the framework has already made those decisions for you.
Frameworks provide features that are considered the norm. By doing this, it saves you from having to roll with your own "custom" work. Custom work is less usable for maintenance down the line.
I swear by CodeIgniter and Mootools. GREAT frameworks. (mootools is a JS framework, and is excellent)
Just tried out CodeIgniter for the first time this week. Minimalist. I like!
Yes, CI is excellent - small footprint, modular code, it really does make it easy to develop some great sites. I also work with Drupal, which is considered a Content Management Framework, as it's highly extensible and can handle much more than just blog management. It's highly complex, though, so I like to use CodeIgniter for smaller projects.
Yes there is - its arguable that PHP itself is a templating system. http://php.net/manual/en/control-structures.alternative-syntax.php
If you like CI, give Kohana a try. It's based on CodeIgniter, but with some OOP and PHP5 improvements.
You could actually easily write that in PHP versions that support namespaces, just wrap around fopen(),fclose() and friends. I personally have no problem with using functions.
You didn't advertise this very well. You make it sound like it's just for unit tests, but it's actually an ORM with a PHPUnit example.
It's not arguable. Down-votes for? PHP *is* a templating engine. The sooner people realise that, the sooner we can do away with Yet Another Abstraction Layer.
I'm trying out Kohana again based on repeated recommendations on here, the last time being v1. I'm all for OOP and PHP5 improvements, and there are indeed many.. but I don't think I am going to use Kohana for anything serious. The reason being simple, documentation is absolutely atrocious. Just getting it up and running was a pain. I work with so many different languages and frameworks I don't have the luxury of being able to learn one inside and out, so poor documentation massively affects my productivity. Incidentally, this is an area where CodeIgniter and MooTools both excel. Am I doing something completely wrong? Is there somewhere that has any decent documentation for Ko3? Or am I just going to have to consign it to the pile of "great frameworks that might have been"..
I'll do that, thanks! I'm working on some CI based utilities for work, but the server I have to work with is running PHP 4.4, doesn't have support for .htaccess, and in general, had been a pain in the ass to develop on due to needing to connect to it via SFTP - I ended up finding out I could install Aptana despite our severely locked down "secure" workstation images, and that has support built in - Much much better than running portable versions of software, doing coding in notepad++, and uploading after each little change via a different program... And I'm not even a developer, really - Just a tech that knows a bit about web dev. There is a dev department, but they all work with .net, silverlight, proprietary "enterprise level" muck that looks greek to me. For all I read on reddit about how terrible PHP is, I still like that it is easy and clean to code with it, and I don't have to worry about annoyances like typecasting all the time. I'm way off topic now.... So I'll let the thread resume. Again, thanks for the tip - I'm off to check it out now.
Ruby has a built in templating system?
For the more experienced in programmatic architecture, not necessarily the more experienced programmer. Then again, if programmatic architecture is the bar at which we judge a developers skill level, why would he have even started using php in the first place? ....for fuck sake, php gets name spaces and all the sudden people turn into coding snobs. 
&gt; Well said and maybe my criticism of ZF was a little harsh. Stop writing outrageous bullshit then stepping back and say "oh man, maybe that was a little too much". If you give people advice, you have to be **on the level**. Are that fucking stupid that you don't understand that? Yea, I bet you are. &gt; My initial experiences with ZF were terrible. Buggy code and bad documentation. What version? What was buggy (specifically)? I've been using ZF for over a year (among a few other good frameworks like Symfony) and the only buggy component I've ran into was Zend_Markup. As for docs, I don't understand the problem people have with them. The reference manual explains pretty much everything about every component. All that's left is going in the code and trying it out. Unless you're that douche that tells your clients/bosses that "yea, I'll get this done in 5 minutes" and get pissed that you can't do a complex task in one line. &gt; I typically recommend CodeIgniter No surprise there. Out of all mainstream frameworks, CodeIgniter is by far the biggest dogshit framework. Every other framework (even Cake) has some great concepts and will scale fairly well for a large web application. But, CodeIgniter? This is the framework that **chose to write all session data to a cookie**, realized how fucking stupid that was (after almost a year), rewrote session handling, but neglected to add a way to handle sessions in a database without hacking their shitty code to shit. I'm sure that's changed since 2 years ago - but come. on.
&gt; CodeIgniter is more about Rapid Application Development than Zend Framework. You have no idea what you're talking about. &gt; That's accessibility. CodeIgniter has a more predefined mvc structure out of the box than Zend Framework. You have no idea what you're talking about. &gt; Zend Framework projects can become more unweildy unless the dev(s) already have a good understanding of design principles. Yea, no shit. That goes for any programming job. &gt; My "skill set" isn't what forces me to use CodeIgniter, it's what helps me see the advantages in doing so. You're in denial. You suck.
Ditto that - I hate magic code and love the CI let's me define pretty much everything. 
Just go ahead and join the [Kohana framework](http://kohanaframework.org/), the community is amazing.
Thanks for the detailed post, a question that I have is, with a framework am I going to be learning the framework's syntax or does it keep in line with regular PHP syntax?
Frameworks generally give you a set of components you can simply plug into each other using the languages regular syntax. For instance, the Zend Framework would have you write PHP in order to work with all the components it offers. In some cases you have markup languages that are used with some of the automation or configuration. For instance, some frameworks let you configure things using .ini files, others describe database tables in YAML, XML, and whatever else might be out here.
Look at the MVC pattern. That's really what it is. MVC, with alot of features for RAD in the controllers and for support. Check out CI (CodeIgniter) to start or Kohana (I personally use CakePHP)
As a general rule, there are three syntaxes for frameworks: the framework itself, which is always PHP; the configuration syntax which is usually XML or INI files, but could be JSON or YAML or anything else; and then there's the templating language. Templating languages are a dime a dozen and what you wind up writing in depends entirely on the framework and if you decide to use their templating language or something else entirely.
[www.Kult-RPG.com](http://www.kult-rpg.com)A small site, dedicated to a single out-of-print pen-and-paper RPG. In other words, not that popular. Parts of it is an old forum software which I was involved developing (xmbforums and ultimabb). What makes it special? - Play-by-forum section that (at the time) was really special. Members can make as many characters as they want and use them in a play-by-forum setting. - tons of minor apps A lot of it is very dated, and the whole site is kinda bloated. The next iteration is minimizing it all. 
Kohana 2 used to have [better documentation](http://docs.kohanaphp.com/). As for Kohana 3, their [new online documentation](http://kohanaframework.org/guide/about.kohana) is absolutely terrible. IMO even the Kohana website became less usable after the recent update.
Pragmatism and software architecture skills are two different animals.
Yes, share them so that hackers can look for common exploits and rootkit your server!
You might be surprised at how event-driven or asynchronous you can make PHP be. Using socket\_pairs, select, and pcntl\_fork etc, you can come up with just about anything you want.
What are they thinking? All that work into the framework, seems like a complete waste to me without some decent docs. Thanks. Kohana 3? Consigned to the scrapheap for now I think. Time wasted looking for documentation costs me money.
I was talking about site templates - as in views or pages that are inheritable. Kohana, for example, has template controllers and views. Alternative syntax of course helps in abstracting logic from the UI (and is what you primarily use in your views if you use an MVC framework), but an MVC framework gives you a mechanism to do this that is already built for you and in a pattern that other developers familiar with MVC already know. Granted, this doesn't stop developers from not using models or having logic in their views, but, like mentioned above, MVC attempts to force developers to separate UI from logic from data activities. 
Wow, you've been using ZF for a whole year? That's great. I Looked at it two years ago and half of the examples didn't work and the documentation was out of date. I looked at it again at this years PHP Zend Conference in San Jose and I didn't like it. It's gotten better but I still wouldn't recommend it. CodeIgniter is the "biggest dogshit framework?" You clearly have no idea what your talking about. CI is the only PHP framework to receive praise from Rasmus Lerdorf. (You know, the fucking INVENTOR of PHP). You can google it, bitch. 
I bet you code the way you debate ...badly
Rasmus doesn't even like MVC: http://toys.lerdorf.com/archives/38-The-no-framework-PHP-MVC-framework.html PHP has evolved from Rasmus' original idea of what it's supposed to do. Taking his word as gospel at this point will only lead you to a black hole. I said I've been writing in ZF for *over a year*, it's closer to 2 years now. The fact that you would even bring that up further shows your ignorance. A year and half of heavy usage is more than enough time to really understand a framework like ZF. It's easy. You've yet to give a **single real-world example** to back up your claims against ZF. The Zend_Controller stack can be set up in just a few minutes and every single aspect (the router, the dispatcher, the request/response handlers) can be augmented with simple plugins. 
Oh, let's not forget the fact that CI was deemed so shitty by its userbase that it was forked to Kohana. Then the Kohana developers realized how stupid the CI architecture was to begin with and with Kohana 3 they're completely rewriting the thing to utilize HMVC. And guess which framework's components will fit snug into Kohana's structure? That's right, ZF.
That comment thread is full of shit. Why the fuck does everyone speak so abstractly without providing code examples? Setting up ZF is easy as hell and it provides you all the structure you need. What structure does it not have in your opinion?
Hey troll, your logic has broken down. I claimed ZF was less accessible and more unruly and said why in previous posts. Your counter point to my arguments? "you don't know what you're talking about". ....Well then, all hail ohnoyyoudidntyo, the intellectual giant that's been writing in ZF for 1.5 years. Now Rasmus doesn't know what he's talking about either? Damn! I think you're ready to step up and write your own language son! Go head last word getter, spit your shit back ...but remember, nobody gives a fuck
You're looking at AJAX at work. Furthermore, the URL isn't actually changing. Look closely and you'll see a # up there indicating an anchor tag. This is just so that you can use the forward and back buttons in your browser. So when you click next and previous on the page, you are really staying on the same page. Some crafty Javascript is doing the work to change the content of the div that the photo/caption is in.
This isn't restricted to PHP, but all they're doing is loading up a new pic asynchronously and modifying the address in the address bar after it returns with Javascript. http://stackoverflow.com/questions/1457/modify-address-bar-url-in-ajax-app-to-match-current-state
The only counterpoint I've really brought up (multiple times) is you give no examples to substantiate your claim that ZF is "less accessible and more unruly". You've conveniently ignored this in every post. That's bullshit - don't get mad at me for calling you out on that :) I never said Rasmus doesn't know what he's talking about. Quit spinning shit. Rasmus wasn't heavily involved in the development of PHP past version 2, thus his choice of framework isn't a good selling point. 
A framework is much more than a library. * When using libraries your code is responsible for application flow, and chooses when and how to call library functions. * When you are using a framework then the framework is responsible for application flow and will include and execute your code at appropriate points. The benefits of an framework is that it can handle most common functionality like session management, database setup, configuration, routing (pretty URLs) before your code does anything. It will only call your code when something specific to your site needs to be done. Frameworks tend to enforce rigid code structure. Your templates go *here*, your controllers *here, etc. Even if you are using bespoke code you'll find any well engineered application will evolve its own framework eventually. Using an open source framework from the start gives you a head start and also helps other developers, as there will be documentation and it will generally be more polished than something that has evoved in an ad-hock fashion.
Don't presume it's AJAX. It's just as easily plain Javascript. All you need to make this work is to store a list of the image href's and any metadata you want to display with it in the initial request. The liberal use of the AJAX buzzword pisses me off to no end.
but it is AJAX, they load a few images that are to be next and when you go through those images they load some more all without loading the page. they also load comments. if you cycle through the pages with firebug open you will see that.
ajax &amp; dom manipulation, jQuery is your friend in this regard, they built a framework to do this efficiently and often.
This
On kudoz's defense, we still shouldn't presume it's AJAX. Although it's still AJAX in this particular case.
Of course, of course, but as others pointed out, it is AJAX in this case. In all other cases, I agree with you.
No, it is akin to driving really carefully instead of using proven safety features.
I've been using geany as my text editor, but I think I may be trying out netbeans for my next project.
When you insert or update. Clear the cache. Inserts and updates are far less common than selects.
Depends how often the data is being requested. For things which are going to be viewed a lot I use a 10 minute cache lifetime. You can increase the lifetime for the quieter pages, but then is it worth caching? The last option is to cache the data indefinitely and clear it when new data is inserted or updated. I store cached items with APC (memory store).
Say I have a report with filters to search for items and each search gets cached. Would it be practical to clear all cache records relating to that table when a record is updated/added or should I just make the cache expire?
I only ever really cache items that require information to be pulled through an API. Twitter &amp; Bit.ly are huge, both require different forms of cache. For twitter we cache for 5 minutes, this keeps our requests low. Bitly we cache both the long url and the short url so we make sure that we are not requesting duplicates. I store both in MySql You probably wanted more info, but that's all the time I have. Cheers.
Thanks for the share. I am gonna try it out in one of my scripts later this week. I already have currency conversions in place without GeoIP, but def wanna try this.
You can "group" cache records so that caches in the group expire all at once. It's called cache namespacing. For instance, using memcached (or whatever) you can store "G\_USERS" which contains some sort of id, like 8949873. In "USERS_1" you can store the userdata along with that id. Then, every time you get USERS\_1 you should check G\_USERS if the key is the same. If it isn't, it's expired. As a result, you can indefinitely cache records and expire them at once. :) ninjaedit: formatting
In the beginning we cached each item as an object. List queries were not cached and only returned item ids. Works well as our list pages changed pretty frequently, but object data rarely changed. Currently I cache the output HTML, a callback and a list of headers to send. If the output is cached the callback can be used to run small scripts for hit tracking or the like. This is by far the fastest way we've done it (as no processing is done past checking for the cached html, and running the callback if present). The home page is cached for an hour, the rest for a day.
There is no rule with caching as it depends on many factors that are specific to the application. You should never cache on the filesystem though. Your database is far better at storing data on the filesystem and retrieving it. Cache it in memory instead. If your issue is with searching records, you might want to look into using Lucene to index records and search against that. It'll be far more accurate and way faster with large database tables (especially when sorting and full text searches are involved). If you're using Zend Framework, Zend\_Search\_Lucene works great. 
I built a cashing library called [Stash](http://code.google.com/p/mortar/source/browse/trunk/system/thirdparty/Stash) which I use. The front end is simple- it's a class with a handful of functions, such as adding, retrieving and removing things from cache. The backends can be a number of different things- files, sqlite databases (sqlite3 by default, sqlite2 otherwise), or even memory (using APC or xcache, and I"m working on a memcache backend). All of my database access happens though models that represent the data. In the "load" functions it will attempt to retrieve the cache, or reload it if it's empty/expired. The "save" and "delete" functions clear the cache. This way the cache is always fresh- we're manually removing the stale data as it becomes scale. Our caching is also hierarchical. When you call one item, lets say a user's email address, you would call the cache item "models/users/*id*/profile" (where *id* is the specific user's id). If we wanted to clear the data for just the user we clear "models/usesr/*id*", or we can clear all users by clearing "models/users". 
Varnishes all the way to the bottom. As all our data is usually pulled through different web services, we cache each of the services separately in different Varnish servers. We then make purge requests to Varnish when we need it to re-fetch a resource. This can also be implemented through cache channels (not sure if they're in the current trunk / release), which allows you to associate a resource with several tags - and then purge by tag (so you attempt to minimize the impact of a purge). You can throw a varnish in front of your frontend (to cache the HTML), a varnish in front of your storage / service layer (HTTP), and you can also use ESI to cache different parts of the service layer or frontend differently. The cache length is determined by the service itself (by sending expiration information in the response), or by configuration in a particular Varnish instance. The goal is to serve as much content as possible fresh from memory instead of hitting the database (.. or anything else on disk).
I'd like to point out an exception to your rule of filesystem caching. I completely agree that memory is faster and that databases are faster for raw data. Caching full generated pages (even to disk) can be significantly faster than pulling queries and building a page if there is a lot to it (for example generating reports that include tens of thousands of entries in a database). Even these full reports could be cached in a database for quicker access but depending on what you're doing that might be overkill (or you just might not be in the mood for making sacrificing to your DBA at the moment to get tables created for your cached content). I guess an example using APIs from software you don't control is another good example.
^ this. I looked into it because the company I work for is preparing to migrate from .NET to PHP. Lithium sounded great since it was geared toward PHP 5.3 and looked a lot cleaner than CakePHP. We ended up sticking with CakePHP though because of scant documentation and lack of model relations in Lithium. For whatever reason Nate and Gwoo seem to love them some MongoDB, which is fine, but can we get some RDBMS up in here please?
Thanks for pointing that out. I was referring to raw data and neglected to mention that saving, say, a generated HTML file is a huge performance boost. For many web applications, a great caching mechanism would include generating the entire HTML result and storing it in an HTML file. Example: my-site.com/articles/283-my-article-title/index.html You can capture the above with mod_rewrite in Apache. If the page exists, just show that. If the page doesn't exist, let PHP take and route to a the relevant controller which will output the page and save the HTML file at the very end. This technique would work great for many web applications. If you have dynamic data on the page (ie: a username, custom settings, etc), you can load those with an AJAX request on page load. The user gets the content extremely fast and has to wait a few more seconds at most to get the "dynamic" portion of the page.
I only cache data until the script finishes executing. Databases are designed to be hit a lot, in fact some of them cache queries internally to speed up access times. I wouldn't try to cache database information into a file because the database can access information off the disk faster than you can using a file no matter what. If you want to get the best performance out of your database, then read up on optimizing your database, don't try and step around the database, it just defeats the purpose of the database software in the first place.
its fine requesting from a db if its a simple query or low traffic, but when you have queries with lots of joins, and it keeps retrieving the exact same data, there are plenty of reasons to cache.
Of course you could get into a thousand situation specific scenarios. But there isn't anything you should be doing just for "general caching"
Haters gonna hate.
This is a really open ended question, and no one but you can answer adequately. Really. What are you caching? What does it represent? How often do you expect this data to be updated? What kind of business rules are supposed to be in place? Do you want to cache data, or representations of data? Does it really matter if you serve based on stale data? What is your tolerance if it is? What kind of processing will take place on cached data? Only template outputting or more intense crunching? How costly is retrieval in case of cache miss or eviction? Are you trying to spare CPU, disk or network IO? Hopefully, answering some of these questions will give you a better idea of what you need.
Yes, a profiler like xdebug is what's needed here, not a stress tester. How the fuck is siege the top comment?
How much traffic do you get? You feel kohana handles very well?
To stop reinventing the wheel for the millionth time and build something original. Everyone should at some point build a framework so they understand how they work but please just chuck in in your github somewhere or something and don't attempt to compete with the millions of more mature, fully featured and robust solutions that already exist. Unless you are going to be completely revolutionary and deliver us the next step beyond MVC why not invest all that extra time improving your applications?
This isn't true. The "new" page on Reddit for non-logged in users is basically static, and could be equated to a basic: "SELECT * FROM links ORDER BY posted_at DESC LIMIT 10" But that would never let the site stay quick. That kind of stuff **should** be cached. 
We cache our cms using memcached, basically they stay there indefinitely until the page is edited in our cms or memcached is restarted. Rendering a page from memcache is a lot faster than having to go through zend framework and render the page.
OUCH. Recursion make brain stop... Ack...
Nothing, but none of our sites are load intensive as they are internal only ;)
If you're really dead-set on writing a compiler in PHP, take a look at Smarty, which has an interesting FSM to "compile" their template language into PHP code.
Most people who write PHP don't care/understand how PHP works, they think if a page loads fast then the code must be optimized.
Not to mention, putting "SPL" in front of everything is ugly. And putting "SPL" in front of SOME SPL libraries but not others (their current approach) reminds us of the ugliness PHP is known for.
ytmnd was great, I'm sad it got flooded to shit though. the new flash player is awesome however, great for watching the classics perfectly synced.
Every php framework is capable of enterprise level applications, whether it be CakePHP, Zend, Symfony, Kohana, etc (I'm a CakePHP user, but I've used almost all of them). Your business logic is what's important and that should stay the same in whatever framework you choose. There may be helpers/plugins in some that allow you to approach certain problems a different way, but your thought process is what's important. The other thing to keep in mind is this: you're going to have scaling issues with all of them, and it will be rare that the issue is your php. Servers, network, database, frontend, all those things are going to cause speed problems, but it will be extremely rare that it's your php to blame. I only say this because it's often that developers will want to endlessly tweak parts of their php to get almost insignificant gains when you could be tweaking your HTML/CSS/JS and getting incredible speed increases. Oh, and caching is your friend. Cache everything. DB queries, HTML/CSS/JS, etc.
Thanks for the tip, speed isn't our biggest enemy tough, extensibility is.
Same fucking problem, I don't understand what purpose they serve, they must be good. 
It's been my experience in developing desktop applications of my own design for many years, that in the process of design, redesign and refinement, that a framework more or less "naturally" emerges. Just like it "takes money to make money", it takes software to make software. Much of the time spent in developing an application from scratch involves writting little utility programs or adding "backdoor features" into the program that you use to built it with. As time goes on and these little utilities are refined, then *can* become more general-purpose (which should be a conscious goal). Eventually, *voila* you wind up with a "framework". Certainly, you'll get more bang for your buck if you use a framework that has already reached a level of perfection. You're going to need to spend time to learn and understand it, but you'll be way ahead of people like me who love making tools. As an aside, I have always enjoyed making all kinds of tools -- not just software tools. The neat thing about "rolling your own" is that you know it cold. 
And what do you suggest those languages are?
http://php.net/manual/en/language.constants.predefined.php I believe you're looking for the \_\_FILE\_\_ magic constant.
there is also get_included_files, but i'm not sure how you'd use it in the way you appear to need
To clarify: I want to define a function 'F' in one file, that will be called in various other files, and have function 'F' know where it was called from. 
&gt; I would like to have a logging/debugging function defined that would be called from various places, and have it "know" where it is being called from. While \_\_FILE\_\_ can do what you're looking to do, you should also look at [debug_backtrace](http://us.php.net/manual/en/function.debug-backtrace.php), which can pull up the list of function calls that lead to the current point in the script. Generating this is not fast, so you probably don't want to use it as part of a normal non-debug operation.
Alas, \_\_FILE\_\_ and \_\_LINE\_\_ , etc. return the values according to where they appear in the code. They'll work if you pass them to the logging/debugging function, but I was hoping they would "know where they came from". That's not the case.
try this echo __FILE__; that's underscore underscore FILE underscore underscore, no quotes. It gives the filename of the file in which the code is, not the one that's called by the browser. there's also: echo __LINE__; echo __FUNCTION__; echo __CLASS__; echo __METHOD__; They're called "magic constants"... Just in case you get lost. I use \_\_LINE\_\_ a lot when testing and troubleshooting. Oh yea echo dirname(__FILE__); will give the directory name of the file. 
If it's for debugging/logging, I'd use [debug_backtrace](http://php.net/manual/en/function.debug-backtrace.php). It returns a stack trace and the file/line for each method call leading up to the trace (warning: it breaks when you use call\_user\_func). Otherwise you'll need a profiling/debugging PHP extension like Xdebug.
And `__DIR__` in 5.3! 
Ah! That's nice. I should have mentioned that I'm also using FirePHP, and I wanted my logging statements to be sent to the console. For a debugging vs production situation, I invoke the FirePHP class from inside an if/then statement that checks to see if the host is "localhost". If it isn't, I define a null "console" function. That way I can keep the logging calls in the code and not worry about them executing except on localhost. 
These constants aren't magic enough to know where they come from, however. I was hoping I could issue a call such as, `log("Everything is ok here");` And not have to worry about passing the __LINE__ etc. constants. However, they only return the line, file, etc. of *where they are written in the code*. That means that if the "log" function was written like, `function log($msg){ echo __LINE__ . $msg; }` ... would always give the same line number -- the line where it appears in the code, not the line from which it was called. I've just gone ahead and coded the function so that you have to pass these constants to it from the caller. I was just hoping I could save a few keystrokes. Geany is such a nice editor... :) 
Yeah, I didn't know about debug_backtrace, so thank you. Never heard of Xdebug, I'm using FirePHP, which I (come to find out!:) has a trace method itself. 
http://php.net/manual/en/function.array-keys.php
 $query = mysql_query("SELECT * FROM resources"); $columns = mysql_num_fields($query); for($i = 0; $i &lt; $columns; $i++) { $colm[$i]=mysql_field_name($query, $i); } 
Ah, I see what you're saying. Maybe try log("everything is fine on line " . __LINE__); 
Enable Xdebug and get yourself an IDE that supports it. I've been pretty happy with NetBeans, despite its occasional flakiness. It's a whole different game when you can trace through your code without having to add `echo()` statements all over the place. I've been missing that functionality since moving away from VB years ago, and I'm glad to have it again, even if it's not nearly as polished.
actually, php has a function for that. [mysql\_fetch\_field](http://php.net/manual/en/function.mysql-fetch-field.php) No need to make a loop and do complicated stuff like that. MySQL also has a query for that SHOW COLUMNS FROM [your table] That will return all the column names and some info about them. You can also use [mysql\_fetch\_assoc](http://php.net/manual/en/function.mysql-fetch-assoc.php) that will return associative arrays, example usage: $result = mysql_query("SELECT * FROM your_table"); while ($row = mysql_fetch_assoc($result)) { echo $row["first_name"]; echo $row["last_name"]; echo $row["phone_number"]; } 
Don't do this, unless you also need the entirety of the resources table. If you're using mysql and you can set up the appropriate permissions, you can query the COLUMNS table in the INFORMATION_SCHEMA. If not, at least put a limit 1 on the query above so as to limit the amount of information queried. You might also think about why you are doing this, since database schema is usually set at development time, and doesn't change during runtime (unless it does for you, in which case, disregard...). It will be faster and less resource-intensive to simply code the column list into php, or load it from a config once, or something other than repeatedly querying the db itself.
Yes I know I was being a bit of a dick with that first comment lol. You are right about HAML, after using it I'm not sure why'd you want to go use anything else. Well I guess I still use ERB in my .js views but that is not a good example.
I think you mean "wish PHP was more like Ruby" but anyways I have to agree. Ruby is a wickedly cleaner language to write, very concise. Also something about having everything be an object just makes me happy.
Ah, yes. I ended up writing a custom log handler that did the proper backtracing bits before passing things on to FirePHP (and a file on disk, and the database).
You'll need to do debug_backtrace() in your log() function and pull the needed data out of there. The data structure kinda sucks but if I recall correctly I believe you are looking for the second-to-last index in the returned array.
The theoretical cross-platform way to determine the columns of a table is to query against the INFORMATION\_SCHEMA.COLUMNS table. Not all databases implement INFORMATION\_SCHEMA, such as SQLite.
I thought I'd make a novelty account and post answers of how it would be done in the [Zend Framework](http://framework.zend.com/). Because usually there's a great component to do what people want to accomplish. Especially the easy stuff like this one: /* * Instantiate the table object for the "resources" table * It's expected that the database connection is already configured and * made the default via Zend_Db_Table::setDefaultAdapter() * * The call will automatically fetch the table definition from the database * unless it's previously been cached. This can be accomplished by providing * Zend_Db_Table::setDefaultMetadataCache() with an instance of a cache. * See the Zend_Cache section in the manual for more details. */ $table = new Zend_Db_Table('resources'); /* * Easily access the column names */ $columns = $table-&gt;info(Zend_Db_Table::COLS); 
Do it, just drop the introductory text and make sure the code is as verbose as possible.
Also have a look at [dBug](/http://dbug.ospinto.com/). dBug(debug_backtrace()) is your friend! :D
In short, are you trying to do like a printStackTrace() sort of thing?
new dBug(debug_backtrace()) is awesome :)
I have used dBug extensively and I do say it is a nice little app to aid in development. Although I do use xdebug as well for error catching.
This is great? Any tutorials of how to use zends modules/classes without using it's MVC? How would I use the db module/classes in my other projects?
How is this compared to Krumo?
This is pretty neat, but I've never had problems with a quick print_r if I need to check things out.
TYL: the term you're looking for is *database metadata* and most databases make the info available via the [INFORMATION_SCHEMA](http://en.wikipedia.org/wiki/Information_schema).
GPL? Thanks, but no thanks. Krumo is at least LGPL.
This is pretty neat, but I've never had a problem with adding a break point, clicking debug, then inspecting my arrays in the IDE.
lol, but GPL is ok as it's running on the server. LGPL lets you link to a free(dom) library from your closed source if you are distributing an application. If your server code stays on your server you can mix proprietory and GPL and LGPL.
I add a break point, click debug, then inspect the stack. 3 clicks. http://www.nusphere.com/
It's important to note that this only applies to GPLv2 as GPLv3 has this loophole covered. In general - GPL hurts developers, but helps the end-users. LGPL is the best of both worlds. While BSD/MIT helps developers &amp; not necessarily the end users.
Good for arrays, but not helpful for objects at all, since it does not display protected/private properties.
What IDE do you use?
mysql : describe table_name
Zend Framework can easily be used as a component library, where you cherry pick classes as you please. * Add the Zend Framework library to your project. * Add the directory the Zend Framework is in to PHP's include path. * Set up the autoloader to automagically find and load classes when you instantiate them. The only thing to set up, really, is the auto loader. There's a section in [the manual on autoloading](http://framework.zend.com/manual/en/learning.autoloading.html) you may want to go over ("The more you know" and all). Especially the [basic autoloader usage](http://framework.zend.com/manual/en/learning.autoloading.usage.html) section. If you decide to use their autoloader, you can get away with the following: require_once 'Zend/Loader/Autoloader.php'; Zend_Loader_Autoloader::getInstance(); At this point you should be ready to instantiate any Zend Framework class. Now you need your database connection. Here's the [manual for Zend\_Db\_Adapter](http://framework.zend.com/manual/en/zend.db.adapter.html). And a simple use case: $db = Zend_Db::factory('Pdo_Mysql', array( 'host' =&gt; '127.0.0.1', 'username' =&gt; 'webuser', 'password' =&gt; 'xxxxxxxx', 'dbname' =&gt; 'test' )); Using PDO is recommended. Using the mysqli\_\* interface is also supported (barely), but mysql\_\* is not. When working with [Zend\_Db\_Table](http://framework.zend.com/manual/en/zend.db.table.html), you can pass in the db adapter explicitly: $table = new Zend_Db_Table(array('db' =&gt; $db, 'name' =&gt; 'resources')); or configure tables to use your database connection by default with: Zend_Db_Table::setDefaultAdapter($db); Tables can also be used in different ways. You can either instantiate Zend\_Db\_Table directly and pass in which table you want, but the more common usage pattern is to define a table class to represent that table: class My_Resources_Table extends Zend_Db_Table_Abstract { /** * @var string The name of the table */ protected $_name = 'resources'; } Tables understand their own schema. The schema can be defined in the table class, but if it is not, it will query the database for it. It can also be cached, so that on production systems you're not querying the database for the schema every time the table class is instantiated.
Thanks for taking the time to write this. I try Zend with a small project is definitely on my todo list,
I like to use function pre($t) { echo "&lt;pre&gt;"; print_r($t); echo "&lt;/pre&gt;"; } 
Not really. Just wanting to know if there's a way to avoid having to pass the \_\_FILE\_\_ etc. magic constants in the call to the function. Trying to avoid a trace, actually. 
A database of my bugs would overwhelm the Great Cloud. 
so how is your compiler pet project going? any progress?
Could be a great thing for the organizer/to-do list I was wanting to write.
I like the CI to CakePHP idea. It's saved me so much time coding and forces you to write understandable, maintainable code.
Avoid WebCalendar... it's a big, sticky ball of spaghetti code, unless it has been cleaned up significantly in the past couple of years. I can't speak to any others.
Don't worry about it. The disk call to include_once is more costly than storing some extra functions in memory. Stop worrying about micro optimizations like this that just makes the code more difficult to read and debug. It's not worth it, and you won't notice any difference. It's like the same argument of using single quotes over double quotes or using echo like: echo $abc, ' ', $def; Stop overthinking things.
It is trivial. Also, your proposed solution wont work. Instead, perhaps look into [autoloading](http://php.net/manual/en/language.oop5.autoload.php) - it is a feature whereby files will only be loaded as they are needed, as opposed to up front (particularly valuable when some may not be used for a given call).
It is very trivial. So trivial in fact it's the last thing you should be concerned with. Reality is, it's probably the most trivial thing you can think of next to leftnode's example of single vs. doublequotes. You in fact incur a bigger performance hit (and said hit is still extremely trivial, so extremely trivial) loading an external file and using the __call() magic function than you ever would having a class with hundreds of methods. tl;dr your proposed "enhancement" is actually a regression. Focus on **your** performance. Lay out your code in a way that makes it easiest for **you** to maintain because you cost far more than your server does. Maybe split up a class into multiple classes if your lines of code in said class break 1000 or 2000, but not for PHP's performance: yours. It's easier to maintain a smaller, more focused source file. Use xdebug or xhprof to profile your code, look for the real bottlenecks. Don't optimize based off of assumptions, they're usually always wrong, optimize based on fact.
As others have mentioned, stop pre-optimizing. You are just making things more difficult for yourself, for no viable reward. Once you have already built a 500,000 line super CMS, THEN optimize it where needed. Don't try to predict the problems. All that said, what you are looking for is [autoload](http://php.net/manual/en/language.oop5.autoload.php). It will only load class files when they are called.
Well structured code is going to have way more of an impact compared to 40kb of data. Work on optimizing your code, not worrying about minimal amounts of memory. Also, if you don't use a class don't include it. Why are you including 6 classes if you're only using 3?
Ahh I remember those tables back in my cold fusion days.
You're assuming 120kb is wasted, but without a before and after it will remain an assumption. Before you went down this route you would build a script like you normally would, with all the functions in one class. Benchmark it, get a few runs in for some nice averages. Then you would build a script in the style like your asking (dynamically loading functions). Benchmark it, get a few runs in for some nice averages. Then you compare the numbers. If the second option was faster and used less memory, memory usage is no longer an assumption as you have cold hard (well not that hard, statistics and sterile benchmarks mean nothing about the real world) proof. Until then you are just assuming you'll save 120kb or so, but you don't know for sure. Plus the whole language use of "Well **say I have** ..." indicates assumption. *edit:* and when you build those tests you have to be fair. you can't compare solution A to B when B isn't having to load it's secondary files and say "see!", you'd have to compare A and B using no function calls, A and B using random function calls, and A and B using ALL function calls and compare those metrics. Real world will be closer to the second (random) test and worst case scenario (e.g. you have to at least have this capacity) will be the third test. The first test you will pretty much throw out because that indicates nothing of value in the real world.
I'm sorry but this sounds like poorly designed or generic code. Do you have a better example of what you're trying to do, and why it needs to be so generic?
I found that jumping into Kohana/CakePHP right away without any previous MVC experience is very tough for people. It's like jumping right into Java when all you've been writing is procedural C. But I always suggest people check out CI since it is so lightweight, and that eases up the learning curve quite a bit
It's do-able but not with inheritance - you'd want Demo to be a [proxy](http://en.wikipedia.org/wiki/Proxy_pattern) e.g. something like (not tested); class Demo { public function __call($name, $arguments) { include_once ("DemoFunctions.php"); $demoFunctions = new DemoFunctions(); call_user_function_array(array($demoFunctions, $name), $arguments); } } Then just have; class DemoFunctions { public function foo() { echo "foo"; } } ...no inheritance.
I'm not suggesting anything until I know more about what you're trying to accomplish.
I'm assuming you'll be doing this client-side with javascript, so you can just make sure that it becomes "something[#]" (like "something[1]") and you should end up with a tidy little array on the server side on submit.
You'll spend more time keeping track of the code, than the amount of time this new code would save with your whole user base combined.
I couldn't agree more. The path of followed from CI to CakePHP worked well but I've seen people struggle a lot with just CakePHP from just knowledge of PHP without strict MVC.
This is something that bugs me about asking programming-related questions. . . OP asks how he would go about doing a certain thing; rather than just answering whether his assertion is possible and how to do it, 90% of the comments just dismiss the idea outright and turn into a "YOU'RE DOING IT WRONG" lecture. Make your points why you think it's not a good idea, and then just answer the damn question, people.
It is cheaper/easier for you to buy a 4GB stick of ram and chuck it in the server then it is for you to waste a couple hours to save 120kb of ram. Seriously put this in perspective.
I've got some ruby style mixins working in this project: http://github.com/huberry/phuby
You might be interested in this project - I bet there are some tricks in here that you haven't come across before: http://github.com/huberry/phuby - rubyisms in php
Is this "experimenty" enough for you you? http://github.com/huberry/phuby - rubyisms in php
You should try [autoloading](http://php.net/manual/en/language.oop5.autoload.php) instead. If that's too complicated you can start with the [Zend Loader](http://framework.zend.com/manual/en/zend.loader.html) wrapper which simplifies it a bit.
The reason for this is that people tend to ask about a particular implementation detail, instead of actually being concerned with the problem they're trying to solve. If the question is in fact concerned with the implementation, the context around the question make it impossible to answer in a proper way, without making assumptions and some serious guess work. A question like this (and how it is worded) strongly suggest that this is an attempt to solve something which is a) not a problem b) based on the wrong assumptions (120kb memory more costly than proxying a function call for each call? that's going to be hard to defend) c) People questioning the reasoning behind the decision usually does it because they can't see the whole picture - which would also be the issue if someone is trying to debug it.
nusphere - phped
I'd suggest http://alwaysdata.com , PHP 5.3, SSH/MySQL/FTP/IMAP , free for &lt; 10 MB accounts .
Just fork out the whole ~$16/m for a VPS and have all the power!
http://nearlyfreespeech.net/ has 5.3 support, MySQL, etc. and are really really cheap. They have a pay as you go model and I've been recommended to them by many people before.
Wow, this looks exactly like what I need. Thanks :)
http://php.net [just for the upboats ;) ]
[This is all you need](http://www.php.net/manual/en/index.php) Then again, Google if you need something specific.
http://framework.zend.com/
yeah, I've used next(debug_backtrace()); to get the details of the caller before. Ok for debugging/logging.
Just thought I'd post a follow-up to this. I wish I'd heard of this host a lot sooner... as someone who usually just needs hosting for my own projects, their "pay for what you use" system is amazing. They start you off with $0.02 on your account, and with that I've already got my application up and running. Using their price estimator, it looks like it'll only cost me about $12 for a full year of hosting :D
These are my most frequented PHP resources: http://php.net/in_array http://php.net/substr_count http://php.net/array_search
I was previously on nearlyfreespeech. Their pricing was fair but they don't configure apache to gzip compress the pages. And I am fairly certain they don't run php accelerator either. A month back I went with linode with ubuntu lucid and I am really happy. My setup runs nginx, apache, mysql, sphinx. Page loading is snappy as hell.
TotalChoiceHosting.com. I've been using them for years and have a few hundred sites there now. I believe they are running PHP 5.3 across the board now, but just put a note on your order in case they haven't upgraded all of their servers yet. They stay on top of upgrades like this. Edit: $4/mo. or you can just pay $44/yr.
I second this. The documentation is really good and filled with examples. I don't think I have ever looked elsewhere, other than the W3Schools tutorial when I first got started.
Agreed, I learned PHP from that site and almost never reference anywhere else.
It depends - if you're looking for a quick help on a function or two it's great. But if you're looking into - lets say - writing a WebService serwer a specific tutorial is of more use. That said - upvoted.
Someone needs a better IDE ;)
You won't usually be able to get an accelerator on shared hosting because it uses a decent amt of dedicated ram. That makes any shared hosting basically a deal killer for me. I currently happen to have a dedicated server for the server for a game I'm developing but otherwise I'd go with VPS as well. Ninja-edit: I wouldn't get a VPS if it costs more than 80 bucks because you can start to get nice dedicated servers at that point. I have a kick-ass Quad Xeon w/ 4gb of RAM for $108/month.
Yup. Now that I'm at Cake, I'm _still_ having trouble with symfony, though. D'oh!
Upvoted, because I do this too. I will never understand how they managed to switch needle/haystack up like that.
I find the ZF documentation really lacking sometimes, however they have done a through job phpDoc-umenting everything and the [API references](http://framework.zend.com/docs/api) are really useful.
I'm not much into pirating stuff and I'm poor. All the good IDEs that show function prototypes while you type cost too much money. That said, I did win some silly PHP contest and got a free license for Eclipse. But that's like winning a scratch ticket -- if you use it, you're fucked.
It is always an assumption until you have tests to prove it. PHP is not C or Java or C#. There are many things being done in the background that the other languages either do not do or do very differently. Plus, go back and look at the examples in the Proxy Pattern wikipedia article you linked me. Notice how when the discussion turns to memory it's not to save memory by not loading up methods, but instead: &gt; The proxy could interface to anything: a network connection, a **large object in memory**, a **file**, or some **other resource that is expensive or impossible to duplicate**. They say nothing about "to save time or memory loading classes with many methods" but they all discus objects that contain much data. The examples given are a Java and C# set of classes to interact with a high resolution image object without actually hitting the disk to load the full high resolution image until it is displayed (and after displaying it discards the image). This pattern is used in the PHP world, IIRC Doctrine 2.0 uses it in their object graph to reduce memory usage especially when loading a large number of rows from the database. I'm sure I've accidentally used this pattern before when working with large files off the disk. However both examples are parsed and interpreted by their respective VM's and once C# or Java parse and interpret code, the results of definition code (like defining classes, functions, etc) will remain in memory effectively permanently for the VM to re-reference. Look, either run benchmarks and prove your idea is correct (correct meaning it saves memory in my aforementioned random and all test cases) or come to the realization that without benchmarks all talk of memory savings (and other improvements) will remain an academic assumption. edit: The larger point the rest of this thread and myself are TRYING to express to you is that you are chasing a red herring. Build first, then benchmark, research, and refactor. The application needs to work first, performance needs to come second.
[tizag](http://www.tizag.com/phpT/) always seemed to help me out in PHP/MySQL
License for Eclipse? Isn't eclipse like ... free? Take a look at NetBeans - there are many free/open source IDEs out there. That said, noone of them are right for me :/
Plus, PHP requests are very short-lived. You may consume 120kb extra of ram but that gets released back to the system in under a second.
They are very expensive if your site has any remotely significant size or traffic. Great for tiny projects though. 
Welcome to programming, this is how we all learned and so shall the newcomers. If you ask a stupid question expect to receive an answer telling you that your question is stupid, why it is stupid, and usually (if you're lucky) a better question you could ask. But as fiskfisk said there's no context behind this question beyond assumptions and when the stated goal is to improve performance, I cannot in good conscience answer his question when I am convinced an answer will, in fact, NOT improve performance. So I discuss why, given the stated goal, the OP is "doing it wrong" and suggest that this is not an issue one should worry about. So, in effect, telling the OP that this quest they are on is a red herring and "not answering" the question IS answering the question. Albeit in a way that helps him much more than being an irresponsible troll and giving him the gun he can use to go shoot himself in the foot with.
I didn't say to not inform him of better methods to his ultimate goal, but if you look at this thread it turned into a debate about optimization rather than just answering the question. Will I give a loaded gun to a newbie programmer? Absolutely (with a little white slip that says "DO NOT POINT AT SELF" pasted somewhere on the barrel, of course).
Or Netbeans, etc...
Zend Studio for Eclipse I mean, sorry.
You shouldn't be on shared hosting if you have a lot of traffic.
&gt; debate about optimization rather than just answering the question. There's no debate about premature optimization. The overwhelming consensus is it's wrong and doesn't fulfill its intended purpose. The OP is attempting it in a way that will muddy up their codebase something fierce. Even with a warning label I cannot in good conscience provide an answer that enables premature optimization because I know how newbies work, I used to be one. As soon as they have their code snippet they stop reading and move on not really digesting the lessons we are all trying to pass on until said gun backfires and blows up in their face (we can only hope in a non-production environment that tarnishes the OP's reputation). While I'm well aware that my rant will probably have no effect and the OP will still have to make these mistakes their-self, it doesn't mean I can try and it doesn't mean I have to be a party to it.
Eh, I can respect your stance. However, if I come up here asking how to do something complete bass-ackwards, just let me be. Sometimes I want to just try out something completely stupid ;)
Oh, I feel your pain - I've been using Zend 5.5 and it was great. The 7th (or Zend Studio) ... not so much.
I usually just do something like this: $res = mysql_query("describe table"); $columns = mysql_fetch_array($res);
200mb space and 20GB bandwidth for $130 a year isn't a great deal.
If Netbeans and Eclipse don't do it for you, there is always PHPStorm, which is $49.99 until Sept 1 when it goes up to only $99. There is a full fledged trial version as well.
There is a little bit of reason to it. If it's an array, needle is first, if it's a string, haystack is first.
Use Komodo Edit, free and can handle autocompletion and calltips.
You should just declare an __autoload() function to load classes on first use. This way you load the parent classes when they're needed, not the child classes. http://php.net/manual/en/language.oop5.autoload.php
Their use of passing in an array of options to a method is odd. Makes it really hard to figure out what are possible parameters. But using a debugger to step through their code is a joy.
Unfortunately, that does not appear to be a valid autoload benchmark. Its benefits come into play when you have a large framework whose classes may A) be large and B) not necessary for all requests. If you *know* you'll need a class, a straight require is an obvious win. Also, assuming you are doing complex enough things to be worrying about performance like this, your requests are likely already many megabytes large. 120k seems somewhat insignificant for the amount of mindfuck a trick like you are proposing seems to generate.
Yeah i have stuck with the original zend studio as well (non-eclipse) i find it must easier to work with. While it may not have all the bells and whistles that the newer, eclipse based versions have its simple, fast and tailored specifically for PHP.
[http://oreilly.com/catalog/9780596004156](http://oreilly.com/catalog/9780596004156) Best reference book I have ever purchased.
Just curious, in which way are my comments full of shit?
You've got decent specs and a lot of bandwidth... Maybe something to do with video encoding?
Yeah, can't think of anything like that that isn't either very complicated or already has a million websites doing the same thing. I've done some transcoding and such with ffmpeg, but nothing serious.
Porn
Already did a few porn websites, but sold them off ages ago because working with porn gets really old really fast..
Looking into that now.
I just purchased a domain name that I am trying to come up with ideas for... youspotted.us I have some ideas if you want to discuss it...
Where are you hosted?
texas. A friend of mine runs a web development firm, had some rack space and bw available and hooked me up with this deal.
Done. Set bw limits at 70mbits to start with. Server should pop up in tor directories soon, I just named it "Reddit"
// include_once is bad bad bad for performance. // It basically passes through every other included file. // forward static call is PHP5.3+ class Demo { private $includedFuns = false; public function __call($name, $arguments){ if(!$this-&gt;includedFuns){ include("DemoFunctions.php"); $includedFuns = true; echo "Loaded functions&lt;BR&gt;\n"; } echo "Forwarding call: $name&lt;BR&gt;\n"; forward_static_call(array('DemoFunctions', $name), $arguments); } } echo "Syntax Test&lt;br&gt;\n"; $demo = new Demo(); echo "Demo class created.&lt;br&gt;\n"; $demo-&gt;foo('testArg1','testArg2'); ---- class DemoFunctions extends Demo { public function foo($args) { // this doesnt really have to be static echo "DemoFunctions foo called with args dumped below:&lt;BR&gt;\n"; var_dump($args); echo "&lt;BR&gt;\n"; } } 
Thanks, nice thing you have done there.
Decent specs, horrible I/O.
How very strange. An actual answer, though intentionally naive but with no little merit, has been downvoted to oblivion. I am starting to suspect this subreddit is full of douchebags.
Quick way to get your server seized by law enforcement.
I am confused at the down votes here really, because essentially you are right - PHP itself *is* a templating engine. Personally I am not so sure what is so attractive about these alternative engines in PHP. For a good reference on why I think this, please see [this article](http://www.bigsmoke.us/php-templates/smarter-sans-smarty). I can only surmise that it is relative newbies who *truly* feel templating engines like smarty are a good idea. The rest of the people must be using it out of necessity (job requirements, designers that just simply won't do anything else, etc).
I used to be just like you, worrying about stuff like this. I used to cite these same benchmarks. What changed everything was noticing how small of a percentage of time is actually spent in these areas compared to data access. It doesn't matter if autoloading is 46% less efficient, because database access is going to be taking up probably 95% of your request time. It's not like you get 46% more requests per second using straight requires. Stop trying to optimize things like this. It's pointless. People smarter than you and me -- authors of major frameworks -- do not do this. 
I will remember this. Thank you.
Well if that didn't work, there's always porn.
[StackOverflow](http://www.stackoverflow.com)
So what you really mean is: [This is all you need](http://google.com)
This is really good to know. Thank you!
They don't have very good symphony docs though...
really? Edit: I did some googling and didn't find much about this, but I can see this being a risk if someone goes and downloads illegal material through my server..
I've consistently served 1gbit on a server like this, using lighttpd and mod_memcache. 1gb of the most accessed files in memory and io is not a bottleneck in many cases.
pm me with your ideas, we might be able to work something out
They aren't. I was referring to the link in ryeguy's response to you. I agree 100% with your comment :)
http://php.net/manual/en/book.dom.php
I publish here so I'm biased, but http://net.tutsplus.com/ has web development articles all the time.
TIL: Linking to your website in Reddit is a security risk.
Random PHP Nugget I feel like sharing: If you're using Imagick (PHP's ImageMagick extension) to generate giant images (50MP+), something ImageMagick is quite good at, stop. Instead, read about the MVG format, which is effectively a sequence of ImageMagickDraw commands in text form. Create the text file by streaming it to disk as you go, then feed it to ImageMagick's convert tool out of process. You'll save yourself a ton of headaches. Until I figured that out, my php processes would simply jump to 4GB then fail horribly. 
What debugger do you use? I've been thinking about it since I have eclipse but never really got anywhere. I like passing values as an array as long as somewhere there is a reference of what adapters need what etc.
[Best programming resource for any language:](http://en.wikipedia.org/wiki/Design_pattern_\(computer_science\) ) Edit: formatting 
Dreamhost is still running 5.2.14 as their base install, but [they allow you to install your own PHP build](http://wiki.dreamhost.com/Installing_PHP5) if you wish to do so. They wont provide support for it, and they tell you that if it breaks it's your own responsibility to fix it, but they do allow it as an option.
It's not part of PHP standard yet, but there is an option for APC that explains itself: apc.lazy_functions If ever adopted mainstream, it would work in tandem with the APC op-cache to load only parts of a class into resident needed to execute a complete request. That is your best bet, any alternative optimization would most likely incur a high performance hit because you're trying to change the nature of the language from inside of itself.
you're so nice I bet you could find the kindness in hitler's heart
This works. You should check out the project from my other comment. I've discovered a bunch of interesting hacks like this while working on it. &gt; Demo.php function autoload($class) { require_once "$class.php"; } spl_autoload_register('autoload'); class Demo { public $name = 'Bar'; function &amp;__call($method, $arguments) { $variables = array(); foreach ($arguments as $index =&gt; $argument) $variables[] = '$arguments['.$index.']'; # calling it this way sets the "$this" reference correctly eval('$result = &amp;DemoFunctions::'.$method.'('.implode(', ', $variables).');'); return $result; } } $demo = new Demo; echo $demo-&gt;foo(); &gt; DemoFunctions.php class DemoFunctions { function foo() { return $this-&gt;name; } }
Setup a Magento and watch your server weep!
&gt; But in most cases you don’t want your mobile visitors to stop from returning because they went through their data plan to quickly because of all the extra ‘bulk’ on your site. They just want your content. Normal-sized-browser users just want the content too. That's why there are a million different add-ons for removing distracting crap from pages.
to = too
`[sic]`
=)
Do the PHP community a favour and stop putting out crap.
[get_browser()](http://php.net/manual/en/function.get-browser.php) ?
&gt; to = too = false
what
well if we are in /r/php i think the answer is actually true
Nah, it'd be an invalid expression resulting in a parse error.
Only problem with the original code is it's going to try to include and instantiate DemoFunctions on ever function call. harryf probably meant for it to be like this: class Demo { private $_demoFunctions; public function __call($method, $args) { if(!$this-&gt;_demoFunctions) { include 'DemoFunctions.php'; $this-&gt;_demoFunctions = new DemoFunctions(); } call_user_func(array($this-&gt;_demoFunctions, $method), $args); } } And that's actually a cool way to dynamically add functions to a class, but remember the __call magic method is much slower than a real method, and your IDE or PHPXref won't be able to follow through to the real method and provide documentation. [Autoloading](http://www.php.net/manual/en/language.oop5.autoload.php) might still be a better fit and it's easy enough: function __autoload($className) { if('Demo' == $className) include 'Demo.php'; } 
WURFL supercedes browscap because it's specialized for cellphones reporting on additional features like what DRM technologies the phone supports, viewer size area, and if the browser is WAP or a true HTML browser. For some older CDMA JavaME devices its possible to accidentally crash these phones if you send the wrong response back. Fortunately their mostly solid state, so no damage is done, but you might lose a customer if trying to sell ringtones.
This comment needs a flash intro
&gt; What the hell is it? Here's a rough explanation as to what I think it is and can be You know how we can comment on submitted content here? We can also reply to those comments, and so on. What I did is make those comments and all replies appear on the front page to become the start of its own thread. If (big IF) this ever becomes popular, the data (all the chains of replies over time) in it could be very useful. For example: Imagine from the very first post "Hello World" stems a bunch of gibberish as people try and figure out what this is. From there it splits into people talking about Reddit and other random topics (Programming, Coolness of Fluin :P, etc.). Over time a chain of replies leads to a whole convo on basketball and eventually about the 2012 presidential election some years later. A person can then use that data to see and try to understand connections between topics and how they affect one another. From this example... who would've thought basketball had a big impact/connection with politics (this example is fake btw lol,but who knows if that connection exists). I hope some of what I wrote makes some sense :P and I'm still trying to figure out what it is too lol **Plans for the near future (IF there's an interest in this... no point in developing if I'm the only user lol)** * Interactive visualization of the chain of replies * Search * Live updates/chatter * Some other small things
Can't spot the error right-away, so.. - Try a pastebin (google'll turn some up) for this much code, they don't mess up the formatting and have syntax-highlighting. - instead of **eval**(), try echoing your string and see if you can spot errors in the result (you **do** have quotes around the string in the eval, right?). - finally but most importantly: don't use eval. There's bound to be a better way to do what you want. ##php on irc.freenode.net or maybe a channel for whatever framework/solution you're using (Wordpress?) might have suggestions. Edit: eval() instead of echo at bullet 2 (fail...)
Break your eval strings up onto multiple lines with regular string concatenation. Keep breaking until you find the one line that has the error message and it jumps out at you what it is.
It's actually used by a wordpress plugin. I use it to populate a select input (which is a custom field for a custom post type) with values of another post type. Essentially I'm trying to create a relationship between 2 custom post types.
i tried eval-ing return "test"; ... and same error. Might it depend on the hosting settings?
Hm. I don't know; I don't use eval a lot :( Try stackoverflow?
At my work we are using an wordpress blog which we have integrated into a website. I think we just made a modified wordpress theme that includes the header and footer of our site theme. You could also go the other direction, and create a stripped down wordpress theme, without a header and footer, and just include wordpress right into on of your pages.
Second this, also you can charge your client every time you have to update wordpress which is like every week. Otherwise they will get some nasty javascript payload inserted into their site.
You're definitely using single quotes around the escaped eval'd code right?
trac?
divorce yourself from having to find one that is PHP based. ive used a couple various issue trackers over the years and finally found [redmine](http://www.redmine.org/). it is by far the best, most easy to use tracker ever, IMHO.
T-ENCAPSED-AND-WHITESPACE is a [parser token](http://php.net/manual/en/tokens.php) that refers to the 'constant part of a string with variables', meaning the part of the string that's not a variable. T-STRING refers to a 'string array index inside [of a] string'. A quick example of how you might generate this error: $foo = "$bar[ "; You should check your code very carefully and look for something like this. Failing that, you might look into the possibility that your IDE or text editor is using some sort of strange encoding that's inserting invalid characters behind the scenes. Having said that, I think you should think about changing your approach and not use eval() which is bad for a number of reasons, foremost being its potential dangers.
We use [Mantis](http://www.mantisbt.org/) for Radio Reddit. It works great and is easy to use, but full of features. 
I use trac at work, and while it is a fairly nice tracker, it is written in Python, which is not what I am looking for.
I would prefer to use PHP, as it is intended to be a local tracker, and I already have a WAMP server on my local machine. Id rather not have to set up anything else and complicate my life, since I am only doing PHP development anyway.
Thanks for your input, Mantis does look promising.
Good luck adapting to Symfony 2 ;)
You could check out [mtrack](http://bitbucket.org/wez/mtrack/wiki/Home).
Looks interesting, thanks!
What I'm looking at doing is running redmine on a live distro in a virtual machine.
I know wordpress has a post fetching loop built in. You would have to play with the backend, but you can pretty much build whatever you want around that loop for the page. Just place your header and other parts into the blog and you should be good to go. You might have to fight some security features to get it up and running with the backend and some pages being different, but its more than do-able.
If you do really need eval ( I doubt it) just call a single function with the rest of your code.
You will have to face the [horrible UI](http://www.mantisbt.org/demo/view.php?id=8054) though... I did the same search a year or so ago, and didn't find a decent PHP issue tracker. Not what you're looking for (Python), but I found [Roundup](http://roundup.sourceforge.net/) to be the best. It comes with its own webserver so if you're running locally you can just start the process and let it do its thing.
I have no complaints with flyspray
You don't have to setup anything with http://www.turnkeylinux.org/ - just download it and run it in VM.
I second going with linode. Been using them (their 768 package) for about 5 months now and everything has worked flawlessly. They even bumped up everyones RAM for free back on their birthday =D. Their base package will get you a VPS with your linux distro(s) of choice and 512MB of RAM for $19.95/month. Definitely worth it. However, just make sure you know your way around linux, or are willing to learn since its not managed at all by them.
They all are good. But maybe [The Chaw](http://thechaw.com/) will help you. Also there is [Collabtive](http://collabtive.o-dyn.de/)
It would be nice if they told you the system requirements before you download the trial version for Windows. I should have deduced by the corporate look of the site that this was a Windows product. 
Don't use eval. Problem solved.
Double Choco Latte (DCL)
I checked earlier today and could not find a node named Reddit. Did you remove it?
Using eval is almost as bad as leaving register_globals turned on. You may want to consider asking the plugin author to change it or rewrite the code yourself. Where does this eval'd string originate? In the database, I suspect...which is an even larger invitation for disaster. If it doesnt originate in the DB, then that's just turning bad design into a complete cluster. I'm curious, which plugin is this?
Clean and powerful. We love it. We've used Lighthouse and Codespaces in the past. Lighthouse is great, but a bit pricey. Codespaces is buggy as hell. We set up Redmine on our Hostgator account. Very simple to set up.
Try [indefero](http://www.indefero.net/) it's multi project and looks like google code
this is the one I use...its decent, but not great http://bluescripts.net/apps/bluebug/
I thought you were trolling for a second, but [I looked it up](http://www.google.com/#hl=en&amp;source=hp&amp;q=%22Double+Chocco+Latte%22&amp;aq=f&amp;aqi=m1&amp;aql=&amp;oq=&amp;gs_rfai=&amp;pbx=1&amp;fp=6133cf3ad706bccf), and it really is a PHP issue tracker. What a strange name! Thanks for the suggestion, I will have a look.
Thanks for your input. Not sure about Collabtive, as I have no need for it to be "in the could", plus I will likely be the only one using it.
Am I the only one thinking that this is pathetic?
Ive got ubuntu installed on mine simply because Im lazy lol. Right now the main purpose my linode servers is my personal blog/portfolio and a very convenient dev environment. Updating Ubuntu is pretty easy, but if you're concerned about security updates and rock solid stability, I would suggest running Debian. With debian when you update packages or go for a full upgrade, everything is (for the most part) guaranteed to upgrade cleanly and not break (this is most certainly NOT the case with Ubuntu between versions). So, if this is a production environment, I would say take the time to set up Debian (takes a little more than ubuntu since not everything is pre-installed). But if its just a dev environment or something to just mess around on and youre lazy, go with Ubuntu. Hopefully thats a decent answer for ya.
Minor bonus: if you're not using any special IDE, I'd recommend installing Notepad ++, installing its Language Help plugin, then downloading PHP's full manual in CHM format off the PHP website. This will let you highlight a PHP function and jump straight to the PHP manual help page - essential for shitty internet connections. 
it was meant to be
[A Small Orange](http://www.asmallorange.com) is a nice host, and is run by a fellow redditor: [timdorr](http://www.reddit.com/user/timdorr).
$test = '$option_list = ""; $retrieved_posts = get_posts(array(\'post_type\' =&gt; \'domains\',\'numberposts\' =&gt; -1,\'post_status\' =&gt; null,\'post_parent\' =&gt; null)); if ($retrieved_posts) { foreach ($retrieved_posts as $post) { $id = $post-&gt;ID; $option_array[$id] = $post-&gt;post_title; } } else { $option_array[0] = \'No domains exist\'; } foreach ( $option_array as $value =&gt; $option ) { $option_list .= $value.\'|\'.$option.\' \'; } return $option_list;'; $e = eval($test); var_dump($e); Included code works on my wordpress install. Using eval on code you have stored in the DB for easy injection is fine.
have a look at [OpenAtrium](http://openatrium.com/). They have a simple case tracker that's easy to use.
Try with lighttpd or nginx. How are the benchmarks doing on a static file?
First step in optimization is finding exactly where or what is the bottleneck.
Very this. Profile the crap out of your code. Look at [xdebug](http://www.xdebug.org/) and [xhprof](http://pecl.php.net/package/xhprof). 1.6 seconds is utterly absurd, even for ZF. &gt; I've also recently added APC to the server to speed things up, before they were using eval and I told them we might as well not use APC because it doesn't work with eval. You'd better have a very good excuse for using eval in production code to the extent that you believe that it might impact performance. Eval is evil, but to get it to impact performance, you'd have to be putting together entire pages of content using it.
I love it because it's very customizable.
How complex of a page are we talking here?
Actually, my usual shared hosting is with ASO (lifetime plan!), but they're the ones who don't support 5.3.
ummm. . .0.01145 seconds on my current app. . it's running through over 40 different schemas too Definitely sounds like an application design issue (especially since you mentioned eval)
in reality most CMS systems have exploits. wordpress just has tens of thousands of people to find, report and fix those so thats why we get updates so often. i would rather get 100 security updates separately than have to wait a month for them to bundle them together.
It's possible w/ most CMS's but its a pain in the ass. I wrote my own CMS a while back for this sole purpose. I probably have the code around here but I haven't updated it in a while &amp; I'm probably going back to wordpress soon when I start another site because I know how to work around it now &amp; there's an Android app. I should just make my own Android app &amp; update my CMS but I don't want to waste my time when I can make a wordpress theme to do everything I want.
I'd recommend you learn programming first then jump into a framework.
Learn to program, learn the language, then pick up a framework if you want to. 
Understand the basics of PHP and build something like a blog or a very simple wiki using plain PHP. Learn best practices like clean and well-documented code, separating business logic from the display logic (eg: code that deals with the database should be completely separated from code that deals with outputting HTML), and sanitizing and validating all input and output. You'll be at a good level when you can make a good guess about the details of how various websites work. Keep asking yourself, "how did they implement this?" with various features (eg: how would you implement the orangered envelope as well as showing all unread replies?). Once you're comfortable with that, start looking into various frameworks. The idea is that you should be able to guess *how* a framework does things to use it most effectively. When an issue comes up, you'll be comfortable enough with the language to figure out what's wrong. Also, frameworks change and new ones come up, and knowing the language well will let you adapt quickly.
Came here to write this. Also, [Eclipse can connect to redmine](http://www.redmine.org/wiki/redmine/HowTo_Mylyn) to use it as a task repository, so if you use Eclipse as your IDE, it's a double win!
I am fairly familiar with Linux so that won't be a problem. What I liked about them was StackScripts that will automatically setup things for you, like installation of lamp stack. My node was good to go in 30 minutes.
Yeah before they weren't even doing profiling and didn't even seem to believe that the problem could be in the code. Now they want to learn how to profile their code and we're using Zend Studio, so I'll show them how to use the zend profiler to examine our code.
Static files are served quite fast, especially the ones that use memcache and basically bypass Zend Framework altogether.
Basically its a page that has drop down boxes for different product options and then it calculates the price based on this options, they call this feature the calculator. But pretty much its supposed to be a CMS that has a template, that has different sections and a content page. They store the contents on a mysql database and before they were using temporary files to execute the code using include, then they switched to eval() and then I told them that this was bad and we use a permanent file to cache the code in the database. They seem to think that the servers could be the cause, we're using Fedora 13, PHP 5.2, Apache 2 and Mysql 5.1
Using a framework requires a certain level of proficiency with the language, so you'll need to learn the basics first. After you learn how the language works, you should probably write an app or two with your own code, and try to whip up your own framework in the process. To do that, you'll need to learn the basics of what frameworks do, how their elements interact, what are the common file structures and so forth. All this should give you enough knowledge and experience to decide which framework to use, or whether to continue using your own code.
Performance depends on the amount of data and the complexity of processing. Unless you deal with vast amounts of data, or need to perform very intensive computation, your performance issues are most likely to be the result of bad design. A simple page that reads a few database rows and does a few eval()'s should certainly not take 1.6s to generate.
Wordpress sucks.
There are millions of people that disagree with you.
I wish I could upvote you more. Perfect answer, if you ask me.
It is horrible. The code is unreadable, updates usually break everything and there is no separation of php and html. For end-users it is "ooh! shiny!", but for developer it is hell.
ha!ha!
I am a web developer that has dealt with integrating with wordpress on several occasions over the past three years. The code is not unreadable. Its not perfect, but it is far more readable than 90% of the code I come into contact with on a daily basis. I have yet to have an update break anything at all. I have probably done an automated wordpress update at least 10 times, on installs with many addons/modifications, some custom. There is plenty of separation of PHP and HTML, in fact you are pretty much blowing wind out your ass on this one. They use PHP in their templates, as PHP is in fact a templating language, and there is little need to use anything else besides PHP. Now, they do make plenty of function calls in the templates, which I dont agree with, and there is some chunks of PHP code, but that is a far cry from "*no* separation", as you would have people believe. The templates could be improved, for sure, but there is plenty of separation going on there. Wordpress is a solid, functional and versatile system, that fits many peoples needs, and if it doesn't, it can usually be bent to fit them. While it has its downfalls, I regard it as one of the finer pieces of PHP software available.
I totally agree with you, wordpress is abominationware, but what viable alternative is there?
maybe you could help reddit with hosting, they always seem to be running out of server power, although it has been pretty good lately.
Not sure if it's your thing, but I'm working on a Lisp to PHP compiler at http://github.com/scriptor/pharen. It's at a good stage and I'm planning on another full public release within the next few days. Tech-wise, it takes a dialect of lisp and compiles it to PHP code. It supports features like lexical scope, lispy macros, tail recursion elimination, and more. It uses a custom parser as well.
I find that quite unlikely. Aren't they hosted in the amazon cloud? service thingie?
I got nervous that I would get into trouble so I removed it
Do take a good, long look at xhprof and xdebug in addition to Zend's commercial offering. In particular, xhprof was designed (by Facebook) to run on production systems without incurring a major performance penalty. You might discover different performance characteristics on production than on the dev environment.
&gt; we're using Fedora 13 Why are you using a short-lifecycle operating system for a production system? This won't impact performance any, but you really should be using a stable environment. &gt; They store the contents on a mysql database and before they were using temporary files to execute the code using include, then they switched to eval() and then I told them that this was bad and we use a permanent file to cache the code in the database. Wait, wait, wait. Are you telling us that code is being created on the fly and then evaluated? Nobody that knows what they're doing would ever come up with that solution. Ever. &gt; Mysql 5.1 Has every query been run through EXPLAIN? Improper indexes can be a gigantic bottleneck.
[Amazon EC2](http://aws.amazon.com/ec2), and yes they are...
start your own cloud then.
&gt; Has every query been run through EXPLAIN? Improper indexes can be a gigantic bottleneck. This was my first guess as well. 90% of the time whenever one of our pages is taking too long to load, it's because of slow queries.
&gt;guy I went to college with being teased about running Debian on his laptop; they said he was a masochist. haha...I think the operating system you might be thinking of is Gentoo since pretty much EVERYTHING has to be compiled from source and recompiled on updates. &gt;Well, I was actually looking for something a little more security-specific I guess what types of security related tips are you looking for? System security, security in web apps (eg. MySQL/database security)?. Generally if you have SSH installed with a password that isnt easy to guess/run a dictionary attack on youre pretty much set. Typically (with debian atleast) if you keep everything up to date (PHP, MySQL, etc) you should be good.
Try CodeIgniter
Any resource is good.
Good book for starters: Head First PHP &amp; MySQL - Beighley &amp; Morrison
Thanks for everyones help, I guess we'll start by profiling the code and then look into the database to see about finding improper indexes. :) We're planning to go live on Friday, I guess it will be a disaster story or a success story depending on how bad we're gonna get raped.
can anyone recomment a software project planner app, not just a bug tracker? i.e. something that would help me document my plans, ideas, plan the tasks, delegate, track progress, etc?
&gt; finer pieces of PHP software available. ಠ_ಠ
I'd say "Eventually, voila you wind up with a "framework"" is the best response. Even if you start from scratch, you'll find that the end product is a framework of your own devising. User authentication handled here, webpages handled there, DB calls handled this way, and file uploads handled that way. Compartmentalization is only natural. To add, pre-fabbed frameworks likely require the same amount of cost over plain in terms of time and money reserved for training and patchwork. And, they offer job-security as your devs will find the universal framework just doesn't happen to be exactly compatible with your server settup. But at least you get to blame someone else when your server gets turned into a zombie as the framework of choice turns out to be a block of swiss cheese full of security holes.
PHP devs have decent timing. With a large user base on a language devoted to HTML scripting, they come out with CLI capabilities. Suddenly, basic users are able to run advanced CLI scripts to manage server automation. Suddenly, users realize they're able to do just about any PC automation task using a scripting language tonnes of folks are already familiar with. Market thus expands. But this momentum stopped at .Net, and PHP devs are running out of time to catch this window of opportunity. Hell, I had to make my own PHP/.Net wrapper, which starts to make VB a better simple language to turn to. Will PHP devs keep PHP competitive for space on our command lines and our internets? That is the question. Also, on "PHP has served it's purpose", I'd argue any MS product has reached its sell-by date a generation ago. Yet it's still alive and kicking because people still find a use for it. A language is dead only when no one finds any purpose in keeping it alive. By the pragmatic, preservationist, and self-serving nature of programming in practice and philosophy, you're not likely to find any language left for dead as long as magnetism holds strong on those fast-spinning, circular-disk thingamajigs and some arcane computation device can still be powered up to read it.
Why are you trolling against PHP in /r/php?
Who's trolling. Me, or you praising the horrible WP code?
Stop downloading bullshit and write it yourself. What the fuck.
Slicehost is $20/month. Just get that. You can set up PHP/Apache/MySQL in like 30 minutes. http://articles.slicehost.com/debian-lenny
I really don't think this is the subreddit for you. Your like a catholic in /r/Atheist.
Yeah, right. As if I'd [venerate such code](http://ideone.com/iD5OI). True quality, what can I say. You're exactly like the other 99% cocky WP developers.
How much time do you have to learn before you have to start producing stuff that will get you paid?
The only person being cocky here is you. Your the only one bashing other people. Go do something useful.
Kudos on creating something original. Most people don't get past the idea part. That being said, I have no freaking idea what it is and why it's useful. No idea at all.
&gt; Stop worrying about HTML, JavaScript, AJAX, and Comet. I'm not worried about HTML, CSS or JavaScript. I like it. I would hope people would understand this by now and stop rewriting ASP.NET in PHP.
I heard of it in a web development podcast a few months ago. I liked what they had to say. Then I saw their website and my opinion fell to the inner circle of hell. I came to the conclusion that they spent the majority of their time talking shit and not writing a framework. The JavaScript animations on the homepage and a completely boneheaded approach to organizing their website didn't help either.
&gt; in fact you are pretty much blowing wind out your ass on this one Well you blew it again. As if it where my manner to reply in such a way to other peoples comments. Especially when they have a point. &gt; They use PHP in their templates, as PHP is in fact a templating language, and there is little need to use anything else besides PHP That's a fine contradiction right there. What else could they use if not PHP? You are oversimplifying what PHP is nowadays. While it started out as a template language, as when, 15 years ago, you are out of your league in this subreddit. &gt; The templates could be improved, for sure, but there is plenty of separation going on there. As almost any file has something in it that produces output, I wouldn't call that separation. The can't even be consistent on their code. The includes sometimes use the relative path, and other times the absolute path. &gt; Wordpress is a solid, functional and versatile system, that fits many peoples needs, and if it doesn't, it can usually be **bent to fit** them. Anything can be bent to fit some specification, but that doesn't mean it should be. There is nothing special with wordpress here. A little decency and less fanboism wouldn't hurt you. That's all I had to say.
You could not troll any harder if you tried.
The code is unreadable, if you compare it to anything decent. I'm talking about using global variables which almost always (and most definitely in WP's case) indicate poor code design. I'm talking about PHP functions that return pure HTML. I'm talking about breaking virtually all common coding conventions. The problem with WP is exactly this &gt; Wordpress is a solid, functional and versatile system, that fits many peoples needs, and if it doesn't, it can usually be bent to fit them. It tries to be everything so hard, it can't even do the basics right. And if you haven't ever had an upgrade break anything, obviously you haven't upgraded from 1.x to 2.x. I stand by my words - wordpress is a horrible, horrible engine to work with. I'd rather code a new blog engine from scratch, than "slightly tweak this plugin" in WP. To each his own, of course, and if you're well versed in WP and feel good doing what you're doing, then good for you and I'm genuinely impressed, but remember that WP in no way encourages good code design. In fact, it promotes sloppy coding practices and in the long run you're just shooting your own leg, if you plan on doing anything with coding in your life. edit: formatting
Depends on your needs. For deploying blogs you'll probably want to develop your own blog engine, if you anticipate future upgrades. Or you can find somebody in need of money and pretty ok with WP so you can subcontract work to them ;)
I personally use [Fossil](http://www.fossil-scm.org/index.html/doc/tip/www/index.wiki) version control which has a built-in bug-tracker, ticketing system, timeline and a wiki. For simple local use it is quite adequate, especially as most of the features can be accessed from a local web interface.
the easiest way I know to achieve this is jQuery and jQuery.address plugin which helps you reset the page address without reloading.
I don't get it.
first, turn notices and warnings on, and display them: ini_set('error_reporting', E_ALL); ini_set('display_errors', true); then dump your eval into a file and include it instead of using eval(): $code = 'return test;'; $tmpFile = tempnam(sys_get_temp_dir()); $ret = file_put_contents($tmpFile, $code); include $tmpFile;
If WP is quality code, 90 y/o grandma amputee is a quality hooker.
I think you're mistaking 'trolling' for something else here. Just like you are mistaking WP for something that doesn't reek of dead fish.
Yup.
I don't like the idea of updating all websites when Wordpress releases a new version and changes part of the bullshit. So I use a plugin which is regularly updated to use Wordpress's new bullshit. 
I am not even going to address most of that, because this is just becoming a trolling festival. However, I would like to respond to this: &gt; In fact, it promotes sloppy coding practices and in the long run you're just shooting your own leg, if you plan on doing anything with coding in your life. As someone who has done web development both personally and professionally for many years, as someone who goes out of his way to make clear, clean and structured code, and as someone who as had to work with many people who code with no regard to anyone else who will have to read it later, I must say you are wrong. Just because code may be "Sloppy", is not a good reason to not use it. If it fits the bill better than anything else, then by all means go for it. You are not going to suddenly become a worse programmer by digging into the internals of Wordpress, in fact, you will only stand to become a better programmer. If you ever plan on working in web development professionally, you are going to run into systems far scarier than Wordpress will ever be, possibly on a daily basis. Legacy code, patchy integrations, features that were slapped on overnight and never revised, etc. That is the reality of it. If you only touch systems with spotless code, you will never have the skills to deal with working in a real web development environment. All that said, yes, when you program a new system you should lay out some standards and follow best practices. But there is always going to be shitty code out there, and professional web developers will always have to deal with it. &gt; I'd rather code a new blog engine from scratch, than "slightly tweak this plugin" in WP. "So I want to spend 30x the time and money doing it this way to produce an undertested product, because I am squeamish about touching some ugly code". Good luck pitching that to a boss.
How convenient that you didn't respond to the parts that make your WP justifications invalid.
Troll: "In Internet slang, a troll is someone who posts inflammatory, extraneous, or off-topic messages in an online community, such as an online discussion forum, chat room, or blog, with the primary intent of provoking other users into a desired emotional response or of otherwise disrupting normal on-topic discussion." I just don't think that you've seen good, structured code, kind sir.
&gt; I just don't think that you've seen good, structured code, kind sir. If you even took the time to read my arguments, it would be blatantly obvious to you that I am not arguing that Wordpress is "good structured code". By your own definition, you just trolled me by posting an inflammatory message meant to provoke me, without properly reading the thread.
How convenient that I didn't respond to your obvious attempts at trolling.
I am sorry, but I did read everything. As far as I can see, it's impossible to make a point here, because there is a misunderstanding between both parties. I suggest we lay down our weapons and go our separate ways.
I keep meaning to make the framework i have designed available for use. Its modelled heavily off of the Zend framework except it rips out all the stuff that you dont need. Its about as bare bones as a MVC style framework as it gets. And has scaled well for a few applications in the top 10,000 in alexa.
You are likely correct, and provide wise advice. It is time for me to leave this topic alone.
I am hosting the website for the creator (he's Indonesian, so please overlook his English) of the Monas encoder. It's currently only compatible with PHP 4 and PHP 5.2, but works extremely well. It saves the PHP files as compiled bytecode, giving them both a speed boost and making the code harder to disassemble. He has a Linux and Windows version of the extension, and I can confirm that it works in 64-bit environments as well. Please donate if you find it useful, I'm sure he could use any extra revenue, and hopefully encourage him to put out an upgrade for PHP 5.3 ;) I may submit a few utilities I wrote to help manage encoding/decoding as well. Hope it helps!
&gt; Developer, they can fully protect their intellectual property by distributing their work in bytecode format ... &gt; Provide machine identification function (like reading ethernet MAC Address, harddisk serial number, etc) so user can easily crafted their custom restriction/licensing scheme for their product. Stop that.
What is the benefit of this over the various commercial tools available? (Zend Guard, for example)
PHP 5.3 support would probably help increase adoption. I was excited about testing this and possibly deploying it until I read that it only supports up to 5.2. With all the alternatives out there, if this performs and runs as it potentially appears to do, this could become huge in the PHP world. Looking forward to updates, and possibly contributing.
Pom
I am discussing possibly making it open source so that 5.3 support could be implemented regardless of his workload. I can attest that it works as advertised and with a noticeable speed increase to boot. You can also match it with a cache system like APC for more boosts.
I don't think either of those features are actually in the program at this point, and of course you can decide whether to use them or not. However, what options do PHP developers have to earn a living with their skills if they can't distribute without their work being ripped off wholesale? I'm all for open source (and have several open source projects of my own) but the reality is that sometimes you need to pay the bills without worrying that 2 years of work will get blatantly stolen.
The price tag is $0. It also compiles the scripts, giving them a speed boost that can be coupled with cache systems.
&gt; Requiring any javascript for a site to run is lunacy. In this day and age? C'mon. 
That is very true, but also think about the other side of it, without being able to see the source you are running on your server you could be more vulnerable to malicious or dodgy code. But then again that could open a new market for bytecode "virus scanning" software...
The code will not have any more privileges than regular PHP code you run on your server, so any exploits encoded with this will be just as effective running as plain PHP.
&gt;However, what options do PHP developers have to earn a living with their skills if they can't distribute without their work being ripped off wholesale? If I ever figure out the answer to this question without having to invest ungodly sums into "encoders" that can't be decompiled, I'll be able to retire, so upvote for asking. The closest I came was from 2002-2005, when a business partner and I sold memberships to a site where you could download everything from simple scripts to complete apps. The membership model worked a hell of a lot better than the HotScripts shareware model, that's for damned sure. (There were different membership levels at different price points, of course.) It paid my bills for a couple of years, took a few of us on a two-week trip to Hawaii, and then suddenly all of my work started showing up for free on pirate sites in the Netherlands. So I got a real job as a PHP developer at a real company.
Well, this program is free, and includes both the encoder and the decoder. Try it out, see if it helps you, tip the developer (not me, I swear) if it does. I just talked to him a bit ago and he said he's working on a version for 5.3 as well.
I'll try to check it out if I get some free time, I do appreciate the post and I've saved the link!
s/PHP developers/graphic designers/ They have the exact same set of problems, and the answer's pretty much the same there as it is for us: contract and copyright law, or getting (as it was put elsethread) a "real job". Like pretty much all DRM, all this does is get in the way of actual, paying customers.
You're missing the point- with regular PHP you can actually look at the code when you're suspicious, whereas you can't with this.
You don't have to implement DRM if you don't want to do so. It also speeds up the execution of your code by compiling it to bytecode so the PHP parser can skip that step. Just distribute the unencoded dource as well. The encoder as/is doesn't support DRM anyways, it's just a compiler.
The encoded scripts can't run without you installing the decoder on your server, so exploits that have been encoded can't be used on a plain server. Furthermore, most exploits are obfuscated anyways, so viewing the source typically won't do much good. I wouldn't recommend using Monas in a webhosting company, however.
&gt;I wouldn't recommend using Monas in a webhosting company, however. Which makes it useless. If encoding my script means eliminating 90% of the market then any gains from "protecting" my intellectual property have vanished.
&gt; It also speeds up the execution of your code by compiling it to bytecode so the PHP parser can skip that step. APC, eAccelerator and xcache all do this already (as well as opcode optimization). Are there benchmarks to compare how Monas stacks up against them?
Not necessarily. My programs are typically distributed as complete server binaries, ready for deployment on the customer's hardware as needed. If you're developing a drop in script meant to be used by anyone who buys the script under the widest array of webhosts, then there's not any real solution for you anyways: the majority of webhosts only support plain PHP, and obfuscation is your only real recourse. If you're making a program worth protecting, host it in one of the numerous webhosts that specialize in VM hosting, where you can install a PHP extensions such as this for decoding your scripts, then resell the hosting to your clients. I don't know what to tell you about PHP's inherent non-support for encrypted scripts.
No. It's a one man project (and I'm not that guy) who is just trying to help fill a need with his work for free, so benchmarks and proper English (again, he's Indonesian) are not to be expected. If the program doesn't work for your needs, then no harm done. I'm getting a very critical vibe from your posts despite the fact that I've explained the limitations of the program upfront and its possible uses, and stated repeatedly that it's free, so you're not getting ripped off here.
Try Pear Cache Lite http://pear.php.net/package/Cache_Lite/
Nice domain
Not a bad idea, but until it's supported by the hostings, it's much easier to use something commercial.
2K38, a.k.a. 2038
No, I'm all 64-bitted up.
yes, but i don't care.
I plan to be retired and safely ensconced on my private tropical island with my generator, my millions of dollars in cash, my trophy wife, and my staff of monkey butlers when all hell breaks loose in 2038. So yeah, I don't care either. You have to leave something for the next generation to worry about. ;)
Please don't, we have enough other things to worry about!
I had Y2K to deal with. I did my bit to save humanity. The next apocalypse is somebody else's job. :P
`DateTime` class is the way to go.
I'll second that. Looks like a great idea, but it's completely useless to me until it supports PHP 5.3.
If your PHP app/website/etc. is still around in 2038, then the computers it's running on will have been using 64bit ints for some time. PHP has already fixed this problem in their 64bit releases, which means you don't have to do anything different as a developer. By 2038, all modern servers should be using 64bit CPUs, so they will have to install the 64bit version of PHP. This is more of an issue with software development where the language supplies int32 and int64 types and you've been using int32 for a Unix timestamp. Of course, those programming languages don't use Unix time as the default date/time representation, so it's not really an issue.
looking forward to toying with this when it reaches 5.3
Yes, and really sucked. I was in a project that listed inventory. One of the fields was Maturity date. (Maturity date is when you can expect to get your money back if everything goes right). Sometimes this would be up to 50 years from now. I found a way around it. There are a few different functions out there that solve this problem without needing to upgrade your server.
Is your PHP application going to be running in 2038? **No.**
Where is the target file being sent to? Your desktop? Does your copy of PHP have write privileges to the destination?
try to echo $_SERVER["DOCUMENT_ROOT"] to make sure your path matches up. After that I'd make sure you can write to the folder. EDIT: remove ftp_pasv($conn, true) and see if that helps.
 $sourcedir = ""path/to/file/"; $target = "target.txt"; $source = "source.txt"; // try to change the directory to sourcedir if (ftp_chdir($conn_id, $sourcedir)) { if(ftp_get($conn, $target, $source, FTP_BINARY)){ echo "&lt;br&gt; file was downloaded :)"; }else{ echo "&lt;br&gt; file was not downloaded :("; } }
 $_SERVER["DOCUMENT_ROOT"]
 $_SERVER["DOCUMENT_ROOT"] stupid Reddit formatting, need to add four spaces.
TIL about the DateTime class. And here I've been using strtotime like an idiot...
You're not missing a / from the start of the $source path are you?
yes to /home/myuser/tempFTP/ I gave it chmod 777 so it should have permissions to write there
Do you get any error or warning messages? If not, insert an obvious error (like a wrong password) and find these messages. Look in the log file, turn display\_errors on, see the earliest user contributed note [there](http://de.php.net/manual/de/errorfunc.configuration.php#ini.display-errors) etc. You want to see these messages because they are useful. E.g. your script told me with my ftp server: Warning: ftp_login(): Non-anonymous sessions must use encryption. I have no idea how to fix this (probably I would need to use ftps somehow), but without that warning message I would have not the slightest clue.
no since I made the home /chroot/ftpStuff/ it starts there then goes to the path/to/file
this $_SERVER["DOCUMENT_ROOT"] returns the path to were the php file I'm running is located, if i do ftp_pwd($conn) it does give me the correct path to file 
Try adding in... file\_put\_contents($source, 'TEST DATA'); This should check if you can definately write to the file.
Yeah the chdir does happen, it's just the ftp_get that does not work.
the wisdom of crowds is a lie
try saving the file to the documentpath path and see if it works. If it does you probably have a permissions issue.
I don't get any login errors, I do log in correctly, theres no error log for UPLOAD or DOWNLOAD, when I use filezilla to upload a file I get an OK UPLOAD message in the error log for vsftpd Here in my local machine where I run this script , I get these messages: I checked the error logs here in my local machine where I'm running this, and these are the errors I'm getting: PHP Warning: ftp_get(/home/myUser/tempFTP/target.txt) [&lt;a href='function.ftp-get'&gt;function.ftp-get&lt;/a&gt;]: failed to open stream: Permission denied PHP Warning: ftp_get() [&lt;a href='function.ftp-get'&gt;function.ftp-get&lt;/a&gt;]: Error opening /home/myUser/tempFTP/target.txt
You can also escape with \ $\_SERVER["DOCUMENT\_ROOT"] can be used inline like so: $\_SERVER["DOCUMENT\_ROOT"]
Your target.txt gets "permission denied". I guess /home/user/ needs the x bit for others and /home/user/tempFTP/ needs x and perhaps w for others. You could try is\_writable() or file\_put\_contents() on the target.txt to make sure it's writeable.
Try doing a file exists check, if the file doesn't exist create a blank one first before putting your content into it. Sometimes PHP needs to create a file under it's own user before it can write to it. Those 2 errors you're getting are file permissions errors. Also try setting the source and dest locations to 777 for testing, then remove permissions until it breaks again. You should be able to set the source folder to 777 using your FTP client.
Unless PHP has write privs to /home as well I don't think that would work
are you on GoDaddy? Oh, wait you're on localhost
Bug Report closed as bogus. Not a Bug. Time does not need to exist beyond 2147483647.
In my personal experience (with HTTP and sockets, etc.), it's always easier to write your own than deal with PHP's built-in things, which may or not be installed/enabled/available/working.
Hey guys, I don't want to be that guy but, this is r/php. "News that relates to PHP, along with tutorials.". If you have code related questions, there's always stackoverflow.
D'oh, my bad, thought this was an all purpose php subreddit for news, tutorials or help
No worries. I just pointed it out because as of late, r/php has become more of an ask for help subreddit. Not many discussions with PHP itself. 
So, a few hours late on this, and you're in the wrong subreddit, but: &gt; PHP Warning: ftp_get: failed to open stream: Permission denied Permission denied when opening a socket can mean that you're running a "security enhanced" Linux distro and Apache or PHP don't have permission to open a connection. If you're on Fedora/RHEL/CentOS, check the SELinux Audit log. If you're on Ubuntu, check AppArmor.
Let me get this straight: You are encouraging the readers of this reddit to download this software, of which they cannot access the source, and install it on their server, with the promise that it will work? Anyone to install this software on such a promise is an idiot.
We shouldn't expect benchmarks because he's Indonesian?
I like the general idea of making a framework as simple as possible, and it seems to be written by an experienced programmer. I would say it's better to write something like that for yourself than to use someone else's, but if you like the coding style, it should be very easy to learn it and extend it if necessary.
I am using this for rapid development/sandbox projects I have. **Some of my Observations** * GPL by default. You can however get a MIT licensed version for about $100 (this also helps the developer, so it's not a real con). * You have to call it by using F3::(...), by default. But you can remove the "final" keyboard and create a class e.g. App extends F3. Very subjective issue as I do not like branding. I just prefer App::route(), App::set() App::get() instead of F3::route(), F3::set(). * One file, couple of thousand, well commented lines - It's pretty easy to fix &amp; extend. * By default error handler does not allow dynamic routes (F3::set('E404','errors/e404.htm');). It is easy to fix however. * Axiom, it's integrated ORM is pretty good. I'm using [php-active-record](http://www.phpactiverecord.org/) however. And it did not interfere with F3 at all. * Caching - F3 has a wonderful caching system. You can cache routes, variables, and queries (if you use axiom). * I like how it does not interfere with the way I want to structure my application. I have the file layout the way I want it (symfony2 way that is). I think it is also the same developer that's behind [ZWAMP](http://zwamp.sourceforge.net/) - another solid product. It's a **portable** WAMP setup. *edit: formatting.*
That sounds like a pretty cool idea. Unfortunately I can't access fluin.com as the proxy of my company marks it as "porn" for some reasons o_0
I've never used the framework, and I actively maintain a "framework" myself (you could even use them together if you want - http://flourishlib.com). I looked over the code some, and here are some things I noted, which may or may not be important to you: - PHP 5.3+ only - won't work on most shared hosts - GPL v3 unless you want to pay - Files have ?&gt; followed by whitespace, requiring use of output buffering to prevent output has already started errors - Generic class names that may possibly conflict with your own classes: Cache, Runtime, Log, Auth, etc - I couldn't find any unit or integration tests for the framework itself For many people the only real issues would be PHP 5.3, depending on their environment, and the GPL if they don't want to pay.
They advertise as "fat-free" but i think theres still fat that could be trimmed, that wouldn't be needed in a base framework. I don't really understand why they call some of these plugins through the F3 class instead of using them separately. Wouldn't it be better to separate db class, and do Db::query() or Db::sql() instead of F3::sql(), which uses a __callStatic() magic method and loops through all the files in the autoload dir and checking each class to see if it has a sql() method. Just seems like it's doing a lot of extra un-needed work, even if it is caching it
"It's also the only framework that shields you from bandwidth theft and Denial-of-Service (DoS) attacks." Um, this seems like a bit of a bold claim for a php framework. 
Cool concept. I think we're witnessing the start of something. Keep up the good work!
I just started a Reddit for folks that are rather new to PHP or need answers to their questions, etc. (no one knows all of it - and if they do, they're probably no fun to talk to) here it is: http://www.reddit.com/r/PHPnewbies/ - Post some of your stuff. - Cheers :)
Here's a link to the PHPnewbies Reddit. It's for folks who are new-ish to PHP or folks that just have questions, etc. http://www.reddit.com/r/PHPnewbies/ - I created this reddit because the general PHP Reddit goes above a lot of folks' heads. Cheers :)
I've used it in a couple of small projects, and while it is indeed smaller than other frameworks, there are a few things that I don't like: * It has its own template class with custom formatting. That makes it less of an ideal "fat-free" framework that I would want to use. Ideally, it would leave the output completely up to me, but that's not the case with F3. * As someone already pointed out, they call plugins through the F3 class, which does a lot of unneeded work. * The framework only has one developer, which doesn't really reassure me that this framework will be actively developed for in the long run. Even with those cons however, it's still not too shabby to use for a small-scale, quick deployment project.
Loop through your results and use this function: function extract_emails_from($string){ preg_match_all("/[\._a-zA-Z0-9-]+@[\._a-zA-Z0-9-]+/i", $string, $matches); return $matches[0]; } Usage: $text = "blah blah blah email@address.com blah blah blah email2@address.com"; $emails = extract_emails_from($text); Results: print(implode("\n", $emails)); ?&gt; 
The framework is designed and targeted towards developers who need to get a job done quickly. The template system is optional too and I haven't had a problem using Smarty with Fat-Free. MVC is encouraged, but not enforced. This is the reason for its flexibility and interoperability with third-party classes. Some of the plug-ins were contributed by other developers. Axon, the built-in ORM, in my opinion is the simplest to use ORM at large. It doesn't require any change in your app (nor a code generator) to synchronize your DB schema. Change the structure of your database and the ORM automatically detects it.
something like `SELECT * FROM ``table_name`` WHERE Email REGEXP "(^[a-zA-Z0-9_-\.]+)\@(.*)` This is more of a mysql question I think. 
Thanks, man. I'll try this out. Cheers :)
The regex specified will miss quite a number of common valid emails, especially those with + and ' in them. The following regex will get you much closer: preg_match_all('~[^\x00-\x20\(\)&lt;&gt;@,;:\\\\"\.\[\]]+(\.[^\x00-\x20\(\)&lt;&gt;@,;:\\\\"\.\[\]]+)*@([a-z0-9\\-]+\.)+[a-z]{2,}~i', $string, $matches); It is based on RFC 5322, excluding: quoted strings, folding whitespace, whitespace between dotted atoms, IP address domains and unqualified domains. All of these excluded constructs are *extremely* uncommon.
You can use the regex's from here: http://fightingforalostcause.net/misc/2006/compare-email-regex.php But it will only pull out emails with valid formats.
&lt;3 flourish. Keep up the great work. My only major-major-major criticism of flourish is the class naming convention you chose. If only it were standardized like "Flourish_ActiveRecord" then I could easily make it work together with Zend Framework and others.
Is it loading the classes in your autoloader that is the pain, or do you dislike it aesthetically, or just that it is different and requires mental switches? It is quite a bit different than Zend and Pear, but I really disliked the verbosity of prefixing everything with a full word and _. Symfony 1.x is similar, except they use sf instead of f.
You got permission to use those email addresses?
[Hehe](http://www.reddit.com/r/PHPhelp/comments/d5uyo/having_troubles_using_rphphelp_give_rphphelphelp/)
Considering that r/php is half php links/half help I don't think this is going to fly. Really I don't see a problem with questions. The whole "we don't answer questions here, get off my board" really stinks of Linux groups in the 90's. Lets not go down that path.
I disagree entirely. I don't want to see these questions cluttering up this subreddit, I can go elsewhere for that. To quote this subreddit's own description: &gt;PHP &gt;- frontpage4,809 readers &gt;News that relates to PHP, along with tutorials. &gt;Having problems? Check out r/phphelp
Everyone helping this guy is only making spam worse.
and then you go to phphelp and there's 115 subscribers. No one is going to get their question answered with that small of a user base so they come here. I like the questions. I'll come here and answer them when I'm stuck on something at work.
So if it says it right in the side bar, why post this and piss everyone off with your cross sub spam? This post is worse than a help thread with actual code in it. 
Or the PHP5 way: `filter_var($email_a, FILTER_VALIDATE_EMAIL)` http://uk3.php.net/manual/en/filter.examples.validation.php
Maybe, maybe not. It still is a valid question. It would have probably had a better home in http://www.reddit.com/r/phphelp but since people already answered....
&gt;I don't want to see these questions cluttering up this subreddit http://i.imgur.com/Nn5Pl.png
I don't understand why a reddit with &lt; 30k readers has split itself already, **WHEN A REDDIT IS SMALL YOU DO NOT WANT TO PUSH PEOPLE AWAY FROM IT**
This guy speaks the truth. 
One of the nice things about OO is that you can group your functions into classes so the function names don't conflict with existing stuff. You can have class foo and class bar that both contain a function named getID. foo-&gt;getID and bar-&gt;getID are totally cool and will not conflict with each other. At the very least OO gives you a way to organize your code and not have to worry as much about function names.
Im in a similar position (taught myself php), and could anyone tell me how I should start learning OOP?
This is what I am using: http://www.killerphp.com/tutorials/object-oriented-php/
Thank you very much.
I'm about to blaspheme hardcore... but here it goes anyway... If you're asking questions like this, you probably don't "need" OOP. You're probably not doing anything complex enough to require it. That being said, OOP arguably forces you to organize and manage things better, so it's good to get in the habit anyhow. A good example of OOP would be a machine problem I had to do back in college.. The teaching assistant wrote all the code necessary for a chess game to move pieces around in a predefined manner, determine check/checkmate, and end a game... Our job was to define a class "ChessPiece", and then extend that class for each type of chess piece (i.e. Rook, Queen, etc)... Each of these pieces all had a function called "move", with defined rules around how (i.e. a knight had to move 2 spaces in one direction, 1 space in another) they could move, etc... This is a really simplistic example, but there's two key ideas here: 1) Reusable code shouldn't be duplicated! So every different type of Chess Piece just extended or modified the class ChessPiece 2) The idea that pieces of code are "abstracted out" is the real beauty of OOP. We didn't have to know jack squat about how the chessboard was defined, how our pieces got placed on the board to start the game, etc... All we had to know was that at some point, the chess game would call "move" on each of our pieces and make them move... All we needed to know where what functions they needed our pieces to have, and what functions our pieces might've needed to get information from the game... the rest could be in a black box we didn't care about or need to understand... This concept is crucial to collaborative development... Nobody should have to read every line of your code just to figure out how to accomplish a simple task... OOP is not as convoluted or complicated as you think, however... it forces organization, which means the syntax may look bigger (i.e. having to call MyObject-&gt;someFunction(); instead of just someFunction();.... Yes, you can keep writing someFunction() on its own, outside of a class, and it'll work just fine.. but once you start working with a team of developers, it'll become a big pain in the ass... Finally, a class is more than just a collection of functions.. it's a collection of functions AND properties... so you might have something like this pseudo representation of a class: Student { string name: 'bob', string year: 'freshman', string hairColor: 'brown', int age: 14, int intelligence: 30, int hunger: 3 /* value between 1 and 10 */ function constructor(name, age, year, hunger) { this.name = name; this.age = age; this.year = year; this.hunger = hunger; } function doHomework() { /* spends 1 unit of time on homework trying to solve problems */ this.intelligence++; } function eatCookie(numberOfCookies) { // note the "this.hunger" means I'm referring to my own hunger.. there may be MANY students, but this refers to THIS student's hunger! this.hunger = this.hunger - numberOfCookies; } } The idea here is that to do this without OOP, you'd have to have an array of students, something like: $students = new Array(); $students[0]['name'] = 'bob'; $students[0]['year'] = 'freshman'; $students[0]['hairColor'] = 'brown'; $students[0]['age'] = 14; $students[0]['hunger'] = 3; Now, how do I let that student I just created eat a cookie? Well, I guess I could have a function called eatCookie that takes in an associative array, and say eatCookie($students[0]), but that's sort of silly, isn't it? Instead, let's do this the OO way: var $bob = new Student('bob',14,'freshman',3); $bob-&gt;eatCookie(); $bob-&gt;doHomework(); Obviously this is a silly example.. I'm making up useless shit... but I think it illustrates the point.. maybe... or maybe I just confused you even more.. I dunno... :)
In a nutshell... An object describes a concept; an idea. You wrap up your data and functionality in one container and call it an object. The object's methods describe what can and can't be done with the data, or what kind of behaviors the object is capable of engaging in. So, OOP isn't just about well organized code, it's about building models of your problem domain and exerting control over data flow and manipulation. 
This is what namespaces or modules are for. Objects are way cooler than that.
PHP didn't get real namespaces until 5.3. It's easier to use objects as function containers. Also, build one customer object and you can use it over and over again. Need more customer fields? Just extend it.
You still have to extract the emails from the text and using this approach you'd have to run it on each word. A regex would be better as it can extract and validate them at the same time.
Yes ... you're getting at the real use of objects. PHP also didn't get a real object model until 5.0, and didn't really get a *decent* object model until about 5.2. Using them as tools to keep your code organized is beginning to understand some of their utility. Now, you're talking about a customer object, and binding data and functionality. You're also talking about extensibility. These are good things about OOP. But calling them a container for preventing name collisions vastly oversimplifies the reason for OOP's existence. 
True, but I figure a functional programmer will understand that. That's why I said at the very least. There's a ton of other great reasons for using OO, but IMO this would make sense for someone who's coming from a functional background.
Good luck sir. I feel like I was in your shoes when I first started at my current job a couple years ago. Just a couple tokens of advice: * 1) Learn how to use [class autoloading](http://php.net/manual/en/language.oop5.autoload.php). You'll never have to use "require" again! * 2) Understand how the [magic methods](http://php.net/manual/en/language.oop5.magic.php) work once you have a handle on the basics. They can be very useful. * 3) You might even look at starting with [static classes](http://php.net/manual/en/language.oop5.static.php). I use them more like extensible namespaces than how you generally think of classes in OOP, but they offer some of the encapsulation advantages of traditional OOP along with the, IMO, easier stand-alone simplicity of just using functions. In fact, with 5.3 now supporting [Late Static Binding](http://php.net/manual/en/language.oop5.late-static-bindings.php), static classes + autoload is my goto approach for new projects.
Oh yeah, that's a point. Wasn't really thinking very well. Preg is the way to go!
Another of the advantages that OOP offers is that you can extend and override existing code. For example, in the code sample below, I have two classes, Person and Knight. Since Knights are a type of person, I can have them inherit all of the functions and variables that a Person has and then overwrite any functions or variables that I want to change. Later if I want to add give my Person class other properties such as age, weight, etc, I can do so and Knights will automatically be able to take advantage of them. Similarly, I can easily create new types of people or even new classifications of knights by extending them. This wold be a lot harder to keep organized if all I used were functions. &lt;?php class Person { protected $name; protected $gender; protected $title; public function __construct($name, $gender) { $this-&gt;name = $name; $this-&gt;gender = $gender; $this-&gt;title = $this-&gt;getTitle($gender); } public function getTitle($gender) { if ($gender == 'male') { return 'Mr. '; } else { return 'Ms. '; } } public function sayHello() { echo 'Hello, my name is ' . $this-&gt;title . $this-&gt;name; } } class Knight extends Person { public function getTitle($gender) { if ($gender == 'male') { return 'Sir '; } else { return 'Dame '; } } public function attack() { echo 'Chaaaarge!'; } } $randomGuy = new Person('John Smith', 'male'); $randomGuy-&gt;sayHello(); // Hello, my name is Mr. John Smith $knight = new Knight('Michael Caine', 'male'); $knight-&gt;sayHello(); // Hello, my name is Sir Michael Caine
I was in your shoes a few years ago and I will tell you what helped me as far as really learning and understanding OOP and wrapping my head around the how's and why's of it. This may be unconventional and unpopular advice, but here goes. I'd been doing nothing but procedural PHP programming and OOP just didn't make sense to me. I was at the level you are. I could pretty much make the code do whatever I wanted it to do, but it still felt like a hack. So what I ended up doing was totally stepping away from PHP for a bit and dove into a new language, one that's more dependent on object-oriented design patterns. I chose Ruby, but I think python would also be awesome for this. It forced me to stop thinking "Well, I could just go back and do X with a function, so why bother with an object?" because Ruby is an extremely (virtually entirely) object-driven language, and because I didn't know how to do it any other way in Ruby, so I was forced to learn the "right" way. Now, this isn't a post about bashing PHP and extolling the awesomeness of Ruby. I like PHP and I use it extensively, every day. My point is that picking up the other language that forced me to write OO code allowed me to get a completely different perspective on the whole process, which really helped me to understand it better. Ruby had the benefit of having a very clean syntax, too, so there wasn't a lot of clutter and confusion to get in the way of learning technique. After working with Ruby for a while, going back and applying those OO principles to PHP code was *easy* and made perfect sense, because I already knew the language very well to start with and now had the OO concepts squared away in my brain from the time I'd spent writing Ruby code. And on the plus side, learning a new language is always fun.
OOP is a way to simplify and organize your code. It lets you separate out different modules with their assorted functions and data structures. If you're a functional programmer you're probably passing around a lot of complex data structures as function arguments. In this context an object is a data structure with appropriate application code attached to it. One of the advantages is that you can make it so that you pass around different data structures, but each of them has the same methods. For example, if you've got a $user (containing user data) and $comment (containing entirely different set of comment data) and need their data as SQL strings, instead of having separate functions UserToSQL() and CommentToSQL(), each object can respond appropriately to $user-&gt;toSQL() or $comment-&gt;toSQL(), which is simpler, prevents mistakenly using the wrong parsing function and lets you reuse more code.
I was in your exact shoes when I was first starting out with PHP. I never thought I would need objects and thought they were kind of dumb. Once I got a grasp on them and realized how useful they could be, it made everything so much more organized and easy. I suggest reading the [PHP Docs](http://us3.php.net/manual/en/language.oop5.basic.php) on objects and just experiment with them at your own pace. 
Just a small clarification: a "functional" programmer is someone who works with "functional" languages like Haskell or OCaML. You must mean "procedural" or "structured" maybe? I think that the single most confusing fact of OOP from programmers with a procedural background is the difference between "static" and "dynamic" class members. Try to clarify this first. Food for thought: the constructor should be treated like a static or a dynamic method? 
I learned OOP by learning a framework (Zend). You might not need a framework, but setting up and coding a few sites with one will help a lot in understanding how they work.
OOP is great, but too often OOP becomes a dependency nightmare (e.g. Java and to a lesser extent the .NET platform). I suggest before you start straight away with one of these 'higher-level' languages (higher-level only in the sense that it is so far removed from the hardware), you spend as much time as it takes to learn the very low-level basics. Im talking about structs, enums, preprocessor macros, and all the other C niceties that make your average C# developer stare at their screen with their head tilted to one side. Then, spend a few weeks learning everything you can about memory allocation and deallocation. Learn about pointers and pointers to pointers and pointers to pointers to pointers. Learn what they do and when to use them and when to avoid them. I am to this day absolutely convinced that a 'classically trained' programmer who codes with memory and resource allocation ALWAYS in the back of his/her head is vastly more efficient and produces better-performing code than their certification-farm raised counterpart. I always tell junior developers to remember what their mothers told them as children: if you take it out, you need to put it away. Once you're sure you have this memory thing down, you should then spend your time learning the OOP paradigms. I recommend going straight to the academic source for this. You dont want to go to Borders and pick up a 'For Dummies' book for this. You can usually find true computer science textbooks on Amazon used for pretty cheap. There is also iTunesU, which has some decent foundational OOP coursework scattered throughout. Once you are confident you know OO when you see it, the language should be irrelevant. Of course, all languages have their own way of doing things, such as closures in Python and ActionScript 3 and categories in Objective C, but you shouldnt have a problem recognizing these things as the syntactical sugar they are. Not a short path to OOP mastery, but it's solid and wont paint you into a corner.
With the exception of github, I don't use any of these...
Seriously, most of the suggestions in the article just lead to bad habits.
You're right, I mean procedural ... but when I say functional, almost everyone automatically knows what I mean.
Phing is horrid. YMMV, but I doubt it.
This is actually quite good.
Github, PEAR and PHPDoc (on occasion). I read things like: &gt; Another hindrance to understanding the intent of source code is poor formatting and I can't help but think "you're doing it wrong".
I know it sounds lame but if you really want to learn how to program I would take a beginning programming class or two. You will learn a lot more than just what OOP is and it is the sort of information that will make your code way better. The PHP field is chock full of people who have taught themselves PHP but are not really programmers. Acquiring some basic skills and knowledge will set you apart from the pack and make your life as a programmer a lot more interesting and enjoyable. 
What does Phing suck?
wouldn't that just select all rows that have an email address in them? he still has to extract just the email.
Wow. You did a really awesome job. Thanks.
One thing a well-designed function can't really do is have a state. I found it helpful to think of classes as 'mini-programs', that have states and all their applicable functions, bundled into a neat little package.
It's having to write a new autoloader for flourish and that flourish doesn't follow the PEAR naming conventions. It's hard to enforce a standard when one of the core libraries doesn't adopt that standard. Enforcing a standard naming convention is crucial for projects that end up growing in size. Writing plugins and extending your code means I need to create a new naming convention and flourish really doesn't have one for class names. I understand your choice for the short prefix. I think it's important to note that Symfony is the more verbose convention now with Symfony2. Kohana is doing the same. This is a great thing. I never have to type it all out though. Many serious PHP developers are using an IDE with code assist. If it were Flourish_Db_ActiveRecord, I would type "FDA" then press CMD+SPACE and code assist would do the rest :) Edit: Forgot to mention that I don't want to influence your priorities with flourish. Your framework will never compete with Symfony or Zend and I don't think you ever intended it to. If your target audience is the type of PHP dev that uses Dreamweaver or Textmate and doesn't write large scale web apps then perhaps following the PEAR standard really doesn't matter. I will say that if you ever intend for Flourish to be used in dev shops that are writing custom software solutions that stay in development for over 6 months, you might want to consider switching to the PEAR standard since larger teams really care about standards for their own sanity.
PHPBuilder is such a god awful website. I can't believe people still read that ad infested piece of shit.
Lean java.. Everything in java is an object... If you don't understand OOP after that then you never will. Plus it'd be much easier to learn OOP in a true OOP programming language rather than something like PHP that has OOP kind of "hacked in"
oh no you ...oh you did it.
Hey. Followed the link. Yawn, another editor .. hey, what, they say itès fast? Integrated debugger? JS/XHTML/PHP code completion? Commercial product BUT they offer free licence for Open-Source projects AND education purposes. They have my full attention, will try this out, up one for you bud.
Oh crap. I honestly meant to write "Why does Phing suck". Why does Phing suck?
I use all of these except I use subversion. Phing is PHPs weaker version of Ant, it can be useful. I would add memcache tools, cachegrind for profiling, codesniff for style checking, PHPDoc for Java-style API auto-generation, and PECL C extensions for PHP. I use most of these daily.
Thank you for saying this. Functional and procedural are very different. Many would argue functional type languages (Lisp, Scheme, etc) are more difficult to master than OOP.
I don't have any comment on the article itself, but it made me chuckle to see the extension ".php3" at the end of the URL.
Don't laugh. We still have a php3 based system running. Client is a NPO and doesn't have the budget to pay for an upgrade. The system went live before php4 came out.
With PHP you can write code in object oriented or procedural style, like the most of the current programming languages (procedural programming is extended with objects). You can mix these easily in most languages. The main difference between the approaches is encapsulation. With objects you abstract the inner logic and state inside the objects. With procedural code you separate the data and the function, or just write one big function (in php you don't have to specify a function for that, just write the code in a file). Functions are simple. You give them some data and they do something with it. Maybe output something on the screen or just return data. But the important thing is that functions rarely have state. You can use static variables in PHP functions, and that provides one way to keep state in functions. You can use global variables in PHP or constants and dynamic defines to give some state or configuration for the function (usually you want to avoid these kind of things, but there are obviously use cases for them). But in general functions and data are separated. Like in C, you define your data in structs in header files and then you write functions to operate with them (they say: "it's better to have only a few data structures and many functions to operate with them"). PHP has its roots deeply in C-style procedural approach. There are many things that make PHP a procedural language. The main points are: * PHP is shared nothing (and that's a disadvantage in writing OO code). * The most of PHP's inbuilt functionality are provided as plain old functions. * PHP programs are 'throw away' programs (after the program has been executed, you can cleanup everything (maybe you keep byte code cache)). * PHP is usually extended with C coded extensions that natively define their functionality in functions (maybe a wrapper for well known C-library) * In PHP scripts you want to include only the functionality that you really need to fill the purpose (=&gt; huge class libraries and autoloading the stuff you don't really need, is not what you should use PHP for). * Zend Framework as a PHP extension would work so much better, but it would not be this far if it was developed as an extension (writing extensions is a lot harder than writing PHP code). * PHP has ultimate datatype called array (a way to store data inside PHP programs) and a whole lot of functions to work with them, why not to use it then? What's the point to throw all your datatypes in separate classes? * Most of web problems are rather simple, you get data from some back end store and format it as html, json, xml or whatever. Generally I'm with you, procedural approach fits so much better in PHP than objects (now we even have anonymous functions and closures, and namespaces give us a way to organize our functions and prevent name collisions). But I still see use for objects here and there. I tend to avoid as much as possible using OOP when I'm working with PHP. Sometimes I start with OO approach to prototype my ideas, but very often I end up simplifying my OO code as plain old functions. Sometimes it's really eye opener for me: "I can do this exact same thing I had in OOP with plain old functions so much simpler, straight forward, and easier to understand). Most PHP programmers start with PHP as one of their first programming languages. First they learn just simple procedural scripting (less structure and more of I got this to work approach). Then they start learning OOP. After that they start overengineering everything (I build this facade for this object factory to instantiate my singletons. I start using framework and I learn every way to give knife to it). And finally they start to think about simplicity. Simplicity is the driver and if OOP gives you that, use it! If procedural functions gives you simplicity, use it! If its a tie, use procedural. With objects it is easier to define more strict data types and bind functionality with them in more idiot-proof manner. But in the end, like Python coders say, we are all adults. With object you can gain in pluggability and modularity (and use dependency injection), but you also lose in readability and start building dependency jungle.
FirePHP - is there any way to embed it in such a way that it can be turned on and off at the server end, but not add any extra load to the processing of a page? In C you would use compiler directives to expand into debug calls, that can be removed simply, allowing a recompile without any trace of it. Not sure how that would work in PHP. What I want to avoid is a load of function calls to check whether it is enabled and generate the debug code. Or perhaps that would not add any measurable load, since data passed into a function is not longer duplicated unless it is modifed? In case that is not clear, what I am talking about is [this](http://www.firephp.org/HQ/Use.htm) - invoking $firephp-&gt;whatever() all over the place. If if disabled, it still gets executed.
A debugger. Even if it saves you a few minutes a day, it's worth its weight in virtual gold. But for some reason, people who refuse to use a debugger seem to think they are somehow superior and I get voted down for good advice they disagree with. My LGPL project has over 250,000 downloads, and 15M page views. Not to brag, just that I can code, and a debugger is neat.
not as bold as everyone else making claims that each one of them is the fastest
At least it's not as bad as [the site that must not be named](http://phpclasses.org/). *shiver*
This is the best introduction to OOP that I have ever seen. Good job. 
&gt;If you're asking questions like this, you probably don't "need" OOP. You're probably not doing anything complex enough to require it. Either that or he's doing things sans OO that would be better served if he *was* using OO.
Hybrid approach works best, especially with PHP. Avoid OOP overkills at all cost.
How depressing. Is there a URL to it somewhere?
Loading Flourish through an autoloader tends to be really simplistic, but I do understand the dislike of different styles. if ($class[0] == 'f') { return require '/path/to/flourish/' . $class . '.php'; } In terms of class naming, Flourish does have a standard - it follows PHP core with class names, except a lowercase f is prepended. Normally when writing plugins or classes that extend it, we use UpperCamelCase like PHP core. That said, there is no reason why you can't use Pear-style names in your code. The ORM even supports arbitrary mapping of class names, so you could have Model_User instead of User. Way back in the early days of Flourish I had considered publishing a version with a custom prefix, but I thought that would just lead to compatibility issues. If it is something you find an issue, I suppose I could create a compatibility layer that would extend all of the Flourish classes in Pear-style naming with explicit includes. I could even name it Flourish Enterprise Edition. ;-) I do think that comparing Symfony2, which is built using namespaces, is an apples to oranges comparison. And while Flourish certainly can be used for smaller projects, we and a number of other people have had really good luck using it on good size projects with our IDEs. :-)
I had some time before work to make a quick test table and try it out. First off you are 100% correct, it would return the whole field, so it would still have to extract the email from that field. but it would still be much more efficient than parsing the entire table. Also here's a working query: `SELECT message FROM query WHERE message REGEXP "([a-zA-Z0-9_-]+)\@(.*)";`
Xdebug and a decent IDE will change your life.
I'm sure PHP 3 can make sense for some people - but this is a site called "PHP Builder", and an article recommending tools for increasing PHP productivity! Seriously though, I would guess they're not actually using PHP 3, it's just the extension. But it still made me smile.
Array logic seems verbose, but take this example: $student = array('name' =&gt; 'bob', 'year' =&gt; 'freshman'); student\eatCookie($student); or even: $student = student\build('bob',14,'freshman',3); student\eatCookie($student); Inheritance is something you cannot do with functions, but of course you can have your functions behaving differently depending on data: namespace student { function eatCookie($student) { switch($student['year']) { case 'freshman': return eatFreshmanCookie($student); } // normal implementation } }
&gt; You probably are familiar with the spaghetti code that procedural code forces you into Well, this is wrong. Spaghetti code does not have anything to do with programming approach. Spaghetti is all about mixing of concerns instead of separating the concerns. With procedural approach you can do that just fine. For example Linux kernel is mostly procedural C code. It's not even close to spaghetti, and it's bigger than anything you build with PHP. In C you define your data structures in header files. In PHP you define them basically as arrays or objects. PHP arrays are not strict definitions, but you can document them or make builder functions that create them. By combining data with functionality = what objects basically are, you throw your datatypes all over your projects. Is it easier then, I'm not sure? In web it's usually better to have flexible data structures (like PHP arrays are) than having strict type definitions.
I discovered that site for the first time two days ago. I hope I don't have to discover it again.
Well, at first I was wandering what's so difficult about OOP since you already knew functional programming! Then I realised that this is /r/php. :-)
This is me right now, only I went with Python. I've been building a natural language text parser from scratch as my learning program. So far, I've used a 'Word' object with properties for each word's location in the sentence, paragraph, and document. The program will eventually use this information to analyze the source text.
Short of your own PHP builder that strips these FirePHP calls out for production run of your code, I don't think you can do it like in C/C++. It's easy in C since you can provide a compiler directive and entire chunks of code can be inserted/omitted from the compiled binary based on compile-time values. Since PHP is interpreted, that's not going to be possible without literally manipulating the source code through a build process. Overall though, the thought of pushing a function call to the stack, checking a simple boolean for enable/disable status, then popping back out if it's disabled doesn't sound like a ton of overhead. I know PHP frameworks do this to enable debug statements and I haven't heard anyone bitch a fit over it. But I guess Frameworks are just assumed to be slower anyway.
Funny, because for me I didn't really grasp OOP until I got into PHP. Learned it in a couple of Java courses back in college but didn't see the need for it in anything I was doing at the time. Then when I started to get serious about PHP I learned OOP and now I use it a lot. That being said, 99% of PHP programmers I know do not use objects. Since then I've really improved my javascript and am still working hard to master their psuedo-oop thing they've got going. As for Java, which I still work with a fair bit, I find myself using classes a lot more now, and now they make sense to me.
Wow, I didn't make it past the 2nd paragraph. His randomly placed ellipses and commas before closing brackets just annoyed me that much.
I especially hate the mouse minefield of mouseover definitions/ads.
Lisp... difficult... fucking... makes... no... sense
&gt; Every web developer in this universe would like to have a Twitter application on his website. What? I love how this is the "most simple script", which of course requires a library. A library that is mentioned in the code and *not mentioned anywhere else*. Oh, and then there's the demo that wants your username and password and is totally safe and not malicious at all. Then there's the *second* "demo" link, which is in reality a download of the previously mentioned library. Except it eventually results in a 404. When the file is found manually, the library in question is just a freaking curl wrapper for the old twitter API. The one that they've been screaming for *months* is [going away in favor of OAuth at the end of August](http://countdowntooauth.com/). That's about four days from now, by the way. At least the code isn't *awful*... but seriously now, this is a horrible blog and the writer behind it clearly needs a little help doing the most basic tasks.
I use GitHub, Xdebug and FirePHP. The documentation creator is nice idea but I put my ideas on paper first then start coding. I also make comments in the code about the function. When I return I know that class X is for representation for X object and has methods for certain actions. Good documentation is key for any project. Good documentation shouldn' t be stuffy just to the point. Also the author should mention a IDE. NetBeans, VIM, Notepad++ are the choice now but I seen great coders working with Notepad. 
I've dropped that site like a bad habit and am now reading PHP Object Oriented Solutions by David Powers ... Amazon gives it pretty good ratings, so I may be happier with this one.
i beg to disagree. i like the idea of remembering only one class to call everything else. i see no performance degradation either, considering the correct class calls are being cached. and the doc says, as far as you, the application programmer is concerned, "the framework is just another object". not everyone wants to know what's under the hood, some just want to know how fast the car goes, and how easy it is to drive. so let's not be anal about it.
related functions built as a library is just that. a library. now try looking for aisle 6, row 12, shelf 3, "encyclopedia of hard-to-find south american mushrooms" with cross-references to "ancient hisory of hallucinogenic mushroom consumption" in your local library. you can't do that in a strictly-functional application. OOP leads to fine-grain organization. OOP is good. abstraction is good. too much abstraction, on the other hand, kills performance and your sanity.
At the end of the day, the only real advantage of OOP is that you can more easily think about and work with large, complex programs. In Engineering we like to talk about "black boxes." The appeal of the black box is that you don't need to know how it works internally to use it. OOP gives you that with your software.
Looks very cool, if I was in a heavy Java environment I would be sure to look further into this!
GAE uses it, but I'm afraid that you cannot use the datastore.
I've played with Quercus, but for any kind of performance boost you need one of those massive sun servers. 
I have an include file in all my scripts that defines misc. stuff and inside it there is a conditional block that executes if the server is localhost. I load the firePHP class inside the localhost block, and define a function that merely wraps the $firebug-&gt;whatever statements. Inside the else part, I define that function as null. So there is a tiny bit of overhead with 'executing' those null functions on the production server, but at least that's all I have to do. Aside from that, you could have an .htaccess protected script that you need to log in to, and it could search and comment out all the firePHP related lines, or uncomment them. But the former approach works for me. 
Flourish is awesome, i ported code out of the fUTF8 API because we had production servers without mbstring. If you ever start a 5.3 port ... let me know i d like to work on it. 
I'm not exactly sure where you decided any of these suggestions form bad habits, but something tells me you don't have experience collaborating with developers on projects. Aside from PHP_Beautifier, they're all great tools and resources. Unit testing, automated build and deployment processes, collaboration tools, debugging tools... these hardly seem like bad ideas.
Nice idea. Does anyone here try to do this or have any experience with it?
This is awesome. It will help me grow outside of my little PHP world while still getting stuff done in the meantime. 
APC/memcache? Serialise things to files in tmpfs?
I imagine you could use the singleton pattern whereby its only possible to have one instance of a class instantiated at a time. After the request is finished, you serialize it and write to file. Then at the start of each request unserialize the saved instance and start again.
Using the magic functions sleep/wakeup via serialization should allow for what you are speaking of, but as you said the only way you can do it is via some sort of storage mechanism (database, cookie, cache) as there must be some sort of storage to hold the data between requests.
PHP sessions use cookies to store the session ID. That is the **only** way to reliably add state to multiple http requests. Remember, HTTP is not stateful. Every request is completely in dependent from any other request. The only way to determine if the client making request B is the same one that made request A is to use a cookie with a unique value (like a session ID) to identify the user. So the answer to your question is: no, there is no other way. What problem are you trying to solve?
Nothing really, just seeing if there's a better way to do it. I've been using the session method.
Thats not entirely true, i work in advertising where this was a major issue. As people have a natural distrust of cookies. You can create a very unique identifier for a user using various system information (user agent, ip address, caching etags). While i admit that this will not work in ALL cases as its still very possible for all of this information to be duplicated but the chance of it happening is fairly rare. Especially if you have other ways to segregate the users information. ie, user clicks on link A and you know that the only way to get to location B is via link A. So if you have all of the same system/browser/ip address configuration between two users, but you know you have only seen one of them pass through link A you can reliably infer that if you see that same configuration come up at location B, it is the same person. The above example can really only be applied in certain situations and wouldnt work if you are just trying to track a user through a static application of some kind.
I know you didn't ask, but I'll say it anyway :) You're much better off solving problems as you encounter them instead of solving hypothetical ones. I've written and been a part of writing some large scale web applications and we never had the necessity to do anything like this.
I'm just trying to keep persistent classes to prevent unneeded pulls from the DB across multiple pages. From what I'm seeing sessions are the way to go. If the user doesn't want to use cookies then I guess they don't want to use my site. Too bad.
&gt; You can create a very unique identifier for a user using various system information (user agent, ip address, caching etags). That's completely unreliable for web applications used for the general public. For private intranet, maybe. I know you did say that, but I'm re-emphasizing ;) I do agree that there workarounds under very specific circumstances. As a general rule though, you can't do it. If he outlined a detailed use case maybe we could come up with something.
The way I've done it before with sessions is by putting the classes in the sessions so I don't need to pull data down from the server on every page request. Load the class up once, when I need to update update the DB and the data in the class, then use the data in the class instead of making a DB pull every time. I just wanted to see if anyone had any tricks that might work a little better than loading up a session.
Sounds like you need to use APC or memcache.
Do you have any decent tutorials on either of these? I've seen this twice on here so far, and it seems like something to look into.
It's practically impossible to surf the web with cookies disabled these days. I wouldn't worry about making it a requirement that users have cookies enabled to use your site - plenty of other sites do.
I wrote one in 2006 (holy shit time flies): http://www.rooftopsolutions.nl/blog/107 Most of it should still be relevant. I was thinking of writing a new one, focusing more on cache strategies.
I've tried numerous editors in the past. Before PHP Storm, I was using Eclipse and Netbeans, bouncing back and forth. While both are excellent IDE's, I found both problematic on the memory side. I have a lot of code, large libraries, and a lot going on at work, so for me, I needed something that could offer up what an IDE did, but was still fast. But, more importantly, it had to be cross platform. I want to take my tools with me, so having Mac, Linux, and Windows support was a requirement. Hope you like it. They offer a generous trial period, and version 2 is coming out soon with some really nice features. It's by the same guys that do IntelliJ, and it's top notch.
You can re-invent the session by setting your own cookie and storing your own data in a DB or memcached, but why the fuck would you want to do that? ;)
Do you mean on the client or the server?
What you sir have encountered is a fundamental limitation of PHP as a language. If you want objects to persist between sessions you have exactly two options: 1. Serialize them and unserialize them when you need them, whether it be via memcached, apc, sessions, mysql, etc. 2. Switch languages; Java's web model supports these things, I'm not sure any other languages is. .NET's may be. EDIT: however, if you REALLY want objects to persist between requests, you get the fun stuff dealing with many requests accessing the same object at the same time, which means you'll have to learn how to write threadsafe code, if you don't know already.
I think applications work better when you don't try and hack them into holding state. Look at ASP's much loved __VIEWSTATE, oh, I did I say loved? I meant hated. I'm sure whatever you want to do is achievable without holding the state of you're application between requests.
Put the team names into an array, and try something like that $teams_array = array( 'A' =&gt; 'Team A', 'B' =&gt; 'Team B', ); echo '&lt;select name="edowner" value="' . $playerowner . '""&gt;'; foreach( $teams_array as $tkey =&gt; $tval ) { printf( '&lt;option value="%s" %s&gt;%s&lt;/option&gt;', $tkey, ( $tval == $playerowner ? 'selected="selected" : ''), $tval ); } echo '&lt;/select&gt;';
Here's how I'd do it, slightly different style to mapbuh, but otherwise similar. $selected_team = 'b'; $teams['a']='Team A'; $teams['b']='Team B'; $teams['c']='Team C'; if (isset($teams)) { echo '&lt;select name="edowner"&gt;'; foreach ($teams AS $key=&gt;$team) { $selected_team==$key ? $sel='selected' : $sel=''; echo '&lt;option value="'.$key.'" '.$sel.'&gt;'.$team.'&lt;/option&gt;'; } echo '&lt;/select&gt;'; }
Slight modification of this (you used single-quotes inside single-quotes, which won't work): $selected_team = 'b'; $teams = array( 'a' =&gt; 'Team A', 'b' =&gt; 'Team B', 'c' =&gt; 'Team C' ); echo '&lt;select name="edowner"&gt;'; foreach($teams as $key =&gt; $team) { $selected = $selected_team == $key ? ' selected="selected"' : ''; echo '&lt;option value="'.$key.'"'.$selected.'&gt;'.$team.'&lt;/option&gt;'; } echo '&lt;/select&gt;'; 
.
It can be either, but I prefer `selected="selected"`.
I don't think SELECTED alone is valid markup.
Depends on wether you're validating against regular HTML or XHTML. For XHTML it's selected="selected", as XML doesn't allow attributes with a value (although the value can be empty). All other HTML versions does however allow this (as they're not aiming to be valid XML).
Thanks, learned something!
One thing I do is put the space inside the variable so it doesn't mess up my formatting of all my non selected elements. e.g. $selected="selected"; &lt;option value="value1" &gt; &lt;option value="value1" selected&gt; $selected=" selected"; &lt;option value="value1"&gt; &lt;option value="value1" selected&gt;
Lose the echo statements and make sure you're outside of the PHP tags to start with. Also, there's another syntax that can come in handy here. &lt;?php // some code to initialise $playerowner ?&gt; &lt;select name="edowner" value="&lt;?php echo $playerowner ?&gt;"&gt; &lt;option &lt;?php echo $playerowner == 'A' ? 'selected' : '' ?&gt; value="A"&gt;Team A&lt;/option&gt; &lt;option &lt;?php echo $playerowner == 'B' ? 'selected' : '' ?&gt; value="B"&gt;Team B&lt;/option&gt; &lt;/select&gt;
I assume you mean persistent objects. The simplest answer is no, not even using session, because the PHP interpreter executes your code and then exits, so no actual objects can survive between requests. There are ways to emulate object persistence -- you can use the automatic persistence of objects in session data, or you could roll your own, using some other way to store the data.
Now we're getting into personal preferences, so I'll just a my $0.02 solution: &lt;?php // ... $teams = array( 'A' =&gt; 'Team A', 'B' =&gt; 'Team B', 'C' =&gt; 'Team C', 'D' =&gt; 'Team D' ); $teamSelectHTML = &lt;&lt;&lt;EOT &lt;select name="edowner" id="edowner"&gt; EOT; foreach ($teams as $teamID =&gt; $teamName) { $teamSelected = ($playerowner === $teamName) ? ' selected="SELECTED"' : ''; $teamSelectHTML .= &lt;&lt;&lt;EOT &lt;option id="team_{$teamID}" value="{$teamID}"{$teamSelected}&gt;{$teamName}&lt;/option&gt; EOT; } $teamSelectHTML .= &lt;&lt;&lt;EOT &lt;/select&gt; EOT; ?&gt; Some folks love it, some hate it.
I'd have the stuff in an array, but I wouldn't be using printf, as my select box would be in a template. So in my template (you don't have to use short tags but I think they are awesome and should be brought back): &lt;select name="edowner"&gt; &lt;?php foreach( $teams_array as $k = $v ): ?&gt; &lt;option value="&lt;?=$k?&gt;"&lt;?=( $k == $playerowner ? ' selected' : null )?&gt;&gt;&lt;?=$v?&gt;&lt;/option&gt; &lt;?php endforeach; ?&gt; &lt;/select&gt; But really, which you prefer depends on your style - this example uses PHP purely as a template, whereas mapbuh's may end up looking cleaner. Printf/sprintf/etc are nice functions and you should use them a lot. My personal preference is to as much stuff in the template outside of the `&lt;?php ?&gt;` tags, but in some cases it is a lot cleaner to do it within the, purely because of the "overhead" of the &lt;?=?&gt; or &lt;?php echo ''?&gt; etc. For instance, this may end up being cleaner: &lt;select name="edowner"&gt; &lt;?php foreach( $teams_array as $k = $v ): ?&gt; &lt;?php printf('&lt;option value="%s"%s&gt;%s&lt;/option&gt;', $k ( $k == $playerowner ? ' selected' : null ), $v ); ?&gt; &lt;?php endforeach; ?&gt; &lt;/select&gt; Either way, here's a comparison: http://imgur.com/hXrAG.png
The isset is unnecessarily because if you are passing data to a template, you should be setting up `$teams = array();` first, regardless of whether it gets populated. And if you're setting up an array initially, the `$array[ 'key' ]` syntax is a waste of code, and repetitive. Also doing echo is really ugly.
This is mind fucky and bad to maintain and slow and unclear.
Depends on what is being referenced. But yes, selected along is fine for HTML.
Here's a PHP 5.3 way: &lt;?php $name = "selection"; $values = array( 1 =&gt; "one", 2 =&gt; "two", 3 =&gt; "three", ); $default_value = 3; $html = makeselect($name, $values, $default_value); print "$html"; function makeselect($name, $values, $default_value = false) { $callback = function(&amp;$value, $key, $default_key) { $value = sprintf(" &lt;option value=\"%s\"%s&gt;%s&lt;/option&gt;\n", $key, ($key === $default_key ? ' selected="selected"' : ''), $value); }; $html = '&lt;select name="' . $name . '"&gt;' . "\n"; array_walk($values, $callback, $default_value); $html .= join("", $values); $html .= "&lt;/select&gt;\n"; return $html; } Output: &lt;select name="selection"&gt; &lt;option value="1"&gt;one&lt;/option&gt; &lt;option value="2"&gt;two&lt;/option&gt; &lt;option value="3" selected="selected"&gt;three&lt;/option&gt; &lt;/select&gt; Might need a fancier method if you need to be able to apply arbitrary classes or ids to the selects (for styling). I used sprintf 'cause it's easier to read. If you use . concatenation it's about 10% faster, not that microimprovements like that really mean anything. Heh.
What is this blasphemous use of heredocs? 
Well, this is strange indeed. I wrote and tested a solution that was simple enough, but damn if it doesn't reveal some strange, strange behavior in Firefox/Firebug. It works as expected in Chrome. $teams = array('A','B','C'); $playerOwner = 'B'; echo "&lt;select&gt;\n"; foreach($teams as $team){ echo "&lt;option "; if($playerOwner == $team){ echo "selected ";} echo "value = '$team'&gt;Team $team&lt;/option&gt;\n"; } echo "&lt;/select&gt;"; What happens in Firefox is that team 'B' is not selected, and mysteriously, firebug shows the second option as `&lt;option selected="selected" value="B"&gt;Team B&lt;/option&gt;` or something else -- I turned off firebug and used ctrl-u to verify that what the browser is getting is what I wrote. When I turned it back on, I got that. Before, it was messing up in a different way, on the same line, right after the `selected` attribute. Totally WTF. EDIT: Fixed it by changing the 'selected' line to this: ` if($playerOwner == $team){ echo "selected = 'selected' ";}`
This. It bugged me when I ommited it and firefox wouldn't present it as expected. My test page was had no other markup -- just that select block -- and FF treated it like xhtml. And so did firebug, because even though I wrote `&lt;option selected value = ...` Firebug showed `&lt;option selected = "" value = ....` 
And apparently, if FireFox doesn't see a doctype declaration, it treats the page as xhtml when it comes to &lt;option selected... and it won't select the option as the default. 
&gt; The isset is unnecessarily because if you are passing data to a template, you should be setting up $teams = array(); first, regardless of whether it gets populated. Ideally yes, but is it not good practice to check something exists before you use it? &gt; Also doing echo is really ugly Really? I thought it was clear, simple and easy to read, especially for someone new to PHP. Compare: $selected = $selected_team == $key ? ' selected="selected"' : ''; echo '&lt;option value="'.$key.'"'.$selected.'&gt;'.$team.'&lt;/option&gt;'; vs printf( '&lt;option value="%s" %s&gt;%s&lt;/option&gt;', $tkey, ( $tval == $playerowner ? 'selected="selected" : ''), $tval ); 
For XHTML, that's the way it's supposed to work. So make sure you use the correct DocTypes!
Mindfucky, yes. Hard to maintain, no. Slow, no way. Heredoc may be ugly, but the tokenizer loves it. Same goes for bracketed variables within double quotes. Don't take my word for it. Run test dat shit.
In this situation, it doesn't matter TOO much, however if you consider things like localisation and have to have a string like. Welcome, &lt;username&gt; - how are you today? And you have that in constant like L_WELCOME. `L_WELCOME` can be something like `"Welcome, %s - how are you today?"` and then when you use it: `printf( L_WELCOME, $user );` As opposed to ?!?! String formatting is excellent as it allows for separation of content and data.
But then how is this any good for templates, that are supposed to be as close to HTML as possible? Not many people are familiar with the &lt;&lt;&lt;HEREDOC syntax, and mindfucky != maintainable, especially to someone who has not seen the code before. Also, why would you bother using it on single line, static strings? Furthermore, it breaks indentation horribly.
selected="selected" is the proper xhtml super strict way of doing things indeed. Why did you edit your comment to "." so nobody else could learn from it? Its ok to look stupid on the internet....
it was completely wrong, I didn't want to mislead anyone
lots of ways to do this, but you might want to try /r/phphelp for help
I was able to do exactly what I wanted to do with [this code](http://www.ozzu.com/programming-forum/echoing-the-pre-selected-value-dropdown-menu-t92971.html). Thanks to everyone who was able to provide some insight! I learned a lot.
mapbuh has the best solution but you should stick an iif function somewhere in your code it cleans up clustered if statements nicely stick something like this somewhere in your code: function iif($condition, $true, $false ) { return ($condition ? $true : $false); } then you can use: echo "&lt;option".iif($playerowner == "A", " selected","")." value=\"A\"&gt;Team A&lt;/option&gt;"; echo "&lt;option".iif($playerowner == "B", " selected","")." value=\"B\"&gt;Team B&lt;/option&gt;"; echo "&lt;option".iif($playerowner == "C", " selected","")." value=\"C\"&gt;Team C&lt;/option&gt;"; 
What surprised me was that this happened with nothing but the select block on the page. No doctype, no html tag, no body tag. Chrome didn't care. 
Why not just use the ternary statements themselves instead of wrapping them in a function? echo '&lt;option' . ($playerowner == 'A' ? ' selected' : '') . ' value="A"&gt;Team A&lt;/option&gt;';
Maintainability. Imagine you have an application with 100 drop downs. If you wanted to extend the functionality of 'iif', it's much easier to do it once rather than searching through the code base for every drop down. 
 &lt;?php function dropdownoptions($selected,$options) { $output = ''; foreach($options as $option) { $tsel = ''; if(strtolower($selected) == strtolower($option)) $tsel = 'selected="selected"'; $output.='&lt;option value="'.$option.'"'.$tsel.'&gt;Team '.$option.'&lt;/option&gt;'; } return $output; } $options = array('A','B','C','D'); $selected = 'A'; ?&gt; &lt;select name="team"&gt; &lt;?php echo dropdownoptions($selected, $options); ?&gt; &lt;/select&gt;
And you discover the difference between HTML and XHTML :-)
That's why you write a function to render select boxes/drop downs. But writing a function (the example's `iif($cond, $true, $false)`) that's simply a proxy for a ternary statement (`$cond ? $true : $false`) doesn't make sense. It's unnecessary overhead.
So what happens when you have multiple plugins with the same method names? It seems like the app won't know which one you want, and will just call the first one it finds.
That's what is so frustrating about certain frameworks in the Flex/AS3 community (I'm looking at you Cairngorm and PureMVC). Framework communities don't seem to be able to understand that adoption comes from ease-of-use/initial investment , and examples that show how it can help the proverbial "me" solve my problems.
The type restriction goes in the constructor signature where you'd pass the object in in the first place.
Maybe I misunderstand what you're saying here, but you can make classes in php.
From the point of view of defensive programming, you can use the instanceof operator to enforce types in setters and getters: * http://php.net/manual/en/language.operators.type.php From the point of view of declaring expectations, you can use some sort of a commenting system metalanguage: * http://manual.phpdoc.org/HTMLSmartyConverter/HandS/phpDocumentor/tutorial_tags.var.pkg.html
 class Car { private $_engine; public function setEngine(Engine $engine) { $this-&gt;_engine = $engine; } }
 class Car { protected $engine; public function setEngine(Engine $engine) { $this-&gt;engine = $engine; } }
... followed up by: /** * @return Engine **/ public function getEngine() { return $this-&gt;_engine; } Worthwhile IDEs will read the phpdoc comment and provide proper autocompletey goodness for you. Do note that creating getters and setters for everything is a pain in the ass and can mostly be avoided for code that's purely internal to the project. If you're writing a library or code that others may eventually work with, then it might possibly be worth creating getters and setters.
Im sorry , I meant can you do something like this. Which is demonstrated by the "turnOn" function. Can you then reference , and invoke a method on the object , or reference or interface ? class Car { protected $engine; public function setEngine(Engine $engine) { $this-&gt;engine = $engine; } public function turnOnEngine() { $this-&gt;engine-&gt;turnOn(); } } 
Yes. This is quite fundamental if you're going to support any form of objects in a language. I would strongly suggest at least playing around a bit with PHP along so you can see what works and what doesn't - asking if something works can be answered by a compiler.
Java APIs probably use cookies(because maybe it would otherwise be impossible), so calling it sloppy is not a smart thing :)
This works just fine, although it's not the way I'd do it. You have to take into account the fact that the variable may not be set, since trying to run a method on a non-object is going to cause a fatal error. class Car { protected $engine; public function setEngine(Engine $engine) { $this-&gt;engine = $engine; } public function getEngine() { return isset($this-&gt;engine) ? $this-&gt;engine : false; } public function turnOnEngine() { if(!($engine = this-&gt;getEngine()) throw new Exception('Unable to retrieve engine to turn it on'); $engine-&gt;turnOn(); } }
&gt; can you do something like this Yes. In fact, your syntax is perfectly correct already. Is something not working properly for you? If so, we'd probably need to see the actual code you're using that isn't working.
No , it was just me being stupid. The nuances of php got to me and I didn't really think straight. Generally , if I have a question on how a particular method or technique works , I'll make some test code. For some reason , I couldn't see the forest for the trees and didn't take the smart , easy , responsible route. Especially since I demonize people who do the same thing on the Flex/AS3 boards. Thanks for your help folks.
What you are also missing is autoloading of classes. If you have the class Engine defined, there is a mechanism in PHP to allow the declaration of a class type, then the interpreter goes and finds the class definition and autoloads it based on a namespace. The PHP ORMs use this a great deal.
It depends what you want to make persistent. True persistence doesn't currently exist within PHP. Almost anything that implements persistence (as of PHP 5.3) generally just serializes the class/variable/etc into a string and stores it in memory. Anything with a "resource", is more-or-less impossible to serialize, although the mysqlnd library manages to pull this off internally by creating a zval cache outside of the reach of RINIT/RSHUTDOWN functions. If you look at the APC or memcache extension source, they serialize and unserialize, which is generally quite quick. I heard one of the pushes in the next Zend engine is to have the ability to easily create zval persistence across requests, but for the time being using memcache or APC is your best bet. If you're going to go the session route, it's worth it to make sure you're using memcached as your session engine, otherwise you're going to take a performance hit from storing any amount of data in a flat-file. 
No, what I "discovered" is that FireFox/FireBug *assumes* an XHTML doctype when none is specified, while Chrome assumes HTML. That code is the *entire page* I tested. FF treated it as XHTML in regards to the 'selected' attribute. Firebug added an `=""` fragment. Browsers are typically very forgiving of invalid code. Chrome didn't expect a name-value pair for the 'selected' attribute. FireFox/FireBug did. That's a little wierd, if you ask me. 
actually it should be more like this class Car { private $_engine; public function setEngine(&amp;$engine) { $this-&gt;_engine = $engine; } public function &amp;getEngine(){ return $this-&gt;_engine; } } It's very important to use the &amp; symbol when you need the [reference](http://php.net/manual/en/language.references.php), not the data.
It's not, all objects are passed by reference in PHP 5.
on top of type casting in the function you can specify type in docs, which doesn't do anything for code, but helps your IDE understand what kind of variable something is and can properly auto complete for it, like this: class Car { private $engine; private $cylinders; /** * * this function sets an engine * * @var Engine $engine The engine in the car * @var int $cylinders The amount of cynlinders * @return bool */ public function setEngine(Engine $engine, $cylinders) { $this-&gt;engine = $engine; $this-&gt;cylinders = $cylinders; return true; } }
Flat files shouldn't have any significant performance hit as long as they fit into memory. In newer versions, `file_get_contents` is just a wrapper around mmap.
That's not very PHP-y. private $_engine; function __get($var) { return $this-&gt;{"_$var"}; }
What jack9 is saying that your class won't automatically discover an engine class unless you have __autoload defined. I generally do this in some sort of init.php file. Something like this would automatically discover Engine.php if you made a new Engine instance. A simple example would be this: function __autoload($class_name) { require_once $class_name . '.php'; } http://php.net/manual/en/language.oop5.autoload.php 
PHP has no compile-time type checking whatsoever. It has a feature (as already suggested by others) which is called "type hinding" and can be used for the arguments of a function, like this: public function setEngine(Engine $engine) { $this-&gt;engine = $engine; } **However, this won't be checked until run time**. So, it won't actually give you the security you are looking for.
Thanks linepogl , that is one of the "crutches" I was looking for. On the flip side , php doesn't have those never-ending build times of Java. So when I make a change , I can get straight to it.
\_\_get and \_\_set do not replace getters and setters... if you're going to do it that way, you might as well use a public member.
There are [interfaces in PHP](http://php.net/manual/en/language.oop5.interfaces.php) So you could write your classes against an interface, then check that the object passed implements that specific interface.
I was going to downvote you, but then I realized that your code unfortunately is very PHP-y :( 
&gt; public function getEngine() { &gt; return isset($this-&gt;engine) ? $this-&gt;engine : false; &gt; } While I've done this many times, I hate it. Isn't it better to always return an engine (or throw an exception) so you don't have to do alot of testing in your code?. Something like this: public function getEngine() { if(!($this-&gt;engine instanceof Engine)) { $this-&gt;engine = new Engine(); } return $this-&gt;engine; } if you can't somewhere else (like in the constructor) guarantee the construction of a proper $engine object. Maybe I'm getting spoiled (damaged) by jQuery, but I just love doing stuff like this now: $car-&gt;getEngine()-&gt;TurnOn()-&gt;Accelerate("100MPH"); you can't do that if the getter can return something that isn't an engine object.
Valid points, and I didn't mean to imply that the way I showed was the only way. To be honest I think it really depends on the situation- if the engine is something that should be set before the class is used then by all means put the exception in the getting itself, but if you want to allow the coder to decide exactly how to deal with the error then I recommend just returning false. 
I'm not too familiar with the Zend framework, but typically, Models represent the Data. Does your app not have Data?
The difference is that his way makes the variable read-only from outside the object.
Model-View-Controller. No models means, View-Controller. Which is not MVC. It's perfectly ok to not use the MVC pattern if you don't want to. I'm just pointing it out since you mention you totally get MVC. The design patterns you use should be based one what's best for your application. If you're application benefits from not having any models, don't have models. I've seen crazier things. Otherwise, learn how to make models.
I'm not 100% sure I follow your train of thought and I'm not very familiar with Zend. Typically you need a model to store the data and sometimes it's tempting to add Data-Manipulation (Controller) and Data-Representation (View) stuff into the model itself, instead of creating those two extra classes. Again, I'm no expert. But I try to look at it that way... * Do you always need access to the manipulation methods when exposing the model? * Do you always need access to the representation methods when exposing the model? If the answer is yes on both counts. Then I'd say it's safe to just build one class. Otherwise you're exposing methods to parts of your code where you never need to use them. In my personal opinion, if you're going MVC... you might as well go all the way. Just pick a pattern that suits your application and your coding style.
Technically you _can_ just put all of your model logic into your controller and communicate directly with the database / data access layer, but why would you? It's just going to result in a lot of code repetition. This is why you put methods in your models-- to avoid duplicating data logic in your various controllers.
Sure, sometimes I have a model object that is a simple wrapper around some SQL and returns an array of rows. Then calling my 'model' is just: $user = my_users::get_one($name); class my_users { static function get_one($name) { .... } } ZF model is grim, take a look at Doctrine, I switched and was much happier. It takes a bit of investigation on how to integrate it but the effort is worth it.
It does use data. I was just having a hard time doing it the Zend way. I know how to use models in say Rails. But, as I am still learning Zend, was getting frustrated with the many different ways to access models. 1AM in the morning I finally figured it out. So, I will be using Models.
Much agree. Finally figured out how to use Zend with models and I think it'll be a much smoother ride now.
Thanks for the tip. I may just see how that is done.
you're == you are If you are application benefits!?
If you're having a hard time doing it the Zend way then maybe Zend isn't the right framework for you. I personally think it is terrible, but it's developed in a way that lets you use its components in other frameworks so you don't lose some of its functionality. Try a framework like Kohana. It won't "wow" you with its features, but I really like that it's fairly small, structured without being confining, and easy to extend in any way you want. There are lots of tutorials for working with Zend objects from Kohana.
Only when I'm prototyping... everything gets moved into the model afterward to make future code changes easier. I just found that while prototyping trying to define and re-define and re-define the model's interface is annoying. Basic rule I go by is that if you ask for (approximately) the same info in two different places it's time to move it to the model. 
Zend doesn't provide models because it expects you to provide your own. Your application will have models regardless of whether you use a framework or not. Ever used a Flickr API class? That's a model. Ever created a class to open a text file and read and write data? That's a model as well. What you're asking for is not "how do I work without models" it's "what are some good DB access libraries" or "how do I work with Zend_Db." Zend takes the definition that a model is any class related to retrieving or storing data and specifically doesn't provide any integrated "Zend_Model" classes to force you, as the developer, to really sit down and think how you organize your data retrieval. It also does this because it knows that "Model" doesn't just refer to a RDBMS access library, but also refers to API classes etc. and doesn't want to confine you to a narrow worldview. **tl;dr** Stop using the word "models" and start being more specific, you'll find your questions much easier to deal with than the abstract and loose world that is "models".
 class Car { /** * This holds my engine * @var Engine */ private $engine; //stop using _, it isn't necessary anymore public setEngine(Engine $engine) { $this-&gt;engine = $engine; } /** * Get the car's associated engine * @return Engine $engine */ public function getEngine() { return $this-&gt;engine; } } The docs are understood by most IDEs and that gives you sufficient type hinting.
Not really that big of a deal, but you can't undo a vote. Either upvote or downvote can't reset to no opinion. Has some potential, I'm going to be following it =)
like it matters. Anybody with any skills could download your encoded source and then run it through php with the decoder installed and just "print" out the original code right before php loading. If somebody wanted to, they could even make it an installable php module (perhaps it already is). The only security seems to be in the service you provide, not the code itself.
No. But what you want is currently in PHP trunk, slated for PHP 5.4, PHP6, PHP42 or what it will be called when the time comes. The feature is named array dereferencing.
It's a limitation of the language, but [things should improve soon](http://schlueters.de/blog/archives/138-Features-in-PHP-trunk-Array-dereferencing.html).
Fiskfisk's answer is correct, but you could do this: echo reset($keys[0]); `reset()` sets the internal array pointer to the first element and returns its value. `end()` will do the same, but with the last element in an array.
[`list`](http://php.net/list)`($key0, $key1, /* skip 2 */ , $key3) = array_keys($b);` It's an easy feature to miss, but pretty useful.
If you want to hack-in your own solution for now so that you don't need to create a temporary variable, you can write a function that will return a particular index of an array, then use that to dereference. function i($array, $index) { return $array[$index]; } Use: echo i(array_keys($b), 0);
*facepalm* this is such a simple idea, but it had never occurred to me. Thanks! :)
Bonus points if you never use it on function return values: Good: reset($someVar) Bad: reset(someFunctionReturnsArray()); Or, you could never turn E_STRICT error reporting on and not give a fuck about forward compatibilty :)
Hahahaha. The comments. PHP developers tend to be so backwards \*Is a PHP developer\* 
E\_ALL does not include E\_STRICT? Why the hell is it called E\_*ALL*? Disregard my comment, then. :\
64bit php timestamps are still limited to 32bit length. fyi...
I know, right? From php.net &gt; In PHP 5 a new error level E_STRICT is available. As E_STRICT is not included within E_ALL you have to explicitly enable this kind of error level. Enabling E_STRICT during development has some benefits. STRICT messages will help you to use the latest and greatest suggested method of coding, for example warn you about using deprecated functions.
This has been brought up recently on the internals mailing list. Doesn't quite make sense, does it? It has been proposed that we a) *fix* E\_ALL to actually mean *all*, or b) add an E\_EVERYTHING.
I'm running 64-bit PHP on a 64-bit OS. root@gerty:~# php -a &lt;?php var_dump(strtotime("01-01-2222")); int(7952342400) 
The best answer is to deconstruct other libraries that do something similar to yours, such as Doctrine, PEAR::PDO, etc. You'll get a better idea on how high-use systems tackled similar problems to you, and will more easily absorb it since you've worked on the problem yourself and tried to come up with your own answers.
Without having an indepth look, I can make one recommendation. The benefit of PDO is that it is a database agnostic wrapper to creating connections and making queries. The problem with your approach is that you're hard coding MySQL functionality into your class, which may make sense at this stage but if you wanted to port your apps to another backend then you need to rewrite your classes. I'd recommend that you make a more abstract connect method that takes two parameters, an adapter and a settings array, then your connection code looks like this: $connection = new dbmcPDO("mysql", array("database"=&gt;"xxx", "username"=&gt;"xxx","password"=&gt;"xxx")) Then in the connection method, load in an adapter specific class - you only have to build the mysql one for now, but if you want to add more later then you've made life easier for yourself. Even better would be to make a base abstract adapter class that defined all the common functionality and only use adapter specific code where needed.
Right out of the gate this looks like well commented, nicely formatted code. So good job there especially being newish without anyone yelling at you about it. It's a pleasure to read I guess is my point. &gt; $aStmtType = explode(' ', $aQuery[0]); &gt; $sStmtType = $aStmtType[0]; If you're going to try to parse sql like that you will run into issues, even with the most basic task like this. At the very least you need to strip leading spaces because they're allowed and some user will put them in for God knows why. You might want to look up a sql parser / tokenizer I know there are some good examples in Perl, they're fairly simple and can divide the query up into logical parts. &gt; $sStatement-&gt;bindParam(':' . $k, $v[0], $v[1], isset($v[2]) ? $v[2] : null); Personally I like using ? for params and passing all my args to execute, it just seems cleaner, but there's nothing wrong with that way, other than it's harder to read. Don't bind yourself to mysql or a single dbms, make that configurable. Good use of try catch, good cleanup. I don't have anything to complain about, as far as code goes this is not below average. Good start!
The fact that you can write your own classes, understand PDO, and actually comment your code puts you ahead of about 90% of php developers. Good Job!
What sort of business do you work in? I find what makes the best developers is not having great mentors, but learning from experience and example. Having to deal with your code six months or a year after you wrote it, and to understand how it isn't performing optimally is incredibly valuable. For the first few years of my career my position was to fix/update/rewrite bad code contractors had written. The problem with people telling you to learn by example is that it isn't always clear when you're starting out what is good code and what isn't. PHP is notoriously bad at proving this; there are a huge number of code examples in the PHP manual that are terrible. Your goal shouldn't be "I want to be a good PHP coder.", it should be "I want to be a good programmer." Personally I have always avoided PEAR. When I first started out, I was always concerned about portability and used large database wrappers. The fact is if you're using MySQL, switching to another database is going to take more work than just changing which database engine you use in PDO, so you may as well take advantage of the spectacular new mysqlnd library (in PHP 5.3+) written in C instead of a PEAR library or the somewhat dated PDO mysql library. Hell, write your own wrapper. It would be good practice. If no one reinvented the wheel, we'd still be using stone wheels. Write code whenever you can and try to find a use for it. Come back to it in a year from now and find your design mistakes, and make note of how you would develop it differently now. The fact that you doubt yourself means you care. You are capable of being a great developer, and there aren't that many out there. 
Unless you're only reading one file, mmap doesn't avoid fs stat calls which can be a huge performance issue when scaling, it also has to look up the cache in a potentially large hash table each time. Theoretically your operating system/file system should cache repeated stat calls, but since most operating systems aren't tuned very well, it's hardly good advice to claim that file_get_contents wont have performance implications at scale. If you're going to be reading and writing data to a persistent source on every request, and it's transitory data, use memory.
Why would you abstract PDO? Looking at the code: * It locks you to MySQL * It doesn't actually seem to do much apart from wrap PDO. Here's my database object returnifier: http://github.com/radiosilence/core/blob/master/controller.php#L10 It assumes that the calling code (in the actual controller itself) is at least partially aware of the DB it is connecting to (IE so you can pull in an MSSQL database when working with PDO).
&gt; Why would you abstract PDO? Without having looked at the code posted: There's often a good case for adding *convenience* methods to any database adapter. For example, I always find uses for the following: - Perform the query and return the last auto-generated ID - Query and fetch the first column from the first row of the result - Query and fetch the first row as a numbered array - Query and fetch the first row as a hash - Query and fetch the first column of all rows - Query and fetch all rows in a numbered array, each row as a hash - Query and fetch all rows in a hash using the specified column name as the key With the exception of the last auto-generated ID, all of these are database agnostic. 
dude... everything is difficult when there's no bar. I mean come on - where are you gonna cruise chicks?
"How do you architect in PHP?" "I don't"
If you need the 0th, 1st or last element but not the **nth** element, this will work in most cases: echo current(array_keys($b)); //first element echo next(array_keys($b)); //second element echo end(array_keys($b)); //last element 
Kohana is fine if you already understand OOP and how frameworks function, but they horrible documentation and lack of examples is a killer, even for those who know. You have to spend a lot of time looking at the code to figure things out. If you're starting out, CodeIgniter is the best framework to go with, and it's good to stay with if performance is important (consistently wins benchmark tests compared to other PHP MVC frameworks). Besides, CodeIgniter 2 is coming out very soon (been using it already, you can find it on GitHub), and it drops PHP 4 support and has some much-requested features that have been grabbed from Kohana, like drivers.
If you're _starting_ out with web development, then PHP would be the obvious choice. Countless code examples, applications, snippets, forums, guides, resources, etc. available online, and every host supports it out of the box. I could see adding Python or Ruby to your arsenal after you're fluent in PHP, but not as a starting point.
LOL , bad joke ... When you first see an weakly typed language , it is unsettling. But the rules still apply , layering and separation of concern.
Maybe put the configuration logic in its own class so you can reuse it elsewhere. In the config I would replace $db_config[s_address] and $db_config[s_db] with just $db_config[s_dsn].
&gt; so you may as well take advantage of the spectacular new mysqlnd library (in PHP 5.3+) written in C instead of a PEAR library or the somewhat dated PDO mysql library. Everything I've read doesn't show a major advantage for mysqli over pdo, do you have something I can review that says otherwise? I haven't benchmarked it myself. I've always thought the advantage to using PDO or some other abstraction layer is that your product can use different a dbms based on customer preference, not that you could change it later and migrate data. Maybe it's a little of both. Thoughts?
Blah. I do not care about types. weak/strong dynamic/static have their advantages. Architecting PHP is like cooking haggis. There's no way to make it good.
Doubts like these will lead you to enlightenment! Even without looking at your code I'd like to recommend you to go and work in some company where you can get influenced by others of your kind. There's no absolute wrong or right in programming (especially not in PHP!) but there are lots of opinions. When you can take into account multiple views while designing programs and solving problems you'll automatically become better at your craft. Another concrete thing for you to do is start to use some *opinionated* framework. You'll learn some specific way to do things and it's quite easy for you to find out if you're going against the grain i.e. you start to feel the awkward.
The last time I used PDO it was a 160kB Pear library written in mediocre PHP. Now that PDO is a proper C extension, I doubt you'll see a noticeable difference until you scale. mysqlnd has less overhead and memory usage, and also supports true connection persistence, it's relatively new but I think it will only get better. I think you can make PDO compile with mysqlnd support as opposed to mysqli, so maybe it's moot. At any rate, you can use database abstraction to work like a hot-pluggable storage layer, but it means you're never really using any database as well as you could natively. Each database is going to require different query optimizations and what scales well on one could fail catastrophically on another. Unless you have a solid reason up front to use an abstraction layer, there's no real reason to do so other than convenience, which is fine; just don't think using a database abstraction layer makes it any more portable. The chances are that the SQL you write will have much higher implication on performance than your abstraction layer. To be honest, even when I write specifically for MySQL I use a small wrapper I wrote purely for convenience. Additionally something I've been doing for a while now is to have two database objects (like $db_r and $db_w) and I split up my queries based on whether they write, or need to avoid possible replication lag. When I doing small things I just do $db_w =&amp; $db_r; and if in the future I need to split my queries up I can actually instantiate separate objects.
In "fetchConfig($sAlias)", I see you have a lot of return statements with most being false (the last return statement you can't even execute). Stylistically I prefer to have a single return value (this isn't always easy), but in this case a variable at the top set to the default "false", a single assignment for the true, and a single return on at the bottom. private function fetchConfig($sAlias) { $wasFetchSuccessful = false; if(isset($sAlias)) { $sAlias = $sAlias."_"; $sFile = 'configs/config.do'; if(file_exists($sFile)) { require($sFile); $array = $sAlias ."db_config"; $this-&gt;_aCD = ${$array}; $wasFetchSuccessful = true; } } return $wasFetchSuccessful; }
Huh? What does this have to do with my LOLCATS blog?
Your doc comment for commit() is wrong (it doesn't always return true). I'm leaving my desk now, but my immediate impression on reading the code was "why?"
Sometimes, it's just a better idea to validate stuff and return false at the beginning of the function instead of getting in a pile of nested if statement. As long as you use the same style everywhere, I think it's all good...
My preference would be; if foo == True: if bar == True: if baz == True: return True return False leave off the else completely. If all the conditions are met, we hit a return True. If any fail we drop out of our conditionals and the return False at the end of the function kicks-in.
That is a very valid point and have run into that exact case before multiple times. On micro controllers you'll sometimes find multiple return statements faster (or produce smaller code). When in doubt I go with whatever I think is most understandable/easiest to read.
Actually your example could be improved to: return ((foo == True) &amp;&amp; (bar == True) &amp;&amp; (baz == True)) At least it would in C++, I haven't programmed in PHP in a couple years, but you get the idea. I have found that depending on your language and debugger, your example may actually be easier to single step through and debug as mine would be a single step. Coming to that realization when looking through some old code made me think a bit differently about writing software.
In terms of coding conventions: * I've never worked on a PHP code base that used Hungarian notation. * PHP class names should be in uppercase: DbmcPDO, Dbmc or even DBMC might be better. * The underscore for private / protected is more appropriate for PHP 4 code, though this is a personal preference. * Single line `if` statements are asking for trouble (line 73). In terms of actual functionality. * Printing errors messages to stdout is never, ever an appropriate side effect of any function. Use user_error() and return false or throw an exception. * You don't need to wrap a single query in a transaction. It will either succeed or fail. By using transactions at such a low level you've painted yourself into a corner, as you now can't wrap higher level functions (e.g. such as a method that does a dozen inserts that must *all* succeed) in transactions. You need a little work, but obviously have a decent grasp of the basics/intermediates principals. Good luck.
To clarify, since I've seen this twice in this thread: PDO isn't related to any of the PEAR database libraries. The API similarities to PEAR DB and MDB2 are really just because there aren't that many ways to write a database abstraction library.
mod_rewrite is what I use (Apache)