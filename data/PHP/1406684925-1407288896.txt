In more than two decades of being a professional, I have never seen another professional say that. Are you able to cite any legitimate source (ie, not a blog you google up) that takes this position, or are you just asserting opinions as fact?
No
This is not what I wanted. I'm a firm believer that six comes after five. Regardless, I don't always get what I want. (**Use tabs for tabs, ffs!**) I'd rather see the community move on and do cool things. Still, it would be remiss of me to not say something here. I am deeply concerned with PHP's direction at this point, and this vote is a good example of it, as are countless others. It feels to me that "internals" has become greatly divorced from userland developers. The majority of improvements to PHP have come from outside of PHP itself, and often in spite of PHP. I'm referring to the excellent frameworks available, the work of the PHP-FIG. I'm referring to Hack. I'm referring to Composer. To state brutally - I worry that PHP's internals has become a regressive and stagnant group, rather than one dedicated to improving the language. Not all of them, by all means. But too many. I mention this on this post as I think it's symptomatic. PHP6 never existed in userland. It existed only among internals. No developer developed with it. I worry that PHP will remain forever stuck in a mentality that clings to "backward compatibility" at the expense of innovation or improvement. I worry that PHP 7, major versions intended as a BC break, will instead just add a few new features... you know, so as not to break backward compatibility. I worry that some great features like static type hinting, generics, or proper annotations will never be available. I worry that php will never get a consistent or rational API. I worry that the userland devs are foaming for these features and changes and they're consistently rejected for reasons *I personally think* are inadequate. In fact these reasons often come down to "PHP does this horribly in other places and we should keep it egregious for consistency". Or backward compatibility. Most of all I worry that to develop as a programmer I'll have to learn Ruby. Please save me from that fate. I fucking hate those people. **Let me head off the responses pre-emptively:** 1 - Yes yes. Python 2 &amp; 3. We get it. 2 - Improvement doesn't have to mean the destruction of backward compatibility. Consistency and rationality could be something moved towards, rather than simply setting the language on fire and dancing in the ashes. 3 - Everyone in the PHP internals team **is** a better programmer than me. And probably better looking. 4 - I feel that between the desire for progress of developers and the desire for stability of the core of a major language, the focus is entirely on the latter. I appreciate that these things conflict, and I think they should. But that should mean only the best improvements happen. Not that none happen. 5 - Yes, improvements to PHP have happened, and some have been significant. But ones that progress the overall direction of the language seem to be languishing, and there seems to be no vision for consistent and rational API. 7 - I don't care what Rasmus thinks. This is a man who famously said "I'm not a real programmer. I throw together things until it works then I move on." Please stop treating him like a guru. And yes, he's still better than me. 
IT specialists manage physical resources, such as lans and printers. They clean up virus infections in labs. They maintain hardware. Sysadmins manage servers, almost always abstractly over the internet. They manage security, are responsible for uptime, monitor intrusions, keep backend software up to date. Their jobs are essentially always unrelated. It is not common for the same company to need both unless said company is enormous. (The reason people think you're on your second language is because you give off nearly exclusively a series of errors that is particular to Indian English. Eg "write beautiful codes," misuse of things like "e.g.," switching between British and American spellings of words, and great difficulty with basic capitalization and punctuation.)
Yes, they're said by the same kind of people who say "full stack designer." People who don't understand that the attempt to look important makes you look less important.
&gt; One of the opening lines says that "full stack developer" doesn't return anything on google. Except for 8+ million results. It's actually three hundred thousand, unless you accidentally search for every web page containing those three words separately. http://bit.ly/1qJCBmJ For reference, even full stack alone comes in less than one sixth that often. http://bit.ly/1tq79tJ . &gt; Everybody knows what a full stack developer is. The article author does not appear to.
Internals took to long to reach a wrong decision. What a half-assed, sorry episode.
Well if you want to go as deep as you are, then unless you're also a PHP internals developer, then you're infact, not a full PHP developer.
I run an entire consulting company around working with legacy code for the most part.
Great! You can almost hear the renewed premature book printing due to this very welcome premature versioning announcement.
Take that, you out-of-date-book-selling charlatans!
By 58 votes to 24?
The point of the vote was to get it behind us so we don't bikeshed later. i.e. precisely so we can get onto more important matters.
Yeah, like how CentOS's had 5.3 up until literally last month.
And announcing new versions before they're ready. (At least they're consistent)
Did I miss the joke? No wonder everyone shits all over PHP that's absolutely insane.
Can you guys not create a spin-off of PHP that addresses all the old issues, and also means that people can stick to PHP7 or switch to PHP Ultron if they want to migrate/upgrade?
&gt; You obviously seem very butthurt It's often pretty disappointing when someone chooses to begin by actively misreading someone else's tone to marginalize them. . &gt; So by stating you hire in San Francisco and asserting the fact that I do not know what I'm talking about is going to show dominance Actually, no. It's a way of stating why anyone would care what my opinion was, and why I was to be taken seriously. You know, that I'm not just some yahoo off the street, which is why I'm saying to you the same thing everyone else who has actually done this for a living is. Kind of like how if you give bad medical advice, and someone leads with "actually I'm a doctor and." If your interpretation of that is that they're trying to dominate you, then you've been involved in internet arguments for too long, and have lost track of why people actually say things. Do you poorly psychoanalyze everything you don't want to hear? . &gt; You say that Full Stack Devs are 4 different kinds. I said no such thing. Please quote when you're claiming I said something, so that I can explain to you whatever you're misunderstanding. I do not believe that full stack developers "come in four different kinds," and so I will not be explaining to you why I said the thing I didn't actually say. In general, it is poor form to attempt to speak for others; especially when you're not putting much effort into understanding them. . &gt; Unless, you're just here to flame, then good job. If I was just here to flame, then I probably would have flamed. That you haven't quoted any suggests that this is just posturing. . &gt; So you're saying, I'm supposed to create an out of this world custom CMS just to be able to blog? I didn't say anything of the sort. You seem to invest a lot of effort into inventing things people said, and then arguing with those. This suggests that you don't actually have much to say about what I really said. What I really said was "you shouldn't write teaching blog articles about things you don't understand." This has nothing to do with writing a CMS. No idea where that comes from. Similarly you probably shouldn't teach particle physics, nor political theory, nor other things you have no formal training in from real schools or practical experience in from the real world, unless you're at least able to back up your position with reference. Auto-didacts are more impressive when they can defend their position with reference material. When they can't, it's usually because they just don't actually know the things they think they know. Dunning, meet Krueger. . &gt; And my blog has low quality design. Oh wow, thanks for the injury. Er. If you're claiming to be a designer, and this is how you represent yourself as a professional, then yes, you should have good design. You know, kind of like if someone's claiming to be a programmer, and to teach everyone else what it means to be a programmer, and you look in the console and their stuff is spewing errors, and when you look at the source it's a bunch of mismatched tags and bugs, then maaaaaybe this isn't who to listen to about being a programmer. Yes, actually, when you claim to be an expert in a field, then do a poor job in a field, while attempting to act as an authority in a field, it is legitimate and germane to point out the low quality of their work in said field. . &gt; that's not a default theme of Ghost, but I'm sure you already knew that. Cause, you're from SF of course. And you hire. Are you taking the position that people who hire for software engineering jobs are all intimately familiar with the theme list of every minor blogging engine out there? No, I wasn't aware of that. That's why I talked about the problem like you didn't fix it, instead of that you caused it. . &gt; And font hierarchy, white space being unbalanced is not an issue with Ghost. It's an issue with me being the designer / dev of the theme. Ah. Well, that seems plausible. . &gt; (I was going for minimalism, if you didn't notice). Legitimate minimalism means getting as few differences into place as possible. Having differences in your white space and colophon margins is a form of complexity. If you are trying to defend your lack of being able to be uniform as "minimalism," well, I'm not entirely sure what you think minimalism is. What I said was "you have too many font faces, you used your fonts incorrectly, and your margins are irregular." Your response was "well I was trying to be minimalist." I don't entirely understand how to interpret that. Could you please explain how minimalism leads to too many margin sizes, too many font faces, and the incorrect use of a font stack? Thanks. . &gt; Oh wow, thanks for the injury. &gt; Note taken on the over-usage of emphasis. Thank you very much. Emphasis comes in more form than just difficulty with bold and italic. The way in which you paint yourself as a victim while you write is far more tedious and attention grabbing than the typefaces. . &gt; I'm sorry but I don't understand I confess I really just want this to be terminated here. . &gt; I'm sorry but I don't understand what you mean by putting emphasis before headers. You realize how this reads, right? * "I'm a full stack designer!" * "Dude there's no such thing, and here are some 101 design tips for you." * "You're insulting me by saying I'm not a designer! What does this basic design terminology mean?" Like. My favorite part here is that if you choose to interpret those terms as HTML, and just write what I said you had wrote, you will see it. Emphasis. The thing you were just apologizing for doing too much. Bold and italic. &amp;lt;em&amp;gt; and &amp;lt;strong&amp;gt;. Before a header. &amp;lt;h1&amp;gt;. Emphasis before a header. I don't know what there is to not understand here. You're violating the basic concepts of a font stack. This is seriously the very first thing you get taught in design school, is how to manage a font stack. Seriously, if someone claims to be a full stack car mechanic, and then you point out to them that mechanics don't use those words, that those words don't make sense for mechanics, and that their car isn't running very well so they probably shouldn't be giving car maintenance advice, like for example look here they haven't cleaned their spark plugs for ten years and they're mis-firing which is damaging the engine block, and they go "how dare you insult me by suggesting I'm not a full stack mechanic and also what is a spark plug," how would you react? If it was someone claiming to be a doctor, a lawyer, or an electrician, that person would go to jail. Ah well. . &gt; essentially at the end ... So I don't see why it's at the wrong position just because the height of the block is a little lesser than 1/3 the entire post. I mean. If you weren't a full stack designer, this would be a lot less hilarious. Also, if you weren't a Redditor. "I don't see why putting tl;dr at the 1/3 mark is dumb!" Okay. Because, y'know, when someone's looking for TL;DR, they usually look more than one paragraph past the end. . &gt; When I say developers commercialize, I meant, UI/UX. I sincerely hope the developers you hire know what those means... I have never heard any of the UI/UX professionals I've worked with call their work "commercialization." I'll ask one of them tomorrow. Then I'll explain why I asked. I'm sure that their college degrees and decades of professional experience won't matter to you either, and they'll just be dominating you by being confused by the weird claims you made without reference and saying "um, nuh-uh" too. There is, actually, something called commercialization in software. It's not even slightly related to UI/UX though. It's getting software ready for shelves (making a box and box art, a manual, getting the EULA ready, negotiation with Walmart, etc.) But hey, I guess probably the places where that was run by 30 person teams, they're just dominating you too by not immediately switching to some words you made up and asserted one day, right? Lol. I will happily go through the development staff that you sincerely hope know what that means tomorrow. What if none of them have ever heard that word used that way? . &gt; So you're saying developers don't... Test? You seem to have great difficulty understanding what's said to you. If someone says "you don't have to drive a car to be a full stack developer" and you hear "so no full stack developer drives," then you're kind of being obtuse. Yet again, I did not say this, no. I wish you wouldn't put so much emphasis on your first, pretty obviously wrong read. Most people, when they see someone else saying something improbable, say "maybe I misread this; I should try again," instead of scoffing and trying to criticize someone. . &gt; Of course I realize there's no "stacks" in design. Then why are you saying something which leads all listeners to believe you hold this confusion? This really seems like "yes, of course I know an automobile isn't driven by dragons." Then why did you say it? It's not a coherent metaphor. Why did you claim other people say this and that that's what the words mean? They don't and that isn't. (continued: too long)
You realize I'm taking the position that this isn't the way those words work, right? Feel free to downvote for disagreement, though.
It's worth mentioning that it's not just "internals" developers who get a vote. Everyone with project karma can vote on these RFCs. That includes documentation people, who are mostly a completely different group from the "internals" group. There is a fair amount of representation of the greater PHP community in the people who can vote - it just so happens that most of the people who have project karma are contributors to the source code.
I'd suggest error 405 "[Method Not Allowed](http://en.wikipedia.org/wiki/HTTP_error_codes#4xx_Client_Error)": &gt;A request was made of a resource using a request method not supported by that resource; for example, using GET on a form which requires data to be presented via POST, or using PUT on a read-only resource.
Cool, just re-read it. Looks a little more standard now. Curious as of why it happened in the vagrant box though. 
&gt;Most of them are based on LTS distros, which never upgrade the major versions of software Out of curiosity, which ones? &gt;none of them want to hop major versions for fear of breaking internal tools It's a significant mental roadblock. I wish I could start using 5.4 for more projects but 5.3 and earlier still makes up 75% of PHP's install base. How are we going to convince these same sys admins to make the jump from 5.x to 7? I know it was never going to be an easy job. But the fact there now has to be a concerted effort to educate people that the version jump isn't as massive as the number suggest won't do us any favors. It feels like internals has traded a short-term problem - a half-dozen 5+ year old books with bad information in them - for a long term problem.
Long term is it really a good idea to fragment the ecosystem like that? There's always Hack.
Which languages don't?
So "insane" several other projects have also skipped versions in the past.
Yeah, nobody is moaning about ECMAScript 5 not being 4. In the end it's just a version number.
Ubuntu is the most fast-moving and there are ppas for newer versions like 5.5 for it. You won't get incompatibility problems really. If it bothers you, just compile from source, PHP makes this ridiculously easy. Though doesn't 12.04 go out of support in not too long? Is 14.04 really so bad?
I totally don't understand what everyone's issue is. My favorite thing to do is to refactor legacy code and my bible for doing it is [Working Effectively with Legacy Code](http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052). I get a huge amount of satisfaction from turning a complete mess into something magnificent and the best part is that it can all be done with minimal risk. 
That's my strategy as well. When I add a feature, I clean up and refactor the area I am working in, add a few tests, and get the feature implemented. I never ask my boss if I can refactor. That would be silly. I subscribe to the Boy Scout method of programming..."Leave everything a little cleaner than you found it." 
People do when referring to versions (ES3, ES5, ES6/Harmony).
Then why not stick it on github? 
[W3 Techs - Usage statistics and market share of Linux for websites](http://w3techs.com/technologies/details/os-linux/all/all)
&gt; Out of curiosity, which ones? Any host that uses a distro that promises long term support. CentOS, since version 5, has a 10 year support window. Very few hosts use distros that have quick release cycles, and in the case of Ubuntu most of them run LTS specific releases. &gt; It's a significant mental roadblock. I wish I could start using 5.4 for more projects but 5.3 and earlier still makes up 75% of PHP's install base. How are we going to convince these same sys admins to make the jump from 5.x to 7? Honestly, it's an issue we put ourselves in. PHP 5.2 -&gt; 5.3 was a major version upgrade, so we burned the distro vendors and scared them that every time we upgraded 5.x, they fear that it's a major version upgrade. It's not, and PHP 5.3 code should (mostly) run on PHP 5.5 without any problems. The next isssue is the release cycles for distro vendors like Redhat. They want large enterprises to use their software, and large enterprises want stable software. This means that no major BC breaks during the life of the OS, so things like Python, PHP, Perl, MySQL, config tools, etc, all stay at the same major version. This reduces the likelihood that software vendors will see their software break as long as they stay on the same OS version. If it works on CentOS 5 right now because it relies on Python 2.6, it always should, so Python 2.6 will be there no matter what. System admins are then at the mercy of the distro vendors, as a system admin's job is to make sure things run smoothly. While there are times that they need to custom compile software, most of the time they want to set it and forget it. Let Redhat handle the backports of patches, and automate the system to update from the package manager. I'm not against this, as on my production boxes this is what I do. I go the extra step to stay on the latest Ubuntu LTS release, so I no longer have 12.10 boxes hanging around, and am in the process of moving everything to Ubuntu 14.04 (and utilizing Docker where possible). Sysadmins for fly-by-night hosts and $3/month business hosting plans don't do that though. They install a CentOS 5 box and that box will live there forever, because Plesk works just fine. Since profit margins are so low, constantly upgrading customers and handling the resulting support means they make no money. &gt; I know it was never going to be an easy job. But the fact there now has to be a concerted effort to educate people that the version jump isn't as massive as the number suggest won't do us any favors. We did at one point. It was called the GOPHP5 Initiative, and it worked well to move from PHP 4 to PHP 5. We aren't the only project to jump version numbers. Again, it's not an issue with the number itself, as the package maintainers will know that there is no PHP 6. The issue is that Ubuntu 14.04 ships with PHP 5.5.x, and will stay at PHP 5.5.x because going to PHP New has the possibility of breaking things. PHP New can be PHP 6, 7, 12, 2015, whatever, and they still won't budge because it's a major version upgrade. Complain to the distro vendors. &gt; It feels like internals has traded a short-term problem - a half-dozen 5+ year old books with bad information in them - for a long term problem. Realistically, it's a number and nothing more. PHP 7 is newer than PHP 5, and that's all that matters. The distro vendors aren't going to not upgrade to PHP 7 because they think it's too new, calling it PHP 6 means it's a new version and therefore not going to be put into the package system. Hosts are not going to upgrade to PHP 7 because they think it's 2 major versions ahead, they aren't going to upgrade because their package managers don't have it. Yes, they can add additional repos like Remi or dotdeb, but that's more work. 
https://tim.siosm.fr/blog/2014/04/25/why-not-ubuntu-14.04-lts/ http://comments.gmane.org/gmane.linux.ubuntu.server/6827
Unfortunately, PHP's largest "competitors" haven't, and absurd decisions like this are why Ruby and Python are now favored for building websites as software, while PHP is essentially cementing itself in a CMS spiral of death, despite modern frameworks like Laravel and Symfony.
The sad part, is all of those features you mentioned aren't even necessary to write clean software, very quickly, in PHP. PHP's biggest enemy is the Wordpress/Drupal/Joomla trifecta. I'm now convinced that these are nothing more than honey traps. Clients and management *THINK* that by using these, 90% of the code is already written for you, so it should be fast and easy. Well, it never is, and developing sites with these tools is less stimulating than watching Teletubbies all day...
Seven is lucky /ducks
Okie doke. 7 it is.
&gt; While it might seem that if you go to /r/PHP or such, I doubt the subreddit is representative. It's hard to say, really. It's an easy out to suggest that the vocal are a minority. But I can just as easily say that people who like kittens are a vocal minority and the vast majority of people despise both kittens and puppies. I'm not saying you're wrong, just pointing out that we don't really know either way. I just worry that active, cutting-edge, best-practise development is being stifled to facilitate legacy projects in a maintainance phase of their life. &gt; Many developers used pre-release builds and were taught to use them. Perhaps, but a long time ago, and for a short period. For the **overwhelming** majority of users, PHP6 is something that has no meaning. &gt; There is a lot of old PHP code out there. There is a lot of egregious old code out there. Do we support that *at the expense of* improvement? And do people really upgrade the PHP version of old codebases? It seems to me that new development would occur on new builds, while old software would tend to sit on whatever platform it's on. If your BC requirements are actually that the PHP version has to date from a year BC are you really installing everything on the bleeding edge? &gt; A lot of people wrote brand-new mysql_* apps in 2010 (like myself, yuck, I've moved past that), why should we punish them? See, is that the right attitude? Are we punishing them? Or are we encouraging best-practise development? Are we making their jobs harder, or are we pushing them towards more modern standards. To answer more clearly: why should we punish them? *Because they're doing it wrong.* Don't get me wrong. This is a **hard** question. How much BC break is too much BC break? I just feel that the erring is on the side of caution too much. With no impetus to innovate, and substantial inertia not to, PHP cannot help but stay static. That's not good for anyone. Speaking of which... &gt; PHP, by nature, can't have static type hinting Sorry, brain fart. I meant *scalar* type hinting. I'm aware of "the long-held PHP tradition of weak typing and type juggling" and I think it's disastrous not to be **allowed** to require a specific type. Yes, PHP is weakly typed. And that's great. But there's a reason scalar type hinting implementations come up as RFCs a lot. Developers want them. They want a language they can use as they need. The lack of scalar type hints is... frankly odd. And yes. Strict is (imo) the only logical option. &gt; It never will. It'll get more consistent and more rational over time Not without a concerted effort it won't. Certain things seem to me like givens. No break of BC and a move to more consistency. `str_replace`, `strlen`, `parse_str`, `isset`, `is_array`, `empty`, `htmlentities`, `html_entity_decode`, `strtoupper, nl2br, `mysql_real_escape_string` This is an undeniable clusterfuck, and that shouldn't be just shrugged off. It's entirely possible, and IMO should be a priority, to decide on a standard, create functions with those standards, and alias violators to the canonical term. [This ~RFC~ bugfix](https://bugs.php.net/bug.php?id=52424) was closed as "won't fix" by Rasmus in 2010 dismissing this change as "cosmetic", but still attracts comments. These comments include people suggesting the same as me or other productive solutions. These are dismissed out of hand as "breaks to bc" or "aliases are evil". The "yeah nah" attitude here is bullshit. "If it ain't broken... " **but it IS broken!** This isn't the only possible approach. Most of the inconsistency is in string and array functions, PHP's bread and butter. // strings echo strlen($username); // 11 echo $username-&gt;length(); // 11 // arrays $users-&gt;search('steve'); array_search('steve', $users); $users-&gt;sort(ARSORT); arsort($users); I can but dream. /u/nikic was looking at implementing this some time ago. I'm not sure how far he got, but I've seen other similar projects. Backward compatible AND forward progress. Doesn't fix the cluttered global scope, but allows you to move functionality into more logical places. &gt; Rasmus is the original creator, but he's not a BDFL. ~He closed an important RFC in 2010. And~ He still has a significant influence over PHP's direction and voting. I would **prefer** he was a BDFL because at least there would be someone in charge rather than the inconsistency and design-by-committee. It would also push me into finally learning Python. &gt; And for a facetious but strangely Did you accidentally forget to
&gt; This is not what I wanted. I'm a firm believer that six comes after five. Regardless, I don't always get what I want. (Use tabs for tabs, ffs!) I'd rather see the community move on and do cool things. Please. Neither of these things matter in the slightest. &gt; It feels to me that "internals" has become greatly divorced from userland developers. The majority of improvements to PHP have come from outside of PHP itself, and often in spite of PHP. I'm referring to the excellent frameworks available, the work of the PHP-FIG. I'm referring to Hack. I'm referring to Composer. The PHP team has finite resources. Do you really want them wasting resources working on problems that have been largely already solved by the community? They should focus on what they do best, working on the core PHP. &gt; I mention this on this post as I think it's symptomatic. PHP6 never existed in userland. It existed only among internals. No developer developed with it. And why should anyone have developed with it? &gt; I worry that PHP will remain forever stuck in a mentality that clings to "backward compatibility" at the expense of innovation or improvement. I worry that PHP 7, major versions intended as a BC break, will instead just add a few new features... you know, so as not to break backward compatibility. Uhm... [uniform variable syntax](https://wiki.php.net/rfc/uniform_variable_syntax) *did* pass. They *are* making backwards-incompatible changes. We have to carefully weigh the pros and cons of every backwards-incompatible change -- each of them is a major hurdle for the community to adapt; the Python 2/3 issue is legitimate. D phobos/tango is another example. &gt; I worry that some great features like static type hinting, generics, or proper annotations will never be available. What's static type hinting? Do you mean for scalars? Generics aren't needed with dynamic typing. Annotations? Like doc-comments? Those are largely up to community tools. &gt; I worry that php will never get a consistent or rational API. Very low priority IMO. You can wrap the standard lib if it bothers you that much. Having two APIs is worse than one shitty one. &gt; Most of all I worry that to develop as a programmer I'll have to learn Ruby. We've seen a lot of progress in the past few years. I'm actually very optimistic about the future of PHP. A couple years ago I thought PHP was just a shitty language I had to put up with, now I actually enjoy writing in it. Still has a few quirks, but every language does. I bet you'd find that Ruby has a different set of issues if you really got into it.
Can we see it with something that isn't a massive pile of shit like wordpress? Perhaps with some sort of symphony application? I'd really like to see the results from a well coded piece of software that uses OOP principles properly.
Could, yes, but no one would use it (unless maybe you want to back it with a couple billion dollars).
There's no alternative to JS. (But otherwise I agree; who gives a shit?)
Logic fail.
JS is a PHP competitor.
Completely agree, I was just using OPs example from his post to make it clear what I was referring to regarding DI. A real world controller would look quite different obviously.
Uh, that was a bug report, not an RFC. Even I can close those. Re: scalar methods, I'm very much a fan of those. As you said, it's progress without breaking BC. Better than introducing a bajillion aliases (makes the problem even worse) or plain renaming (breaks code for little benefit). Also, no, Rasmus really has very little influence or power. The thing I forgot to finish typing was me saying that the ElePHPant is a good mascot for a slow-moving language. ;) **EDIT:** The thing with `mysql_` is that it took until *2013* to deprecate it, and so until last year it wasn't officially considered bad form. Also, there are plenty of tutorials out there. While we should force the developers from 10 years ago to update their practices, there are new developers unknowingly using bad practices they got from dodgy tutorials who probably don't want their code to break. Then again, if we break it, anyone who used those tutorials would see they were out of date when their code didn't work ;)
lol. alright, so i think the consensus is there is no real point for it to be done this way, and just a styling thing that the developer did. This is the one theme I ever paid for, and the developer refuses to help with any sort of customization, so I'm pretty much on my own trying to figure this thing out. I like how the theme looked at all, but the process for uploading a simple photo album to the site is a pain in the butt. The most inefficient thing i have ever worked with. As a photographer, this simply won't do for me. Current process has me uploading images to a photo album which doesnt have the ability to display the pages directly. So I must create a page that links to that album, then create another post type that links to the page for the overall client page that has multiple galleries. When all I really need to do is upload images, define a few variables for that particular album (client, shoot type, location, ect) and then display the images in a flickr style grid directly from the album creation page. I could probably figure all that out with just php, but trying to make it work within wordpress is bout killing me. 
This is a joke. Please process accordingly.
Yes, this actually makes sense. If you're declaring full stack, might as well go all the way out isn't it. What do you think would be a better term to replace "Full Stack *"
Most languages announce new versions when they have something to announce for the new version... What do we know about PHP 7 so far? Uniform Variable Syntax is more or less it (there's a couple other RFCs I'm forgetting, but nothing earth-shattering). Maybe phpng (although there's some fierce opposition to that in internals) but right now that's *not yet part of PHP 7*. This whole problem of PHP6/PHP7 came about because PHP6 was named too early - it should've been PHP NEXT until it was ready for a beta release. Most software projects I've worked on are labeled 'vNext' until we've at least figured out exactly what we want in the damn thing and can release an alpha build. Had this happened, when that failed we would've gone back to 5.x, and then now we could logically try PHP NEXT again - this time it succeeds, so it gets named PHP 6. Instead, internals decides to repeat the mistakes of the past and do the *exact same thing*. What happens if PHP 7 never makes it out of development? Do we give up and then a few years later start work on PHP 8, meaning we jump from 5 to 8? It's silly! Let's talk about PHP's most significant competitor, and what it most frequently gets referred to - Python. Python 3 was NOT called as such during development - all docs and discussion referred to it as Python 3000 (or Python 3k). Why? To avoid prematurely naming a release before it's ready, in case they decide to scrap the changes for whatever reason (just like PHP did with 6). However here, internals is giving already naming the next version and thinking about release when **work hasn't even started**. Versioning should be the last thing you think about, when you're starting to release builds maybe. Talking about it now is just silly.
Please do not quote a comment meant as a joke...
Definitely, I'll try to proof check before publishing next time :D
Heavy refactor
I just check your Member Controller at store Member function you don't check anything (like form validation or entity validation), that's bad
I doubt that the employers would want a full stacker. In fact, I'm starting to actually think it's a developer community word to describe someone who is **familiar** with the entire stack, but only an expert in one or two of the stack. Probably due to the lacking of staff or money to hire staff. But this got leaked to the entrepreneur network and boom, suddenly all startups want a full stacker and developers start calling themselves a full stacker to let them know they're the one the startups should hire.
He can do the work of five people. At the speed of one.
While Wordpress may be a steaming pile, it's also probably one of the top applications people are actually running on PHP, so it's not the worst thing to benchmark to get something atleast related to "real world results". There's a number of other aging codebases such as phpbb and vbulletin (last time I looked - they may have had some rewrites since I last dealt with these) which people are also regularly running.
wow... im speechless... im feeling for your employer. Best practise should be followed anytime possible and dependency injection is an easy one. Switching from DI to SL is really bad for the readers.
And not subtracting the fact that when you identify as one of these, you probably learn a lot from the job as well watching the expert in the field work and you actually know what he's doing without him having to explain every keystroke. 
I would suggest that both implementations are going to be in our future. Some people (for example wikimedia) are already switching to HHVM. Regardless, "Facebook" (or rather the Facebook developers who work on not only HHVM, but also contribute directly to PHP itself) are not going away. They're doing excellent work for PHP, both in the form of competition from HHVM, and with direct contributions both to the PHP codebase and the language (for example, with the upcoming language specification document)
"Guys, we'll release books and call it Programming With PHP7: The Ultimate Guide". It'll work. Trust me"
&gt; I don't know if that makes a difference in your assumptions Sadly no. The entire wordpress codebase is like this. &gt; I need something that can provide a good starting point for me where i can just focus on creating the functions and content I honestly have no idea what the blog / CMS situation is currently, so I can't really suggest anything :/ If nothing else comes up, you should of course start with Wordpress. It's better than not starting at all :) 
So the work of five at the cost of five, then. 
A designer can design a website in Photoshop, but he still needs to know the constraints of HTML/CSS. I saw PSD designs that were just impossible to implement in a modern browser. So a "full-stack" designer could mean this: he can design PSD in the constraints of HTML/CSS/Javascript/etc. He/She knows what are the capabilities of HTML/CSS and design accordingly. A full stack developer in my perspective does: back-end, front-end and also does the conversion from PSD into HTML/CSS/JS. Many people call themselves front-end developers, but when they get a PSD file they don't know what to do with it.
Did you know you don't have to reply with just links? Like, words and stuff.
i actually came back to php (specifically symfony2) from ruby/rails. Symfony has a far nicer design than rails (imo obviously). Although i came back in spite of the situation with internals (it is quite upsetting). I saw HHVM/Hack and their efforts to make php itself better. (ESPECIALLY THE SPEC WORK!!!) I just didn't see anything out there worth building web applications in but Java. I consider Go too immature and current JS dev isn't quite what i want either. NOTE: I would have had voting powers i would have chosen 7 too. 
I think the hardest part of PHP is dealing with people. What the hell do I tell them when they mess up
Well, if the state of the system is that the requested resource is no longer available, "204 No Content" would be appropriate. This is regardless of whether the DELETE request actually initiated the removal of the resource, or if that was done by a previous DELETE request (DELETE is idempotent). 
&gt; Also, no, Rasmus really has very little influence or power. Many people (last I heard, the number was 6) with voting privileges just vote whatever Rasmus votes. In fact, Rasmus being against it was one of the primary reasons the getter/setter RFC failed.
I'd suggest to remove the extra layer of work needed to create and parse a zip in this case. Just provide the user with a HTML5 multiple file upload and only allow mp3/ogg/flac/jpg/png or whatever you want. This saves the user from having to zip his files before uploading (there's no additional compression possible here anyways), and yourself from having to find a way to avoid the vast amount of possible attack vectors.
just clicked in the comment section to rant about this, thanks you did that first.
Is that really true? Perhaps they were just swayed by his opinion.
&gt; Most languages announce new versions when they have something to announce for the new version... PHP 7 hasn't been announced, we've just said whatever the next major release contains, it'll be called PHP 7. For all I care, PHP 7 can come out in 2020. &gt; This whole problem of PHP6/PHP7 came about because PHP6 was named too early No, it came about because it was abandoned. Simply not naming it would be nonsensical. Everyone would call it PHP 6 anyway and the problem would still exist. In fact, people were *already* calling phpng/PHP NEXT "PHP 6" before we even had a vote on this. Similarly, PHP 5.6 was called that before it existed in many discussions and RFCs dealing with it. &gt; Most software projects I've worked on are labeled 'vNext' until we've at least figured out exactly what we want in the damn thing and can release an alpha build. Few I've worked on are. All seem to assume the next version will have the current number incremented, as you'd expect. That's always been obvious and non-controversial. &gt; However here, internals is giving already naming the next version and thinking about release when work hasn't even started. Work *has* started. Because the name has been controversial and because nobody was able to agree (unlike literally every previous increment), I decided to have it named in advance. &gt; Talking about it now is just silly. Talking about it now *gets it over with* so we can focus on more important things.
&gt; Generics aren't needed with dynamic typing. I'd argue they'd be useful to ensure the correct types when calling functions. However, they'd be a right PITA to implement because of references, so it may never happen.
Salesforce.com is [best in class](http://www.crm-guidebooks.com/wp-content/uploads/2013/07/SFA-MQ-Gartner-July-2013.png) and has been top scorer in Gartner research for the last 4 years. Note where SugarCRM is. Also, ZOHO is pretty terrible. Their api is extensive, and you can code a lot of actions / triggers / etc on the platform.
I'll look into them as well, thanks! 
If you break backwards compatibility why continue using PHP over another more modern language that already exists and has community support?
At the cost of... Lesser than 5. I wouldn't say 5. Haha. I honestly have no idea how it's calculated. Safer way would be to charge by service rendered I guess.
PHP is not a JS competitor however. 
real_insane()
My boss will never understand this. Dammit. Maybe I won't have a boss by the time this is ready for prime time . . .
On my mobile so can't provide much to back up my claims but... I'm currently in the process of customising SugarCRM for a client and absolutely hate it. If you plan on making changes within the CRM prepare for stress and tears. I'd you stick to using the module builder tool built into Sugar you will likely be fine but as soon as you want to do something even moderately complex you will be faced by a mountain of challenges trying to understand what is going on. Auto generated code: When using the module builder code is magically generated. At first this doesn't seem entirely outrageous but that code gets shit out in probably about 3-6 places. It gets merged with other files put in a cache folder, history folder etc. Because of this it is just about impossible to have more than 1 developer working on the code at a time because merging the 100's of files + the schema changes are a pain. Performance: Using the module builder is awfully slow at 5-10 minutes from making a change to the point it can be seen in the interface. This can be quite time consuming if you aren't happy with the changes the first time. Table structure: Again using the module builder creates less than optimal table structure as far as relationships go with very little control over the use of joining column vs table and also column names. Autoloader: Can't quite remember all the details but it certainly isn't PSR-0/PSR-4. There are plenty of switching throughout various files to determine if files should be loaded from the core locations or the custom folder (where you override core files). Phone is nearly flat I shall return later if I remember to continues this but please make sure you properly look into Sugar properly before committing to anything because it has truly made work a nightmare for me. :(
sugarCRM is good if you have 1-2 coders that can at least focus quite some of their time for it and if you NEED a lot of individual stuff if you dont have the need for that or dont have the coders - Salesforce, no buts, they are just THAT MUCH better than any other CRM esp. if you have someone who knows how to administer it, then it gets even better. 
Yeah sadly it is true. Moreover, many of the voting people have either *never* committed a single line to src, or their last commit was in the PHP4 era. I think to keep voting privileges one must make at least 1 non-trivial (i.e "fixed indentation" is a trivial commit) commit every six months. This would get rid of a lot of bagge from internals, including Rasmus.
I think that I just managed to convince a potential client to use Laravel instead of their initial plan to go with Wordpress. Fingers crossed.
&gt; Are closures, namespaces, generators, splats, short array syntax, traits and so on not improvements? They all came from internals. They came *despite* internals. If it were not for Anthony and Nikita most of those would have never seen a release. Check the discussions of those features, most of internals who still live in the PHP3 era objected to them, most notably Zeev and Rasmus. The fact that Zeev is the CTO of Zend, the largest PHP company around speaks *volumes* about the current state of things. They have, time and again, pushed stuff into the core without so much as a discussion. Now they are insisting on merging NG to master, despite the fact that: * It has been developed **in secret** with no input from internals, * Has absolutely no documentation whatsoever, * Breaks *every single extension* out there, * Does not attempt to fix existing mess (PHP is already a macro hell and they added even *more* macros). At this point, I really have zero faith in Zeev, Zend, Rasmus and anyone else who either goes *"my way or the high way"* or *"I voted no because i don't wanna"*...
&gt; This would get rid of a lot of bagge from internals, including Rasmus. Rasmus isn't inactive.
Didn't you already post a thread about this? http://www.reddit.com/r/PHP/comments/2burdg/unread_messages_php_mysql/ My reply is the same as in that one, but let's have another go. Just treat the tickets as any other type of message thread, like in a forum but with specific types of messages: 1. Tickets have many messages, including the first one that starts the ticket. You can remove the content &amp; subject fields from tickets table, just join to the info of the opening message. 2. Each message has one type: open, close, resolve, comment, question, re-open, etc. These embody your ticketing system's functions, and allow you to manage a proper history for each ticket (which may be closed and re-opened many times). 3. Messages belong to one ticket and one user (have ticket_id, user_id), and have many users as readers (messages_readers: message_id, user_id). 4. Query the messages table LEFT OUTER JOINed with the messages_readers pivot table for all messages (e.g. of type comment) belonging to a user that have no readers (where messages_readers.message_id = NULL), or only readers who are not staff, etc. Do a simple count, or optionally link to the tickets, display the unread messages, etc. Or you could just selectively denormalize and add a boolean flag to the ticket for whether it has any unread messages, or the same on each message, toggling them when tickets/messages are read by anyone. I wouldn't recommend this, as it's guaranteed that you'll be wanting more from your ticketing system than you've specified here, like knowing *who* exactly has read each message (and probably *when*). 
You will only be able to find out what's in the archive while you are reading from it/extracting. if that's too much of a bother use multiple upload, and zip them for download if needed.
&gt; many things are developed in secret That doesn't make it ok. &gt; You don't make a patch public until it works. No one is arguing against the patch. They could have announced their *intention* a long, long time ago. They chose not to, and that's on them. &gt; Also, it does have documentation. It's extremely limited, but it's better documented that current Zend... somehow. Zend lacking documentation is the result of *decades* of neglect. There is absolutely no justification for missing documentation for *new code*. &gt; we regularly break extensions. Hmm, I don't recall. When was the last break when you couldn't simply recompile an ext? I maintain close to a dozen proprietary extensions and I honestly don't recall the last time I had to make code changes due to a BC break. &gt; Finally, phpng is better than master in many ways. zend_string and the removal of zval double-indirection for starters. I never said it wasn't. Yes, NG might be better than what we have right now. But it is still not acceptable to drop a patch out there and go "hey we did this without telling you, and yes there are tons of problems, but merge it anyway". Do you really think if an NG-like patch arrived at ***any other language*** it would get merged?
You're the second person to recommend Salesforce. Will have to look into that! Thanks.
&gt; non-trivial No true Scotsman.
No, I'm saying you're dismissing his "trivial" commits. I didn't say he was doing major stuff, but he's certainly active.
Funny thing, I was discussing that yesterday with other PHP developers. Yes Pimple is very simple. But having to declare all your services and controllers and repositories (etc.) can become very painful on large applications. Using PHP-DI, you just write your service (with DI in the constructor), and that's it. No need for configuration 90% of the time. You save a lot of time.
Heh, I have docs karma and wouldn't vote. I've seen in the past where it's been fairly close and a few non-internals developers are called out for voting. Perhaps I should change my mind?
&gt; Overflow It depends on what you want to build. For learning programming I wouldn't recommend PHP since I believe its' power is on web development only. (Java was my first language) If I want to make something portable by whatever this means I would use java-ish languages. I like the approach of Rust when it comes to system dev and yes I agree that Haskell can make you a better programmer, even just by playing with it. But I also believe that github can make you a better programmer as well, by trying to contribute to a project you like/support/use and get feedback from more experienced devs. I believe that PHP should never be your only language, but I think is by far not dead! And what I always say in such conversations what I like most about php is the ecosystem, deployment, IDEs, ease of update, plenty of frameworks with different strengths and of course the amazing competition that started between, HHVM, PHPNG and the PHALCON guys with ZEPHIR that can move the language really forward. As a small conclusion by me, PHP is an amazing language when it comes to the web and it's great for freelancing as well just because of the friendly ecosystem. For system programming, heavy algorithmic staff and programming learning there are better choices out there.
Everyone's history is filled with merge commits, but look at the ones that aren't. He's fixing tests and bugs. He *is* active.
What if there is a php script to walk through your source folders and read dependencies of each class, (using reflection ofcourse)..and generate a pimple container file automatically....I can add this feature to [Cliche](http://imakesnowflakes.com/cliche-introduction.html) which already can check the pimple container files for missing constructor arguments and cyclic dependencies...
My experience of Sugar CRM, although 3 years ago, was also very painful. Alas, I had all but suppressed the traumatic memories, but raing3's comment has made me recall them again!
&gt; That doesn't seem very practical to me in dev environment, Can you tell me why?
You need to re-run the script every time you change your services to regenerate the Pimple config file.
Of course, but that does not sound too bad to me. And why do you think it is better to let the script figure out the dependencies at run time, using reflection, instead of using something pre-built, like a pimple container file. I mean, that is a lot of work that can be spared at run time..
OP's username is almost identical to the submission domain. This guy is just spamming his own blog.
To me it means an employer wants someone to do the job of two or three people, whilst only having to pay the salary of one.
It is spared at runtime because it is cached.
No. JavaScript competes with PHP, but PHP cannot compete with JavaScript. Unless you consider this work of insanity - http://tantek.pbworks.com/w/page/19402872/CassisProject
Darn, I was really pulling for moving to an eldergod version system with PHP Cthulhu.
I take it registering new users, billing users and creating orders are separate services?
I heard there was an orgy organised at Oreilly in celebration.
Yes, I did. But I did not specify the tables that I have, and many replies were answering in a ticket to read/ unread situation. I tried to implement that, but can't seem to find a solution with having a replies table. So what you're explaining here would be: **tickets** | ticket_id | |:-----------| | 1 | | 2 | | 3 | **message** | type | |:-----------| | open | | open | | close | **messages** | id | ticket_id | user_id | |:-----------|:------------|:------------| | 1 | 1| 1 | 2 | 1| 3 | 3 | 3| 5 **messages_readers** | message_id | user_id |:-----------|:------------ | 1 | 1 | 1 | 1 | 3 | 3 and to LEFT OUTER JOIN the messages_readers? What would the final table look like?
Well, I am not sure if that makes thing better or worse, because you know, cache invalidation.. How do you invalidate the caches? You are probably depending on the modification times of the files. But I am not sure if that can be very reliable..I have had issues with templates not being updated because of cache issues...So I am not sure if I want to rely on that for something critical as DI. EDIT: And wouldn't be much better to use something like inotify to automatically run the container-file-update script in your dev machine, when any of your source file changes..
Basically this, and they clearly don't want to change that (for now). That said, if the customizations you wish to do are simple it's pretty straigthforward, and it'll probably cost you a lot less than Salesforce. Other things to note: - Salesforce is SaaS, so if your client handle sensitive/protected datas he may not want to have those data hosted within a US based service. - Sugar can be self hosted so you have control over it from A to Z 
Best of luck with that. We just lost a project that we (and our client) agreed should be custom, but their boss is a drupal nutcase so decided that we would build it in drupal. So now it's going to take twice as long and cost twice as much (but we aren't charging twice as much, because WE'RE idiots) since it's so custom it requires a custom backend anyway. Normal Drupal content types won't cut it, and fuck knows what kind of other "Oh btw we want this too"s we'll get along the way...
PHP can and does compete with JS *on the server side*. Competition always goes both ways.
Duplicate posting - This link was posted to /r/php yesterday by the same user. I suspect most poeple interested are going to be subbed up there already making this posting worthless. Plus this link must hit one of these 2 subreddits at least once a month on average.
And now people will start writing PHP 7 books before it's released.
Hm, but we're not benchmarking the script itself :) We're only changing the interpreter in the background while everything else stays intact to measure *their* capability. It's not a WordPress vs Drupal vs Laravel or whatever comparison so I don't think the *how* is important here.
And half your work is obsolete.
The difference is that the mb_\* ones will handle multibyte character encodings correctly (in particular Unicode and the most common Unicode encoding UTF-8, which in 2014 you **really should be using**), while the "standard" string functions are designed for single byte encodings like ASCII and can't handle Unicode text properly. Unicode is a set of characters which supports almost every human language, and is the standard on the web these days, while ASCII is a very old standard which only supports a few characters used by American English. Unfortunately, PHP's standard string functions were made for an era when Unicode wasn't the standard and they don't understand Unicode, only ASCII. This means you need to use different functions which do understand Unicode. UTF-8 is a clever *encoding* of Unicode which takes up several bytes for each character, but includes the ASCII characters and represents them the same way ASCII does, meaning that anything in ASCII works as UTF-8, but the reverse isn't true (most UTF-8 characters aren't in ASCII). This is why the standard functions might seem to work fine if you pass them some UTF-8 text that's only made up of ASCII characters, but you'll only spot they don't work properly if you pass them UTF-8 text with characters that ASCII doesn't have in it. While there are *some* operations that you *might* be able to safely use standard string functions for, you should **always** use the mb_\* functions where possible to avoid mangling text. This is particularly important if you're splitting or manipulating text somehow when it's something less basic than just concatenation, as the standard functions are liable to mangle the text as they don't understand the encoding. `mb_strlen`, for example, understands how to calculate a UTF-8 string's length in terms of characters, while `strlen` would just return its length in bytes. If I have the string "naïvété" (a word in English, although a lot of people omit the accents) for example, `strlen` says it's 10 characters long as `strlen` just counts bytes, while `mb_strlen` understands UTF-8, so it gives us the right length of 7. Note that you need to have told the mb_\* functions what encoding to use, either by specifying it when you call the function like this: `mb_strlen("naïvété", "UTF-8")` or setting it globally (much better idea as you only need to do it once and means you don't have to worry about forgetting the encoding when calling) like this: `mb_internal_encoding('UTF-8');` To take another example, the standard functions only understand how to make ASCII text uppercase, while mb_\* can deal with encodings. For example, take "naïvété" again. If we use the `strtoupper` function, we get "NAïVéTé" as it only understands the ASCII-compatible characters in that string so it doesn't touch the bits it doesn't understand like the ï and é, which UTF-8 encodes. However, `mb_strtoupper` understands UTF-8, so it gives us "NAÏVÉTÉ", which is what you actually wanted. Again, you need to have told the functions what encoding you're using or they won't work properly. Also, it's important to point out that doing `$str[2]` won't do what you expect on a string which has a multibyte encoding (such as UTF-8). That doesn't actually get you the third character of the string, but the third byte. If `$str` was "naïvété", then we'd actually get the first byte used to represent the `ï`, which is completely useless as it's an incomplete character. If you want to get the third character, you actually need to do `mb_substr($str, 2, 1);`. (Side note: Technically, this may not work quite right either, as what I'm referring to as "characters" here are actually "code points", and sometimes the thing that appears as a single character you see on-screen is made up of several code points, which layer on top of eachother. In which case, what you might get instead is one of those layers and not the full character itself. However, you probably **don't need to worry about this** realistically in your app, unless you're doing something funky with strings like making anagrams or implementing reversal yourself.) For more information, please have a look at this: http://www.phptherightway.com/#php_and_utf8 (what I said above is only a brief introduction, there's more things you ought to do) Also, don't panic. Handling Unicode safely in PHP isn't really that hard, so long as only you use Unicode-aware functions like mb_* and so on, and make sure the things you're dealing with (MySQL etc.) are also handling it properly. If this is too technical for you, feel free to tell me what you don't understand and I'll try to help.
I think you might need it if you have an international audience, other languages like Arabic and Japanese have multi byte characters.
This somewhat depends on your level of expertise. If you have a good understanding of how UTF-8 works and which properties it has, then you can safely use normal string functions in most cases. There are only relatively few operations, like "take the first 50 (hardcoded!) code points from a string" that require usage of mb_ functions.
fine, if we're arguing on semantics: PHP can never replace JavaScript. JavaScript could potentially replace PHP.
No. You need it **even in just English for an American audience**, as English speakers may use Unicode characters in their text. Like ° (the degrees symbol) or € (the Euro), or perhaps they're using OS X or copying text from somewhere and their text has curly quotes. Also, never assume your customers will never need "foreign words". They might well need them.
While this is true, I suspect the OP doesn't actually have a good understanding of UTF-8 given the question, so in their case they should probably always use mb_ unless there's no alternative. **EDIT:** Also, there are some more frequently used cases (uppercase this string and getting the first character) which break if you don't use the mbstring functions.
We use Ubuntu 14.04 LTS with PHP 5.5, no problems so far after upgrading from 12.04.
I agree totally with PHP 7. There was a PHP 6 with its code branch and books http://it-ebooks.info/book/348/
Great news PHP 7. I was worried thinking if we will add the year as a suffix when we talk about PHP 6-2009 or PHP 6-2014
- Production: use the cache, no problem of invalidation - Development: don't use a cache, no problem of invalidation You might say that then it's slow in dev environment (without the cache), but honestly I've never experienced any slowness because of the DI container. Let's be realistic, a common application only requires 4-5 services max per page, so it's not noticeable at all.
The passive-aggressiveness in the last paragraph gets me the urge to start a huge commotion with the theme "are you seriously implying that name isn't many times more important than silly stuff like code?" Pathetic "hurr I'm a serious person and everything must be gray" action from Andrea's part.
messages needs a type_id linking to a message_types table (with e.g. id, description as minimum columns). This is only one suggestion for developing the functionality of the ticketing system. Otherwise you can split out tickets into histories, journals, whatever, and make a fatter tickets table. It really depends on what you want the whole system to do: how you want users to interact with it, how you need to report on it, etc. The same is true for what the select query would return: whatever columns you want, joining whichever linked tables are needed for the infomation you actually want at any particular time. Outer left joins will include NULL values for columns in the right-hand table where there are no matching rows in the left-hand table. You can have multiple joins in each query. Each join allows you to add new columns and new WHERE criteria. Experiment in phpMyAdmin, that's what it's for ... This is why it's quite a good idea to spec out carefully (on paper) exactly how you want the system to work before you design the db. Edit: and [read this](http://www.w3schools.com/sql/sql_join_left.asp). Example using your tables, but with the second row of messages_readers as 1 | 2: SELECT m.id AS msg, m.ticket_id AS ticket, mr.user_id AS read_by FROM messages m LEFT JOIN messages_readers mr ON (m.id = mr.message_id) msg | ticket | read_by ----|--------|---------- 1 | 1 | 1 1 | 1 | 2 2 | 1 | NULL 3 | 3 | 3 Now if you add WHERE mr.user_id = NULL you will just get the third row. You have 1 unread message in ticket no. 1. 
Sorry, you're too late.
This is the kind of answer I was looking for, extensive and detailed, thank you. I have a doubt though. PHPTheRightWay says that I should use the *mb_http_output()* function to ensure PHP tells the browser I'm using utf-8. How is this different from setting the header this way: header('Content-Type: text/html; charset=utf-8'); Are they equivalent? And what would happen if I use none of them? I don't understand how it would affect my php script if the users browser doesn't know I'm using utf-8. EDIT: Also, phptherightway mentions how to ensure the mysql connection is being made with utf-8 by using utf8mb4 in the connection string. Is there something similar for postgresql, or does postgres handle utf-8 automatically?
Glad I could help! :) Unfortunately it's poorly documented so I'm not actually sure what `mb_http_output` does, but I believe that actually makes sure PHP won't try to output non-UTF-8 stuff (I'm not quite sure what that entails), rather than telling the browser which encoding we're using. They don't seem to be equivalent. Do both `mb_http_output` and `header`, as PHP The Right Way actually recommends. **EDIT:** Regarding what would happen if you used neither: I'm not sure for `mb_http_output`, but if the character set isn't set with either a header or a meta tag, the browser has to guess it and may make the wrong assumption causing [mojibake](https://en.wikipedia.org/wiki/Mojibake) among other problems. This also causes a security vulnerability in older versions of IE, as if the charset isn't specified before it hits the `&lt;title&gt;` tag, malicious user titles can use data that makes old IE think the page is *UTF-7* (never used today) encoded and perform exploits. There's also an extremely marginal performance benefit to specifying the character set in the header, not with a meta tag. **EDIT 2:** Turns out that `mb_http_output` will set the encoding output will be converted to (converted from the internal encoding). I edited the doc to make this clearer. This exists because you can have a different internal encoding from your output encoding. This is so you could, for example, have an http_input encoding of some legacy character set, an internal_encoding of UTF-8 or another Unicode encoding, and have an http_output encoding of the same legacy character set. This obviously isn't what you want to do in your and most cases, as you want your input, internal encoding, and output all to be UTF-8, but for some applications it's desirable to have differing encodings.
Thanks. Any idea if I should take similar measures when working with postgresql? Phptherightway only touches the subject with mysql
Didn't CentOS 7 just come out? How can it still be offering PHP 5.4? The mind boggles.
Thnx, that was helpful!
You should probably refer them to a drupal house if the heart and skill (and budget) are not there.
SugarCRM is balls. Don't use it. Never used Zoho but their marketing always seemed a bit spammy and I didn't like it. There's a new player in town called Oro CRM. It's built on Symfony2 and is open source. What I've seen of it so far is pretty good. http://www.orocrm.com/
I can understand that on technical issues which you might not have a full understanding of the issue being voted on, but for things like picking the next version name, which is more of a docs-related issue than an internals-related issue, I don't see why every docs person wouldn't vote.
Sorry about deleting. I did that because I edited it and wanted to ensure you'd see the edit, so I reposted the comment. Unfortunately I know nothing about postgres, though I expect postgres is saner than MySQL is here. There's [pg_set_client_encoding](http://php.net/manual/en/function.pg-set-client-encoding.php) which will convert stuff you get from postgres to a specified encoding, but I don't think that's what you want if the data in postgres is already UTF-8. You'll have to look at the postgres docs I'm afraid. I expect UTF-8 will either be the default for storage, or if not, it's some other unicode encoding (in which case I assume you'd want pg_set_client_encoding, so you'd get UTF-8 in your PHP), or you can easily set UTF-8 as your type explicitly. But again, sadly, I don't really know and you'll need to look at postgres's docs. Might be worth creating an issue on the PHP The Right Way GitHub repository about it. :)
No worries there, drupal will run just fine on the old 5.2/5.3, no one using modern PHP is using drupal or shared hosting. 
It seems to me that there was pretty much a PHP 6, but it wasn't released. Now they are making something new and are calling it PHP 7. I haven't been following the story at all, why is everyone so butt hurt over this?
Php has the same issue as a lot of successful languages/libraries... It has a lot of history, not all of it good, that can't be removed due to backwards compatibility. That doesn't mean you can't write good/safe programs in it. But it lets you write poor/unsafe ones too. I quite like php (and I'm a c++ developer)
I think a successful DELETE should return 200
Upvote for you good sir, for that disclaimer! 
&gt; System admins are then at the mercy of the distro vendors, as a system admin's job is to make sure things run smoothly. If you're on CentOS and you want latest PHP, use the [webtatic repos](http://webtatic.com/packages/php55/). They're perfectly stable (We're using them on live and development servers), and they don't try to upgrade half your stack for a version update (unlike the ppa for Ubuntu, which wants to change your Apache and your MySQL at the same time for just a PHP update...)
You don't need anything to push you into learning Python. Just try it, you wont regret it one bit. :) (You're starting to wake up. Run from PHP, run and never look back.)
Also if your users will use ASCII art like (╯°□°）╯︵ ┻━┻ you'll want to have Unicode support
Its a little obscure; easier terminology might help. Mandate is a Queue, Command is some kind of Message (i.e keep it as Command, but would probably use an Event object instead), Handlers (or listeners) are invoked with a Command and produce a Result (Artifact) ... Its always nice to have succinct code. I would suggest adding interfaces, whether its realized or not, every class has an interface.
Why? PHP is a land full of choices. That's the short answer.
Agree with devosc on the easier terminology, plus an overview of specific applications would go a long way to help showcase what your software can do.
Also the HTML5 validation is very easy to remove by using a console on a modern browser.
Yes please!
I cant imagine what content couldn't be contained in Drupal. 
Why you don't just stick on Debian and update the PHP to the latest stable? In my company our main servers are Debian Based with PHP 5.5.15 and we check for stable update at least twice a month. If you pay attention to your system it easy to maintain stable software like PHP or any other LAMP stack.
Or beautiful emoji flowers: 🌸
6 is cursed. Perl 6 anybody? Because it would have made it had they named it Perl 7.
At my workplace our standard is this - don't commit any commented-out code, as that is what version control is for.
I've got three beers waiting for you.
It returns 200. Since your delete request turns out to be successful, you may want to return some feedback on your delete. 404 if the object could not be found. And everything else as applicable.
The "standard" is to use version control. Remove the code, and if you need it again you can get it from a previous version. 
You usually see committed commented out code along with other atrocities. For example, a 6200+ line method (yes, really) with about 1400 lines commented out.
Oh, closures by reference.. that's deep :) Ok, but still the concept is not noob friendly. It assumes that everyone is acquainted with event handlers already. 
How dare you provide evidence. You must be downvoted
good points! I'm often bad at explaining things to people.
internals is open, if you think there is a problem, help us fix it. but I do think that there are more userland devs who aren't willing to learn about internals or the though process behind the decisions while still keeping the belief that it was the bad decision than core devs who are calling out userland devs/projects for their decisions.
Roger that... I guess if it's not getting checked in, it doesn't really matter. Just my OCD kicking in.
&gt; It's an easy out to suggest that the vocal are a minority. But I can just as easily say that people who like kittens are a vocal minority and the vast majority of people despise both kittens and puppies. What?!?!? Protect Kittehz! Pitchfork time! -------E
I'm not even sure where to begin with this. Modern PHP devs use Drupal all the time. I do, and I run and build many sites. Yesterday I worked on 4 different Drupal 7 sites. For my personal clients I have 5 of them on Drupal. Why? It solves problems. I'm also a modern PHP developer, and I understand it's pitfalls. For 90% of the business websites out there Drupal works great. So does Wordpress, for that matter. And yes, both will run on PHP 5.2/5.3. Wordpress has an insane, almost negligent need to be backwards compatible and run on everything, and Drupal 7 is just old at this point. Neither of them are examples of "good" codebases. That doesn't stop them from being popular, nor "modern" PHP devs using them. A good developer solves a problem with the best tools, not the fanciest. Most of the core Drupal developers I personally know are incredibly smart, advanced PHP programmers. Wordpress and Drupal also work just great on PHP 5.5. In fact, for my personal clients on Drupal I try to run them on PHP 5.5 whenever possible because it's quicker than 5.3. It works great. As for hosting... sometimes you are stuck with hosting. One client I just took over is using a Drupal 7 site on a crappy CPanel box hosted and resold who knows how many times. The site works, and the client is happy, so they won't let me move it. I'm OK with that though, because you work within the constraints supplied to you. Would I recommend cheap web hosting to a client? No. But sometimes that's not up to me. My projects? They are generally built using PHP 5.5, nginx, docker, and scaled across AWS or another API-backed VPS provider. Or sometimes they are on the shared boxes I myself run. It all depends on the project. 
Im afraid modern PHP is not building websites with Drupal. Even if drupal runs on PHP 5.5 its not any more modern than Drupal on 5.3. The server running PHP with the same crappy codebase Drupal or Wordpress has dont make it modern. Thats the thing, theres so many sitebuilders who have a metal lock-on on drupal or wordpress they have no clue about PHP as a language, all they know is the abstraction (backend) the cms system provides. Thats also the downfall of PHP, because of all this there cannot be BC because none of those CMS systems will work. 
IM going to go publish a book about PHP 7 now just to make that argument look retarded.
This argument is beyond invalid. Get it out of here.
&gt; This is not what I wanted. Boo hoo. I have one piece of advice: Get over it &gt; I worry that some great features like static type hinting, generics, or proper annotations will never be available... If you want features like these to get done, stop wasting everyones time bitching about a small decision like this. Saying the "internals" don't care about you and your vision of userland because they've decided to name the next version "php 7" is a ridiculous overreaction. Grow up and move on.
This is **far** bigger news than the "7 was selected" bullshit. This right here, is a **massive** win for the community as a whole.
Yeah I tend to believe more someone who claims "I've seen a 25% gain in production for our website" than an unrealistic benchmark (let's hit the login page without sessions!) posted on some random blog.
Indeed. Having Facebook as "partners" for the specification is only a good news for me, even because HHVM is way better than Zend Engine (but this is only a personal opinion)
You most definitely are :-)
No i'm not a PHP internal but I'm using HHVM since the release and I will never go back to Zend Ending for sure. And as I said before it is a personal opinion based upon my personal working experience. 
Do people think that downvoting PHP 7 will turn it into PHP 6?
I think you missed the part where he said &gt;this is only a personal opinion
Now that your cover is blown ... what's going on with runkit? I'm rather fond of the idea of sandboxing, but it looks like the idea was abandoned..?
There's been some talk about a MVC variant called ADR (Action Domain Response) which more or less was created to combat the problem of controllers getting too fat, and taking up too much responsibility. In simplistic terms in ADR each "action" is it's own class. http://paul-m-jones.com/archives/5970 It sort of makes sense, and if you are worrying about things like SRP it might be a nice bit of inspiration. As for your code. Assuming showDashboard has a form and showTest is the handler for that form. I think that in it's essence is already great. I never did like actions that submit to themselves, and have those if ($_POST) blocks. I would personally however name the action more explicit for it's purpose. Something like handleShowForm(). But that's nitpicking and preference.
Runkit was always more proof-of-concept than production-ready-implementation. In theory it could be merged into PHP, but you'd need some serious champions to push for it. To be honest, I'd love to combine Joe Watkin's pthreads with Runkit_Sandbox sometime. Could do some wacky things there...
Leaving aside the subject of the article, it's incredibly annoying to read with all the analogy. So much talk of kids and playing it's not making anything clearer, just confusing something that would otherwise be simple.
5.3 went EOL a few weeks ago, so I suggest avoiding that one.
But that also gives one the ability to not include the very important code found in the abstract classes.
From one of my favorites books, [Clean Code: A Handbook of Agile Software Craftsmanship](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882): &gt; Others who see that commented-out code won’t have the courage to delete it. They’ll think it is there for a reason and is too important to delete. So commented-out code gathers like dregs at the bottom of a bad bottle of wine.
Reference from the reddit: http://www.reddit.com/r/PHP/comments/2bfdwl/facebook_shepherding_a_php_language_spec/
I've never had a use for this myself but I always thought of using the [virustotal api](https://www.virustotal.com/en/documentation/public-api/) to scan files. Although since you only want those three file types which are non-executable, your solution could be simpler, just use FileInfo to verify the correct mime types, and discard any files which don't match.
hehe
Why make the comparison at all? Something else bothering you? Can both items be interesting news?
php noob here, can anyone explain what it is and why is it important?
Complex relational data managed through custom business rules. You *can* do it in Drupal just like you *can* do it in Wordpress, but this is a classic example of "if all you have is a hammer, all your problems start to look like nails".
&gt; I never did like actions that submit to themselves, and have those if ($_POST) blocks. I agree, though you lose a major UX option by doing this: modal window forms and pure back-end validation. If a form submits to the same endpoint that renders it, you can then show that form with the validation errors by using a `getJSON()` or `load()` on the form partial. That is not possible when you have a different form handler that redirects back to the show view with flash error messages.
Having worked with ZF2 I can say that having DI magic is not that good. Having `zend\db\adapter\adapter` (or whatever aliases are there) in your container instead of `db` doesn't make the system easier to understand. I would prefer to be forced to define the constructor of the `controller.users` object instead of having an automated process create 3 aliases for `usermodule\controllers\user`
I don't know if it's just cynicism, but does anyone else feel uneasy about Facebook's interest in PHP? What are they gaining from it all? Will they be data-mining everything that goes through their version of PHP? Is the full source visible to everyone? Am I completely misunderstanding the whole thing? Edit: Ok, I'm being downvoted, but will you tell me why? I only asked a genuine question.
&gt; though you lose a major UX option by doing this: modal window forms and pure back-end validation. What does that have to do with separating the back end? It's the developer's job to decide what response to generate based on the request. There's zero reason you couldn't accomplish this.
Until a few years ago, there was only one PHP - the one provided by php.net. There had been a few efforts to run PHP on different backends, but they were all slightly odd and mostly incomplete. And then came Facebook's hiphop, and later HHVM. This means that there are now two major (and a bunch of minor) platforms on which PHP programs can run. By formalizing the specification of what makes up the PHP language, and by detaching that specification from the original implementation, it makes it a *lot* easier to create PHP implementations and language-understanding tools (like those you'd see in a good IDE). 
So far, PHP has never had a specification, a document that states exactly how the language should behave. It was all just implemented in code, and people hoped for the best. (Which is partially why PHP is wonky and /r/lolphp has so much material) But that's causing issues with new advancements like HHVM and the engine rewrite that significantly speeds php up. There's nothing to refer to when implementing things, so the developers have to actually install a current version of PHP, play around with a bunch of edge cases, figure out how they work and why, then reimplement them in their project. If there's a proper spec, both the PHP developers and the HHVM developers can work against it so that both implementations behave the same way. Additionally, having a spec will bring a lot of major issues to light. Things like comparisons not behaving as expected. These issues are already in bug reports, but probably many years back in the archives. With a spec, there will be painfully obvious sections that have tons of edge cases, the developers will see those and can work on cleaning those up and overall making the language better. (in every implementation) 
This is really awesome! Those of us behind phpspec (phpspec.org) are a bit worried about the naming collision.
I think they'll change it
&gt; My boss will never understand this. "They called it 7 because they tried to do 6 five years ago but had to stop development on it, and they didn't want anyone thinking that this version was the thing everyone used to call 6." As opposed to the other explanation we'd have to give, "No, none of those Unicode things work at all in 6, it's a different 6 and you apparently haven't paid any attention to PHP development in five years if you think so."
I don't have a problem with 7 either: - It conveys the critical information of "I'm newer than 5" - 6, although un-released, was still a thing of note. - Is it worth avoiding confusion with 6? Don't see why not. - Now in the future if you want to talk about or search for the failed release of 6, you can. I don't see how calling it 7 has any negatives at all. Saying '6 normally comes after 5' isn't actually a good reason, as that has no negative effect on users/people other than 'it irks some'.
The initial claim was it being an anti pattern, you're arguing about best practices now.
No problem, I figured that. And thank you for the awesome responses!
Here's what I don't understand. You say "I worry... I worry...", as though PHP was a sick friend. Why are you so attached? You've seen things you like in other languages. &gt;&gt; I worry that some great features like static type hinting, generics, or proper annotations will never be available. Yet you seem determined to be a PHP developer. You call those who use Ruby "those people" whom you "hate". Why are you so attached? I know it takes time to learn a language well, but if you don't like the hammer you're using and you don't see it improving, try another hammer. Ruby, Python, Haskell, C#, ASP.net, COBOL, Erlang, or whatever floats your boat. PHP is not your dying friend. You can try something else. You can know and use multiple languages. And you might find you like something better, and stop using PHP. Or not. Whatever. But you aren't bound to ride the PHP train to the end. Don't worry, just experiment.
bjori just changed it to php-langspec :)
&gt; Will they be data-mining everything that goes through their version of PHP? No, but don't take my word for it: http://github.com/facebook/hhvm As to what Facebook gains: 1) A target to aim for in compatibility. 2) Good will. Personally, I work for FB on HHVM, but I've also been developing PHP for years. The leftie-hippie in me wants to bring those together. 3) Making PHP a better language overall. That means more people picking up PHP skills and bringing that expertise to a hiring interview.
That's absurd. 5.5 has been around for a full year. Welcome to the Arch club though :)
I was being facetious. I come from a Perl background, during the days of the "Perl6" hype. I abandoned Perl before it ever came to light.
I agree! Out of date repositories and dependancy issues forced my hand from CentOS to Arch (although I do consider Debian a fine distro). [I distro-hop](http://reddit.com/search?q=subreddit%3Aunixporn+author%3Am4rx&amp;sort=new) from time-to-time
Out of date repositories was what forced my hand from Ubuntu. I shouldn't have to wait two years and reinstall my OS just to get an up to date version of the language I develop with.
You could implement something around AWS Digital Media. http://aws.amazon.com/digital-media 
&gt; Made using an RFC that was in continual editing ~~right up until the vote started~~ even during the middle of the voting process. FTFY.
How bad is it that when I write if statements I like to do them like this: if (true) { // do a thing } elseif (false) { // do something else } else { // defy logic } Reason being that if I wanna comment out the `elseif`, I can simply cmd+/ those lines without it commenting out my brackets too
Thanks :-)
Thanks :-) You, /u/mike_sol and /u/WizKidSWE have explained well why it's a good thing, and nothing to worry about. I appreciate you taking the time to do that and not just downvote.
Thanks! Quite honestly, Laravel's IoC container looks great. I have never used it, but I believe I would be much less frustrated using it than with Symfony's one for example (mainly because it offers autowiring). That being said, there are a few differences so if you are interested to know: - Laravel IoC is mostly done for Laravel (obviously), for example the docs use the "facades" which work using Laravel framework. I imagine it's definitely possible to use the IoC alone, but the docs are not meant for that - PHP-DI is framework agnostic, and it has several "bridges" so that it can work with many frameworks: ZF1, Symfony 2, ZF2, I've done Silex but it's not in the docs yet (not Laravel yet though) - PHP-DI offers annotations (*[which are only useful in controllers, don't use them everywhere](http://php-di.org/doc/best-practices.html)*) - PHP-DI supports [lazy injection](http://php-di.org/doc/lazy-injection.html) and I can't find anything about that in Laravel's doc - [I put a lot of work](http://php-di.org/news/06-php-di-4-0-new-definitions.html) into optimizing the config syntax to make it practical and easy, this is a personal preference but I find the syntax (with arrays and all) nicer than Laravel's service providers That's the main things, since I haven't used Laravel yet I'd be interested to know if I'm missing major features.
There is a balance point between putting too much on one class and scattering it across too many classes. SRP says "fuck good practice, scatter it as far as possible". So forget SRP and concentrate on questions about cohesion and encapsulation.
How much time do you want to spend searching for the right class? How much time do you want to spend searching for the right method in a class? Balance these two and you'll be much happier. 
I run most of my stuff on Linode. Mainly because it's a good combination of simplicity while still offering a few extra "power" features like Node Balancer creation and management, as well as some decent charts. Also, they have a "managed" option if your app gets pretty serious and you want a hand with the server management. I wasn't paid to say this or anything, heh.
I usually just hardcode the URL in the configuration. Really depends on the setup.
Listen, this isn't a sub for beginner's tutorials. Please refrain from posting these sorts of links in the future.
phpng won't have hack. that itself is a loss
Facebook does millions of things without user's knowledge - but with their consent, from the EULA they don't read. Can't really call it underhanded if they do what they want with a service they run that people use voluntarily. &gt; As someone who only codes in PHP but has never actually compiled it Back in the day, you used to have to, because distro packages got horribly behind. These days, I can see that you'd virtually never need to know how to do it by hand any more. It's still a good exercise, though, and a locally built version with just the things you need can be faster than a generic one, though more work to maintain.
Do you mean phpspec.net? phpspec.org is some crazy Russian expired domain
&gt; I don't know if it's just cynicism, but does anyone else feel uneasy about Facebook's interest in PHP? Why? They power a big chunk of their business using PHP, and this isn't chump change, its a $200 BILLION business. It would be very odd and risky if they just sat back and relied on the community to drive the development of their backend. Thats why they are taking control and forking it into their own stable platform, so there are no curveballs which could affect them in the future You're right to be cynical about Facebook in general, but you should separate their business practices (ie, far reaching data mining) from their actual technology platform. 
&gt; now we're going to see the same idiotic book publishers put out clueless, incomplete, useless "PHP 7" books in the same way that they did for "6" Technically the publishers are not idiotic. It's the idiots that buy them, publishers (and the authors) are just trying to make a buck any way they can. Preying on the naive for profit is nothing new :P
If you're going to comment entire blocks, my favorite way is like this: /** if ($var) { $x = 1; } /**/ The reason is that to uncomment, I just need to do this: /**/ if ($var) { $x = 1; } /**/ The only time I really use these kinds of comments is when I'm testing something, which is a time I'll want to comment and uncomment frequently.
&gt; Break too much and offer too little (e.g. Python 3) and people won't bother migrating, resulting in complete fragmentation of the community. I kinda hope that FB gets further and further into just forking PHP, so that we can have the starter PHP and the grown-up PHP. The community might not migrate 100% of applications, but that's fine with me if my internal shop can leverage 95% of our PHP knowledge and teach the extra 5% that breaks.
I do something like that to detect true production, stage or dev. 
AWS is a great platform if their other services look attractive to you. If you're doing a large app right, you're also going to be looking at queues and mailing systems. AWS gives you instances as well as the ability to use an Elastic Load Balancer - really easy to spread the load. You can then set up Autoscaling so that when all your instances are taking a hit it will boot up new ones as necessary to keep the app going. Of course, you're going to need to know how to provision servers (or use something like Laravel Forge or ServerPilot). RDS is a great platform your database and they have made it really easy to set up read slaves and database backups. S3 is great for storing files, CloudFront is really simple to set up to serve your assets over a CDN. SQS is a simple queue system (like the name implies!) that Laravel has support for out of the box. You've also got Route 53 which makes internal DNS routing within the AWS platform seamless. The only AWS service I might consider giving a miss would be SES. Their email service is very basic - go with one of Laravel's supported platforms like Mailgun or Mandrill; they give you much better tracking/analytics and I think Mandrill even helps you write correct code for your emails. Source: we are moving our Laravel apps from dedicated servers to AWS.
&gt;Facebook does millions of things without user's knowledge - but with their consent, from the EULA they don't read. Can't really call it underhanded if they do what they want with a service they run that people use voluntarily. Yeah, that's true. I wish more people did read them but they never will. &gt; Back in the day, you used to have to, because distro packages got horribly behind. These days, I can see that you'd virtually never need to know how to do it by hand any more. It's still a good exercise, though, and a locally built version with just the things you need can be faster than a generic one, though more work to maintain. That's pretty much the situation I've had. I only got into PHP when it was PHP 3, and I was on shared hosting then so didn't have to even think of compiling it. I didn't really understand Linux as an OS, and any time I attempted to install it locally, it failed due to lack of drivers for one piece of hardware or another. If I asked online for pointers to a guide, it'd always be that RTFM attitude ("if you're not able to even look it up, you're not ready and I'm not gonna tell you how"). RTFM is great if you already understand it, but not if you're trying to learn. In the years since, I've gone from using shared hosting for development to installing PHP on IIS in Windows, to having a local linux dev box, and on that, moving from shiny gui stuff to more command line, and getting a better understanding of how open source works. My local linux dev box is due for a wipe soon, because I've learned a lot since I last set it up, and it'd be a good time to try a local build of PHP. It's all a learning curve, and I'm still learning. Thank you for being polite and not just downvoting me into oblivion.
I'm definitely not opposed to this method. I already have an html5 multiple file uploader in place for uploading single songs so implementing it would be familiar. My issue with this method is allowing the user to download the entire mixtape of songs. If the user uploads all the files at once, can I have the server package them into a zip for later download? 
Right, but JS would still be "popular" without Node.js because nothing can replace it in the browser. You can transpile into JS, but the end result is still JS.
&gt;Ubuntu 14.04 LTS has several issues Do you actually understand any of those "issues" you talk about?
doesn't conform with [PSR-2](http://www.php-fig.org/psr/psr-2/), [ZEND](http://framework.zend.com/manual/1.10/en/coding-standard.coding-style.html#coding-standard.coding-style.control-statements.if-else-elseif), [PEAR](http://pear.php.net/manual/en/standards.control.php), etc
&gt; though more work to maintain Oh yes. (currently switching about 300 machines over from source built packages to rpms and utilizing puppet)
Actually, I spent all day perfecting my server setup documentation for Ubuntu 14.04. I ran into several issues. However, I was able to work through all of them. They are all minor, but annoying. I mildly don't like the kernel situation. Also, I had an issue with the plymouth upstart bridge spamming dmesg with a bunch of respawn errors. It doesn't hurt anything but I am extremely OCD about my server setups. I will spend days polishing my procedure for the way that I set up my servers. It really annoys me when I see anything that is even slightly unpolished in a distro. I do the same thing for tuning the installation. For example, for many settings I will develop equations for the optimum values based on various system factors. I know it is overkill, I just really like my servers to be clean, stable, and very boring.
Indirectly, usage stats of the internet at large for this particular metric are a very good indicator of relative "stableness" for several reasons. I am further making an assumption that the big three are "stable enough" for a discussion of the comparative stableness of each of them to be non-productive. 
This is the correct solution. However, per [RFC 2616](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) you must format the response properly as well. &gt; The response MUST include an Allow header containing a list of valid methods for the requested resource. And people think APIs are easy. :D
Is Facebook positioning HHVM for world domination? If that is the case then I, for one, welcome our new PHP overlords. 
For REST a DELETE should return status code 204 No Content with no response content. **EDIT**: Check https://github.com/zfcampus/zf-rest/blob/master/src/RestController.php for a pretty solid implementation.
Yes, exactly. **EDIT** Comma separated if you add other methods. e.g., header('Accept: POST, GET'); P.S. I'm not an API expert. APIs are hard and what I know I've learned from using Apigility. There are are ridiculous amount of things to consider when doing an API so if you have the choice don't roll your own unless you have a very good reason.
$_SERVER['PHP_SELF'] won't help if you move to a front controller/pretty URLs setup. I doesn't answer your question, but personally I would bite the bullet now and install one of many available Router packages and get your application structure right from the get-go. Then you can also use reverse routing to build your links. Read this excellent section of [Symfony2 versus Flat PHP](http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html#a-front-controller-to-the-rescue) for how to set up a simple front controller. 
I am with you about using vanilla. I've mostly used either Ubuntu LTS or Debian over the last or so ears. CentoOS before that. In general I favour Debian the most now for web hosting. Seems a good balance between stability and availability of packages. My favourite aspect is the rolling releases. Generally have found upgrades slightly more straight forward and less risky than with Ubuntu. If I do need a later version of something then I use **apt pinning** to get the package from the Debian Testing release which actually is pretty solid and what I think Ubuntu periodically takes a snapshot from. On one occasion I did use dotdeb as wanted google nginx page speed module and I prefer to not compile myself as makes it easier for other devs to help manage the server if they are not as familiar with Linux. 
That doesn't really make sense to me. By that logic Internet Explorer was the most "stable" browser for many years (which it clearly wasn't).
&gt;6 is cursed. Believe it or not that was actually one of the arguments by the pro-7 camp.
I think the title of "Developer that is familiar with the full stack" would be more fitting. But then again, the origin of the "Stack" refers to the L(E|A)MP stack. So I'm sure it just ends at the CLI layer as far as deep goes. I also agree a lot on what you said regarding how you are able to troubleshoot past your job scope - as a developer who just provides the codes - and when an error is presented that has nothing to do with the code you produce.
Just as an FYI, NetSuite has an attrocious API. Had a project that needed to integrate NetSuite into Drupal UberCart to handle various customer loyalty coupon and discounted transactions. It took one of our senior developers about 2 months just to get a mental map of NetSuite's API, only to find out that a minimum API request to NetSuite was approximately 8 seconds long (others up to 36 seconds), making it painfully slow for ajax coupon lookups for returning customers. We had to implement a very complex cron'd two-way synchronization system that essentially meant duplicating a lot of NetSuite's functionality locally so that lookups would happen quickly. It was not fun. At all. Just putting that out there in case you get the incorrect impression that NetSuite might be a good option.
If you don't mind hosting in the UK, Redstation gives you absolutely beastly servers for cheap, even with the unfavorable exchange rate. They also offer discounts for paying up front. Example server configuration I currently have: * Hexa Core: E5-2430 - 2.20Ghz * 96GB DDR3 * 4 x 600GB SAS 15,000 RPM * H710p Raid Controller with BBU - Raid 10 * 1TB Dedicated Windows Network NAS (for super fast backups) * 4 Usable IP Addresses * 1Gbps Port - 500Mbps Guaranteed, Unlimited Bandwidth (you can do light video hosting with this) **£199.98** monthly if you pay month to month ($337 / month) **£169.98** monthly if you pay a year up front ($287 / month) You simply cannot match those specs on AWS, Digital Ocean, Softlayer, or Rackspace for that price, not even close. The only sticking point is the exchange rate is heavily favoring the UK right now. If the exchange rate were better, those USD prices would be dirt cheap. Also, Redstation's support is very prompt. The only issue I have with them is they won't reduce the cost of your server when you ask. You must order a new server at the new price, re-provision it, and cancel the old server.
http://i.imgur.com/ERO0MKv.png
I suggest you to take look at how other languages/frameworks are utilizing auto-wiring feature. I also suggest to use cache as mnapoli mentioned. I'm not exactly sure why you think it doesn't add value. If you think that way, composer doesn't add a value as well. Would you use composer without having a cache? I hope not. You will be surprised that some people even say that an IoC container is not an IoC container without auto-wiring feature. 
Just looked through it all-- its definitely a cool little system! I have no idea what real-world usage I could apply it to though.. I think a real-world, practical example (not just basic maths) would go a long way in showcasing the idea. It definitely got me thinking.. and that's always a good thing :)
This looks really great. Do you happen to have a benchmark? I don't expect it to be slower than any other containers, but it would nice to see one.
Spec is a win. Facebook involvement ... well, I have a hard time trusting them. We're talking about a company that made its billions treating users like shit.
Yeah, Fuck Zend! Stuff like "the 7" is fucking *ridiculous* superstitious nonsense that makes even PHP apologists cry in our sleep. The language spec is something we have wanted + asked for for, gosh, over 15 years now. And it took Facebook? Hello?! I, too, have started using HHVM in production. I, too, say fuck Zend's past "stewardship" of PHP since [**The Great Backslash Namespace Backlash of 2009**](http://www.newmediacampaigns.com/page/php-namespaces-backslash-example), even breaking backwards compatibility in minor releases, plus all the Internals drama. As long as the 5.2 syntax plus closures stay alive, I'm good. HHVM+Hack existing can only be good things, since Zend's lack of leadership is leading the language to the veritable breaking point.
&gt; I'm not exactly sure why you think it doesn't add value. If you think that way, composer doesn't add a value as well. Well that is a weird argument. I said that caching does not add value, because the problem can be solved in a more reliable and efficient manner by using a file monitoring service and generating the container file in the dev machine automatically. 
...not a Perl user, I take it? Perl6 had been in the works since __2000__. PHP can't even *fuck up* as well as Perl can.
Long live HHVM and HackLang! Thank FACEBOOK that in 2014 we *finally* have a mostly viable alternative to what was once the utter hegemony of the Zend Engine v2! Facebook, no matter what, has done something AWESOME for the entire community! We should all chip in and donate $100 to each company for each year we've used their products. Unfortunately, I couldn't find ways to donate to either, and I am incredibly loathe to purchase Zend Studio again after being burned three times already.
Could you explain why you think using a file monitoring service is more reliable? You're trying to solve a problem by adding one more layer/service. I don't think that's a bad idea. My point is that the problem you're solving isn't a problem in the first place. It works on dev without cache and it works with cache on production. What's the difference between the generator you're talking about and the caching feature found in pretty much all the other containers? Update: I'm not trying to say that your method doesn't work. Watching file changes and generating a pre-config (??) file is used in many places and they work. My point is that what benefits do you really get out of that? Does it dramatically increase the performance over the caching? Does it provide better dev environment? I had a similar question in the past and did a few tests. I don't have exact numbers, but even with a deep dependency graph (around 20 as far as I remember), it didn't slow down the performance even without any caching layer (including APC or OPcache). 
&gt; Can't really call it underhanded It's definitely underhanded if you quietly change all the default facebook permissions to the point where people are over-sharing and don't realize it.
&gt;So, for entirely the wrong reasons, you're right. Don't get bogged down in semantics. A grease monkey or body worker isn't a full service mechanic with ASE + specialty certifications who can build a car better than new. A line or fry or short-order cook don't have the same range of skills as a chef who will be able to plan a menu that will make money and manage the kitchen.
File monitoring service such as [inotify](http://en.wikipedia.org/wiki/Inotify)is provided by your OS. It is not part of the application. And the process that happens to regenerate the container is not in the scope of you application. In the same way the process by which you use composer to update your libraries is not part of your applicaton..So you are not adding any more layers to your application by using a File monitoring service like inotify. The generator that I am talking about is a script that walks through your source files and generate a pimple container file based on the constructor arguments of all the classes it finds. It is the same mechanism that things like PHP-DI that uses auto wiring use, but they do it at run time, and they cache the results so that they dont have to do this on every page load. But it is not very reliable and still has some overhead... By using PHP-DI you are delegating something that can be done very efficiently on the dev machine, at the development time to the production system at run time. Which absolutely makes no sense to me. It is like processing .less files into .css on server, so that the developer is saved the trouble of manually compiling the less file every time the less file is changed. And you know that every less compiler has an option to monitor less files for change and convert it into css when ever a change is detected. Same thing. 
The generator or watcher you're talking about depends on inotify, you're not using inotify directly. Generator/Watcher is another layer in my opinion because it's a dependency to your development environment. Runtime injection can cause performance issue if there's no cache whatsoever. I'm not entirely sure what your generator generates, but I assume that Pimple has to use reflection unless you use Pimple as a service locator. If a container caches a dependency graph, what's the difference between the file/dependency graph that your generator generates and the cache file that a container generates? Both containers have to use reflection and find out what a class requires. If a container generates a cache like below, how is it different than a file that watcher/generator generates? $dependencies = [ 'classA' =&gt; [ 'classB' =&gt; [ 'classBA', 'classBC' ], 'classC' ] ]; if one of your classes depends on 'classA', any container can generate a cache like above then simply loop through the array and inject the classes for you. watcher is a good way, but I don't see why anyone wants to use it when a container can generate a dependency graph cache in production. May be we're talking about a similar concept, except that you're using watcher in dev environment? 
I'm more worried about a company that names a language "hack". 
&gt; I agree, though you lose a major UX option by doing this: *modal window forms* and pure *back-end validation*. 1. Can't be done anyway 2. How would you lose that when you just change the url where it gets posted to? &gt; If a form submits to the same endpoint that renders it, you can then show that form with the validation errors by using a getJSON() or load() on the form partial. &gt; That is not possible when you have a different form handler that redirects back to the show view with flash error messages. uh... No you don't lose a thing. You just flash the inputs to the session and then pull them out of the session...
What I would do is the following: * Upon receiving the zip file validate that the file is in-fact a zip then move it to a directory for processing and save a record in your database containing some meta about the file and a flag stating its ready for processing * Have a process/cron (actually something like [gearman](http://www.gearman.org) is perfect for this) check the database for pending files, unzip the content run an antivirus on it (possibly [clamav](http://www.clamav.net)) and then just copy the valid mp3/ogg/flac/etc files to their final destination, updating the database with meta from each and linking it to the original upload record * Provide the user with feedback once the task is complete and inform them of any errors, if any, that occurred. I imagine the above process from a UX point of view, would look similar to uploading a video file to Youtube, where the user is provided with a progress bar and an eta for when the processing will be complete. As a disclaimer the above is a quick "back of the napkin" plan of how I would go about the task, there are likely to be more than three points once a final plan is mapped out - but this should give a good idea of how someone could do it.
Of course, just use PHP's [ZipArchive](http://php.net/manual/en/book.zip.php) class, for instance. Having to deal with ZIPs is a mess - it's a matter of time until someone uploads a [zip bomb](http://en.wikipedia.org/wiki/Zip_bomb) or some cleverly crafted malware, and the users wouldn't want to have to create a zip before uploading, anyways.
&gt; What are they gaining from it all? Cheap, naive and guillable workforce..and they are in a position to actually attempt to fix the shitty aspects of the language, So it is a win for the php community and that is what really matters...I Hope 
&gt; It is like processing .less files into .css on server, so that the developer is saved the trouble of manually compiling the less file every time the less file is changed. I would take that anyday over having to compile .less files (as long as everything works as advertised and there is no perf impact in production), so that's probably where we agree to disagree :) Similar thing: Doctrine proxies are generated on the run in dev (eval'd in memory now with latest versions), and manually in prod (i.e. it's the same as clearing the cache). I much prefer what is done today than manually generating them in dev *and committing them in git*.
I don't take offense :) &gt; which also can be automated using file monitoring services like i notify quite easily. I personally don't think setting up a script with inotify on every dev machine is easier than just clearing up the cache in the deploy script. &gt; And please don't justify it because Symfony uses it every where. For things like Doctrine an templates like twig, caching cannot be avoided. Not so with dependency injection. Well in Symfony the container is completely cached and regenerated in dev (automatically).
&gt; as long as everything works as advertised and there is no perf impact in production Well, there will be performance impact. That is the whole point, or else that wouldn't even be an argument...right? But you seem to avoid my argument that there can be tools that can detect file changes and regenerate the container files automatically...so that will solve your problem of manual configuration. And when you need manual configuration, it can be much easily done from Pimple container files, instead of having to deal with the intricacies of a DI framework. 
I've got a repo where I **try** to benchmark DI containers, but it turns out it's really hard… Given most containers use a cache, and OPcache plays a great deal (there are file accesses), I need to set up a whole HTTP server. I first tried in a VM using Vagrant so that everybody can reproduce it -&gt; the VM slows everything down big deal :( And that setup means I query through HTTP right? -&gt; The whole HTTP overhead is much bigger than the container's usage so the numbers I got weren't very useful :( I even loop around getting containers entries a hundred times and more (which is very unrealistic) and even then there are little to no differences showing. The conclusion I got to: - I need to benchmark a real application with different containers - Even then, I wouldn't see a difference because containers are such a small part in the request So that's when I stopped caring too much about having a benchmark :) I would be interested in anybody has ideas for benchmarks though. This is the repo: [mnapoli/di-benchmark](https://github.com/mnapoli/di-benchmark) (this is quick and dirty code)
&gt; I personally don't think setting up a script with inotify on every dev machine is easier than just clearing up the cache in the de... I am not sure why you say 'on every dev machine'..You set up stuff you want on your development environment...What is the big deal? And not every project need to use a deployment script...right? 
It depends. You can either prebuilt a cache file then simply replace or you can dynamically generate a cache file progressively as your application request a class. It just depends on how you approach it. I don't believe anyone will try to re-cache the whole dependency graph in the production. Not only it's unnecessary, but it will impact the performance as you mentioned. As long as you can create a cache without impacting the performance (progressively generate a cache or prebuilt it on staging or dev), I don't see any reason why I would go back to a container without auto-wiring. 
I meant for every developer.
tool or layer, it's an extra thing you and your team members have to manage. it can be an issue as your classes grow since the watcher has to check more files and then regenerate a cache. How would you detect dependency changes with a watcher? When I change a single char in a class, do you re-generate the cache file? I don't know. it works for less, sass, and js..but we're taking about class dependencies. 
&gt; Well, there will be performance impact. Where? &gt; you seem to avoid my argument... I totally understand the point you try to make! It's just that I really don't like that solution. Setting up a script with inotify for every developer is a big turnoff for me. I wouldn't even know how to do it honestly. Does it work on OS X? Windows? Do I need to start the script everytime I begin to work on the project? Does that automatically start where my computer starts? Will it slow my machine down if I work on many projects at the same time? I imagine the new junior on the team will struggle with that even more, and *uselessly*. Why bother so much where something can do it for you so that you don't care? &gt; And when you need manual configuration, it can be much easily done from Pimple container files, instead of having to deal with the intricacies of a DI framework. PHP-DI offers pretty much the same syntax than Pimple, only with (optional) additions. So if you only want to write closures, you can perfectly do that just like with Pimple, nothing complex here.
Who said you had to show a site's complete code online as you portfolio? Just a link to the sites you made, and additionally what tools you used (framworks, front/backend) tools will suffice. You probably should [take a look at this site](https://www.addedbytes.com/) to get some ideas. That's how I would do it. 
Sure, they need to... :), I have no more arguments..
Go with Linode instead of Digital Ocean for this type of project! A lot more tools are available, it's a more polished platform plus they're currently beating DO with their pricing! It's a no brainer.
I have been using https://github.com/tedious/Fetch for quite some time and it works really well.
Once the specification is complete I'd be interested in seeing "PHP implemented in X" kind of projects.
I've never been much of a blogger, but gathering parts of the code which represents my style best makes sense. Thanks for replying. :-)
Please comment here your thoughts on what I need to post. thanks :)
I think it depends on the company, ready to hire you. If they just want to know you can create websites, then links will be enough, otherwise, you could create a github account, like [mine](https://github.com/bivoc) and just contribute to / create to open source projects. In doing so, it will let them know if you are more than just a website designer. 
&gt; Building a Better **PHP** This is Hack, not PHP. 
The c in your phpspec logo looks like a Q.
"Do not advertise." [Subreddit FAQ](http://www.reddit.com/r/PHP/wiki/index)
It's unrelated to my original question, but where do you start when you're pulling/pushing things on Github? Do you have certain projects you decide to work on, or do you just randomly stroll past things seemingly interesting and see if you can contribute?
Well, I used to hangout [here a lot](http://chat.stackoverflow.com/rooms/11/php) and got the inspiration from the PHP Gurus there, just to build simple stuff, have it on github so they could review it for me. That's just about it. I hear plugins for SF2, Laravel is what PHP devs look for the most these days. You could give that a try. 
&gt; assumed companies/recruiters would want to see example code as well Never show code you made for another client. Ever. If you did that to me, the interview would be over. If they want sample code (not all companies do), create a github account with a sample project. 
This comparison by OP between Java and PHP makes no sense to me. Both languages are products of ecosystems that while not at cross purposes seem to serve very different audiences. If anything, PHP has been in a position to learn from the Java community's tendency towards over-engineering and adopt features ad hoc to reach a level of maturity now that it is expressive and fun to use. Moreover, the established community has attracted some fantastic developers that have championed the virtue of developing in accordance with a whole range of industry standard best practices and in doing so have produced a compelling toolset that supports PHP as a good language to develop in. As such, I feel the current incarnation of frameworks represent a renaissance of PHP. Fundamentally, Java and PHP are different languages oriented towards different goals. PHP got lucky in that it bet on the web early, while Java is much more general purpose in nature and definitely a better fit in the enterprise world due to its versatility. Both of them are great languages as evidenced by their popularity but I know my preference is PHP as I consider it well suited to handling the whole HTTP request/response cycle. Until it's no longer the best fit, I'll happily use it to create good software.
Watch out it doesn't cover all IMAP features, like (IIRC) moving messages, marking them read, etc. I needed a library providing me all the features possible, I first tried the zeta components library but it's buggy and not maintained. Then I switched to Horde and it's working, faster than using the PHP extension, and feature-full. However it's pretty much low level, so you need to get your hands dirty and learn how IMAP works. And the documentation is not very good too :( But that's really the best solution there is. I have began writing a library that is a layer on top of Horde, in order to provide a much higher-level library (much easier to use). I'll publish it sometimes when I get to finish it and document it properly.
#rekt
Yeah, good point, this is quite important too. PHP doesn't care about your source code's encoding and it treats all strings as bytes, so if you had a literal string with UTF-8 characters in your source code, it won't touch those bytes and everything should be fine. However, your text editor or IDE might be encoding your source code in something other than UTF-8, so you must check that.
FTA: &gt; The OO craze has a part to play in this madness as well. More and more developers are stepping back and realising that as a programming paradigm, OO is actually pretty shit. Would like to see some arguments for this.
Fleeting thought: is that dependency inversion (gone wrong) ?
[Fetch](https://github.com/tedious/Fetch/blob/master/src/Fetch/Message.php) has moving messages [moveToMailBox($mailbox)] and marking read [setFlag('seen')]. I am actually using it for the exact same reason /u/Kratzyyy wants to use it.
Having example code is always a good thing: keep it in github and just send them the link when asked.
&gt; The service locator itself is not an anti pattern and it's definitely not an anti pattern when used in a slim controllers. It is an anti pattern, it is also used in Java but it still is an anti pattern because it hides the dependencies, you can read more about it in the internet and I think even in martin fowlers blog. also covered in one of googles talks: https://www.youtube.com/watch?v=RlfLCWKxHJ0&amp;feature=youtu.be &gt; You keep going on about best practices, while ignoring that they are nothing more than a means to an end everything is relative, genius. &gt; call bs on your claim that controllers as services are best practice Hm... interesting... because I never said anything similar to this.
This is the easiest way to spot bad coders imo, anyone who hates on a language without actually telling you what you should be doing instead and why. You never learn anything from these people and they have nothing to offer their colleagues or community. callow piffle
You should be using Laravel instead. There. I'm a good coder.
Thanks for the clarification! Quick rundown to round out the comparison as I'm seeing it: You can use Laravel's IoC as a standalone component really easily. Service providers are for registering bindings on the Laravel core Application class (which extends the IoC container), so that wouldn't be an issue if you were using the container by itself. If you're wiring up your own application with the laravel container you can easily put that stuff all into one bootstrap-type file. But as far as I know, PHP-DI is distinct in that you wouldn't be able to accomplish this with an array configuration. With laravel's ioc it's basically a bunch of calls to `$container-&gt;bind('FooInterface', 'ConcreteFoo');`, with options for singletons and of course passing in closures for the resolved class and probably other stuff. Lazy injection looks pretty sweet! Same with the annotation capabilities. Also the config syntax looks like something I could definitely get used to. I suppose one final thing to point out is project size - Laravel's IoC is a single file with no dependencies, something like 800-900 lines of code. PHP-DI is pretty gigantic in comparison, but obviously that lets it come with some very cool extra features. 
These are good tail-end questions to help find really senior PHPers. You certainly shouldn't start interviews with these as most interviewees will get them wrong and you'll have no idea where on the spectrum of experience they sit. Nitpick: You write: "sets all intermediate characters to blanks." Instead of blanks you should say spaces, yes?
OOP is shit? yes ...but so is everything else if you have a massive codebase it will fluctuate between verbosity, magic, design patterns, convenience, edge cases and no mather how many times you refactor it will not be as good as we would like it to be for small projects, libraries and things like that you can have nice things.. but it often feels like we do things for the sake of doing it, like Linus Torvalds once said: "it's not programming, it's masturbation" (paraphrasing)
Great lists. I literally solved 0. I hope you are happy now :)
&gt; Also, controllers as services refers to controllers that don't utilize service locators. Which you have been touting as best practice. Genius. uh no, controller without service locator are not a controller as service... You know you could use simple dependency injection to inject the dependencies in to the controller and BOOM the controller have to search for them on its own! Genius...
Most of these are cute little gotcha questions, and as such they can be fun for trivia games, but as interview questions themselves I don't find them terribly useful. Simply *running the code* will give the answer. What you want to find out from an applicant, *after running the code* and getting unexpected output, is: "Why do you think the code is giving that unexpected output?" Alternatively, I'd be much happier with a candidate who can tell me what XSS, SQL injection, CSRF, and other security flaws are, and how to mitigate them.
This is where he lost me. It sounds more like "I don't understand what factories are useful for and I hate long class names" There will always be over-engineering, but if anything, the PHP community is moving full steam towards applications composed of small, well encapsulated modules. Symfony and Zend framework development are perfect examples. We're taking all the benefits OO and leaving complex inheritance schemes and other anti-patterns behind. It's a great time to be a PHP developer.
Yep...
Thanks Sara :-)
What's your go-to move if the block you're commenting out contains its own multi-line comments?
Thanks for the clarifications :)
I approve this message.
Ok, but, i run away the moment that i saw a link to OpenCart :(.
Not the best designed thing, but at least it seems to work fine.
Now if only someone would make a formatted version available online, seems to be too big for GH's markdown parser.
Hi! Actually I'm sharing a link that is related to php and I'm looking to get some ideas on what to post to my blog. In some ways, to get page views also, but I believe that the content of my website will also help when it booms. :)
Old PHP programmer saying: PHP is the second to worst programming language ever developed. And all the other languages are tied for worst. Just insert whatever language you happen to like. 
Boy scout motto: Leave it a little better than you found it. Every time you touch it.
This bullshit again. Swallow a shotgun blast.
Half the article is attacking straw arguments (the PHP/FI syntax is not remotely relevant) and the other half shows a serious ignorance of the entire topic (geez, PHP arrays are actually hashtables? And that's a negative?) I'm sick of the goddamn posing by fuckwits who think being a CS student makes them qualified to do more shut the fuck up until they do something of significance in the world.
Unfortunate choice of title, as I think many will probably think this means "Criticizing Facebook's new PHP spec", while the article is actually more appreciative than carping. I was actually surprised to see the memory model described in such detail in the spec, despite being abstracted. 
I'm not so sure about that -- I do all of the above and have to come up with the design and aesthetics of every website and application we produce, not to mention general administration, etc.
I'm glad you said that, because that's the first thing I took it as when I read the title. It's a really well written article by someone with a lot of knowledge in the subject matter.
I was paid to upvote this.
We're working on splitting it into chapters, and producing html/pdf/etc... versions for read-only uses. Stand by :)
Ohh cool! Thanks!
Full stack developer means (to me) working 16 hours a day and not making headway and your boos is too cheap to go hire more people. You start taking shortcuts all over the place, in code, no test scripts, ad hoc deployment and patching, OS/network tuning and to top it off, support calls. Eff that job.
Depending on what your site does, sometime overkill is better. One issue that I think will happen is I login to you site at Location A on my laptop and move to location B (different IP), and I will be forced to re-login. If that is the kind of security you want, then it is cool. 
**critique**: *a detailed analysis and assessment of something* I think the problem is that people bitch about everything, so anytime you hear the word critique, it has negative connotations.
You continue to not getting it. Have at it.
It's hard to know how to read remarks like this from that article: "Finally, what does it mean for me? Well, I’ve left that ship already. I’ve hated PHP for a long time, and have no desire to go back to it." Still - assuming you're back with us now - I hope you'll post more of your thoughts about the spec in future, as I enjoyed reading this article. 
If apache is configured with AcceptPathInfo, PHP_SELF can be fooled and if you use this in a form, the content of your page can be changed with a crafted URL; try something like http://hostname.com/index.php/yadda"&gt;yadda. SCRIPT_NAME or a hard coded URL may be more appropriate.
The IBM code example is flawed?
Considering contributing to open source projects to show your coding skills. :)
yeah that could be an draw-back
That is funny. After a few years of not touching it, things don't look that bad!
I typically host on DigitalOcean ( https://www.digitalocean.com/ ) or Pair ( http://www.pair.com/ )
Here's something: [How to Make / Create Your Own Website: The Beginner's A-Z Guide](http://www.thesitewizard.com/gettingstarted/startwebsite.shtml) Steps 1-4 are relevant, anyway. Basically, buy a domain, buy hosting, point domain to hosting, upload files via FTP or through host's interface... profit!! (or get an 'A').
Thanks, been writing with this library all day and it's made my life super simple. :)
That is incredibly handy in scraping. Thank you!
There are some options if you want a free site, although they may be more complicated than you want to get. [Squarespace](http://squarespace.com) gives you a 14-day trial, with no commitment. Or you could try [Dropbox](http://www.dropboxwiki.com/tips-and-tricks/host-websites-with-dropbox) + something like [.co.vu](http://codotvu.com/). Hopefully the prof appreciates the initiative and you get extra points for trying something different.
That's no reason to be concerned with Facebook's involvement in a PHP spec. They have pretty solid developers and engineers who know their language design. I'm glad this has the backing of Facebook because it makes it more likely to be adopted and listened to.
You're probably right, but I can't seem to shake the feeling that we'd all be better off having as little involvement with facebook as possible. PHP's adoption rates are just fine without them.
Ha yes I'm facing that too :( Give a "+1" here: https://github.com/horde/horde/pull/89 Unfortunately the Horde guys are not considering it a priority because their setup works with PEAR and bugs with Composer :(
First you should learn to write proper titles and subjects.
I make no claims that it *validates* URIs, just that it matches them. I'm sure you can make false positives.
That's exactly it! Kind of silly they're not willing to give this more attention. A lot less people will be willing to install the library through anything but Composer and their docs do actually say you can use Composer. Ah well, I've +1'd the issue.
SugarCRM isn't the best code in the world plus it has almost no documentation. I hope you aren't coding in that style. Its a great way to learn terrible OO. Read an advanced PHP book. Learn about abstraction, interfaces, design patterns, and how to use the SPL.
If they want you to do it for a school assignment, they should provide you with web hosting.
Haven't seen SHTML in a while.
Hi! I have just put the project on GitHub to share the source code. (Only the customer part.) I posted only the website link earlier (16 hours ago). That time I had not plan to share code, the full project.
Ha, I didn't even notice. I guess the old stuff is pretty solid, that was the first page I found that gave a decent overview of the whole process.
Have a look at the SOLID* principles if you haven't already. Another step that might help you is to code from the outside in. First write how you actually want to use your objects and methods, then make them work. And of course try to practice as much as you can. Make projects and see if people can give you feedback. Use different frameworks and libraries to see their design approach, its pros and cons. Keep making the mistakes you consider stupid. Chances are you'll make the same mistake less often with time. * http://en.wikipedia.org/wiki/Solid_(object-oriented_design)
Thanks so much! I really appreciate the help. I swear, it took more time set everything up than it did to actually code everything. &gt;_&lt;;
The teacher recommended Wix. It's what everyone else is probably using, but you have to use a template. I wanted to start from scratch because I thought that would be more fun. It just seems so silly that all these PHP tutorials will baby you through "Hello World" but not mention how much work it is to get everything set up. If I had known that in advance, I'm not sure I would have attempted this. 
I just figured out how to push their "Hello World" example. I think this is what I'll be using. Thanks so much!
If people don't know what "critique" means, fuck 'em. It's their mistake, not the article's.
And it's horrifically outdated.
Certainly can but it's a great starting point. Validation is an interesting problem to tackle: would you prepare use cases for the different types of URIs to test validity? Computationally expensive? edit: By matching on the URI scheme (before the colon) you could select the relevant use case and perform the test for validation.
I prefer W3schools myself. ^/s
Sure, but that'd require programming in addition to regex. I think validating if it matches the scheme in general shouldn't be too hard. I made that thing as a way to actually *learn* regex; I didn't do several parts in very smart ways, and I'm sure there are better ways to do certain things that would let it validate. Particularly, I think there's an issue with the way I handle IPv6 addresses in there.
While I generally agree with the author here, the way he's gone about this is pretty old-school. First off, depending on your webserver, having a log-running, resource-intensive process running within the webserver's request-&gt;response cycle is only going to slow everything else down. You should really move these sorts of interactions into another process and periodically check the status of that other process. This is typically handled by the queue/subscriber paradigm. Basically you have an entirely separate process that consumes these 'job requests' and actually performs the work. Once that job is complete, it sends back a notification that the job has been completed. Then the problem becomes progress: PHP is an inherently blocking, single-threaded language, so how can you tell "how much" of a blocking process is done? The answer is probably to break the task down into the smallest parts possible. For example, if you're sending an email via an SMTP server, you can likely determine when you've connected to the external server (~33%), when you've sent the message (~66%), and when you get some sort of acknowledgement. You can then curry that data to your end-user. At this point, you've got to ask yourself whether having a progress bar is an appropriate solution to this problem. If you're simply sending an email via SMTP, you'd likely block for around 1.5 seconds. Probably not enough for the user to desire a progress bar (one of those spinny ajax-loader things would likely suffice). If you're doing something long-running, like transcoding video or compiling some sort of executable, a progress bar may be appropriate. For bonus points, you can leverage [ReactPHP](http://reactphp.org/) to perform these tasks asynchronously and report progress back to the user.
Technically all you have to do is make your root block template set to a rest or empty template. You don't need to do anything else. 
Check out [PHP Mentoring](http://phpmentoring.org), and join #phpmentoring on Freenode IRC. You don't necessarily have to find yourself a mentor - it's a great resource for interacting with experienced developers who are interested in teaching others what they know.
I really like what some are calling [hexagonal architecture](http://alistair.cockburn.us/Hexagonal+architecture), or the [Entity-Boundary-Interactor Pattern](http://www.whitewashing.de/2012/08/13/oop_business_applications_entity_boundary_interactor.html). First off, you have entities. Entities are DTOs. Pretty simple stuff. For bonus points, add in facilities that allow for easy manipulation (i.e.`__get` -&gt; `get()`, `__set` -&gt; `set()`, etc). Basically, instead of the traditional MVC routing (where the request hits the router, which directs it to a controller, which returns a response), the router routes the request to a 'boundary'. The boundary is responsible for translating a request into a useful format (this is probably what you're referring to here as mapping data to entities). Typically this involves de-serializing the request (if relevant), finding all relevant models from a datastore, etc. These are the things that need to happen before business-logic can be performed, but are not actual business logic (what pretty commonly constitutes the first 6-8 lines of any MVC controller method). The boundary then relays this 'request' object to an interactor. The interactor performs the pure business logic against the input (what typically constitutes the middle portion of an MVC controller method). Typically, in a CRUD app, this consists of validating, inserting, deleting or modifying objects, and returning the resource or collection of resources in question. This data is then passed back to the boundary which then transforms what it received from the interactor into a HTTP response (typically the last few lines of a controller method). You'll likely determine what format to send the data back at this point, and pass it off to a serializer (e.g. `JsonModelSerializer` or `XMLCollectionSerializer`). The benefits here are huge: you've cleanly separated your 'contextual code' from your 'business logic`. If you want to swap this out for, say, a plain-text API, or even an HTML API, you just need to write a new set of boundaries that transform HTTP Requests into HTML. If you want to create a command line interface, you can write a boundary that transforms stdin to stdout. If you've got the time or are interested at all, I highly recommend checking out Uncle Bob's talk [Architecture: The Lost Years](http://www.confreaks.com/videos/759-rubymidwest2011-keynote-architecture-the-lost-years). It's from a Ruby conference, but it's pretty agnostic about which language you're writing. He's just trying to get people to write good OO code.
That's all well and good... But where can I buy them? 
Haha no clue. If you follow them on Twitter ask them if they can send you some! If your not already I'd recommend you try out their services also! 
I actually thought this article was written in like 2006 for the things it covered.
I agree with everything you said. For an example for OP - I worked on a project where the app (Laravel) would do a data dump onto a rabbit queue, where it was picked up per FIFO order by a constantly running process that was written in Go. The Laravel app could "ping" the Go-based process via socket for status updates should the user visit the status page.
 $b[1]++; $b[0]++; Should be $a[0]++; $b[0]++; I think?
What's wrong with OpenCart? :P
Was expecting a rant, was pleasantly surprised.
Is react mature? 
Learning general programming principles and best practices. Every programming language has particularities, but that's just like 20% of the overall picture. You need to be a programmer first, and a PHP programmer second.
I'd suggest start with http://www.phptherightway.com
Try to understand and implement the different Design Patterns in oophp. http://www.oodesign.com/ Once you understand all of them and know how to use them, you'll be miles ahead in oophp.
Good presentation on improving your OO coding by Rafael Dohms here - http://protalk.me/your-code-sucks-lets-fix-it It makes some solid suggestions you can start using immediately.
&gt; The title's implications are otherwise though... I don't think so. A critique is just that, and it can equally come out favourable or scathing of the material its appraising. Assuming the latter is just assuming malice in the author straight away without reading its content.
Looks like you had a lot of fun making it ;) You'll probably want to look again at your [escaping function](https://github.com/Laurelin-/Athelas/blob/c988ae6108979354bca0c8bc7b23f9c9f7843392/src/Athelas/Environment.php#L182) to make it more secure, though - compare with the [Twig escape strategies](https://github.com/fabpot/Twig/blob/30d4f2b2b1cfaeca5315bae30809337c4c762e79/lib/Twig/Extension/Core.php#L938), and [Mustache.php's defaults](https://github.com/bobthecow/mustache.php/blob/1430ca884912eaba2b3830856b45685733b16789/src/Mustache/Compiler.php#L433). Edit: also you can speed up your tokenizer quite a bit, I think, e.g. [here](https://github.com/Laurelin-/Athelas/blob/c988ae6108979354bca0c8bc7b23f9c9f7843392/src/Athelas/Token/Tokenizer.php#L66) where you don't need to keep counting the array on each iteration. 
Using queued-up background processes also means you have much more control over how they run, such as how many may run concurrently, and how busy times are handled.
Skynet Technologies India based web design &amp; development Company provide PHP template design and PHP website development service at affordable price.
Syntax looks similar to that of the Razor engine in ASP.NET MVC. 
Sorry, I missed that. 
Full Stack is fine and is as good as any other term. Full Stack is a specific form of T shaped employee, which is a more common term. A T shaped employee has broad understanding of the business and industry. A T shaped employee also has a depth of understanding in one area. A T shaped employee is an expert at something, but has a keen understanding of the areas they impact and a willingness to consider the effect of their work on those areas and vice versa. This makes a Full Stack developer not a single person who does 5 jobs, but a single person who can make the combined contribution of 5 people better.
&gt; JavaScript could potentially replace PHP. *barfs*
Why would someone use __() completely differently? Its explicitly *for* translation. Good coding practices don't mean you account for every whacko idea someone may have. Its OK to have requirements like "use __() properly".
They can be set up that way, but probably shouldn't. Designing session management based on that is bad practice.
Thanks! I should definitely read some more about escaping in php :)
I mean even if both the parent and child projects were using the exact same function, their .po/.mo files would be different.
According to whom? It's a fairly standard method of handling it (especially in the microsoft world). Sure, the node could fail or become unstable, which would cause the load balancer to switch to a different node, requiring re-authentication (assuming there's no central store between the nodes), but the chances of that happening is pretty darn slim, so the decision really comes down to whether it even matters in the eventuality that it does happen. So it's not so much bad practice as it is a business decision. Either way, the database would be the wrong place to put it in. 
Looks like all you need to do is call the above the code to get a session key, $rinfo in your code. Then.... $serverId = ????; $vars = xmlrpc_encode_request('system.getDetails', ['sessionKey' =&gt; $rinfo, 'serverId' =&gt; $serverId]); After that, rinse and repeat with your curl code.
Eh I think this is a pretty bad idea. I'm wary of long lasting PHP scripts. Just doesn't feel right. What I'd do instead: POST /endpoint - generate $key - fire a queue($key) - return $key GET /endpoint/status?key=$key - return percentage or whatever queue($key) - do the task's step - save the status associated with the received key Frontend: - setInterval that checks /endpoint/status Bonus: instead of setinterval, use pubsub and engine.io 
The use of call_user_func_array() on unfiltered data sounds like a security problem waiting to be raised. 
So did I: https://github.com/jqs/tmpl
Nice tests. Oh, wait...
If we are talking about elegance I'd argue that anywhere you have a switch statement is a likely candidate for using some OO polymorphism.
You should choose whichever makes the most sense for a given situation. Arguing that one should be used over the other because it's slightly faster is pointless; you're getting into micro-optimizations which just don't matter. Code readability and maintainability needs to come before perceived performance gains.
Try apigility. Adding filters and validators are as simple as hitting a button.
My primary opinion on this is that it doesn't matter which is faster - any performance difference is going to be at the tiny micro-optimization level. You should use whichever one will provide the cleanest, easiest to read code in the particular context. You could create some arbitrary benchmarks to try to prove your point (ie. how long does it take to perform n thousand iterations of what is essentially the same operation written with either if/else or switch). Another method is to go deeper and look at what PHP is actually doing under the hood, at the opcode level. Davey Shafik demonstrated this in a presentation at PHP UK earlier this year: http://youtu.be/bHZX-CM-qQc?t=8m35s Note: I've bookmarked the section where he starts talking about opcodes - there's a second section that starts at approx 24:30. If you have the time I highly recommend watching the entire presentation as I think it's interesting stuff. (Among other things, he shows that single vs double quotes generally doesn't matter because PHP automatically optimizes the op codes)
In a lot of cases if you're using heavy amounts of either your problem isn't if vs switch, it's your code logic in general. A function or method which has large if() or switch structures is probably taking on too much responsibility in the first place. As everyone else has already pointed out, speed is irrelevant in this case.
the use of either is often a code smell. A switch typically indicates a missing abstraction which should be identified and extracted. An else often indicate unnecessary complexity which could be avoided with fail fast guard clauses followed by happy path execution or should be simplified by extraction refactoring. 
Already been benchmarked here, use his scripts if you want: http://www.phpbench.com/ Conclusion: not much difference between them.
What could potentially go wrong? I do not use call_user_func_array() on anything that's not callable
The world probably doesn't need this agreed. However I'll probably use it in some of my personal projects :D
It's a good thing we're doing groundbreaking work here, like reinventing the template engine for the 9,000,000th time.
If eval() is callable, it's enough to make it a vulnerability, here's a payload example : @exit(@eval(@base64_decode('ZWNobyAnSGVsbG8gV29ybGQnOw=='))); In this example, the base 64 payload is 'echo "Hello World";' Example was taken from this article : http://average-coder.blogspot.fr/2014/01/exploiting-code-execution-in-jomsocial.html 
I guess, I can conclude that the switch statement is better in speed, but the difference is not really that big, so it's up to the programmer which one to use. I don't want my readers to be hanging in that thought tho. Thank you for the comments. I'm thinking about the posible situations now. :)
Because there are so many insightful things to say about something that has been done 9,000,000 times. /r/php gets a new template engine every other week because the creativity and intelligence here is near non-existent. 95% of the people here aren't even anything close to good programmers.
You can solve this by making sure that the DTO in your SPO interacts directly with your transformer making sure that the ORM properly abstracts the autobot implementations done by your VIPs. WTH is this!? It's like every post in here has been dilbertized just to solve the problem of getting data, validating it and putting it into your database. Are we doing PHP-EE now? This is web development, people, not rocket science!
I wouldn't. Build it to learn, don't build it to use in a production environment.
[Razr](https://github.com/pagekit/razr) is another engine inspired by ASP.NET Razor. It could be interesting to make a comparison and give each other some feedback.
Comments like this don't help anybody. Chances are your first program and half of your programs aren't original. I remember in college writing binary search trees in C++, hardly ground breaking work. But I wasn't trying to revolutionize the world, I was trying to learn. OP here is trying out any &gt; php4 pretty much for the first time and this is the only thing you could think to say.
~~If accepted, this will be a ***huge*** improvement to PHP and it will finally remove many wtfs like the following~~ EDIT: Removed the wtf in question as Nikita says that is fixed by the uniform variable syntax rfc and the only userland fixes here are minor stuff. Original post: In 2014 there really is no reason not to have an AST based parse/compile process. Any performance gain by using the current single-pass system becomes irrelevant if you have opcache enabled (and you should). For the record, here is Nikita's previous [RFC](https://wiki.php.net/rfc/ast_based_parsing_compilation_process) on the topic and the resulting [discussion](http://markmail.org/message/trt5oz5uioxe3fdv). 
Yep, great points. And I should have probably linked [today's announcement/discussion](http://markmail.org/message/br4ixewsnqitrx3n).
Abandon or fork were the only options? What about setter injection?
Assuming the vote for this RFC passes (the devs would be stupid if they didn't vote this through), I hope it won't merely be applied internally, but also exposed via an API as well. Doing so would allow us to do some interesting things, such as using lambdas for SQL queries (a la LINQ). 
I don't understand why anyone would define a constructor for an interface. What is a constructor if not an implementation detail?
Symfony has also taken the number of private methods and properties to the extreme compared with the rest of the PHP world. It's like the 'protected' keyword just doesn't exist anymore. I'm sure this wasn't the intention, but it can foster a very uptight attitude toward extension vs the We're All Adults Here approach of Python. 
That's a good point. I'm a big fan of making things protected by default to allow people to extend and override if necessary.
Honestly, this is a **terrible** idea. The issue the author is having isn't with interfaces, but rather that ZF1 is hard-coded to a specific constructor signature. The solution to it is not to extend interfaces to include the signature for constructors, but to apply a dependency resolution strategy such as that offered by dependency injection containers. Interfaces define a protocol for objects to interact with. Not only are constructors not for interaction but initialisation of the specific implementation, adding the constructor signature to the interface would severely limit what an implementation can do. In fact, it limits it so much that you might just as well code against the implementation directly at that point. 
You want to use `private` if you're not committed to making it part of the public API. It lets consumers know that it's an implementation detail and should not be relied upon for BC, because it can change at any time. `protected`, on the other hand, makes a different contract with consumers: it says that the property or method is only open to extension, not external modification, but it is still ostensibly part of the public API. Once something is part of the public API, it becomes a whole different ball game support-wise and it's very, very hard to take it back. So `private` by default tends to be a good practice until your'e absolutely sure the feature won't change in ways that would break consumers. You can always use reflection to change the visibility if you absolutely want to rely on something that can change from version to version, but perhaps a better way forward would be to inquire upstream about getting whatever it is you need added to the public API.
&gt; I don't know of a container that handle automatic setter injection, certainly the container I was using only handles automatic injection for constructor dependencies. You could use a factory: class FooFactory { private $myDependency; private $bar; public function __construct(Bar $bar, MyDependency $my_dependency) { $this-&gt;myDependency = $my_dependency; $this-&gt;bar = $bar; } public function build() { $foo = new MyFoo($this-&gt;bar); $foo-&gt;addMyDependency($this-&gt;myDepedency); return $foo; } }
Thank you for the feedback! * I actually did the curly braces on purpose, since it's syntax comes from the ASP.NET Razor library (which also does it that way). For some reason I like it more than using the @if/@endif syntax * It's possible to render multiple kind of sections in the parent template, by calling show("nameofthesection"), where the section can be defined in the child template * Escaping is on by default, but I should probably improve that part some more * I come from a .NET background, so using the I for interface is just in my system I guess :) I should probably update the documentation some more to make these things clear
You can do with the Symfony DIC :) http://symfony.com/doc/current/components/dependency_injection/types.html#setter-injection
Big wheel keep on turning...
&gt; but also exposed via an API as well The RFC intentionally avoids this but I agree, it would be great to use such an API for static code analysis, IDE support etc.
Well you can start by proper whitespace and some comments: // each objects for ($a = 0; $a &lt; 26; $a++) { // each other object for ($b = 0; $b &lt; 26; $b++) { // height for ($c = 0; $c &lt; 26; $c++) { // width for ($d = 0; $d &lt; 26; $d++) { Otherwise, you can split them in functions
This was the common explanation in the move from Symfony 1 to 2 where everything got shut down, but it's simply mistaken logic. Equating public methods published in a public API with methods that can be extended by children is just stretching the definition of public API way too far. There's no "ostensibly" about it. Even worse are private properties that can't even be reached from any *new* methods in the children, even though they may be critical to the basic functions of the object. So it becomes difficult to even add new behaviour. Before then, was the PHP world full of devs complaining that their overridden protected methods were constantly being broken? Nope. This was a solution in search of a problem. No, it's not correct to assume that private is best by default, and it's a shame if young devs are taking the attitude that 99% of their code shouldn't ever be extended by anyone but themselves. It removes one of the principle functions of inheritance. It's crazy if your only option is to re-implement, wrap or delegate, or else haggle with the upstream - this is how abstraction inversion becomes a real problem. But I guess the Symfony world will wake up to this anti-pattern eventually, too, as it has slowly with service locators. 
"*A few*" ? You are modest :-)
&gt;Equating public methods published in a public API with methods that can be extended by children is just stretching the definition of public API way too far. There's no "ostensibly" about it. Member visibility is how you specify the public API. That's what it's there for. If a property or method is an internal implementation detail, it should be declared `private`. Marking a member `public` or `protected` and then either a) not documenting it, hoping nobody notices it or b) marking it explicitly as internal in the documentation contradicting its visibility is just silly. It's equivalent to not using interfaces and hoping people rely on the API docs instead. &gt;It's crazy if your only option is to re-implement, wrap or delegate, or else haggle with the upstream - this is how abstraction inversion becomes a real problem. You've already listed two in-code options to avoid re-implementing: wrapping and delegation. Like I said, there's also reflection which will allow you to modify member visibility. Yet another option is to a hard look at what you're trying to do and figure out if you absolutely need to rely on implementation details that are clearly sectioned off instead of using the library's public API. But I wouldn't call submitting changes upstream "haggling" like it's some hardship: one of the primary *benefits* of consuming an open-source library is the ability to be the change you wish to see in the world and fix something you think is broken. APIs that are mis-categorized as private but are stable enough to be public are something you have the ability to fix and submit back upstream. If that doesn't work for you, you also have the option to fork and maintain your own version. &gt; I guess the Symfony world will wake up to this anti-pattern eventually Encapsulation is at the heart of object-oriented programming. If you think it's going to go away, that it's an anti-pattern, or that only Symfony and "young devs" practice it, you'll be disappointed for a very long time.
Your reasoning is based entirely on mistakenly equating public and protected visibility as far as the API is concerned. This is one of the unfortunate developments since Symfony 2's introduction. We have two different keywords for a reason. I've already explained how wrapping and delegation can lead to the anti-pattern of abstraction inversion (the link is above). These strategies are of course useless if the class doesn't allow access to behaviours and properties that are needed for any meaningful extension. This is how the rot of re-implementation sets in. Forking? Please, haven't we had enough of NIH syndrome already? The promise was also made with the introduction of Symfony 2 that private methods could be made protected again if needed. But the reality is that "until you're absolutely sure the feature won't change in ways that would break consumers" means only one thing: *never*. I don't think you seem to really grasp the subtleties of what encapsulation actually means, nor the open/closed principle despite citing both. Neither are designed to cripple the inheritance features of a language. They don't mean that we should only be sharing completely opaque black boxes with each other, and if you don't like them as they are then just *fork off*. Edit: in PHP land, the keyword *private* means one thing before all else: this property or method cannot be referenced by any other object or child, and even if re-implemented in a child, the parent will only use its own versions. It creates a completely new scope for the class. That's a bigger statement with more implications than "this is just an implementation detail, and may change at some point". When everything apart from public members are considered "just implementation details" in this mistaken way, the effect is simply the same as marking the class *final* and shutting down the inheritance system completely. This isn't a decision that developers should be making lightly, routinely or by default. 
&gt; Isn't that what this RFC does? I don't know really...I mean, I don't know if this will fix the issue that I am talking about. To me it seems to be an issue with the library functions..But fixing library functions seems to be boring job no one wants to do... 
I learned about ASTs in my Intro to Compiler's class (of course), and I guess I assumed everything was made with them. I think it's great then PHP is moving towards one.
Look, if instead of discussing the issue like a normal person you want to have a wholly-unwarranted condescending douchebag contest, I can do that too. &gt; I don't think you seem to really grasp the subtleties of what encapsulation actually means, nor the open/closed principle despite citing both. To be honest, I really think the same about you: you demonstrate a severe mis-understanding of OOP, and it's a shame. I'm guessing you have no formal training and are used to cowboy coding makeshift solutions to problems: I otherwise can't really fathom why you're so dead-set on tightly coupling your code to implementation details instead of availing yourself of the multitude of options to avoid it. To wit, this: &gt; I've already explained how wrapping and delegation can lead to the anti-pattern of abstraction inversion (the link is above). indicates either a) you base your entire programming knowledge off of poorly-written Wikipedia articles or b) the education system from which you reside is woefully inadequate for getting programmers the knowledge they need to do their jobs well. If you do, in fact, have an educational background, I'd be looking to see if I could get my money back. And for the record, I never mentioned the open/closed principle. I'm guessing you really didn't read much of what I wrote all that closely, either. &gt; Your reasoning is based entirely on mistakenly equating public and protected visibility as far as the API is concerned. I never equated the two. You keep attempting to equate the two into some bizarre strawman, but they are separate concepts and have separate uses. I know you didn't really read anything I wrote and are more interested in some weird rant about young people and their Symfony 2 and/or their rock and roll, but I specifically delineated the two in my first comment. On the other hand, you seem to believe that the `private` visibility shouldn't exist, and that Symfony 2 is the primary cause for its existence. I'm sorry to say that it predates Symfony in PHP by several years, and predates PHP in other languages by decades. Why do you think most OOP languages support it? If you think it's a gross anti-pattern, why did so many people choose to include it? They can't all be "young devs" corrupted by Symfony 2. Though that'd be one hell of a time travel story. &gt; The promise was also made with the introduction of Symfony 2 that private methods could be made protected again if needed. But the reality is that "until you're absolutely sure the feature won't change in ways that would break consumers" means only one thing: never. Hey, if that's what you truly think, then it's hopeless: fork Symfony 2 and make everything public. Woo! Now that's an API! See how that works out for you. The rest of us in the real world wish you luck. Ohhh right, making changes to another project even though it's open-source is either NIH or pointless haggling! Damn, since you ruled out every possible useful solution to deal with your contrived problem, I guess bitching about Symfony 2 and those damn "young devs" in random Reddit threads is the only thing left to do. You might want to consider writing letters to the editor of your local Pennysaver, too. Edit to respond to your edit: &gt; When everything apart from public members are considered "just implementation details" in this mistaken way, the effect is simply the same as marking the class final and shutting down the inheritance system completely. Wow, that's absolutely breathtaking. I can't even begin to imagine how you can say you know what encapsulation is and write that with the typing equivalent of a straight face.
Well, if all you have left is ad hominem attacks, then the discussion is obviously over. 
Needing to use sticky sessions is typically a sign of some other bad design choice (like server specific sessions) and has a list of cons longer than pros. Uneven load is the primary reason I avoid them. This Stack exchange post covers it pretty well: http://stackoverflow.com/a/1570655/153767 It may be "business decision" but that doesn't make it a good decision.
I am using https://github.com/horde/horde currently. It is a bit tricky to get it working, but does its job.
Just be careful not to oversplit it either. If you are operating on multi-dimensional matrices, it may be best to do it all in one block.
I would say a better strategy is to [self encapsulate field](http://refactoring.com/catalog/selfEncapsulateField.html) with a protected method and keep the property itself private.
Are you just talking about the login page getting slammed with phony login attempts?
Do you mean something like this? &lt;?php $hello = "hey line break dude"; var_dump($hello); ?&gt; Seems to work just fine for me. 
This is a jQuery question, not a PHP question. /r/jquery /r/javascript
I am on my way home but will send examples when I get back. 
Can you share the code you are using? Just the jQuery will be fine.
 var params = {latitude: venue.latitude, longitude: venue.longitude, radius: 10}; $.ajax({ url: 'http://localhost/nearby', type: 'POST', data: params, dataType: 'json', success: function( data, textStatus, jqXHR ){ // we could submit it if(data.length === 0) { create_station_from_venue(venue); } else { venue.station = data[0]; alert('Found: ' + JSON.stringify(data)); } }, error: function( jqXHR, textStatus, errorThrown ){ alert('Error: ' + textStatus +' '+ JSON.stringify(errorThrown)); } }); 
Also happens using AFNetworking -(void)stationsNearLocation:(CLLocationCoordinate2D)location radius:(CLLocationDistance)distance completionHandler:(ServerCallback)completionHandler { NSDictionary* params = @{@"latitude": @(location.latitude), @"longitude": @(location.longitude), @"radius": @(distance)}; [self POST:@"nearby" parameters:params success:^(NSURLSessionDataTask *task, id responseObject) { completionHandler(responseObject,task,nil); } failure:^(NSURLSessionDataTask *task, NSError *error) { completionHandler(nil,task,error); }]; } 
What version of jQuery are you using? I'm testing with 1.11.0 and your exact code is showing a POST request method. Also, how are you determining that the request method is a GET?
See code below.
Array functions take advantage of the fact that they're working with actual array data structures to do things efficiently. I can't think of any good reason to support the array access interface. 
What browser are you using to test the JSON? Are you able to capture the AJAX request headers and confirm that your browser is using a POST method? Or perhaps check the web server logs and confirm whether it's doing a GET or a POST? I wonder if there's just some weirdness with your PHP config or build that's translating or confusing the request method.
 &lt;?php $json = array('SERVER' =&gt; $_SERVER, 'POST' =&gt; $_POST, 'GET' =&gt; $_GET, 'FILES' =&gt; $_FILES, 'COOKIE' =&gt; $_COOKIE, 'REQUEST' =&gt; $_REQUEST); header('Cache-Control: no-cache, must-revalidate'); header("Content-type: application/json"); echo json_encode($json); exit; with var params = {latitude: venue.latitude, longitude: venue.longitude, radius: 10}; $.ajax({ url: 'http://localhost/echo', type: 'POST', data: params, dataType: 'json', success: function( data, textStatus, jqXHR ){ console.log(JSON.stringify(data)); }, error: function( jqXHR, textStatus, errorThrown ){ alert('Error: ' + textStatus +' '+ JSON.stringify(errorThrown)); } }); returns COOKIE = { "_ga" = "GA1.2.816915019.1402528707"; }; FILES = ( ); GET = ( ); POST = ( ); REQUEST = ( ); SERVER = { "DOCUMENT_ROOT" = "/Library/WebServer/Documents/"; "GATEWAY_INTERFACE" = "CGI/1.1"; "HTTP_ACCEPT" = "*/*"; "HTTP_ACCEPT_ENCODING" = "gzip, deflate"; "HTTP_ACCEPT_LANGUAGE" = "en;q=1, fr;q=0.9, es;q=0.8, it;q=0.7, ja;q=0.6, de;q=0.5"; "HTTP_CONNECTION" = "keep-alive"; "HTTP_COOKIE" = "ubid=eEUhcGWzXEILIRRcxZfCR20Y; _ga=GA1.2.816915019.1402528707"; "HTTP_HOST" = "localhost"; "HTTP_USER_AGENT" = “AF/1.0 (Mac OS X Version 10.9.3 (Build 13D65))"; PATH = "/usr/bin:/bin:/usr/sbin:/sbin"; "PHP_SELF" = "/echo/index.php"; "QUERY_STRING" = ""; "REMOTE_ADDR" = "127.0.0.1"; "REMOTE_PORT" = 64406; "REQUEST_METHOD" = GET; "REQUEST_TIME" = 1406930986; "REQUEST_TIME_FLOAT" = "1406930986.505"; "REQUEST_URI" = "/echo/"; "SCRIPT_FILENAME" = "/Library/WebServer/Documents/echo/index.php"; "SCRIPT_NAME" = "/echo/index.php"; "SERVER_ADDR" = "127.0.0.1"; "SERVER_ADMIN" = "you@example.com"; "SERVER_NAME" = "localhost"; "SERVER_PORT" = 80; "SERVER_PROTOCOL" = "HTTP/1.1"; "SERVER_SIGNATURE" = ""; "SERVER_SOFTWARE" = "Apache/2.2.26 (Unix) DAV/2 PHP/5.5.10 Phusion_Passenger/4.0.14 mod_ssl/2.2.26 OpenSSL/0.9.8y"; }; } 
So are you spoofing the User-Agent, or are you still running the request through AFNetworking? You said it works fine when requesting through the browser? Is it possible this is an AFNetworking bug?
*and* jquery apparently {"SERVER":{"HTTP_HOST":"localhost","HTTP_ACCEPT":"application/json, text/javascript, */*; q=0.01","HTTP_COOKIE":"ubid=eEUhcGWzXEILIRRcxZfCR20Y; _ga=GA1.2.816915019.1402528707","HTTP_CONNECTION":"keep-alive","HTTP_ORIGIN":"file://","HTTP_USER_AGENT":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_3) AppleWebKit/537.76.4 (KHTML, like Gecko) Version/7.0.4 Safari/537.76.4","HTTP_ACCEPT_LANGUAGE":"en-us","HTTP_DNT":"1","HTTP_ACCEPT_ENCODING":"gzip, deflate","PATH":"/usr/bin:/bin:/usr/sbin:/sbin","SERVER_SIGNATURE":"","SERVER_SOFTWARE":"Apache/2.2.26 (Unix) DAV/2 PHP/5.5.10 Phusion_Passenger/4.0.14 mod_ssl/2.2.26 OpenSSL/0.9.8y","SERVER_NAME":"localhost","SERVER_ADDR":"127.0.0.1","SERVER_PORT":"80","REMOTE_ADDR":"127.0.0.1","DOCUMENT_ROOT":"/Library/WebServer/Documents/","SERVER_ADMIN":"you@example.com","SCRIPT_FILENAME":"/Library/WebServer/Documents/echo/index.php","REMOTE_PORT":"49865","GATEWAY_INTERFACE":"CGI/1.1","SERVER_PROTOCOL":"HTTP/1.1","REQUEST_METHOD":"GET","QUERY_STRING":"","REQUEST_URI":"/echo/","SCRIPT_NAME":"/echo/index.php","PHP_SELF":"/echo/index.php","REQUEST_TIME_FLOAT":1406932590.958,"REQUEST_TIME":1406932590},"POST":[],"GET":[],"FILES":[],"COOKIE":{"ubid":"eEUhcGWzXEILIRRcxZfCR20Y","_ga":"GA1.2.816915019.1402528707"},"REQUEST":[]} From safari.
Safari I think it is something with my PHP config but I don’t know what it could be - that’s why I’m here. I was hoping someone would say “oh there’s a setting in your php.ini” or something. FWIW, I used brew install php55 or something like that to install it 
If there isn't much logic in the innermost for loop then what you have is going to be close to the most readable you can get. Refactoring the loops into functions could help but IMO it could actually make it less readable. Instead of for loops you could go crazy with range and array map. $range = function(){return range(0, 26);} $map = function($closure) use ($range) { return array_map($closure, $range);} $map($map($map($map(function ( { // something }))))); Edit: wrote this on my phone, the formatting is broken and I think it might not work. But maybe you get the idea.
Nope. It's a PEBKAC "HTTP_ORIGIN":"file://" doing a XHR from file:// to localhost is blocked reason: not same origin (CSRF)
If you want a VPS, http://dediserve.com/ is the way to go. Every other VPS provider looks like shit after trying these. Source? I'm the owner of big b2b application, and it went like shit on Digitalocean, Meebox (Danish) and Afterburst (Yeah I know, but I liked them from other projects but underestimated how bad cheap hosting providers can be). Now we are on dediserve. Every server there is pure SSD as standard, free 10GB private networking between your instances and all resources are guaranteed. Many VPS providers will terminate you for using 100% CPU all the time because they are in fact overselling. Dediserve won't as you own the cores you buy.
Just out of curiosity... what other refactoring did you already have planned for moving to 5.5? Are you moving to 5.5 for any reason? You do have a testing server right?
I suspect you were downvoted because /r/php is not a support subreddit. You should be posting in /r/phphelp.
One example: I was updating some legacy code that relied on a monolithic array. I wanted to sub out that array for an object without breaking everything, so I implemented ArrayAccess and substituted it hoping everything would continue to work but allowing me to add in new functionality gradually. I got a decent ways into it, but it turns out we had a whole bunch of `is_array` calls that depended on it being an actual array. Was too much work to update everything all at once without everything collapsing.
And a shit tonne of unused variables
Erm, I have to disagree there. If my project is under version control, any commented out code gets removed as and when I encounter it. That shit serves no purpose.
I'm not versed enough in compilation or internals of PHP to understand this completely, but it sounds like the result of this would be a marginal speed increase for a not-so-marginal memory cost. Can anyone explain why I'm wrong (if I am)?
I'm no expert either, but as I understand it, you're correct insofar as the runtime performance is concerned today. But, this proposal alone isn't about performance, it's about moving from a [single-pass ](http://en.wikipedia.org/wiki/One-pass_compiler) to a [multi-pass](http://en.wikipedia.org/wiki/Multi-pass_compiler) compilation process, which opens the doors for things that are impossible under the current compiler. It also allows for more advanced features and optimizations, since the current compiler has limited information with which to work with, whereas the AST allows the compiler to consider the entire program all at once.
No, its not. Access-Control-Allow-Origin: * is sent as a header. The call actually works. I edited the original post with the solution.
No, every one is busy [putting lipstick](https://wiki.php.net/rfc/abstract_syntax_tree) on the pig... And [this](http://www.reddit.com/r/PHP/comments/2cc9xp/rfc_abstract_syntax_tree/cje6l32) is what happens if you mention it. 
I'm not 100% sure on this, but I think *both* RFCs are required to fix all syntax limitations. For example, this RFC has a chapter saying parantheses will no longer influence behaviour.
I see. I'm all for fixing those as well and there is plenty of time till PHP.next so it's certainly doable.
Sometimes you can generate opcodes directly while parsing token stream, avoiding AST.
There seems to be a bit of confusion about this RFC, so I'd like to clarify what it does and does not do: This RFC is not about any particular PHP syntax. It does not make `(func())[0]` work - that was already implemented by the Uniform Variable Syntax RFC. It *does* fix a few minor points with regard to variables vs. expressions, but those aren't particularly important. What the RFC is really about is a cleanup, or rather reimplementation, of our compiler infrastructure. This will make implementation of new language features and maintainance of the existing ones simpler. It also opens the doors for some things that were previously completely unthinkable (e.g. LINQ). So, really, the whole thing has no direct effect on userland devs. It's an internal rewrite.
 I don't have an argument regarding the 'plenty of time' part..I mean, its 2000 fucking 14...ok anyway, that is not the point.. The point is, there needs to be a strong base or foundation so that the high level constructs that are available can be used fully..We make foundation before decorating the roof, regardless of how much time we got...right? So, if we don't prioritize stuff in a sensible manner, we are going to end up with some flashy high level stuff, that you can boast about, like 'hey, php has now got this, php has now got that'...but which would end up being leaky abstractions, which falls apart when you try to put it to real use. Like the ArrayAccess and Array type hints that I mentioned earlier... 
I really like that it has the Razor syntax. Razor is awesome. ~~Now you only need to incorporate sections and I'll be happy.~~ :) 
No, the point of the ArrayAccess interface is in it's name. It allows objects to use the array access syntactic sugar. That is all. An object that implements it is in no way contracted to be at all like an actual array. I could create a class that uses ArrayAccess to make HTTP calls and that would be a perfectly valid (although strange) use of the feature: $http = new HttpRunner(); // Make a GET request echo $http['http://www.reddit.com'] // Make a POST $http['http://www.crazyontap.com'] = array( 'name' =&gt; 'wvenable', 'body' =&gt; 'This is a test'); // Make a DELETE request unset($http['http://www.example.com/files/456.pdf']); Exactly how are array functions supposed to work that that? 
sorry for your loss!
&gt; We make foundation before decorating the roof, regardless of how much time we got...right? That's just my point. The parser is low level, it is the very first step of the execution cycle. ArrayAccess is a public interface so it is a much higher level concern.
Well, not from the point of a user. It makes no difference to me if the thing is using AST or what ever...Just give me features that are consistent, even if that means less new-features/release...
Now I see your point. I disagree, but I get it.
Might have been able to do that, but I think there were a few other problems too. But you're right, if it did return true, the outcome probably would have been a lot worse.
Let med guess. You're part of php internals?
Thanks for making it clear why it would not work...
In this example you can remove the need for comments like "// width" with better named variables ($width). Comments are sometimes a sign your code could be cleaner.
See [this](http://www.reddit.com/r/PHP/comments/2cc9xp/rfc_abstract_syntax_tree/cjepu64) answer that explains why it should not work.
I don't know man... I can make an IDictionary behave wonky in C# too, but there's still a ton of functions that will "work" with it. That's your own damn fault for making an effed up class.
No I'm not, never have been, never will be. I'm a user, just like you. Also the downvote button is not a disagree button, it's a "[doesn't contribute to discussion](http://www.reddit.com/wiki/reddiquette#wiki_in_regard_to_voting)" button.
&gt; parantheses will no longer influence behaviour. Can you elaborate? What about this? (1 + 2) * 3 == 9 1 + (2 * 3) == 7
Laravel is a "Go". Starting next week.
Nikic is a God.
It's not about grouping or mathematical operations. It means that: ($foo)[$bar] = $baz and $foo[$bar] = $baz will finally mean the same thing.
As well as this you can handle setter injection using [PHP-DI](http://php-di.org/doc/definition.html) &amp; pimple - I assume that most other DI libraries should be able to handle this. That being said, as OP said constructor definitions in interfaces is a really nasty code-smell.
CodeIgniter is old. It is a dying framework.
CodeIgniter is not being speedily maintained. Do not expect it to keep up with current spec. It's very likely dying out. That being said, in its day it was a very handy framework. It's a bit on the bloated side though.
This would be "normal php". OP doesn't mean a seperate distribution, he means adding this stuff without removing the current system.
Sadly this would never happen. None of the internals people want to do it, and even if someone did came up with an implementation, they would vote it down and it would never get accepted.
&gt; Opt-in, alongside the current standard. ...is what I'm suggesting. Defining e.g. `std\string\find` would not prevent a library from using `strpos`. If you break compatibility with existing PHP libraries, there is no reason to use PHP at all.
it's more a function of the skill level of the developer. I've seen good CI and bad CI. Personally, I found the conventions a little basic, but workable. The 'helper' stuff is, imo, a bit wonky, as it's not object-based - it's just loading functions in to the global namespace.
It's a lot of work and another dependency. The majority of people that value this sort of thing are using a framework already that abstracts away much of this (feels like at least 30% of ZF is just wrappers around core functions). The 'majority' is sort of a guesstimate based on people I know. :) The people who don't care about it tend to be cut/paste types, and they'll never be cutting and pasting code that references your code idea. Unless it's baked in to a PHP distribution, I think (sadly) it's a non-issue. Would be nice to have 'CPL' (common php lib) baked in, much like SPL stuff is, which is just a standardized wrapper around the other stuff, but with the param order standardized, underscore/camel standardized, etc. 
I believe the Uniform Variable Syntax RFC resolves that specific example. Having looked through the thread a second time, there's a more information response from /u/nikic explaining this.
I remember it had good, easy to use docs. 
It's a small, simple framework that gets out of your way as quickly as it can. Easy to pick up, has a comprehensive documentation and should you get stuck there are a lot of people to help (or you can just read the code, which is definitely understandable if you know your way around PHP). It uses a query builder for database interactions (although it calls it active record) and has limited support for migrations as well. No templating engine comes out of the box, but people managed to integrate one easily. The downside is that it's pre-PHP 5.3 meaning no namespace support, definitely no Composer support and has a lot of not so great design decisions. For instance it's rather painful to break out of the classic MVC pattern: it has the concept of services (called libraries) but no dependency injection, the autoloading is clumsy and manual loading is tedious. For these reasons, very few Codeigniter projects look the same, people usually invent some sort of internal naming conventions, autoloaders etc. to compensate. This is actually the hardest part of Codeigniter: figuring out what your predecessors bolted on the framework. I've seen people write a whole new framework on top of CI.
For the built-in helpers, yes. For custom helpers you can write whatever you want, it just works like an include.
this could also be implemented as an extension.
The documentation is incredibly clear and concise and although it's a dying framework, it's still quite easy to learn and to manipulate in any way you'd like. 
Only thing I would say is that using the same syntax for control structures and variables could be problematic. I'm pretty sure that `$if`, `$foreach` etc are valid variable names. Not that you should ever use those names, but your other control structures like @body or @show could easily be variable names. It makes the system less flexible in general since you can't introduce new control syntax (say, @forif) without it potentially conflicting with existing variables.
Absolutely. Though I think even pure php is worth considering.
that's even more confusing, if built-in helpers are functions, but custom helpers 'can' be something else. My limited experience is CI is/was fine for smaller/mid sized projects, but there wasn't enough guidance in the framework itself towards better practices for larger projects. Just a feeling I got.
A location redirect somewhere? Edit: nvm you found it.
&gt; That said, if you've inherited a CI app there is no reason to scrap the entire thing and rewrite in Laravel right away. Or you know, any of the other great frameworks that are out there that may be more fit for purpose. :)
[This crossed my mind](http://xkcd.com/927/).
unfortunately moving framework is usually not possible when working on live legacy applications.
Hi, replaying with things like - "LMGTFY" - "use the search function" - "never mind i figured it out but I'm not telling you how" Are not helpful to a discussion, if you don mind I will ask you not to do that. 
If such a library were implemented in userland and not in the core, it would be *massively* slower and people wouldn't use it. Clean code is nice, but fast code is nicer.
That is the absolute least helpful reply to his question that I could imagine.
It would be difficult, but not impossible. It depends on how stable the live legacy app is. If there's problems abound, get it all straightened out, and suggest an overhaul (IMO). I did this with my company and it's going extremely well. Our legacy app works beautifully, and my team is more fluent in that framework (asp.net). Now we're porting everything over to Zend, which, for us, allows for quicker development and familiar territory. Because of this, we can expand the app beyond what the company originally had in mind.
You are old and dying.
Good point, I've added the current version as 1.0
I am (at this point) only thinking aloud. But if I were to implement this, I would start with a pure php implementation and measure performance before considering C. Thanks though, I'll definitely keep it in mind.
It's been discussed, search.. But IMHO the first thing you need to know about is [Composer](https://getcomposer.org/) - a package/dependency manager, handles autoloading. You should probably read through [PHP The Right Way](http://www.phptherightway.com/), note all the deprecated stuff mentioned in the standard PHP docs, and so as not to reinvent the wheel, skim through the [toolbox](http://www.php-toolbox.com/) and explore on [packagist](https://packagist.org/explore/popular). (EDITndum:) And, coming from that time, if you ever feel the urge to use the `.` oprerator (even in conjuction with `mysqli_real_escape`, well, *especially*) or `echo` for non-debugging purposes, **you're probably doing it wrong**. See prepared statements, html templating, etc. Then, start coding :). EDIT2: Oh, and you're probably going to need to learn modern JavaScript, etc. as well. Sorry.
http://www.phptherightway.com
Learn composer. It's changed the game with PHP.
Thank you and good luck.
Slightly tangential, but I think that migrating the stdlib to PHP might be useful. It opens up functionality so that non-internals developers can look at implementations (and perhaps make fixes). Python does the same thing; perhaps with phpng performance improvements it might be on a similar level to native C? HHVM [seems to do at least a bit of this](https://github.com/facebook/hhvm/blob/master/hphp/system/php).
I was in a similar situation. Stopped programming for about 5 years and then came back. It was pretty easy to get going again mainly because PHP/Javascript have advanced so much a lot of things that used to be an ordeal are now really simple. I highly suggest you ignore all the frameworks out there except for Laravel. Learn Laravel and you'll have a great time. I'm not saying others are bad. Its just that Laravel is the easiest to pick up, makes the most use of newer PHP features, and is frankly fun to program in. It's the best thing to give you a good idea of where PHP is now. (and it utilizes composer, which others have mentioned is a cool new thing in PHP)
Wait. What is wrong with the . operator? Is there some other way kids are concatenating these days that I don't know about?
There's nothing wrong with it, but - If you use it to output html, use templates instead - If you use it to build SQL queries, use prepared statements (or an ORM) instead
It was a very good framework, it has the BEST documentation I've ever seen, but it's now a dying framework. 
implode()
It's extremely important for him (and you) to understand one thing: if you're using `echo`, `var_dump` or `print_r` for debugging purposes, *you're not using the best tool available*: xdebug.
The entire field of programming, especially webdev, has changed drastically in the past 10 years. While you might be comfortable with PHP (since it hasn't significantly changed in that time), you'll be missing out if you just disregard the decade of progress everyone else has made. Shop around before you put all your eggs back in the same basket.
Unit tests is also a way of debugging.
You're trying to make it something it's not. ArrayAccess serves only one purpose; allowing array syntactic sugar. It's not even a complete enough interface to support all array operationgs in PHP. It isn't meant to indicate that an class is a type of array. This is in contrast to say C#, where arrays actually implement the IList interface themselves. One should absolutely not expect that objects that implement Iterator be accepted by array functions. For starters, any function that modifies an array won't work. Any function that access arrays other than iterating them won't work. 
But now you can't put a variable @body followed by something in brackets...
The [Github repo](https://github.com/EllisLab/CodeIgniter/commits/develop) is still active, there were a bunch of commits in the last couple days.
I love modern javascript. Edit: Not sarcasm
Oh, I can help you with that. I started again in January since a similar stop of 10 years. Here's some of the stuff I had to learn rather quickly. Before people reply, please note that this was my experience and it may not align with your view on the 'best' methods. **Screw tables, use divs.** Personally I'm against giving up on &lt;anything here&gt;, just as much as I hate people who say goto commands are evil. Unless you have a valid reason, nothing is off the table (ghehe). Everything has its uses, including tables (even for layout). However, 9 out of 10 devs won't agree with you, even though when you ask why they'll just laugh at you like you're an outdated crazy person, followed by not actually giving a valid reason. Just go with the flow on this one, it's a lost battle. **CSS** has improved tremendously since 10 years ago. You no longer have to use browser specific hacks, except for certain IE versions, but it is expected to support more versions of each browser because we've got smartphones, tablets, desktops, a couple of operating systems, different browsers, etc. You can no longer ask people to just get the latest version, because not every operating system supports the latest version. A lot of things are finally standardized though, which is nice, but be wary of using CSS3 as not all browsers support everything. Here's a [list](http://www.w3schools.com/cssref/css3_browsersupport.asp). **Responsive design** is the standard now. At my company we no longer make different pages for different platforms (mobile/desktop). We now make a single page that can be dynamically scaled from 320 width to 1920 and still look good on all browsers in between every resolution. Learn about **CSS media queries.** **Bootstrap** should be mentioned, but I only know about it in post production and there's a whole thing you do in pre-production that I know little about, so it's probably best to learn about that yourself [here](http://getbootstrap.com/). **jQuery.** for javascript. Enough said. Get it. Learn it. Use it. It's great. Unless I forget about something, that's about it for front-end layout. **Google!** is everywhere and also in your website. **Open Graph Protocol**, learn about it [here](http://ogp.me/). **Search Engine Optimization** is a business on its own. Some things have changed drastically. The url should reflect the content of the page. Google likes this. The first H1 is crucial to explaining the content of the page. Google likes this. H2s are also important, because google likes this. Forget about meta keywords, google pretty much ignores this due to years of abuse. However the meta description is crucial and should be about 150-160 characters, because that's what you see in the google search. Use google analytics. Resistance is futile. **On backend** side almost nothing has changed. If you stopped 10 years ago, unless you were behind at the time, you should be familiar with Object-oriented programming. Learn about the MVC (Model View Controller) design pattern. **MD5** is broken, don't use it for important things. SHA256 is the thing. **SESSIONS** have a few weaknesses. Learn about them [here](http://en.wikipedia.org/wiki/Session_hijacking). Especially the part about SSL is important if you're doing content sensitive stuff. **MYSQL**. Use prepared statements to prevent SQL-injections, but this should also be a familiar thing. I'm probably forgetting a ton of stuff, but this is just the things from the top of my head. 
Hey, just a suggestion you could try to provide more information in the `readme.md` file so people know how to use and and it might be a a good idea to comply with the `PSR-0/1/2/3/4` standards. Not to mention the use of `mysql_*` functions which is deprecated as of PHP 5.5
There are [already](https://github.com/rossriley/scalar_objects/) [such](https://github.com/rossriley/php-scalar-objects) [projects](https://github.com/gossi/oophp).
Don't use raw password functions ever. Use password lib. Built into modern PHP, and someone has created a PHP implementation for older PHP. SHA256 isn't super secure anymore either...
Eh? `sprintf`. Using `implode` for string concatenation is asinine.
You could use iterators: $nestedIterator = new NestedIterator(); $nestedIterator-&gt;addIterator(new IncrementIterator(0, 26)); $nestedIterator-&gt;addIterator(new IncrementIterator(0, 26)); $nestedIterator-&gt;addIterator(new IncrementIterator(0, 26)); $nestedIterator-&gt;addIterator(new IncrementIterator(0, 26)); foreach ($nestedIterator as $current) { list($a, $b, $c, $d) = $current; // This goes from 0, 0, 0, 0 to 26, 26, 26, 26 echo "$a, $b, $c, $d\n"; } These two classes are not built in though, at least I couldn't find anything of the sort, so I created them to demonstrate the solution. You can find these [NestedIterator and IncrementIterator classes here](http://dpaste.com/3PM04B8). I'm not saying this is necessarily the best approach, I just thought it was worth mentioning. I hope it helps somehow, and that you're not trying to brute-force the alphabet.
Not with PHP, that's for sure.
Everything is less or more bloated compared to something.
I would not build it like you're suggesting to begin with. Having multiple sources of truth is bad. I doubt that you need to do it like this. I'd be happy to give some advice if I knew more what you're trying to build. 
Don't SHA. Use blowfish.
I don't want to communicate back to the server just because a player moved a slider and have to wait for a return value. I want something that updates the display live. 
Think of any moddable game where you can define new behaviours for things that happen in game in scripst. Simplify that and apply it to an online game with online editing - the "mods" are built right in to the system. You can modify rules or build entirely new rule sets and run games off it. It needs to be public and easy, yet also secure and trustworthy. "Pseudocode" functions seemed like the best bet for all of that, combined with needing to work both server- and client-side. The example given in the original post is a "SpeedCalc" function. The SpeedCalc function (the earlier example) interprets what that value means for both display (live update as the player changes the setting in-game) and for the server to calculate actual distance traveled. By default, it's speed squared - 1 = 1, 2 = 4, 8 = 64, etc. The alternate example provided demonstrates a Star Trek: TNG style distance calculation. Obviously, other simple variables limit things like maximum speed and speed value steps (default 10 and 1, although for ST:TNG it would be 9.9 and 0.1). 
I don't know your situation. By I'd use Ampps, very easy and painless. http://www.ampps.com
&gt; recently released a new version which version ?
The easy way is something like xampp/wamp or using vagrant. The harder way would be install iis and mysql community server for windows.
You can't really say xdebug is the best tool available compared to DBG and phpdbg
I'm sorry, I believe it was a security update. Not an actual full release. 
What's the error message?
"XHTML" and 2009. Horrible code. Why in the world is this linked here?
Just get on git hub and fork a project and do merge requests.
"Fatal Error: ezSQL_mysql requires mySQL Lib to be compiled and or linked in to the PHP engine" I had planned on cloning my webserver that normally runs this over for testing while I am out but if there is a better way to do things I am more than willing to learn if you point me in the right direction. I have a VM setup in vShpere that this site and database run on. I am guessing vagrant would be the proper way to deploy a testing server. Thanks for the help!
Yeah, it is that simple. I was just looking for some that the community here recommended. 
&gt;One should absolutely not expect that objects that implement Iterator be accepted by array functions. For starters, any function that modifies an array won't work. Can you tell me why, you type hint a parameter as an array?
it's hard to do that. generally the best way to get involved and also stay motivated is to pick something of direct interest to you. So pick some existing software you already use and think could be better and then start there.
Idk, i hear all the laravel guys saying theirs is the best documentation.... lol
To get an array. Not a string. Not an integer. Not an object. Not an iterator. Not an object that supports array-access operators. If I wanted any one of those types, I could hint on one of them instead.
One of the biggest beefs i have with laravel, is the attitude that most of the developers have with it. It isn't better than all other frameworks... There are definitely other frameworks that can be better suited, given the situation....
OK, so it's "had" not "has" right? :P I haven't seen the Laravel doc, I was speaking from the docs I've had to read in the past.
10 years ago? Misewell be starting from the very beginning if you haven't been doing any other programming x_x
I get the impression he is someone who is tangentially related to development, but isn't actually a dev... or someone who has never progressed beyond "junior" status. I don't see how someone could justify using tables. Even back in the day all they were good for, layout wise, was easy columns.
Yea you make a valid point. The thing you would have to do then is write something along the lines of **@body @("(")** or smth. But yea I understand how that could be annoying
Sometimes tabular data needs to be in a table. I don't do UI in PHP, but on the frontend Datatables is a sweet table to simplify table handling with dynamic bits of data.
Then use a stateful backend (maybe node.js, or python + twisted, or even java) and use websockets to maintain an open connection for each client. Your last sentence in the OP is correct. For this project, I would drop php and go with another option.
Run "php -m" to see if you actually have MySQL installed. Also, do you have MySQL installed?
Another option is having those rules in JavaScript only and evaluate them using PHP V8js extension http://php.net/manual/en/book.v8js.php
Those will still communicate back to the server
Everything you mentioned has its place.
I find template engines to be much clearer than mixing PHP and HTML. My name is &lt;strong&gt;{{ name }}&lt;strong&gt; vs. &lt;?php print "My name is &lt;strong&gt;$name&lt;/strong&gt;"; ?&gt; &lt;?php print 'My name is &lt;strong&gt;'. $name . '&lt;/strong&gt;'; ?&gt; My name is &lt;strong&gt;&lt;?php print $name; ?&gt;&lt;/strong&gt; 
That can be even simpler: My name is &lt;strong&gt;&lt;?=$name;?&gt;&lt;/strong&gt; But I do like templating engines as they offer a lot more than just simpler syntax.
Thats fine, I have no objection to people using them, just with the animosity towards not using them that is displayed when someone says they prefer it that way.
I often find myself wading into old / un structured code bases to fix bugs or add much needed features. I don't have much of a problem with it. In a perfect world legacy code bases would be upgraded to use newer frameworks and remove bloat and what have you, but sometimes projects simply don't warrant the time or effort to do so. Instead, I adopt the attitude of "when in Rome", and do whatever needs to be done to the level of the code base I'm working in
6 squared is 36... Just wanted to point that out :p
Exactly..This was the first thing that came to my mind...But may be, he got no choice...
I have two projects you might find interesting and that could use contributions: https://github.com/JordanRL/simpleprofiler https://github.com/JordanRL/APIManager
This post worries me a little. I used to use ColdFusion "back in the day" and was curious where it was currently. I know for a start that it's barely used, but some googling shows me that CF7 dates back to 2005, and the current version is 11. I should also note that CodeIgniter is quite thoroughly out of date now, and few if any applications will be built on it these days - it is almost completely going to be legacy applications. It sounds to me that this job is going to be **entirely** based on the maintaining of horribly old applications, in a dying language and a dead framework. Be very aware of the consequences of this. Sometimes you don't have a choice, a job is a job. But don't let a job kill your career. You need to keep your skills fresh and new. This isn't how you do it. It may be you can make up for it in your own time, but you will have to put in a lot of time.
Not me. I love Laravel, but I think the docs have some gaps.
I knew what link that would be before I even clicked it. But it's not really applicable IMO. The idea that a single alternative to a problem is somehow a "proliferation of standards" is misleading and wrong.
In my opinion, no. They will do nothing about the current API clusterfuck because there's no widespread admission that there's actually a problem. There seems to be this general view among the internals group that it's "cosmetic" or "trivial", and that it's an "idiosyncracy" of the language. My own view is that it's an absolute disaster in desperate need of fixing. These things could be fixed. But there's no direction, and no will to do so. It is, I suspect, something PHP users will have to simply accept.
C#
Could you pass the 'mods' as simple variables from the sever to the client, or are you talking totally rewritten js functions? Perhaps you could jsonize a compiled function from the server and have the client update itself?
I had a little trouble finding a lot of sanitization &amp; validation examples all in one place. Security for input from forms more or less. O'Reilly has a PHP Cookbook in its recently released third edition that had a lot of what I was initially looking for and then some. http://shop.oreilly.com/product/9781565926813.do I do wish I had spent the extra $10 or so for the pile of dead tree version sent to my house as well. I only bought the ebook version though. The one thing I remember really needing to handle differently is that a perfectly valid '0' submitted from a form will evaluate as false under some circumstances-- because 0 equates to false. I do not yet use composer. And autoloading looks really cool. The cookbook also goes into OOP features a touch and gave me a better gist of things I wasn't using than X-many years of coding has. Specifically the native autoloading built in. I have not read PHP The Right Way, I can make it the next book I read on my lunch breaks.
One immediate problem is that you probably mean: My name is &lt;string&gt;&lt;?= htmlentities($name) ?&gt;&lt;/strong&gt; 
This! It massively depends on what you want to do inside the loop.
I agree. People that don't do web programming don't seem to realize that you have to wear a lot of hats. At the very least a 'good' PHP programmer should have a solid grasp on at least one Web Server (Apache, nginx, or euughh IIS), PHP itself, SQL, HTML, XML, CSS, and JavaScript (including JSON &amp; jQuery or other helpful JS libraries). That gets you as far as a basic CRUD app that uses AJAX... You need to learn a handful of other tricks to manipulate images, send emails, generate QR codes, or a whole host of other peripheral features to be implemented.
We can compromise with a solution likes [Plates](http://platesphp.com/), which gives you templates using native PHP syntax.
True. I got my hands dirty in Rails and lots of Javascript, but I'm rusty :)
Thanks for the long answer. I still did a lot of HTML/CSS/Javascript over the years, so I'm familiar with the majority of advice provided by you. Your last three points are the most important ones for me. I remember reading on cracking MD5, but sessions and mysql security are now on my list. 
Also lots of thanks to you. While I stopped using php ten years ago, I was still active in frontend development. I'll stuck my nose in the code of symfony2 deeper - I spend an hour reading through the random pieces of code and the code is indeed nicely written. 
Unfortunately, I don't feel time is favour here. I spend a couple of weeks starting with Rails and while the framework is beautiful, I don't have the passion right now starting from scratch a new language. Rails with a solid understanding of Ruby sounds just wrong to me ;-)
Nice! 
You should type-hint in the minimal value you want to accept. If you see a function that accepts an array, you don't know if maybe the function randomly accesses the array or makes a copy of it. If the function is only iterating over the value then it should type hint on iterator. Callers should then just pass in an iterator, even for arrays. It's easy: $array = ['One', 'Two', 'Three']; iterating_function(new ArrayIterator($array)); There is no issue. 
OK, but if you're saying don't use CI because it's bloated, you ought to at least hint at what *isn't* bloated.
Oops. Typo, I meant 8 :) Fixed. 
Try to keep it fun =), after 10 years of PHP I've moved to NodeJS/JavaScript which you might want to look into especially since you've done a lot of JavaScript. The Express framework with NodeJS is awesome and with hulk hogan you can build sites with html files and variables just like you do with PHP.
Well, if you have tabular data of course you would use a table. I meant justify using tables for layout, as is implied by the original commenter. No one says use div for your spreadsheet data.
Well, plus one to you good sir!
These are the packages I use in Laravel most of the time: [way/generators](https://github.com/JeffreyWay/Laravel-4-Generators) This is one of the best packages and the ones I use more frequently it has come to a point where I can't play around in Laravel without them (it's just so damn useful) [barryvdh/laravel-debugbar](https://github.com/barryvdh/laravel-debugbar) Have not used it too much myself but it seems rather extremely useful when running into a issue and you're in the need of some debugging [dingo/api](https://github.com/) This is a extremely useful package when creating a API it has extensive documentation and uses Fractal (wonderful package aswell) and it's a must have for creating a API ( I have heard that [cartalyst/api](https://cartalyst.com/manual/api) is also a nice package to create API's with. [dwightwatson/validating](https://github.com/dwightwatson/validating) is a extremely helpful package for validating models and extremely easy to start using and has a quite nice documentation and sample code to get started with. Not too mention all of [cartalysts](https://cartalyst.com) packages are amazing and have impressive and easy to learn documentation and they're definitely worth the 75$ dollars for 3 months. Fortunately their [cartalyst/sentry](https://github.com/cartalyst/sentry) package is free and is a very nice authorization package with everything you'd need to get a *secure* web application off the ground. Sentry 3 has transformed into [Sentinel](https://cartalyst.com/manual/sentinel) and sadly requires a active subscription or to the lucky 500 (I think) who got a free active subscription to that. Sentinel is going to recieve the latest updates and fixes which I believe Sentry 2 is not ;( I myself am considering purchasing their package. I hope these packages are helpful to you and help you get your web applications off the ground as soon as possible. ;)
Please don't engage in personal attacks.
&gt; A grease monkey or body worker isn't a full service mechanic with ASE + specialty certifications who can build a car better than new Okay. That's probably true. (Though, also, I respect mechanics, and I think you might be under-selling them a little bit. Cars, like computers, when sold new aren't in perfect condition, and having a mechanic, like your buddy the nerd, once-over them even without certification does often actually end you up with a better than new device.) &gt; A line or fry or short-order cook don't have the same range of skills as a chef who will be able to plan a menu that will make money and manage the kitchen. That's very true. They both have skills the other doesn't. The line cook won't be able to balance a seven course, and the blue-ribbon chef won't be able to serve 100 breakfasts in half an hour in a modestly equipped kitchen. I'm not sure what that has to do with the appropriation of words that refer specifically to a part of webserver software, is the thing. I'm not trying to play up, or to play down, anyone's skillset, in particular. I'm just confused why we're calling everyone "full stack." That's not a term of respect or endearment. It's not like "oh wow, they've achieved a broad range of skills, and as such have earned the title full stack." There don't exist full stack lawyers, full stack authors, or full stack farmhands, despite that those are difficult, broad, specializable, complicated fields of profession each worthy of respect. Full stack means "does the frontend and the backend of a web system." Doesn't even mean all the other stuff that goes into a web system, like database work, sysadmin work, network security work, A/B stuff, etc etc. It seems, to me, like trying to call a programmer "esquire," or "your honor," or "senator." It's the misuse of a title reflecting a specific skillset and background as if it was a general honorific regarding respect. It's confusing and bizarre.
These are those I use: fitztrev/laravel-html-minify =&gt; minify your blade templates. mews/purifier =&gt; purify user input, if you need to accept html. It's basically a facade for htmlpurifier, but with simple configs. You can create different configs easily, so you can have an html-stripper and a config for markdown only. vtalbot/markdown =&gt; easy facade for markdown compiling. itsgoingd/clockwork =&gt; I prefer this to laravel-debugbar. I used the debugbar but because I use RequireJS and jQuery, it was causing conflict (debugbar injects javascript). Clockwork works as an extension to chrome, so it adds a tab in the dev panel. 
&gt; You should type-hint in the minimal value you want to accept... Minimal value? &gt;If the function is only iterating over the value then it should type hint on iterator. Callers should then just pass in an iterator, even for arrays... Well, that sounds plain stupid to me, wrapping it in an object just for the sake of fitting with a type hint. You know, what I a saying it very simple. When I type hint for an iterator interface, I want to accept all objects that can be iterated upon. Array is an object that can be iterated upon. So I want that function to accept arrays. 
Why don't you just start your own project? Just think of something big, pick a framework and start. Else, just join someone else his project. There are always open issues you can work on or you can try to help confirm issues.
Well I'm still learning and I just don't have anything that I need. Necessity is the mother of invention. 
these stickers are not for sale. its a limited edition, we are looking fwd to print more. oli, fortrabbit.com
That looks really good by the way. Maybe when I get up to par I'll see if I can contribute anything ;). Anyways, I try to think of something slightly above my skill level that causes me to pursue learning further, but not too far otherwise I get discouraged.
* [rydurham/Sentinel](https://github.com/rydurham/Sentinel) (Not to be confused with Sentry 3). An implementation of Sentry 2 which handles log in, registration, forgot password etc with Twitter Bootstrap. * [robclancy/presenter](https://github.com/robclancy/presenter). Presenters. * [Anahkiasen/former](https://github.com/Anahkiasen/former). Form formatting. * [intervention/image](https://github.com/Intervention/image). PHP image handling and manipulation library - not Laravel specific but I feel it's worth mentioning. 
Haha thanks. At least that gives me a direction to look at. Appreciate it. 
You could hit up Simon Welsh on #silverstripe on freenode. It is his code.
I too just inherited a few CodeIgniter projects after doing Laravel only for over a year. So my answer is to sidestep CI. Watch /u/rossuck's talk on Service Layers. http://youtu.be/3uV3ngl1Z8g I had to watch it a few times with a bunch of other googling, so now I have a Service Layer which I bootstrap Laravel's IoC Container and Eloquent (which also adds a few more goodies) and implement that in a way that /u/shawnmccool talks about here http://youtu.be/2_380DKU93U which is an implemention of what /u/fideloper talks about here http://www.reddit.com/r/PHP/comments/29bprf/hexagonal_architecture/. Put all that together, and you end up with a robust Service Layer and sits next to CI, and then what I do is use CI's controller to grap the data from the Service Layer and pass it to the View. The Model is in my system. It's a beautiful thing. After I get everything refactored into my SL, then I will be framework independent and can move to a modern framework, only needing to replicate the views.
After using https://forge.laravel.com since it was released, I wouldn't build anything new any other way.
&gt; Well, that sounds plain stupid to me, wrapping it in an object just for the sake of fitting with a type hint. Array's in PHP aren't objects. They can't even be made into objects because they don't have reference semantics like objects do. Assigning an array makes a lazy copy of an array. You can use the built in ArrayObject for an array that is in object and it also implements the iterator interface. It does everything you want. &gt; You know, what I a saying it very simple. It's never that simple; you have to take into account every consequence. 
So jealous :(
Damn, I know that package was named beforehand but it must've been annoying to have the Cartalyst team re-release Sentry with your name.
This certainly won't help you, but I do love that "Joomla", "Wordpress", and "Drupal" are part of the swear words file: http://logs.simon.geek.nz/source/swears.txt
Here's the easy way https://developers.google.com/chart/interactive/docs/gallery/calendar#SimpleExample
All the logs are in postgreSQL hence the line $this-&gt;con = pg_connect('user=simon password=pass dbname=logbot'); In the funcs.php The database structure is something like this * Time (datetime) * Text (string) * Command (string) * Target (properly string) * Nick (properly string) * ID (properly integer auto increment) * Search (text properly with full text searching or a index) And the code also uses Redis as cache Setup a postgresql database with the above fields in a table called ***Log*** and change the username/password to the postgreesql server near the top in funcs.php Setup a redis cache on localhost Add your logs to the Log table, and fire up the index.php in the www folder and see what happens
Thanks, I will be trying this tonight and tomorrow!
I am working on a project that is just for fun and has pieces at various skill levels. The beta is at http://japaneselearningsite.com/ I have to warn you that the code I write is generally procedural and does not use a framework.
PM me if you want a scraper heavy job.
It depends on your constraints really (money, traffic, etc). Memcache or redis are not bad solutions too but just make sure you abstract your code so that you can easily swap the storing engine later.
Agreed with /u/castironpotatoe. I'm using memcache in my implementation, but it goes through a generic cache lib that could be swapped out whenever. [Here's the actual implementation code](https://github.com/dxprog/reddit-booru/blob/master/lib/session.php).
Not sure if anyone will still see this, but to add to the question, do you think the standard advice of "don't rewrite, refactor" always applies or are some codebases (such as the one OP described) beyond saving? I mean, if you were to try to make such a codebase clean, testable, separated concerns, etc., you'd basically end up rewriting everything anyway but I feel like it would be less painful to start from scratch. Of course there are budget/time issues, but assuming a decision was made to massively improve the codebase, would it be easier to just rewrite it?
There is none. This is JS leaking into PHP for no reason.
&gt; a good IDE for php dev is PHPStorm (i love it!), but if you prefer a lighter and faster editor, sublime text should do the job (and can be heavily extended over time with Package Control). Also, Netbeans. It does the job well and is free. https://netbeans.org/ 
That is not constructive.
Like the idea, though implementation seems a bit ambiguous. array_map(&amp;strlen, ['foo', 'foobar', 'elePHPant']); // [3, 6, 9]; This syntax reminds of call-time pass by reference.
I don't know how it can be useful (is it just a shortcut to "bind" then call?), but the name of the function isn't very good IMO. We would have `__invoke()` and `call()`, each one doing a different job (i.e. `call()` takes an object first). That's confusing.
Oh dear. How would we ever have known? If only there was some indication as to what types I should use in the documentation. string bcadd ( string $left_operand , string $right_operand [, int $scale ] ) string bcdiv ( string $left_operand = "" , string $right_operand = "" [, int $scale = int ] ) string bcmod ( string $left_operand , string $modulus ) string bcmul ( string $left_operand = "" , string $right_operand = "" [, int $scale = int ] ) string bcpow ( string $left_operand , string $right_operand [, int $scale ] ) string bcpowmod ( string $left_operand = "" , string $right_operand = "" , string $modulus = "" [, int $scale = int ] ) string bcsqrt ( string $operand [, int $scale ] ) string bcsub ( string $left_operand = "" , string $right_operand = "" [, int $scale = int ] )
&gt; The whole goal of that is that you get autocompletion from the IDE and refactoring support: I wouldn't mind a feature enhancing the autocompletion, but I don't think you shouldn't propose one ONLY on that basis. 
Good point, but the broad argument would be "static" referencing, with all the good things that come with it: - fail early if a property/function/method doesn't exist - more readable code (see my example above, the reference is more explicit than the string) - better tools support (already mentioned in the previous comment)
This is not something people should be publishing tutorials for. If you can't work out how to do this yourself, you shouldn't be touching phpng.
That's the spirit! Let's keep all the knowledge to ourselves! Jesus...
Depends on https://wiki.php.net/rfc/closure_apply, see php-internals post [here](http://php.markmail.org/message/um5anpe2xntpkgqn).
&gt;PHP-NG is quite usable in production. No. If the software hasn't been released, don't use it in production. End of. 
No, it's not about "keep all the knowledge to ourselves". It's about creating an environment where people who shouldn't be touching highly unstable, development code aren't. phpng is not currently in a state where people who are not directly interested in working on PHP core code (ie. are C programmers, or at least have enough knowledge on how the internals of PHP work and how to run typical "C level" debugging tools such as strace / gdb) should be touching it. And to pre-empt the "people might want to test their code for stability / issues", this is far too early to be doing so. This branch will (most likely) be merged into PHP.Next and given even a small selection of the other changes which are being proposed for PHP.Next, it will be unrecognisable with many major changes (both internally and affecting "userland" PHP) by the time it has any sort of alpha release.
Oh dear gods! NOOOOOOOOOO! I missed that part. Development branches like PHP-NG should NEVER EVER be used in production. &gt; The RFC says that at the time of submitting it (the RFC, I mean) approximately 20 tests out of about 11,000 PHPT’s were failing (~0.18%). I’d say that’s a high enough compatibility with the “old” Zend engine! :) Yeah. Just a few problems with that logic: * The test suite does not test or have any relation to compatibility with previous versions - it's only tests against the current expected behaviour (tests are added or updated as that behaviour is changed) * Quoting a static figure from the RFC is dumb. This is development code, constantly changing. That figure will almost certainly have changed. * PHP's test suite does not claim to be complete - there will be bugs and other issues it will miss. * At this stage of development security issues probably aren't being thoroughly tested for and fixed in a prompt manner.
As the word "production" does not reflect all cases, I have edited it out. However there's a difference between running a SaaS app with a 100K visitors per day on it and running your little blog with 10 visitors a day on it. You have to decide yourself based on your unique requirements.
Then you underestimate the [stupidity](http://www.amazon.com/s/ref=nb_sb_noss?url=search-alias%3Daps&amp;field-keywords=php%206) [of]( http://www.lifeofguenter.de/2014/08/the-rise-and-fall-of-phpclasses.html) [people](http://philsturgeon.uk/blog/2014/01/the-tribal-framework-mindset) - especially when you start putting false claims like "production ready" in your posts and put them on /r/php .
&gt; Development branches like PHP-NG should NEVER EVER be used in production. I have edited and clarified in another comment that part. &gt; The test suite does not test or have any relation to compatibility with previous versions That's one of the reasons why someone might want to compile the source and try it in their environment. &gt; Quoting a static figure from the RFC is dumb. Based on that logic as the world is constantly changing, writing tutorials for anything computer related is dumb, it will change anyways so why bother? &gt; PHP's test suite does not claim to be complete - there will be bugs and other issues it will miss. That's why everyone should test it. And godforbid submit submit a bug report or something else useful. &gt; At this stage of development security issues probably aren't being thoroughly tested for and fixed in a prompt manner. That's an assumption, which might be true. Luckily there are never ever any security issues with other (old) PHP releases. ;) I'm still not sure what it is about this tutorial that upset you so much... If you're afraid that every Jane and Joe will start using PHP-NG now because of it, then I think you should recalculate the chances of that. Again and again, until you reach the conclusion that this article may have helped one or two dev / devops guys (in the whole lifetime of the article itself), who probably know what they're doing anyways but are too busy to scrape the information together from a gazillion sources.
&gt;However there's a difference between running a SaaS app with a 100K visitors per day on it and running your little blog with 10 visitors a day on it. You have to decide yourself based on your unique requirements. And neither case would warrant running unfinished, unreleased software with potential security issues. There are other roads to walk. 
+1. I haven't even used `bind()` / `bindTo()` once, why would I need `call()`..
Maybe I did not expressed myself correctly. The API requires user authentication. So, when the client sends me their username &amp; pwd, I generate a random token to associate following requests with that user. The client has to store that token, of course, but I also need a way to map the token with an actual user ID, and what I don't know where to put is that map.
It's a good idea, the fact that when the password changes, all session become invalid. However, I still have the original problem: How do I know who is sending me the request? Neither iterating over all registered users nor sending the username in "plain text" (ssl is assumed there tho) look good to me. EDIT: As /u/castironpotatoe suggested, I'll give memcache a try. It seems to be exactly what I'm looking for :D
Cache it server side. Expire the token after some time and during logout. Renew its ttl on every requests.
Hmn, I didn't really know about the existence of memcache, and it seems perfect to me! Thanks! :D
Yup, what I was actually asking is *where* to cache it :P Somebody suggested memcache, and I think I'm going through it.
This does not reflect the common way to build PHP applications in 2014. Please DO NOT base any code whatsoever on this tutorial.
Very skimmable / readable documentation, but it's not 100% thorough. 
Hey Folks, I apologize for the late response, my deck took priority over work for the weekend. I do appreciate your assistance. Below is the example code and the output. &lt;?php $test = "I am a test string"; error_log($test); &lt;? The out put is this. I am\n\t\ta test\n\t\tstring
Yeah but you probably rely on a framework/library that do make use of that. You might not be using it, but you might still be needing it. (I'm talking about `bind()/bindTo()` here)
I'd go with skimmable/readable, but not terribly helpful.
If they can explain why it is compulsory no. If they cannot explain it would raise warning bells but if I was happy with everything else I would probably accept. The only issue is if the editor was something like vim. That would be setting me up to fail and I wouldn't be happy.
Absolutely not. Unless it was an indication of extremely poor decision making or raised some sort of red flag. Like... "We use Dreamweaver because we have a contract with Adobe to exclusively use their software." or "We only use PHPStorm because that's what Steve uses and Steve would know because he's the best." Or "We use Eclipse because it's Java, which is the language of the future". Or some other dumb shit. The IDE itself wouldn't be a factor, the decision making might be. 
https://github.com/phalcon/mvc That details many different kinds of project structures that one can use with Phalcon. Also, don't forget the devtools (http://docs.phalconphp.com/en/latest/reference/tools.html), which can help you set up a project to your liking. 
^^ This. It screams of micromanagement - and likely by someone/people who have no idea what they're talking about. I sometimes wonder why my developers choose to use what they use (notepad++ when we have licenses for phpstorm and dreamweaver) - but in the end, whatever allows them to be most productive is good enough for me.
It would prevent me from accepting the job, because it's a dumb thing to require. I have spent a significant amount of time and investment into using, learning, and optimizing `vim` to the point where it is now the only editor I will use. IDEs in comparison are slow, clunky, and will severely hinder my performance and efficiency. A professional should be able to choose their own tools. This would be the equivalent of hiring a bunch of artists of all different skills and telling them they all would be forced to use only acrylic painting for their tools, instead of the tools they prefer, and have invested in their entire careers. As others here have already noted, the requirement of a specific IDE to be used is really more of a red flag than anything else - It's a sign of management that doesn't know how to manage programmers. I would stay away.
Why, why, why? It's a development branch, highly unstable, and shouldn't be used for anything more than testing and contributing to the branch. If you can't figure out how to compile it from source, you shouldn't even be touching it. Hell, it still has a possibility of not making it into PHP NEXT since the RFC hasn't passed. And seriously? 5 requests? For a benchmark? Use a tool like `ab` and do something like 100-1k requests, and even add in some concurrency. 5 requests is absolutely useless.
OK fine, but saying "everything is less or more bloated compared to something" is a complete non-statement. What was the point of pointing out that you think it's bloated?
I would be interested in the reason why. If it's a good reason, I am ok with it. Next to that, it also depends on how close the tool comes to my favourite IDE. However, if it's eclipse, I would probably try to get an other IDE or quit. That's the only IDE I really hate.
Because the OP asked what to expect?
You didn't point out all the other stuff that applies to every framework either... ;)
You raise a very good point. but don't forget that maintaining an old legacy app is a skill as well and it show that you are capable to solve problems regardless of the platform or the framework. 
Its actually pretty powerful, and moderately easy to learn :)
The IDE, not so much...the operating system? Definitely. I've turned down a job before based almost completely on the fact that all of their workstations were Windows and the job was for a PHP programmer. Can I dev PHP on a windows box, sure. Would I ever _want_ to? Nope ^nope ^^nope
I originally named it `apply`, but then noticed JavaScript calls the one that doesn't take an array `call`, hence the URL. :)
https://github.com/search?l=php&amp;q=bindTo&amp;ref=cmdform&amp;type=Code
&gt; v0.2 - Closure::apply renamed to Closure::call for consistency with JavaScript but i'm not writing javascript... I think "invoke" would probably be a better name to make it more consistent with PHP [ReflectionMethod::invoke](http://php.net/manual/en/reflectionmethod.invoke.php)
Just because you haven't used it doesn't mean someone else won't use it. Would you reject the inclusion of PostgreSQL because you use MySQL?
yeah 5 requests seems strange. HHVM isn't even 'primed' until the 11th request for a resource anyway. it seems a bit fishy to me.
Yeah sorry meant constant. And the RFC only gives the static referencing for functions and methods. Hopefully it could be generalized to everything.
Yeah that would be great. But that wouldn't be a consistent syntax. If `&amp;FooBar` would work like `FooBar::class` (maybe return "some sort of object" like you suggest) that would be great. Same could be applied to properties then. But I think the `&amp;` might be too confusing.
No it isn't, and no it doesn't. :P
What do you use? I used windows for most of my career, but couldn't go back from a mac now. 
I have never worked (and would never work) at a place where they limit my options for IDE, OS or any other developer-specific software.
How is it "not terribly helpful"? I learned 90% of what I need to know just through those docs. Only when I needed to do something more advanced did I have to dig around in the source code or ask on SO. Honestly, 90% of normal use cases are documented in Laravel's docs.
Navigating and thru old and complicated code sure is a skill.
Do you really need all of those parameters? Because if you do, then it sounds like you have too many things baked into a single command.
Vim is love, Vim is life.
I think if this were added, IDEs could colour it differently, perhaps.
We already have __invoke, wouldn't that be confusing? Also, we already use "call" for call_user_func and call_user_func_array.
And if you're using doubles, why aren't you just using the built-in operators?
What you need to consider is licensing costs, support infrastructure and security vulnerabilities. In a company as large as mine (30k people) it would be nye impossible to meet the needs of developers all using their personal preferred IDE. Not to mention conflicts with software lifecycle policies and incident management.
Really? Or is it a pointless waste of time? I mean, just because something is time-consuming doesn't necessarily mean it's a valuable asset to my team. I'm speaking from the point of view of a potential employer here. I wouldn't consider extensive experience with legacy code a benefit at all. I'd be more concerned it had stunted their professional growth. Trying to turn it into positive doesn't sell me on it as a "skill". 
How do you populate a drop down from a database?
Then I'd suggest you just learn to deal with it. You obviously have a very complex command, and trying to fake things out is just going to make your code more complex and harder to understand. If you really can't figure out how to make it simpler or split it out, it's best to be straightforward.
Obviously NG should not be used in production, or anywhere near production. However, there is value in sharing information about setting up to run benchmarks, it allows everyone to verify results, stops any kind of dillusion, also weeds out edge cases. If everyone decides to test their apps with phpng tomorrow it will leap forward in stability and reliability very quickly should they bother to report bugs ... So, setup, do the benchmarking, run your own tests, report bugs, be amazed, but don't take it to production ...
yeah, nothing wrong with Windows if that's what you like/what works for you. I'm also Linux + Linux on vagrant...all that said, any company telling me I am required to use a Windows box to develop for a Linux server, or requires me to use a specific IDE when multiple options are available....red flag
I'd say the issue there is in your workflow. Your host OS shouldn't matter at all as a web developer. If you have the resources, you should be working on a full server stack (i.e. dev &gt; qa &gt; stage &gt; prod), if not, should be using vagrant or similar. I've been working as a PHP Developer almost exclusively for the past 6 years and rarely work outside of windows (Mostly because I sometimes have to work with javascript as well and want to replicate my majority end-user experience as far as browsers go, also because I'm just used to it now).
well, it's tickets support system and these are the params to be passed title, assigned_to, owner, priority, status, details they all related to a single command.. no way to separate them
Personally, Ubuntu.
I work as little as possible with JS, alas I have a Windows 7 vagrant box for testing on the front end if it's absolutely necessary. I also do systems stuffs along with a smattering of languages from C to Ruby and in between. Setting up / maintaining the environments for all of these on a Windows box is unnecessary in my opinion when interpreters and compilers are available through &lt;insert distro&gt; package management.
Fair enough, just saying that your host OS shouldn't matter for anything other than personal productivity.
no
That's not a lot of params imo i have some commands with a bunch more than that. If you're using the latest version of the Laracast Commander you can ignore sending parameters and it will map all the input data to the command on it's own. Just take a look at the examples over at the github repo here: https://github.com/laracasts/Commander#the-controller
/r/python
It would be good if you could give an actual use case. That link just gives a load of example code of how to use the syntax, but with no actual use case so has very little context or meaning to me.
Vdebug.
I smell either an admin or manager. :) Point well made though, probably wouldn't work there.
security analyst. We are probably the least favorite group for the development staff. THEY all want full time admin to production systems to lob whatever asshat code they cooked up on to our customers any time of day or night.
I would refuse to work without 3 displays, OSX for OS and PHPStorm for IDE.
In this case, it's good design. Sorting is very resource intensive (CPU/RAM) for even slightly-large arrays. Imagine you have 8MiB of ram in a PHP instance and you want to sort an array costing 4MiB of ram - it cannot be done *unless* you sort the original array in place. If sort() was designed to return a sorted array, it would need to allocate another 4MiB* of ram. *plus a bit more for the algorithm to actually compare/swap variables
The original article was posted here 13 days ago, but it just made the Symfony blog today. Here is the previous submission if you want to look at the comments: http://www.reddit.com/r/PHP/comments/2be5ei/handling_1_billion_requests_a_week_with_symfony2/ 
From the article(emphasis mine): &gt;For most people, using **full-stack frameworks** equals slowing down websites. At Octivi, we think that it depends on correctly choosing the right tools for specific projects. and &gt;Features we don't use &gt;**Doctrine ORM** &gt;**Twig** Not really fair to say Symfony is fast when you're not using the chosen Model library or the chosen View library of an MVC framework. This just clarifies that they have some fast components related to request/response/routing. Which is already evident by the fact that other frameworks use these components with great success.
&gt; nigh impossible FYI 
I mean it's only possible on new year's eve
Ah, I thought perhaps it was a unit of measurement of impossibility named after Bill Nye. 
Yeah like it shows the company professional level, if they use Dreamweaver I will never accept a job there. PHPStorm is the IDE for me and Sublime Text is my current editor. For me it's important that a Tech company is updated and got a vision and is willing to adapt to new Tech... In place of force complete outdated software to their developers. And make the live of the developer much harder. It's one of the red flags that this company may have some problems that can turn into huge problems. It's like that time I got hired as a Developer and got my first project to make web design with notes to make sure it works in IE6..... I was like wait a sec you hire a web developer and not a designer and the guy was like both they are both the same thing, also I need see the completed design in 3 hours. 
Haha, maybe! Depending on how bad I need a job, I would take the job, and then I would covertly use my own, and set it up to work in conjunction with others. I've never been to a firm where all the developers use the same IDE. There might be cliques, but for the most part the IDE is used for its features, some are better than others, and some jobs demand certain IDEs. If they told me it was required, and I didn't like using it, I would reject the job, simply because it would hinder my ability to do my job. It's not a very productive way to run a business if they force people to constrain an employees preference for the right tool. Kinda lacking vision there.
I read your first sentence and wanted to down vote you. Then I read the rational. Up vote for you!
:D thank you sir!
Piwik is one of the few PHP open-source projects to have a security bug bounty program: http://piwik.org/security/ We have quite a many such OS projects in the PHP land who should follow Piwik on this.
OS I may be able to deal with, if its a security concern (as dumb as that is). But, yeah, it would definitely depend on the reason...
Well, it was just a combination of an idea, a template and a framework. See if you can come up with a simple idea and start building :) Maybe you throw it away after a year, but at least you learned from it :)
We've been over this before. The lack of those two things doesn't make symfony any less of a full-stack framework. Stop nitpicking this shit. Its getting old. Link of you getting downvoted before: http://www.reddit.com/r/PHP/comments/2be5ei/handling_1_billion_requests_a_week_with_symfony2/cj4j8wn
For me it's the opposite. IDE I might be able to deal with, maybe. But if they don't let me use my own Linux setup, we part ways. I have rejected offers for this in the past and I'll do so in the future. My setup shouldn't matter as long as I'm productive and deliver on time.
&gt; I do pick phpstorm over *everything* when it comes to PHP. I have seen many sceptics turn into absolute believers in PhpStorm. Once you start using it you can never settle for anything else.
&gt;We've been over this before. Yes we have, but new article, and I'm trying to leave a comment discussing the article for those who haven't seen it. Just because you've already seen it means nothing to me. &gt; The lack of those two things doesn't make symfony any less of a full-stack framework. Wow, way to not even understand what I'm saying. Of course symfony is a full stack framework. However, when you take a full stake framework like symfony, and choose not to use two major compoents that represent two of the three tenants of MVC, you're not really using a full stack framework anymore are you? &gt; Stop nitpicking this shit. Its getting old. So, it's OK to make misleading claims in an article, but it's not ok to point out that those claims are misleading? What's the point of even having comments if not to point out stuff exactly like this. Sounds more like you're expecting me to just accept that symfony is the best thing ever. I do accept it's a fine example of an MVC framework, one I use on a daily basis, but I don't accept the misleading claims from the article.
&gt; Yes we have, but new article, and I'm trying to leave a comment discussing the article for those who haven't seen it. Just because you've already seen it means nothing to me. no, its the same article. &gt; However, when you take a full stake framework like symfony, and choose not to use two major compoents that represent two of the three tenants of MVC, you're not really using a full stack framework anymore are you? from /r/aorfin &gt; Keep in mind it isn't that Symfony2 is meant to be -strictly- a mvc framework, of course in the most typical use cases it's used for building MVC applications.... But hey! Arent we now talking about a MVC application? &gt; there's huge codebase for [M]odel handling (redis, doctrine dbal, cache logic etc) &gt; [V]iew - yep, indeed we are "only" returning some JSON but thats our view format. You can change it to the Twig if you want to ;) - that's a feature of MVC architecture, easy replaceable view layer. &gt; [C]ontroller - some logic still sits there &gt; You're right - you won't be able to achieve such results with orm, twig and e.g. advanced forms. But for that, in every application, you use cache layer. Even Stackoverflow bases on a full stack .NET framework... It's all about smart caching. The key in our article is that, even when requests go to Symfony2/PHP they are still handled quite fast, without big overhead from a framework. Saying more - in the most webapps request ends on some Varnish layer (which is superb fast), in our - almost every goes to Symfony2 :-) Yes, it still is a full stack framework. Still models, still views. and &gt; So, it's OK to make misleading claims in an article, but it's not ok to point out that those claims are misleading? They make no misleading claims. They clearly state they arent using ORM and twig. Nothing misleading about that.
Piwik is awesome. My company uses it for all our clients and I haven't had a single complaint. It's much easier to understand than google analytics. The road map is looking good as well, I'm looking forward to A/B testing, though I can't really tell how that will work from a privacy perspective. 
Committing code that doesn't compile sounds like a developer issue, not an IDE issue... THis is one of those dumb reasons why i wouldnt accept a job. Just fire her, and allow other IDE's.
&gt;no, its the same article. This is not the same reddit post as last time, it's also not the same link, yes it's the exact same content, but again, not the exact same link as last time, thus I was posting here for people who saw this reddit post and not the last one. I really don't get how this is complicated to you. I suppose I should have written "post" instead of "article", but who's the one nitpicking now? &gt;They make no misleading claims. They clearly state they arent using ORM and twig. Nothing misleading about that. I understand what they claim, but this may be a real shocker to you: ***NOT EVERYONE READS THE ENTIRE FUCKING ARTICLE*** While you deserve a bajillion fake internet points for obviously reading the whole thing, not everyone else does, and if you notice I quoted something in the first sentence, as well as something stated at the end of the article. Most people would gloss over this article and not read the finer print of it. For those people, I offer some clear comments letting them know what they might be missing. So, this leads me to ask: ***WHY THE FUCK ARE WE EVEN ARGUING OVER THIS?***
No. I guess it somewhat decides on the size of the client. If its a 5 man shop with anal policies I would probably not work there, but if if it a larger client with decent size IT dept I would respect their working environment and adapt to their process. I suspect your answers are mostly from small-shop developers or freelancers as they are so sure their personal work-flows cannot be compromised. If the shoe were on the other foot, I am not sure (in a large shop) I would hire a developer who could only work using phpstorm or similar. In a small project I would not really care as long as they got tasks done in time and produced quality work. 
One of the downsides of frameworks like laravel is the application boot time. You can speed it up with op opcode cache and by running the artisan commands to compile and optimise the code. That might give you a good enough boost. I don't know which server setup you use, but nginx with php-fpm (5.5) over a socket is really fast. If that's not enough you can try varnish to cache full requests. Or you could write something that writes static files and let laravel only generate and write the requests for files that don't exist. Biggest challenge would be invalidating and deleting old files. I hope this gives you some ideas. 
Can't stand how much of a resource hog it is. Tried it, ended up with Sublime Text Editor and now we're married!
Still you nitpicking. All you had to do, was link to your previous comments, and let people see how crazy you are again. &gt; For those people, I offer some clear comments letting them know what they might be missing. You aren't offering clear comments, you are bashing the article. **BECAUSE YOU ARE STILL NITPICKING SOME BULLSHIT ABOUT THIS NOT BEING A FAIR REPRESENTATION** like i said, they CLEARLY state they arent using ORM and TWIG. Its not your job to call everyone out for **LITERALLY NOTHING**. /endrant. 
Any "true" IDE is going to be a resource hog.
I wouldn't call ST a "true" IDE, i'd call it a super glorified text editor. I mean that as a compliment. Its good at what it does, but it doesn't have the full feature set i would expect for an IDE
&gt;Still you nitpicking. All you had to do, was link to your previous comments, and let people see how crazy you are again. Do you even have an argument, or are you just pissed off i'm not agreeing with your views? You keep saying nitpicking. Guess what, I'm allowed to not agree with you, get over it. &gt;You aren't offering clear comments, you are bashing the article. I'm pointing out what people may miss by glancing at the article and also what is contradictory IN the article itself. Sure, you can call that bashing, fair enough. But tell me where i'm wrong. The article flat out contradicts itself. You keep saying "You're nitpicking" but you can't even discredit my point. Instead, you just get angry. Pro tip: if you want people to believe what you're saying, getting angry rarely helps. You should go outside and relax. &gt;like i said, they CLEARLY state they arent using ORM and TWIG. Its not your job to call everyone out for **LITERALLY NOTHING**. Thank you for telling me what my job isn't to do. I'm so glad I had you, random internet stranger, to clear that up for me. If the article wasn't clear, they wouldn't have made the claim they did in the first sentence about full stack frameworks, then go on to provide benchmarks for a third of a full-stack framework. Clear as mud.
Thank's for the kind words. Just wanted to let you know Sentry 2 will receive bug fixes, security patches etc. Also we released sentinel stable today. https://medium.com/cartalyst-works/cartalyst-report-31-a3ef8c5bb4ab
I regret we had not noticed that until after our announcement. :(
The first few pages don't, but towards the end there are some, for example using it for mocking. Daniel Lowrey has a specific one: http://chat.stackoverflow.com/transcript/message/18091142#18091142
I shouldnt need to add extensions to get features provided by a true IDE (Eclipse, netbeans, PHPStorm). Fanboyism has nothing to do with my calling of ST a glorified text editor.
Holy shit dude. &gt; then go on to provide benchmarks for a third of a full-stack framework. Clear as mud. **IT IS STILL A FUCKING FULL STACK FRAMEWORK** get over it.
My sides have never seen orbits of such magnitude, you sir are a great jokester. Apparently all the "true" IDE's should remove their extension support, because that makes them less of a man! I'll get alerting the teams tasked with sending out "the memo" to those who should be in the know right away! On a serious note: God forbid you have to select the packages you want that offer a similar experience in any of the editors you consider to be holy, while not being bombarded with a bunch of "beginner" feature-sets. The humanity! As I said before, learning how to program effectively is **my** job, that is why I am paid to do what I do. It is not the job of an editor, and to consider an editor anything less than what it is ("true" vs "false" editors) simply because it doesn't provide those features is silly and shows a real lack of understanding in regards to what makes you a developer (hint: it's not your IDE, and if it is, please find a new job).
&gt; Apparently all the "true" IDE's should remove their extension support I didnt say that, they already have the basic functionality that should be included. &gt; On a serious note: God forbid you have to select the packages you want that offer a similar experience in any of the editors you consider to be holy. The humanity! I'd rather spend that time developing, and not hassling with pay for plugins, or plugins that simply don't work.
Hey, thanks for the reply. Then why do people rely on frameworks to develop their API server? They do more complex tasks and require a framework to speed up their development? They simply don't care about the speed at all? Or, there are lots of tools available to speed up even the slowest framework so they prefer battle tested components to create their API server? We use Nginx in front of Apache, php-fpm 5.5 with zend opcache. (Afaik, we had Serverpilot install it for us.) I assume Varnish will help only for certain GET requests, right? (e.g It will load /api/v1/something's response from it's own cache without hitting Apache.) If so, we'll be using it. (My own projects use it like that.) We'll also be using IronMQ on PUT/POST requests to shorten our response time, but I believe Varnish can't do much in this case. Is there anything we can do speed up this part? The reason I need such a low load time, is because in some cases, our API server should return a response under 50ms. (e.g we should be able to make an API call between link mouseover/mousedown events, which roughly take 100-200ms.) Also, what do you think about my last idea? Having something runs forever on CLI and simply listens/responds connections. (like NodeJS) I'm sure we can use React/Ratched or something like that. Ps. I don't understand the downvote, isn't this a valid php discussion?
Is there a way to use `sprintf` to join an arbitrarily long array of strings? Because that's what I use `implode` for.
I can imagine ORMs being slow, but is Twig really slow?
&gt;pay for plugins Haven't bought a single plugin for ST.... &gt;plugins that don't work Haven't had a single plugin for ST not work for me, or steal all my RAM or CPU. Have you even used ST or are you just talking out of your ass at this point? Are you even a developer, or do you just work on WordPress sites in your free time? Keks. Keks all around.
They should want you to be productive in an environment you feel most comfortable. I went for a job interview a few months back for a company that just used windows and some kind of wierd virtual environment (not vagrant) that ran on a server in the office and you ssh’d in. I said i wanted to carry on using mac and by the end of the interview they had agreed to get the mac and adapt their setup to allow me to be comfortable. If the company is mandating you do things in their preferred way, i would worry, but then I’m lucky ive worked for companies that allow me to find my own setup, whatever that might be and work within that. Dreamweaver is a tool used by frontend developers who have just done a cource on Lynda.com (thats how i started), so I would say that it says more about the experience of the company than anything else. 
Yes, i have, when ST 3 came out. Why don't you stop being an asshole, and revert to having an adult conversation here. I mean jesus, you are acting like i kicked your puppy. Talk about fanboyism.
According to my resource monitor, Chromium is using more resources than Android Studio (same base as PHPStorm). Sadly, Java itself contributes about half of the memory use of the JetBrains IDE. Over all though, I have found it to be stable, quick, and feature packed. For some things, yes, I continue to use Kate (does most of what Sublime does, and a few things it doesn't that I use constantly), but the extra things that PHPStorm does makes it so much more useful, I'll deal with the extra resource use.
That's exactly why I appreciated his comment. If the article was about optimizing Symfony using those 2 components then I would have, but his comment saved me from doing so.
Serverpilot installs apache between nginx and php-fpm. When you read the docs you can see how to remove apache from the stack. This saves you a lot of time. Serverpilot also sends the php-fpm over tcp/ip instead of a socket, you can create a custom configuration for php-fpm and nginx to create the socket and have nginx tap into that. I can't really say much about your idea, I have no experience with that and I guess it depends a lot on the application. People use frameworks to speed up development, it saves time and thus money. Performance can (usually) always be optimised afterwards. You can tune varnish any way you like, but at some point it will possibly mess up your work flow when outdated content might be served. Usually you use it for staticish content. You could also prefetch the responses in the user's browser for even better responsiveness. 
I'm not being an asshole? I'm not the one referring to ST as a sub-par IDE because I'm a fanboy of Eclipse/PhpStorm/Netbeans or whatever you use. You're the one getting worked up here friend :) As I've said multiple times, this is absolutely hilarious to me. Sublime, Netbeans, PhpStorm, whatever you want to use I don't care, they're all IDE's, and they all produce the same product.... Just because PhpStorm has one more feature than Sublime does not make it "supreme overlord of IDE's" and knock Sublime out of the IDE category, which is how you're acting. EDIT: By the way, don't kick your puppy and blame it on me. That's not cool dude. That's what you're doing.
I understand where he's coming from. I tried using Sublime Text 2 and used the exact same phrase that he did to describe it, a glorified text editor. It may have been the best glorified text editor I've used though. I get what you're saying, it very well could be technically considered an IDE, I think that's why he used the term "true" IDE. It didn't have the feature set I'd expect either. In my experience, using plugins on those glorified text editors to give it the feature set tends to add the same bloat that a feature rich IDE has. If Sublime Text with plugins has all the features of something like PhpStorm without the bloat I'd be both surprised and delighted to find that out.
Its a good article to read either way.
How would you prefer the white space be handled?
Fair enough.
I was purposefully insulting your intelligence, not because you use sublime, but because you are being an ass. I know plenty of smart people who use sublime. You are not one of them. Also, **i've never even SAID the word PHPStorm** except while mentioning all the ide's. Get your head out of your ass lol. 
You share the shady post with a repo that I can spin up the docker container and match said shady results =P
QQ more pls, I need your tears. You're the one being a baby because I insulted your favorite editor (whichever that is). Seriously, bro, you need a chill pill.
If the function has an ampersand before the variable it is passed by reference. Like do_something(&amp;$var). Otherwise it is passed by value. If a function takes a variable by reference it is designed to modify that variable. Unfortunately you need to depend on your IDE or the PHP documentation to know this. You can use pass by reference in your own functions as well. Just put an ampersand before the variable in the function declaration. 
You haven't insulted any editor, nor my favorite, you just keep vehemently backing up your glorified text editor. 
I agree that there are some really shitty benchmarks being submitted, but there is no reason they should be banned from being submitted to the subreddit. Shitty or not, they are PHP-related. Furthermore, sometimes it is a matter of controversy about whether a benchmark is fully legitimate or not. As long as the content is relevant, it should be allowed on this subreddit, and then it is up to the subscribers to downvote shitty benchmark posts.
Pretty sure that's how it always has been. Every new feature or change requires a separate RFC, even if one relies on another. I would love to see what would happen if that ever occurred though.
Riiiiiiiiiight, that's why you felt the need to insult my intelligence. K bro, cool story. #rekt
If this means I could walk in on day one and my entire toolchain/workflow was already set up and good to go on my workstation AND if it also means that there is a decent size group of developers all using the same setup available to answer questions then it probably wouldn't bother me overly much.
&gt; I would like to put forward that all benchmarks must provide a repo that allows the benchmark to be fully replicated as a docker container or vagrant or something similar. Preach the Word! I was doing benchmarks before Vagrant/Docker came around, so I had to rely on Amazon instances (the closest thing to "standard" boxes that could be used by anyone) and scripted setups. https://github.com/pmjones/php-framework-benchmarks I have since deferred to the guys at TechEmpower and their very good benchmarking comparisons. http://www.techempower.com/benchmarks/ 
As a developer there are a set of tools that I use to make my life easier. If a company said "__Hey, we want to hire you, but that set of tools that you use... We don't like them. Here, use these tools that will make your life miserable!__" It's not worth the aggravation or time it would take to adjust. Just keep looking for a better job, really.
I wasn't there, so I can't comment on the 'laughing at', but "Good project strategy means saying No". http://insideintercom.io/product-strategy-means-saying-no/ 
Very funny. But you seem to have missed this part of my comment: &gt; sometimes it is a matter of controversy about whether a benchmark is fully legitimate or not. Also, are we *really* going to go and tell all blog writers that if they want to post on /r/PHP, they need to release all their source code and machine specs, and then package everything into a Docker box just so some Redditors can check it? If I were the blogger, I'd just move on with my life, or maybe post it to /r/programming, where they don't have such a ridiculous requirement.
good project strategy means KNOWING WHEN to say no. Flat out always saying no, isnt a good thing, and master slave connections is something that piwik couldve heavily benefitted from.
That's not really what he asked, though.
True. Like I said, I wasn't there. But, did he check with them in advance whether a change like this would fit into the project philosophy? 
Didnt know there was a project philosophy for piwik. Didnt seem like it would hurt one though
&gt; Why do some functions actually alter the variable instead of returning a value? Because the variable is passed by reference. Its exactly what he asked.
Many features in Eclipse, Netbeans and phpstorm actually are plugins, too. What's separating a true IDE from a text editor with IDE like features for me, are things like full code analysis and completion, proper refactoring and truly integrated debugging.
Yes, I did see the edit, thanks!
He asked about the reasoning why it was designed that way, not what technical property made it do this.
Right. He's not asking about referencing itself, but why `sort()` was made the way it is. /u/adragons answered it spot on.
You're basing this on the idea that if a benchmark cannot be reproduced then it must not be true. I don't think it's entirely unreasonable to put a little bit of trust in the person running the benchmark. Even if they don't release their exact source code, but instead give a general idea on what they tested, it is still reproducible. The obvious next step would be to require an /r/php moderator to be present while running any benchmark, just to make sure it's legit. Also, that's a bit of an exaggeration. Any worth listening to on /r/programming knows that PHP is an important programming language considering its widespread usage (even despite its flaws).
In my UserSignupCommand I just pass in the form data as an array. You might try something like that.
An important one left out. * You ran the benchmark on a vps running on hardware shared with god knows how many other users.
Yep, this as well!
I think what you want is something like this http://reactphp.org/
If you limit yourself on dumb things like that you only limit your career. 
Nailed.
ITT: Complaints about shitty benchmarks for a shitty language.
I don't think trusting $_COOKIE[session_name()] is a good idea.
&gt; They do more complex tasks and require a framework to speed up their development? They simply don't care about the speed at all? I wouldn't say they "don't care" at all, but you need to understand what you are trading here. You use a framework because it reduces development time and drives behaviors around quality/consistency/maintainability etc. Typically servers are cheap compared to the cost of employing a developer so you trade absolute performance for cheaper maintenance and development costs. For your particular case Laravel might not be the right choice - your clearly need sub 100ms response times so maybe you should be using a solution which is optimized to deliver this rather than a general purpose framework. A number of Laravel's components are available as standalone, so you could just roll them into whatever PHP solution you end up using. As for your problem, are you running Laravel in debug mode? using debugbar? these will slow things down a bit.
I did work for a company that required that I used Zend Studio. In their defense, they did create it.
Use Phalcon. It's a complete MVC framework for PHP written in C. It adds around 5ms overhead (in a VPS!) to my full featured application. I seriously suggest you try it. http://docs.phalconphp.com/en/latest/index.html http://imgur.com/DaJOGQV more benchmarks: http://www.techempower.com/benchmarks/#section=data-r9&amp;hw=peak&amp;test=fortune 
I think it might be because Zend (the company name, not product quality per se) doesn't have a good reputation around here, or most subs. Source: observation. I never used any PHP code from them, besides looking a little at what it does. Just saying. 
We have similar challenges, and the way we do it is by normalizing the data. No matter what format the data is when you feed it into the system, it always comes out written the "standard" way. Normalize both your MLS data, and the queries the users enter, and it's easy to match exactly.
So if CI is dying, what is replacing it? I've looked at Symfony, Laravel, and Zend.. they are all too big/complex for our needs. Any suggestions?
This was among a few different things we used during our (ongoing) migration to PHP 5.5. We ended up writing some other custom scripts to help out as well, but this gets you most of the way there. Our code base has several hundred thousand lines, and we've been working on this since February. It takes a lot of patience, testing, and determination. I helps to have multiple concurrent development and testing environments. E_STRICT is pretty damn useful as well. 
I worked for a company that allowed you to use any IDE. Only catch was that they forced us to maximize code reuse - they made us copy and paste semi-columns from a central text file... Trade offs, I guess...
I've not seen IntelliJ miss a warning. It always shows for me in the bottom console, but either way, the developer should be testing the compiled code, no? Ant/Maven too.... lots of reasons this isn't an IDE issue
Another alternative is to move your session handling functions to database *(table locking may be a factor here too)* or memcache/redis storage.
Yeah that's right, but I'd like to see security bug bounties started by, say, SensioLabs and Zend. Also, huge projects like Cake, Drupal and WordPress could arrange some kind of security bug bounty programs, I'm sure. Heck, I'm even myself thinking to start to offer security bug bounties (something like 20 euros per bug) for my GenPhrase library. Such small scale bounties are nothing compared to those bigger companies can pay, but I'm thinking the "trust factor" and most of all, get more eyes looking at the code (I think even 20 euros bounties, or so, could help with that).
OS is not important for me. If i'm part of a team that use git and/or i can use a virtualized Debian on my workstation for my tests, i can deal with it. 
how often does the data change? if you are in 95% of the time just reading the data, you may want to generate static json files which are just served by a webserver. and generate this static files via your php+redis/db script.
Noob question here, but are benchmark run in Vagrant really meaningful? Doesn't the fact that it's running in a VM affecting performances a lot? (I do get that it's nice to have reproducible environments though)
I guess there are linter plugins for Sublime Text which should help on that. IDEs like PHPStorm comes with really good code inspection functionality out of the box.
Thank you. That sums up nicely my thoughts of reasoning before writing the article. Unfortunately everyone got stuck at my admittedly poor choice of words regarding production, which has been edited since, I'm glad to see there are a couple of people who understand why this tutorial was put together.
Not in itsself, no, that would be silly. But it's a bit of a red flag that I might not like working there, what other "rules" do they have that I might not be aware of...
You would be locking and releasing the lock in this case, right?
me neither.. that is why this is "dirty" code and also why it would be great if this function became part of a future PHP version.
That is an alternative, but does not change anything on the locking strategy. The cost of locking in a database are quite high. I would go for locking in memcache using CAS or redis using NX.
I found some linter plugins for Sublime Text when I used that for project developing and not just as a single file text editor - but I couldn't get them to work very well and eventually switched to the IDE: PHPStorm. PHPStorm does highlight coding issues well, especially when you use docblocks to identify what methods should accept and return and what types variables can be - its certainly useful at design time having the IDE highlight mistakes. PHPStorm also has built in integration with [PHP Code Sniffer](https://github.com/squizlabs/PHP_CodeSniffer) and [PHP Mess Detector](http://phpmd.org/) and possibly for other code analysis tools (although I am unaware of them) HHVM has a really [nice static analysis for its Hack](https://blog.engineyard.com/2014/hhvm-hack-part-5) variety of PHP; it would be nice to see this come to PHP with some IDE integration other than with vim, although it does seem to do similar things to Code Sniffer - design time static analysis is lovely to have. I use [PHPStorm](http://www.jetbrains.com/phpstorm/) day to day and so am quite biased towards it as my IDE of choice, however I am sure other IDE's such as [NetBeans](https://netbeans.org/features/php/) and [Eclipse](http://www.eclipse.org/pdt/) can be just as good and certainly better in someways than using Sublime Text for developing, especially if you are used to using an IDE for programming. For run time debugging I would recommend that you look into the PHP extension [xdebug](http://xdebug.org/); all the IDE's I mentioned above have integration for it and there is a plugin available for sublime text, if you wish to continue using that. It allows you to add break points, watches and profile your code and I would be lost with out it ;) I hope this helps.
 $session_data = file_get_contents(session_save_path().'/sess_'.$_COOKIE[session_name()]); Pretty sure that's insecure, dude. I can do a directory traversal with this. If somewhere along you output $_SESSION, I can make it read everything that PHP has access to (db passwords, for example) Just use memcached or redis instead of doing hacks like these. 
There are many good comments here. I would just like to add a few notes: - Linter (php -lf) only checks syntactical errors. Many IDEs do this automatically. - [PHP Mess Detector](http://phpmd.org/) and [PHP CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer) can catch errors in the code you normally wouldn't notice (unused variables, high complexity...) as well as force some coding standards - They however cannot detect a method called in a wrong way, with missing argument etc., because they only check the code in place - Extra note: Both have horrible documentation if you want to write your own rules, and CodeSniffer doesn't even understand autoloaded namespaces. Ugh. - For checking missing methods or missing arguments, use an IDE that highlights these mistakes, and/or write integration tests And two more controversial notes: - If you're working in a team, don't rely on IDEs to check the code. Instead, use a task runner (eg. [Robo](http://robo.li/), [Bldr](http://bldr.io/) or [Task](https://github.com/taskphp/task), or even Gulp or Grunt (I chose Robo)) and define a task that will watch the source directory and check changed files automatically. Bonus points for clear unified coding standards across the team. - Sublime Text is a text editor, not an IDE. You can use various plugins to add IDE functionality, but IMO you would be better off with a real IDE.
Linter only checks syntax errors, however. It won't detect calling undefined methods, or calls with missing arguments. Edit: What is not to understand about the previous two sentences? PHP linter, as in php -lf, won't check anything else than syntax errors. A linter plugin for Sublime Text won't help the OP.
That and they're using caching. Zend is "fast" with caching. Anything is.
Sublime Text is a text editor, not an IDE. If you want IDE capabilities, use an IDE. A damn good option is PhpStorm. 
Memcache/Redis is good if it's going to be a heavily used API
If anything, providing a bounty sends the message that you're open to responsible disclosure. That alone is worth it, in my opinion. 
wordpress plugin architecture is really really nice judging by the time it was made in, i.e. the core code is kinda bad, but the plugin model still makes nearly anything possible which is kinda impressing based on the fact that it is VERY old. 
But it would be an even playing field right? Since we're trying to compare two or more products to each other, as long as they are all run on the same machine then it should be even. Then there can still be a bias, if one framework requires additional software to run faster, it can be omitted and the results would not be optimal.
turn up your logging way up... display errors... make it strict.
I have written a tool called[ 'Cliche'](http://imakesnowflakes.com/cliche-introduction.html) that does something like this...It is a command line php script that can accept file path, and location of cursor in an editor and use that info to provide completion information to editors as an encoded string. I have written plugins for VIM and included it in the package. It should be easy to make plugins for Sublime... To use it you must have some kind of autoloading. It can infer the class of a variable (using static analysis) from type hints of functions and it can infer type of properties from the type hints in constructors. One it figures the class of the variable, it will provide the method signatures and property list of that object as a completion list. So you can prevent undefined method errors... 
I'm more interested in Laravel packages that think I am awesome.
The author isn't asking about what was the best architecture 10 years ago, however. They're asking about the best architecture now. Based on my experience, I think Drupal definitely isn't the best example, but unfortunately I can't tell you what the best example is. I like Laravel's system of package service providers, but I don't think that will be very helpful to you in figuring out how to architect a plugin/module system. Personally, it seems like the best way to design this would be to rely on events that you can have modules/plugins "hook" into cleanly.
Find an API that offers address validation, such as any of the major shippers (USPS, UPS, Fedex), pay for their API if it costs anything, and use that. That's how I solved address normalization in my app and I'm guessing it's the best way to get consistent and accurate results.
Don't do the CLI listener daemon. That's not how PHP is supposed to run and you're going to experience nothing but headaches once you need to scale. First, I would look at your server configuration. What version of PHP are you running? Do you have APC enabled? Review your php.ini and understand what settings are enabled or disabled. Maybe run xdebug, examine the xdebug profile and see if your code can be optimized at all. If no luck, post on a Laravel-specific forum. If you still can't speed it up, look at bulking up the hardware or migrating to a different framework.
he adressed wordpress, wordpress architecture is from 10 years ago ... it exists "today" so i just wanted to clarify on that.
Depends on what you mean best. I found Magento to be very good in terms of overriding/substituting core classes with my own, and in general about being configurable and malleable. Not to mention adding plugins and whatnot. BUT it's also very complicated.
yep, those cats are on the other side of the wall. And they're all real young, so they eat a boot full of shit every day.
We are currently working on an extension marketplace for [our CMS](http://bolt.cm). In the spirit of preventing NIH and "standing on te shoulders of giants", it'll work as a custom wrapper around composer. Any extension for the system will basically be a composer package. The CMS compiles a custom composer.json file, and subsequently fetches/updates those packages. We're stil working on it, but it'll be pretty awesome. 
PHPStorm has very good static analysis along those lines. Best I've ever seen for PHP
https://cve.mitre.org/cgi-bin/cvekey.cgi?keyword=wordpress
I would advise against running in a VM, *unless* your production is also in a VM. Otherwise what you want is a standardized setup routine that everyone can use, so as to remove the variability between setups.
Here is the thing, benchmarks are a *science*. Science should be reproducible and be open as to how it is done in this context. If all the post says is "I chucked out hello world here are the results" and nothing else, it isn't science. It is someone saying they've done something and throwing it around, but not actually doing the work to back it up. If we can't reproduce it and if it isn't explained to a sufficient extent, then it should get blocked since all it does is waste all the time and energy of every reader. It also spreads some stupid views that somehow X framework is faster than Y in some peoples minds which then leads to a lot of explanation later as to why that is complete crap. For the sake of readers time and energy, people trying to educate others, the people trying to learn, and for the simple fact that if someone is to claim science and not back it up... Ban it. 
I know this is off-topic but why is the entire bolt application in the public directory? The reason I ask is because another symfony-based CMS [pagekit](https://github.com/pagekit/pagekit) does the same thing and I'm just wondering why this decision was made. Shouldn't the public directory only have the front controller and public assets? Isn't there a security concern with having the entire app in the public directory? You have htaccess files to prevent access, but what if someone wants to use nginx? Are the yml setting files protected from access as well?
As dumb as it sounds, I've refused jobs because they use spaces instead of tabs.
&gt; Your host OS shouldn't matter at all as a web developer. Of course it does, there are all the little things that you get used to, which make it a chore to adapt to a different OS. Keyboard shortcuts, dealing with the file manager, etc.
You kept insisting the last time this was posted, give it a rest already. It's absolutely fair to say that Symfony is fast because that's still what drives their app. There's no law that you have to use 100% of the components. Jesus christ.
The problem is prevalent in most frameworks because of their design which has been inherent for many years without much consideration (including me). What it comes down to is not being able to inject a static configuration into a system and that system is not separating its concerns between configuration management and its actual SRP. Any framework or application that requires you to invoke methods prior to dispatching the actual action is dependent on this bootstrap step. E.g Route::add('/', function() { echo 'Hello' }); So in order to minimize the bootstrap step, all the configuration management (including object dependencies) must be resolved prior to deploying the application and the DiC must be able to create services from this static configuration (Factory classes are acceptable here). Closures can be used but then the configuration is not serializable and consequently it is not static; but it does provide a means of rapid prototyping. The other problem is that even if everything is configurable, it doesn't mean that the configuration is actually best suited for the application, typically these configurations are geared to be human friendly (e.g Rapid development) rather than being Application friendly (Run Ready or Stateless), so in most cases the system is still further processing the configuration in order for it be ready for consumption. The reason for preferring a static configuration is because of opcache, at which point this would be the closest you can get to keeping the application's configuration in memory. So in short, imo, its about having better configuration management and dependency injection; and the consuming service should be SOLID. Have you tried consolidating the most commonly used classes into a single file (or a single file with a bunch of include statements) ? I use get_declared_classes to determine the common classes and put them into a single file with include statements. 
There's [pfff](https://github.com/facebook/pfff). It doesn't run in an IDE unfortunately, but it's quite good at static analysis.
Unit tests
But the problem is that this is not a black and white thing. Like I said in another comment, wouldn't it be sufficient to just give a general description of what was tested and some basic specs of the machine it was run on? Generally, that should be enough to reproduce. It is a big jump from saying "your benchmark should be reproducible" to "all benchmarks must include exact machine specs and release all their source code". And it is because of that lack of black and white separation that the question arises: what exactly qualifies as "reproducible"? And to be honest, I'd rather the general /r/php community be answering that question than the moderators.
I like EasyPHP. It is the easiest way to do php development on windows, ie if you are not using a virtual machine. I believe it is portable too...
Sublime is a (really great) text editor. Not an IDE. IDE's are designed to do all those things, and as mentioned, PhpStorm is a great IDE. 
any query builder gives you safe composability of queries. you're working on the level of syntax-tree and both IDE and PHP can check safeness of code. Building complex queries (as in: conditional parts, loops) by hand is an error-prone process. so, I'd say that you don't need query builder if you don't have complex dynamic queries. but if you do, you better use one
Most shared web hosting solutions don't offer non-public directories. I personally admire [CakePHP](https://github.com/cakephp/cakephp)'s handling of this: the web directory is technically app/webroot within the repository, but the .htaccess at the repository root handles if the application was copied straight into a web accessible directory.
It provides an abstraction over plain SQL queries which allows you to substitute the underlying SQL implementation against another one (say postgresql -&gt; oracle). In addition to that, it also helps you to construct safe queries by handling escaping of identifiers and parameter injection under-the-hood. &gt;all I can see is that the zend query takes longer You're micro-optimizing. Whether you use Zend's query builder or not doesn't matter as it makes no noticeable difference to the visitor. You should read this: http://blog.codinghorror.com/the-sad-tragedy-of-micro-optimization-theater/
By using name-spacing, auto-loading and following PSR standards, packages made for Zend Framework 2 can be used for Symfony 2 and vice versa. This is the way to build PHP components moving forward. 
Thanks for the detailed reply. As I understand it, phpstorm uses phpmd, phpcs, and php -l, none of which has the ability to detect undefined functions. I was kinda hoping at least one tool was able to do it, But I guess you can't win 'em all. 
I can't believe this is all the way down. If you write tests, you'll be warned when you run the tests, which should be way before even thinking about deployment. If you employ TDD, you'll be warned with each iteration.
That's called personal preference. It has nothing to do with being a web developer, you'd have those problems no matter what your profession was.
Like /u/Adduc mentioned: We try to provide a tool that's usable for as wide an audience as possible. We know it's less than optimal, but some people just don't have access to folders outside the webroot. Pagekit does this, but also Craft, Wordpress, Joomla, Drupal, Magento, PHPBB and basically every other mainstream PHP project. &gt; Isn't there a security concern with having the entire app in the public directory? Unless the server is set up by drunk monkeys, no. &gt; Are the yml setting files protected from access as well? Yes. see: http://bolt.cm/app/config/config.yml By the way, you currently _can_ move the config folder _outside_ of the webroot. With the upcoming Bolt 2, you'll have more freedom over things like this. 
Thanks for the Bldr shoutout :) can i ask why you chose Robo over bldr or task?
Whole bunch of people saying ST isn't an IDE: http://www.reddit.com/r/PHP/comments/2co68h/is_there_a_tool_for_php_that_catches_designtime/
There is something very wrong with your benchmarks which either implies a problem with the benchmark or the configuration. I've tested both phpng and hhvm extensively and phpng is rarely more than 10% slower on wordpress. Your example with 155ms for HHVM while phpng gets 660ms (after warmup) is just not plausible. Here is a different way of looking at it, requests per second, best average numbers after warmup: wordpress 3.6 front page (default, no plugins) 135/sec with php 5.6 226/sec with phpng 242/sec with hhvm HHVM in this case has a 7% edge over PHPng but they are still not done with optimizations to phpng, many things left on Dmitry's list, he is doing a fantastic job. On the other hand, while HHVM is an amazing effort, they refuse to use the label "beta" on it for some very wrong reason - it is changing every two weeks, sometimes dramatic internal changes that improve or break things. HHVM cannot even turn off file stat (without using authoritative mode which breaks too many programs) and I am not sure its fastcgi implementation is optimal.
I didn't mean that and I have no idea how you got that impression...
https://packagist.org/search/?q=svg https://packagist.org/packages/mld/svg-graph might do what you're after.
Shameless plug for my own project, not really what you want, but I thought I'd share [Lavacharts](http://lavacharts.com) Edit: link 
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 22. [**Confirmation**](https://en.wikipedia.org/wiki/Scientific_method#Confirmation) of article [**Scientific method**](https://en.wikipedia.org/wiki/Scientific%20method): [](#sfw) --- &gt; &gt;Science is a social enterprise, and scientific work tends to be accepted by the scientific community when it has been confirmed. Crucially, experimental and theoretical results must be reproduced by others within the scientific community. Researchers have given their lives for this vision; [Georg Wilhelm Richmann](https://en.wikipedia.org/wiki/Georg_Wilhelm_Richmann) was killed by [ball lightning](https://en.wikipedia.org/wiki/Ball_lightning) (1753) when attempting to replicate the 1752 kite-flying experiment of [Benjamin Franklin](https://en.wikipedia.org/wiki/Benjamin_Franklin). &gt;To protect against bad science and fraudulent data, government research-granting agencies such as the [National Science Foundation](https://en.wikipedia.org/wiki/National_Science_Foundation), and science journals, including *Nature* and *Science*, have a policy that researchers must archive their data and methods so that other researchers can test the data and methods and build on the research that has gone before. [Scientific data archiving](https://en.wikipedia.org/wiki/Scientific_data_archiving) can be done at a number of national archives in the U.S. or in the [World Data Center](https://en.wikipedia.org/wiki/World_Data_Center). &gt; --- ^Interesting: [^Discourse ^on ^the ^Method](https://en.wikipedia.org/wiki/Discourse_on_the_Method) ^| [^Scientific ^Method ^\(Star ^Trek: ^Voyager)](https://en.wikipedia.org/wiki/Scientific_Method_\(Star_Trek:_Voyager\)) ^| [^Outline ^of ^scientific ^method](https://en.wikipedia.org/wiki/Outline_of_scientific_method) ^| [^Morphology ^\(folkloristics)](https://en.wikipedia.org/wiki/Morphology_\(folkloristics\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cjhp22a) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cjhp22a)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
fyi since almost the beginning of the project 6 years ago, we've established the security bug bounty. (Piwik PRO was only established one year ago.) At the start we used donations money to pay for bounties. We have paid out more than 30 bounties over 5+ years. 
when was it? could you point us to the code? maybe we can re-consider if the contrib makes sense (it may happen that we take wrong decisions, though we try to reject contributions only after thinking hard whether it makes sense or not)
What do you mean by debug mode? Debug option is set to true on my dev env/staging, but false on prod. We have debugbar installed but that only works on dev env as usual. We track prod errors using Bugsnag. Yes, but there should be something which lowers the load time of Laravel, just like compiled languages. I mean, serving Laravel inside React/Ratchet would get rid of all booting time (I'm not sure why we can't do this?) and in the end, we would get both speed, maintainability and reduced hardware costs. Opcode caches should also help. (I mean, that's their point, isn't it?)
Cool, but I have my concerns. First, I don't want to duplicate the frameworks we use for my/company's sake. It would take a while until I become proficient on Phalcon and future developers on this company could get trouble learning two frameworks. I'll keep this as a secondary plan. I'll see if I can mix something with the ideas on this topic.
[It's a few years old, but I used this article to learn to do it a while back.](http://devzone.zend.com/1683/creating-scalable-vector-graphs-with-php/)
Get vs.php plugin for visual studio. http://www.vsphp.com/
I'm not a big fan of doing this (I mean, Varnish pretty much does the exact same thing) but yeah, we read the same data alot. Probably way more than 95%.
I wrote the specs on my main post. As I said, we don't have problems in our application layer (so webgrind/xdebug/xhprof doesn't help) so there is no enhancement we can do in our API logic. It is already extremely basic (most of the time it is just this: "Does Redis have X key? Prepare JSON response with that key") and as you can see it usually takes less than 2ms.
&gt; its a bit ridiculous to think the volume of money that the real estate industry brings in, yet their underlying system is such a joke It's also hilarious how small their listing images are. Some are like 350px wide....
Laravel's `php artisan optimize --force` command creates a single compiled.php file.
I don't see why you would specifically need the benchmarker's source code in order to replicate the results. If the problem being tested is described in sufficient detail, you should be able to replicate the benchmark with your own code and still receive the same results.
Right, but "Your host OS shouldn't matter at all as a web developer" made it sound like somehow web developers should be above this sort of thing, which I don't think is true.
Ah I see, that's not what I meant. If I had to rephrase, I'd say "Your host OS should have no effect on web development." I think any developer worth his/her salt should be able to use any OS of course, but what matters is the one you're comfortable in.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
I think its actually more inaccurate to say that a framework is slow because of third party libraries which are not part of the core framework. Yes symfony provides strong support for twig and doctrine orm (a feature not a criticism) but if you are building a web service why would you use a templating engine? The fact that it lets you use what you need instead of forcing a stack on you is a nice benefit of a well designed framework. Other libraries that come with symfony standard edition which you can drop if they dont make sense include * symfony forms: this can be quite slow also and is not necessary for many apps * monolog: logging * swiftmailer: email * assetic: asset pipeline management * translation, validation, security, etc. etc. You dont have to use any of those if they dont make sense for you or if there is another library that does the job better for your purposes. A lot of frameworks these days are just collections of libraries strung together for convenience and this is a great alternative to the monolithic approach a lot of frameworks have taken in the past. 
Oh, my, word. I never thought we'd agree on something. ;)
That is only assuming the benchmark runner is actually being honest in the full config. Also, just the code isn't fully sufficient since there could also be other system configurations done to optimize things in different ways. The only way for an absolute scientific reproduction is: 1) A full config listing of the entire system. (Way more time then most benchmarkers want to go through.) 2) A docker container/VM appliance of the exact setup being run. Even with this provided, most of these "Hello World" benchmarks are still completely irrelevant. No one echos just that in production, so how do you think it is in any way relevant to actual production-level operating?
I stopped using Monster when looking for jobs because they never had a large amount of results. I usually go with Career Builder, or Indeed (which I believe aggregates many different sites) when I'm looking for a new job.
Depends on where you're located of course, but here in the Netherlands it's really hard to find good help these days. If you're a good developer you can pretty much have your pick. Even if you're terrible and lazy you can get a job here, as I've seen several being hired over the last few months. It might be that there simply aren't any people to fill the position. 
Could you imagine the bounties the OpenCart guy would have to pay out?
Hmm, it's an interesting idea but I'm not sure how well the adoption would be. It's difficult enough to get people interested in securing their own code, much less someone else's. I'd love to work with the corporate entities and see if there's any interest there. I'm not sure if they currently have the resources (funding and manpower to admin it) to be able to handle it now, but it could definitely be interesting. I imagine some kind of tracking service would be easiest to implement for this...PHP projects currently offering bounties. Maybe make it interface with the Composer files much like Packagist does to make it as "single click" as possible. Pick the library, describe the bounty, define the price - done. UPDATE: Maybe even an integration with Packagist itself, adding a "submit to --- for security bug bounties" checkbox that hits up an API on the service and adds the project automagically. Just a thought...
That's exactly what it should be doing. What would you like it to do?
I'm registered in Linkedin and I'm getting at least 5 job offers a day. I'm pretty sure there are a lot of jobs and not enough people to fill them. Worth noting that I'm in Poland and I would be suprised if the situation was different in more advanced countries.
None, there are no problems with OpenCart. IT IS WORKING AS INTENDED. DO NOT QUESTION IT.
I would add Dice to that list, which is more geared toward tech jobs. 
Do you mean it's difficult to find good Dutch-speaking developers? I'm just curious because I work as a PHP developer at a start-up in Amsterdam and our entire development team are foreigners (including myself.) *All* of these guys are smart, hard working, some of them contribute to the open source community... a pretty hardcore group. I did not find it particularly easy to get hired anywhere but, then again, my Dutch is very poor and I'm a bit older than most of my colleagues (I know that can be a problem here!) I guess my point is that lots of good, talented people are out there and ready to start writing quality code for any company that will give them a shot (and just because someone might be currently unemployed doesn't mean they're no good, either!) but sometimes companies need to be a bit flexible on certain requirements in order to find them. Obviously I know nothing of your workplace and these are just some general impressions from my own experiences here over the past couple of years.
We're in the SouthEast United States.
I also like the idea that BugCrowd has of "kudos" for the smaller projects that can't really afford anything in the way of compensation. It'd be pretty easy to have that list very visible for each of the projects.
no, the last 4 sets of digits will always be 2 groups of 2, whereas I want the remainder to be their own group of digits.
craigslist is what I always recommend.
I've never been a big fan of todo mvc but one thing I seen from browsing the code in the Laravel app is it's not built in a way that I would recommend. If it gains traction I would have people that are proficient in each framework build it. 
It would be great to get your recommendations. The project is open sourced. Proficient people are welcome to improve applications.
~~If I could get their example android app to run right, I'd be very happy using this SDK to make a web portal for it.~~ [Oops, see lower comment]
Usually when someone says "They can't fill the position" they neglect to add "at the price we want to pay" to the end of the phrase.
Why don't you post the link here? You're trying to hire people, right? What perks do you offer? What does the position pay? Also developers are at a premium now which is why (good) ones are hard to find.
In France, there are lot of full time employment in Symfony2, Zend 2, Magento and other Framework offers. Monster.fr is a very good option but we are called first by Recruitment company (not final client).
An idea about PHP specific platform (based on BugCrowd) was mentioned on Twitter. That would be interesting and I think worth it. A central place for PHP projects which has active bounties (or kudos), and for "bounty hunters" who could collect some extra cash. Of course this needs PHP projects to join in, but having the bounties small enough, I believe quite a few projects could join. Maybe bounties ranging from even a couple of dollars to up, could be enough to catch some attention.
Whilst a monetary award is definitely an incentive, I actually think that most people don't care (unless it's serious money that Google or FB offers) – a name on a list of people that have found security holes is often just as valuable since the people finding holes will likely be looking to expand their resumé.
By "Job Offer" I assume you mean "Recruiter Emails". Those aren't straight up offers, they're stage 1 interviews.
When I was last looking for a job I spent 2 days applying for jobs, the next 8 days taking calls from recruiters getting asked to apply for additional jobs. On the 10th day I attended my second job interview and accepted the job offer shortly after I left the room. I only applied on monster and reed. Our company uses an agency. We get 5+ CVs a week when hiring. Granted a lot aren't great but there is always someone to look at.
I tried monster, stackexchange, CareerBuilder, and craigslist for a month and plastered message boards, email lists, and other frequented sites and in total I ended up with 18 applicants of which only 1 was actually qualified. Used a posting that was similar to others I've seen. Surprising as it is a state position with excellent benefits and decent pay There are times when I really have to wonder how we can only end up with 1 decent applicant when spending so much on a single search. I want to say I think its the majority of actual PHP Developers stick to freelance type of work and don't see the benefit in a full time position at a company. They don't want the hassle of coming into work each day or the meetings or the policies that can come from being in that type of environment.
Look, with the increasing attention on HHVM, PHPNG, etc. There are going to be more and more benchmarks coming around. Lately we've already seen quite a few more than normal. We should deal with these now, so the link-bait stuff can be weeded out from the people that actually care to do things the *right* way. The subreddit should not contribute to sending traffic to blogs that don't care to conduct proper scientific methods with their posts that involve science. &gt;Am I really the only person who thinks it's ridiculous to have to construct a Docker instance just to perform a simple benchmark? If the results of the benchmark are really that sensitive such that a slight change in configuration changes the results, then maybe the results of the benchmark were invalid to begin with. A good benchmark should be reproducible across different machines and configurations. Apparently you are the only one who doesn't care for proper science. We can do our best to reflect other setups, but we can't always hit it. Without having the exact config detailed or an exact server image we can run against, we can only take the test runner at their word that their config is what they say it is. Science is not conducted based on the *words* of people, it is conducted based on the words of numerous people testing the *exact* same approach repeatedly and seeing the same result (in our case, yes there will be *slight* differences.)
I looked through the PR's, and neither him nor I could find the PR, sorry
cast it to a string first and then use substr. $str = (string)123456789 $z = substr($str,-2); $y = substr($str,-4,2); $x = substr($str,0,-4); I did that by looking string functions up in the manual until I found one that suited. No prior knowledge of that function. You could have done the same.
That's a cool idea too...set a budget and only get bothered when someone (securely) submits a bug or the funds are running low. There's lots of potential here, including automatic payments (like through Stripe) when the bug is accepted and even a GitHub integration to link to code locations/files where the bug may be.
Dutch PHP developer here; I've been told both by a friend who's been looking for a PHP developer, and a few recruiters, that there is a LOT of "kaf" in the "koren". Apparently, there are a lot of bad PHP programmers out there, and/or the good ones are staying where they are. I've got a LinkedIn account with about 3 years' worth of PHP experience, and that's enough for me to get a LinkedIn mail and/or connection request every few weeks. My profile specifically states, "please don't contact me as I'm happy where I am" and it isn't stopping them.
I think it's a matter of preference and comfortability. I don't use dreamweaver because I think it's too bloated. However I wouldn't use notepad++ either because I think it's a bit too under-featured. I love using Coda because it does what I need. I know people would scoff at that though...
Where are you located, region wise, or in what city? Are you in the United States, in Europe, Asia?
Arizona in the US
This. I'm tired of hearing about how hard it is to hired developers. Raise what you're willing to pay and you'll see both the quantity and quality of applicants increase.
indeed, dice, stackoverflow careers, linkedin
:), cool
I was simply asking because it's often overlooked.. And, I don't know that there *should be* an option to do what you want... It's not a compiled language. Also React is experimental so I don't know that this is a viable option. The load time really isn't all that terrible really. PHP itself has a rather high boot time. ~100ms on an API request ... unless you have a problem serving it at that speed with high concurrency I don't really see it as a major problem. If it is a major problem Laravel probably isn't the solution to your problem... and PHP might not even be the solution to your problem...I don't know You could also try running the whole thing out of HHVM which may help. And yes, Opcache is helping you. If it is turned on it's doing it's job.
What went wrong with the android example?
&gt; decent pay That's probably your problem. This means different things to different people. IMO if it's not six figures, it's not decent pay for a skilled developer. 
I'd like to know where these supposed jobs are posted as well. Dice and indeed aren't working for me. I got laid off months ago and haven't found anyone hiring - and that's with the magic "devops" and "magento" flags on my resume. 
where is this?
Correct, it would require that you write your application in a different way. Since the PHP process would never die you would have to deal with memory leaks and clean up after something is done. Compared to how your app is now each web request spins up and destroys a PHP process.
Another tip I don't see mentioned here: Include a salary range in your job post, even if it's broad and includes a DOE next to it. If I'm looking at job posts and have no idea what you're willing to pay I'm not going to risk wasting my time.
Sigh.
Depends on your contacts. Opportunities comes to me most of the time via non stop recruiter emails. Maybe you should hire a respectable recruiter. 
ditto most of what you said. Dice and Indeed were my two go-to boards. In my last job search I didn't even look at the others. For tech jobs [not sure about other industries], Monster I think is the worst of the big boards.
I found my current PHP job from an ad on Kijiji. Probably not the best place though.
Same here. Dutch php developer as well. Got tons of emails on my LinkedIn account with job offers. It became so terrible they even started calling me at work (didn't have any phone numbers listed). As a result I killed off my LinkedIn account altogether. But in general in the Netherlands there are lots of php jobs available and not enough quality programmers. 
I got my current job off of LinkedIn. I like it because it lets you see who is looking at your profile and you can see a lot of detailed information about the companies right there.
Hi, congratulations for a great project. I made the decision based on documentation, activity and in-built tasks. In the end Robo won because it supports inotify in the watch task. Good luck with Bldr!
I must say that I love you. There is so much love towards anyone that puts screenshots in their github info. A big thanks to you and people like you. 
I'm just being fussy, but it seems a little silly to namespace the code Parse and then prefix every class with Parse. `Parse\ParseQuery` vs `Parse\Query`.
&gt; Monster.com [...] PHP developer. This really made me laugh. I would hope that a developer would be smart enough to know that a web service like monster also sells your personal information to advertising agencies. Which is most likely why you're not getting any interest.
Thank you, very good! I overlooked that.. updated the post..
&gt; IMO if it's not six figures, it's not decent pay for a skilled developer. That's totally location (cost of living) dependent, of course. Six figures in my area would be *absurdly* good pay for a skilled developer.
But then you have to add additional logic with an impact on performance that has no purpose than to make a line of code slightly shorter.
Incorrect. php storm does both of those things. 
Man, Dicethrowers comment had me all happy thinking I could move to Europe and find work. Then your comment came and pretty much put an end to that.
PhpStorm detects undefined functions/methods for me. Does it not work for you? 
&gt; it is conducted based on the words of numerous people testing the exact same approach repeatedly and seeing the same result (in our case, yes there will be slight differences.) This is not entirely true. While the reproducibility of scientific experiments is important, testing the *exact* same approach on the *exact* same hardware and configuration will not get you any further in proving whatever hypothesis you are proposing. To the contrary, it is only when numerous people take the same approach using *different* configurations and *different* hardware does the hypothesis get stronger, because then you begin eliminating other variables as causes of the results. As an example, if somebody does an HHVM v. PHP benchmark for something like the crypt() function, and it shows HHVM is faster, and then somebody tries it on a different OS and the results are flip-flopped, then maybe it's not necessarily HHVM v. PHP that is causing the results.
Well, to be honest, I was lucky to get the job I have now given my experience. I didn't follow a straight line career path as a developer. For years I did a lot of support (light systems administration + Perl, shell scripting etc) and systems integration before moving on to proper development roles in recent years. Someone with several solid years of experience doing development at an actual company (as opposed to on and off freelancing for small websites) should have an easier time of it than I did. BUT... you're talking about moving to Europe and that's an entirely different story. I already had an EU passport before coming to the Netherlands so I didn't have to find a company to sponsor me or anything. If you're serious, have a look at expatica.com and also any subreddits specific to the region you're interested in.
Hahahahahahahahahaha, god, I think this is the saddest thing I've ever seen. This is really hard for you to get over, isn't it? If I lived my life by the word of random people on the internet, I'd probably be a lot like you, and put nicely, that's not someone I'd like to be ;). I've been using ST since it came out, you're not going to change my mind, but I'm flattered that I managed to rustle your jimmies so much.
That sounds about the same as in the US tbh. I think it's just a trait of PHP in general. 
Yup. This.
Have you considered using another programming language? Python/NLTK can do this, although I had to train the POS tagger using previously tagged corpus. What you are looking for in any case is POS (Part-of-speech) tagging. Parsing involves a whole lot more.
Other people. Community ftw.
Ninja level in PHP. Must have 10+ years experience with Angular. 80 hour weeks common. $35,000/year... salaried.
Usually they just grumble around online until they find a nice forum they can employ themselves with by complaining about how much PHP sucks.
I meant more of a "here's what our link looks like, please critique it" sort of thing. Should've been more clear.