Doesn't work if no one signs up.
with Zombo.com
You're asking how to do something in a browser, and php doesn't run in a browser.... so you'll want to look at some client-side technologies, like webrtc. Maybe /r/WebRTC would be a better place to ask.
Wow... Dojo is on your list of things you won't use as a primary tool/platform? Why?
Ya'll need to get a non default WordPress theme (from 2010) for your blog. ;)
Normally I'd agree with you, but: &gt; Just need Taylor to build Laravel.js and save us from the madness of half-baked UI libraries This is some next level of confusion here. This guy has crossed the line from which there is no return. The least we can do is make fun of him, before he infects even more people with this kind of stupid. I don't know if you watch Walking Dead, but if you did you'd know my logic is rock solid here.
We had in a massage therapist two weeks ago. I believe GitHub has one in fairly regularly. 
http://hnhiring.me/
I'm trying to work out the pricing model of PPH. Does it take a cut of earnings, like Upwork? (Just had a browse of the available projects - Lordy, it's a mess. Hopelessly unrealistic budgets coupled with woefully inadequate specifications.) 
*alot*
* 100% telecommute for 40% paycut reduction: $200,000 -&gt; $120,000. * 50% telecommute for 25% paycut reduction: $200,000 -&gt; $150,000 * No telecommute: $75-85/hour at Corp-2-Corp rate. My own corporation matches my 401k contributions by 25% salary. So I contribute the max: $17,500 and my corporation matches that by, say, $32,000 if the rate is $85/hour. Then, once a year, I take out a loan of up to $50,000 per 401(k) account. Of course, I reach $100,000 on 401(k)s about every 3 years, but my tax guy showed me that the loan restriction is per account, so I just have multiple accounts. I then have $50,000/account to play around with in more profitable investment ventures. 100% of those profits go into Roth IRAs, usually. So I could already basically retire at age 33. Since I only do Roth 401(k) and Roth IRA, self-manage my portfolio (I am a stock and options wiz), none of my dividends or future sales are taxed. I can also (although I never have), pull out my own personal contributions without having to pay tax, just the penalty. This is how you get rich, guys [in addition to leasing out your owned real estate, owning a corporation and owning dividends and other money-generating assets], but, of course, I thoroughly studied how the rich get wealthy and how currency works, how markets operate, etc., and vanishingly few people, especially my colleagues at dev shops, ever bother.
It's a tax write off. Any company not willing to do this is really stupid. 
Hi azidblazer, I hoped to address these sorts of questions with my comment above. &gt; ### Will you audit an obscure library for me for free? &gt; &gt; No. That wouldn't be fair to Paragon Initiative's clients. The invitation I'm offering is limited to StackOverflow questions. Code auditing a library on Github is a [professional service my employer offers to companies](https://paragonie.com/service/code-review) that falls outside the scope of what I'm trying to do here. I can't really justify charging them a consultant rate if I open the door to doing the same work for free to anyone that asks. :) However, I did take a quick look and discovered that you were [escaping input](https://github.com/HumanWorks/phpUserClass/blob/master/access.class.php#L257-L271). I'd like to encourage you to take some time to learn [the correct way to prevent SQL injection in PHP](https://paragonie.com/blog/2015/05/preventing-sql-injection-in-php-applications-easy-and-definitive-guide). (Hint: It doesn't involve escaping anything, but you still need to perform validation.) Also, [this is a poor way to generate random passwords](https://github.com/HumanWorks/phpUserClass/blob/master/access.class.php#L280). We just published a blog post the other day about [random string/password generation in PHP](https://paragonie.com/blog/2015/07/how-safely-generate-random-strings-and-integers-in-php). Don't use SHA256 for passwords. [Learn how to do it right](http://stackoverflow.com/a/401684/2224584). I highly recommend subscribing to the [Securing PHP mailing list](http://www.securingphp.com). It's run by /u/enygma and sends an email once per week (on average). You'll learn a lot about application security best practices, and Chris is a good writer to boot.
Awesome, thank you. I actually found the library via /r/php and noticed a couple of issues. I remembered your post and hoped for this explanation.
Better than calling it Moist. ;)
How so? Don't you see that each test is annotated to test a specific set of method. There are @covers tags before every test
I guy at my work used to leave messages like... &gt;* . &gt;* . &gt;* . &gt;* changes &gt;* another fix &gt;* fix ...stern discipline was applied
How about multithreading? Afaik its not possible, keeping php out from high concurrenct apps. Unicode support is still lacking. 
There is! And it's right next to the people who use "thiers" when they mean "there is" or "there's". I'm only joking of course, but your post title niggles me more than it should.
I have several of these and they just wont listen, im quite sure their just doing it to annoy me at this point.
You can already do this, but you lose out on the isset check. It's great for logic in models and what have you, but bad for input validation. A lot of existing code would break if the semantics of || were changed. 
Hmmm wonder how long till rhel gets it. I guess sometime around 2020. 
Although this is partially true, a properly configured DB shouldn't be the bottleneck for a Wordpress application until you start scaling into large numbers of posts/users/comments.
People ask me why I use Gentoo on a production server. I tell them this.
Fantastic...
Nearly as frustrating as folks who use "im" for "I'm" and "their" for "they're". At least there's no-one in this sub that'd do that. Imagine the toasty place in Hades we'd have to reserve for people who write like that _in commit messages_. `/runs off` 
Wouldn't you get a warning if $b were to be undefined? I guess the ?? operator is special in that regard.
PHP still benefits from the multi-threading of the web server in front of it, or from something like FPM. You can handle many simultaneous requests.
Yep! If the company you're looking to work for doesn't provide you any good materials, this proves they don't really want you to perform, my 2 cents.
What niggles me is when people use "thiers" when there correcting somebody for the misuse of "theirs". 
Almost as bad as when theyre using "there" when their obviously trying to use "thei'r"
It's special.
The version number is a bit of a misnomer, as they backport the sec patches into that version (hence release 36). I would wager this is most likely to be the most recent version of 5.4 patch wise. But again, if you want newer than 5.4, choose a decent custom repo.
&gt; when there correcting Trying to work out if you did that one deliberately. 
ITT People that can't spell
So what you have annotated your tests when test runner doesn't do checks for unintentionally covered code? Right now it's including into coverage report every possible piece of code that your tests might have bubble to without your permission or knowledge.
Came here for the grammar correction - was not disappointed.
IUS is an awesome repo. I have run binaries from them for years in a 24/7 ad server type scenario where millions of impressions are daily. +1 for them.
I see what you did they're
Jeje, I'm starting this days one of those only for learning purposes but in Yii2, not a big fan of laravel myself (also don't want to start a discussion about sega/nintendo php frameworks right now, don't take it wrong, just only giving my oppinion), it's very cool, I'm reading the documentation right now, very detailed; I think that you are also using adminlte as frontend design?
.
Totally expected that Brad would do it, but Mike too? That breaks my heart.
Good point. I honestly hadn't thought about it that way.
Yeah we are
Giggle. I like this alot! 
Wordpress by itself is not that bad, even with a ton of posts. But add some badly written yet popular SEO plugin and tag clouds and what not and you can reach 100+ queries of varied complexity to display the home page for a bonus of 2-3 seconds (or 10-20 seconds on godaddy) more load time.
Sometimes this happens because you've got a "keep changing things until it works" developer who--for whatever reason--cannot test the feature purely in their VM, so it spills over, as they do their test/tweak loop in a shared-dev environment.
Mike and Brad are bad bastards!
Sounds too complex tbh. Just work in a branch (committing as usual), then do a --squash merge onto master. No fussing with rewriting history, and master stays clean with one commit is one idea. 
PHP code is complex enough that it really matters how fast PHP can dish output. Which do you think is faster: 1. MySQL serving a few cached queries from RAM. 2. PHP loading 60 classes and running a gigantic bootstrap on every request. I intentionally did say "loading 60 classes" and not "parsing 60 files of PHP", I do assume opcache is present. It's still work.
this, but added 1.1, 1.2, 1.3 for each subsequent commit after the first one
For every apostrophe I need to switch my keyboard layout on my phone. No thanks I will stick to 'Im, theyre, youve' etc as you will easily understand it anyways. Greetings from hell.
We need to go deeper
For my dev team, I set up a git hook that would reject the commit if there was no message, or the message was too short (single words, 15 char..)
They should tie you to a fiery chair and read you the current minutes of the [Apostrophe Protection Society](https://en.wikipedia.org/wiki/Apostrophe_Protection_Society) on a tape loop. 
Is there any way to go back and edit the commit message? 
OK fair enough. Still seems like an edge case... and it's only shorthand for `&gt;=1.2 &lt;2.0` which is arguably easier to understand.
Although a large part of the slowness of using mysql is in the socket/connection to the db and the latency and overhead involved, regardless of where the query results come from.
Not without reverting and re-commiting
~1.2 is also easy to understand. It means "compatible with 1.2". 1.2.0 is compatible with 1.2. 1.2.3 is compatible with 1.2. 1.3.4 is compatible with 1.2. 1.8.9 is compatible with 1.2. 2.0.0 is not. 1.1.0 is also not. This is why semver is useful, because "compatible with 1.2" is a very specific and very commonly used version range. In terms of real world usage you are using three patterns in semver: X.Y.Z - When your usage is highly specific, highly reliant on undocumented features, or in a highly sensitive project. X.Y.* - Typical for production use of larger projects. ~X.Y - Typical for smaller projects (most of projects) and prototypes. If you think about it, anything else would be odd or rare. So it helps to have common cases be short.
I like this idea but how do they edit it once its in their local version?
I'd personally be more worried about the foreach changes when dealing with references and determining positions than with the uniform variable syntax changes. Anything that changes based on the variable syntax will be way more obvious than some of the old broken foreach magic changing. 
I agree with what you said, although it doesn't seem to contradict what I said or implied? Sockets are slower than compiled vm code, generally speaking.
&gt; Sockets are slower than compiled vm code, generally speaking. Thing is... that statement is nonsense. Socket IO adds lag to a given request, but doesn't generally reduce throughput (your requests per second). The bottleneck for a VM is, in a nutshell, the CPU, and sockets don't compete for CPU with your VM, so talking about which is "slower" is silly. In other words, if you get 1000 request per seconds, and have sufficient concurrency, I can put sleep(1) in your code and you'd still get 1000 rps.
If you were looking for something to let you know but still default to "default" i'd just do this. $a = $b ?? "default"; if ( !$b ) { log("something"); }
 $a = true; $b = $a || false; echo $b; &gt;Output: 1
Bummer. That would be fairly handy
Well you are making it into a silly discussion. We are still talking about PHP and MySQL here right? Getting data from MySQL does require CPU time, transfer time, ram access, converting from MySQL data structures to PHP ones, etc. Even with a single query, this is slower than vm code.
We had issues with this. I became the "git master" and forced them to check with me before committing code. After about a week, everyone was so tired of me looking over their shoulder every time they did a commit and finally started doing it correctly. 
No, you are wrong, the annotations limit what gets included in the report. Try it yourself, clone any PHPixie library ( phpixie/slice is the smallest one), run composer update and then run a single test: php phpunit.phar --filter="SomeTest::youLike()" --coverage-html=/some/folder and you will see that the coverage includes only the result from the functions mentioned in @covers In fact I doubt you will be able to find a test that "bubbles to" somewhere outside the tested class, since I mock ALL of the dependencies. 
omg I'd lose my shit...
I'd say: **3 weeks after start date** * can implement simple components * understands infrastructure **8 weeks after start date** * deep understanding of product * able to work on features mostly alone
You people are worse than grammar snobs. I'm not allowed to use TrackerCodes and have to write a stupid tweet about every f*ing bugfix!
wheir?
Thank you for the link. I've been browsing around, but unfortunately they don't offer the data we need (postal code patterns to match to specific country subdivisions) :(
RoR and Django are both frameworks, so it's not a true equivalence in your comparison. Ruby and Python are the base languages, and neither of them were written directly for the web. Conversely, PHP's raison d'être is entirely geared toward the web. That's not to say that Ruby and Python aren't usable for the web - they're just as worthy for backing websites as C or Java, for example - it just means that you absolutely have to bring in a framework to ease the burden of HTTP. One shouldn't discount the possibility of Javascript/NodeJS, but speaking as someone who learned to program in C++/PHP, working with prototypal inheritance is a bit of a brainf***. A more fair comparison in terms of web technology would be ZF2/SF2/Laravel vs Django vs Rails vs ExpressJS. To one degree or another, each of these frameworks tries to do as much as it can to chauffeur the creation of web applications. This often means a lot of generated code and in some cases a lot of headaches. My personal preference (after using ZF2, SF2, and Rails) is SF2. However, I also like working with microframeworks. Being able to pull in only the components you need can result in applications that are much faster than full-stack framework apps. My personal preference there is Silex, but there are other microframeworks that benchmark better than it. Overall, PHP has a slight advantage in that it can speak HTTP (and CGI) natively in a helpful way. You're probably still going to want a framework, but they tend to be big and slow regardless of the language (unless you go with a microframework or avoid them altogether). When choosing a web technology such as a framework, you also have to pay consideration to the other people who will be working on the project. You have to make sure the technologies you work with are well-documented and well-tested. Having a corporate support organization backing them is also a big plus, if you're working for a company. Also, if you're part of a larger team, having a full-stack framework has more appeal because it means everyone can standardize on the same workflows and practices. In terms of syntax, Python and Ruby do tend to be more concise. That concision can be a drawback, though, when too much magic gets involved. Also, there's the matter of familiarity. Coming from C, which would you prefer: (0..5).each do |i| puts "Value is #{i}" end vs. for ($i = 0; $i &lt;= 5; $i++) { printf("Value is %d\n", $i); }
Not in europe.
I have several times now. Im the one that manages deployments and sometimes make it through what little QA we have so i have to roll back until the bugs are fixed trying to figure out if i need to roll back to "" or "" or "" not fun.
Just add a pre commit hook that requires a comment. You could even go so far and only allow the same comment x times and require a minimum comment length.
You can get a job; really easily. 
The Jetbrains IDE's are also excellent for day-to-day by the way.
I'm not an expert but basically, you have to provide help and training you cant just fire someone if they dont write good commits messages. If they are categorically just ignoring what you ask them to do then yes you can fire them but you have to be able to show you tried to teach them. But it obviously changes based on what they did writing crap code is different to lying about how good they are at writing code in an interview then it turning out they have no clue. In Europe we don't seem to have the same "fire" culture that you do in the US your not constantly under threat of losing your job if you make a mistake.
I might force every commit message to have the words "from" and "to" in it.
I'm a big fan of them too!
You just needed return (string)$this-&gt;number; On the final else. &lt;?php class FizzBuzz { public function __construct($number) { $this-&gt;number = $number; } public function __toString() { if ($this-&gt;number % 3 == 0 &amp;&amp; $this-&gt;number % 5 == 0) { return 'FizzBuzz'; } elseif ( $this-&gt;number % 3 == 0 ) { return 'Fizz'; } elseif ( $this-&gt;number % 5 == 0 ) { return 'Buzz'; } else { return (string)$this-&gt;number; } } } Or you needed: $this-&gt;assertEquals('1', (int) $fizzbuzz); $this-&gt;assertEquals('101', (int) $fizzbuzz); Depending on what they provided. Did they provide the Test and said make the class, or the class and make the Test? Given, you're using the __toString(), it more likely they gave you the Test Class and had to write the FizzBuzz class, right? Anyway, the output from phpunit was enough to clue in pretty quickly: 1) FizzBuzzTest::testInputOne Method FizzBuzz::__toString() must return a string value 2) FizzBuzzTest::testInputOneHundredAndOne Method FizzBuzz::__toString() must return a string value This is one of those gotcha's in PHP, automatic casting, and looks like that's probably what they wanted to see if you knew about. Although in this case nothing is being automatically casted, but the princple loosely applies.
For everyone complaining...notice how Brad had it to Feb and Mike is only touching it now in Aug? This is a single maintainer repo. Yeah, that will happen. when you are the only one touching the code. 
 from to
Agreed on all counts :)
What would you recommend instead of `strlen()` and `substr()`? Using `mb_substr()` would introduce a dependency on mbstring where none existed before so idk that that's a good solution. Really, I think PHP was stupid to overload string functions. It is as bad as register_globals and all the other things that have been deprecated in PHP 5.3 and 5.4.
That's for the last commit only
My manager does this...FFS
Time to find a new job.
If you do an [interactive rebase](https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History) you can edit the commits freely (including the commit messages). However, since this is rewriting history, the hashes of the commits will change. You have to force push them to the remote (if they had already been pushed before editing) and other developers will have to take special action to move to the new head (since it forms a distinct chain of commits to the one they're tracking). 
I invested in a good mouse keyboard and mouse mat for work a while back when i move from company it goes with me then i never have to wait for them to sort it and i get exactly what i want.
We used to use a self hosted svn (this is why their are no branches) and mantis bug tracker we have now moved to BitBucket git my next goal is to get them to use the built in issue tracker as that basically solves the issues.
Since PHP was designed as a template engine its much easier to get simple, dynamic sites up and running with no framework at all. On most servers just take any .html page, change the extension to .php, and start mixing in php code. The same is not true for Python where anything you want to do web-related is going to require implementing a template engine of some kind and a bunch of other packages to get the same results - which inevitably sends you into the arms of Django, Flask, or Pyramid. Python has mod_python which acts a lot like mod_php does with Apache, but that approach has been largely abandoned in favor of WSGI. So now if you want to write web apps in Python you have to write a WSGI-compatible application that can handle your requests and output a response that a server like Apache can use, or you implement your own server, again pushing you towards using something like Django so you aren't writing everything from scratch. Now there's nothing necessarily wrong with this approach, but compared to PHP its just more complicated. Depending on the size and complexity of the applications you want to build, you're probably looking at using a framework either way. My opinion is that PHP will make things much easier on you in the short-term. 
That's not a great commit message either, but that's just me. I try to have a short descriptive message as the first line (under 70 chars, I think?), second line blank, then third line onwards is a detailed message that explains why the fix was made. And if necessary, more in depth and/or low-level info on the actual fix. I don't know about other editors, but a base vim install will guide you through this via colored text hinting. That all said, few devs have the luxury of being that descriptive with something as inconsequential as commit messages. 
To each their own. I enjoy it. Developers seem to be the only people that don't like it and it's usually for academic reasons (aka: not OO/modern/inconsistent). It runs great, easy for end users to use, and has a silly amount of customization. Even as a programmer I can't deny how quickly I can get something up and running.
Please be more civil. We don't allow personal attacks here.
If you were making a site like facebook would you use PHP or something else?
There should be a special place in the unemployment line for them.
I'd stay with PHP. I work in the advertising space and I've seen sites built in everything (RoR,PHP,Django,ColdFusion,Java,DNN) you name it. Dev time on PHP is almost always the fastest and cheapest of the lot, we can deploy damn-near anywhere, and if you handle object and database caching right, the sites are almost unsinkable.
Depending on your background, this is unintentionally hilarious. It isn't a part of reddit culture, but "message containing a single period" is [a way of indicating a somber moment of silence in some online communities](http://mefiwiki.com/wiki/The_Period).
super interesting. so why do you think people use all those frameworks? just the easier learning curves?
http://imgur.com/2XzBsrT
There are some real serious health issues associated with this. Fifteen years ago I though it will change with time, it didn't.
Generally speaking, whenever a chain in a thread gets out of hand, I just nuke everything from the start of when people started to get uncivil. This is to prevent anyone from continuing the bad behaviour by replying to any of those comments. It's worked well so far. If you do take issue with that approach, feel free to send a modmail. It's not a policy that's set in stone. It's just been effective for dealing with these situations, and nobody's complained yet. :)
yeh ... pre commit hooks for the win, regardless of whether its svn or git :) on some projects we have regular expression checking for a linked jira task ... if its not there, its not committed
&gt; On most servers just take any .html page, change the extension to .php, and start mixing in php code. Yeah, you can but don't. That's not the way that modern PHP applications are made. You need to use proper architecture if you want to build a decent application in any language. Mixing business logic into views is a great way to end up with a mess. 
Ya'll motherfuckers need some change management.
I use Capistrano for deploying my PHP applications. Works great.
really appreciate this insight. is there anything you'd recommend reading that would help prevent me from making the same mistake as FB? 
If people are this lazy, at least ask them to type the issue#. Something like Fix JIRA#101. At least you can still make some sense by linking and looking it up in the bug tracker software.
No love for Tower?
For not writing commit messages properly? Are you web developer for the People's Republic Army?
Get back to me when you inherit a landing page that runs 1800 queries. This is my hell..
It varies between then public and private sectors. The private sector behaves more or less as you would expect - you screw up, your job is on the line. The public sector is different. Firing people a very long bureaucratic processes with extremely slow pace. The result of this is that an underperforming or even negligent employee may take many months to terminate. An example from an unnamed source in an unnamed public sector organisation: two employees live together (a couple). One arrives on time, the other consistently arrives late because of traffic problems. He was terminated over a year later.
Read about the Netflix architecture, why it's so resilient and how they test it (chaos monkey). Read about the memo Jeff Bezos sent to all employees that all communication should happen through service APIs: http://jesusgilhernandez.com/2012/10/18/jeff-bezos-mandate-amazon-and-web-services/ Read about Thrift and why Facebook came up with it. In general, read about best practices in creating service oriented architectures aka "microservices" (stay away from: people who claim service orientation requires heavy middleware and verbose protocols like SOAP; also stay away from crazy people who say a microservice is up to 100 lines of code or other such nonsense). If you have time, read about the Actor model and how Erlang works (Erlang processes = actors) and how it's used to coordinate operation between services written in other languages in a distributed environment.
 foreach (range(0, 5) as $i) { echo "Value is ", $i, PHP_EOL; }
Oh my god, "the needful" was something that I only ever saw offshore folks write. Where did it come from?!
Its a lot... Its not alot
Which is exactly why many people's personal utility function files include something along the lines of function isset_default(&amp;$var, $default = null) { if (!isset($var)) { return $default; } return $var; } 
I like the war elephants, but PHP7 is making such a leap that perhaps the new elePHPant should be the [Ancient Psychic Tandem War Elephant](http://adventuretime.wikia.com/wiki/Ancient_Psychic_Tandem_War_Elephant?file=Ancient_Psychic_Tandem_War_Elephant.png). 
Comments in the code is not the place to put names, dates, and changes. That goes into the commits. With the information in the commit, you get a clean and permanent record of who did what and when. The versioning comments in the code pile up on one another and get in the way of reading and understanding the code. Explanations of the code itself should be in the code as comments, but only after you've done your best to make the code as self-documenting as possible. There's another special place for people who do this with their variables: $blnR = 'Y'; It's an extreme example, but I've seen each of the three sins embedded in that tiny line far too many times. Edit: Forgot to mention this, but if there are too many things happening in a single commit to have it all explained, then you're doing too few commits and probably trying to force too much information into the commit message. The commit message should just say what the commit _is_. No detailed elaboration need or should be given. The diffs on the commit tell you what the change was. You just need to be able to look at a list of commits and know the point of each one as you scroll through.
I agree, it depends on the product and how its written. If it's a single app with on a common framework with a half dozen open source components, sure that's not a huge deal. I'm 3 weeks into a new application that spans 4 languages, 5 different ways of distributing or queueing up work, 4 different kinds of web servers, wrappers that wrap wrappers for wrapping wrappers, dependency managers that provision other dependency managers... It's gonna be a long road.
I remember an anecdote when a dev lost a company 100k. His boss was asked if the dev would be fired and he replied 'Of course not, we just paid 100k to train them'. 
I'd say it all depends on how much process is followed within your codebase, how idiomatic the code-base &amp; problem solving approach is. Are there a lot of one-off scripts, is the application very problem-domain specific. How much peer to peer coding you do alongside this person as well. If you or someone else mentors this person in the codebase, build a decent sized feature, something new, and allow them to tag along throughout the process. If your codebase on the other hand is 9-10yrs old w/ lots of legacy style written php, we are talking years, I know this from experience. Globals are not your friend.
Its a remnant of the [british rule in India](https://en.wikipedia.org/wiki/Do_the_needful).
Surely it depends on whether spelling mistakes [are part of the joke](http://hyperboleandahalf.blogspot.co.uk/2010/04/alot-is-better-than-you-at-everything.html)? `:-)` 
If you're the author of this article, you can remove the function in the snippets since it's not used. Otherwise it will only confuse the readers. 
It's useful to push daily to a branch, so that if the developer has their laptop stolen or suffers a disk crash, only a small amount of work will be lost. This sounds like a serious business risk that needs addressing. 
**3 weeks after start date** * doesn't complain * doesn't sexually harass co-workers **8 weeks after start date** * hasn't quit yet * has at least one fuck to give
Where commits message you!
Its such a tricky question without knowing what you eventually want to be. I am going to guess based on your "if you were going to create reddit from scratch what would you use" question that you want to move into full-stack web-development and not just code back-end APIs or embedded device code. To be a full-stack developer i would definitely learn PHP first, but with some caveats. The world of web development for larger systems is slowly changing and so is the role of PHP. Soon, the entire front-end will he html,css,javascript using AJAX calls to talk to back-end REST APIs. So PHP will not be used to output html any more - it will be used purely to implement the back-end APIs and business logic, back-end processing, database, persistent storage etc. Some thoughts on what to learn: - learn the basics of PHP 5.3+ including the OOP model - learn a light PHP framework (Silex, Slim) for API work - how to consume and output JSON in php - how to implement a REST interface and pros/cons (look online for examples) - how to integrate back-end libraries and external interfaces (how to use curl, how to process credit cards, how to load data (files, http, etc.) - learn the database interface using PDO (understand pros/cons of pooled connections and scaling isues with how we write data to the db and why we need a write Q for large apps) - understand memcache and the difference using mysql vs postgres vs Oracle (its all very similar) - understand issues and workarounds with sessions - understand how to scale apps using replicated slave databases, clusters, load balancers, multiple http servers etc. maybe using container or VMs - understand composer, test driven development, continuous integration Theres a bit more than just PHP there, but I dont see when you will have time to learn Python for a while. After you have the PHP back-end down you will still need to learn the front-end stack (html, css, javascript, js framework/plugins like jquery, angular, test tools like jsunit, gulp and grunt, sass or less, how to minify your JS and http calls etc.) To answer how i would implement Reddit, I would create a single page app in html/js calling a PHP API back-end which did all database/business functions. Its all very simple when you have learned all the stuff listed above. 
Most of us have moved on from the shared hosting nightmares of the past, and actually control our boxes.
That's fine, as long as you realize that the message you are sending to the reader/receiver is "My time is more valuable than yours".
I [tried arguing this](https://www.reddit.com/r/programming/comments/3blpyj/solid_a_minimalist_interpreted_language_with_a/csntkzx?context=3) on /r/programming once. It's my 3rd most controversial comment and I've debated a lot of controversial topics. 
This is surprisingly on-point. Other than categorically doing nothing (not even making an attempt), the first few weeks are a culture test as much as anything else. So much of this depends on the company though so it's hard to answer. Expectations will be really different in an early stage startup than an established or public company. Everywhere will have its own different set of requirements. And I wouldn't even expect PHP knowledge on day 1 necessarily. I've hired senior people with other OOP backgrounds (typically Java) with the expectation that they could learn the new language quickly. Been in the same position myself (contract rails gig). It's never been a real issue. 
You should be able to look at the commit history and find the bit change you need to look at without having to look at the code.
There's a lot of good advice in this response. However, the one part I'd ask you to clarify a bit more is this statement: &gt;To answer how i would implement Reddit, I would create a single page app in html/js calling a PHP API back-end which did all database/business functions. The problem, as I see it, with the single page app approach for a site like Reddit – which relies on search engines to bring in a decent amount of its traffic – is that you can only create "real" URLs (ones that don't use hash tags) for users who are viewing your site with latest-generation browsers that support the HTML5 history API. And, of course, you'll be creating those non-hashtag URLs with javascript, so you run the risk of many search indexing bots not working well with your site. So, unless I'm missing something, you'll have to create an entire parallel architecture on the server side to filter requests from search engine bots and users that don't have the latest browsers, processing them on an entirely different backend to generate the requested pages on the server instead of the client. I'm not saying this can't be done. But it's a non-trivial detail you can't leave out if you want your site to benefit from search engine-generated traffic. Or am I missing something?
You don't have to use a framework to make webservices with Python (and I'm sure the same with Ruby, but I have zero experience with it). [Here's a post from Armin](http://lucumr.pocoo.org/2007/5/21/getting-started-with-wsgi/) where he explores implementing WSGI with nothing outside the stdlib. However, even a bare WSGI framework like werkzeug makes life so much easier. The same can be said about PHP, though. You don't *need* a framework, but it makes your life easier.
how does it not? please explain yourself. if you control the box, you can decide what services are running and what are not. I certainly don't run cpanel. I run bare metal. I have a much smaller attack service by doing it this way. then you decide what level of control you have for selinux and iptables. you can even go so far as to have another box to test OS updates before then patching the production boxes. In short, you have many many more options running your own boxes then shared ones.
When it was strictly procedural, I had all my functions prefixed with v_, so that particular function was v_isset(). Short enough. My current iteration, when I use it, is part of a static class where I tried to have more descriptive names rather than brief, but the names were still fairly short - **Util::checkVar()** and **Util::checkSetVar()**. /** ... * @param mixed $var Variable to test * @param mixed $defaultValue Value to return if $var is not set or fails $testFunction test * @param string|callable $typeOrFunction Function or 'function_name' to test variable with. Must take one parameter * ($var) and return a boolean or something that evaluates as true/false. * * @return mixed */ static function checkVar(&amp;$var, $defaultValue = false, $typeOrFunction = null) { ... } /* Similar function, but would SET the variable if it didn't exist or failed the given test. */ static function checkSetVar(&amp;$var, $defaultValue, $testFunction = null) { ... } The latter allowed for quickly and safely checking, retrieving, and defaulting all the GET/POST variables. Some frameworks now include similar functionality (such as Yii2's Yii::$app-&gt;request-&gt;get() functions): Util::checkSetVar($_GET['index'], 0, 'is_numeric'); Util::checkSetVar($_GET['sort'], 1, 'is_numeric'); Util::checkSetVar($_GET['sortby'], 'name', function($var) { $var = strtolower($var); return (($var == 'name') or ($var == 'date') or ($var == 'total')); }); Can post my code if anyone is really interested, but I doubt it's any better than what's in the wild already. 
If you read about why Facebook has the stack it currently has, including its continue reliance on PHP (in one form or another), you get the sense that the legacy of having started with PHP is one important part of why they're still using it. However, the Facebook folks also seem to really like the rapid development you can do with PHP in comparison, in particular, to compiled languages. You can change a line or two of code and almost immediately test the change. This aspect of the language comes up over and over again in discussions of PHP at Facebook.
I don't know how PHP compares to some of the other languages you're looking at, but it's worth mentioning that PHP apps are very stable. They don't crash or leak memory easily. If you're planning on building a site that will get a lot of traffic and involve a lot of code, this is important.
I guess using curl is more secure? What's the difference between the two? Or should one just not ever load files from remote servers?
First week is a wash. Setting up your PC, getting accounts, learning the workflow and what projects are what. But assuming the employee only has to focus on 1 project I'd expect a shallow understanding of 1 project with a couple weeks on it for a mid level developer. The developer will be able to fix bugs, add code, but won't understand gotchas like not being able to change an existing database model because running an alter on that table in production would require 6 hours of downtime. So at the 3 week mark I'd expect the developer to be writing/submitting code, but running into a bunch of "you can't do that" areas and they'll probably be most productive/comfortable being delegated a specific narrow task to work on. Assuming they stay focused on the same project, after 8 weeks I'd expect them to know quite a bit of that project's ugliness. They should have a good understand of the flaws in the project and when(if) those flaws are going to be worked on so code that depends on it can go forward. At this point you should be able to assign broader tasks. So couple weeks to get a shallow understanding of a single project and be able to code on it, but seniors having to correct their direction a lot. After a couple months on a single project a mid level developer should understand most of the current warts on that project(assuming it isn't a massive complex codebase). They should also be able to take general requirements and work out a solution without a lot of hand holding. They know who the people are to go to to get more specific information(on the code or business side). They should know many of the gotchas in the project. How releases and deployment works on it. What customer concerns there are with the project and so on. But being a mid level guy they'll still need reviews and "how ya doing?" checkups by the senior guys. They also probably won't fully understand the impact their changes can have towards the business and systems guys. 
I dare you to give me 3 security issues that exist with file_get_contents that don't exist by the presence of curl.
I don't know what type of experience you've had but that's not WP at all. You can't blame the CMS because some bad devs muck it up. Out of the box it passes most industry security checks. And plugins don't slow it down. Bad plugins, maybe. But not by default. What you don't seem to like is WP in the hands of bad developers - which is hardly WP's fault.
I'm paranoid 😄
Please tell me how the problem is with file_get_contents and not with the programmer's choice to trust user input in this case? Please explain how, other than preventing PHP from accessing outside content, you solve the issue in the code above? My box, My code, My security. This isn't 2001.
On the flip side, during prototyping, commit messages &amp; even version tracking serve no purpose. When I start a new codebase I typically do commits more sparingly and have no interesting things to say in the commit message: "I tried several hundred random things today". So I suppose it matters what that codebase was and what they were doing. Also the most interesting part about the lack of these commit messages is asking those folks - why not supply messages? From their answer we can learn a lot more than we can learn by hatin' on a screenshot. For example, what if their workplace deployment workflow requires a commit before they can deploy the code to their testing or staging environment? So while fixing bugs they'd be committing potential fixes over and over just so they can test an issue they can't reproduce locally. And you can't have a meaningful message for each, and it's no longer a dysfunction of the committer, but of the established workflow.
file_get_contents doesn't handle ssl well out of the box. Prior to php 5.6 certificates are not verified. You could be vulnerable to a MITM attack. To secure it you need to create a stream context (see http://phpsecurity.readthedocs.org/en/latest/Transport-Layer-Security-(HTTPS-SSL-and-TLS).html). The original script probably won't run into issues, especially on php 5.6. The easiest option would be to use curl, since it does everything the right way on every php version. Edit: and to add why I'm so anal about it is that some inexperienced php developer might just copy/paste that code and use it on a shared hosting environment or an outdated php version. He/she might run into problems, I think this reflects poorly on the php community. When you write blog posts with code snippets please check for all security flaws or stick with posting it to the comment section on php.net. 
Hi! I've too been unable to find such information, in fact your package is still our best resource so far. I was thinking about downloading all postcodes from geonames.org and deriving validating regular expressions from that data, but as you say, the few seconds we gain from a simplified form exceed the effort required to do that. At the moment we have discarded the idea of doing this validation and will require visitors to select a predefined subdivision for their country. Hope we can solve this in the future though!
Largely the same reasons coming from a desktop development background and at the time Python wasn't so enticing for the web.
which questions you got right?
I can't remember too many of them to be honest. Some conditional statements comparing types, using "==" instead of "===" for certain use cases i.e 4 = "4". Along these lines. Spotting and explaining $$dynamicVariables. This is what I remember atleast.
I'm sure `new Array` was just the result of high adrenaline. I think programmers freaking out in job interviews is the rule rather than the exception. &gt; SQL command line was bad practice If you meant connecting to a production server and running SQL on the CLI then fuck yeah. I'm sure you meant something which made sense, but lost your train of thought as you were phrasing it due to emotions. The array push, on the other hand, I just can't fathom how you never came across that in 6 years of development. You didn't use it yourself, but you must have seen it thousands of times. Somehow you managed to ignore it and that makes me wonder if maybe you just tend to ignore things you come across and don't understand. If that's the case, I think curiosity is what you need to work on. Make sure you have a very clear understanding of the code you're looking at, at all times. 
rude
PHP may have it's faults, but it's still very popular and has gone through something of a renaissance in the late years. It's also worth noting that PHP has the most popular tools for web publishing (WordPress, Drupal, WikiPedia). Also the packet management, etc. have taken it to the next level. Read more: https://www.symfony.fi/entry/php-and-symfony-structure-stability-and-flexibility But as far as I think Ruby or Python are not the #1 new language to switch to. I would go ahead and start learning JavaScript or maybe even Hack (which is a lot like PHP). Both of these have aspects important for modern web development. JavaScript can be ran on the server (with Node.js) as well as on the client (browser). More about the future of JavaScript here: http://drupal.ovh/javascript-in-the-enterprise Currently Hack is quite a niche language, but it's close companion (also from Facebook), React.js is becoming a staple of web developers in a way to develop interface components. By combining these technologies as XHP-JS, Hack is now able to generate front end components (JavaScript) from the backend. Read more about XHP-JS here: http://hhvm.ovh/entry/xhp-js-building-efficient-user-interface-components-with-hack-re
It happens, for various reasons. Sometimes I think it's because developers want to solve complicated problems, and simple problems are boring. By coming up with a more complicated solution, they basically convince themselves that it's more appropriate (a type of confirmation bias, maybe). How your interviewing company reacts is how you should determine if you want to work with them or not. If they basically write you off because you made some syntax errors while nervous, then you don't want to work for them anyway. If you can demonstrate good problem-solving abilities, and an understanding of the fundamentals behind any type of development work, that's much better in my book than being able to memorize the syntax of every programming language you know.
I got caught out on ternary operators once. I know and have used them many times but didn't know the term for what they were. Eg. $var = ($x&gt;10) ? True : false 
Dynamic variables, okay, not everybody came across those or know you can invoke a variable by putting its name in a string! Comparison operators + array syntax on the other end are truly two fundamentals of PHP. Because when you program in PHP (and almost all other languages) your entire life revolves around conditions and array manipulation! There have been wars over those comparison operators. It divided and still divides the whole PHP community, unable to agree on the appropriate time to use either of them. But it's okay! Because here, on /r/PHP, the word is pretty much use === or die. Cast if needed, but ===. Objects are the exception, because to compare two identical objects per their properties but not their class name there is no other choice but use ==, ah!
In Colombia, only a few cities, like the capital Bogota, have postal codes at all. And those were just started roughly two years ago and no one knows their's [right now it's 4 big zones for a city with more people than NYC and twice the area of Los Angeles]. In the Bahamas, they don't even have street numbers! You'll see literal addresses that look like "Blue house next to the pink house on East Bay Drive."
Still not a good enough excuse. Good commit messages are not just for other people but also to remind yourself why you made specific changes at a later date. There is potential for that user to look at a change and not remembering why they did it.
No code comments, no exception handling for the low level functions, pretty useless.
Someone said I didn't know it because I didn't know globals (not superglobals). I said to pass it to a function or encapsulate it in a class and he rolled his eyes. Really glad he didn't want to work with me in the end.
Parenthesis baby! (($z) = (($x) + ($y))):
Either put the functions in namespaces (``fopen`` as ``open()`` into ``\php\file`` or similar) or create classes that use real OOP like exceptions for error handling. Putting global functions in classes is completely pointless. That beautifies nothing. And the classes are all in the global namespace, hurray!
 array_map(function($i){ echo "Value is $i"; },range(0,5)) 
Yeah, not sure of the relevance of number of lines in a project. Why would they ask that? I did actually want to work for this company though. I don't believe it was anything to do with them, I just rose some red flags in regards to some basic knowledge, that out-with an interview setting, I wouldn't have had any trouble with.
It's normal because tests are an arbitrary sampling of not just your skills and experience, but composure under pressure, and dealing with the unknown. You're quite likely not a moron, and neither you're a genius. You're an average guy (or girl) who's good at their job and tries to do their best in this hard life. You'll marry another average girl (or guy) and have two average kids. At the end of your life you'll think you did well overall and have some regrets, but don't be too hard on yourself.
PHP seems to be doing just fine despite the negativity. I occasionally reach out to its harshest critics, but there is some bandwagonism in that group and some of them will just not change their minds. I say leave them to it, and instead spend time with PHP beginners to spread best practice. PHP does have some historical problems with poor security, for example, and good efforts within the community can help fix that. 
The fact that preloading and loading on demand are both referred to as "autoloading" in Composer is unfortunate, but I mean PHP's class autoloader, which is on demand. Composer can preload files in advance, it can't autoload functions on first use. This adds up quickly over all components you use. This is why we have autoloading for classes, which is done *on demand*, and not *always*. Adding files which are always preloaded to Composer I treat as arrogance and lack of experience by the author. They assume all their preloaded code is used all the time on every PHP request, or preloading it when it's not used doesn't affect performance. Both assumptions are false in any larger project.
That's very motivational. PHP wants to thank you for your kind words. PHP always wanted to render 3D movies at Pixar, do microtrading on Wall Street, power NASA spacecraft piloting programs, and eventually create Skynet and destroy humanity, but it never believed in itself much. But now, it feels like it can. Because is Turing complete!
Still, jamming functions into classes just so you can use a class autoloader isn't a good design choice either.
&gt; I don't think I know anyone who got into programming as a "career choice". Wait, what? Computer science/software development tracks at universities are **filled** with people who chose it as a career choice without having a clue of what it really entails. That's one of the reason for the very high dropout rates in CS. Software development is amoungst the most highly paid job in many countries and very hyped in all those "top 10 jobs" articles you see floating around the web, so this is a natural consequence of the hype, and some people being like "Well, I do like sitting at the computer.." However, those who stay and finish the education are of course interested in programming, and from my experience very passionate. So maybe you just don't know about people's motives for getting into programming? (Doesn't really matter any way, but the industry is extremely hyped and this is very appearent at the universities, so just found it hard to believe)
As a newer guy, I find it really easy to mix up syntax between the dozen different languages I've been dabbling with (php, python, ruby, javascript, etc).
Yeah, fuck em. If you can write whatever they can in rails, Node, or Django then it doesn't matter. Every language sucks, if it was easy everyone would do it. Feel free to agree with them, but you write your stuff well every time no one gives a damn. 
It is not a bad thing. I was caught off guard since I had around 8 different projects I was working on at any one point. I had never been asked that question before. It had also seemed like a question out of order since no prior question had even asked about projects or experience. The question was asked in this order, which might help you understand my confusion. Question 1: Why are you interested in this position? Question 2: How many lines of code are in your project? 
I was talking about prototype inheritance. 
Going off on a tangent here... Does the "survival of the fittest" model apply to programming languages? I am asking because PHP has to be doing something right if it is still around and has such a huge share (75%) of the webserver languages.
If you don't have a lot of stuff around your ears, you could try to spend some time reading other people's code on Github. I don't really do this myself, but it is definitely something to have on the priority list :) Reading other people's code is one of the best ways to learn, and then you will come across a lot of different ways to acomplish the same task - both in terms of code conventions and architecture :)
PHP is "crap" because it allows you to do too many things. Developers tend to be very unfocused. Or rather, are prone to getting off on tangents. Most languages actually take much more care deciding what *not* to include than anything else. Imagine if you took Haskel and added Java's object model. You didn't take anything out, you just added Java objects. Did the language get better or worse? Most people will reply to that with "you wouldn't do that, Haskel isn't an object oriented language"... right, but why? PHP has first class support for several different ways of programming. It has the support to be a first-class functional language, and it also has the support to be a first class object oriented language. The problem is that it *also* has the support for you to mix the two together, and that's where you run into trouble. They are completely different modes of thinking for the developer, but the interpreter won't have any issues switching between the two. The interpreter just assumes you knew what you were doing. In fact, I'd say that's the main difference between PHP and many other languages: unlike most languages, PHP is built from the philosophy that the developer is more correct than the computer. This explains why PHP deals with errors the way it does (deferring them until it literally can't even), and why it tries to make assumptions about ambiguous situations. The C way, or Java way, or so on, is for the compiler/interpreter to say "this developer is smoking crack, I don't know what he wants", while the PHP way is to say "well, that's really unusual, but then they're the human and I'm a lowly interpreter... this is probably what they want me to do". C, Java, Python, Ruby... they all give you enough rope to hang yourself. PHP gives you enough rope to hang your whole family. Or to build a magnificent pulley system. PHP is one of the least forgiving languages to the software itself, because one novice developer can create ENORMOUS amounts of technological debt and bugs very easily, but in the hands of a very experienced developer, it is one of the most productive languages you could imagine. Lots of developers don't like PHP, but that's because it is a mirror. PHP doesn't save you from yourself, so it shows you just how bad you might be without a strict compiler to save you. EDIT: Perhaps I should clarify, since most people don't seem to be comprehending what I'm saying here, that I'm explaining why other developers think PHP is a crap language, and why they are wrong.
On /r/learnprogramming there are people on occasion looking to learn COBOL. I get that there are still legacy systems using this language but I don't get why someone would willingly want to work on these systems.
I know this likely isn't what you want to hear, but the two things you mentioned (`$arr[] = ...` and `$var = new Array`) would have both been red flags to me if I were hiring a PHP developer with 6 years of experience. It sounds like you're very knowledgeable and that you have quite a lot of PHP under your belt, so I'm sure it's just one of those freak things where you got unlucky that they asked the few questions that would stump you, but from the interviewer's perspective, it immediately raises a lot of doubts. `$arr[]` is the idiomatic way to append to an array in PHP, and `array_push` is largely seen as outdated. What other idioms might you have missed? What other community things might you be behind in: Have you come across SQL injection in 6 years? Are you familiar with the deprecation of the mysql extension? The relatively large security-awareness leaps the PHP community is making? So on, so forth. (Also, for what it's worth, in JavaScript, `var a = new Array()` is not the preferred way to create an array. Idiomatic JavaScript prefers `var a = []`.) Put bluntly: while it seems that you have a good grasp of using the languages to get things done (at least I would assume so after 6 years), if I were an interviewer and you told me that you were unfamiliar with either of those, I would assume that you're either lying about 6 years of experience (which I very seriously doubt is the case, but is not a risk an interviewer wants to take), or perhaps even worse, I would assume that you've been living in isolation. The best thing I think you can do coming away from this is go read as much high quality PHP as you can. Go find well respected libraries, peruse the code, and try to notice things they did differently than you would have done them. Even better, if you can find a skilled, well-respected person or community, get them to review some of your code (perhaps codereview.stackexchange.com, though I'm not sure if they have much of a PHP presence these days). Best case, you'll learn a lot about idiomatic PHP and best practices, and worst case you'll reaffirm that it was just a freak occurrence (it really does happen to everyone!), and you'll move into your next interview knowing that you were just frazzled last time, and you'll feel more at ease. edit: fixed the ambiguity about MySQL vs ext/mysql. 
I think in situations like that, they are doing it for the nostalgia effect as they have no real use for it. Kinda like trying to play Golden Eye 007 on the Nintendo 64, for the first time, because you are a fan of first-person shooters. Plus, there is hipster status/bragging rights.
I can't comment on the good-ness of COBOL because it was before my time, so I'll leave it alone. Recently, I started to learn C, because of I only know web languages. I was at it for a minute, then I realized, I am a web-dev. In addition to that I remembered I don't need to impress, score points or please anybody but myself. Then back to learning PHP. 
That was the only odd ball that came at me. The questions were extremely standard for almost every interview. The other coding related questions were variable variables, database connections, get|post, etc
Data is being crunched :) sorry for the delayed response!
I'm going to leave this here: https://xkcd.com/327/
Why the hesitation?
&gt; if someone is asking the question, it shows a level of expertise that might not be able to define the nuances of when they should be used and in that case The nuances are important, because more than once I've seen people do this... $s = $pdo-&gt;prepare("SELECT * FROM foo WHERE x = $x"); ... and claim they're "preparing" to protect against injections. Also, if you decide to skip the nuances and go for a short easily repeated advice, you're not teaching people what to do when they *can't* bind a part of their query as a value in a prepared statement (identifiers, limit/offset numbers, etc.). So, "always use prepared statements" doesn't really make it easy for those who are learning, it's only making it easy for those who want to teach by the numbers.
/thread
Prepared statements are less important if you have a known query that runs the same every time with no changes. For example: when pulling up a list of menu options from your database. Select URL, description from menu where type = 'home' Every time that query runs it'll be the same. There is no need to prepare it. There is no danger of injection. There is no user input.
Don't most databases cache statements made with prepared statements better? Sure it helps to reuse the statement in the same run of the program, but on the db end out should be caching execution plans that it can't do as easily without prepared systems due to where clauses changing.
This is a good point.
So is Brainfuck. It's like claiming free speech to add weight to an opinion.
Go ahead. What do you want me to be more specific about? EDIT: Okay, reading your edit... what? Are you saying that I'm just parroting stuff I've heard other people say? I'm not sure why that would matter, actually. Regardless, I'll be more specific about why I think in general PHP can be more dangerous to work in under some circumstances. Lets start with some low hanging fruit: type juggling. It makes things in general much easier... it gives you more rope to make that pulley system, to continue the analogy. However it can get you into a lot of trouble sometimes. Suppose you have a variable that's a string with the value "2 Fast 2 Furious". Now suppose we cast that string to an int, either explicitly or through using it as an int (it doesn't matter which). The value it gets cast to is (int)2. Let's look at a similar string " 2 Fast 2 Furious". This one hasn't been run through trim(). What does it get cast to? (int)0 If you write your code to take advantage of this casting, that's great, you're using as much of the rope as you can to build your pulleys. But it introduces these tiny little nuances when you do. These little nuances add up, and as time goes on it becomes harder and harder to maintain a PHP app if you aren't careful and/or your team isn't experienced. These sorts of problems aren't really as big of a deal in single-dev environments, but on teams they can creep up on everyone. And they are exactly the kind of problem that most C compilers won't let you get away with. And yes, I have programmed in C.
I'd like a programming language engineers hate, just to keep engineers away. 
This
&gt; Yes, buffers and pointers are difficult in C, but once you learn the language they are just a thing you need to deal with. And more importantly, you really CAN'T use the language without understanding them. So I guess memory management related crashes, vulnerabilities and leaks don't happen in C then. Before you understand buffers &amp; pointers, you can't use C, once you understand them... it's all ok. 
Yeah, I get asked a lot whether or not so-and-so should try their hand at programming and I try to be as honest as possible. While you can force yourself to achieve an academic understanding of programming, overall, the work we do has a creative element that really can't be forced. If you don't have a little passion for it trying to construct complex problems and solutions in your head is going to be damn near impossible and only end in heartache and frustration. 
You're always welcome to post at /r/learnprogramming 
Sometimes I prefer `array_push` over [] syntax for clarity. For example, if I have an `array_shift` in the method, I'll simply use `array_push` for clarity so people can consider the array as a LIST at first glance. However, I find myself relying on `Collection` classes more and more. 
two modern apps built on php are slack and spotify. 
&gt; I wasn't suggesting that we needed to involve the db to pass around statements - only that it is a good way to go about it. It's a good way to make an SQL call creating a resource on your RDBMS in order to pass a reference to it from PHP to PHP? It's ... good how, exactly? &gt; Yes, you can create a "query object" of sorts, but why do that when PDOStatement is an already good working solution? I'll admit it's not perfect, but it is sufficient in most cases. How about... to avoid the pointless roundtrip to the database and creating a resource there? You know, when you do something, you usually do it for a reason. The only reason you're giving me for abusing prepared statements this way is "I'm lazy so I'll use this never mind it's wrong for the purpose and slower".
&gt; with what the hottest languages and frameworks are, are too busy arguing to actually do anything with their supposedly superior language. one of my bosses right there. gladly not my direct boss
the best criticism against php i have seen has been reading the mailing list.
I can't possibly be "butt-hurt" by this discussion. I don't want someone else to be misled by your suggestions. As living RDBMS-side objects, prepared statements are not to be used as poor man's encapsulated queries in PHP.
The main reason that you don't see many big applications do what you were talking about is because it makes the application aware of and depend on data states themselves. The ideal is that the data store and the application logic are state independent. They depend on each other to fulfill a request, but not to determine their state. Usually with a DB abstraction, if you do it in objects, you fill in the object with the data and call something like a persist() method that saves. Inside the object, it checks if it has an id. If it doesn't, it does an insert, because it can't possibly do an update statement if it doesn't have the index for it. This is the same concept as what you are doing, but it depends on what you actually have the data to do (the id) instead of a state flag ($param === "edit"). As for where to learn... are you doing your own hobby work, or do you have a job somewhere doing programming?
His post was made in defense of PHP, and from where I sit his more noteworthy point seemed to be about mixing functional and OO programming
PHP is a crap compared to Erlang, Scala, Haskell and whatnot? Well maybe. It lacks several features of a modern language and even most of the important features a just a quite recent addition (eg: first class function). PHP is crap compared to Java? I don't think so. The only big difference (in the language, not the platform) is a Standard Library messier but easier to use.
Well, there is a joke about it: &gt;Developers went to grab a beer. They sit in the pub and discuss what language is the best and which is the worst. They argue if Python is better than Java, but they are all confident that PHP is slow, not very efficient, not very secure and is a bad solution. A guy next to them overheard a conversation, bought them a beer and asked for help: &gt;-I have a great idea and I need an online shop. It won't have large traffic. It doesn't have to be extremely secure. It won't be updated frequently. What do you guys think, what language should I use? Python? Java? &gt;-....... Nah, PHP will do. It's the biggest argument in favour of using PHP. It's not the ultimate language and it's not the best language when it comes to speed, security and so on. But in most cases you don't need extreme speed, military (or banking) level security - you just need a not very complicated solution to your problem and PHP is just enough to solve it.
I noticed he's trying to make it positive, but what matters is if it makes sense or not. And it frankly, doesn't. PHP is not "functional". Functional doesn't mean "having functions". Functional languages have constraints like immutable variables, lazy execution, modeling side-effects through monads and so on. PHP has never been functional. Also "first class functions" means being able to create new functions at runtime and refer to them from variables, which didn't happen in PHP in earnest until version 5.3 (with \Closure). Guy is using words he doesn't know the meaning of. The word he was looking for is "procedural". However "procedural" (C style) is not opposition to "object oriented" (say C++ style). OOP builds on top of procedural code and is very much a superset of it, and a very natural progression for PHP. **It's not a matter of my opinion** - simply google the terms used.
Of course it does. Some of the legacy features which people now complain about were absolutely necessary for PHP to survive the [selection](https://en.wikipedia.org/wiki/Selection_\(genetic_algorithm\)). Here's a complaint I read on /r/programming &gt; The second biggest mistake is having to wrap PHP code in &lt;?php. Like the extension is .php. What the fuck do you think is in it? This is what made PHP *fitter* than Perl at the time. You didn't need to `print` every piece of HTML, with escaped quotes and interpolated variables. Source: https://www.reddit.com/r/programming/comments/3cwbv5/php_700_beta_1_released/ct12oti?context=3 (keep in mind that you're not allowed to vote on that thread if you follow this link) 
Wow. You really, really think you know what you're talking about, and you really, really think I don't. I honestly thought you were just in a bad mood. Now I feel bad about engaging you.
Yes... don't engage with me, cause... I really, really know what I'm talking about. Or something.
You know, it's not a matter of *opinion* and *blame* whether what you wrote makes sense. Just google the terms you used and that I called out. You're just improvising based on clues assembled from various blog posts you've read. You wanted to be another echo in the echo chamber, I get it. But your narrative that PHP has a *goal* of second-guessing programmers is quite insulting to the people who work on the PHP core (especially when you try to list it as a "benefit" - makes us look like a bunch of amateurs), and it's factually and historically wrong. 
Yes, that's the right attitude. Don't check anything, you know better.
You're right about functional/procedural, I spotted that too. However, your response is so unnecessarily aggressive, it is not a wonder that your points are not finding agreement. Why not reach out with diplomacy instead? Edit: hmm, /u/badass-loser has deleted their contributions and their account. Oh dear. 
&gt; But it's not the full story. In php you can pull up stuff in 2 lines that would takes 2 pages of java (like save a webpage to a file). This irks java developers to no end, as well as the dynamic type system. Well, I get your point, but let's not exaggerate... In Java it'd be something like this: InputStream in = (new URL("http://example.com/hi.html")).openConnection().getInputStream(); OutputStream out = new FileOutputStream("hi.htm"); IOUtils.copy(in, out); in.close(); out.close(); And you can definitely wrap that in a single method to call if you do it a lot.
[reactphp](http://reactphp.org/) could help you upload asynchronously... You can make a PHP daemon - which I think sounds good. If I understood correctly, sounds like you want to have a setup like so: 1. user sends images to app 1. creates thumbnail 1. php pushes new images to a queue 2. background php worker 1. polls queue every n-seconds for new stuff 1. uploads files 1. remove images from queue 1. sleep if no tasks found But I gotta say: this doesn't sound easy for a beginner.
I saw aggressive stupidity and wrote an aggressive reply. My frustration comes from the fact how many align with this post without thinking what it's saying. "Well PHP's mixing incompatible paradigms and is randomly deferring errors and second-guessing your intent, y'all! It's more rope to ha... I mean to make great stuff with!" It's comical. It's like a feminist going at length "It's true, we're kinda dumb, but as long as we stay in the kitchen...". Is this the kind of attitude in the PHP community? Well I better get the fuck outta here then.
I interviewed a guy on Friday who got all the technical problems right, and did a complex coding challenge, but failed in numerous ways on FizzBuzz... 
If you didn't know about $arr[] = 'foo'; then you obviously don't read other people's code enough.
I also did this back in the old SVN days
You could use [Gearman](http://gearman.org) non-blocking background tasks to create a queue and 1-n worker that process the queue. If you need to scale, just add more workers on the same or other machines. I think you'd need Cygwin to run Gearman on Windows. Alternative to Gearman could be [RabbitMQ](https://www.rabbitmq.com) or any other messaging queue.
Of course. A quick search for "average salary COBOL programmer" on Google seems to suggest the pay is well below what you'll need for convertibles, cocaine, and classier hookers, though. That search may not be completely accurate but it at least implies that some, probably a good number, could have better paying jobs without working on such systems.
&gt; PHP is "crap" because it allows you to do too many things. I 100% agree. Hopefully the PHP core team will manage to "clean up" the language with time and deprecate then remove most bad parts of PHP. But it has good stuff, in my opinion the share-nothing execution model is very good for websites.
75% , but how many shares are just CMSes deployed like Wordpress or Drupal ? it doesn't qualify as PHP the language to me.
I guess I bought into some urban legend then. I always thought COBOL programmers make a lot more money than your average developer. Of course the convertibles, cocaine and classier hookers example was a joke and an exaggeration, but I wouldn't have guessed someone chooses to code COBOL for less than $100k. I'm with your original point. 
That's a horse table.
PHP was also originally designed to build procedural pages with PHP and HTML code interleaved, using the `&lt;?php ... ?&gt;` tags. That still works today, and is still, in general, a phenomenally bad idea. I work on a huge e-commerce site and we have thankfully pivoted all of the actual customer-facing code to the MVC pattern, which is also something you can do in PHP in about 3,000 different ways. It's helpful to interleave HTML for certain internal debugging tools just to make it faster and simpler to get something working, but in the long run, with a complicated system, you're shooting yourself in the foot. I think this is a big part of why PHP takes shit from e.g. Java, Haskell, Scala folks; its history is steeped in fairly bad ideas by any modern standards. As a programmer, you need to recognize and avoid those code smells. You can write very clean code in PHP, but you have to work at it a little bit. It helps if you use a prescriptive framework, if you aren't able to sense these code smells yourself yet. Being able to break those rules to get prototypes working is why PHP is lauded as so phenomenally productive. You should refactor them later, but as they say, "first make it work, then make it right, then make it fast."
Don't feel bad about it at all. I have been programming C++ for many years yet I could write a test that I would fail horribly. In pretty much all languages there are multiple ways to do something. In C++ there are pretty much three fundamental ways now to open a file. There are PHP keywords that I basically never use I use include_once but never require_once. So a simple question for me would have been what other keyword could you use instead of include_once; I would remember include but not the require pair. I so rarely use abstraction keywords such as abstract and implements that I would not be 100% sure how to use them or any of their gotchas. For years I used the mysql way to access my database but then I switched to mysqli. Even though I have used the older one for years I pretty much completely forget its use. The same with postgres; it has been forever since I connected to a postgress DB so while I certainly knew my way around one; there must be a plethora of questions that would make me look like I barely knew what a select statement was. memcached is what I use. I don't even really know the differences with it and memcache from an API perspective. Prior to that I used APC but now forget most of its nuances. And keep in mind that I have been programming PHP since 5 came out. I would much rather do an interview where they would discuss body of work than take some test where I might have to answer most of the questions, "I would google that." and my only expertise really being that I am smart enough to preferentially choose stackoverflow.
I... I can't help but feel violated by PHP after reading this
I might have asked, "Thousand? 100,000 or 200,000? Sorry they aren't quite that large. But some might crack 50,000." 
Though I agree with the comment below (this is all public information already anyways). Is there a possibility that the content would be replace en route or simply intercepted using file_get_contents and old versions of php?
The point of the story was not that I don't understand the basics, but I somehow screwed up the basics despite knowing better. I was going for a "code golf" sort of result. I wouldn't do that in a production application, so in hindsight I can see where that's not an ideal answer for an interview question. Let's just not go too far with it: http://www.tomdalling.com/blog/software-design/fizzbuzz-in-too-much-detail/
Don't forget about Pornhub.
It's not going too far at all. If a candidate uses `! ($i % 2)` in the fizzbuzz solution that's an indicator that he most likely doesn't understand modulo. As a result I would follow up with the question "what does `8 % 3` output?". The interview is over if you say 'false', even for a junior position. 
&gt; As a result I would follow up with the question "what does `8 % 3` output?". The interview is over if you say 'false', even for a junior position. Now we're back on topic: How easy it is to screw up the basics. Yes, `8 % 3` is not `false` but it's also not `0` as you implied.
You really should read up on modulo before replying to this comment. `$i % 3 == 0` when $i is a multiple of 3 `$i % 5 == 0` when $i is a multiple of 5 It's [just silly](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect) to accuse me of screwing up the basics because I changed the example to one which wouldn't yield 0 or 1, to make sure a boolean answer confirms an unworthy candidate. Before you ask, I would expect a boolean answer from a candidate who doesn't understand modulo in that case because he tried to negate its return. If he relies on type juggling on purpose then sure, whatever. It's opinion based, I suppose. But if he really thinks that modulo will return a boolean then he's out. He doesn't pass go and he doesn't collect 200. Edit: Linked 'just silly' to relevant cognitive bias. 
&gt; The other coding related questions were variable variables I don't work with PHP, but have done some open source stuff and some projects in the past. But I never understood the purpose of variable variables? Everything I could do with them, seemed like it could be done better without them.. Do you know the use case for them?
It's a shame that you had to be so abrasive as what you are pointing out is correct. 
today most languages features are equivalent. You can argue about strictly vs dynamically typed languages, but I take a dynamic languages with good static analysis and enforcing explicit type casting over a strict one any day. Haskell or java allow and encourage you to abstract stuff so much you don't know what you were supposed to do a few hour after you started your point.
I used to write C based cgis for interactive webpages pre-2000. Took forever to do anything. Php is a blessing. 
"It makes me money" is my personal answer. Everything I make is in PHP and I'm self-employed and don't have to work for anyone. Fuck those guys.
&gt; Yes, 8 % 3 is not false but it's also not 0 as you implied. &gt; I never misunderstood modulus. I'll go ahead and assume that you're rowing (as in trying to escape an awkward situation which you put yourself in). My comments were very clear, considering we're supposed to be roughly at the same level of experience. Any misunderstanding could only stem from you not understanding WHY `$i % 2 == 0` is a reliable way to check for even numbers. 
&gt; who chose the language because it's easy and that we're incapable of programming in a "real" language. I use a lot of different languages, but when I'm writing something in Java (for example) I often find myself thinking, "Dammit, I'd be done by now if I was using PHP." That thought keeps bringing me back to PHP.
Good post, I agree with everything you say, except for this which is complete and utter nonsense: &gt; Are you familiar with the deprecation of mysql? I've been programming PHP for 15 years now, and I'm not familiar with that. I'm pretty sure MySQL is used very widely and it's not deprecated at all, in fact it's still supported in PHP 7 (of course, legacy code using the old API may need to be updated). Can you point me to an announcement somewhere deprecating MySQL?
&gt; I generally think that syntax questions are bullshit. I promise you, I can come up with a PHP syntax question that will stump most people. I really don't think the `$arr[] = ...` syntax should stump anyone. The interviewer was right to see it as a red flag IMO, even though I don't necessarily think this makes OP a bad programmer. 
So in other words: DGAF. Just do what you love, and stop worrying about your job.
I'm no beginner, with queues, but using them on windows systems I am. I would have gone with a queue from the start if I didn't have the concern of maintaining the queue services on the clients PC. Not sure queues are where I want to go. 
That's weird. How did he fail that? Can you elaborate? I just can't see how that would work, I'm super curious.
What I was arguing is that Java encourages you to abstract in the very same way PHP does. The difference you can see in the real code mainly comes from the community, being Java much more "enterprisy". Haskell and similar languages let you abstract in a very different way, and offers you some patterns (like monadic composition) that are very useful but quite inconvenient or impossible to apply with PHP. Of course you need to abstract things correctly, but that's over the point of the discussion. More often than not you may avoid that kind of abstraction (that may have a cost) in your code, but the times you need it PHP is not there to help you with that. Is PHP crap because of these shortcomings? IMHO no. It's a language very well suited for web dev programming, that is exactly what it's used for. If you want to argue on a purely theoretical level (what OP was talking about I guess) PHP lags behind other languages in terms of features, but so does Java.
I've been having a hard time with adding dependencies. Frameworks, managers, whatever. I'm an amateur, so my opinion is largely of the grain-of-salt variety, but I think that if you really need that much *stuff* added to your programming, you might be in the wrong language. I don't think frameworks are inherently bad, but I do think PHP developers have a tendency to over-engineer what they're doing. And as an amateur PHP developer who loves coding in it, who has made some seriously over-engineered solutions for problems that sometimes didn't even exist, this is a lot for me to admit. :-P
&gt; He could be referring to the deprecation of the mysql_* functions in favour of new methods like PDO. Who knows. &gt; He could also be referring to MariaDB, which many Linux distros are now shipping instead of MySQL in the official repos (Arch Linux, for example, only has MariaDB in the official repos). I'm not 100% sure about this, but I believe that MariaDB will work seamlessly with PHP as if it were a MySQL database. But I guess that doesn't really mean that PHP supports MariaDB. On the other hand I'm not aware of PHP having officially endorsed or decried either MariaDB or MySQL recently. I'd expect both to work fine with PHP for years and years to come.
PHP is fantastic for making websites. That's what it was designed for and that's what it does well. The people who complain about PHP are complaining about when it's used as a real programming language. Because it was never meant to be a real programming language. I'll admit that it has gotten much much better in the last 5 years. But it's not a high quality language. I don't really think there's an argument against that. PHP was designed to print HTML web pages. It wasn't designed to build large web apps like WordPress, and that shows. There are a lot of hacks and inconsistencies to try and make PHP work like a programming language and not a web template language. A lot of things in PHP are so odd that it's just down right embarrassing. The existence of __get() comes to mind. It completely breaks the ability to use isset() on an object, so they went and added __isset(). But there isn't an equivalent for empty(). So if you use __get() you have to implement your own isset function and you can't ever use empty(). And of course there is no way to programmatically tell if the object is using __get(). Your only option is to dig through the source code. I suggest checking out /r/lolphp for some examples. EDIT: __isset() exists and __empty() does not. I got them backwards. Just goes to show how confusing it all is.
Oh ok. Well, queue doesn't have to be a queue-ing service a-la-gearman; a sqlite-db would suffice I imagine. From `process picking up any new images to send to the web server` it sounded like you were going to poll the filesystem for new images.
The docs suggest that you don't use `array_push` unless you are adding multiple items on to an array, due to performance issues. 
I would just say I'd agree that some things are crappy in PHP but it's been getting really better recently and when using a framework like symfony 2 it's actually close to the feeling of Java
You say there's no equivalent for isset but there is -- __isset() (and also __unset), http://php.net/manual/en/language.oop5.overloading.php
Someone beat ya to it, in /r/webdev! `:-)` https://www.reddit.com/r/webdev/comments/3dte3a/the_selfhating_web_developer/ Edit: I don't mind the DVs but I don't understand them. Is it not of interest that a Reddit discussion may already be underway elsewhere? 
Bjarne Stroustrup's famous quote, "There are only two kinds of languages: the ones people complain about and the ones nobody uses", is pretty relevant here ([source](http://www.stroustrup.com/bs_faq.html#really-say-that)). As a language gets more popular (and this applies to any language, really), there will be more attention focused on it, and naturally, at least some fraction of that attention is going to be negative.
To clear things up: * PHP's ext/mysql is deprecated (I'm pretty sure it was removed from master months ago) * mysql server is not deprecated * PHP's mysqli and PDO are not deprecated
He failed in almost every aspect. Syntax errors, not knowing how to test for % truthiness, he spent a good 5 minutes trying to figure out what to do with the string he had made, then he had problems outputting just the numbers. At the same time, he had a solid understanding of advanced OOP, SQL, PHP, and NodeJS. so I gave him a coding challenge to do over the weekend. That will ultimately determine his eligibility.
I don't really understand how your sync is working ... but : There are SFTP (Net_SFTP) libraries (and the ssh2 library) for PHP, which you could perhaps combine with pcntl_fork() or pthreads to have multiple uploads in parallel -- however, I don't really think you'd see any great improvement uploading in parallel if their restriction is their 'net connection. I'd be inclined to want to introduce a local Linux samba server - which they just copy files into. That'd handle copying to the external local storage and the remote web server. Your Linux box could then handle the uploading (rsync would probably be the easiest) and if you needed to implement parallel workers you could. &lt;/2p&gt;
Hmm, and yet, why do people prefer incorrect comments over abrasive, but correct ones?
Because most people can't stand assholes.
I think that's an intentional design by the developers of PHP. The idea is to spread out the amount of stupid that people write in PHP over time so your computer doesn't get clogged with stupid. I wish it was a PHP.ini option though, say like "disable_stupid_throttle=true" for those of us advanced users.
To be fair it's always ugly to see the sausage being made. PHP publishes that mailing list, but it's not much prettier in other open source projects (Linux itself comes to mind) and even commercial projects in big companies. You just don't see it. 
&gt; it doesn't qualify as PHP the language to me. All right. I'll bite. Which language do we count it towards?
That's too bad. Assholes are the best kind of people.
Lets say I got php5-json, php5-xml, php5-&lt;whatever&gt; installed, ALL functions are ALWAYS available in every class and file, compared to Python where you have to import them. That might make more clear what I ment with that. And why is it an advantage that PHP has to load the classes and everything again and again? Sure, it *can* have advantages, but also has drawbacks.
I work in the LIMS (laboratory information management systems, so basically just database GUIs for laboratories) area and we don't have this problem at all. We can easily predefine every query that is needed and all our relationships are dynamic.
I was coding in php and JavaScript for work and Java after hours... results? public void function($array) { var $tmp;
Web programming is real programming. However web developers seem to be more content writing the same old thing over and over and over again than other types of programmers. To take just one example, in most other fields in programming people would probably have murdered browser development teams for even suggesting that every website and webserver under the sun should work around browser bugs.
Oh yeah, I've mixed other languages too, it just winds up mashed up in the brain. 
&gt; And you can definitely wrap that in a single method to call if you do it a lot. A try-with-resources statement is enough to reduce that. I guess PHP-11 might have that as well.
&gt;&gt; It has the support to be a first-class functional language &gt; &gt; Nothing can be further from the truth. OP confused imperative with functional.
But the question is not if it was a blessing back then. It's about asking if we have stuck with it because of comfort with the language. Just as PHP was a blessing for you ("C based CGIs" = masochism), or as others have had it with Perl; maybe if we step outside the PHP ecosystem and look elsewhere maybe we will find a new blessing, but this time, one for PHP. I'm not saying there is or isn't one. But it helps if most comments would contextualize their comments like you did, so we would be able to better understand where some people are coming from. I think that adds a lot of value to the comment, that we might not been aware of otherwise.
Ah, are you sure your shuffling algorithm is correct? You are choosing the random number from the whole range, instead of the current subrange. This is a standard implementation error creating a somewhat non-obvious bias, see https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#Implementation_errors for some discussion.
Thank you for the validation. I eventually decided he either couldn't grasp the point or was trolling and I regretted replying either way. He got stuck on me not understanding modulus which was never true. 
I was making a little quiz/game using web sockets and it was bending my mind. Data going and going out all at the same time.
you have a typo near 'age', '&gt;' 18 looks good, ill give it a try
Awesome, great library! 
A lot of EE developers moved over to [Craft](http://buildwithcraft.com/). IMO it's much nicer that EE. They are [currently re-writing it with Yii 2](http://buildwithcraft.com/3).
Thank you! I took some time to really digest this. I think this particular issue is a little weird because I'm actually updating a pivot table for a many to many relationship. I suppose I could do a check to see if there are any existing relationships and remove them. If there aren't , then I go ahead and just create new ones. But I'm more concerned with this === "value" pattern I keep repeating in other places. Any time I need a function to do two very similar things, I create a parameter and an if statement. The only reason it's a string is so its a little easier to understand (or at least that's my reasoning). When you say it depends on the data state, do you mean the form input data? Or the param data that my controller is throwing it? I don't quite understand. Also, this is a little of both work and personal. 
I use it for any CMS project with enough budget to cover the cost of licensing (EE + add-ons is usually around $500+ for the sites I build). Most of the my clients that I have built sites for love using it. I quite enjoy working with it and version 3.0 just around the corner brings some much need changes to the core architecture. I have built one site with Craft and wasn't a big fan at the time. I would be willing to look into again however. 
I was unaware of this nuance. Thanks for the head's up.
You could give it a shot and if you just absolutely hate it, start looking another gig while working at your current place. There are even a lot of remote based Laravel jobs you might be able to land. But at the very least, if you learn a little WordPress then decide to move on to another gig, at least you now know some WordPress, which you never know when that could come in handy down the road.
Thank you Taylor, your work absolutely inspires me and is the reason I get to call myself a web developer. I'll keep an eye on Laravel jobs. My personal experience with WP is a simple website i built back in 2009, when I had near to zero PHP knowledge. Now the other members of the team are using WP, which is good because they could help me out (although everybody is supposed to work solo on a project). On the other hand I see everyday some of the pros/cons and the struggles that come with the WP ecosystem, and that discourages me.
There is seriously nothing wrong with developing in Wordpress. Yes it's API is build entirely on functions but that doesn't meen you can't use classes in your own code. PHP API is 99% functions itself, and also a big chunk of coding with Laravel is calling static functions. So it's not like WP is that different. You can still use Composer and whatever tools you like for your code within Wordpress. And, of course you can find a lot of familiar pattern in there. E.g. their whole filtering is based on the chain-of-responsibility pattern, etc.
Good luck in whatever you decide! :)
Hello, I have a question that I recently ran into the other day. Is it possible to get a constant of a class, that is stored in a member variable of another class without an intermediate variable? If I had a class Car and a class Engine, and $car-&gt;engine is an instance of Engine. Is it possible to get $car-&gt;engine::TYPE? I was getting errors so my workaround was creating a temp variable $engine = $car-&gt;engine, so I could get $engine::TYPE
Just use a getType() method on engine... $car-&gt;engine-&gt;getType()
dude, keep going! doing what you love and working for yourself is literally the best shit in the world!
&gt; Lets say I got php5-json, php5-xml, php5-&lt;whatever&gt; installed, ALL functions are ALWAYS available in every class and file, compared to Python where you have to import them. That might make more clear what I ment with that. Ah, I get it. Well, we have namespace now. It's a different solution than forced import aliases, but works fine. Of course, extensions tend to be namespace blind due to inertia and keep piling stuff in the global space... But give it time. &gt; And why is it an advantage that PHP has to load the classes and everything again and again? Sure, it can have advantages, but also has drawbacks. Because it matches the stateless nature of the HTTP protocol itself. When you refresh, your server script gets restarted (PHP), your HTML DOM gets rebuilt, and your JS gets a fresh start too. It's a much simpler combination to debug when you get all your inputs at page start and all your outputs by page end. No other long-running application state (except from explicit I/O like files and SQL). It's more "pure", like pure functions in a functional language. The web request = pure function's arguments and the web response = pure function's return result. Simple, right? No further application runtime state keeps application startup fast, which means fast feedback during development, which lends itself to the rapid update cycle of a web site or application. You try different inputs, you get different outputs, immediately on refresh. Sure it has drawbacks for complex apps. I just tend to think, once you start having complex logic, you need to move it to a service (which can be persistent and not restart every call), and then you can call that service from PHP. Just like you use SQL from PHP, but a service with an API specific to your domain. The service itself can be anything: PHP again, C, Java, Python, ... In other words I see PHP as a language uniquely in sync with the web, it's a web language. The further away you get from the pure "web purpose" of it (simple page logic), the less suitable it becomes, and the closer you get, the greater the benefits. From that PoV it's nice to have PHP for the pure web front-end layer, because we have dozens of other good languages for everything else (that might help power that front-end through services). Play PHP to its strengths, don't ask that it's more like the rest. And if you think about it, would PHP really be any closer to being this popular if it ran a persistent process with state all the time? Consider shared hosts, where you have hundreds, sometimes thousands of sites per server, most sites getting a dozen visits a day, if that many. Imagine thousands of persistent processes written by people who don't care for your shared resources. Doesn't sound good, right. The PHP model with its "I run on demand when I get a request, and then exit by the page's end" is uniquely suitable for those cases.
Son. Back when I learned, PDFs were brand spanking new, 3 to 4 years old, my P2 could barely open a 20 page PDF, and no one had ever heard of a 500+ page programming book as an ebook. Publishers were scared shitless of them, MP2s were all the rage [shared over Undernet (#mp3chat, baby! Oh how I miss those guys!!)], and Napster's creator wasn't even out of high school yet [neither was I!]. No, I mean really heavy, really bulky paper books. To this day, I still find programming ebooks to not be nearly as helpful, and that's saying a lot, because I read over 300 ebooks a year and not a single non-programming paper book.
&gt; If I accept to learn Wordpress, should I do it at work during my shift, or in my free time at home? (I think my employer implied the latter.) I think if you are being asked to learn Wordpress, at the very least you should be given some time to learn on the job.
&gt; I work as a Laravel developer and my employer wants me to learn Wordpress. What should I do? I maintain a complicated service-oriented application based on a custom framework. Absolutely no WordPress in it. The public-facing pages though? WordPress. You gotta learn to be flexible and combine multiple existing solutions into new solutions. Right at this stage, you're rejecting WordPress before you even have learned it, so the problem seems PEBKAC oriented. Learn WordPress so you know why you hate it, at least. Then when you know why you hate it, we can discuss solutions to specific problems it has.
&gt; There is seriously nothing wrong with developing in Wordpress. Theres a lot of things wrong with it, lets not be misleading. But yes, its still a viable tool for certain situations, and has some good stuff in it.
&gt; Again there are several ways how to do this, my philosphy is to allow as mutch freedom as possible. Does that include spelling words? ...Kidding aside. I don't think the freedom to write the same thing 4 different ways is "freedom". That kind of thing where foo(a, b, c) is the same as foo([a, b, c]) will bite users in the rear, when they pass what they think is a scalar and it's an array. I'm talking injection-level security problems. It's much better for a dynamically typed language to keep method signature simple and predictable, so input is treated exactly like users expect it would be. I'm talking from experience, because I did use to heavily overload my API methods, but in PHP it doesn't work well.
Thanks for the quick reply. I think, it's better to use imap_status rather than imap_search to check for any new emails. I'll implement this one. About cache, currently we are not doing it for emails. But, is it'll be a efficient solutions ? Because, in this way, we've to cache each email copy of all user's which will be require by only those users. Is it a good practice to store email message in DB ? How, other web email client tackle such kind of issues ? 
Stop whining, it\`s a job and WP is a huge part of the web, it\`s not going to hurt you.After you get more familiar with WP you can even develop plugins on your own for some extra cash,nevermind WP is a lot more popular than Laravel.
PHP has a lot of frameworks, but they're all kind of similar. Essentially all takes on RoR's MVC-ish layout. What are your most common annoyances with those, and what would you imagine a hypothetical better framework could be?
Web programming is like a gateway drug to full distributed system programming. So hating yourself for that is hilarious. Distributed systems do a lot more real-world work than a little C toy kernel would, and the algorithms for creating resilient distributed systems are fascinating. Many of the lower-level problems you can solve in lower-level languages have been solved (say you don't write everything in C, you write yourself a runtime like Java, PHP, JS and write most code there). Distributed systems is where it's at. And the web is the most mainstream (and largest) distributed system. 
One practical use case (I'm facing right now) is an upcoming freelance project which is about overhauling an existing EE project.
You could [tip the scales in your favour](http://framework.themosis.com/). (Disclaimer: I haven't used that.)
Well but then you have to remember to escape your own raw expression yourself
no context? people tend to want to fit everyone's problems into "their" own version of how it should be done, truth is, it dépends, it dépends on so many things.. do you work for clients? in team? how many programmers in your team? skill level? what are you building? etc...
Wow good article, i think it describes a part of most "web developers" lives. Almost every web developer i know, mostly php developers have at one point talked about this feeling myself included. I think i was lucky, at the time i had a lot of contact with the users i was building the software for the thing that kept me going was their great feedback. Knowing i was able to develop new features that would make their live easier, and being able to develop them within a short time span. But still at the time i didn't always had the feeling i was an software developer, i think that came the last few years with php maturing and me writing more complex, more structured and better code. What i learned the past few years is that PHP might not be the best programming language, but done correctly we can make/write beautiful software and dominate the web with our ability to quickly develop and deploy new features. 
Problem exists between keyboard and chair. Basically saying that he is the problem for knocking wp before he tries it.
How often do you roll your own "no-framework" framework to clients? When frameworks like Symfony and Laravel are too big for you?
Ah, I just did ) Going to start using it now )
php and jquery is not the definition of "web development". after 10+ years of embedded-, PCL programming and web development i EASILY prefer programming in the term of "easy". real webdevelopment is ALL but easy, and my experience with people who call it easy usually indeed stop at jquery and php.
This still doesn't look quite right to me: The range for the random number does not include `$i`, so elements will never stay in the same position. The abort condition for the main loop `$i &gt; 1` should probably be `$i &gt;= 1` as well.
I just refactored throwing of the same "BaseXxxException" with different error messages across controllers into five different exception classes (MissingSomethingException, InvalidMessageStructureException etc.), all extending from Base. Now I'm catching them individually in controller with a separate logic for each exception type. Is this a good practice?
I shall make a point first, though: when you see people attacking language constructs, then probably you do not need to defend yourself or the language. Probably they do not know what they are talking anyway. With that out of the way, most of the criticism I heard of PHP come from CTOs and not from the real hands on keyboard people. I have collected them throughout the years and it turns out that PHP is really indefensible: 1 - There's minimal overlap between C/C++ and PHP communities, and PHP is not written in PHP. Thus, if you have a problem with PHP, you can neither patch the language, nor affect its runtime. So, if PHP internals has a problem, you have a problem and can do nothing about it. This problem cannot be fixed. 2 - PHP suffers from dysmorphic growth due to languages' cold war feature race. It grows in so many weird ways, but none of them towards to make better use of multicores etc, e.g. lack of green threads. However if you need support for SPPLUS (???) it is there. And as of PHP 7, it introduces static typing which also introduces more attrition. It does not growth to solve issues, but to introduce features. This problem cannot be fixed. 3 - Hiring PHP developers are a lottery. The jitter in levels of experience and craftsmanship within PHP community is so high, that people completely lose their sense of proportion. Personally, I have seen too many times "Senior PHP Developers" that are anything but. This problem cannot be solved, even with the best hiring techniques. 4 - Emacs syndrome: no one really knows nowadays what PHP is for. "No one know what Emacs is, but some people write code in it". This is not a problem per se if PHP really was general purpose. It is not, even when it tries hard with things like React, or support for libpthread. 
it dépends, a hypothetical better framework to do what? sorry I don't use frameworks so... but I can tell you that I hate it when in a meeting some software shop dev ask what framework we use and we tell him none and he (and our management guys) give us that weird look like we just killed kittens or something
Well, let's use a more generic term: architecture, infrastructure, plumbing. How do you organize and tie your code to make a web application?
As a career developer, I would immediately start looking for another position. Having to "Learn" Wordpress is enough to kill tangible future prospects. You as a developer have just initialized your own progress to becoming a dinosaur. Stay relevant, stay current. 
I always do it, because when you connect the components yourself you know how they interact and there are no hidden shortcuts taken between components that can become an obstacle to refactoring later. That aside also an application should have the freedom to define its own architecture. You can definitely *fork* a framework and customize it, but now you're entirely on your own, merging patches from upstream and so on. A better solution is to draw the line at components: I'll use these components, not fork them, but integrate them as-is, and the "framework" part will be in my repository where I can customize it. I.e. the framework becomes a little bit of glue code between third party components, much easier to maintain than a full framework fork. 
http://blog.codinghorror.com/so-youd-like-to-send-some-email-through-code/ Good article, its about sending mail not fetching it though, but good read though.
If you frequently have multiple nearly identical "catch" blocks for every "try", then it's not a good practice. If the errors are different enough that their handling code is different, and you catch one or a couple at a time, then yes. Details, details. I personally prefer one exception class per component and different exception codes for the different errors. I don't know of any drawbacks to this practice. The important part is having a machine-readable identifier for the error type. It can be just the exception class, or it can be the exception class combined with the exception $code. A code is machine parseable (whether it be a number or a string code). A $message is an English (or whatever) sentence for human consumption that may change from release to release and is not for machine parsing.
Being a good developer / programmer.. isnt about the next best framework. its not about learning tools. its about understanding logic and being able to create solutions to problems. Wordpress may just be a solution to someones problem. If it is, its time to look for a better position that requires you to solve more "difficult" problems. 
What exactly woukd a mtm attack do for fetching data from an etsy? Change the avatar of a crystal pendant ?
Do you have any local-side user table for each of your four websites? That would seem to be the first thing you need, if you do not already have it. When your SSO logs on and creates a local session, you should ensure a row exists here - and if it does not create one. It will need to record what type of SSO is used as you'll probably want to render this information with user content (Facebook user X reviewed gig Y). That will give you a foreign key for concert reviews and the like, which of course will go in another table. 
oh my bad, totally missed it
Would you like to write a short tutorial how to test php7 / wordpress on digitalocean?
if all you need is a 3 page website with a contact form I'll tell you to use plain old html files and maybe have a php function declared somewhere at the top of your contact "page" to send your contact form data somewhere (email, db, whatever) if you need to build the next etsy... it really dépends on what you're building where I work we maintain a single "app" with different "modules" used by around 200 people (coworkers) daily, we don't use front controllers (or "controllers" at all) because we think they are an overhead and add unecessary complexity to a very simple and extremely flexible "base" architecture (we lost that war several years ago to java/c# devs, I know) we use apache httpd and a combination of multiviews / ressourcefallback and a basic route() function à la microframeworks for "clean urls" / views and doctrine to model our domain
`mysql_connect` oh no you didn't
Oh yes he did.
&gt; we don't use front controllers (or "controllers" at all) because we think they are an overhead and add unecessary complexity to a very simple and extremely flexible "base" architecture I'm quite curious what that would be like. Usually when people say "we don't use controllers" there is a component that is 1:1 a controller, but they just have another name for it (handler, action, ...). But if it's not the case, that makes your architecture a lot more interesting. The front controller is typically the router, BTW, so... do you have a router? If not, how do you identify and call the code relevant to a given URL/page? One way is routing through the file-system, old-school style, which works, but can be a bit limiting.
Oh gosh, my eyes
For me, it's Magento, when you need to modify some core features, speed up the site etc.
i posted a rather angry and curse laden response elsewhere. here's the bottom line - if you support yourself by writing code that solves people's problems than the hell with what anyone else thinks. somewhere along the line, the programming industry has attracted people who want to engage in some kind of dick measuring contest based on the tech they use. really? really? if you think you are a more worthy human being because you know a particular *programming language* then you really are beneath contempt and thank you for identifying yourself as a flaming asshole instead of leaving me to guess.
This is usually the kind of shit n00b developers, or non-developers come out with. PHP does lack mainstream mature tooling, and well documented public best-practices *(Sorry PSR CS has nothing to do with best practice, although their logger and http and autoloader specs are great, and have improved PHP)*. This tooling can easily be put in place by businesses with competent developers, and as with any language, there are variances in practice that are improving around testing, and deployment. &gt; Lots of developers don't like PHP, but that's because it is a mirror. PHP doesn't save you from yourself, so it shows you just how bad you might be without a strict compiler to save you. Very true comment, which I would say is less true of other languages. PHP shows our business all the time how to efficiently, and eloquently describe a solution to a problem. It is not always our last-stop, and we do currently need to use other languages to power our apps, but this is not a problem with PHP; just a reflection of how complex computing has become as a field. 
our "router" is a combination of file-system routing and a small function that parse URLs then run a callable just like microframeworks do (derived from [web.php](https://github.com/bungle/web.php) route() function) httpd MultiViews does it's magic routing through the file-system then our function will map the request to a callable our app has a "human ressources" module (more like a collection of HR modules), in our `htdocs` (document_root) we have a `hr` folder with an `index.php` in it, httpd (with Multiviews enabled) will "use" this file for every requests to 'http://mydomain/rh(\*.)', if we add a `mymodule.php` file in this `hr` folder httpd will use it for every 'http://mydomain/rh/mymodule(\*.)' requests inside those files it works like in microframeworks &lt;?php include $_SERVER['DOCUMENT_ROOT'] .'/../lib/bootstrap.php'; route(['GET'], '/hr/employee/%s', function($uuid) { if (null === $employee = entity('\Hr\Employee')-&gt;findByUuid($uuid)) return http_response_code(404); return new View\Html('/hr/employee.phtml', ['employee' =&gt; $employee]); }); remember this is in a controlled environment but even if we fuck up and php source is seen we don't care, there's nothing usefull to see, domain objects and services are not in document_root you know I learn a lot from you (deleted accounts :p) even when you're angry
So.... build your own framework then?
&gt; also a big chunk of coding with Laravel is calling static functions You mean static object proxies. ;)
Hi, as mentioned before pthreads could benefit you here. I've coded up a example (dirty) which work and does concurrent uploads without requiring anything other than normal flysystem. I've tested it with a 2,2mb cat gif upload and all was fine and speedy. use Aws\S3\S3Client; use League\Flysystem\AwsS3v3\AwsS3Adapter; use League\Flysystem\Filesystem; function get_filesystem() { $client = new S3Client($credentialsArray); $adapter = new AwsS3Adapter($client, 'bucket-name'); return new Filesystem($adapter); } class Upload extends Threaded { private $from; private $to; public $success; public $start; public $end; public function __construct($from, $to) { $this-&gt;from = $from; $this-&gt;to = $to; } public function run() { // A thread needs the autoloader. require_once __DIR__ . '/vendor/autoload.php'; // Upload + profile $this-&gt;start = new DateTime(); $handle = fopen($this-&gt;from, 'r+'); $filesystem = get_filesystem(); $this-&gt;success = $filesystem-&gt;putStream($this-&gt;to, $handle); $this-&gt;end = new DateTime(); fclose($handle); } } $pool = new Pool(8); $uploadJobs = []; foreach (range(1,5) as $num) { $uploadJobs[$num] = new Upload(__DIR__.'/cat.gif', '/cats/'.$num.'.gif'); $pool-&gt;submit($uploadJobs[$num]); } $pool-&gt;shutdown(); foreach ($uploadJobs as $upload) { var_dump($upload-&gt;success); var_dump($upload-&gt;start); var_dump($upload-&gt;end); } Hope this helps to illustrate it.
I don't think there had been anything that didn't make me more crazy than magento. I've spent hours with my head in my hands pulling my hair out.
Hahahah. OK, that deserved at least MY upvote.
Thanks for the reply. When a user logins through username password pair or going through Social Login than a call to their api is sent, cookies are stored on the client browser and the whole serialized user object is returned to the client. No tokens. Any call to THEIR web service is checked against user authentication and authorisation. On the client it is possible to check id user is (still) authenticated through a client api call but no token is exchanged, nor there is a method that can turn a "token" to a user unique object. So it is an authentication and authorisation system, but for the platform service itself (e.g. they provide "follow" functionalities on our topics or entities, I cannot follow a topic / artist without being authenticated or authorized; but all this happens on their side not mine) So we have no tokens. I omitted one piece of information. There's the ability to log in towards the service as an administrator and being able to manipulate other user's data (so for example get a complete profile of a user based on his username, modify user profiles and so on) So, taken the above what to do now? Something along the lines of this can be considered acceptable? - I create a script that can produce a token based on some rules and that can return the user id given the token (need advice on the standard libraries to produce secure decryptable tokens) - I also create a PHP script that logs in to the server as admin and can check if a specific field is present and has a certain value on a particular user - user (client - authenticated) goes to the form page X - async call to my script to generate the token - when token is generated at the same time I do two things - I store the token on user profile - I put both the token and the username in the form fields - on form submit I reject all the calls that don't have token and username in it. I check if user has the token in their profile and if yes and the token is valid I proceed. On operation success I delete the token from user profile. 
&gt; (My experience with PHP, obviously based on this post, is zero prior to this project.) Reality enters; that being a developer is not a simple task, and should be left to those with *experience*, or *undertaken with those, with experience* of the specific tool-set and languages you will be working with; to create a controlled environment, before undertaking major projects... There is an alternative, and that is to explain that the works are innovative and iterative, and if the client agree's to this, you should file all complaints arising from under `/dev/null` The best advice anyone can offer is ***Only sell solutions you know you can provide!***, or put in place mechanisms to remit the risk. 
It's an interesting question, but I'd say it's a little weighted. You'll probably find that the most complex problems solved with PHP, including IT and business rules/logic are almost certainly not going to be a product. With complexity, you're starting to get into the realm of bespoke development and logic - something that a "product" wont answer off the shelf, and then you're into the age old question of using someone else's code versus rolling your own. The most complicated things I've been involved with didn't need PHP - that was just by choice, but it did need a lot of thinking time (design/planning). Business rules will confound your complexities way more than the language and IT requirements will.
A lot of people dislike ellislab products like EE and CI... It's based in general ignorance, scapegoating, and dev-snobbery. When released all these projects are using out-of-date PHP, but so is Laravel, so is Slim, and Symfony, and some of these add technical debt that PHP does not need. I Think of Laravel as a completely separate thing to EE as well, so these are not comparing easily comparable objects. It really depends upon the developer, but I don't see much about plugins on craft page, and as it is commercial, it seems really limited for what it does [See Plugin docs for Craft](http://buildwithcraft.com/docs/plugins/introduction) 
That "somewhere along the line" was 1979 when suddenly there were multiple platforms and languages to choose from to accomplish something. By 1986 people were starting to get paid very differently according to which platforms they knew. Today it's alpha geekdom, and if you don't know anyone who thinks they are better because of what techs they are using, you aren't paying attention or haven't worked with a team of programmers. The dick measuring contest begins with which keywords you can lie about on your resume and ends with how much money and power you are getting because you have those keywords. It's part of the brogrammer universe. Have fun in IT. 
Is this something that JWT is designed to solve? User logs in with external service, and is directed to your authentication system. Your auth system looks at the details provided by external auth system. Checks it against a users table (via any unique attributes of the data provided by the external auth system that you can trust). Create/return that user's uuid for your auth system. Store that in a JWT and pass to client. Now any of your services use the JWT to verify the users identity, and and that they are authenticated with your service. Basically, use external auth as your first point of authentication, then rely on your own implementation. External auth only provides users details, and that this is who they are. Then your auth says 'we know this person'. Using JWT with a shared secret between all your services means they can share JWT tokens/payloads and verify they have not been tampered with. Unless I have mistaken something. Also, on mobile. Please forgive any mistakes or formatting issues.
Heh. :-)
Wordpress really isn't hard to learn. You just have to have a rough idea of what it can do out the box, the easy things to do outside of the box and a working knowledge of the API. You could be doing a lot worse - you could have inherited a codebase that's locked to a legacy version of PHP with a home grown "framework", globals everywhere, etc. 
Is there a reason that namespaces used in regular code are relative, but namespaces in "use" are not? Example: namespace MyNamespace; // doing this is relative and refers to \MyNamespace\Vendor\Package\SomeClass $thing = new Vendor\Package\SomeClass; // need leading backslash $thing = new \Vendor\Package\SomeClass; But here, `Vendor` is a top-level NS without the leading backslash: namespace MyNamespace; use Vendor\Package\SomeClass; 
Question why. If you don't like the answer, move on.
Thanks Towerful, so basically what you're saying is: * on the first occasion use the client side data coming from the external service to generate a JWT that will then be stored in a session cookie client-side. * use that JWT token as the source of truth on who the user is and if it is authenticated Then I should only be concerned of the times when the user calls the logout on the external service during the same session. if it happens than I should also delete the JWT token right? 
that's interesting. i got into the industry in 1990 and didn't notice this till the mid 90s. since then, i have worked with people who thought their intellectual shit didn't stink and had excessive pride in having memorized parts of different language specs. i just thought this crap was a relatively new invention. i've got a simple solution to dealing with it though. i work remotely. when my only interaction with you is thru IM and email, i can ignore an awful lot.
It is still a static call. It doesn't matter what the code behind the static call does. The important part is that it is a hidden dependency that you don't see immediately. I know you were making a joke, but wanted to plug some explanation too )
The most complex project I setup, is 4 distinct applications with a unified UI front-end, sat on top of the same data base with 150 tables. The infrastructure is split into 2 sections: - The back-end which is a webserver running the "media buyer" portion of the application, with the database running Citus db which is a clustered database and sharding across several servers. There are 5 db servers which allows for 100s of millions of rows in a single request in under a second. - The front-end is 1 web server with varnish, nginx, hhvm and currently redis. Within a month may be varnish, golang and aerospike (depending on the performance). Aerospike will give the ability to horizontally scale for redundancy and have all 3 server serving requests. Seriously, Aerospike &gt; Redis in a huge way. - There is a backend process built in python with zeromq which pushes messages between both the Redis server and postgres database. A 1 minute interval is in play to move the data from the front-end to the back-end for near real-time analysis. It's the most complicated architecture I have set up to date. When then primary desire is speed as 100ms can make all the difference. You tend to find that certain languages and database applications just don't cut it.
At the time it was the master version of all the branches. Slim v2 i think is the same code as it was... but lumen and especially slim 3 have undergone a large amount of change. I might re-run the tests later this week if I get some time. All sites were setup to use just a simple hello world example. GET /hello/world with Hello World! body
/quit
Yes, Yes I do. /not_java /not_python *grabs popcorn and waits for hate*
So you're getting judged only on the quality and quantity of the work you provide? That's crazy! :)
this looks awesome, never heard of it and it looks very cool. Thanks for the share :D
&gt; Any call to THEIR web service is checked against user authentication and authorisation. What does that mean in specific terms. Checked against... username and password? Is username and password entered every time? I doubt that. You said cookies are used, and I bet what's in that cookie is a token which you can then also read on the server and check against the service API (in order to fetch user identity). &gt; I create a script that can produce a token based on some rules and that can return the user id given the token (need advice on the standard libraries to produce secure decryptable tokens) The identity service should be producing the token, not you. Also "some rules" is too fuzzy for me to interpret. As I said, I think you should go through docs and contact the service providers and ask them simple directed questions about your use case. Don't try to create some hairy schemes for emulating proper authentication workflow. Either find where the token is stored and how to use it to obtain user id from the service, or don't do anything.
He did :\
Yeah. However, I've been the sole maintainer for multiple internal repos at work for years. The amount of time I've saved not writing commit messages for thousands of commits no one but I will ever see is non-negligible. I'm also never reverted any slice of code more than 72 hours worth of commits. Literally no one [even my replacement] is going to read through 3 years of git log on any of those projects. I'd only stop skipping the commit messages if I put in my 2 weeks notice so they next guy had info on the most recent changes.
Sounds good to me, thanks.
This JSESSIONID looks like a token (that's what a token is: a session identifier linking you to an authenticated user). So, good, step one accomplished. Now, step two: how to call that service with that JSESSIONID from *PHP* (not JS) and obtain a stable unique user id from the service.
Sounds like the cookie is the token then.
I never understand why developers are so against learning different tools, I really like Laravel and use it often, but it shouldn't be the only tool in your kit. Wordpress may not be the best CMS out there, and to a programming purist the codebase is horrific, but in many cases it gets the job done just fine. I have a very large site running on Wordpress right now with 50k users and a highly customized theme, it runs perfectly and allows my client the ability to make the simple changes they want. For the more complicated tasks and 3rd-party vendor needs, I have Laravel installed on a sub-domain and use it to power a REST API. That works great too and allows me to use each tool to its best abilities. Don't lock yourself into one tool and declare yourself done. At one point CodeIgniter was great, and then Laravel came along. In five years Laravel could go the same way and we'll all be using something else. Never stop learning, build your skillset, and become a better developer.
I think typo3 is also up there when it comes with it comes to ridiculous complexity. Hint: If you decide your CMS should have support for its own programming language, you're doing something wrong.
Hey, screenshot links in the readme are broken when I view it.
I just remind people that a lot of good code has been written with "bad" languages, and visa versa. PHP is popular so you see a lot of bad code, but all the bad code is made by people and it is entirely possible to write good code in PHP.
.. and the github page does not work.
&gt; It seemed the main problems were the design of the app, and in inexperienced approach to account handling; not the absence of linux-only features. Well, since you like to make assumptions, I'll clear things up for you. I've already built a fully featured webapp that manages their 800k+ photo library, client accounts, payments and analytics. I'm now building a lightweight PHP app that they're currently already using to replace their previous workflow that required 3 different windows programs and a lot of manual clicking and dragging and renaming of things. This 'thumbnailing and uploading' app has already made their life MUCH easier, works flawlessly; but, the uploading could be faster. Which is why I'm here, asking for help. Could I have done various things and gotten it done on my own? Sure, but why not ask people who likely have more experience than I working with PHP on Windows? I'm not too proud to do that. Why am I not charging? Because the client is a family member and I don't want or need their money. I have paying clients for that. I bite off more than I can chew all the time, but never for paying clients ;)
Thank you for taking the time to illustrate this!
Yes, that was "just an example" and indeed a router component can fix that. Maybe it was a bad example. The point I was trying to make is that you will have to think about how to tie things together whereas the people who wrote a framework already did that work for you. The Silex framework I mentioned does exactly what you want: you can use as little as nothing of it or you can make it as big and complex as you want. But still: it does give the toolbox to help you with that job instead of you will have to start from scratch each time. Still though: in the end it's just about getting the job done either way :)
For clarity, it isn't my view that people _may_ not discuss the post in two places, but that there is increased value if it is all in one place. People may well click on the top bar, but they would not necessarily know it has already been posted in a related sub. Thanks for the feedback though - I will ease off mentioning it, unless it is x-posting from one user. 
You seem mad bro, have a snickers... As I have said, it is your application design that is fundamentally flawed, not the windows platform; which is flawed, but not within the context of the app you have described! If there is a problem with the description, perhaps ammend it. 
Don't do it if you value your sanity. This thing is enterprise for enterprise's sake.
&gt; The point I was trying to make is that you will have to think about how to tie things together whereas the people who wrote a framework already did that work for you. I guess this shows our difference of perspective. I already know how to tie things together (I mean, it's fairly simple, it's not a lot of code and you can have a template to start with for a new project), so someone else doing it for me is a drawback, not an aid. Consider that a framework author is building a "generic solution" without any regard for your specific project needs. Not all apps are the same by far, and being able to replace components one by one is essential for the longevity of a codebase. All Silex does is combine together Symfony components. If I want to replace one of those Symfony components with another, there's no simple way for me to do it, Symfony's interfaces are not designed to be easily replaceable - consider the HttpKernel, very minimal, one method, right? Yet it takes a Symfony request and returns a Symfony response, and those are gigantic composite objects made of other composite objects. Any third party component that doesn't speak "Symfony" can't play in the Silex sandbox because it can't use the same Symfony objects. This is why PSR-7 happened, but there are many other such tie-ins to Symfony for which we don't have a PSR standard and adapters. So Silex may seem minimal and decoupled, but it's anything but. It's simply Symfony Light. Also, in Silex the Application class is a god object that combines routing, handler creation, dependency injection and dispatching (among other things). If you need to tease those apart to customize &amp; control them, you have to fork Silex. Which, as I said is undesirable, as a framework repository is typically not designed to be "forkable" - a lot of reusable code is mixed in with the "glue code" and if you fork it, you need to maintain it all. I support the idea of there being a public "app skeleton" which we can download and use as a starting point for our projects. And many frameworks have that. The problem is that the "tieing things together" code is in the framework (reusable code) and not in the app skeleton (customizable code). Most PHP frameworks are like that - they don't separate reusable and customizable code in a way that gives app developers control over their own app architecture. Maybe the framework authors feel the need to maintain control and dictate architecture to the app developers, or more likely it's simply where we are in our state of art right now. We've more to learn.
WordPress refuses to change minimum versions until the metrics justify it. Currently 13.7% of active installations are running on PHP 5.2.x and 33.2% are on 5.3. That's ~8% of the *internet* that can still receive application-level security updates even if they're not able to receive server-level updates. I call that a good thing. At the same time, the lead developers have data so specific that they use it to go directly to hosts to tell them which customers haven't chosen to update their environments, etc. so that hosts can proactively and very specifically pull all their versions up. Not to mention they [do push new users to use supported versions of PHP](https://wordpress.org/about/requirements/). There just isn't a compelling technological reason to upgrade given that distros tend to backport security fixes to their own PHP releases. It'd be tons of new shininess at the expense of forwards compatibility for nearly half of the active installations in the wild.
### Perhaps a more useful description Hi all, #### The Problem I'm having an issue with something I made for a family member. I wrote a PHP app using [flysystem](https://github.com/thephpleague/flysystem) to upload images. My family member processes in the region of 10k photo's a day, but it's synchronous. #### The high-level process is simple * Scan ***n*** sources, *provisioned via flysystem* * Create a Thumbnail for each image * Upload the original image #### More Info I'm looking for a way to upload multiple files asynchronously preferably via SFTP on a *high-end* windows laptop; and while I would consider using vagrant, I am concerned that my family member might faff with my work and fuck everything up. &gt; **N.b.** This is a hobby project, and although my family member is likely running a sizeable operation, I am not interested in making this commercial. &gt; **P.P.S** I am awesome, nothing I have ever said or done is worthy of critique, if you do try to critique in order to help me, I'll ignore your positive intentions; I'll suggest you are deficient in some way; you have problems, and tell you about how ***amazing*** I am. All solutions should be in code form so I can copy and paste, and when I am done, rather than contribute to the thread you have all tried helping me with, I'll just tell you I have a solution, so in 10 years time, there will be a million threads asking this question, and nobody will have any answers...
But that's my point, you can't use it to quickly assign to variable A the value of variable B or a default without setting B if it isn't yet; which is what the new addition to the language we're talking about ( ?? ) will allow us to do. In the example you answered too, echo (isset($foobar) ? $foobar : 'nothing); He isn't validating the content of $foobar. In fact for all you know the content of $foobar is holy and should not be altered at any cost. I too use a similar replacement (it's probably something everyone wrote in their first week once the realized they wrote the same isset every 3 lines), but it is not a proper replacement/alternative to a proper solution like the one coming.
The flexibility and speed that you can create a complex content driven site in EE is pretty amazing. Just like any framework or tool available, finding what fits your requirements best is what is important. Expression Engine also has a strong Stack Exchange site that has a pretty high Answer percentage and has a great community revolving around it. (http://expressionengine.stackexchange.com/) EE does have a learning curve, but once you understand how it works, how simply it can be extended and the large quantity of quality plugins available (http://devot-ee.com), EE becomes a tool that can quickly and securely develop easy to use, solid sites. Being part of of the EE community, i have never had and bad feelings from within, just from other people who may not understand or care to learn how the CMS works, or don't want to be part of the community. 
clearly they didn't run their unit tests...
do it! It won't hurt and you'll trounce the competition. PLUS once you show them what you can do, they will be more open to listening to you!
That sounds fair.
You're right, learning is not a bad thing. My objection is that I would prefer learning things/tools like git, testing, design patterns, deployment strategies etc, than learning a CMS from scratch that will require far more time for me to master.
This is not a support subreddit. In any case, just add the following lines before the mail() method and check if your data is there: var_dump($name); var_dump($number); var_dump($email); var_dump($comment); Enable debugging options in the php.ini and see if any errors appear. If you plan on working more with PHP, get PHPStorm, enable xDebug and learn how to use the debugger. Also, read and do this: https://stackoverflow.com/questions/845021/how-to-get-useful-error-messages-in-php
Nothing detailed yet. The author allegedly ran a collision test but didn't report back yet. See comments [here](http://jenssegers.be/blog/67/id-transformation-with-optimus).
Okays, someone could explain to idiot what practical usages this haves. I can't imagine anything but preventing id showing in url, but that can't cause any harm (right?) or you could replace id with username or something
The horror!
If you have ids as get parameters users could reach pages they shouldn't by guessing ids (which the application should prevent anyway). The only other thing I could think of is that users could take something from the numbers they can see, if you have an application where the user can create objects he could create two objects with some time in between and make assumptions from the difference of the ids (e.g. user activity) or something
Roots looks promising! I think the implication is that there won't be enough new projects (web apps) to sustain my Laravel-work. On the other hand, there are Wordpress-presentational-website projects that need to be done, so I need to learn how to do that, in order to keep my position and the company going.
Not necessarily. You can use dependency injection for most things instead of Facades and helper functions.
Depends on what kind of spam filtering they are doing. It might also be that they do not have the PHP Mail functions available to prevent people from spamming via PHP.
&gt; you could have inherited a codebase that's locked to a legacy version of PHP with a home grown "framework", globals everywhere, etc. Been there done that. I more than once had to debug and implement features to a web app like you described, except it was sitting on Laravel. I'm talking spaghetti functions, hundreds of DB queries per page, blade template code mixed with PHP echo's inside config files (I'm not talking about view paths, but ACTUAL view data inside config files), and the like. Such fun.
Fair enough!
I will do that.
I've gone through a lot of pain and tears over the past 10 years trying to deal with sending mail from my own servers. It's very difficult to get your web server trusted with a lot of mail clients. Try running your servers IP address through spamhaus (https://www.spamhaus.org/) to see if you are blocked. If you are they have a process you can go through to whitelist it. One thing you may consider, is using a sass provider such as Sendgrid. These days this is what I do because I just got so fed up with my email always being considered spam from my own server. Sendgrid on the other hand has a free tier that lets you send 16,000 emails a month (which for me was way more than enough) and their servers are trusted. I've never had an issue with an email considered spam coming from them. You can easily send your email via Sendgrid by using SMTP or a REST call by updating your server configuration or modifying this PHP script slightly. Their instructions are very easy to understand. Regardless, good luck with your project!
Laravel would like to have a word with you.
I'd like to add that; if disabled, a lot of hosting companies will enable PHP mail once you ask, they may ask you to provide a couple details about how it will be used. I don't see any red flags in the script but I can't back what u/ultio said enough, learn to debug PHP. Without using an extra debugging tools, I would print the input right from the start, then you can rule out your form not being setup correctly. After that dump the variables. If you've gotten this far you know php mail is getting all the info it needs to work. Then you can also print the response of php mail. $result = mail($to, $subject, $body); print_r($result); Should that result be true then you know that your script is working fine and it's something external from your script, like IP reputation or server config that is causing your mail not to send. If it does turn out that it's your hosting company and they aren't willing to unblock it, you can use a service like Mandrill to send your mail or as an email alternative, Slack to push alerts to. Both work via API and have PHP packages.
This whole argument about being open minded and learning new tools is great but falls down when you sit and really think about the finite time we often have available to us. That also coupled with the often crippling feeling of imposter syndrome you can understand why developers like to stick to what they know sometimes. Never stop learning of course, but not at the expense of your sanity :) additionally op, I am looking to hire a trustworthy remote Laravel developer ;) 
And you seem to have deficits relating to reading comprehension and people skills. I'm not at all mad, bro. I appreciate your time and energy to tell me how poor of a developer I am, how poorly my application is designed, but offer nothing of substance that helps. Meanwhile, I've solved the problem thanks to some input from constructive advice from other users. I hope you have a wonderful day :)
I was so angry for the time lost doing this test that I took 15min writing an article. https://www.reddit.com/r/PHP/comments/3dz8hi/is_it_me_or_laravel_lumen_is_actually_pure_sham/ ;-) I know I'll be quite alone.
Like OP, I was puzzled what does Lumen have to do with "micro-services". It's like whoever wrote the copy was skimming headlines on /r/programming and just liked how "micro-services" rolls off the tongue.
I don't know how to count 40k visitors (is it 40k visits or N page views per visitor?), but if it's 40k visits, and let's spread them over 8 hours (and not 24) to account for uneven load during different hours of the day, you get ~1.38 visit/sec. Any of the mainstream frameworks can handle couple of visits a second on modern hardware, anything less would be tragic (it depends on your app code too, but you know what I mean). Laravel is kinda heavy (maybe the slowest of the popular ones right now), but it doesn't matter, because many projects never reach the kind of traffic where the framework becomes a bottleneck. If you pay per CPU minute, however, you may see larger bills with Laravel than with leaner components.
O kurwa. Polish word...
I noticed on your video, in your browser you specify a port - but in your ab test the port is missing (so defaults to 80). Maybe the ab wasn't hitting what you think it's hitting?
That's because I am running ab from within the VM, while in my browser I'm on the host machine so need to use port forwarding. So, it is correct. All of that would also be moot on a Forge server where I get the same results.
WordPress has improved a lot since then. Add Advanced Custom Fields and you can do a lot. 
There aren't easy suggestions either OP or anyone can give you. You keep going with the solution that works until it stops working. And when it stops, it pays to be aware &amp; ready to go for an alternative. This post is about awareness.
I like the idea, but i really think you should use a more PC term, instead of Bullshit. edit: Closed and locked.
If the benchmarks were real they would be submitted to the Techempower Framework Benchmarks site ( google it). They do objective reproducable comparisons. A year ago I submitted PHPixie there to prove my claims. Until I see Lumen there I wont believe any made up numbers
I honestly find it hard to believe that Lumen is faster than Slim 2, especially considering that Slim 2 is only a handful of classes with minimal functionality, while Lumen is basically the entire Laravel framework.
Because use is importing from the global scope, not the local scope.
Unless you sometimes WANT to run the "bullshit" tests.
/u/philsturgeon talks about this a bit, but one of the drawbacks of using sequential IDs is that your API can get scraped quite easily. If you have a data-driven service (like IMDb, for example) and use sequential IDs then a competitor could pull all your data in 3 LOC, and have a new product up in no time at all...
They are the worst!
&gt; # In the philosophy of truth and rhetoric &gt; **Assertions of fact** &gt; Bullshit is commonly used to describe statements made by people more concerned with the response of the audience than in truth and accuracy, such as goal-oriented statements made in the field of politics or advertising. On one prominent occasion, the word itself was part of a controversial advertisement. During the 1980 U.S. presidential campaign, the Citizens Party candidate Barry Commoner ran a radio advertisement that began with an actor exclaiming: "Bullshit! Carter, Reagan and Anderson, it's all bullshit!" NBC refused to run the advertisement because of its use of the expletive, but Commoner's campaign successfully appealed to the Federal Communications Commission to allow the advertisement to run unedited. &gt; **Distinguished from lying** &gt; "Bullshit" does not necessarily have to be a complete fabrication; with only basic knowledge about a topic, bullshit is often used to make the audience believe that one knows far more about the topic by feigning total certainty or making probable predictions. It may also merely be "filler" or nonsense that, by virtue of its style or wording, gives the impression that it actually means something. &gt; In his essay on the subject, William G. Perry called bull[shit] "relevancies, however relevant, without data" and gave a definition of the verb "to bull[shit]" as follows: &gt; &gt; To discourse upon the contexts, frames of reference and points of observation which would determine the origin, nature, and meaning of data if one had any. To present evidence of an understanding of form in the hope that the reader may be deceived into supposing a familiarity with content. &gt; The bullshitter generally either knows the statements are likely false, exaggerated, and in other ways misleading or has no interest in their factual accuracy one way or the other. "Talking bullshit" is thus a lesser form of lying, and is likely to elicit a correspondingly weaker emotional response: whereas an obvious liar may be greeted with derision, outrage, or anger, an exponent of bullshit tends to be dismissed with an indifferent sneer. https://en.wikipedia.org/wiki/Bullshit#In_the_philosophy_of_truth_and_rhetoric --- &gt; #Bullshit asymmetry principle &gt; Publicly formulated the first time on January 2013 by Alberto Brandolini, an Italian programmer, the Bullshit Asymmetry Principle (also known as Brandolini’s law) states that: &gt; &gt; The amount of energy needed to refute bullshit is an order of magnitude bigger than to produce it. https://en.wikipedia.org/wiki/Bullshit#Bullshit_asymmetry_principle
LOC is probably not a good measure, but if you start digging you'll find the term "micro-framework" is, in fact, impossible to define. Yet another meaningless buzzword.
Don't forget the Error with ID: 10-T
If you want to see horror, here ya go: https://codex.wordpress.org/The_Loop and the following function: https://codex.wordpress.org/Function_Reference/have_posts &gt; Calling this function within The Loop will cause an infinite loop.
My opinion: A microframework is below 10K SLOC
Sure. But once you installed Lumen you got this huge vendor folder, used by the framework.
https://codex.wordpress.org/The_Loop requires you to use https://codex.wordpress.org/Function_Reference/have_posts which has the following note: &gt; Calling this function within The Loop will cause an infinite loop. Effectively, the concept they use is a circular array with an empty spot in it to denote the end. If an filled spot is accessed, it stays at that spot, until the data is read out. If the empty spot is accessed it directly moves to the next spot, and the above applies again after that.
http://taylorotwell.com/how-lumen-is-benchmarked/
so what?
I already use markTestIncomplete when a test is crap and needs to be re-examined
Analysis and design are "two sides of the same coin". One (analysis) is taking things apart, and the other (design) is putting things together. Analysis is about studying something and understanding itself, its parts, and properties involved. Design is about deriving something by combining things with interesting properties in interesting ways. Analyzing just mean reasoning about something so you understand it (or some aspects of it) better. 
This is painful. Wait, do I see a lot of functions there without any argument?
lol.. was asking a serious question. Why 10k? why not 30k? why not 100k? do you include external dependencies? if not why not? what is the advantage of 10k SLOC over any other number? You can write 10k lines of incredibly slow code.. so speed isn't the reason... 
Yup, they all interact with the global $wp_query and related global variables.
It's his opinion. It's like asking why Twitter made tweets 140 chars. Why not 141? Because reasons. Hard definitions may be arbitrary, [but they work.](https://en.wikipedia.org/wiki/64k_intro) In fact, I propose microframeworks be 64kb (that'd be close to 10K LOC, BTW). 65536 bytes. A nice, *round* number...
You had me at *global*.
Yes... my question is *why?* Doing `use \Vendor\...` works, so why not use that for importing from global scope, and have the lack of backslash import from the local scope? Then it would be consistent with the rest of your code.
The TechEmpower benchmarks are very, very well done. I gave up my own benchmarking project in its favor.
&gt; Which one are the best tools for Design and Analysing objects? I suppose we can put UML diagraming tools and high-level static analysis tools in that category (for example tools which plot the graph of dependencies in your code; what uses what). There aren't any *required* tools, though. "OO design and analysis" means being able to reason how project requirements are best modeled as objects, knowing pros and cons of the common design patterns, recognizing them in existing code, and thinking in objects in general. For PHP, high-level analysis tools are slightly harder to come by than for, say, Java. I tend to do my PHP "OO design and analysis" with pen and paper, or a white board, and it's good enough most of the time. 
Those fall in the "PHP Sucks" attitude category, and don't offer actual, meaningful criticism
except that the images are showing on http://visualphpunit.github.io/VisualPHPUnit/ which means the bug is on the github side.
and that is why you never create or implement your own algorithm, but instead use build-in functions, as bugs in those are way more likely to be found and fixed. (and have even more respect for those that do write those build-in functions)
In this case 'viewsRequired' is another column name in the database, there is no need for escaping. If you're allowing dynamic fields (e.g. based on user input) then you should have a whitelist.
No idea really.
This article isn't really about defensive programming - it's just standard practices that everyone should be using already like consistent naming and not trusting user input.
Faaaanks... Honestly, throughout this, I think you have been as much of a dick, as anyone I have dealt with this year; and not taken anything as more than an attack, instantly becoming defensive, when none of my comments were intended in this way. I didn't say "Get off the internet scum" did I? Instead I took the time to quote you, so you could understand what you wrote that led to my iterative understanding of ***your problem***. I'm glad you think you have a solution, and would suggest linking to a github at least privately to those you feel did help, as the whole point of reddit is that it is a community, not your personal bouncing board, or support hotline.
I think he's just suggesting you have a dog in this fight, not that you faked it or anything. Techempower at least provides the appearance of impartiality. 
The problem is that Wordpress is still a buzzword, and the unfortunate fact is that clients respond to buzzwords. Sometimes we have to take a bite out of that shit-sandwich in order to give clients what they want. I still do quite a few Wordpress websites. In the spectrum of "Fast, Cheap, and Good", Wordpress covers "Fast" and "Cheap". It's easy as hell to roll out a site built on top of Wordpress, but the codebase is still garbage, and the organization comes from an era before PHP developers even cared about a little thing called "separation of concerns". But it has its place, and if you have a client that doesn't see the benefit in coming up with the extra money in focusing on the "Good" aspect of their web application, then Wordpress is worth knowing. With all of that in mind, learning Wordpress isn't going to be your major concern. Your real concern is going to be security, and Wordpress has more holes than a campaign promise. 1) Install [Wordfence](https://wordpress.org/plugins/wordfence/) 2) Disable trackbacks, pingbacks, and seal off xmlrpc.php 3) Deny access from requests that don't have a user agent Every single compromised server I've ever dealt with was because of Wordpress. The minute you install it, it WILL get hit with bots. If that doesn't dissuade your boss, then you're either going to have to suck it up and deal with writing the best code you can for a sub-par tool, or find a new job.
I really doubt you could cause security issues unless you do something really weird, like enabling it to overwrite various other variables from get or post calls.
look at the [commit](https://github.com/malkusch/phpunit/commit/6f4ded97ddca778ca861ff7689f6adc724c9118a). that's just a crazy amount of boilerplate to add such a simple feature. i wanted to add a new assertion the other month...god, i had to implement so much crap. i'm still not sure what all of it does.
Are these even hashes? They're decodable!
I agree here, throwing in the towel when faced using a different tool doesn't make a dev any better. But, if you aren't happy, leave. A new challenge is awesome, and that is why I program. 
Hold on a second... You don't curse in your repo?
Unless you're Linus Torvalds, that kind of language in code is juvenile, by my reckoning.
Not sure why I said single, definitely meant a minimal amount. Thanks for pointing it out.
Well what if it comes from user input. You cant just not escape it
You should not have to guess or try hard to understand code. Code should be written so it's understandable and reasonable as soon as possible. function work(array $a) { extract($a); // no one can be sure what variables are now in scope }
Extract is useful for templating libraries. I have not come across other uses yet. You definitely should not use it in your "normal" code.
I can answer: is it the result of a heavy comparison work, that included many criterias. I found that all of the micro frameworks falls below that limit. I can provide the list of them. In this regard, the best ratio features/sloc was fatfree. 
my answer just above. We are talking about speed because it is advertized ont it. Sure it is faster than Laravel, but it is far from the fastest. While it is among the fatest. 
done it. Fat free is among the fastest. 
Great Article, good to see that they reduced the load on their server by 50% and reducing the response time by half!
I meant, It is part of the framework, because the framework uses it: Symfony components, illuminates folder... 
It's juvenile when Linus says it, too.
Unpublished results are unpublished. Why should yours be believed but Taylor's not?
I don't know why you were downvoted. Presumably people don't realise big frameworks like Laravel use this in their templating engines.
Basically every query builder would like to have a word with me :) They almost all implement the same Api pattern ( Kohana, FuelPHP, Laravel, AuraPHP, CCF, Codeigniter, FluentPDO ) and so does Hydrahon. 
&gt; when you use a framework, it enters in the codebase of your maintainance? Er, i'd disagree. When you choose to use someone else's code (be that a library or a framework) you are in part choosing to do so in order to offload some of the maintenance overhead to them. I am not responsible for maintaining Symfony Components in my application anymore than you are for maintaining F3. &gt; You got linked not to a framework, but to a particular version of a framework. True of any framework you select. The size of the framework rarely matters. How much you intertwine your code with that framework does. You can minimise the impact of an upgrade (or wholesale framework change) by being selective about how much of the framework your code knows about. &gt; Think about it. You used Laravel 3 because you tought it was the best at that time. Then they moved to v5. They went from 3 to 4, an upgrade I didn't perform myself, but 4 to 5 was not that hard. A day's worth of work at most. And upgrading is one option. Another option is to not upgrade and be satisfied with your framework for as long as security updates keep coming your way, at which point you have to make that difficult choice again....You could at this point DECIDE that the framework is your responsibility and start patching it yourself. Or you could take the upgrade pain. Choices. And the difficulty of those choices are largely down to how you as a developer have done your job, not the tool you've selected to help you along the way. &gt; Another thought: more files means more risks regarding security. Maybe. But I'll take carefully selected components which are used by a large number of users and subject to rigorous security tests over something just because it's small, thank you. It's all about risk, and how you mitigate it. Besides, these points have nothing to do with your original premise - that Lumen is not a microframework because it's larger than 10k LOC, and that somehow this is linked to PERFORMANCE. Really the only justification I could come up with is the cognitive load of having the entire framework's codebase in your head at once. And IF that's important then 10k LOC is probably the most anyone could manage. But I don't know where storing a framework in your head like this would be useful. More useful to store your app code in your head I'd think? Unless you're actually writing the framework. Your whole article is... kind of weirdly aggressive. Your point that Lumen's benchmarks may be misleading is probably a valid one to make, but to accuse it of being a sham, to all but accuse it's author of falsifying the results... to conclude that it's only reason for existing is because Laravel's performance is "pathetic" (hint, it's not. It just doesn't see performance as it's major reason for being. It's trading performance for utility. The safer conclusion is that Lumen exists so that Taylor can have a framework for cases where performance is more important than utility while retaining a familiar API... which is a valid enough reason for writing it!) is unnecessary and disrespectful, and detracts from your point.
Twitter made tweets 140 characters because originally they were conceived as being sent and received via SMS which has a message limit of 140 characters when you take into account all the various services. The SMS part went away over time, but the limit stayed.
I am happy to have that kind of discussion with you. Even if we do not agree ;-) I agree the article appears aggressive. But I confirm that I think that the author is falsifying the results. Regarding Laravel. "pathetic" is the right word for its perf. I agree it is a deliberate choice, but to me it is not trading, but replacing performance for utility. That being said, what is the purpose of a framework? you will say "it depends on your goals" ;-) To me performance matters. Otherwise my opinion is that it should be a concentration of best pratices so that you that reinvent the wheel + you could work in group. 
Extract can be sandboxed within a function. it is not bad by itself, it is used internally by most of the templating engines. That being said, my personal "good practice" says that you should avoid using it just because of your laziness. ;-) 
&gt; I agree the article appears aggressive. But I confirm that I think that the author is falsifying the results. At least you're honest I guess. On what basis do you conclude that Taylor has falsified his results? That's a fairly big accusation to level at somebody. Quite an unprofessional thing to do if you don't have evidence. You've not shown anything conclusive in this regard. &gt; Regarding Laravel. "pathetic" is the right word for its perf. I agree it is a deliberate choice, but to me it is not trading, but replacing performance for utility. Its performance is more than adequate for what it does. Nowhere near "pathetic". I mean it's not as fast as fat free, but it **does more**. You pay for that. That's a trade off. You absolutely ARE trading. You give up one thing in trade for another thing. If you don't like the trade off, don't make it. But don't go around calling other peoples' work "pathetic". &gt; but replacing performance for utility. Which is exactly trading. So again, your point is? &gt; That being said, what is the purpose of a framework? you will say "it depends on your goals" ;-) To me performance matters. Of course performance matters. But micro optimisations don't. And if you get to the point where Laravel itself becomes the bottleneck (and the cases for this are most certainly not in the main).. guess what, you can use Lumen to write a service which offloads just that portion of the performance problem onto another server somewhere. Or you can use Slim to do the same. Or you can go and write something in C and use that as a service... the point is you have choices. Your claims that Laravel's performance is "pathetic" is ... well ... pretty laughable. Your conclusion that Lumen is somehow an *admission* of that patheticness betrays a pretty serious case of not getting it. You could have written your article in a manner which wasn't disrespecful, taken the higher ground, asked some actual serious questions and analysed the answers.. instead you decided to take the low road. And I'm left wondering why? what is the point? 
don't do anything more, once a video is out there, that is it.
To be honest it doesn't surprise me, but 5r/s is probably enough for a 12 user web-app taking enterprise speeds, and the fact people are not machines into consideration. The problem with simplistic logic, and using benchmarks to decide a stack, is that benchmarks are only good for a code-base that is under a consistent load, with consistent data, working with robots. I would also doubt 200 r/s for most complex web-apps on a single node, with end-points requiring auth. This is why we cloud, and in any case the app would not do much for 200 r/s.
If you want to run it, it's probably not a bullshit test. Poorly written or covering annoying code, but not meaningless. 
Yeah, but he's earned the right to be juvenile. 
Well he did fisprove a claim by expetiment. The 'why' is really not his burden
Just give it a sensible name, you're not 15 years old
&gt; Seems like you still believe the less code and less files magically equals more performance. It is a principle of physics ;-) Il applies to computer science too: The less you do, the faster you can do it. I think you are the one believing in magics. &gt; unprofessional piece Where do you see it unprofessional? I just took 15min more to report an evidence that should be known. Let apart it should be obvious. 
&gt; It is more relevant than testing in a local VM or in your local PC. Absolutely true. &gt; still flawed because client is in the same machine. Also absolutely true; however, it is less flawed than doing it "in a local VM or in your local PC." Basically, if someone cannot publish written-down step-by-step instructions, or a script, to run their benchmark on widely-available platforms, especially with AWS available to all, then it's not to be trusted. EDIT: Speaking of which, are your instructions published somewhere?
if you feel like laughing, please look at the techempower benchmarks https://www.techempower.com/benchmarks/ IMHO Lumen should just become the next version of Laravel. ;-) 
Probably by using this: https://developer.github.com/v3/repos/#get
many businesses do everything you're describing with Magento
http://superuser.com/questions/227509/git-ping-check-if-remote-repository-exists#answers-header `git ls-remote` appears as if it would do it for it and not limit it to github.
many years ago, we sold a 250k line project to some british conglomerate. the deal was, naturally, subject to passing the buyer's internal code review. i spent four days reading every comment and deleting/editing all the juvenile crap my co-devs had inserted, thinking they were speaking exclusively to the private audience of their peers. so, no. i don't curse in my repo.
(Author here) It's definitely defensive programming (which, as you say, everyone should be using). It's intended to be a high level overview though, and perhaps I should've made that a little clearer. Almost the entirety of this article is on subjects that experienced PHP devs should already be doing - it's a reminder at best. Given the feedback, I'm considering doing a more practical and advanced guide made up primarily of coding examples and such as a Part II later on some time - it's on the list anyway.
GitHub's API is wonderful, I got the chance to work on it when working on [Ship](http://ship.getherbert.com). Their API has the [perfect method](https://developer.github.com/v3/repos/#get) for what you're wanting :-). It has a key (private) which is used for this. Though (unless you're a member or owner of the repository) it'll throw a 404 on the API if it's not public anyway.
Isn't Odoo PHP-based?
When you fucktards have an app that needs more that 100 requests per second let me know. 
&gt; I think he meant the creation method of a factory class. That is not a factory. A factory is something like this: class FooFactory { private $dbConnection; private $logger; function __construct(DBConnection $dbConnection, Logger $logger) { $this-&gt;dbConnection = $dbConnection; $this-&gt;logger = $logger; } function create($info) { return new Foo($this-&gt;dbConnection, $this-&gt;logger, $info); } } Having it be an instance allow the presence of DBConnection and Logger to be encapsulated away. The class that depends on the factory (and will be calling `$fooFactory-&gt;create($info))` doesn't need to know about DBConnection or Logger - it only needs to know about the factory. If it's a static method then it doesn't encapsulate anything. 
Thanks for clarifying. My knowledge of the factory pattern was limited to what's described on [phptherightway](http://www.phptherightway.com/pages/Design-Patterns.html) , but the example doesn't encapsulate anything, it just prevents duplicating code if creating the object is more complicated. I guess your example makes more sense.
One reason static methods look better to you is because you're using "new" in a curious way here. Just so we're on the same page, what your second code example reads like is this: "I create a new middleware, I register this function at it, and I throw the middleware away". Chances are you don't want to throw away something you've just set up. You want to keep it around and use it. So why do you throw it away? The static example is also curious. Do you always have just *one* middleware? Ever? That's odd, maybe the class is named incorrectly. Static vs. non-static depends a lot on intent, so we need to understand intent before we can give good advice.
The problem here is that there is no built-in function which does this. The `shuffle` function, while unbiased, is also predictable. So it's not usable for purposes where predictability actually matters, the standard example being shuffling a Poker deck. If you shuffle a Poker deck using `shuffle()` you'll loose a lot of money, fast. From which we conclude: We should add a `random_shuffle()` function which does a cryptographically secure shuffle...
Blog spam that really has nothing to do with PHP... 
The middleware example look like Laravel so I assume the static version is a facade.
Nope. Also, please let's avoid Laravel-specific term misappropriations when not talking about Laravel :P
&gt; Nope. OK my bad. &gt; Also, please let's avoid Laravel-specific term misappropriations when not talking about Laravel :P What a non-sentence. Clearly I would have if I didn't think it was Laravel.
Your FooFactory::create method is using local variables that are not present - $logger and $dbConnection
&gt; (new Class)-&gt;method() &gt; or &gt; Class::method() So, static methods are properties that belong to the class itself and are propagated to all instances of that object. What kind of situations is that behaviour useful in, rather than harmful? 1) Instances where the class is a singleton and instantiating multiple objects from that class will simply never happen and/or 2) Instances where *all* objects of that class have no state whatsoever A front controller is an example of the first; a one-way naive logger, the second Should you use static methods just because they map well? Well, it makes static analysis easier (no surprise) which increases the legibility of the code for those with modern IDEs.
MediaWiki
&gt; Between keeping more websites more secure for longer (even though it permits shitty hosts to keep being shitty a little longer) and abandoning sites to a host of problems en masse for the sake of stroking an ideological purity stick, I'd pick the former. When a system is insecure on the system level, because it has an outdated and insecure PHP version, there is basically nothing you can do on the application level to make it more secure. &gt; The core team literally couldn't find hosts that offer 5.2 any more when they were developing automatic updates in 2013. Then why still keep supporting PHP 5.2? &gt; Without the customer's initiative, upgrading all those accounts takes a long time because of the potential loss in money if the host breaks a customer's site. Yes, and without raising the minimum system requirement, they don't cause the customer to take initiative, because there is no need to upgrade. Take a look at Drupal and Wordpress. Drupal 7, released on Jan 5, 2011, required PHP 5.2, to permit those that ran Drupal 6, which had modules that were incompatible with PHP 5.3 basically to upgrade without having to worry about the PHP version, However, it strongly suggested at least PHP 5.3 the latest supported PHP version, Drupal 8 will require PHP 5.5 at least. Wordpress 3.0 was released on June 17, 2010 which required at least PHP 5.2 which, at that moment was the supported version of PHP, and you don't hear me complaining about that. Wordpress 4.0 was released on September 4, 2014, less than 1 year ago and still only requires PHP 5.2 I don't mind Wordpress 3 getting security updates and still supporting PHP 5.2, I do mind Wordpress 4 still supporting PHP 5.2 It's like releasing a new version of your software in 2011 with a minimum system requirement of PHP 4.4 &gt; Also, as long as the PHP core team continues to drop support for PHP versions that account for ~80% of their market share, they're going to be creating this problem for themselves. We already know that support for PHP 7.0 will stop on Nov 12, 2018
&gt; In the above example, adding a pepper could mean replacing hash('sha256', $_POST['password'], true) with hash_hmac('sha256', $_POST['password'], CONSTANT_SECRET_KEY, true). We do not recommend this approach. &gt; Peppers do not add any meaningful security above and beyond the salt that password_hash() generates for you. That's not factual though, is it. Salt is public, it's often a part of the final hash. Pepper is stored separately and never exposed on purpose, so it's a secret. If your attacker has access to the database, and database only, which is *quite common in real-world attacks*, then they have access to the hash and salt, but not the pepper. Defense at depth does include layers of seemingly redundant measures, but added together they improve security due to the different context of the attacks, which can go through some of those layers, but not others. The same reasoning that goes with "pepper doesn't do anything salt doesn't already do" can go for two-factor authentication: "an SMS with secret code doesn't do anything a password doesn't already do". But it's instantly obvious why it's not the case; the information comes from different channels. The attacker may not have access to *all* those channels at once. Even if you decide to argue pepper doesn't *help*, you certainly can't argue it does *damage*. It's at best neutral. So why not do it? Do it if you want, you've got nothing to lose no matter who's right in that argument. &gt; Password policies (especially shameful ones) are usually a dead give-away that an application doesn't employ proper password hashing. &gt; [...] Establishing minimum requirements (e.g. password must be at least 12 characters long) is fine &gt; [...] Your zxcvbn password strength must be at least level 3 (on the 0-4 scale). Contradicting advice detected. How can you say "password policies are a dead give-away for no proper password hashing" and then start listing password policies? Surely you don't consider it secure to have an app that allows the password to be "p"? So the advice is more like "don't have bad policies, have good ones". &gt; To clarify: if one changes first byte in the rememberme cookie from an W to an X the comparison will fail slightly faster than if the last character was incremented from n to o. This *may* apply to B-tree indexes in some databases, but doesn't apply to hash indexes, for ex. Details matter. Also I don't think a practical remote attack against an SQL B-Tree index has been demonstrated for a real-world application (and not just an isolated local attack against that B-tree with nothing else running). &gt; Google's Anthony Ferrara covered this topic in his blog post, It's All About Time. It's inappropriate to drag Google's name in anything Anthony Ferrara says on his *personal blog*. Also, his job at Google is a "developer advocate" not a "security expert". &gt; Even if the query doesn't find a valid entry for the supplied remember me token, attackers get unlimited tries. They can keep re-sending a slightly different cookie until they get their desired result. Especially if your application is not tracking and rate-limiting automatic authentications. So attackers get unlimited tries unless we limit their tries...? I guess it doesn't sound so dramatic put this way. &gt; On the database side of things, the token is not stored wholesale; instead, the SHA-256 hash of token is recorded. With this failsafe in place, if somehow the auth_tokens table is leaked, immediate widespread user impersonation is prevented. If you store the *hash* then looking up back by that hash you've prevented the timing attack from happening. You don't need a selector. Especially if you add pepper so the hash is not predictable (funny we come back to that). &gt; Separate selector from token. &gt; Grab the row in auth_tokens for the given selector &gt; Hash the token provided by the user's cookie with SHA-256 &gt; Compare the SHA-256 hash we generated with the hash stored in the database, using hash_equals() &gt; If step 4 passes, associate the current session with the appropriate user ID I feel this process is starting to look more like superstition-based ritual.
he was talking about laravel lol edit: Downvotes. Classy.
create isn't static
Yeah, I find that just about every time I make something static, I end up either removing the "static" keyword or pulling it off onto another class, as you suggest.
I thought he said it's "**like** Laravel" and not that it "**is** Laravel". Never mind.
DokuWiki is lightweight and stores everything in text files, which is good for a small site. My one problem with it is that there are no built-in file descriptions (and file uploading itself is a bit unintuitive). MediaWiki is good if you know how to edit Wikipedia, but it's harder to setup.
In the biz we call that padding.
Thanks for sharing your thoughts on this blog post. I'll attempt to respond inline: &gt; If your attacker has access to the database, and database only, which is *quite common in real-world attacks*, If I can compromise your database, I can often compromise your filesystem. The best way to mitigate this is to make sure your database and webserver are on separate hardware. Most low-budget websites don't do this. &gt; Contradicting advice detected. Not at all. &gt; How can you say "password policies are a dead give-away for no proper password hashing" and then start listing password policies? Surely you don't consider it secure to have an app that allows the password to be "p"? Maybe read the line after that where I said "Establishing minimum requirements (e.g. password must be at least 12 characters long) is fine..." implying that *not all restrictions are bad*. Or the parenthetical statement (especially shameful ones) wherein I linked to the Password Policy Hall of Shame. If that section confused you that badly, it probably confused others as well, and warrants a rewrite. &gt; This *may* apply to B-tree indexes in some databases, but doesn't apply to hash indexes, for ex. Details matter. See also: [there are no good constant time data structures](https://wingolog.org/archives/2014/12/02/there-are-no-good-constant-time-data-structures) and [Do hash tables work in constant time?](http://lemire.me/blog/archives/2009/08/18/do-hash-tables-work-in-constant-time) &gt; Also I don't think a practical remote attack against an SQL B-Tree index has been demonstrated for a real-world application (and not just an isolated local attack against that B-tree with nothing else running). Funnily enough, if you make the requirements for "real-world" vague enough, you can exclude most vulnerabilities. In security, we have a rule: attacks only get better. So even if nobody has demonstrated one yet, that doesn't mean that no one will. &gt; It's inappropriate to drag Google's name in anything Anthony Ferrara says on his personal blog. You're absolutely right, especially since he's leaving in like a week. I've amended the article. &gt; Also, his job at Google is a "developer advocate" not a "security expert". I never said his **job** was security expert. Is that even a job title one can hold? &gt; Especially if you add pepper so the hash is not predictable (funny we come back to that). This blinds the timing information. We call it "double HMAC", and it is an effective mitigation against timing attacks, provided the second HMAC uses a nonce. (Even a nonce from a weak PRNG will screw up attacks.)
Yes, as I said, it's not just "reasons". They had a good reason. Character limit, minus reasonable upper limit of info that will be in every message. This pressing issue is not open. We know why they did it and it is not arbitrary as much as it might involve some gut and informed guessing.
Follow they money. They all have pros and cons. Im still loving laravel for my own projects, but its probably not widely adopted commercially. If you just pick one and practice good OOP, the others will come to you more quickly. Symfony maybe to start? It is probably the biggest and most widely used commercially, but I dont have a source to back that claim up, so don't take my word.
&gt; If I can compromise your database, I can often compromise your filesystem. That's an arbitrary conclusion. Let's take a typical example: SQL injection where you can modify a SELECT query's WHERE clause, but you can't append other queries (multiquery disabled). Now access my file system. &gt; Maybe read the line after that where I said "Establishing minimum requirements (e.g. password must be at least 12 characters long) is fine..." implying that not all restrictions are bad ones. Read the sentence before next sentence where *you* say that policies are typically a sign of "no proper hashing". The fact your sentences contradict each other is why I'm calling it out. You can definitely word that better. &gt; See also: there are no good constant time data structures and Do hash tables work in constant time? This refers to a data structures' O notation complexity and not timing attack vulnerabilities. &gt; I never said his job was security expert. &gt;:[ When you cite someone and cite their employer, it pretty much reads like "here's security advice from Google". So how we say things matters.
Laravel, Symfony2, and probably Wordpress if you can stomach it. Maybe Drupal too.
There's a general shortage of programmers, so you might want to just choose whichever interests you most (at least that way you'll perhaps enjoy the work more). * Wordpress and something like WooCommerce - companies will obviously pay for online shops, and require support for sometime once they're deployed. * Magento - apparent steep learning curve, very customisable, definite shortage of skills, again - probably used by larger companies. * Symfony - far more 'bespoke' * Slim framework - seems to be gaining a reasonable mindshare .... &lt;/2p&gt; 
symfony. I've seen it used in many other big PHP projects (open and commercial). It is also used heavily by [laravel](https://raw.githubusercontent.com/laravel/framework/5.1/composer.json). It's a well designed set of components and there are so many examples to learn from. Want to build **x** for your project? All you need to do is go to Github and look at how the other FOSS projects use the components.
&gt; That's an arbitrary conclusion. Let's take a typical example: SQL injection where you can modify a SELECT query's WHERE clause, but you can't append other queries (multiquery disabled). I'd also like to point out that as soon as you go beyond basic sites, the database server is physically a different server - so even if you're able to somehow read files local to the DB engine, the code might very well not live anywhere close (where the pepper is).
There is this story, where some guy used social engineering to hijack a domain and gain access to the user's e-mail address. https://medium.com/@N/how-i-lost-my-50-000-twitter-username-24eb09e026dd I am not sure about the phone though; I imagine it would be pretty hard to hijack a phone number.
You shouldn't focus on learning a specific framework. You should focus on learning advanced programming concepts and fundamentals, design patterns, algorithms, etc. All of which can be applied to any PHP project, framework-backed or not. You can certainly pick up on fundamentals by using a framework, seeing how others use it, checking out their internals, etc. I would recommend Symfony since it is one of the most enterprise level fameworks, and generally regarded as the most best practice as well. But don't think in terms of learning the framework -- think in terms of how the framework is built, what problems does it solve, what architecture is used to solve those problems, etc. This is what hiring managers care about.
[Here's a screencast](https://knpuniversity.com/screencast/behat). Notice you can scroll down past the video to read the text version without paying for access to the screencast.
&gt; As for GnuPG, depending on your audience, the average user may not have the technical expertise to or be willing to decrypt a recovery token. When I've deployed these features, I've always made them optional. If the user wishes to trust their email provider (and every router between my server and their email provider's), they can. If they do not, I offer to encrypt with their GPG public key. &gt; Also, is there a particular problem with sending an auth code to a cell phone? Wouldn't that require the attacker to be in possession of the user's phone? There's no problem with auth codes, outside "they're probably sent in the clear", but I'd like to develop a system to send encrypted messages to TextSecure users in the near future. (Maybe even integrate with Twilio.) Just to be sure.
&gt; That's an arbitrary conclusion. Let's take a typical example: SQL injection where you can modify a SELECT query's WHERE clause, but you can't append other queries (multiquery disabled). &gt; &gt; Now access my file system. Subqueries. Example query: $data = $db-&gt;query("SELECT * FROM users WHERE username = '" . $_GET['inject'] . "'"); An exploit might look like this: ' AND userid != (SELECT '&lt;?php eval(base64_decode(gzinflate("someevilcodehere"))));' INTO OUTFILE '/var/www/reverse_shell.php'); -- 
INTO OUTFILE can't be used in nested subqueries. If you're lucky and there's nothing after the injectable parameter (no other params, no ORDER BY, LIMIT etc.) you can give it a shot on the root SELECT query, but then you can't overwrite the SELECT ... clause so you need to insert PHP code into the table being selected so you can write PHP code out from it. 
or `UNION SELECT .... ;-- comment out the rest`, maybe
I'll echo that: I've used dokuwiki on several wiki now. It also supports a concept called wiki farm where you install the software once and run multiple wiki off it, which makes upgrading a lot less tedious if, like me, you're running four or five wiki on the same server. 
If you haven't worked with any frameworks before, I would start with Laravel. It's commercially viable and have a low barrier to entry. It also is a nice stepping stone to the more complex Symfony. If you get to know Laravel and Symfony well it will be easy to pick up other frameworks as needed. You could also take a look at Wordpress, learning enough to customize themes and write plugins is pretty easy. I would stay away from Drupal and Magento for now though, they seem to be almost like separate career paths for a lot of people.
Well it depends on your future clients. If you're looking to freelance for small websites and need to let the customer edit its content, you have to consider using Drupal/WordPress or any user-friendly CMS. They're gonna love the fact to edit everything. However, if you're looking for something more corporate, you should take a look at something heavier, stronger with Symfony, Zend, etc. You're will tend to work for bigger clients (with bigger budgets). But I'm still using Laravel for its simplicity and pureness for my personal projects.
The Content-Type header should have a capital T. Assuming fixing that doesn't resolve the issue: * What is the value of $type? * What are the actual headers that the browser receives? * What is the type and size of the field in which the data is stored? * What is the size of the original file?
Heavy work should be avoided in a web process never mind if it's Java or PHP. The web process should ideally do light processing immediately related to the displayed page and nothing else. A better solution is a task queue. You can look at Gearman (it can tie together PHP, Java, Python etc.) and similar solutions.
if I had to guess, I'd say $type is wrong. Can you output that and see what it is?
Not sure I see the point of this article. 
The first time I had to dig into learning WordPress, I came across this whole loop thing and just immediately knew I was in for a bad time.
Just set it to `application/octet-stream`
CakePHP is created by pragmatic folks with medium level skills, who work on small to medium sites. I'd say it's appropriate for web *sites*, less appropriate for web *apps* (many PHP frameworks aren't, actually). It's not as popular as it was, so you probably won't get many opinions about it here. CakePHP is comparatively slow (so is Laravel), but this doesn't matter for most sites. If you like CakePHP, use CakePHP. It'll be ok.
Thats the thing, I was looking for opinions to see if I would spend time on it or not. Thanks for your comment. One more thing, what do you think its appropriate for a web *app*?
Hmmm, that array spreading... :)
A friend of mine is starting to write posts about PHP. This is essentially the first attempt. Sharing it in support of that, whether or not you feel it teaches you anything, personally. :)
I saw this one as an answer on StackOverflow, and like all neat hacks, it's best not to use it. 1. If your root level keys are strings, you get a fatal error. 2. If you root level keys are non-consecutive numbers, they get remapped to consecutive indexes. 3. If you have string keys in the deeper level, they get lost and remapped to consecutive indexes. 4. Generally icky feeling from using a semi-documented behavior like passing a null handler, that may change. I'd probably consider a single loop + array_column as middle ground solution (if it's faster than nested loops at all).
Very cool.
I can't figure out how to apply the script to a whole folder. I mean, I could pipe ls or find, but I'm pretty sure I'm doing it wrong.
You can take a look into http://codeception.com as an alternative Probably it is more designed for testing with docs covering the most related to web application testing
If your main priority is performance, use Phalcon. Even if you don't care about performance, it's a good modern framework on its own.
As already mentioned in other comments, doing heavy computation in a web request is not usually a good idea, but PHP should actually perform decently at the analysis (depending on the details). Do you need to know anything about the process or when it's done (like some sort of user-facing webpage that shows the current status)? If that is the case, some sort of task queue server like [beanstalkd](http://kr.github.io/beanstalkd) or [Gearman](http://gearman.org). With task queues, you should be able to query if a task has been completed or not, and be able to display that information to the user. Depending on what platform facilities are available to you, there are some other methods that may be simpler, faster, or require less setup. Here are some ideas to explore: - **Simple standalone script**: If yuo want to write a standalone Java program, you can, but you could just as well write a similar PHP script that could take advantage of the same libraries &amp; code your website uses (DB access, etc.). You can launch a background process like this: `exec("php processRecords.php &gt; /dev/null 2&gt;/dev/null &amp;");` but note that you won't be able to read the program's standard output, so you will probably need to create a file at a known location to store the results that you can check in your website code for. You may also need to lock the file with [`flock()`](http://php.net/flock) to make sure the external program and the website don't bump heads. - **Daemon processes**: Would work in Linux servers that you have control over. Most daemon libraries/frameworks trivialize saving data to disk and checking if a particular daemon process is still running or not. Some helpful libraries: [Clio](https://github.com/nramenta/clio), [PHP Daemon](https://github.com/shaneharter/PHP-Daemon). - **Threading using [pthreads](http://pthreads.org)**: Doesn't separate the request &amp; processing, but could be used to speed up the processing code. Requires some understanding of threads and a little extra work. Here are some relevant links that may help you get started: - [Working with PHP and Beanstalkd](http://www.lornajane.net/posts/2014/working-with-php-and-beanstalkd) - [Introduction to Gearman – Multitasking in PHP](http://www.sitepoint.com/introduction-gearman-multi-tasking-php) - [Multi-Threading in PHP with pthreads](https://gist.github.com/krakjoe/6437782)
What are your thoughts on Medium's password-less one-time authentication requests?
the one for "dead code" this one could be mistaken when you have "magic" methods, such as getters/setters that follow a specific "pattern" that is interpreted at run-time but never directly called. I hate those.
well, hate to be the first person to mention, but you should probably look into rabbitmq for queues, possibly consider ratchet for websockets, haproxy to merge your websockets &amp; http server traffic together and zeromq to be the go-between from your completion response between your queue &amp; websockets to communicate back to your client it's completed. rabbitmq: http://www.sitepoint.com/use-rabbitmq-php/ ratchet: http://socketo.me/docs/push (use the pub/sub model) look into zmq look into autoban for websockets communication. php will not be a problem for high-processing type workloads unless it's a lot of math computation which you might consider writing a very minimal extention for php.
That's really nice of you. I approve.
clickbait title
Not with all versions of IE. It bit me once. 
&gt; I have seen people make this web site vs web app comparison a couple times on here. I wish they would stop. Instead of instantly wishing that people unconditionally accept your point of view, have you considered maybe they have something in mind when they make that distinction? I'm trying to think of one feature in Laravel that would be an aid and not a burden to me in a complex web service API, and I can't figure one out. While in a site with simple CRUD logic and lots of HTML pages with a good amount of static content, I wouldn't mind Laravel. It's like someone from McDonald's showing up in a subreddit for professional chefs to insist we can base all our recipes upon whatever we can order from their menu.
I've used CakePHP in production and personal apps for about 5 years now. It boils down to what you're comfortable with (which all of these framework discussions do). I enjoy the framework and find it performs well once you tweak it. My main project at the moment, a full featured accounting platform, with API for iOS and Android apps, that's been going on 2 years now is based on CakePHP 2. I enjoy the speed at which you can get something out the door and into the consumers' hands. My exposure to other frameworks is purely in testing them out for fun, but my entire business as a contractor has a foundation in Cake so I'm rather biased. CakePHP 3 has incorporated the latest trends in PHP so if you learn Cake you aren't going to have an issue switching to any of the others. TL;DR Play with it, play with something else, choose what you like.
&gt; Instead of instantly wishing that people unconditionally accept your point of view I wonder what happens if you point your highly tuned perception of other people inward ... Taylor didn't come along and say *anything* about Laravel, he made an *arguably valid* comment about full stack frameworks in general. &gt; I'm trying to think of one feature in Laravel that would be an aid and not a burden to me in a complex web service API, and I can't figure one out. Which you replied to with something *completely indefensible*, some barely veiled insult. &gt; It's like someone Is this another insult !? I'm tired of people berating prominent members of the community for no other reason than they are prominent, it's boring to watch, stop it, please.
&gt; Taylor didn't come along and say anything about Laravel, he made an arguably valid comment about full stack frameworks in general. Well I suppose when he said "I have the apps to prove it" he meant CakePHP apps. Right? My bad, then. &gt; Which you replied to with something completely indefensible, some barely veiled insult. I listed an example where I believe Laravel, CakePHP and so on in that range are only a detriment. And then *in the very next sentence* I listed an example where I think they would be an aid. I started the thread by giving a very balanced, I believe, overview of CakePHP. I ended that post with "if you like CakePHP, use it, it'll be fine". Laravel is very close in many regards to it. Of course, Laravel uses more up-to-date concepts and is more popular, which matters, but in terms of target audience and suitable use cases, they're very similar. Someone doesn't agree? Fine. But don't mischaracterize it as if I'm "insulting" them only for listing cons next to pros. Let's tone down the drama a bit and afford ourselves the freedom to have a balanced conversation, like engineers should.
Well Behat is a tool to help you utilise your scenarios from BDD for testing and development. It goes along side TDD extremely well since TDD is just write a test first. So if you write the Behat scenario and context first and then start writing your unit tests you're doing TDD. So I think the first thing you should be aware of is what is BDD? Well the author of Behat has very kindly (thanks to Inviqa's marketing team) created a short video giving an over view of BDD. https://www.youtube.com/watch?v=njcHzGYv7nI. Here is another good talk about BDD - https://vimeo.com/43612884. There is also another good talk by the author from symfony live. https://www.youtube.com/watch?v=F0YK0OfPWEY Again from the author you have a post explaining an extremely cool technique he developed called modeling by example. http://everzet.com/post/99045129766/introducing-modelling-by-example You should also be aware all that nearly all the good resources for cucumber can be easily translated into Behat since Behat is the official clone in PHP.
I agree, if you don't have time, budget and learning constraints. Unfortunately real world requirements often mean we have to be able to build a bit more efficiently than that. Especially if you work on client based projects rather than one large monolithic codebase. 
Behat is not for testing. For example, you probably won't write negative scenarios as part of your feature specs since there is no possibility for user to do this (from UI layer, but this possible from domain layer). Behat (if you use it as a tool for design your software according to feature specifications) never (almost) will bring you 100% code coverage. As for usage - there is pretty good documentation. For each layer of your application you can create context from which will be performed testing. As already mentioned here, everzet's article "modeling by example" covers this part. Also there is a cool stuff like arguments transformers, which will cleanup a ton of stuff in your step declarations. Also a good think will be used predefined set of some names to simplify life with transfromers. For example i have predefined sets of users in each test suite (usually 4 personalized user names like Alice, Bob, etc) And we can add transformer for users very easy: /** * @When :user do stuff function doStuff(User $user) { } /** * @Transform /^(I|Alice|Bob)$/ */ function getUser($name) { if ('I' === $name) return $this-&gt;signedAs; return $this-&gt;get('app.repository_user')-&gt;getUserByName($name); } p.s. There is nothing better than PhpSpec for TDD.
Thanks for trying, at this point you can pass several values to the --files option: $ phpqa analyze --project=php --files=src/,app,bin,my-file-1.php,my-file-2.php 
DokuWiki developer here. Can you elaborate what you mean by file descriptions?
&gt; Needless to say that there is a fair amount of bad faith in your example. It was a contrived example.. however an inefficient loop would likewise make something with very low line count perform worse than it's line count might indicate if you consider that an indicator of performance. Similarly a piece of code with a high line count and lots of complexity which takes various clever approaches to caching and prefetching may perform better than it's line count might indicate if you consider it an indicator of performance. The entire point was that line count alone is a terrible **terrible** indicator of performance. &gt; I was talking about performances. I am aware it is a huge quantity of work and probably the best solution for PHP developers to look professional. My personal opinion is that it is overengineered. Like Symfony is. Should I keep it for myself? You can hold an opinion that it's performance does not meet your requirements. You can even share that opinion. But to say it's **pathetic**? no, that cross a line into the realms of unprofessionalism. As for over engineered... for what exactly? For the kinds of work I do it doesn't seem to be anywhere near over engineered. With the possible exception of Eloquent the API is incredibly easy to get around and understand and usage is quite straight forward. If it *is* overengineered, it's well hidden. Clearly you and I have very different goals.... I favour developer productivity and you seem to favour line count and raw performance... that's entirely fine. Neither is invalid (well, line count is invalid..but performance not so much). To throw around snide remarks about how it's somehow bloated, or "pathetic" shows a level of unprofessionalism that you, quite frankly, should be ashamed of. 
Squid proxy and a reliable vps provider
CakePHP 3 makes me happy on a daily basis, currently using it for work and will use it for a side project. I chose CakePHP 3 over other frameworks because no version has ever failed me. CakePHP 3 has a brilliant new ORM that embraces SQL and people are loving it. New routing which is lighting fast and great for API's. The view layer makes rendering html, json, js or other a breeze. It does everything the other frameworks do: migrations, code generating, testing, composer for everything. There are heaps of plugins on Packagist and Github. The community is wonderful and is a mix of young and old developers, which is a good contrast. One of the things the blew me away was how much passion people have for CakePHP. The core guys are at it everyday, making it better answering questions, so it's motivating to be part of that, checkout the IRC channel and GitHub repo for all the action. They welcome feedback, good or bad, all they want to do is make CakePHP better. I would recommend you use it 100% if you visit the IRC channel please say hi! 
That assumes that by learning one specific tool you are not advancing your general programming skills in any way. That cannot but be a false statement, since that is not what actually happens in the real world. For example, would learning to drive a Toyota would hinder your abilities of driving any other car? Why have you necessarily be stuck with a single brand for life? I'm incredibly passionate about CakePHP, but that does not mean I don't use other frameworks or even other languages. Mastering a tool, or a set of tools, can also be bring benefits to your career. While at the same time, opening your mind to learning new stuff is equally beneficial.
;-) You seem to have a very high opinion of yourself. While on my side I don't give a shit to try to build nice image of myself on the internet. I do not disrespect Mr Otwel because he is brilliant. It is quite obvious. That said, being skilled does not prevent you to make bad choices. You judged me quite quickly, you wrong about me, and let me just say that I favour **maintainability** over all the rest and to me it should be the main goal of any framework. In that area Mr Otwel did very well and it is possible to even do advanced functional testing. Let me share some deep personal opinions: - concise code is more elegant - ORM is an anti pattern ;-) 
If you got this far and don't know what a VPS is, stop right now and go do some more learning, it's going to be a trainwreck if you carry on.
No you misunderstood. I don't like Phalcon because it is all out of reach of the developer. When things go wrong, he is disarmed. I favour maintainability over all the rest.
yeah, code of PHPUnit is a way too monolithic and very hard to extend :( i hope one day we will have some more flexible unit testing solution
I dismissed this very quickly. - No english readme - The coding style looks outdated to say the least - It says it's only been tested with XAMPP for Windows 7
Thanks for the suggestions guys. I think at first I'll try using PHP to kick off a Java program to do the processing. Then I'll have the Java program update a flag on the database and use AJAX to try an check periodically for this flag. If I can't get that to work I'll look deeper into the other suggestions.
OP, is this your project? I'm really not an authority on cutting edge application design but it really seems your code is somewhat outdated. Few things i found while having a look over it: - You're using old style constructors instead of the __construct() magic method. It works but is deprecated since 5.3 - You're using global variables. It's not necessarily wrong but it adds unnessesary code and overhead to your application. You might also run into a few problems when renaming variables or accidentially overwriting stuff. - This also goes against general OOP principles as it introduces outside dependencies. Objects should generally be self-containing to be fully modular. Honestly can't blame you. I used to write code a bit like that just a short while ago because for some reason i stopped learning after PHP 4. Just keep on learning new things and you'll soon find ways to greatly improve your code :)
Is this available in Vagrant? [This](https://atlas.hashicorp.com/rasmus/boxes/php7dev) was for the first alpha but it hasn't been updated since.
As always, it's best to wait for the official announcement…
That question doesn't really make sense. Vagrant is a common interface to a few different virtual machine providers. On a side note. The vm image you linked to contains all version of php since 5.3 and an easy ( from source) upgrade process to keep them all up to date easily. You don't need to download another image if you already have this one. You can build the latest and greatest ( including the new beta) with a few simple commands.
Yeah, I'm with you on that one. Thats why I said: "but try not to make comparisons with other frameworks, focus on CakePHP please". The main reason of this post is to have opinions and thoughts about a specific framework.
http://php.net/manual/en/features.file-upload.php
&gt; It is also used heavily by laravel Symfony *components* are, but not the standard edition framework. And Laravel abstracts away a lot of the terrible Symfony component APIs so you can work with a sane API instead of a cumbersome one. Aside from the horribly named "MessageBag" that Laravel validation returns, and a few other misc instances, you pretty much would have no idea Laravel is using any underlying Symfony components (which is a good thing).
DokuWiki has been my go-to on several small projects. Can't complain.
Didn't know they were a php shop. Why don't they have a php api then?!
Never personally used it but [this](https://github.com/aivis/PHP-file-upload-class) looks pretty good.
 I wouldn't have stuff being run directly from a request. Instead create a background task to run that stuff, and then on the web page, just display the status of that background task, refreshing either the page, or just the element with the status on it via Ajax. By doing that, you don't need to monitor the state and pass the value of it around - all you need to do is pass an ID of the background task, and allow something to get the current state of the task.....which is easier to code in a robust fashion e.g. what happens when the task times out, or needs killing remotely. http://12factor.net/concurrency http://12factor.net/admin-processes
The car example was assuming a hypothetical, unique brand that has completely different controls. I know it's exaggerated. Of course there will be learnings from framework A that can be applied in other context! Mastering a specific tool is great, as long as you're aware of its (limited) context. I'd hate to be an expert in a tool that gets out of fashion or abandoned. Rather make sure you gain a fundamental understanding of frameworks, and their components (requests &amp; responses, routing, etc.), which ports to any language, any framework, and makes you more flexible and experienced for future situations. Do you like what PHP-FIG is doing? * If you do: you already understand the value of reusable and standardised components, which supports my point. * If you don't: you really should read more about their purpose until you see the great and fundamental changes it will bring to PHP and its community.
Probably the only time thus far that I've agreed with Taylor on something :). Not sure what a small to medium website is, but I kind of doubt freshbooks is one of those (the lead developer of cakephp is a [senior architect](http://www.freshbooks.com/about/team) at Freshbooks). Lets try hitting above the belt ;) As far as framework speed, when your framework does more, yes, it will be slower. Its kind of like how the framework shootout has CodeIgniter in the lead for building json apis. It basically calls: ``` json_encode($data); die; ``` Which is way faster than what any other framework might do by virtue of the fact that the framework isn't doing much.
What does the output look like?
Beta 3 is shown in the news file because OP linked to the news file on the master branch which already shows fixes that didn't make Beta 2. If you check the tagged branches then there is no beta 3 only beta 2 and beta 1 for 7.0.
I don't mean this in a demeaning way. There's no reason to get "advanced" in PHP in most cases. It should be a light and pleasant experience where brevity of expression is preferred over comprehensiveness. But work with enough real-world apps that stick around for years (and not just, you know, make something and it turns into "legacy code" in a couple of months) and you start becoming irrationally sensitive to lack of code modularity (a monolithic framework and app) and avoiding the untyped array trees in Cake's models and configurations, to name a couple of things. Being advanced is sort of like PTSD developers get after long exposure to harsh experiences.
Virtual Box almost NEVER works. That is the biggest hurdle. Dropping $300 just use VMWare is not such a great idea either. You should just buy a Mac (if you can) and be done with it. 
Does it make sense right now to develop for the new PHP version? I heard that the new PHP version brings a lot of improvements regarding performance , and i really want to use anonymous classes that the new version brings, so does it make sense to start developing with it? Im currently just coding to learn and improve, but i might want to release a project later on, so what do you guys think?
Have I said *anything* that's not relevant to modern CakePHP? Be specific.
If you are willing to keep it up to date with any changes they make from now till final release. You should be fine. It could end up being a lot of work or not much at all. All depends on what happens from now til release.
Sometimes it takes a premature commitment to realize you're not finished.
Oh, so similar to when I can't stop editing my comments after I post...
Theoretically, since first beta, there is total feature freeze. Chaning language semantics is unlikely to happen.
Before this, I had no idea how binary trees worked. Now I sort of have an idea how they work.
Switched baits.
Use PHP 7 Beta 2 when its officially announced. Changes after that should be bug fixes, not language changes.
For the output, looks line no php files on the directory, the path must be relative to the place you run this tool, do you mind to change to the directory project and run phpqa again.
Oh, hello! I was referring to pages like [this](https://commons.wikimedia.org/wiki/File:Dokuwiki_logo.svg) on MediaWiki, which show a description and copyright information, which can be edited like any other page.
Ah I see. Yeah, we autogenerate a detail page for images (https://www.dokuwiki.org/_detail/example:sunset.jpg) and you can even edit the EXIF tags of JPEGs. But yeah, not exactly the same.
&gt; The TechEmpower benchmarks are very, very well done. No, they are not. They are horrible esp. regarding PHP frameworks. They don't care about PHP, they don't have a clue about the PHP frameworks and the quality of test cases and results is very poor.
IMHO, CakePHP is the closest you're gonna get of RoR on PHP. If your main concern is time to market and you're willing to live in a walled garden, then CakePHP is for you. Later on, you're gonna feel the cost of the automagics it does for you. But by then you will either rewrite your application out of CakePHP, or just delay the inevitable rewrite through architecture reorganization. It is a safe bet to get things started and push speedy deliveries. Symfony is awesome, but it takes some time and ahead preparation to use it in its full capacity. Laravel has a very interesting design of API. CakePHP, depending on the market you are, you might find yourself having hard time to find people good at it or willing to learn it. Ofc, YMMV. 
You don't master WordPress. WordPress masters you.
/me shrugs Their relative performance comparisons among PHP frameworks were similar to the numbers I was getting, and they do a wider range of scenarios. If you can find specific issues with their setups, I'm sure they'd appreciate your expertise in the form of a pull request.
I usually use a "flash" session variable.
... says /u/FuckingLoveStarWars... Joking aside. We don't really have a policy for our repo. Our customer has access to our bug tracker and commits automatically appear in cases, but our customer is pretty fucking cool and we're all grown-ups so we can pretty much talk like we want.
At this point I'd almost be willing to say it doesn't matter between laravel and symfony anymore. Laravel wasn't highly adopted in enterprise software because it lacked LTS and was still pretty young. Symfony is laravel's foundation and has been around longer so it's obviously more widespread. I actually just started a job writing in purely Symfony2 after doing Laravel for 2 years and while I'm still on the laravel boat, symfony definitely has it's advantages.
At this point I'd almost be willing to say it doesn't matter between laravel and symfony anymore. Laravel wasn't highly adopted in enterprise software because it lacked LTS and was still pretty young. Symfony is laravel's foundation and has been around longer so it's obviously more widespread. I actually just started a job writing in purely Symfony2 after doing Laravel for 2 years and while I'm still on the laravel boat, symfony definitely has it's advantages.
Laravel's API and documentation are light years ahead of symfony2. I just had to learn symfony2 after using laravel for the past 2 years and it's been a bit of a headache...Annotations, annotations everywhere.
I'd just like to point [how big](http://i.imgur.com/jzF67x0.png) those buttons are.
It's not impossible for a determined attacker to highjack the phone line (by impersonating the real owner with the mobile carrier, claiming the SIM was lost and getting a new one issued). I remember reading of one such cases in the news.
I probably wouldn't. Not for anything important, anyway. Too much risk of bugs and API changes. Also, make sure you have complete control over the server you want to run your project on, because if you're planning on making anything open-source, or putting it on a shared host, it'll be a *long* while before anyone's able to use it.
Moderately inspiring. I'm not sure if I'm quite as awkward as this guy, but I too would like speak at a conference some day. I was hoping he'd say more about the response from people, and how the talk went, but he seems content with simply having done it. I suppose that's good.
Do yourself a favor and master something else.
I understand that, but you can make some really sophisticated bowls of spaghetti with it.
I work with wordpress in my day job and can assure you, you'll never really understand wordpress. It's a complete mess of inconsistencies, which third-party plugins add more inconsistencies to. I recommend you just learn the bare minimums of what you need to get done and don't invest yourself too much in it if you value your sanity. Don't worry about the quality of your code - since you've picked Wordpress the code will be shit regardless, as long as your client is happy that's all that matters. My number one advice would be to tell your customers/clients that upon choosing Wordpress they will be arbitrarily limited in terms of custom functionality, unless they want to pay you ridiculous sums. Advanced custom functionality is definitely possible in wordpress, but not with modern coding practices and not without a large amount of work and maintenance. Take [this graph](http://discrete.gr/complexity/images/cubic-vs-linear.png) as a vague illustration of how wordpress compares to implementing things from scratch. In the graph, the blue line is wordpress, the red line is implementing from scratch using some modern framework. Ignore the numbers on the axis, but the X-axis is the amount of features, and the Y-axis is the development work involved.
wordpress.stackexchange is a weird beast. If you're not getting answers to your questions I'd recommend putting your question on the regular stackoverflow site and you might get better luck. There is some good stuff on https://tutsplus.com/ if you can afford the subscription. Lots of ebooks and articles, and whilst it covers WP it also touches on basically every topic under the sun for web development.
I work with Yii, Laravel, Symfony and WordPress. There's probably more jobs in the last one than the rest combined. At least where I am. &gt; Strategically speaking, sites like Squarespace and others are aiming straight at Wordpress's usecases, because the only sites that Wordpress is really meant to power, are the very types of sites that you can develop on Squarespace for less money. So I sure as fuck wouldn't base my career on Wordpress, even if it wasn't a giant code hemorrhoid. A developer working in WordPress can do a million things you can't do on squarespace or sites where a client gets to DIY their own solution.
Hah, exactly how I felt. Well done Joe.
I'd have given more details of the actual talk, if I could recall them for myself. I can't, at all. I'm waiting for the video to judge how it really went. Response to the talk was good, in general: https://joind.in/talk/view/13581 I made some newbie mistakes, not repeating the questions at the end so everyone could hear them, taking 5 bits of A4 card with me (though I didn't reference them, I did stare at the screen for some reason). In a way, if the talk seems terrible to me, that's better, because there's more to work on, and so more scope for improvement. I don't know what I'll see in the video, but it doesn't matter, the main thing is for me that I done it and find myself looking forward to improving.
You should describe what your class does if you wish a proper answer to your question.
I don't know what you are trying to do, but I'd argue that it's generally better not to create singleton classes and instead control instantiation via an IoC container. You never know what needs you will have in the future, so it might be stupid to paint oneself into a corner by only being able to create a single instance.
That should be done on the client side. Client side and PHP, do the math.
I already made the client side, I made the form successfully with a checkbox successfully. I can also send normal mails with it via php. But I cant seem to get it work when I want to add a checkbox function in PHP. The client side is no problem, I just dont know how to code the php, so that it checks the checkbox before sending out the email.
Thanks for that! I edited the class into the body of the original post.
Can I use 2 issets? if(isset($_POST['submit']) &amp;&amp; isset($_POST['checkboxName'])) Doesnt work, it still checks the checkbox before i even click on submit.
/r/phphelp is that way --&gt;
Okay... the article mentions the words Scala here and there but the author doesn't try to go into any depth about any of the opinions he is presenting. A sub-par article at best to be honest. Thanks for sharing it though.
Read my description: it defines sections when an instance is created (a list of taxonomy IDs is passed via an array), does crunching and appends the appropriate class to the body tag. The body tag class determines the colour of trim shown on the page. Briefly: body.category-foo { .section-trim-background-hover:hover { background: #000; } } body.category-bar { .section-trim-background-hover:hover { background: #eee; } } Etc. There's absolutely no reason for more than one instance to run.
You know the Metallica song "Master of Puppets"? WordPress is your puppet master man, break the chains!
It's kind of primitive that the opcache neither manages generations of cache neither even can compact memory in-place, it just restarts when full. It certainly *doesn't* have to be that way. PHP as a very dynamic environment should be able to handle script churn. It's in its nature. Likewise, having to restart the server in order to update opcache is making PHP no better than Java for web frontends. If we treat this as a last resort optimization for larger, busy projects, fine, but if we recommend it as the norm on the built-in opcache, it's something else entirely. In the quest for performance (which is great overall) we should be careful not to eliminate the *few key benefits* PHP has over other platforms when it comes to web frontends. At some point I'd rather disable opcache entirely and manage more servers with predictable smooth performance, than handle obscure edge cases in cache invalidation and opcache restart hiccups.
I just use new $className. It's one of the benefits of PHP that it can actually do something like that, so I see no reason not to take advantage of it. The caveat being using reflectionclass allows you to be a bit safer by checking things like -&gt;isInstantiable. But if you know the class name is good before runtime then have at er.
The only reason to do the instantiation through reflection is if you're on an older version of PHP that does not support argument unpacking. If you are on 5.6 then `new $className(...$args)` is the idiomatic way to do this.
Hi. First thanks for the article, it was informative and useful. As for "the small guy", you know, I'm not *quite* sure about that. Consider where the average little guy deploys - shared servers. I bet something over 50% of world's PHP sites are shared hosting. And opcache is awfully unprepared to handle this setup. Which is really unfortunate, because shared hosting is what kept PHP alive all those years. It's why PHP is a thing right now. A shared host would be handling a large amount of code (small for every user, but large collectively) and there will be a lot of churn. And there won't be server reboots to update cache or anything like this, because then you'd be constantly rebooting the server when *any* of hundreds of users per server updates. On a shared server also you'd have to be selective about which files you cache, and which you don't, depending on usage. "It was used once" becomes a very poor criteria when you have hundreds of thousands of files, and some get hit hundred times a second, and most others get hit once a day. So yeah... some work is left to be done. 
so what, exactly is happening? Is it opening in a browser with all that gibberish? Or is it opening in a pdf viewer with that gibberish? What happens if you open a pdf viewer, then open that file? Or if you "save as" then open it from your hard drive?
I only gave it a fairly quick look, because I cannot see a single use case that doesn't go against the premise that you should always be able to update your host for a myriad of reasons. That said, in the interest of feedback - I think you should probably have some way to control how far back it goes with version compatibility. From what I can see there is almost no reason to reverse the constructor function name since it's been supported since forever and isn't a PHP7 feature.
It's obviously not a necessity. But I love me some phpStorm. I'm an intern working on a large php codebase and the command-click to find the function definition (or usages) has been invaluable.
Current HHVM's JIT is compatible with this syntactic sugar. In any case it's a very odd concern to have and ask about. ReflectionClass-&gt;newInstance($arrayOfArgs) isn't any easier on the JIT (in fact, I'd guess, the opposite).
Thanks for the feedback! You're right about the typehints. And I guess there are many more details that aren't addressed. I will try to implement more features over time. The whole thing is more of a proof of concept kinda thing, at least for now and for me. As for the Expectations, I have no idea... It doesn't make much sense for me either. I will have to get back to it.
Well I guess on shared hosting using opcache is a no-go anways for security reasons. So if we equate the "small guy" for the one using shared hosting, then he is having bad hardware + no acceleration =&gt; very bad experience. 
Yes, the chained binary operations will be tranformed one by one in the right order of precedence.
I've used three of the jetbrains IDE's: PHPStorm, Rubymine and Webstorm. I guess I would say that these IDE's are more specific to the language you are using. I only used PHPStorm briefly, but Rubymine for example, has amazing support for rails out of the box. It seems like Netbeans or Eclipse are more "general" IDE's that you can configure to your language preference. Where the Jetbrains ones are the other way.. specific to a language but can be set up to use generally for any. Just my two cents.
I strongly recommend you to use an IDE, especially phpstorm. It worth every penny you spent on it.
I see. So........are there any advantages to it being language specific? Are there any exclusive language-specific features worth paying for that the paid IDEs have that the free ones are missing? 
Hmm. So I see a lot of people recommending Phpstorm, and I'm not doubting it's efficiency as an IDE, but if "feeling like home for a php developer" is its only distinguishable feature which sets it apart from other IDEs, I'm not sure I can justify paying the $100+ price tag for a license.
It can. I ran ten instances to piss around. It exploded less than you'd imagine.
In terms of full IDE's I've got good experience with PHPstorm and Netbeans, currently settled on the former. PHPstorm has all the things I need, a REST client, GUI for git merging, 2 key combos commit and push my code, PSR formatting to name a few. It's true that netbeans has plugins or extensions for all of these things too, I used a lot of them. I find however that everything in PHPstorm follows the same workflow or practice, as for netbeans plugins, you're at a mercy of the plugin developer and I'd often find different plugins have completely different workflows or ideas about how to achieve something. PHPstorm just feels like a more integrated experience. Just my 2c
Nice!! You should try to back-port the code itself, to be able to run that same script at php5. The tests should be: 1. grab the php7 version of your code, lets call it `php7` 2. using `php7`convert itself to php5, lets call that `php7_5` 3. using `php7_5` convert `php7` (on a php5 instance), that output would be `php5_5` 4. then compare `php7_5` and `php5_5`, and they should be the same!! 
Yes to any IDE that does code analysis and good (type hint and doc-block based) auto-completion. NetBeans here, for some years. I've just tried an online editor, C9.io - very impressive. The auto-complete doesn't seem to use type analysis but it's impressive what can be done in a browser. Of course, this lends itself automatically to pair programming, which I've yet to try on this platform. 
Personally I think the first method is much clearer than using reflection. BTW if the classname *is* from user input you can check it's a valid class using `class_exists` or use a whitelist approach.
You know PHPstorm also has user made plugins right?
PHPstorm has third party plugins too, quite a lot! https://plugins.jetbrains.com/phpStorm Honestly, if I had to go back to netbeans, it wouldn't be the end of the world, I'm just enjoying PHPstorm. No bad blood for netbeans and in terms of free IDEs it's my goto recommendation!
It is opening in a browser with all the gibberish. I have tried to download it and open it with a PDF viewer, but it just wants to treat it like text. What I imagine is supposed to happen is the headers are supposed to tell the browser "hey, we've got a PDF file here" and then the browser uses the appropriate software to read that gibberish and turn it into a downloadable PDF file. Yet, there is some disconnect and I am getting stuck with the gibberish. At least that is what I think, but this is my first time using a function like this. 
ok, it's completely ignoring the headers. It shouldn't be opening in a browser, "Content-Disposition: attachment" means it's supposed to be forcing the browser to download it separately, not display it. Is there anything going on before you output the first header? Is anything being output before that, because that could throw it off. If you want, you can replace any identifying information and upload it to pastebin.com and I can give the code a second set of eyes. (we do that all the time where I work, when you look at the same code 10,000 times, you miss obvious things. Everyone does it.)
Here is the entire download page: $link = mysql_connect('*******', '****', '*****'); if (!$link) { die('Could not connect: ' . mysql_error()); } if(isset($_GET['id'])) { include 'library/config.php'; include 'library/opendb.php'; $id = $_GET['id']; mysql_select_db('careers'); $query = ("SELECT `name`, `type`, `size`, `content` FROM `fileTest` WHERE `id` = '$id'"); $result = mysql_query($query); list($name, $type, $size, $content) = mysql_fetch_array($result); header("Content-Disposition: attachment;filename=".$name); header("Content-Type: ".$type); header("Content-Length: ".$size); print $content; include 'library/closedb.php'; exit; }
Are you sure that `$content` is valid pdf markup? You can troubleshoot that by replacing it with something you know is valid and trying again. 
A hefty majority of this subreddit loves PHPStorm, way over any other IDE, but i really don't think you are gonna get a solid list of reasons. If you don't want to try it, then just stick to Netbeans. You clearly seem to like it. In the grand scheme of things, the $100 for PHPStorm is less than a day of work, and its definitely worth it to use an IDE that doesn't look like crap, but, thats just my opinion.
I just got it to work. Seems the issue was that I had html page code in front of my php code and it must have been interfering with the headers. So, note to self, &lt;?php Everything must be in here ?&gt;
I'm not biased towards any particular IDE. I just don't see how PHPStorm is worth the extra $100 over free alternatives which can perform most if not all functionality. I will probably try it out though and see what it has to offer over free IDEs. Also, $100 may be less than a days work for you, but a lot of us are struggling in this economy, and aren't as fortunate to be able to earn $100+/day.
The code itself is 5.4...
Should I even make the functions static too, instead of private?
So you're telling me I can draft the class and then use it without instantiation? Sorry, I don't work with classes a lot. :) 
I was one of those people who didn't believe a full-blown IDE was required for PHP dev. I was happy with things like TextMate, Sublime Text or Vim. Mostly because of the IDEs I tried (Netbeans, Eclipse) really felt clunky on the OSX platform. However, when I tried PHPStorm I was instantly hooked and felt the price was worth it. I couldn't go back to anything else.
You are clearly biased against PHPStorm. You've never used it, yet you say it's not worth the extra $100. 
&gt; You've never used it, yet you say it's not worth the extra $100. Only based on the information &amp; recommendations provided ITT. Seems like there's an unusually STRONG bias for PHPStorm here, so if anyone mentions they use something else, it seems like they're against it. :)
Thanks!
Take that as evidence of its merit, and not a downside of bias.
I previously used PhpEd, which had one of the best set of debugging tools I've ever used. I ended up trying Phpstorm and loving it, altho not as much love for xdebug over dbg. All my co-workers use vim and they're purists about it so I get harassed all the time for using an IDE but they make many STRICT errors. I also notice that they take a lot more time doing things that take seconds to do with my IDE. Opening classes is easy because all you need to know is the class name and you don't have to memorize file paths. The same goes for being able to immediately find where a particular function is. Then there's handy tools like being able to run unit tests. Overall I find myself more productive.
I recommend reading this: http://php.net/manual/en/language.oop5.static.php And this: http://www.php.net/manual/en/language.variables.scope.php Final thought - if you are not familiar with OOP, I recommend spending more time doing it anyway. But OOP is only loosely correlated with learning software development and architecture; you may find that you also want to pay attention to *why* you do things the way you do. Ask yourself whether this improves something about your code, and what that is. If the answer is "because it gets me closer to paradigme x, which I read was the proper way to do things," I would ask the question again until you have a real answer.
This code has a SQL Injection. [See my other comment](https://www.reddit.com/r/PHP/comments/3e43qr/trying_to_download_file_from_mysql_database_but/ctdmxf3).
$100 is like an hour or two salary for most devs in North America.
I switched from NetBeans to PhpStorm a few years ago and haven't looked back. I found performance was much better when it came to large projects and debugging, and it integrates very well with others tools such as code sniffers, style inspections, etc. I seem to recall having issues with NetBeans in some projects I inherited with heavy html/php/css/js in the same file. While it's possible that NetBeans has caught up over the years, the fact is that PhpStorm has helped me become a much better developer and I've made a living from it. The least I can do is support the team working on it, so they get my $100/yr. In fact, I've gone back and donated or purchased quite a bit this year to support the guys and gals making my life easier. If you can't afford or just don't want to part with $100, stick to NetBeans and you'll probably be fine. Consider the fact that so many people here are PhpStorm fans for a reason, even if they can't quantify it, because it just feels right. I keep finding awesome new features I didn't realize it was capable of handling. For example, I'm working on a PHP app that spawns a bunch of processes so it can asynchronously crunch some data in the background. I had no idea what was going to happen when I had five worker threads and breakpoints set within those workers. Turns out you get multiple independent debugging/inspection tabs, all of which still seamlessly work with the main code windows. SWEET! You can try it free for 30 days and make the call yourself. 
rofl no it's not.
Wait, what does this mean? If $bar is null then $baz, if $baz is null then $fizz and so on?
Some things that make PHPStorm better than Netbeans (at least the last Netbeans I tried): * **Vastly superior code analysis** PHPStorm is much better at responding to type hinting, both in code and in documentation. For example, the following code generates a warning it PHPStorm but not Netbeans: class TestClass { function test(FooClass $param) {} } class FooClass {} class BarClass {} $test = new TestClass(); $object = new BarClass(); $test-&gt;test($object); Another /** @var FooClass $foo_object */ foreach ($foolist as $foo_object) { $foo_object-&gt;... } PHPStorm can figure out that `$foo_object` is an instance of `FooClass` and autosuggest accordingly. Netbeans autosuggests `$foo_object` as though it were an array. There are many more examples. This alone saves me hours a year with PHPStorm. * **Smarter code inspections** - SQL in your PHP? Javascript in your HTML? PHPStorm can figure it out. * **Better refactorings** - Push-down and pull-up, introduce param, others too I think. * **Trace transpiled Javascript** - Makes it much easier to work with Coffeescript, ECMAScript 6, etc. * **Better debugger integration** - Integrating the debugger is very easy. With PHPStorm 9 we even have inline debugging. I could go on.
Ah, ok, now I'm interested. :) EDIT: Please go on :D
So, sort of the whole point of our profession is programming tools to help people complete tasks that they don't want to do by hand. Can a human do math, compare images, or sort through a catalog? Sure! But we don't want to because it would take *forever* and we have better things to do. I wrote a thousand word essay on how much I hate Eclipse with a burning passion, but I deleted it. It's been said enough. Currently I use PHPStorm. This is why: * It has never crashed on me. Not once. * Every time I've said "It would be neat if PHPStorm could do $X", it's turned out $X is already built-in. * Language injections. It feels weird to not have things highlighted correctly everywhere now. * The most recent one: Simultaneous tag editing. You could do it before with shift-F6, but now it just works as you type. I used it and multi-carets the other day and goddamn *giggled with delight* Eclipse never made me giggle with delight. Not actively hating my development environment is worth 100$ a year for me.
The average PHP Developer in the US makes about $75k/year. Given 251 Working days minus an average of 15 days PTO, you have about $317/day. Assuming a standard workday, that's $39/hour. It's less than 3 hours work. From your comments in this thread it seems like you wanted to start a thread to talk about how great Netbeans is and are vehemently against even attempting to use a free trial of software people tell you they like better. Why did you phrase this topic as a question if you are going to do nothing but be confrontational? In the future, just make your title something like "Who else uses Netbeans to write PHP?" if you want that kind of discussion.
Oh... I thought it was going to be a tool that allows me to use php7 features with php5
Yes, null or undefined.
I'm not sure how many of those users have used NetBeans recently. It does not change the fact that they have a preference based on experience. You should write a post on how great you think NetBeans is and all of the great features that make it comparable to other modern IDEs in regards to handling PHP. 
I use Cloud9 ([c9.io](//c9.io)). I am not a fan of IDEs in general, but that one is alright.
PhpStorm has tons of useful extensions, static code analysers (is has pretty good built in one), and ton of useful small features that improves velocity on doing some routine stuff.
It's been done with a lot of other languages, such as ES6.
You're challenging every person in this thread who recommends PHPStorm to describe *why*, in great detail, and in direct comparison to something like Netbeans. It's not everyone else's job to write a thesis on why to use one IDE over another. And the entire subject matter is subjective -- one user's preferences may not be another's. Every piece of software worth its weight comes with a free trial. Try them out for yourself, and come to your own conclusions.
Nice, that's the way to do it!:) (no irony)
They also do a [free version if you can prove you're a core part of an open source PHP project](https://www.jetbrains.com/buy/opensource/?product=phpstorm). Hit up the 30 day trial, and if you like it, prod me for a 20% discount code on a personal licence. Or, hit up your local PHP usergroup. I know for us in PHP Dorset, basically everyone who's attended has PHP Storm to the point that we've got at least one personal licence going spare for anyone who turns up to our monthly meetup (in person, so don't prod me for that licence!)
The easy answer is that your dependency container or injector should be the only object that creates other objects.
[Quick link to JetBrains Student page](https://www.jetbrains.com/student/). 
Did you even read my question?
My favourite one is being able to configure the warnings to throw a critical one if you ever type: ``` if($foo = 'bar') { }``` Just one little character, a few hours of historical searching. The inspection can save all of that.
Hack actually disallows `new $className()`, so I usually use reflection.
I believe [this](http://php.net/manual/en/threaded.lock.php) is what you're looking for to solve your problem. 
Agreed. Why make something more complicated than need be? However, aside of what might be negligible overhead creating two objects instead of one, the only other downside would be compatibility if this is something you plan on distributing - in other words, your users would have to have reflection support available. 
For the sake of diversity maybe :-) Control is never absolute, and some servers seem to stick with ancient software, like the [13% of wordpress installs](https://wordpress.org/about/stats/) according to their stats. 
You can always check the [PHP docs git repo](https://github.com/php/web-php). Here's your [running elephant](https://github.com/php/web-php/blob/master/images/logos/elephpant-running-78x48.gif). Here's the [code](https://github.com/php/web-php/blob/d59a2e15d7324af6d27638478563725d777a6d79/images/logo.php#L52) that determines if you see the elephant: /* Every so often.. give the elephpant a chance */ if ($now % 64 == 0 || $refresh) { $logos[] = "./logos/elephpant-running-78x48.gif"; } If you'd like to see the running elephant on the live site, go to: https://php.net/elephpant.php
I made that library as I wasn't so happy with those which I found. So what do you think? Could you use that? Would you change something?
Hack is a separate programming language similar to PHP that is supported by HHVM. HHVM is the interpreter as a whole. In other words, HHVM supports that syntax in PHP code but not in Hack code.
&gt; like automatically wrapping highlighted text in quotes that I'm used to having in Sublime Text. In version 9, by default the "Surround selection on typing quote or brace" option at Preferences &gt; Editor &gt; General &gt; Smart Keys is set to off. Set it and you're good to go.
I am a nub, I need to use an IDE. I know I just suck, so code completion just makes my life so much easier. Especially when I'm working on some large OOP app, showing me the methods of the class I just instantiated allows me to focus on implementing what I need to do. I wish I were like a real programmer, but alas. I'm working on it.
You're being funny, but I wouldn't mind a tool that gets rid of some of those stupid `isset($x) ? $x : $y` blocks.
How about when you throw a *new* exception? Do you get that through a container via injection, as well?
You can tail your `access.log` and pipe it through some program to format the data.
PHP 7.0.0 Beta 2 Released - http://php.net/archive/2015.php#id2015-07-24-1
It seems like an interesting idea. Thanks for sharing! I particularly love the idea of isolating the interface and having multiple mutex providers like so. There are real use cases, obviously, say you can ensure a task in a task queue is processed by one worker at most, without having any explicit task manager process. My only (unjustified?) worry would be if it really works as advertised even under high load (haven't read the source yet). Do you run high concurrency tests on it to empirically ensure the contract is met without some edge cases?
Exactly. Try it. If you like it, save money up to buy it (as long as that may take). If PHPStorm doesn't work for you, then don't buy. I don't think it was any skin off our backs.
Is it possible for your company to buy it for you? I've been reading this assuming you were coding on your own, on a per-project basis, not as part of a company.
default (tools -&gt;rest resting client)
Can you give me a run down on what you've found? It's hard to find a discussion that doesn't descend into [bike shedding](https://en.wikipedia.org/wiki/Parkinson%27s_law_of_triviality). 
The same way I felt about going object oriented when I finally made that jump from procedural PHP. On both subjects (OOP and IDEs), at first I told myself, and others... "we don't really ***need*** it". But you don't really "need" anything apart from air and water. So it's a pretty crappy reason. In reality it was mostly coming from ignorance, lack of time, and fearing what I didn't understand. Once I went to the effort to learn OOP, and then later IDE usage (neither were very hard), I realized how wrong I was on both topics, and regret not doing it sooner. This is the experience of most people who truely take a effort to learn something new. There's a few people who fully use PhpStorm properly, then choose to switch to something simplier like vim or sublime, but not many. An IDE is pretty easy to get started with because they're generally just as easy to use as a text editor anyway. So you don't really lose much. Then you have the option to try some of the features when you have time.
Show me some code, don't necessarily copy your code verbatim, show me the simplest version that exhibits the symptoms you are talking about.
!is_null(foo()) ? foo() : $bar
Thanks for the idea. Unfortunately I tried it in both the job and worker levels, but it didn't seem to have any impact.
&gt; Do you run high concurrency tests on it to empirically ensure the contract is met without some edge cases? ~~Didn't do that yet~~, as this is as you said just some empirical test. To be honest I didn't even try to search a tool in PHP land for an deterministic test. While there is [one (non high) concurrent test](https://github.com/malkusch/lock/blob/master/tests/mutex/MutexLockTest.php#L58) guaranteeing the contract, I think I will perform some high concurrency situations as well just to give an benchmark to help choosing an implementation. Update: Here's now a [test with 100 concurrent processes](https://github.com/malkusch/lock/blob/master/tests/mutex/MutexLockTest.php#L30) increasing a counter successful to 100. Everything seems to be alright.
i said the same thing, try it out for 30 days and ull buy it :P so many language specific features that are missing in the others, or just doing it wrong. One example is the symfony plugin, allows me to work 2x faster.
Hi, as a toy project, I've written a simple spinlock library myself. Just as yours, I made additional implementations of locks possible (my first one was a memcache implementation). See here: https://github.com/fanalin/php-locking
Doesn't do exactly what you are looking for, but here are a few live traffic visualizers: http://royal.pingdom.com/2010/11/25/awesome-visualizations-of-internet-and-web-tech/
Having the root password is complex in some situations.
By default, it's really awesome. http://blog.jetbrains.com/webide/2013/02/using-the-rest-client-within-phpstorm/
I don't know if you're still reading this, but here's what made me fork out $100 for PHPStorm. * **Symfony Support** If you work with Symfony, or plan to, I wouldn't trade PHPStorm for anything. Just the help with the service container alone is amazing. You know, the `$this-&gt;get('service')-&gt;something()`? PHPStorm with the Symfony 2 plugin will autocomplete that for you. When you're typing in the `service` part, it'll help autocomplete what services you can use, and once it's in there it'll autocomplete the `something()`. Basically, it knows what service you're calling, and what it has. Similaraly, it has the same features for repositories in Doctrine. `$this-&gt;getDoctrine()-&gt;getRepository('Module:entity')-&gt;find()`. It'll know which repository class `Module:entity` lies in, autocompletes any custom functions you define (`getRepository('Forum:Author')-&gt;getAuthorForPost($post)` for example), and you can just ctrl+click the `Module:entity` part to go straight to the class. It also adds some much needed assistance and autocompletion for the routing yaml files and options and so on and so forth. Basically: All Symfony developers need it. * **PHPUnit Integration** Right, so this comes in multiple parts, but the way PHPStorm integrates with PHPUnit is amazing. I can shift click to run my test, right click files or functions to run just that test or just that testMethod. Hell, I can run my PHPUnit tests with code coverage to get a display on the right to show me my code coverage percentage, and opening a file in the editor will then show red or green down the left side for what lines in the file are and aren't covered. So I can actually check if I'm covering all logic paths without uploading it and getting an external tool to take a look. * **CakePHP Unit Tests** Admittedly I'm still trying to play around with this myself to get it working, but if you've worked with CakePHP 2 (which I have the misfortune to do recently), you'll know that they have their own proprietary unit testing stuff that you need to run through cakecons. And CakePHP2 isn't PSR autoloadable, so trying to run unit tests without cakecons can be... painful. Thankfully, jetbrains saw this issue and [wrote a blog post on making it work in PHPStorm](http://blog.jetbrains.com/webide/2013/02/running-cakephp2-unit-tests-in-phpstorm/). It's not perfect, but it's much better than having to run it in command line. But why would I care, you ask? Who cares if it's in command line or my IDE? This brings us to the next indispensable feature. * **Debugging** We all know how debugging in PHP works. You chuck some var_dumps in, some exits(), some echos and generally try to wade your way through until you manage to find your error. *Or*, using the marvels of XDebug, you can do it the right way: Put break points in your code, run it and when it hits that breakpoint, inspect all of your variables defined in the moment bit by bit, tell PHP to execute one more line and see what changes and how, move with your code and see the logic paths it takes. Even better? Debugging with PHPUnit. It just makes sense. They're reusable, rerunable tests designed to run in command line without a running apache server. Just chuck some breakpoints in there and use your unit tests for code inspection while you're running tests! Debugging in PHPStorm is incredibly powerful (Pin certain variables so that even if you don't have too many breakpoints, it'll automatically break when that variables changes. Got a breakpoint, and interested in what a certain method would return **at that point**? You can just evaluate an expression in the middle of execution to see the results), and I don't even know most of it * **Other Language Support** PHPStorm is built on top of WebStorm. That means you get all the lovely features of WebStorm if you ever need it. Gulp integration, Bower, SASS/LESS/CoffeeScript watchers, various JS library support. All of it is just amazing. As a PHP Dev, I don't need these things. But the times I do end up using them, I'm so glad I don't need to go set up another tool to do so * **All of these are first class features** What does this mean? It means that these features are the main focus of the product, as well as so much more. It means that they aren't just an afterthought, tagged on to appeal to a broader audience, they're things that were carefully crafted and designed to do just what you need, just how you need it to. There's a large difference between first class and second class features. Honestly? All this doesn't even begin to scratch the surface. This is such a small subsection of what PHPStorm does, and does well, that I could write for hours just about the features I *know*, let alone the ones I'm still discovering. Whether or not PHPStorm is worth it to you, these are the reasons it's worth it to me.
&gt; If I'm reading your code right, the loop only retries when the commit() throws an exception? No only if it returns false. Can PDO::commit() throw an exception? If yes, the manual sucks. &gt; Postgres can detect serialization failures at any point in the transaction, and so a PDOException coming from the user's callback may indicate a retry is needed. To be honest I didn't evaluate that field too much yet. Your point that Postgres will throw early exceptions is valid. I'll see if I can cover this in a sane way. &gt; I just can't think of a way of handling it without the client code participating I think that is acceptable. As only the client knows details about e.g. required isolation level or if a constrating violation requires a replay. I will adopt that idea that the client needs to explicitely require a replay.
Big letters though. That's important. Also maybe it should blink.
In the same boat as you. What plugins do you use for ST3?
commit() will throw an exception if PDO::ERRMODE_EXCEPTION is used (which I always use so had forgotten there was an alternative, tbh)
I didn't read the fine print, you could've just said this subreddit isn't for support. No need to be a dick about it.
Good luck going through life acting like a 10 yo.
You could do that fairly easily with a regex find/replace.
It is when you're on shared hosting.
Sure. Just stating how it is. Most of these WP sites are on some cheapo hosting and aren't gonna spend the time to migrate their whole site, when from their view there is nothing wrong with their current hosting. Wordpress needs to up the minimum PHP version to 5.3/5.4 to encourage people to switch.
Package Control (obviously), SublimeLinter plus any linters I need (primarily php, phpcs, eslint, scss-lint), Sublimerge Pro, SFTP ("Winrar"-free), ColorSublime, DocBlockr, Emmet, GitGutter, PHP Companion, SublimeCodeIntel, Trailing Spaces, plus any custom syntax highlighters I need (e.g. Blade). It's a pretty tall stack of plugins but it duplicates 98% of what PhpStorm can do.
you can try it for a month, but It have a learning curve about 10 to 15 days for me. If you watch the laracasts before starting it this curve might be shortened. But again I'm really recommending you to buy it. I never felt this much comfortable with anything else out there.
I doubt that WP users are really interested in new features anyway though - so that doesn't really matter - Wordpress developers are working a different world to the rest of us in many ways.
After dealing with numerous and absurd os dependant case sensitivity issues with MySQL, I've decided that I'd rather have all my SQL identifiers in lower case.
Stop making him use PHPstorm guys. This guy is cheap. 
Still here man. Thanks, just reading everyone's input. Because of the overwhelmingly number of posts in this thread which just recommended PHPStorm off the bat without saying what makes it such a good piece of software, I was initially skeptical of whether or not it's worth buying a license for. However, based on yours and a few others' posts ITT detailing the pros of using PHPStorm in comparison to other IDEs, I'm pretty sure I will give PHPStorm a try and make my own sound decision
Did they make it twice as fast by disabling garbage collection?
Ya that was my plan all along. Never said I was stuck on one piece of software or that I wouldn't try PHPStorm myself, just wanted to see what others opinions of it were before investing in it, since apparently its recommended and held in such high regard here.
&gt; Because of the overwhelmingly number of posts in this thread which just recommended PHPStorm off the bat without saying what makes it such a good piece of software, I was initially skeptical of whether or not it's worth buying a license for. Yeah, that problem is that most people expect others to at least know about what makes PHPStorm special. It made such a whirlwind in the community that it's hard to imagine people not knowing too much about it. The other issue is that everyone has their own reasons for loving it. For me, the PHPUnit, Debugging and Code Coverage is a new favorite feature of mine. My old favorite features were: Symfony 2 Plugin, Better Autocompletion (I've found PHPStorm to provide faster and more accurate autocompletion off the shelf than other IDE's), JS/HTML support (I've found it works better as a full stack IDE than Netbeans or Zend Studio) and autoformatting (It's just eaiser, faster and works better than other IDE's that I've used, and supports more langauges). Someone else I've talked to finds his favorite features includes Vagrant integration for remote interpreters (Rather than needing PHPUnit, PHP, XDebug and so on installed on your local machine, if you're developing on a Vagrant machine you can just get PHPStorm to use the tools on that machine as if it were local), File Watchers (Again, for front end stuff), Postfix (not my cup of tea, but okay) and a powerful custom code templating things (Being able to define a "template" that you can insert in to your code with a few easy keystrokes). But yeah. Let me know how you go
AWESOME. I happen to have one :D
That and PCNTL isn't available for the Windows version of PHP. But I also agree that releasing new code for an unsupported version of PHP has bad idea jeans written all over it.
First of all, let me say, I think this was a good effort at trying to get something to work and I appreciate you sharing it with everyone. I know that pouring hours of hard work into something and having it blow up in your face from time to time is no suiting reward to your efforts. So I'm definitely not here to tear you down. Though I would like to convey a few general observations I think are worth considering. Claiming that some PHP code/library doesn't require some PHP extension is about the silliest possible argument one can make to strengthen their support and exposure for said code/library. First of all, all of PHP is built on extensions. Everything from basic string/math/array functions you use in PHP to the moon and in between are made up of extensions that *extend* the core of PHP, which is nothing more than a parser and runtime, really. Plus, with the ease and simplicity with which most *nix package managers make it to install various PHP extensions today, is this really a barier at all? It takes a single command to install PCNTL with most package managers and can also be trivially installed via the PECL/PEAR installer. I know that some people are under the misled impression that they are actually creating added value and benefits for the community when they try to support older, EOL, versions of PHP with code/libraries that have backwards compatibility with those unsupported, EOL versions of PHP, and little-to-no dependency on various extensions - and that may be true in the near-term (to some extent). However, I believe that efforts like this only serve to hurt the community at large in the long run, because they encourage wide-spread stagnation to upgrade, and allow people to further endorse such efforts in order to remain as stagnate as possible. This creates a confirmation biased that people will likely *double-down* and defend withering technology in fear of their, currently aging, software from breaking down due to an upgrade. This is bad. We really need not encourage such behavior as we already have such a huge adoption gap in the PHP community as it is. Look how long it took people (and is still taking them) to adopt newer, safer, more performant, and more tenable database drivers like PDO and MySQLi over the older and now removed mysql driver in PHP.
Hi, so I took some time to do it (after I managed to kill all my projects tasks). procedure: https://github.com/boussou/php-framework-benchmarks video: https://www.youtube.com/watch?v=QA07YEIRN4Q&amp;feature=em-upload_owner 
There are a lot of hidden easter eggs on php.net that have been added over the last year or so. Here are a few you can try out... - Type "logo" and hit &lt;enter&gt; while at php.net and it will randomly change the logo in the top left-hand corner. - Type "I hate PHP" (*case sensitive*) and hit &lt;enter&gt; while at php.net and you will be redirected to python.org - Type "I love PHP" (*case sensitive*) and hit &lt;enter&gt; while at php.net and you will see a geeky aphorism popup - Type "rotate" and hit &lt;enter&gt; and the site will rotate 90 degrees - Use the Konami code "*up up down down left right left right b a enter*" and hit &lt;enter&gt; and you get a special Konami logo - Type "mirror" and hit enter and it's like looking at the site in a mirror -- *creepy* - Hit &lt;shift&gt;+/ on your keyboard to get a help screen popup for shortcuts - Goto http://php.net/sunglasses to get Rick Rolled -- *you probably don't want to though* - Type the letters "g" and "a" and the lights go out... *spooky* - Type "unreadable" and hit &lt;enter&gt; and the site will be re-rendered in a plain-text version (*careful you have to use "readable" &lt;enter&gt; to get the site back to normal from here*) Cheers! 
Nobody reported any incompatibilities with other extensions until now.
Because ``ps`` and ``kill`` exist on Windows?
Sure, but you do realize that's because forking is not possible on windows, right? The process control library wouldn't work on Windows. Plus, how many people do you know of today that run production web servers with PHP on a Windows operating system? Even developing on Windows is no longer necessary with technologies like [vagrant](http://https://www.vagrantup.com/) and VirtualBox where you can literally spin up a linux dev environment in a matter of minutes and still do all of your work in your native host operating system without having to run your PHP on Windows.
That's how I do it. 8 year-old code of mine: https://github.com/phpexpertsinc/redditmirror/blob/master/users/profile.php#L42
I got my employer to buy me a phpstorm license. I keep going back to vim because phpstorm just does weird unexpected things that I haven't been able to (err... haven't taken the time to) figure out how to configure, and I've been using vim for too many decades to easily switch to something else.
PCNTL is an extension that is bundled with the core and is either already available if you install PHP or can be installed directly from the distributions package manager. There is absolutely no reason to not use PCNTL which is as hard to install as the MySQL or SQLITE extensions. And you would surely not suggest you should use your own MySQL client implementation using sockets because it is an extension.
t1.micro is a terrible instance type to perform any benchmarking. You should use a m3.medium to get some "stable" performance vs random bursts.
The "(We seen a lot of variation during the tests)" is due to the cpu-burst of the t1.micro instance type. If you take a look at the CloudWatch metrics of the instance you would see spikes and throttles applied by AWS.
Laravel 4 project 16:25 (develop) ~/Development/[redacted]/api$ phpqa analyze --project=php --files=app/ PHP QA Analyzer Files to analyze - app/ Check composer.json &amp; composer.lock files Running Paralell Lint Running PHP-CS-Fixer Running PHPCBF Running PHPCS Running PHPMD Running PHPLOC PHP PHPCPD Copy/Paste Detector Running PHPDCD Dead Code Detector Running PHPUnit PHPUnit 4.6.10 by Sebastian Bergmann and contributors. Configuration read from /Users/ronni/phpqa/config/phpunit.xml.dist Time: 145 ms, Memory: 3.50Mb No tests executed!
No errors, see below
To be strict, the extension reflect the execution context in every fraction of a second. I didn't recorded the extension in action I'll do it soon.
You can always break them up into separate files. For example, you could have `public_routes.php`, `member_routes.php`, and `admin_routes.php`. Just add them to your `RouteServiceProvider` class. The one thing you probably *shouldn't* do is conditionally include those route files. It just seems like a bad idea.
&gt; $(document).ready(function(){ &gt; $( "#myForm" ).submit(function( event ) { &gt; var email = false; &gt; &gt; email = $('#email').val(); &gt; console.log('email : '+email); &gt; &gt; if($('#sendMail').is(":checked")) &gt; { &gt; console.log("Checkbox has checked"); &gt; &gt; // Do what ever you want to do when checkbox has checked &gt; &gt; return true; &gt; } &gt; else &gt; { &gt; alert("Please check the checkbox to send email."); &gt; return false; &gt; } &gt; }); &gt; }); Thank you so much man! It has worked &lt;3333 :)
Has anyone profiled Laravel to see where all that slowness is coming from? I think it'd be a curious case study, even for those who don't use Laravel (but especially for those who do).
id rather see it on a $5 DO instance myself but thats just because I am familiar with it.
It's not about the medium or large instance, it's the fact that the t1.micro has a fluctuating CPU depending on throttling and CPU wait spikes. IMHO I believe all benchmarks should be run on a clean dedicated server to ensure full resource usage, but that's just me being nitpicky.
It will, if cygwin is installed and added to %PATH%.
I am going to guess a lot of the slowness is the construction of the 100 objects and the dependencies graphs for it all.
MySQL has weird defaults on some platforms, so you need to fix the config value for "lower_case_table_names". 1. Are you on *nix: nothing to do (default is 0, you need 0). 2. Are you on Windows: set to 2 (default is 1). 2. Are you on OS X: nothing to do (default is 2, you need 2). Using 0 also works on Windows for development, but the manual has macabre warnings about possible index corruption (never happened here, but...), so better not.
The fact that composer is causing a negative affect tells me there is something wrong with your stats... that just simply should not happen ever, because the the optimization in composer creates a class map of every class in every dependency and writes it to a file saving a file_exists() os call. 
IIRC, the biggest single points of slowness come from the IoC container (which is about as slow as Symfony's) and the bootstrapping thereof.
This project is in its early stages. Its essentially a bridge between the [Slim Framework](http://www.slimframework.com/) and the [PHP OAuth2 Server](http://bshaffer.github.io/oauth2-server-php-docs/) projects. 
k.
&gt; Homestead is not a viable way to perform benchmarks IMHO. No doubt, I'm just pointing out that I'm not sure he's concerned about benchmarks past what works for him. Should he be? That's obviously debatable.
&gt; I'm not sure he's concerned about benchmarks past what works for him I agree. Besides He said "Lumen is the fastest". He should say "Lumen is faster (than Laravel)". He could also say "Lumen is (among) the fatest". Kidding.
That is so far away from any sane production environment now it's just a "because I can" argument.
Preface: I don't do any of my dev work on windows. &gt; Sure, but you do realize that's because forking is not possible on windows, right? Really? No kidding. And that has NOTHING to do with what I said. I was replying to the point someone made regarding the use of pcntl, which isn't available on Windows natively. &gt; Plus, how many people do you know of today that run production web servers with PHP on a Windows operating system? How many people do you know that are forking processes in a Web application? &gt; without having to run your PHP on Windows. Why not? It's a great language for quick scripts, jobs and common tasks.
Also as a follow up on this in general, what is the recommended way to implement `collect` for this workflow? - looping through a highly variable length list of jobs, submitting all to $pool, then shutting down. I've also seen `collect` used in some examples as the reporting point (ie `$job-&gt;results` might be how you store what happened to job and then you grab it from collect). Is this a better way to approach reporting on the outcome of the job? I'm just having trouble understanding how I'd implement that after $pool-&gt;shutdown because I can't just have all the jobs hanging around in memory until shutdown finishes right? EDIT: Here's the example I'm referring to: http://php.net/manual/en/class.pool.php#116980 That workflow would be great, I'm just not sure how to adapt it to a big job list.
Can you please re-read that comment. It's not one class entry. My argument is you can use a map subset so small (in a map so big), the cost of loading the map is larger than the cost of the file stat operations for the classes you'll need in that request.
Author's Original Submission on [Hacker News](https://news.ycombinator.com/item?id=9942549)
Hey /u/pmjones, I'm not a huge fan of Laravel and Lumen, too. But, how about Aura? I read recently that it is not that fast either: https://github.com/tyler-sommer/php-router-benchmark Are you going to improve the 800% to 1600% slower performance after we're done shaming Lumen / Laravel?
I don't even use CI anymore lmfao. How is it clear I am a noob? Please show supporting evidence.
That's kind of uncalled for, he didn't even mention Aura. Plus I think Aura has a different audience than the average framework user.
Unfortunately, it's not as simple as simply casting the argument to the respective type. The ZPP rules are stricter than explicit casting (thank god). See the following gist example for an idea of what would need to be done to back port a string type declaration (assumes coercive mode): https://gist.github.com/tpunt/ccab636067a3f815dec8
That's what I meant by "in the very least". I think it's ok for a code backporting tool to *not* emulate conditions resulting in a fatal error, because the presumption is those are a developer error, hence won't be in stable code. Say, stripping non-scalar return types is fine, I think. The cast for scalars ensures you get identical results in the non-fatal cases (i.e. you expect a string, you get a string).
Well: &gt; sham, noun: "a thing that is not what it is purported to be." If the marketing claims behind Lumen are provably false, then that makes it a sham. We all know Taylor is walking a thin line in his marketing efforts and at times he ends up on the wrong side of it. The fact he's doing hard work doesn't mean he should be spared fair critique. The authors of Slim, Silex and so on are also doing hard work. They deserve to be seen fairly by developers, and most of all, developers deserve to receive accurate and balanced information about the components they're being offered. 
True. Look also at the so called "Facade" of Laravel. It is deadly slow, calling a service provider per each method call. 
Im so super excited to finally announce that PHPixie 3 as well as the new website are out now. The tl;dr version of the changelog is that evertthing has been rewritten and has a ton of features. Some of those: * Following the the PSR-2 and PSR-4 code standards * Using PSR-7 and also providing easy to use wrappers and common response templates. * Plain PHP templating engine supporting layouts, blocks, pluggable extensions and even supporting custom file formats ( e.g. the HAML syntax is coming soon ) * Easy to use ORM that splits models into entities, queries and repositories while being as easy to use as acyicerecord ones. Supports relationships between relational DBs and MongoDB and optimized bulk operations ( e.g. assign multiple articles to multiples tags all in one go with a single database query). * While supporting cross-database relationships also features opyimizations for relationships within same database ( uses subqueries instead of lists of ids where possible ) * The Processor approach allows to use old style Controllers and ADR Actions * A Debug compobebt for variable dumps and pretty traces. * Versatile configuration component, that supports directory based mapping. So that key language.english.word can be retrieved from the language/english.php file, etc 
Loading routes shouldn't incur a significant amount of overhead unless you have a *lot* of routes, on the order of a thousand or more. And if that's the case, Laravel provides the ability to cache routes out of the box (which would become impossible if you conditionally registered routes). Plus, this would mess with your ability to inspect your routes from the command line. On a more philosophical level, I consider routes as part of an application's high-level configuration or bootstrapping process. That shouldn't significantly change depending on what the incoming request looks like. 
lmao Laravel is built on Symfony components
[Hmm...](https://forums.frontier.co.uk/attachment.php?attachmentid=13731&amp;d=1423399675) **EDIT:** Oh damn, he edited it. FTR, it originally said me, /u/pmjones and /u/inducido are the same person.
This is precisely what I do.
This is great, OP! 
Yes, it only applies when you have a really large number of classes. Otherwise map is fastest, ofc.
Kinda missing the point of this post lol
only smoke i see here, is the stuff coming out of you.
Hilarious
&gt; Claiming that some PHP code/library doesn't require some PHP extension is about the silliest possible argument one can make to strengthen their support and exposure for said code/library I encourage you to read the accompanying blog post. It explains that the reason I wrote this library was not so that new users (using a sane version of PHP) would adopt the queued jobs module this was initially made to go into, but rather so that existing users could have multi-process support in a minor upgrade to a library they are already using. There is immense value in that. Now, don't get me wrong. I am not a fan of supporting old versions of PHP. If I had my way, every project I worked on would support `5.6` and `7` only. That's not realistic though. SilverStripe has been around for a decade, and we have a huge installation-based in New Zealand. There are government agencies depending on the work we do, and who are still on old versions of REHL (for LTS etc.) which don't ship with an out-the-box PHP `5.4`. And while we are strongly encouraging them to upgrade their server infrastructure, we certainly can't force them to. We also want to improve the stability of deferred processes which their servers run. This is why we wanted to allow for parallel task execution. We _could_ just tell them they can't have parallel task execution until they upgrade their infrastructure. We could require them to use a new major version of the queued jobs module. That would be a breaking change. The trouble is that more of these government agencies don't employ developers. At some point they hired developers/went to a development agency to create their website. And every time they _have_ to upgrade their application, they have to bring in more development help. That cost loads of money and causes no end of headaches. We didn't want that to happen. So I was instructed to make this parallel stuff work in a minor upgrade. That way consumers can upgrade without anything breaking. That required that I use no additional extensions and that the parallel execution code work in PHP `5.3`. And that's what I did! &gt; I believe that efforts like this only serve to hurt the community at large in the long run You're welcome to believe that. I agree that using/allowing old versions of PHP to be used isn't great. You're thinking about all of this in theory though. There are real concerns at play though. Like sane upgrade paths, Semver, Linux distributions being slow to support modern versions of PHP, LTS contracts, 24/7 support teams who need to be trained and equipped, framework eco-systems that need to move forward at a steady pace... It's not as simple as saying "drop support for older versions of PHP as soon as they become unpopular". I would love to, and I'm sure it would avoid headaches for all, but this process of supporting newer versions of PHP is just that: a process. Think of this PHP `5.3` support as a compatibility layer so that people have more time to adjust their applications before we do drop PHP 5.3 support. We actively encourage all of our users to use modern, secure versions of PHP. That's not harmful. 
It's irresponsible to to use unsupported versions of PHP. It's also irresponsible not to honour LTS support contracts. We have to support users already on PHP 5.3, until they decide to move to a sane version of PHP. My comment to /u/phpread spells that out in more detail.
&gt; It's also irresponsible not to honour LTS support contracts. You have a contractual agreement with your customers? That does change the calculus a bit, but you should help get them on PHP 5.6 ASAP. Luckily, I manage to avoid these problems.
The thing I like the best about v3 is that it is less of web framework and more of an "application" one, since the HTTP part has been separated into a single place, and the Processor approach doesn't care if its web or not.
&gt; commit() will throw an exception if PDO::ERRMODE_EXCEPTION is used So I guess you made that experience already? I'm just asking, as this is not mentioned with one single word in the manual section for PDO::commit(). If I compare however PDO::prepare() I can read an explicit exception in the manual. Well, at the end I have to make some tests to figure out how that API works.
I wish every website could have that redirect script. Burn IE to the ground. Die in a fire blah blah blah
I did some very non-empirical testing on a c4 type instance which is currently the best instance type for these kind of workloads. I chose the c4.xlarge instance, 32gb of ssd based storage and used default AMI packages for everything. Here are my notes: https://gist.github.com/mglinski/0dd0033bf2834cb7d66f TL;DR: Lumen is ~18% faster then Slim2 when producing the same basic view from the same basic route.
http://technoyes.com/php-ile-dizin-alt-dizin-ve-dosya-silme-islemi/
Well you can use it of course as you are using a map (you call it array in PHP). A binary tree is sorted data structure. This allows some operations to perform very efficient, e.g. range queries, min or max. OTOH you don't need to bother as you are using such things with your DBS anyways.
Just use a tree which has that feature incorporated e.g. an AVL tree or an red black tree.
I hope it kept the same spirit (KISS Pixie ;-)
Not slim3?
``fork()`` keeps the state of the current process, thats true. So ``if (0 ===fcntl_fork()) { exit(); }`` does the job just fine! I bet there are a thousand edge cases you can never ever gracefully handle with your approach. E.g. races for the PID in very busy environments, you may sometimes kill a process that just died before. If you fork, you need to have real info about the child processes, not best guesses.
I noted the most important parts to getting high rq/s numbers in my notes. The main things you need are: * Recent Intel CPU with high clock speed * DDR3 RAM * SSD Storage with guaranteed IOPS * Extra memory to dedicate to Opcache * Opcache settings that will ensure that every single file will be cached, default settings will start to hit the limits here * PHP-FPM with a static number of child processes, = to 100% of your virtual CPU cores + 1 * PHP-FPM using a unix socket instead of local TCP over port 9000 (the default) * Nginx with all logging disabled or sent to syslog sockets * Nginx using try-files to pass to php * PHP with all logging disabled or sent to syslog sockets * Using 127.0.0.1 or a domain name that locally routes to 127.0.0.1 in your machines host file * Setting nginx to have 2 workers with 10240 events per worker * Setting nginx to use epoll * Setting nginx to have low process priority * Setting PHP-FPM to have the highest process priority This is the current fastest php setup I have. Its not very real world realistic in some areas, but speed is speed. The only thing that gets faster then this is manually building your whole stack from source (which you should totally do on your own boxes). Building from source allows you to disable modules and features that take up memory and small CPU cycles (even if never used). You can also enable things like more advanced optimizations and compiler features.
Bad time to mention the [Django pony](http://www.djangopony.com/), then?
Any idea how to even track something like that? Like, how to know which file/function is causing this? It's a pretty big and 3rd party framework so would take a while to read and understand what its actually doing. 
Did you set the suphp_configpath to the ini?
(MediaWiki developer here) What kind of performance problems? There are some easy guides like ["How to make MediaWiki fast"](https://www.mediawiki.org/wiki/User:Aaron_Schulz/How_to_make_MediaWiki_fast) and various caches that need to be enabled to get things speedy.
These classes are built using internal factories. That class should never be instantiated with anything else but the PSR-7 ServerRequest as the parameter and it never is, unless you circumvent the entire system and decide to do it yourself. I don't use constructor typehinting since in my tests it does pile up to a hefty overhead to have it everywhere. I am however in the process of writing docblocks to tell the user ( and the IDE ) what can be passed where. On top of that you aren't really supposed to instantiate any of these directly. I have factories for everything. &gt; it could be null, a boolean, a string, just about anything which will result in exceptions and errors If there was typehinting, you'd still get exceptions if you pass a boolean. In any case whoever decided to pass the wrong parameter will have to fix it.
Just think of it as a PHP-Ixie framework =) It's not like there are fairies in method/class names
Thanks
It's still simple, just more stuff it can do =)
A factory pattern would certainly suffice for something like what you've described. In essence, your factory class would have a method that would take some identifier or type, and possibly any parameters you might want to pass to the created object, and then return your fully constructed object. For example: class BabelFish { public function create($lang, array $opts = array()) { switch ($type) { case 'en': $ret = new English($opts); break; case 'es': $ret = new Spanish($opts); break; } return $ret; } } This way when/if support for your languages grows, you add a new case statement and you're good to go. Your language classes should also implement a common interface so that no matter what language is used, and no matter how you implement the translations, it'll just work. 
&gt; I don't use constructor typehinting since in my tests it does pile up to a hefty overhead to have it everywhere. How so?
I've updated my description with a stripped down version you can run on the latest php (5.6.11) that illustrates the behavior I'm running into. Also tried it with the locking you suggested and it made no difference: &lt;?php class Job extends Collectable { public function __construct(Threaded $storage) { $this-&gt;storage = $storage; } public function run() { $this-&gt;lock(); $this-&gt;storage['test'] = $this-&gt;storage['test']+1; $this-&gt;unlock(); } private $storage; } $job_count = 10000; $pool = new Pool(4); $shared = new Threaded(); for($i = 0; $i &lt; $job_count; $i++) $pool-&gt;submit(new Job($shared)); $pool-&gt;shutdown(); echo implode(PHP_EOL,[ '', 'RESULTS:', '-------------------------', '$shared[\'test\'] = ' . $shared['test'], '$job_count = ' . $job_count, 'Equivalent?: ' . ($job_count === $shared['test'] ? 'true' : 'false'), '--------------------------', '', '' ]);
Ok, I've updated my post description with a stripped down example that illustrates the problem I'm running into on the latest php (5.6.11) and latest pthreads from github.
I was well off base then ... &lt;?php class Atomics extends Threaded { public function increment($member) { return $this-&gt;synchronized(function($member) { return $this-&gt;$member++; }, $member); } public function decrement($member) { return $this-&gt;synchronized(function($member) { return $this-&gt;$member--; }, $member); } } class Job extends Collectable { public function __construct(Atomics $atomics) { $this-&gt;atomics = $atomics; } public function run() { $this-&gt;atomics -&gt;increment("test"); } private $atomics; } $job_count = 10000; $pool = new Pool(16); $shared = new Atomics(); for($i = 0; $i &lt; $job_count; $i++) $pool-&gt;submit(new Job($shared)); $pool-&gt;shutdown(); echo implode(PHP_EOL,[ '', 'RESULTS:', '-------------------------', '$shared[\'test\'] = ' . $shared['test'], '$job_count = ' . $job_count, 'Equivalent?: ' . ($job_count === $shared['test'] ? 'true' : 'false'), '--------------------------', '', '' ]); That should do it ...
http://simplehtmldom.sourceforge.net/ Very easy to learn and apply, takes practice though.
I saw this. Thanks, I gave it a download and I guess I can read through some code and see how it works. On a seperate note entirely I guess, how safe is it for me to be downloading third party libraries, especially from somewhere like source forge?
I agree with your philosophy of downloading safety. thank you
Well I did see a difference in benchmarks, but I see your point. Do you feel type hints should also be mandatory even when there are apptopriate docblocks ?
Symfony has a great DOM component. You don't need the Symfony framework to use it: http://symfony.com/doc/current/components/dom_crawler.html 
I can vouch for this. I've used this library on multiple occasions at my job for scrapping data to process and import into databases. Saves a lot of manual labor.
EAP is basically public beta testing. They give you the software in its current state for free, in exchange for the bug reports (automatic or otherwise) that will let them identify and fix issues more quickly. Each EAP release comes with a temporary license that is limited to about a month. After that, you will have to download the current EAP release. Once the bugs have been ironed out, the EAP closes, and you have to buy the actual license. There is no real catch, other than your getting hooked on their (rather awesome) products.
EAP usually continues with the next version development, so in reality you can sit on it "forever". But bugs and other stuff of course interferes with normal work, so that is the downside. But yeah, I just bought the licence after 4-6 months of using EAP just because I liked the product and I actually wanted to have a license (that was 5 years ago) not just to use stable version, but at that time it was like having bragging rights :)
I guess you're right, that is actually why I really like the idea of private classes in Java, it allows for much shorter generated API docs and less BC changes caused by minor fixes. Thanks for taking so much time to reply to me this many times ^_^
IMO it's the best version to use but may be buggy sometimes, if you can handle it go for it - you will get tons of new features and long time of "trial" license. I usually switch between stable and EAP if EAP is currently too buggy.
Why do people still use long array syntax?
Phpixie works on 5.3 too. I decided that since there is nothing in 5.4 features that I need I might as well keep it 5.3 compatible. The only sacrifice needed was the short array syntax
Look at the code. It calls ``ps`` and ``kill`. So you need cygwin or something. Use a better OS and don't cripple yourself because Windows is so limited in its usability.
Now the downvotes are coming from people who don't understand how process management works, nice!
Hi, I have forked the project and added PSR-4 autoloader, tests, phpdoc, etc. ¦ https://github.com/voku/simple_html_dom
yes
What would be the point? It's not like they're under-represented now such that we need to call them out like this or so over-represented that they drown out quality content: this sub primarily consists of people showing off their projects, people spamming their blogs for SEO, PHP announcements, and people who can't find /r/phphelp.
just thinking about reading through people's "showing off" to find a potentialy usefull library I can use for my (real life) work is a pain what's wrong with reading titles and clicking when interested?
instead of making two comments, you could have just edited the first one. 
I never said people should only post completed projects, only what they're working on, worked on this week. I'm shooting more towards WIP's not finished production ready library components. I'm also not saying people shouldn't be allowed to post that. I'm also not trying to stop people from making new threads either with production ready library components, frameworks, etc... ~~I could also ask what's wrong with reading well formatted posts in a concentrated area?~~ Edit: Downvote's are crazy in this thread
It's way worth the money. You usually can find it on sale. I think i paid 50 for my initial license. Soooo worth it.
Exactly what I was getting at. Thanks
Yes yes yes! Thank you thank you thank you! Man, I thought PEAR was doomed. Best news yet to come out of PHP dev.
With composer and github there no reason to have a monolithic package management framework anymore. And personally I would suggest using any number of MVC frameworks (Zend, Cake, Symfony, Silex, Laravel)that have way better documentation, sample code, and best practices. 
+1 for "if you want to look like a leet hacker"
SaltTM, I'd suggest sending a PM to the mods if you haven't already. They've been fairly open to feedback in the past (moronic monday came out of a user suggestion).
No one locks you into Symfony. They have tons of components... And silex - that is one of the most open tools I have ever used in my life. It doesn't lock you into using anything. We have Composer, and lots of packages are dropping PEAR support for Composer. There's no point in having two. (Looking at you, node.)
I thought we finally killed it.... Guess not :/
http://blog.phpdeveloper.org/ is up, at the very least. Maybe a DNS/vhost issue? I'd ask /u/enygma though.
With some proper love and care taken, I think PEAR could become quite popular again.
A weekly open source newsletter and website? I can jest publish my internal application and we are ready. Just need some writers and authors to be involved. What do you think?
As you appear not to have any kind of programming knowledge, to build what you want in a way which won't suck, you need somewhere in the region of 300k to 1 million for development and marketing. There is no reason one could not use php to archive this, but almost any other web language would also be a fairly good fit. if you actually have something which resembles a business plan you would be better off asking about start up related stuff somewhere like /r/bussiness or /r/startups 
Awesome, that's exactly what I was looking for. Thank you so much for your help and for your work on pthreads in general. This is the first time I've played with threading so it's nice to be able to do so with a language I'm already familiar with. If I could ask one follow-up, how would the example look if I was trying to submit 1,000,000 jobs? I understand I need to call `$pool-&gt;collect()` to throw out the completed jobs, but I'm having trouble finding an approach that works. I tried calling collect every few `$pool-&gt;submit`: (modified `Job::run` to do `$this-&gt;setGarbage()` at the end of course). for($i = 0; $i &lt; $job_count; $i++) { $pool-&gt;submit(new Job($shared)); if($i % 100 === 0) $pool-&gt;collect(function($job) { return $job-&gt;isGarbage(); }); } But I'm still running out of memory. I also tried shutting down the pool and building a new one: for($i = 0; $i &lt; $job_count; $i++) { $pool-&gt;submit(new Job($shared)); if($i % 100 === 0) { $pool-&gt;shutdown(); unset($pool); $pool = new Pool(16); } } But this runs extremely slowly, even on the 10,000 job set so I don't think it's a good option.
As a developer you've probably had situations where a project's requirements keep evolving over time and when the project ships, you look at your code and think "well, if I knew what the end goal is, I definitely could've coded this better". That's what PHP7 is. It takes the language's existing semantics after years of gradual piecemeal evolution, and comes up with smaller, more efficient data structures that implement them with less indirection (no pointer to a pointer to a pointer...), less redundancy (no reference counted reference counters...) and higher specialization to the contained data (no pointless hashmap generation for sequential indexed arrays), and voila, it's much faster as a result. There's significant simplification in the way objects and arrays are presented internally, among other changes.
I would highly recommend starting with a mature content management system like Wordpress, or my preferred: Drupal. You can achieve all the article types, ecommerce, geotagging, comments/forums, and advertising integration you're looking for in Drupal. It's very configurable and flexible. To fire up a demo Drupal site to play around with, take a look at: https://pantheon.io/. You can try "vanilla" Drupal, which doesn't appear to do much out of the box (needs LOTS of configuration). Or you can try one of the pre-configured distributions there. But to echo another comment in this thread, if you're going to outsource this with custom design, theming, and functionality you're not going to get a hit for less than $250,000.
&gt; You seem to have a nose that you enjoy looking down Well isn't that just the kettle calling the pot black.
Im sensing the inevitable.. &gt; I can't pay you but I'm more than willing to offer shares in this business and the exposure you get is invaluable I hope you're a very wealthy person because as /u/sli180 has already pointed out, this won't be cheap.
&gt; I can do the front-end. I have built a Linode with ningx engine. what..
I really like to use https://code.google.com/p/phpquery The only issue is that it has not been updated in some time.
The problem is that answers don't get any more learned than what he gave you. If you're waiting for an assertion that PHP (or any other platform) is objectively better than other languages for a specific domain you won't get it. There's nothing special about the ecommerce aspect aside from PCI obligations.
[Nailed it](http://www.eonline.com/eol_images/Entire_Site/2014231/rs_560x315-140331131934-feudama4.gif). .^SorryTheLowQualityGif.png
&gt; I'll need about tree fiddy. $350. Done. This is your man right here. 
Same car shell, same steering wheel, same comfy bucket seats -- better engine inside.
&gt; I was the director of an innovation assessment center in a business college in a university, faculty member for 11 years, director of an entrepreneurial program at another university, one of the consultants clients are referred to by the regional Small Business Development Center, founder of three b-to-b businesses, including one PR/Marcom firm that worked with Fortune 500 companies nationally. Yeah, I'm going to have to call BS here.
I'm sorry, but your point is absolutely ridiculous. Replacing the MVC router isn't a *component*, it's a fundamental plumbing of the system. And by replacing, I'm assuming completely rewriting and not simply refactoring the code to follow the same api (because that would be the only example that makes sense). To use your analogy, you're not talking about swapping hard drives between compatible systems that actually have to agree on a standard on which to interoperate, but what you're *actually* talking about is the equivalent of taking an AMD processor and trying to duct tape it to a SUN microsystems motherboard, and then saying "See? It doesn't work!". Of course, it's not going to work, and it'll take you an unrewardingly large amount of effort to make it work. What you're complaining about is a function of the problem domain, not a function of the framework. MVC routing, by its very nature, is a complex problem that touches a lot of other areas in the system. In fact, I challenge you to actually give a real example of an proprietary MVC codebase where it's actually possible to replace the routing component (by your definition). The framework, because it was written/reviewed by dozens of developers and tested in thousands of environments invariably makes this task easier. Every. Single. Time.
&gt; I'm sorry, but your point is absolutely ridiculous. Replacing the MVC router isn't a component, it's a fundamental plumbing of the system. Wait.. let me get this straight. You went from "it's easy to replace as a component" to "it's absolutely ridiculous to replace as a component" in the same thread? Ok... A week ago I replaced my custom router with Nikita Popov's FastRoute in an existing project. Took me less than an hour, including porting the routes, and I've never used FastRoute before. I realize it seems strange to someone who's depended on monolithic frameworks their whole career. But at least show some modicum of curiosity and will to learn before you start arguing. It's full of standalone router components out there. Apparently people use them just fine. &gt; MVC routing, by its very nature, is a complex problem that touches a lot of other areas in the system. You're describing it like a mysterious black box full of wondrous magic. Here's what routing is: 1. Takes input (typically URL and method). 2. Returns output (typically route handler info and path params). It's not that complex, it doesn't touch anything at all (unless you go out of your way to make it so).
It is its base64 decoded/gzinflated/base64 decoded/gzdeflate/base64 decoded/etc.. many times. But in the end it turns into this: http://pastebin.com/s1DTMVW1 Quite an elaborate '*control panel*' type-thing for the hacker to run sql/perl/shell commands on your server. Edit: [screen 1](http://i.imgur.com/7VWKzqo.png) Edit2: Harr harr harr, apparently the password is "708474fe65a018543c71c6a749cc48e3" == md5("shits") https://duckduckgo.com/?q=md5+shits&amp;ia=answer Edit 3: A video of an older version: https://www.youtube.com/watch?v=ZWo3G7iXW8U Make sure your wordpress/phpthumb are up to date.
Check last few posts here: http://nikic.github.io/ It's not a complete set of changes, but what's covered is a big reason for the speed improvements.
Looks like a fairly standard PHP shell. Generally this would be uploaded to your machine through some sort of file upload functionality that you have and would then be used to help an attacker gain further access to the box. You should be looking very carefully at that machine and potentially nuke &amp; reload if that's an option for you. 
You're post a little hard to read, but from my understanding you'd basically want a site that serves up articles/blog posts, and then intertwines related products for sale into these articles? &gt; Anyway, the ecommerce aspect is shaping up in my brain as Amazon- Ebay-like. Haha sorry but this is a totally meaningless statement. Every eCommerce site on planet earth is "Amazon/Ebay like"! If the eCommerce side of things is relatively simple (&lt;500 products, basic pricing structures) then WordPress with WooCommerce might be a good way to go, given that the primary focus of the site seems to be the articles. You will need a fair chunk of dev work done though, largely depending on how much custom eCommerce functionality you need. $30,000 minimum I'd wager, but could be 10x that if you're looking to get really feature rich.
Man, you're all over the place. How did Laravel get involved in all this? Anyway. I'd suggest you look up what SRP is and thinк carefully how is it a *router*'s job to check your ACL or produce logs. Those are not router features but architectural screw-ups.
I think it's a neat idea, but I also think it'd be 3 weeks before we get incessant repeats of CakePHP, Drupal, ThisPopularFramework, ThisPopularPlugin, etc.
Ok, so the elephant in the room is - how did you decode it. Manually, or?
Lol, how odd. When I tried opening the paste in Firefox, the page would load, and after about five seconds, the page auto-refreshed saying it timed out. I did this a few times to see if it was just a fluke, and got this beauty: &gt; Pastebin.com has blocked your IP :( &gt; We have blocked your IP from accessing our website because we have detected unnatural browsing behavior. &gt; Depending on the violation, the block could be temporary, but also permanent. Eh. I hope whatever this thing was didn't infect me with a trojan or something stupid. Was there any mention of a username it was using to upload/run shell commands through?
Pastebin alternative http://chopapp.com/#113lq7tr http://hastebin.com/xidayumuko.php No usernames, so it should just be running as whoever PHP is run as.
Yes, manually.
This is what podcasts are for.
[graphs](http://imgur.com/LB3Z12l)
Do you think a monthly thread would work better?
Worka fine today
So you mean: don't bother with performance, leave it for later, because you'll never be successful. Or Start building your software without having any chance to cope with success. ;-) That is smart. If you read me well, in such cases be prepared to pay 10 times more for the hardware. It means instead of paying $30 per month, you'll throw $300 per month. Or if you wrote your RESt server in ugly old way (pure php), that's 111x so that's $3330 per month. You right, it is not that important ;-) 
not that php is great but the circle jerk around it on reddit is absolutely insane and really doesn't give me much comfort in any other language ranking generated form here as well.
PHP is also used more by new, inexperienced developers. This is cute but doesn't really tell us anything of value.
I saw someone is preparing the Lumen benchmark at the techempower repo. Good for everyone. In the end, PHP candidates of the techempower are far from the top.. ;-(
Yeah, no way PHP is shittier than Visual Basic.
Not surprising that PHP is the highest in the hate graph. PHP developers are so self deprecating when it comes to PHP. 
You can download the entire IMDB database
[Here, let me Google that for you.](http://lmgtfy.com/?q=TV+series+database+API)
It's also used by experienced developers. 
I heard some mention that this lays the groundwork for a JIT implementation. Is there any truth to that?
JIT has been considered, yes. In fact it was implemented early in the project, but then it was shelved when the basic prototype didn't yield major benefits for real-world apps. And there's now an AST step in the parser which also is groundwork for further optimizations (and will aid in creating a more efficient JIT).
See [this](https://developer.chrome.com/extensions/xhr) but also, kind of the wrong sub, maybe go to /r/chromeextensions.
and there are ways to get aan .eddu eemail adress for free (just google them). 
Thanks for following up!
[TMDb](https://www.themoviedb.org/) has probably the best free API for both movies and TV series.
Sigh....I hate the fact that php is developing such bad reputation. It's like that neighbour that everyone thinks is a child molester because they heard some rumors. It may or may not be true but in the end the bad reputation and damage was created. The php working group needs to release php 7 soon. Somebody please do something
It's not just on reddit... Many "senior" developers hate on the language because of the way it was 10 years ago. The amount of language "fanboyism" is insane in out community. Is it really that hard to admit "Language A might be better in some instances for some people"?
To me, that just sounds like your sec guys aren't aware that you're pulling in PEAR packages.
PHP has had this reputation for years, hasn't really stopped it.
This. I've learned to just tune out people that go for the instant, "PHP sucks," comment. e.g. when some security thing happens on a project written in PHP and they respond with something trying to claim it's a fault of the language. You learn to just ignore them. They're just proving their naiveté.
Right on. I'd also like to mention that if you're just pulling code without security checks, that's not generally a good practice. You should always secure it! I've found myself in several situations years ago, where I'd used HTTP_Upload, and there were a few holes in it, I made a suggestion to the developer, fixed the holes, and committed it back for review. Fixed. There's a certain beauty in that. I also would lock down insecurities in library code by just handling in extended classes. Being resourceful is half the battle of being a programmer, the other half is enhancing what's already built.
Whatever you want to call it, it still is a collection of features, sure it had a package managing feature, but the package manager was built so that one could access the library of code that was in it. You could still strip away all of the package management, and still have a huge library of code.
PHP's history will not be escaped by releasing version 7. While the changes in PHP 7 kind of makes PHP a much more awesome language, a ton of old stuff will be stuck on PHP 5.1 and lots of people will still be hired to work on these old, crappy systems. And so, people will keep whining about it, posting things on StackOverflow, and continue to spread the negative perception.
It reminds me of that where two persons are mocking PHP, then another asks what he should use for a web-based project. The first of the two persons recommends PHP and the second critic concurs.
I've been using fresque for a while and no problems so far! If you already are using Redis stick with Resque else maybe try RabbitMQ
the poster above you is not saying that it isn't used by experienced devs, it's just probably that new &amp; inexperienced devs probably bitch about it more, since they have less of an idea of what they are doing.
That's fine too.
I could not care less about the reputation of PHP on this website. I earn good money with so it is and will stay great.
Yes, but the point is there are MORE inexperienced developers than there are in other language, meaning more frustrated, angry people.
The thing that really sucks is once the neighbor proves he's not a child molester the rest of the neighborhood will say "Oh, okay", but they will _still_ shoo their kids away from his house. Once a bad reputation sets in there's no getting rid of it.
&gt; I tried using the Leaky Bucket and Token Bucket implementations but they space out the requests evenly As author of [bandwidth-throttle/token-bucket ](https://github.com/bandwidth-throttle/token-bucket) I'm very interested why token bucket did not work out for you. Could you please elaborate what you mean by "they space out the requests evenly"? Still I would recommend using a token bucket (with a capacity of 30) for your API. Here's a short example with my library: $storage = new SingleProcessStorage(); $rate = new Rate(30, Rate::SECOND); $bucket = new TokenBucket(30, $rate, $storage); $consumer = new BlockingConsumer(bucket); $bucket-&gt;bootstrap(30); while(true) { $consumer-&gt;consume(1); // Send SMS. }
&gt; Silex is a router and a di implementation. Thats all thats really in it. To replace them, like sylkworm said, would be pointless. And huh.... You literally just did what you said not to do.
While I agree that sleeping is necessary I'd say you broke it. His code relies very much on the fact that $current_time equals $last_time for one second. In your code $current_time is always greater than $last_time.
Not if the neighbour updates himself to version 7 and proves to be great in bed with all the kids' mothers
Hi, Firstly, I have not tried your library, so that's on my next to-do list. From my reading about token bucket and attempts at implementing it (which failed for my purpose), the token bucket lets *x* amount of executions run every *n* amount of seconds, sleeping in between the remaining periods. However, I could be totally off in my understanding of the Token bucket, looking at how extensive your implementation is. For my use-case I want to go through all executions sequentially without sleeping between executions. If there is any period left-over, the process can sleep during that period. I will go through your implementation with more time and get back to you if I have more questions. EDIT: Just saw your updated post with an example. Thank you. I will give it a go in the morning.
Ha, this is so true. Check out the Chrome HTTPS post in /r/webdev, there are loads of comments blaming PHP incorrectly when the problem was with Wordpress plugins and Magento.
Spotted that. Here is my fixed version of mglinski's first version: function ratelimiter($max_executions_per_second, callable $callback) { $count = 0; $last_time = microtime(true); while (1) { $count++; $current_time = microtime(true); if (floor($current_time) &lt;= floor($last_time) &amp;&amp; $count &lt;= $max_executions_per_second) { //Do Something $callback(); } elseif ($count &gt; $max_executions_per_second) { $sleep_time = ($last_time + 1.0) - $current_time; usleep($sleep_time); // prevent lots of while(true) ...continue; loops when you know the exact amount of time you need to wait $current_time = microtime(true); } if (floor($current_time) &gt; floor($last_time)) { //reset time &amp; count $last_time = $current_time; $count = 0; } } } Just floor'd the current_time and last_time in the if statements to get the full second behavior back.
Thanks. The *sleep* is a good optimization. Thank you.
Exceptions are the (ahem) exception that proves the rule.
Rwasa webserver binary is just 364K; [performance tests](https://2ton.com.au/rwasa/#perftests) serving static files show speeds about 1.5x those of nginx.
I found it awkward the author opens by talking about premature optimization, then links to this... http://ubiquity.acm.org/article.cfm?id=1513451 ... which opposes most of what he said.
Great. Glad the site is back up. Enjoy reading the articles you post there.
Hrm. The N+1 query "rule" is very basic and shows the author doesn't have experience working at large scale. Sure it's good to avoid multiple queries when you can but it's not as cut-and-dry as just saying to use table joins or IN clauses. In fact when it comes to scaling you can generally scale web applications horizontally pretty easily ... with the exception of the database. The database always becomes the bottleneck. In many cases following the authors advice and writing complex queries (e.g. multi table joins etc). is more harmful performance-wise than making smaller more efficient queries to pull down raw data and let the application do further processing (which is what you want to do if you care about horizontal scaling). It also doesn't get into the most common problem I run into with new developers which is establishing a new database connection for each query (often in a loop ... sigh).
Yes, you're right, architectural boundaries don't exist in re̼a̴̜̺̪ͅl͍̘̜̩̘ ͓̗͞p̪͍͘r̡̜͔o̢̹̭̟j̘̳̳ȩc͏̙̥̲̗̻t̹̝͢s͍͇͔̪̟͓̫. Periodic refactoring to keep them aligned to evolving project needs is i̬͎m̸̯̺̺̙̠̖̜p̢͉̰͚̺̠̯o͖͈̙͇̗̹s̴s̲͖̩͡i͇͇̮̙ͅb̖͚̱͔̕l̷̤͖è̼͙̪͍̦̮. Components don't exist, interfaces don't exist, APIs don't exist, everything is tightly coupled together and changing a̢ḻ̤̰m̹̞̬̹͉̠o̤s̮̲̫͕t̨ ̛̞̠a̘̳ń͎y̟͕̝͔ţ̯h̲̼̞͓ìn̩͕̪͚̜g̰̪̥ ̭̀b̘̹̳͞r̨ea̳̺̤̬͔̻k̖͍͎̱̖̠s̨͕̫̬̲̭̱̱ ͖̪̞̖̫͍̖͢à̰l͚͕̹mo̮͉͖͔s̻̥t̘̠̭̰̗̺̻ ͕̳̗ͅe̳̘̗͔̹v̴͔̯̫e̗̝̖͉͔̩̩͜r̜͓y̛̜͇̳͉̭̩ͅţ̥̹̻h͓̱̦i͚̩̞̤̣ṋ͙̟̲̼̦g͏̝̤̪. I'm some sort of f͚̗͢ͅa͟ͅk̹̠̦̹é͚ ̘̞̩͉͍̗͘ḓe̼v͟e̗̬͓̻l͇̼ͅo̼̘̝̞̥̮pe̲̯̩̳r̼̠̟̦̪̳̙̀, everything I've believed is an i̶̘l̜͍̜̬͇̮͉͟l̛̻̺͉̳̘̼ṷ̥̫̳͖s͇i̲̰͡ͅon͘. Code becomes legacy code once the first visitor opens a page on the production server. It's time to e͙m͇̥͎͔͡b̤̯̲̘͜r̞̗̖ą̺͔̪͍̘c̴̞̠̰̭e͓̩̦͖ ̟̟͓̘a̞rc̩͠h̛̘̗͖͈̼i̹͙̟̙̝͟t̸e̞̠ct͜u̱̳̤̕r̠̞a͈̳̗͢l͔̟̞̼̙͈ ̖̘̬̖͍̫͢n̴͚͎͎̟͓͈̜i̸̻͙h̢̩̗̱̠i͏̳̠͇̣͈̯l͍̞̱ì̖̟͇͎̱s͎͔̮̤̯͝ͅm̩̼̰̦͝ and just open a random file and start b̀a̙͖̭̯͚͈s̠h̪̩i̝ng̖̝͙ my head into the keyboard until the unit tests pass. But unit tests d͔̜̰̀o̷̗̮n̸'͙̫͝t̳̙͚̣̺̣ ̣̬̹̣̥̟͇͝ex̺̰̮i̬s̭͚̤̥̲̘ṱ in real projects, either. Life is a l̖͕͟o̸͎̦̯̬̜̥̟n̨̝g̢̭̩͖̳ ̨̫̠̬l͜o̠̪o̗̞̺͎̤̺̤p̟̥̥̳͔͡ ̶o̤̲͍̰fͅ ͞t̯̹͚͈̰͢w̴͕̹̗͈̘͙ͅe̢̳̬͔a͏̻̬̩̮̖k͚̥͖̫̲̞͇̀i̼̼n̜͎̲͝g̷ ̘̳̟̼̝͍͡ͅḇ̙̟̙̼̥̩a̳̠͈͈d͍͔̗̫͉̼ ͉̬c͎̮̱͜ͅͅo̙̘̫̮̘͘d̳e̝͙̜̻͠ until it runs again, then ó̲̖̪̦̻ṇ͘e̦̤͕ ̦̥̼ͅḑ͎a̡̟̹̳y̰͓͖͕̲͜ y̶ơu̵͉ ͖̼̙̖͝di͚̺͔͉͈e͙͈. T͔̣̖͚̖̪h͟a͖̝͡n̖̥̦k͈̻̫͖̤̻̥ ̼͇̫y͈o̤͍͍̫̺u̻͙̲̠̩͜ ͏͔͉̼̲͔̜̯f̨̹̰̰ͅo̫͚̱r̛͖͙̻̻ͅ h̢̞̼̩è͎͎̠͔̠̤l̗͇͕̰͈̱̠p̛i͍͙̦̣̠̻͜n̗̣̯͇̠͈͚g̟̣̥̱͍̝͞ ̯̰͚̹̖̭m̵͚̯̺͉͍̹͈e͓ w͢el̖̤̝͇͉͙̟c̛ͅo̷̤̫̙̠̪̪͈m̘̦̱̬̦e͇̝͚̝̖͍̙ ͎͍͓̤̞C̸̖̤̩̟̟͖t̘͔̦͎͘h̸̗̠͍̗͎̝u͖̺͚͓̣l̳̮̯͓͙h̫͓̫͕u͚̞͇͙̫ ̸i͖̭̤͢n̫͚͇̖̱͜ ̹̭͉̮̜̥ͅm̵̠͖y͏͚̟̺͕̝͇ ̯̩̦̠͞m͎̖͓͙ͅi̺̜n̠̼d͈̳̞̬͎͢ ̖̺̰̫̫̲͠a̺̱̭̼͙̤n̻̠̟d̸͙̘̫̖̻̙ ̠̩͜h̤̗͖̩͇e҉̲͚͍̞a̞r̮̹t͇̣̫̞͜.̲ ̣̝̼̙̭̹͍P͓r̡͙̜̰͉̼͖a̡̖̞͉̪i̘͚͓͕ͅs̥̬͓̮̪e̷̙̭̠͎ ̨̖t̥͔̤͍̬̖͙h͈̤͙͞e̘̘̫̙̱͙ͅ ̖͔͚M̝͈̦̩̪̥i̴͈͉̙̖̥ͅg҉h͍̬̜̟͖t̪̻̥͓y̻̫̱̣̭̻ ̢̘̬C̺͕̻̯̱̲̖͞ṱ̮̭̪̰͉̖h̖̟̞u̸͕̰̩l̰̘̩̯̣̕hu̘̥̯͖̩͓͘.͕̝,̭͘ͅ ̳̤ ̵̯̜̗͕̩͖͙̻̰̕ ̛̺̼͇ͅ ҉̧̹̥̩͞ ͉͈͉͕̭̲̩̳ ͓͖͓̝͍̖͙̥ ̨͈́͡ ̵̴̲̩̬͞ ̷̻̜̯͇.̡̙̝ ̧̖̳̻̙.̡̲͖̹̼͓̬̦̯ ̟͈̯̀͘ ̸͔̜͟ ̡͚͖͓͉̠̬͡.̗̜̱̰͔ ̛̤̬̩̘̙̣̖̗̗͡ ̢͈̮͢.̳̰̗̝̪͜ͅ ͕̺̟͇̪̭̹̦̀ ̢͖̱̣̱.̫͖͍̣͍̀ ̛̭͓͔.͍̳̯̣̟͟ͅ ̨͓̰̤͓͔̦͎͜ ̳͈̗̠̖͘͞ ͕͈̞͎͍͞ ̻̫̮͉̳͕́͡ ̞͢ ̸͇̗ ҉̦͉̬̜͔̻̳.̺̳͖̳͈̘̤͖͍̬̮̪̗̘̲́̕͢͡.̶̯̘̳̲̖ ̤̳ ̲̘̝̰̻̼͢͞.̙̠̲̠̫͓̞̀͘͡ͅ ͕̙̱̖͢͡.̤͕̠͓̻͜ ͎͙ ̼͎̦̖͖̫̖̪̰ ̡̼̖ ̫̟ ̵̟̲͎͚͓̲̯͢ ̛͔̫̗̮͈̹̲̤͙́.̞̗̲̦͡ ̻̺̖͖.͕̞͉̘̪͎̪͙ ̨̜̜̲̻͜͝ ̡̨̪̰̼̥̲ ̟̱̭̳̘͟͜.҉̡̧̺̫̦͕̬̻ͅ ̠͈̣̩͔͍ ̳̺͜.̷̴̢̱̹̠̖̬͙̀͞,̨҉҉͏̲̘̝͍̱̭̬̯̯̙̗͓̱̜͉̫̻͎͙͟.͏̨̝͖̗̤͇̗̗̬̖̹̠̯̘͘͘,̷̢̬̩̹̥̼͔̬͎̟̘͍̺̖̜͔̤̫̱̰͢.҉̱͚̹̫̠̫̯́̀,̷̳̙̰̜̱͎͖̜̜̼̪̝͈͚̟̘͍ ̮͖͙̠̪̥̮̫̜̗̭̥̟̟̲͈͓́̕͟͠ͅ@̩̪̮̰#͢,̪͚̤͉͓̤͇̺͍̥̯̬͕̟̲̀͠͞.̸̡̨͍̣̦͈̺̪̤̙͉̯̜̠̪̱̫,҉̀҉͉̳͔͚͖͔͞ ̢͓̙̭̳͚͕̹̱̭̕,̧̡̞͎̗̘͕̞̥̞̻͕͔̩̜̩̘̻͡ͅ ̨̡͓̺̠̳̫͍̼͓̞̰̼͉͎̬͎̀́̕.̶̧̢̛̲̲̫̙̝̫͓͚͠,̵̢̮͕̺̩͝͡ ̷̷̷̶̰̠̰̮.͕̲̪̟͙̦̟̰̦͡͞,̢͉̮͇̙̤̮͍̹̮̳̝̖͉̼͚̩͙͘,̧̛̳͖̥̱̣̙̮͔̤̻̙̺̹̲͙̜̘̥́͠.̶̡͜͏̭̘͎̮͍̞͕͇̭͇͈͠ ̜̱͍̹̪̠̰͚̫͕͘,̴̡͈̮͓̦͉̮̮͎̞̞̕͜.̨̨̢̠̯͙̙̖̪̬̳̞̪̲̰̹̥̩́ͅ ̵̕͏͈̗̺͙̺͇̬̺,҉͏̶̹̹̹̜̝̲͉̖̯̺͕̦͙͕͟͡ͅ ̶̩͈̻̟̰̖̰̰̱̯̻͚̩̟́́̕͝ͅ.̡̲͔͖̻̠̹͓̫͉̀ͅ,̴̕͏̵̲͔̞̱̙̦̘̱͖̜̯ͅ ̶̲͍̱̦̙͍̹̺̹̳̘̱͎̮͍̩̝͘͡͝.̴̱͓̱̯͙͝,̵̢̺̻̼̪̞̱͚͎͜͢ ̧͉̱̫̳̙̖̪̹̯̼̬̻̙̫͚͈͙̜́͘͡,̤̹͍̯͉̻͘͠͡ͅ ̷҉͙̻̞̪̮̪̭͠,̢̝̘͉̺̟̝̟.̷̴̵̦̳̤͔͉̮̗͕̜̼̭̫͚̰̰͖̭͎͡ͅ,̸̧͕͉̞̰͖̪̝̖͕̜̜͕͘.̷̞͇̣̹̱̠͉͙̺̬͍̀͘͠,͏̵͡͏͎̬̣̮̮̙̰̤̤̖̦̗̰̗̘̳.̸̷̷̠͕̤̹̦͎̟͉̖̜͚͘,̳͈̤̙̼̹̤͓̥͎̹̞̤̼͟ͅ ̢̀҉҉̠̳̟̹͖̫͟,̵̷͏͏̤͎͇͉͍͉̝̮.̵̼̺͉͙̤͈̯͖̜̠̻̝̘̬͘ͅ,̶̕͜͝͏̺̖̮̟.̪͈̺̠͞ͅ.̡҉̨̡̣͖̟̯͖̯̯͍̣̖̗̜̣͖̟̞̲͍͉ ̸͖̟͚͓͙̣͖̣̳̥͕͈̦͎̘̤͝ͅ ̴̡̫̱͍̼́́,̸̵́҉̘͇̟̞͇͎͉ ͘͠҉̧̪͖͎̮̤̰̝̟̣̖̖̘͙̳͙̤̮͖̫,̵̥̼̟͎̕͜͟͠ ̴̧̡͈̩̫̬̹̙̠̟̼̕,͏̴̡̰̤͉̹͙̗.̻̦͉̜̖̰̣̞̣͟͡.҉͏̠̥͔͍̪͙̟̼̪̞̟̮͟͠ ̵̱̦͇̥͓̖̲̲͉̹͎͓̻̜̬̩͎̮̀.̲̺̼͞͞ ͟͞͏̴̮̣̖̹̺͍̱͉ͅ.̡҉͍̩̫̤ͅ
hacker haha,thanks!
logstalgia looks pretty. thanks !!
There there. You'll get through this.
&gt; Hrm. The N+1 query "rule" is very basic and shows the author doesn't have experience working at large scale. He doesn't have experience cause... the rule is basic?
There's an SQL solution given, and it pretty much translates directly to PHP: function weight($pos, $neg) { return (($pos + 1.9208) / ($pos + $neg) - 1.96 * sqrt(($pos * $neg) / ($pos + $neg) + 0.9604) / ($pos + $neg)) / (1 + 3.8416 / ($pos + $neg)); } printf("%f\n", weight(55,20)); printf("%f\n", weight(2000,200)); printf("%f\n", weight(5000,500)); 
but... where does it get those contants? why does it use 1.9208, how about the 0.9604 or 3.8416? what does they mean, why are they used?
There's a few issues here. When you talk about "tampering", there's already a situation which should not occur, and it's a critically broken library if it does not. The standard way to do this is with an HMAC, but there are pitfalls to implementation. I would recommend throwing that library in the trash. In addition to the issue discussed, I can see ECB mode being used, which is hideous. Also note that you called it an AES library, and it does not implement AES at all, but Rijndael 256. I recommend [the defuse library](https://github.com/defuse/php-encryption). 
okay thanks for the recommendation and reply
okay thanks for the input, will look into that now.
 select article.id, ifnull(sum(vote.value), 0) rating from article left join vote on article.id = vote.article_id group by article.id
thats what the article describe as the first error
I took a look (a quick google search) to see if I could if I could find a statistics library for PHP and the best I could fine was https://github.com/mcordingley/ProbabilityDistribution and I'm not sure if that reproduces the statistical functions properly that are given in the Ruby example. As u/EvanEdwards states, easiest solution is to translate the approximation given as SQL to PHP, which the user did.
Or this.
Looks like there is the following function (this *seems* to be the correct method to use, but I never took statistics): public function getPdf($x) { if ($x &gt;= $this-&gt;minimum) { return $this-&gt;alpha * pow($this-&gt;minimum, $this-&gt;alpha) / pow($x, $this-&gt;alpha + 1); } else { return 0.0; } } So possibly you can use that to compute the z value from the formula: class Stats { protected $minimum; protected $alpha; /** * __construct * * @param float $minimum The minimum value that the distribution can take on * @param float $alpha The shape parameter */ public function __construct($minimum = 1.0, $alpha = 1.0) { $this-&gt;minimum = $minimum; $this-&gt;alpha = $alpha; } public function getPdf($x) { if ($x &gt;= $this-&gt;minimum) { return $this-&gt;alpha * pow($this-&gt;minimum, $this-&gt;alpha) / pow($x, $this-&gt;alpha + 1); } else { return 0.0; } } } function ci_lower_bound($pos, $n, $confidence) { if ($n == 0) return 0; $PDF = new Stats(); $innerZ = (1 - (1 - $confidence)/2); $z = $PDF-&gt;getPdf($innerZ); $phat = (1 * $pos/$n); return ($phat + $z * $z / (2 * $n) - $z * sqrt(($phat * (1 - $phat) + $z * $z /(4 * $n)/$n)))/(1 + $z * $z / $n); }
it will take me a while to understand this. Question. whats confidence and whats alpha?
Encryption is kind of a dumb process, despite the meticulous engineering that goes into it. If you pass an arbitrary string and key to a decryption function, the algorithm will happily assume that your string is a valid ciphertext and give you a valid plaintext for the given "ciphertext". It sounds like the behavior you're expecting is a quality exhibited by **authenticated encryption**. The other redditors who posted here have hit the nail on the head. [defuse/php-encryption](https://github.com/defuse/php-encryption) will give you authenticated encryption, and it will throw an exception if anything is amiss. If you don't catch the exception, it will display a generic error message and kill script termination with no stack trace (to prevent your secret key from leaking). If you're going to implement encryption today, use that library.
You should at least compare on the same OS/kernel version and ideally run it several times to get an average. The script used is mostly calling PHP functions (that are probably written in C) so not a good test. 
Everything in your comment is correct. :)
eli5? i have read it many times and i don't get it :'( where does the z comes from?
You're running benchmarks on systems with different distributions, kernel versions, and probably different PHP extensions loaded. Here's what I got running the same benchmark on my laptop: PHP 5.6.11: ✯ tmp php -v PHP 5.6.11 (cli) (built: Jul 15 2015 10:18:12) Copyright (c) 1997-2015 The PHP Group Zend Engine v2.6.0, Copyright (c) 1998-2015 Zend Technologies with the ionCube PHP Loader v4.7.5, Copyright (c) 2002-2014, by ionCube Ltd., and with Xdebug v2.3.3, Copyright (c) 2002-2015, by Derick Rethans ✯ tmp php ./benchmark.php PHP Notice: Undefined index: SERVER_SOFTWARE in /Users/lolwat/tmp/benchmark.php on line 71 PHP Stack trace: PHP 1. {main}() /Users/lolwat/tmp/benchmark.php:0 Notice: Undefined index: SERVER_SOFTWARE in /Users/lolwat/tmp/benchmark.php on line 71 Call Stack: 0.0007 250544 1. {main}() /Users/lolwat/tmp/benchmark.php:0 &lt;pre&gt;-------------------------------------- | PHP BENCHMARK SCRIPT | -------------------------------------- Start : 2015-07-26 23:11:33 Server : PHP version : 5.6.11 Platform : Darwin lolwat.local 14.4.0 Darwin Kernel Version 14.4.0: Thu May 28 11:35:04 PDT 2015; root:xnu-2782.30.5~1/RELEASE_X86_64 x86_64 -------------------------------------- test_math : 4.657 sec. test_stringmanipulation : 4.530 sec. test_loops : 3.517 sec. test_ifelse : 2.669 sec. -------------------------------------- Total time: : 15.373 sec.&lt;/pre&gt; And PHP 7.0.0-beta.2: ✯ tmp php -v PHP 7.0.0beta2 (cli) (built: Jul 24 2015 10:34:53) Copyright (c) 1997-2015 The PHP Group Zend Engine v3.0.0-dev, Copyright (c) 1998-2015 Zend Technologies ✯ tmp php ./benchmark.php PHP Notice: Undefined index: SERVER_SOFTWARE in /Users/lolwat/tmp/benchmark.php on line 71 Notice: Undefined index: SERVER_SOFTWARE in /Users/lolwat/tmp/benchmark.php on line 71 &lt;pre&gt;-------------------------------------- | PHP BENCHMARK SCRIPT | -------------------------------------- Start : 2015-07-27 04:12:08 Server : PHP version : 7.0.0beta2 Platform : Darwin lolwat.local 14.4.0 Darwin Kernel Version 14.4.0: Thu May 28 11:35:04 PDT 2015; root:xnu-2782.30.5~1/RELEASE_X86_64 x86_64 -------------------------------------- test_math : 0.288 sec. test_stringmanipulation : 0.648 sec. test_loops : 0.325 sec. test_ifelse : 0.368 sec. -------------------------------------- Total time: : 1.629 sec.&lt;/pre&gt; My results show PHP 7.0 wildly ahead of 5.6 but they're skewed because my 5.6 and 7.0 versions are loading different extensions. I'm sure the 5.6 times will drop a bit if I lose a few extensions to match PHP 7's loadout, especially xdebug. See how the benchmark looks on your CentOS system alone. REMI's repo has 7.0 RPMs now, which should make installation a little easier, though not 100% accurate and foolproof. If you want super-de-duper accuracy compile both versions by source on the same system using the same configure command then use that built binary to run the benchmark. Also, your phpinfo() dumps look like links to your internal development resources. Paste `php -i`'s output into GitHub gists for easier viewing. 
I unloaded xdebug and the ionCube loader in 5.6.11 to level the playing field a bit. 7.0.0 is still better than twice as fast: ✯ tmp php -v PHP 5.6.11 (cli) (built: Jul 15 2015 10:18:12) Copyright (c) 1997-2015 The PHP Group Zend Engine v2.6.0, Copyright (c) 1998-2015 Zend Technologies ✯ tmp php ./benchmark.php PHP Notice: Undefined index: SERVER_SOFTWARE in /Users/lolwat/tmp/benchmark.php on line 71 Notice: Undefined index: SERVER_SOFTWARE in /Users/lolwat/tmp/benchmark.php on line 71 &lt;pre&gt;-------------------------------------- | PHP BENCHMARK SCRIPT | -------------------------------------- Start : 2015-07-26 23:28:46 Server : PHP version : 5.6.11 Platform : Darwin lolwat.local 14.4.0 Darwin Kernel Version 14.4.0: Thu May 28 11:35:04 PDT 2015; root:xnu-2782.30.5~1/RELEASE_X86_64 x86_64 -------------------------------------- test_math : 0.935 sec. test_stringmanipulation : 1.257 sec. test_loops : 0.758 sec. test_ifelse : 0.625 sec. -------------------------------------- Total time: : 3.575 sec.&lt;/pre&gt; 
You're not wrong, but it's better to say "use a library written by a security expert". Preferably one that's peer-reviewed. They actually have enough experience to do it correctly. OP, please don't roll your own crypto wrapper. There are plenty out there already, and they've been vetted and battle-hardened. They'll address your current problems, and several others you don't even know exist. This isn't an attack on your skills, just a statement that we can't all know everything, and there's a lot to cover in security and it has to be implemented perfectly or it's useless. (I've been through multiple PCI audits, so I know the struggle)
The title is not self-explanatory. Do you want to be able to parse a file to see if there are CSS selectors in it? If so, do you just want a true|false boolean return?
If you wanna have the rate limiting distributed (e.g. multiple workers/web nodes/lbs) I'd recommend looking at http://redis.io/commands/incr#pattern-rate-limiter
&gt; Do you want to be able to parse a file to see if there are CSS selectors in it? Yes. &gt; If so, do you just want a true|false boolean return? No, I'd like them dumped to a css file. If such a thing doesn't exist, I'd be more than willing to create.
Hello Soucy, author here. First of all thanks for taking the time to read the article and write a comment. The N+1 Rule was not meant to be exhaustive (there are even books about it), I just wanted people, especially beginners to start to embrace the problem and be concerned about it. For what regards Joins, I know they might slow things down, but in many simple cases they are way faster than N+1 queries. I just wrote "when you can" which I admit is quite ambiguous. I'll update my post trying to be more specific both about the non-exhaustivity of the post and the JOIN issue. Thanks also for mentioning about the database connection, is something worth mention as well.
Hi, it's not a big deal, but I think at this stage the "premature optimization" meme is so prevalent, it's used as an excuse for sloppy coding, so it warrants a mention. The article warns against quoting Knuth partially (like you did) and having an attitude where the profiler is the only source of truth with regards to optimization. It speaks that doing some work in advance is warranted, as well. The story of SQLite 3.1.8 is my poster child for how the profiler is not telling the full story with regards to which optimization is worth doing: http://permalink.gmane.org/gmane.comp.db.sqlite.general/90549 Relevant quotes: &gt; The latest SQLite 3.8.7 alpha version ... is 50% faster than the 3.7.17 release from 16 months ago... The 50% faster number above is not about better query plans. This is 50% faster at the low-level grunt work of moving bits on and off disk and search b-trees. We have achieved this by incorporating hundreds of micro-optimizations. Each micro-optimization might improve the performance by as little as 0.05%. If we get one that improves performance by 0.25%, that is considered a huge win. The lesson here is that if we have this popular attitude of ignoring small gains, we can easily miss the big gains by having inefficiencies scattered throughout our code that a profile wouldn't show. Of course, for PHP a better advice would be "if it's slow, outsource the slow parts to a faster language". Like C++, Java and so on. But that *also* requires planning and forethought, as most PHP codebases have presentation and domain logic so tightly intertwined, you can't move parts of it outside PHP in any sane way.
Sounds nice! Small feedback: you can loose the `.99`, it's a bit ridiculous. I'm fine to pay `$3` instead of `$2.99`.
I have to disagree with your point on small gains - I think it misses the point. The issue is not the optimisations, its that they're premature. Code structure and function is orders of magnitude more important than speed in the vast majority of cases, and considering that code often begins and ends its life as two different beasts, I think the idea that one should write clean code now and worry about small gains later almost always holds true. I also kind-of think your point around exporting mission-critical functions to a C-launage (for example) is also a little misleading. There's this conception amongst PHP developers that all one needs to do to have an ultra fast app is to write your mission-stream in C and have each feature branch kept in PHP. Although that seems to be true **sometimes**, more often than not you'd probably be better keeping in PHP. My 2 cents...
Sir, I'd rather it be $2.99 and save a dollar. I can think of many $1.99 items I'd rather buy with that dollar.
The core of the issue is that every optimization can be called "premature", except the one that's done too late. So the result of calling optimization "premature" is to shut down any debate about performance and code quality. Also I was referring to standalone services about the C++ and Java comment, not PHP extensions in C. 
Telling people "don't optimize" is a very crappy way to tell them "use SOLID". How about we say what we mean.
Is there a free trial? Most hosted services of this kind offer a 14-day trial, no payment card required. 
So is this another Laravel thing ( because of the logo in the bottom ) ? Or was the logo just placed there to gain credability ?
It comes from the mantra you support. You may have a nuanced understanding of it, but most people don't. They see "don't optimize prematurely", then proceed to treat any form of optimization as "premature". That's the drawback of mantras. They don't come attached with a book defining their meaning, as we can witness from people regularly butchering Donald Knuth's quote &amp; intent.
You're barely even reading my replies, I said people say put aside micro-optimisations in favour of good code.
Played around with it 6 months ago, pretty neat http://codeseekah.com/2015/02/06/rwasa-hhvm-wordpress/
Most of the time, the value of z is an approximation and pulled from a reference table/book. The value of 95% confidence for z isn't actually [1.96](https://en.wikipedia.org/wiki/1.96) for example but more like 1.95996398... instead, just like how pi is usually used as 3.14 when it's more like 3.14159265358979... The formulas to calculate z accurately require calculus and derivatives so I won't try to write them here. What z represents is more important than what the actual number is which is why many places glaze over where they got the number for z or how it was calculated. So what z represents is the standard deviation to account for a certain percentage of results. Most of the time, a standard normal distribution is used, and it's commonly referred to as a bell curve. What the curve represents is the number of items counted at each point along a line; the more times something is counted, the higher the point on the chart. Most of the time these curves aren't pretty, but the standard normal distribution curve is perfectly symmetrical and perfectly curved and represents a perfect ideal result. The standard deviation is a metric used to calculate how different the results are. If most of the results are very close to the same (eg. throwing darts at a board), then the standard deviation is small whereas if the results are very far apart (eg. throwing darts everywhere in a room including away from the board), then the standard deviation is large. What z is used for is determining how many of these deviations is required to cover a desired percentage of the results. If you measure everybody's height in the world, you will find an average height that most people are. People shorter are a number of standard deviations away from this average as well as people who are taller are deviations away as well in the opposing direction. A human can vary greatly in height, but most people are about the same height and you can't measure every single person in the world either so you estimate. If you wanted to build a safe car seat, then you need to determine the sizes of the people to cover. Do you need to cover the likes of someone [Verne Troyer's](https://en.wikipedia.org/wiki/Verne_Troyer) height as well as [Yao Ming](https://en.wikipedia.org/wiki/Yao_Ming) or do you want to account for 95% of people instead? To cover 95% of the population, you'd need to account for 1.96 standard deviations in height which is the value of z in this situation. Differing percentages require different values for z and what percentage you want is typically done by looking up the value from a pre-computed table. I found a decent [video](https://www.youtube.com/watch?v=grodoLzThy4) that explains z more visually. Specifically for the Wilson calculations you were asking about, the various numbers in question are based on the value of z. If you look at the formula, 3.8416 = z^2 and 1.9208 = z^2 /2 when z = 1.96 representing 95% confidence. What the Wilson score tells you is what the estimated lowest realistic fraction of positive votes to negative votes is with a confidence of 95% based on the provided data; obviously, the more data you have, the more confident you can be about your estimate. In an example, if you have 10,000 votes that are 60% positive for one item and just 10 votes for another also at 60% you'll naturally be more confident that the percentage for the first is more accurate than the percentage for the second. The non-trivial formula to calculate the lower bound of the Wilson score tells you, "I'm 95% certain the score is higher than x" just like your gut would tell you the second item's probably over 20%, but you aren't as completely sure like you are with the first.
&gt; $x.xx p/m Ehm .. that slash means "per", so why the "p" ?
yeah the people in here were awesome and polite, not a common trait amongst most subreddits I've been too. It's greatly appreciated.
no offense taken, these are things I needed to hear.
Generally "free for open source" in hosted services means that the system will only read public repositories. So, to try it on a real private repo, it must access it with SSH or password authentication. One could put up a dummy project on GitHub, but I don't think that's the same. You want to see how a service performs with real-world code. 
Why is it so hard to send mail with PHP and gmail? I'm trying to write a simple contact form and I've tried mail(), PHPMailer, and a handful of other solutions that I don't remember the name of...and I just can't get it to work. Should I try something else instead of gmail?
Shouldn't be hard as Gmail has an SMTP endpoint. Here's something from [stackoverflow](http://stackoverflow.com/a/4691183) using Swiftmailer $transporter = Swift_SmtpTransport::newInstance('smtp.gmail.com', 465, 'ssl') -&gt;setUsername($this-&gt;username) -&gt;setPassword($this-&gt;password); $this-&gt;mailer = Swift_Mailer::newInstance($transporter);
StyleCI is free for open source repos. That's a trial in itself.
Nah, we're happy with our pricing. Many, many people follow this and the saving of a cent is really nice.
Oh thanks !
Why do I get downvoted for asking a simple question ?
Not enough, in my opinion - see my reply to someone else above. I may be in a minority of one though! (I have this problem with Scrutinizer - I have a F/OSS project on it and I think it's excellent, but I'd like to try a closed-source app on it to see what my initial code score is. Can't do that unless I fork out cash, and on this project I can't currently justify it). 
Ah fair enough - good stuff! To make this clearer, a subtle "clients" subhead above this section might help. (I think my initial impression was that the branding/design needed some polish, and combined with the downtime reported on your status page and the uncertainty around the logos, it was tempting to think the service is not of good quality either. Now you've responded to various comments here, I am tempted to think the service is fine and worth paying for, but that the presentation could do with tightening up a tiny bit. Long story short: appearances matter. HTH). 