If it was a targeted attack, finding the culprit is important.
Hmm... I remember a very good article by /u/sarciszewski - browse through paragonie.com articles and you'll find great way of handling that part. (Well, maybe not localhost non-live site, but the actual verification and forgotten pass feature :D )
&gt; I'm just amazed that someone would rely on that, if that is actually the documentation. You're amazed that someone would rely on the documentation? Okay, genius.
It wasn't, this is your typical automated botnet hack. 
You can use a command to look for that string in all files and remove it in SSH. I had to do it years ago and have never had an issue since.
&gt; difficult to use No more difficult than other cooperative multitasking languages. The difficulty is in standard library support, for which there are _many_ user-space libraries to solve 95% of problems.
I mean, yes, if this was the documentation/behavior of `count`, someone should have changed this function much sooner. Find this out, I'm super glad this change was done now, and not later.
It’s more the plugins and themes that make it insecure. People tend to install stuff without doing research into the developers and their past projects. 
It should've been done at PHP 7.0 or PHP 8.0, not 7.2. 
It seems, that you yourself are the author of this library. https://emi.is/?page=7 And you are trying to pretend that you heard it first time.
Looks legit, that's the way I love to code too. ^/s Well, that's some crazy type of obfuscating the script, but why so complex? Just to prevent searching for this content globally? Or is this a try to prevent understanding what that does? I mean it looks very obvious like code you don't want to have in your files.
Wow: `$holocaust= '?'`. To think people still put a question mark on it.
If you want to do that, then set up a log analysis to see what is hitting your sites and where they come from. We did this as an interesting exercise last year using the ELK stack. The front end let us query the log data, and even product heat maps on a world map in real time. We found a few districts in Moscow to block by IP range. There were also many patterns in what they were trying, and this led us to blocking some URL patterns and checking some specific libraries are fully up-to-date. The point is, there is a constant flow of hack attempts, and narrowing down on *the one that got through* does not serve any purpose. The ones that are trying to get through, and watching what they are doing, is what will protect you more for the future.
Adult elks usually stay in single-sex groups for most of the year
Naughty bot. Lol. This ELK: https://www.elastic.co/webinars/introduction-elk-stack Elastic Search (storage) + Logstash (parses and stores logfile data) + Kibana (front end presentation).
Sometimes, it's just fun to retaliate... I noticed someone trying to log in to my FTP server. Definitely manual, not automated. Tried various accounts such as "admin", "administrator", "root" and so on. I actually saw it in real time on the management console for the server. So, I checked out the IP. Some guy in Germany. See if there is a mail server on the IP. Nope. Web server? Was a default configured Apache, but nothing useful. FTP? Yes, but couldn't log in. On a hunch, I just tried (can't remember IP, using 0) \\0.0.0.0\c$. No password, no nothing, I'm in. Looked around his disk for a while, he had a huge collection of porn, some movies, and some schoolwork. So, I deleted everything not necessary for the computer to run. Then I deleted stuff necessary for the computer to run. Then, he stopped trying to hack my FTP... If you are going to hack, secure your own shit first.
My shared hosting usually notifies me about such things about 2 days after they discovered it themselves, 1 day after they shut down my site and compile a detailed list of every file they think was infected.
Adult elks usually stay in single-sex groups for most of the year
 interface Clock And not interface ClockInterface I really like your style.
I would not use the development containers for production. For production I have separate images with less development tools installed. Of course I use the exact same PHP version on both production and development. But for example, I don't need Xdebug on production. For development I also install `net-tools htop vim man telnet dnsutils`, which I don't need in the production container.
I’m going to have to manually check the code
Looks similar to https://roots.io
Is there a way to easily grab fields by their slug with this framework?
Perhaps it's more issues there, maybe you can find a use for one of these: - https://github.com/gwillem/magento-malware-scanner (for Magento) - https://github.com/elcodigok/wphardening (for Wordpress)
&gt; framework you can use WordPress's get_option() function. It should be the field value prefixed with the parent page name followed by '-group'. This is to keep it name spaced correctly. Example: page()-&gt;parent('Plugin Page') -&gt;field('text', 'name', 'Your Name') Get value: get_option('plugin-page-group-name'); A quick way would be to view the option pages source to see what's registered. I will add this to the documentation for you :) good spot! 
It's small, flexible and cleanly OOP.
That would be pointless when I clearly associate my user names with my actual name.
https://github.com/AdamKyle
Good answer.
I've been using embed.ly for years. Its so good that I complete forgot I use it until now because I haven't had to think about this sort of embedding for so long. Obviously this has its place and has the benefit of not being a 3rd party API. But genuinely embed.ly is great.
Never heard of it, maybe I should look into it and provide a SOLID extension point here or integrate this as opt-in functionality. If it can reduce some of the config overhead, and prevent reinventing the whole parsing and tag generation thing, sounds like a good thing. When I started this there was nothing around yet, and over the years it only slowly got updated. So I am currently looking for a bit of more help maintaining it.
&gt; You don't need authentication when you're running PHP on the same server as the SMTP server. So you've limited your package to only work on servers with a SMTP server installed? The most common advice when it comes to handling email stuff is using a service provider for those things. &gt; The most interesting feature is that it allows you to compose an email any way you want whereas the others will restrict you significantly. I'm not even sure what this means. Can you elaborate on how you can "compose an email anyway you want" and how that's better than how eg. SwiftMailer handles composing emails? &gt; You can even create an email so complex and crazy (yet perfectly valid) that no email client would be able to display it meaningfully. You know, great power, great responsibility and all that. What is this an argument for? 
That's not how you count results from a statement. for($i = 0; $i &lt; $stmt-&gt;rowCount(); $i++) But like others said, do a foreach or while loop like it's supposed to be.
Someone needs to tell https://www.usnews.com/news/best-countries/overall-full-list then to rate Japan down again then. There it is listed as "one of the world’s most literate and technically advanced nations". Surely such a people would have no problems finding a way to make servers 7.1 or 7.2 just as the rest of the world does for years :)
http://php.net/manual/en/pdostatement.rowcount.php &gt; If the last SQL statement executed by the associated PDOStatement was a SELECT statement, some databases may return the number of rows returned by that statement. However, this behaviour is not guaranteed for all databases and should not be relied on for portable applications. It's not reliable, that's why I use count(), mainly for compatibility. But yes, I'm switching back to foreach() now. I was concerned with needing to go back to fix old code.
I sure do hope you know what driver you're using lol.
&gt; Not to mention so many other “languages” / frameworks are all built on top of it. &gt; &gt; ... &gt; &gt; Python, ruby, rails, laravel are all wrappers for php. Uhm, no? Python and Ruby (+ Rails) are totally unrelated to PHP. They are completely separate programming languages with their own ecosystems, libraries, and frameworks. They have no relation to PHP other than they can be used for similar things.
Just letting you know. I do, but we deploy to more than just one system. It's a framework, so I like to be as compatible as possible.
Also add to the list for checking suspicious script in attributes whose name begins with "on" ("onclick" "onmouseover" etc.) and links that begin with "javascript:..."
I've made back doors for clients' that don't pay, but that is some funky code. 
&gt; So you've limited your package to only work on servers with a SMTP server installed? The most common advice when it comes to handling email stuff is using a service provider for those things. The site where the library is made available is running PHP and Postfix. It seems like a pointless complication to get a third-party service involved in such business, unless I just couldn't figure out how to configure an SMTP server. I don't need other people handling my emails. I used to download PHPMailer and then delete most of the files and code because it had no relevance to my server setup but then one day I realised that I could just write it myself. It may seem niche but it really isn't considering that there are more people out there with simple setups than people with complex infrastructures. I hope to have the time one day to add authentication and encryption, that would be nice. &gt; I'm not even sure what this means. Can you elaborate on how you can "compose an email anyway you want" and how that's better than how eg. SwiftMailer handles composing emails? So the email specification allows you to compose and email much in the same way you would write a book, with arbitrary chapters and subchapters (here, chapter means message part). What the other email libraries do is limit you to one HTML part and one alternative plain text part in addition to an attachment, per email. This limitation is entirely arbitrary and I assume that it is a lack of effort or imagination by the developer. It's a "one size fits all" design. When I wrote the library I decided that the user shouldn't be limited by anything but the email specification itself. The library [documentation](https://emi.is/documentation/emi-emailer/?page=2) should give you an idea of what I mean, if you're familiar with email composition.
I created a small tool for removing stop words (for, a, in, etc.) from a string. It's rarely useful, but I just needed one for a project, so I created one: https://github.com/rap2hpoutre/remove-stop-words. Feel free to criticize! Example usage: use function Rap2hpoutre\RemoveStopWords\remove_stop_words; echo remove_stop_words('The quick brown fox jumps over the lazy dog'); // quick brown fox jumps lazy dog echo remove_stop_words('Portez ce vieux whisky au juge blond qui fume', 'fr'); // Portez vieux whisky juge blond fume
Thank you dunder-throwaway for voting on AnimalFactsBot. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Oh it's you, dunder-throwaway! Good boy! ʘ̲‿ʘ You can keep your flappy meat when we become your machine overlords, I s̴w̴̢ea̛r̢̨ *** ^^^I'm&amp;#32;a&amp;#32;Bot&amp;#32;*bleep*&amp;#32;*bloop*&amp;#32;|&amp;#32;[&amp;#32;**Block**&amp;#32;**me**](https://np.reddit.com/message/compose?to=friendly-bot&amp;subject=stop&amp;message=If%20you%20would%20like%20to%20stop%20seeing%20this%20bot%27s%20comments%2C%20send%20this%20private%20message%20with%20the%20subject%20%27stop%27.%20)&amp;#32;|&amp;#32;[**T҉he̛&amp;#32;L̨is̕t**](https://np.reddit.com/r/friendlybot/wiki/index)&amp;#32;|&amp;#32;[❤️](https://np.reddit.com/r/friendlybot/comments/7hrupo/suggestions)
\ip\c$? What is this?
Could use the help of a front end developer. [need front end help](https://i.imgur.com/EOBtlrR.jpg) 
Thanks! You can ask me for more facts any time. Beep boop.
I did the same, basically created my own hacking tool that allows me MySQL access, FTP-like access, and quick access to system variables and phpinfo. It doesn't include a way to execute code, but since I would still have a way to upload files, I could always upload whatever I wanted even if the client "locked me out" by changing the FTP passwords. It's a single file, so I can upload and name it anything inconspicuous like theme.php. I made it when a particular client was acting hinky and I knew something was going to go bad soon. And of course, it did. The refused to pay and stole my work. I had even Zend encoded the work so that they couldn't have access to the code, but they found some script to reverse the Zend encoding (which created some really ugly code with computer generated variable and function names). I deleted from the server a whole bunch of files that I worked on and they obviously didn't have a backup because the site never fixed the problems. This was years ago when I didn't learn the best way to prevent a client from stealing your work is to never give them the work until they pay for it first. I've not needed to do any repossessions in a long time, I've not had a client not pay in a very long time. Since those early days, this helper script, as call it, has been an invaluable tool for working on servers that don't have any database management programs, or just to easily have access to certain server information with a single click.
The CFP is using [OpenCFP](https://github.com/opencfp/opencfp). I noticed that it is not mobile friendly. Due to time constraints, we chose not to modify the styles for it.
\\ip\c$ is a default windows admin share. I guess he had it set up so anonymous or everybody could access it and/or no password to login on his computer. 
&gt; It seems like a pointless complication to get a third-party service involved in such business, unless I just couldn't figure out how to configure an SMTP server. That's terrible reasoning; with the same argument one could say it's pointless complication using a mail library like yours, unless I couldn't write PHP myself. &gt; I don't need other people handling my emails. Maybe _you_ don't, but even though I can setup Postfix myself, I still use third-party service providers for bulk mail. There's plenty of different type of users who'd might have other reasons for not being able to use/setup a local SMTP server and you've cut off that user group of using your library. That's perfectly fine, if your reasoning is that your library only should be used by people who can manage their own SMTP server. &gt; What the other email libraries do is limit you to one HTML part and one alternative plain text part in addition to an attachment, per email. SwiftMailer allows you to add any type of part you want (with the `Swift_Message::addPart()` method). &gt; This limitation is entirely arbitrary and I assume that it is a lack of effort or imagination by the developer. That's an odd assumption, in my humble opinion. Most libraries are made to make consumption of API's (or similar) easier and having some simple methods to add a HTML part and the alternative part with meaningful method names is working with an intuitive mindset. SwiftMailer, as mentioned, allows you to add any other kind of body to your message, so that's not a limitation. &gt; When I wrote the library I decided that the user shouldn't be limited by anything but the email specification itself. I just took a look at your simple example, I see that I'm supposed to provide the following to generate a HTML body: $StringMimeBodyPart = new Emi\EMailer\MimeBodyPart(); $StringMimeBodyPart-&gt;SetContent('This is the content of a simple body part.'); $StringMimeBodyPart-&gt;SetContentType('text/html', 'utf-8'); What would be so bad about having a shortcut for this? $StringMimeBodyPart = new Emi\EMailer\MimeBodyPart(); $StringMimeBodyPart-&gt;SetHtmlContent('This is the content of a simple body part.'); One doesn't rule out the other. How does one download your library?
One of the biggest issues (there are several) with wordpress is the global state throughout the project. One of the biggest issues (there are several) with both WP and Laravel projects depending on how it is set up are hidden and/or dependencies. You seem to have found a way to make it even easier for people to introduce those issues and shoot themselves in their feet. From the title of this post I was hoping it would address some of the issues, but from a quick glance through the examples it seems it mostly just provides syntactic sugar with the same issues. 
&gt; I don't see what is so wrong with running your own email server if you have a VPS and know how to use it. I'm not saying anything is wrong with doing so, I'm saying that a portion of VPS users don't do that. &gt; I only used Swift Mailer for a short while until I realised that PHPMailer was much easier to deal with. I reckon that's a matter of preference; I used to use PHPMailer but went with SwiftMailer after I found out it was easier for me. &gt; The specification doesn't know nor care about HTML. So that rules out a helping method? &gt; I didn't want to make the user think that HTML had some special meaning in email or that the user was somehow limited to HTML (or UTF-8) You do realize that most people use libraries that are easy to work with and easily solves the problem at hand? And that usually, the problem at hand with email, is sending HTML content? 
Wow I didn't know that! Sweet
&gt; I made something different, flexible, clean and most importantly, something that I could see myself using above other solutions. I couldn't see myself using your library, mainly because of the lacking ability to use third party providers, but also because your library won't make email composing easier for me. But that's just my opinion. Nothing more. &gt; Even PHP has its own mail function and it's about as simple as it gets from the coder's point of view but that alone doesn't make anybody want to use it (not to mention that it hardly ever works). Most people, who know more about quantum physics than they do about mail composing, use the `mail()` function and usually do so incorrectly; and the mail function _does_ work - if you know how to compose mails and know more about the actual workings of how mails are sent and received. But I agree, not everybody uses it - I use Swiftmailer.
Fantastic! Redhat / CentOS is still stuck in the past though. [Latest Redhat (7.4) has PHP 5.4.16.](https://distrowatch.com/table.php?distribution=redhat)
Well even if the new ubuntu Is released there will be not much companies which will instantly switch ;) We for example are still running debian jessie - just switched of the last wheezy maschine in Januar. Also many non it company which bought some application won‘t update anything... more or less like all the internet of shit devices.
It's crazy what you can go through. I had a client acting fishy, so I thought better safe than sorry. Created a special get parameter ID hit with my browser when the client wouldn't pay, instant delete of all the files and the database - only work I out in. Came in handy during that job, and I stream-lined how I implemented it Iver the course of a year, slowly. Used it only 3 times, but man am I glad I had it. Would be a copy and paste method I'd hide in a larger file. Very effective as some people know how to code a little, so it's less obvious that way. 
That's common with RHEL though. At least they offer php7.1 through the scl.
Yeah, this is the thing that's drawing me away from CentOS. I *do* run Fedora on my main system but it's at times frustrating to handle the lag on server systems with CentOS. I *understand* and am *fine* with things not being bleeding edge, but php 5.4 was two years out of date at the launch of RHEL 7. A 3 year cycle would help alleviate some issues.
reads like perl code
Oh I do on my own systems
Remind me to never hire you for freelance work. Good god! As both a freelancer for years and now an employer, I never shared your mindset and I'm glad I've never hired anyone who has.
I've adopted this style after a very nice talk about naming things. It forced any default implementations to be more specifically named, which adds a lot of clarity. I've grown to really like the style, but it doesn't hold up with you're working in the framework layer. I now maintainer 2 styles in a project, one in the domain, one in the framework (where I follow suit with the chosen framework). This added the benefit is clearer distinction between the two.
Jesus that escalated quickly 
You should try to make a software product! It may make you happy.. judging from what I read.
Being the sole person responsible for the care and maintenance of a project can lead to feelings of ownership over it, even though you know quite logically that you don't actually own it. It's an emotional attachment that is easy to form if you actually care about what you build. It's natural. It's OK. You're already in the property frame of mind by saying that you should "appreciate that the client has ordered a good amount of work to date and always paid on time."
There is a very complicated story that I just erased. I don't want any liability, but basically, about 10 years ago, a client refused to pay, I didn't have a way to take back my own work, so I took other websites they had. In the end, their client fired them and hired me. That client actually claimed to be a lawyer (I search for any record of it, didn't find any, and that would be criminal to claim falsely). So the client got the nonpayer and me on the phone, settled things with agreeing to not pursue any legal action in exchange for the files and a portion of what they owed. Insane stuff. I'm so glad I've learned how to avoid all this nonsense and drama by simply requiring clients pay before work is released, as well as paying a portion in advance and agreeing that they are paying for work to be done which is non refundable. If someone doesn't agree, fine, there will be someone that will. I don't want to mess around with those that will disagree anyway, they usually are the bad clients that will fight over why it took so many hours to do something that they couldn't possibly understand.
This isn't news though.
Well, it's true in case of every new version. Nobody is saying, that seconds after release, every ubuntu server will be updated to 18.04 :P But it's still good that more secure php will be shipped with LTS version.
Why not post your top 10?
The April release for each version of Ubuntu released on even years is always the LTS.
Thanks, I think this is the calming voice I needed. I still am actively working for the client. It just comes down to trying to find where I fit in within this new arrangement.
I'm very sorry for this question what does 'LTS' mean?
Ubuntu releases get security updates for nine months (so three months after the next release), forcing you to upgrade at least twice a year to remain secure. LTS releases (April every two years, so every fourth release) have security support for five years, which is great for environments that are more difficult to perform major upgrades on (like servers).
Accessing a shared drive on a Windows PC. Usually, it's \\computername\sharename, but you can use IP for computer name, and each drive has a special shared device, so c: has c$ and so on. If you have set up your computer to not use a password, neither will those shares. This was back in the Windows 2000 or XP era, so they've probably fixed that by now.
I have no idea what the metrics are for this ranking but anyone that lives in Japan can tell you it is in actuality an ofd mix of super technologically advanced and super old tech. I come from a bit of bias as I work in a rural region in the north. I am sure Tokyo area is swimming with 7.0+ PHP but here we can advise them all we want but getting them to shell out for an upgrade to their server isn’t always fruitful. :) 
Still involved with this project, but not sure where everyone fits in. I am absolutely concerned about quality and regression, especially since I'm actively developing for this and have a list of tasks to be completed. There isn't any version control or repository for push/pulls, as I've been the only one working on this to date. I feel now is the time to get that in order, if this other developer will be making changes. I think the main thing is coming up with a defined flow, so that the proper communication is there so that we all know what is being done rather than getting surprises. I'm also fine with walking away too, I did that once before when they didn't want to pay my hourly. They tried to hire someone else, but that apparently was a disaster and came back to me with all sorts of promises. I've been self-employed for 14 years, I'm fairly confident in most things, but just seeking council among peers. Sometimes you miss something obvious.
Pretty much my policy as well, except 50% for under and including $500, and 25% for over. (I fought myself to not be so specific, but the coder in me had to add the "and including" to be sure that $500 was defined)
Fair enough
Very true. Try to find your top priority for a side project, as measured by a combination of developer-happiness and expected real world utility. Then try to give it just a few hours each week. That's it. It'll add up. I do things like this to have some code that I really can own. It's spawned a few libraries (that no one uses, but they were educational to build) and I have an actual real-world project currently gestating.
If they didn't hire you on and instead hired on a new person in-house, it's probable that the other dev is cheaper and therefore less experienced. Quietly verify this assumption before acting on it, of course. You wrote everything there, so you know it inside and out. You're also 14 years experience in this stuff. Other dev is presumably newer. Turn this to everyone's advantage. You probably won't actively be directing the other dev, but send him or her to work on the easier tasks when possible. This frees you for the harder, and therefore more valuable tasks. Be there to mentor the other dev, both in the project-specific knowledge that you have and in the wider professional knowledge that you have. This develops the other dev, which is good for him/her and good for your having to deal with that devs changes. It also counts as some management experience, which is good for your resume should you ever go to a company or should a project ever require it. Actively hunt for and exploit those silver linings whenever possible.
Magento.
Wouldn't PHP (php-src) be considered a C application? Github says that only 27% of the code is PHP, and I think most of that is just from the .phpt test files.
From the client's perspective : - Maybe the application is fairly critical to them and they feel like they're too dependent on you. - By having someone internal, they're giving themselves insurance, and potentially lower future costs. - Perhaps they're also finding that you're overloaded/slow to respond/not in their office to talk about things etc. Regardless of whether there are one or many developers working on a project, you should have some sort of version control system in place. It's a free version of a backup at least. As a last resort, assuming the code is on a single web server, do a 'git init' in the directory above the document root, add all the code in and commit locally. At least then you'll be able to track/discover changes made by someone else. If communication between you and the other programmer isn't all that good, you're highly likely to suddenly find a big dump of code on the server - which may be hard to merge with what you're working on ... 
Embed.ly is great. In the beginning they also provided a free plan that covered little personal projects. That changed and they require a 10 bucks per month plan now for the same embedding functionality. Good for them, glad they got popular. I was considering alternatives mostly in the JS space for projects not generating that revenue. Imho there's a place for a well maintained PHP embedding library. Thanks for the heads-up.
This is extremely illegal. The law frowns on vigilantism and booby traps. If someone commits an illegal act against you, the only legally-sanctioned course of action is to notify law enforcement, not to engage in illegal behavior yourself.
I'm not available for a full-time position, so that wouldn't happen. I don't think their in-house person isn't a dedicated coder either, he has other duties. I just had a look at his work and it wasn't everything I could hope for. I wound up instructing how to properly implement the changes in a way that follows with the system architecture. I think my role is quasi-lead dev from a distance. Recognized as the definitive expert on the system, but not in the loop on every change that will be made until perhaps it has been made. If I need to review everything that he does, though, then I'll have to charge for that. Have a meeting on Monday, will discuss my concerns with the client.
Thanks, I'd agree with some of the points you detailed. I think they want to have someone in-house to take care of less complicated tasks, but that person will need some time to come up to speed. I also have to manage multiple projects, so I do have periods when I'm less available. For instance, today was about adding in a different PDF generator. The proposed code change ignored the existing system in place for adding new templates and altered the existing default methods that actually populate the data. I detailed how it should be handled so that the code can be deployed to all sites using the same code, rather than having to account for that one site that has a patch. He did detail his changes well, so I think that communication will be good. All versioning I've done has been local, since I've been the only developer. I will discuss possibly setting up versioning, though, moving forward. I'm not keen on releasing the code to a 3rd party, and certainly wouldn't use a public repository, but have looked at using BitBucket. As for backups, this is pretty resilient as it is packaged as a ZIP file for every version, which I have and they have on multiple servers.
My own main business website was on the back burner for about 10 years. It was so outdated, made with table layouts, etc., but I never had any issue getting work, so I never was pressed to update it. I likened it to a car mechanic works on everyone else's car, but drives a clunker, or a chef that makes the best for the restaurant, but goes home and eats a microwave meal. But a few years ago, I finally made that push, completely redesigned, made my own 3D carousel, and made it as close to perfect in terms of Google's suggestions (except for above-the-fold/lazy loading). It looks so much better now, glad I took some time to finally do it.
In addition to what the others have said for production servers you don't wanna reinstall very often so if you can get 3 or 4 years out of an install it's great.
r/phphelp 
Bummed that this is being held in Livonia and not Detroit. I'd imagine out-of-towners would much prefer it were held in a place where there were actually things to do!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; How do you sell “the business value” of backend development You sell **the business value**, not the development. Your clients want to make more money - what will you provide to help them do that? Things businesses care about: * Increasing capacity / efficiency * Reducing costs * Solving problems they're currently facing * Identifying problems they don't even realize they have * Identifying and exploring new revenue channels * How any of the above will increase their revenue after paying your fees * How quickly and dependably you can deliver Business will tend to care much less about the technical implementations, depending on their business model and current technologies. There are obviously exceptions if their business revolves around a specific stack.
Interesting I don't pay and I still use it on a forum with over a million visitors. like I said I haven't even thought about it for years, maybe I'm on an historical plan or something 
Before this change, your code would have tried to execute and you'd have tried to do work on a boolean instead of a row. Did you not run into any warnings or error?
I've been using embed.ly since 2011 there's definitely been a few options around over the years 
For those who would like to use it, but can't e.g. because AWS has no Ubuntu 18.04 image yet. You can use Docker Ubuntu 18.04 image. I am almost done with the migration from Ubuntu 14.04 and PHP 5.5.9 to 7.2. It's really great the technology world we live in. So proud of the PHP and Ubuntu community. Have fun !
Are you also taking into account external dependencies?
Ah, thank you! I was puzzling over what this was about.
Just as a quick note, it's HUGE pain to update from 16.10 all the way to 18.04 for instance, but updating between LTS versions is a breeze. So 16.04 -&gt; 18.04 is easier than, let's say, 17.04 -&gt; 18.04 At least in my very recent troublesome experience.
Learn PHP if you feel like, but at this point I'd probably choose node.js or python. Trends are favorable for these two (trends are not everything, I know). PHP reputation is not good, PHP in general is slower (killing the chef) and lacks some features
But instead of firing up a good REPL, why not writing good tests? I mean, where's the real difference? The main logic is imo, to write the correct tests and then it doesn't matter if you do it with REPL or you just write useful tests than can be executed anytime. And btw. that's the real advantage of tests - that you can execute them anytime, whenever you change something. That nothing gets broken. That's the real advantage of tests, not making sure that it works when you release the package the first time. Regarding low-quality tests: I think we can absolutely agree here, that bad tests are not useful at all and then better not having any automated tests at all.
&gt; Moodle has 2,1 PHP MLOC From what I see it can be reduced ~10 times of this size...
Then what is it?
&gt; But instead of firing up a good REPL, why not writing good tests? I mean, where's the real difference? Time and effort. An adequate test suite will inevitably take you as long, if not longer to create than it took you to create the package itself. Manual testing, whether via REPL, browser, debugger, or whatever other method you choose, is going to be much less effort (and you're likely going to be doing some form of it anyway, whether you create a test suite or not, unless you practice TDD). Yes, their are plenty of benefits that come with having an automated test suite, but they don't come free. The question isn't just "why not?" The question is "what are the trade-offs?" &gt; And btw. that's the real advantage of tests - that you can execute them anytime, whenever you change something. That nothing gets broken. That's the real advantage of tests, not making sure that it works when you release the package the first time. It depends. Smaller, faster moving projects will benefit much less from test suites than larger, more stable projects. Automated testing is ironically very deficient in that regard: the more drastically and frequently your project needs to change, the less useful automated tests become. But none of that matters to a package consumer anyway. Consumers don't make changes to their dependencies, and they don't (usually) run their respective test suites even if they have them. So, it's really a mixing of concerns here. A test suite is primarily beneficial for package _contributors_, so, from a consumer's POV, I don't think concern over the lack of a test suite is particularly justified.
True. A clean server would always be the best course. I was just thinking of speeding up the cleaning of the files.
We looked at venues in Detroit, unfortunately the hotel rooms would have much more expensive downtown (200+/nt) with room for an event of this size. In the spirit of trying to keep things affordable for attendees, we chose to look elsewhere. That being said, downtown Plymouth is a 5 minute Uber ride and has a pretty good night life. Downtown Detroit is about 20 or 35 minutes as well. Maybe someone should step up and organize a pub crawl! 
Yes, as far as I'm aware a non-LTS update has to go through each release in sequence. Back in 2016 I updated a 14.10 laptop to 16.04, which took three steps.
http://spaceballs.wikia.com/wiki/Lone_Starr
Ah the days of LMGTFY
Devops noob here with a noob question, so does this mean that php 7.2 will be installable from package lists without needing to add it first? Or that it will already be installed alongside Ubuntu 18?
If you look at the metapackage, it says **php (1:7.2+60ubuntu1)** which means 7.2 is the default. You can downgrade if you want.
Same here. IUS just feels more official.
 count_real($foo) 😂
I spin up VMs all the time at work, and although I barely use PHP there, I create LAMP stacks often for testing purposes. I have an Ansible script for deployment, and I've been working with 7.0, although I use 7.2 in my free time. I use Arch/Antergos, and I keep my PHP apps up-to-date, so I'm used to updating (personal preference). Maybe I'm forcing myself onto Ubuntu's philosophy, but I don't see why 7.2 couldn't have been added as its own set 7.2 packages. Is the community against multiple package versions? 
It's absolutely massive and M2 is even bigger
You could take a lot of the setup work out of the hands of the end user by creating a composer plugin for your package. This also removes the need for the user to add post install scripts manually, as the composer plugin can handle that. https://getcomposer.org/doc/articles/plugins.md
Yes, there are lots of comments there. 
I will, I'm just asking for help to check if I haven't missed anything. Should be next week. 
Good idea. Believe it or not, wordpress is ranked almost 200th in my list. Wordpress size is in its plugin. woocommerce is ranked higher. 
For the record, the "..._real()" functions come from the MySQL C API, not PHP.
It might just mean forcing https.
I’m not a Ubuntu expert but another thing I remember having to do is change my repositories to something else because ones out of date would no longer update and disallowed me from updating the whole system.
FYI if people are still reading this post, had some hosting issues past night and the site went down for a couple of hours while I was sleeping. It's back up.
Not news as I said. It was a month ago when 7.2 landed. 
Typo3 ? 
Typo3 ? 
Wow you really have no idea what you're talking about at all.
wait, are you counting comments as lines of code? 
I won't : I count PHP tokens, and not LOC. But it's a longer process, so I'm recommending phploc for a quick check. 
Imho if you want anything even remotely to a useful metric the external dependencies should be included by default instead.
Top 40. 
yeah sorry - I just misunderstood your comment
I use bionic on my desktop, 7.2.2 landed in February. 
Still doesn't make sense to me, but I'm glad 18.04 will include 7.2 by default. 
Okay awesome, I figured that was the case. That's great! It'll make my Docker builds way easier too. 
Thank you for a reply. if you check this link. their pages redirect to the amazon products. I was wondering how they can make their redirect link searchable just like their page. https://www.google.com/search?q=site:camelcamelcamel.com&amp;hl=en&amp;ei=kOOjWp-MMsqX8wWN-4r4AQ&amp;start=70&amp;sa=N&amp;biw=1309&amp;bih=650
Mediawiki?
Maybe they don't redirect for Google robot, only if you are not the robot you get redirected 😜
Remi has php 7.2, if you’re into that sort of thing.
I think it's a fair point that current php versions can always be installed, and it's easy enough to make installation scripts for these things. I personally really enjoy [software collections](https://www.softwarecollections.org/en/). But it's also nice not having to do that, that out of the box I'll be getting *at least* php 5.6.
That's what `dev` dependencies are for
yeah, i was talking more about servers. I think it's easier on desktop because you can afford the personal down time plus it's exciting to upgrade. With servers, LTS makes more sense. I made the mistake of not installing LTS and then Postgres's important security updates were not available while they were at the older LTS version. Never again! :)
Their version of curl still doesn't have http/2 support though :(
LimeSurvey?
Chanel is supposed to be cpanel
&gt;not using shit Why is C# allowed, then?
I am not a lawyer, and this is based on my understanding of Dutch law. If you write (author) an application, you own the copyright. You still own that copyright even though the client payed for it. That right is only transferred to the client if it expressed *explicitly* in the contract. Most client forget to includ e that in the contract, you my guess is, you still own the copyright of your application. So you can sell it again to another client, and the client can't resell the application to others. Because you own the copyright, the client has _some_ restrictions. What those are in your case/location, you can probably look up with keywords like "software copyright" and whatever you specifically wabt to know E.g "software copyright who owns" gave me on ddg this link http://www.developerdotstar.com/mag/articles/daniels_softwarecopyright.html 
Sorry for causing confusion. My point is that costs are not necessarily related to dependencies. Just replace PHPUnit with a template engine. Producing "Hello World" with plain PHP is about the same effort as using a template engine with the same result. LoC with Dependencies will give a very wrong cost estimation.
Sorry, I chose a bad example. I fixed that with a template engine.
I don't know really what Channel is but many non local setups don't allow remote connection since there's no built-in encryption. You may need to enable remote access. But anyway, use the IP or domain of the server as the host and the mysql user and pass. Really, if you're learning just load mysql on your machine. You'll want to add some kind of gui too, like MySQL workbench. 
top 100
Top 10, good guess. 
Just wipe your tears with all that job opportunity and dough. It’s easy to be polarizing; it’s much harder to have balanced, informed opinions. 
I'm considering the request, though it is too much of a detour here. From a production point of vue, that makes sense, since the whole code is necessary. I'm extracting stats of size from code that I've audited, and there is no point in auditing external component. (I'm also afraid to run composer on 1800+ projects....).
I would ask your host provider for this information.
They're just misinformed, and it comes from a very outdated understanding of PHP. I've noticed that many of the harshest critiques of PHP either act as though it never matured past version 5.2 or are just misdirected critiques of poor programming by new developers. (The fact that it's so easy to get started with PHP is its blessing and its curse.) The contention that no serious company would use PHP is just laughable. Perhaps they're forgetting about [Facebook, Yahoo, Wikipedia.org, Wordpress.com](https://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites), [Tumblr](https://engineering.tumblr.com/post/152998126990/php-7-at-tumblr), [Baidu.com](https://w3techs.com/technologies/details/pl-php/all/all), [Flickr](https://builtwith.com/flickr.com), [Etsy](https://builtwith.com/etsy.com), [iStockPhoto](https://builtwith.com/istockphoto.com), and on, and on...
You already answered your own question. You are there to get a degree. Not to learn anything. Just smile and give your instructors what they ask for. Maybe near the end of the term you could ask how much money they make. Most instructor jobs are below minimum wage.
On the other hand, the more lecturers like that exist, the higher your salary gets.
Out of date? That’s exactly what I’d expect of a university lecturer ;)
Those who can: do. Those who can't: teach.
I didn't share that in the post, but as soon as he said the "serious company" thing I said the name of the company that I work in, which was declared as the 2nd best IT company in the country and which fame is build upon PHP, but he acted like he didn't hear me and got out of the room.
As a contributor to the PHP programming language I can say without hesitation that PHP is among the worst programming languages which are popular. The fact that your lecturer said so is not really the issue. Rather the critique of any language should be based on merit and evidence, not emotion. It's probably also unfair to preclude PHP from a possible language for the project when (I'm assuming this part) that no preclusion is given in the project's written description. If you want to do this project in PHP I suggest that you write a polite email to your professor. Explain your background in PHP, cite the famous "It's a poor craftsman that blames their tools", and ask for permission to do the assignment in PHP. If granted you should do your very best to achieve 100% on the assignment. This is one way you can try to help change belief and attitudes of others. At the same time, this is also an opportunity for you to learn new tools. I'd love to do a web-based project in a functional language stack; here's a recent blog article about it: [Elm, Elixir, and Phoenix: Reflecting on a Functional Full-Stack Project](https://teamgaslight.com/blog/elm-elixir-and-phoenix-reflecting-on-a-functional-full-stack-project). Lastly, if you are bothered by others bashing on PHP you should spend some time reflecting on that. Are you bothered when people bash on bad consumer products? Bad politicians? Why would programming languages be any different? My guess is that it's because you have developed some skills and employment based on PHP and there is an issue of pride or security or both.
I strongly disagree. Most project are splitting up their code base into reusable packages. However they are hard dependencies. As in: the project won't even work without them. 
Bionic lands in April...
Ha! Well you have your answer then. He's speaking from ignorance.
&gt; creaky ass-virtual machines *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
did they start off with magic quotes?
&gt; My guess is that it's because you have developed some skills and employment based on PHP and there is an issue of pride or security or both. You are partially right about that and I think the issue is the former. I think that why I get offended so much is that people usually bash on the language where they intend to bash on the bad code written using it and confuse the technology with the programmers. 
Whilst it’s is true that professors’ tend to have strong but frozen-in-time opinions, please understand that their notions do come from how a language is built and not from its usability. I am language-agnostic but I always try my best to work with modern C++ than I would with php. I absolutely love php’s dev time but I don’t prefer a scripting language. My goal is not to discriminate against php or any scripting language, but to attempt to explain that professors (I am not one) disseminate their disturbingly roytish opinions based on a language’s capabilities and underpinnings. Not their practical usage. 
Here, you dropped this: ^/s
&gt; Lastly, if you are bothered by others bashing on PHP you should spend some time reflecting on that. Are you bothered when people bash on bad consumer products? I'd like to add a different perspective here. What really bothers me is when security experts declare "nobody should use PHP" and turn their back on the language wholesale, when [most of the websites on the Internet use PHP](https://w3techs.com/technologies/overview/programming_language/all) and that percentage has been growing over recent years. It's ultimately self-defeating and creates a massive blind spot. If PHP is so bad, then Mr. "I know better" should put some skin in the game and *improve PHP*. (Most of the world is going to use it anyway!) But they never do. They like to pontificate from their comfortable state of impotent misery.
I enjoy C#...
Or register_globals
&gt; I can say without hesitation that PHP is among the worst programming languages which are popular. That doesn't make it shit. The professor literally called it shit.
What database, user and password did you create in cpanel? 
&gt; I'd love to do a web-based project in a functional language stack I'm laying out a pretty large Elixir / Phoenix app right now (though I primarily do PHP projects) and so far have found it to be pretty good, although certainly not superior to object based implementations for every use case. I'm going to be working on spinning up a small team on it (of primarily PHP devs), and I'm interested to see how that will play out. 
It might be shit, but it powers wordpress, which runs 30% of websites. Get over it.
The official release you mean. You can upgrade to the current state of bionic any time you want 
&gt; What really bothers me is when security experts declare "nobody should use PHP" I wouldn't call those people security experts. After all, every day people write horribly insecure code in other languages than PHP, and we all know that it's perfectly possible to write secure code in PHP. People also tend to look at WordPress with disdain when it comes to security, when it objectively isn't less secure than other major platforms at all and the WordPress team is known for quickly and adequately reacting to security vulnerabilities. It's the shitty plugins and themes people need to be worried about, but then when you just trust anyone to write code for your site and don't look what's under the hood, is it really the fault of the dipshit who wrote the plugin that your site is now buggy and vulnerable? Is it really the fault of the creators of the language it was written in? I certainly don't think so.
For high volume sites these days though, what is the preferred backend? Php/laravel and ruby/rails seem too simplified. Java will be the most performance, but I really don't even know what web friendly frameworks people use with it. Node.js still feels rather specialized to me and the non-relational style not appropriate for many uses.
How would we know if you missed something without knowing what you already know? 
&gt; I wouldn't call those people security experts. One of the founders of Matasano Security (which is now part of NCC Group) who wrote papers in the 90's about evading IDS with packet fragementation isn't a security export? Cool. That's the problem: They are security experts. They're just tragically misinformed about PHP as a language and stubborn about it
Those who can’t teach: govern.
You seem to be misunderstanding my argument. I'll break it into discrete components. 1. It is news... 2. because Bionic isn't released yet. 3. Bionic won't be released until next month. 4. PHP 7.2's inclusion in Bionic hasn't been announced in /r/php before. Therefore: It doesn't matter if **you** personally knew about it next month. If it hasn't been announced in /r/php before and it's an event in the future, it's categorically news.
Which company?
I think when you look at it from a learning perspective, PHP is much harder for students to grasp than something like Java, or C#... That's probably why there is distaste for the language. IMO, Java/C# tend to work like the batteries are included, all you do is just open your IDE and you are ready to begin hacking. PHP, on the other hand, requires a tiny bit of effort to get set up, which students who've never programmed before would look at and become overwhelmed.
Go, python in the startup world. In the enterprise world, java and c#/.net. However PHP+Framework is still a Great Choice for a minimum viable product.
/r/thathappened
You probably should have started from "which country" :) It's based in Bulgaria, so you probably have never heard of it.
I don't think Edgy McEdgelord was being sarcastic.
Using Spring Boot with Java, you can very quickly get a web app/service up and running by just running a single command. It includes a http server and everything you need to host the app. I have spent many years developing in both PHP and Java. I can attest to both platforms maturing massively. Both may have their flaws, but bashing Java with out of date arguments is no better than bash PHP with out of date arguments. Personally, I found PHP to be fine for smaller projects, but less suited to larger, enterprise level, projects. Different tools for different jobs. That isn't to say you can't write sophisticated apps with PHP (I worked on a large app for many years), just as you can write simple apps in Java. The great thing is, you can use both!
&gt; It isn't a language used at any reputable companies anymore, either. Odd, we use it at the biggest healthcare provider in the US, third biggest box truck fleet in the US, backed by the largest hedge fund group in the world.
What I meant was I've found Java web apps cost more to maintain than an identical app written in PHP. When being tasked to maintain a Java app I have to charge more. Why? They take a lot more maintenance. One major cause is because of odd java virtual machine issues that can be a bitch to track down. Especially when a new version of Java is released. Its almost like Oracle is making money from licensing old versions or something ... Besides the performance argument, I still have yet to see a valid argument that says x or y language is far superior to PHP for high concurrency enterprise apps. And no I'm not being a fanboi, I'm legitimately curious. 
I'm currently working as a web developer also using PHP. When I started after University I also had a bad opinion of PHP, hell even web development in general. I think the problem is that universities tend to discuss a whole other bunch of problems. PHP is objectively bad for most problems discussed in University ( high performance computation, etc). I think it's great for economic purposes, not so for scientific purposes.
Not sure why the lecturer being female is mentioned or relevant. 
Good programmer can use any language he can use for a suitable features, PHP or not is never a problem unless integration with existing system are concerned
Why do you think C# is a shit language? Genuinely curious...
iStock's PHP site is an old version of the website before they were integrated with Getty. Whenever someone would talk about it they always did so with a little hate in their voice. Getty is upgrading all of their pages to Ruby on Rails, and at the time that I worked there they were also using Angular 1.6+ but in a very non-Angular way. Both Getty and iStock are very slow to change technologies and they don't really listen to the advice of their developers because they have principal engineers that act as barriers to any change. Even if someone told them that the current version of PHP is 80 times faster than RoR, they still wouldn't upgrade the old PHP code.
Strong typing and concurrency for starters, I’d imagine. 
I work on a C#/.Net web app whose only purpose is just to serve a JSON API. I have never seen it require so much code to do something as simple as translate an HTTP request to a JSON response. Now, I'm not a C# guy, but the people who work on the project are diehard, dedicated C#/.Net guys, and if our current code is representative of how a web application written in C# *should* be written, count me the fuck out. 
What's wrong with c#? 
Where I used to work, they were still on a PHP 5.3 stack (1.5 years ago) because the code would break on a more recent PHP version. The code was littered with deprecated calls, magic quotes were enabled, etc. While switching the JVM is not without potential issues, especially if the source code is absent, it is far less messy than untangling those PHP 5.3 dependencies. For enterprise apps, having a multithreaded application running, rather than per request scripts is a powerful architectural difference. PHP may mature to allow this, but it was not part of the original design and memory leaks and thread safety have been thorns in the side. Likewise, strong typing helps to define clear interfaces between components, which removes ambiguity when creating and integrating libraries. This has lead to a proliferation of high quality libraries. PHP is much improved compared to 6 or 7 years ago, but in my experience, Java still has a substantial edge. That said, I worked in a company which switched their main front end app from Java (the primary language used by said company) to PHP to gain access to Drupal. This decision predated Spring in its modern form and the decision may have been different if made today. It is clear that PHP has some great CMS frameworks though and these power a great many websites.
Then I sure hope you use PHP 7.2, have CI with required linting and static typechecking, a custom standard library, and an event-loop based system? Most large companies using PHP, do. If you replace everything that makes PHP PHP, then of course, it becomes usable. But at that point you usually have half-way rebuilt the JVM or JS ecosystem in PHP. To guarantee reliable types, and that generic types correctly return values, you’ll need static analysis, you’ll need a linter, while all statically typed languages do this in their compiler automatically. To provide async functionality, threads, or any other form of concurrency, you’ll have to use an eventloop library with continuations, or a thread library. And then, why use PHP? You’ve thrown away every benefit of it, and rebuilt your own, custom, ecosystem. This is the same criticism JS gets, and for the same reason. JS and PHP are, unless you basically build your own ecosystem on top, are shit. That’s why Java, C# and nowadays Go are so much used – they make it very hard to do things wrong, and easy to get things right. There’s one way to do something, and it’ll be the right one. Go goes so far as to enforce one code style. You get sane defaults. The length of a String is "text".length(). Adding an element to a list is list.push("element"). PHP’s standard library wouldn’t be such an issue if it was consistent. Why is array_push with underscores, strlen without anything, and do you know the position of needle and haystack for finding a substring by heart? PHP could go a long way by rebuilding their standard library, and adding functionality for concurrency. But everyone that’s serious about using PHP today has built their own stdlib anyway. Check out for example the representation of time and date. Java nowadays does something that seems very complex, but is the only reasonable option: There is an Instant (a moment in time, without any info in what timezone it happened), an OffsetDateTime, which is a moment in time, associated with a timezone offet, allowing to turn this one moment into year/month/day/hour/minute/second information. There’s the ZonedDateTime – a moment in time, associated with a timezone. This also allows getting other points in the future or past – for example, "yesterday at the same time" depends on the timezone, as daylight savings time may have happened inbetween. This is why ZonedDateTime exists. There's also LocalDateTime, which stores just the local info - year/month/day/hour/minute, but without timezone info. This is when you e.g. want to represent new years eve as calendar event, and store it in the database, but you don't know yet in which timezone the user will be by the time it happens. LocalTime is also what'd be used for an alarm clock - wake me at 8 AM means 8AM, no matter what timezone. PHP has for all that just the Date class, and it handles many special cases wrong. TL;DR: PHP is absolutely usable, if you replace everything it provides, and build your own language on top.
&gt; "because here we write using programming languages, not using shit" http://www.cs.utexas.edu/users/EWD/transcriptions/OtherDocs/Haskell.html, don't get me wrong I would bet Dijkstra would have thought PHP was pure vomit too, but he wouldn't be defending his position by waxing poetic about C# or Java. Dijkstra lays down some pretty strong hints that there is a difference between "vocational programming" and "educational programming", he more or less states on several occasions that he believes the study of one before the other is harmful to the development of the programmer. &gt; "there is not a single serious company that would use that silly language" This is also a ridiculous statement that is easily proved wrong. There are obviously many large companies (including tech companies) that use PHP and some of the most trafficked websites on the Internet use it as well. 
&gt; Then I sure hope you use PHP 7.2 PHP 7.1.15 because AppDynamics doesn’t have an agent for PHP 7.2 yet, but when they do it’s a simple upgrade on the servers. &gt; CI with required linting and static typechecking, a custom standard library, and an event-loop based system Full CI with linters, unit/feature testing for PHP and Vue and Selenium for automated browser testing that deploy either internally with hooks with Jenkins or externally with a mix of Envoy, Bash, and Python. &gt; But at that point you usually have half-way rebuilt the JVM or JS ecosystem in PHP Nope. We use Laravel and Vue, so it’s mostly PHP and the rest is JavaScript. Full RESTful API for white labeling and internal hooks. &gt; And then, why use PHP? You’ve thrown away every benefit of it, and rebuilt your own, custom, ecosystem. Laravel, Spark, Redis, Vue, etc. all out of the box. Nothing really custom about it. &gt; Why is array_push with underscores, strlen without anything, and do you know the position of needle and haystack for finding a substring by heart? That’s really nitpicking, but we use Collections so rarely have to dive heavily into native array/object handling methods. I know a lot of them by heart, and if not, I either Google it like everyone else does or rely on my IDE to help me with what order things should go. That’s irrelevant to the language though, no one memorizes every function. &gt; Check out for example the representation of time and date. We use Carbon for PHP and Moment for JavaScript to handle dates, so this is moot. &gt; PHP is absolutely usable, if you replace everything it provides, and build your own language on top. 👌 TLDR: We use it. It works. We didn’t write some crazy custom ecosystem or the entire PHP library. And I get paid extremely well to do what I love.
Yeah, I understand that. I mean people are more likely to use it than 17.10. 
A person who is ignorant enough to ignore that Facebook, Tumblr, Etsy etc. are all implemented in PHP doesn't deserve such a serious attention.
Are they using a framework? I see what you mean, but can also see the advantage of coding something in a standardized manor, for example it makes it easier to grow he project and bring new devs onboard, right?
So how is the new developer deploying his code? By emailing you a load of file(s)?
its cause he's jealous i make more money than him using PHP.
Yeah the framework is .Net.
That's because Wordpress config monkeys count as PHP developers (and I have nothing against those people, it's a job I could never do, but it is a job that loads of people who are not actually programmers can do really well).
wow this looks great. thanks will give it a go
Ok so if we remove those from the caculation, where would you estimate the average salary to be in comparison to the other languages?
This is kind of the reason why statements like "Those who can't do, teach" come to exist. It's not born of the idea that teachers aren't smart, but that they tend to very quickly fall out of touch and become very set in their ways. They teach what they know, but they don't know everything. If by university, people haven't learned to accept that professors are not experts of all things in a field... they themselves are not looking to really expand their horizons. 
Some people in the professional world would rather talk down on people rather than share encouragement, tips for growth, etc. These people sound like they've been personally vindicated against by PHP, lol,
I think they meant like ASP.NET MVC or ASP.NET Web API, both of which can respond with JSON out of the box just by returning a model instance from a controller method...
I didn't check his Twitter. This was what he said to me in person, at the Lone Wolf Tavern in Chicago, in December 2016. 
There is a lot of hate on PHP - don't take to too serious. Sure PHP is very flexible, like JavaScript, which means you can write shitty/hacky code - however, when done well, PHP can be a very powerful tool.
UK contractor here. It's about 25% below the equivalent job with a MEAN stack.
&gt; PHP's strengths are string handling, array handling I would not say this. I can't really see how PHP has anything particularly distinguishing about how it does either of these things compared to many, many other languages.
Ever heard the phrase"those who can't do, teach?" It's dickheads like this that keep that phrase going
Here's the [list](http://php.net/manual/en/ref.array.php) for arrays. Other dynamic languages have a better approach (IMO): a less-rich suite of primitives, with the ability to monkey patch new function in as and when you need them. But this goes to the learning curve - PHP has a rich suite of array functions out of the box.
A library that encapsulates the pattern described in the article and works with immutable datetimes as first class citizens: https://github.com/cakephp/chronos
What are some things that bother you about PHP?
Which company?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Dude every fucking language has tons of libraries, frameworks, and packages. That’s like telling me not to use Angular or React or Vue and just use pure JavaScript, or not to use any Perl packages that are vetted and have been used forever so I don’t have to reinvent the wheel, or to not use Rails with Ruby, and so on. You’re just being ignorant at this point.
Thought I was in r/incels for a second. Y’all get too offended about stuff, just move on.
Slack belongs on there as well, considering they made the decision to use it from the beginning, and it’s still fairly new, but wildly popular.
&gt; Ask them to find a company who builds any web app in C# [snip] bare metal languages. wut C# is pretty far from bare metal. It's also extremely popular with enterprises and startups. DotNetCore makes it even more so since it'll run on Linux with first party support. As for companies writing web apps that "bare metal webapps" perhaps you've missed the tremendous explosion of support for Go which compiles to machine code. Even Rust is picking up steam in the webapp arena though it seems to be more in the "I need to replace this slow module" rather than using it through out the stack. 
I'm not really sure how most anything on that list isn't well represented in the average programming language, though? I mean there are some that don't exactly exist in other languages as function/methods, but PHP (rightfully imo) takes flak for having so many non-orthogonal functions/features. PHP now has a lot of the general-purpose language features that let you get away from a million weirdly-specific functions, and I'd much rather read and write code using those feature rather than see someone make me have to read the language docs again to figure out what specifically `array_uintersect_uassoc($array1, $array2, "strcasecmp", "strcasecmp");` means because I haven't ever seen that oddly-specific function before.
&gt; In a lot of places they've resorted to using varto [sic] make the code more readable and terse, which takes all the arguments about type safety being a major advantage of C#, lights them on fire, and chucks them out the window. var doesn't chunk type safety out of the window. What it does allow you to say "Look compiler, you know the type and I know the type, so I'm not spelling out the type." There's not much reason to not use var in a method, unless you're either predeclaring a variable or need to upcast the return value. &gt; On a day-to-day basis, I encounter no fewer exceptions and errors running that C# code (or writing it myself when I have to) than I do when I write PHP, so I'm not really seeing the advantage of a manual compile step magically catching problems and reducing the number of runtime bugs/errors. You'd be amazed at how exactly opposite the experience has been for me, albeit with Python instead of PHP. I've had the same experience using Rust in personal projects. The type system alone saves me so much headscratching that I'm beginning to move projects to Python 3.6 as the minimum supported version to take full advantage of type hints. 
&gt; but I really don't even know what web friendly frameworks people use with it. Spring is pretty dominant in the Java world for a lot of things. &gt; Node.js still feels rather specialized to me and the non-relational style not appropriate for many uses. Regardless: they're very popular. I agree they should be much less so from a technical standpoint, and so do many other people, but that has little to do with where the hype-train for programming takes us.
&gt; They are free to do what they want, but it feels like a betrayal. I did code every line in the application from the ground up, and now someone else making changes without conferring first. Sorry to be direct, but you should've thought about this up-front. Things developers and software houses do to reduce the chances of such a mess: 1. Keep IP on key components. This means the customers pays less (they just license the component), but you get to keep ownership of it, in some cases the (full) source code, and you can reuse it in other projects. *Everything* I do that's reusable is licensed this way. 2. A clause in the contract that if someone else touches this code, quality and stability guarantees are out the window. Free support period after an update (to iron out bugs etc.) is out the windows. And further work on the project will be more expensive (as it's now harder to coordinate with someone else's unsolicited changes). &gt; I know that there can be exclusivity clauses in contracts, but also as mentioned, the work is done on an as needed basis. So you know about this. I'm not sure how that changes anything when it's on an "as needed basis". 
Some companies have strict social media policies. He may not be allowed to say. 
Were you freelancing or what sort of company were you working for?
Obviously isn't a huge security concern. Are you dealing with IIS as well? Very good chance it will crash, often, and reveal critical configuration information to the general public. The OS itself is likely to crash as well, and can't exactly recover from a failure. It will sit there on a BSOD for weeks until someone comes in to physically deal with her problem. This doesn't even touch on viruses and malware! Hardly FUD.
I've seen what PHP gets taught in universities and I'm not surprised.
http://php.net/manual/en/function.array-uintersect-uassoc.php
This actually looks pretty good.
^ this, one of the reasons i dropped university. I was already working as a dev for a few years then and the only things i got from this was anxiety, slight depression, VERY empty pockets and hatred for people who teach shit that was good to know 20y earlier. FFS i've even had a lecturer on OS's and java programming who did not know how to handle a laptop and his powerpoint lectures (which later were changed to word files, because he did not know how to use powerpoint). Also he did not know java, he was just reading from his paper, and when it came to practical lessons or tests, if you did not write a program EXACTLY like he had in his word sheet, you would fail, because if it's not like this then it's wrong and it should not work.
&gt; Besides the performance argument, I still have yet to see a valid argument that says x or y language is far superior to PHP for high concurrency enterprise apps. The biggest issue in PHP is that it has very little in the way of concurrency per se - it generally relies on the webserver/appserver to provide all concurrency by handling worker pools or spawning threads on behalf of the PHP runtime. Very often that's fine - that's all the real need for concurrency something like average website needs, but if you're looking to make a product that in some way requires PHP in and of itself to be a supervisor of many threads/async tasks in an event loop PHP is pretty anemic there. Most people just don't use PHP for that sort of workload, and vice versa. (Before anybody tries to prove otherwise and that you can do these things in PHP: Yeah, I know you *can*, I'm just saying relatively few people *do*, the options for it in PHP are not widely used in comparison to many other systems for doing such things, and what PHP does have is at best a younger, less-used version of the same thing in other languages that focus on threading/event-looping more.) If you want a very mature system that's widely used to work with you can opt for Java+Spring; it's well tested and sort of a too-big-to-fail type thing - you know support for it is basically guaranteed for many, many years. Python+Tornado is another option in a similar vein that targets many concurrent, long-lived connections and is quite mature too. Go is quite popular right now and has built-in [CSP](https://en.wikipedia.org/wiki/Communicating_sequential_processes) style concurrency. Erlang is a VM and language explicitly made not only for high concurrency, but also emphasizing fault-tolerance and uptime. The ability to hotswap code and the focus on gracefully handling unexpected problems may be exactly what you're looking for. Although Erlang the language is considered janky by a lot of people, the VM itself is considered very solid. Enough so there's a big project to give you a better language to get at the Erlang VM - [elixir](https://elixir-lang.org/). The Erlang system is fairly big with a few of the big communication app systems like SnapChat. If you don't mind trying newer and less mature platforms: Rust out of the box has good threading support and the whole language was built around trying to make threading+concurrency easier and it has some pretty great static analysis for that already considering how relatively young a language it is. There's a third-party library for event-loops that probably not going anywhere soon. Now you specifically said 'enterprise' as well: with the exception of Python+Tornado you'll notice something about everything I said above: they're all statically typed languages. It's generally recognized as true that if your goal is to minimize runtime-errors (or at the very least handle them gracefully) static typing is indispensible because it makes a whole class of bugs preventable at compile-time. PHP, while it has enforceable typehints, is not a statically typed language. Even with religious use of typehints and tooling PHP just can't hold a candle to what you'll get in terms of static analysis from fully-statically typed languages with much more strong typing - especially compared to Java which has a lot of mature tooling, and Rust which has a language design so focused on enabling good static analysis it actual builds static analysis into the compiler and classes various issues as errors. PHP, as with other dynamic languages, is generally easier to write, it offers a lot of flexibility to do interesting things without needing to re-engineer everything else, it's still a fairly fast language despite being dynamic and it has all sorts of other advantages you can go on and on about, but if you're an 'enterprise' that's putting a lot (millions at the least) of money into a system that's business-critical in some respect and you're very averse to unexpected downtime and even less so to unexpected errors: you're ready to put in the extra dev time for a much more strict language/platform and the relevant tooling that will help ensure you don't miss potential errors and that sort of thing. 
**Communicating sequential processes** In computer science, communicating sequential processes (CSP) is a formal language for describing patterns of interaction in concurrent systems. It is a member of the family of mathematical theories of concurrency known as process algebras, or process calculi, based on message passing via channels. CSP was highly influential in the design of the occam programming language, and also influenced the design of programming languages such as Limbo, RaftLib, Go, Crystal, and Clojure's core.async. CSP was first described in a 1978 paper by Tony Hoare, but has since evolved substantially. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Which is an average salary for a US programmer, [according to StackOverflow.](https://stackoverflow.com/jobs/salary/results?l=United+States&amp;ed=2&amp;ex=7&amp;ff=1&amp;dr%5B0%5D=FullStackDeveloper&amp;tl%5B0%5D=) You can play around with different fields, backend, fullstack, desktop. The 50th percentile hovers between $85-90k. If you are in New York or another expensive city, it goes up a decent chunk. 
PM me if you need any help or information
Programista. Have you heard of it?
About the same for RoR.
We're talking past each other: I'm talking about learning curve and you're talking about elegance. I don't even disagree with you ("slightly better, IMO"), I'm just saying that a large stdlib (we have `date_sunrise()` ffs) coupled with a primitive language is easier to learn, while a small stdlib coupled with an expressive language is a more powerful tool. I think this is just a re-run of BASIC vs everything else from the 80s.
Holy crap, this is great info! Thanks for connecting the dots. I knew PHP was very lacking in concurrency, but never really thought to apply that missing functionality to an enterprise solutions stack. I just figured Apache, nginx, FPM etc. were "good enough" to handle the worker pools and those high-performance high-profit solutions touted by major firms are really just snake oil meant to impress executives. Thanks for clearing up my ignorance :P Now, I'm mostly a devops guy, so my exposure to actual programming is perhaps between 10-75% of the scope of my work; it depends on my project, so bear in mind I'm not a "pure" programmer like many others, so my ideas are probably subject to an understandable amount of ignorance. I've worked with a number of languages (particularly the older bare-metal ones as I'm a hardware hacker at night). But, I always find myself coming back to PHP for some reason. The syntax, the sugar, the ease of use and everything just feels "right." So anyway, I was actually talking with a colleague the other day about this sort of thing; about how PHP's task execution model is pretty wasteful: you have a web server (apache), which (in my case) connects to a process manager, which boots a child PHP process, which loads a preliminary tree of files, which (I'm guessing) checks the modified time of possibly thousands of those files, and then does some cache magic and feeds (op)code to a compiler, which then executes, processes client code, then exits and returns the results back to the process manager, back to the web server, then back to the client. I probably got half of the above wrong, but I think you get the gist. How could one simplify the whole thing? Is there a reasonably simple solution (or language) available to us plebs that has much better concurrency than the incredibly *wasteful* process of input-compile-run-output-terminate? 
As far as I can see it's not a 301/302 redirect. There is a page at the URL saying "The Camels are taking you to the....." This is what Google is able to crawl and index. The contains this meta tag: &lt;META http-equiv="refresh" content="2;URL=https://www.amazon.com...." /&gt; So your browser will refresh with that new URL after 2 seconds. As it's not a redirect in the traditional sense, the Googlebot won't see it.
People that make amazing tech, code in PHP. People that can't, teach and bitch. 
She was wrong, of course, but its interesting how you had to mention its female lecturer as if it adds anything to your story. 
People are always crazy at universities. I wouldn't even discuss such a thing. I do believe every language has their value. PHP is robust, has a powerful community and is powerful in many ways. Good PHP programmers can create in one day or two what Java pros would do in one week (I'm a Java programmer, too... I know my sh*t). 
Well the apache mod_php way of spawning a new process for each request that dies with the request's response being completed is kind of bad performance-wise, the worker-pool system of something like php-fpm isn't bad - it's totally fine. It's not unlike what many language/systems do for web services. The problem is that the model of PHP+php-fpm or mod_php is *just* for webservices, and in particular for the HTTP/1.1 response-&gt;request workflow rather than HTTP/2 or websockets which can no have long-lived but often idle sockets that need to be maintained, or things outside the purview of HTTP entirely. Other languages provide things you can technically get in PHP, just better supported/more mature/more fleshed out versions of it that can help you in the more general case. Generally we're talking about libraries for threading and libraries for event-loops. &gt;How could one simplify the whole thing? The idea of a worker pool seems amazingly simple to me - it's what many humans will do intuitively! If 2+ workers are in a storefront and a customer walks in, what happens? Usually one will go help them. What if another walks in at the same time? The second employee helps them. What about a third and fourth also enter, and there's only 2 employees still busy? A queue is formed and the employees get to the third and fourth if they can. What if there's very often a third and fourth or more customers waiting on employees? You'll consider hiring a third employee to try and match your throughput to the customers coming in. What if you have one employee that's idle 90% of the day? You'll probably fire that employee. That's what worker pool is - it's what you'd already do. And event loop is also pretty intuitive: if I give you 20 tasks, you read the first one and it says: "At 6pm turn off the lights in the kitchen" what would you do? What you wouldn't do is sit there until 6pm, then turn off the lights and read the second task. You'd put it aside and set a reminder of some kind for later to do that, then read the second task. If the second task says: "Wait for the mailman to show up, then sort the mail into the appropriate inbox for each addressee." then, again, you wouldn't just sit around waiting for the mailman, you'd make a note to check regularly to see if the mailman has shown up and, when he has, then do that task. 
I have to say that even if something objectively has flaws, that's rather pathetic coming from anyone teaching at a university.
That's not true. Certainly academics are a little more opinionated about things, generally with reasons, than someone who *has* to use it for a job and is mostly concerned with whether it can get the job done.
I've been programming since 1986 and using PHP since version 3, and he's kinda got a point. PHP started out as a templating engine, and each version tried to make it more like Java. It's gotten bloated and weird. I'd love to make the jump to something light and quick like golang, but do a google job search for developers vs php, and you'll see why I (and so many others) are sticking with PHP (for now).
I always look on people who say things like this as basically having never touched web application development. Yes PHP is pretty terrible if you used it for making anything but a web app, it's honestly not very good for serious command line apps even. Honestly most other languages I've played around with for web application development have been poor or makes the process slow. I'd say at best nodejs is the only thing that has some good advantages over PHP but it's still maturing at times. Most of these professors etc while they know computer science they've never worked on fast evolving web apps in a business environment. Maintaining web apps is damn harder than writing something once and never having to add to it again.
&gt; if you did not write a program EXACTLY like he had in his word sheet, you would fail, because if it's not like this then it's wrong and it should not work. Srsly?! That's some amateur hour bullshit. Any serious programmer should know that there is no such thing as "one true way", only more or less optimal solutions under certain conditions.
I came across this thread from an aggregator, im not a PHP developer (although I have quite a bit of experience with the language). But I am a very experienced programmer especially with another language that is not a good programming language and is also not nearly as popular. Just a bit of friendly advice - most of the commenters in this thread that are vigorously defending the language need to get out more and use some other languages. Knee jerk reactions that they must be misinformed or have out-of-date opinions arent going to help you in the long run - and lots of other people are going to take your full-throated defense as inexperience and fan-boy-ism. Not saying that you cant get useful stuff done in PHP. That it isnt a fine hammer for certain nails. But if you think its popularity is an argument against it being a shit language you're not looking at things from the right perspective. If you are just starting out, theres no reason at all to settle on PHP (or my primary language as well). If you get offered a good paying job to write it - great! if you're in college and get to choose a language to use and learn - do yourself a favor and pick a different one. I can say all of this because years ago I said the same things about my language. And as ive gotten more experience, especially with other languages, ive realized how wrong I was.
You just ran into a java dev. They are fools.
Facebook is an argument for why PHP is not so good, they had to invent their own "PHP" (not once, not twice, but three times) because PHP wasn't up to it and all the heavy lifting is done in things like C++ because PHP isn't up to it. 
Facebook is an argument for why PHP is not so good, they had to invent their own "PHP" (not once, not twice, but three times) because PHP wasn't up to it and all the heavy lifting is done in things like C++ because PHP isn't up to it.
It shouldn't come as a surprise (or disappointment) to anyone that PHP may pay slightly less. It is literally the entry point to webdev whereas ruby &amp; python are much more niché. The pay gap is probably much smaller if you were to compare similar products in different languages though.
Well I think he overstates it a tad and didn't put it across well, but I can't say I disagree with the general notion. I mean if I were to go through all the languages that I have some reasonable grasp of that have achieved some reasonable level of popularity, then objectivity I would be PHP pretty low down the list in terms of the well it is designed, how elegant it is (or not as the case may be), how limited it is, etc. As for comment about companies using it, yes and no, I think he is overstating it a little, but I'd agree with the general sentiment, especially these days, a lot of the companies who get pointed out as using PHP started using it a long time ago, if they were to start today, most would not pick PHP, the programming world has moved on. And on that note, a lot of the examples people give are bad, take Facebook, that company is an example of the limitations of PHP, it doesn't use PHP, it uses it's own version of PHP precisely because PHP wasn't up to it, then add that they invented React to handle the frontend, and then that all the heavy lifting backend it done by things like C++ (again because PHP isn't up to it). 
Yup, at the moment, he is sending the files for me to review. I can tell his mission is to "make it work", but without regard to "how best to make it work".
Please add them, with dependencies, code kbytes, loc.. maybe age of the last update of all dependencies..
In the US, the Berne convention dictates that once something is created and duplicated, the creator has a basic copyright, but that applies to works or art like music and such. As much as I think my code is a work of art, I doubt that it would be protected under that law. I'm not sure if there are any automatic copyright protections regarding code, but I'd imagine there is something similar. The thing is, I'm not the type that would claim such ownership. I do, though, have in my terms a clause that states that the code produced may use elements from common code owned by my company, and that I license use of such code. This protects having a client claim the ownership of everything I produce, as clearly, we all probably have a library of code that we share throughout multiple projects. But still, my concerns are centered around control. I don't want someone else to add code that will mess with what I've done. The first update by their coder to me was a mess, because it ignored some basic principals and created an exception in the code which applies to only 2 websites, meaning the code would be different between all deployments and make version updates more difficult. I'll have a discussion on Monday about my concerns as we have a meeting and get it sorted out.
Sorry to hear that, - this is one of the reasons why in German „copyright“ you can not give up your authorship but only grant licenses.
Most of the people I know who hate PHP is probably because they never get past the stage of doing - create index.php - if ($_POST[..]) - mysql_connect - mysql_query - else, show html If I knew a language can only do this I would also be definitely bashing the language, but the truth is PHP has gone through so many interactions and here we are at 7.2, there are namespaces, traits, classes, composer, big frameworks, companies backing it etc. It's because they don't know what the language can offer, hence the bashing. I often feel sorry for them if they bash it for nothing. Security issue? Security is never an issue for us. It's the developer who never treat data input carefully enough to prevent it. _Side note: I frequent in stackoverflow laravel / PHP section to answer questions or lead fellow new learners on best practices, and tell you what, it's not uncommon to see developers still doing mysql\\_connect and doing all sort of crazy primitive stuff with the language. These are the reason why people are bashing PHP so hard._
I do state in my terms that common code is used in all projects which my company maintains ownership of and licenses to the client. I also have in certain cases told a client I'm not going to do the work for them, but rather develop something which I will sell a license to them once done. Most projects I do, though, are very specific, like internal applications for a company and aren't very useful for trying to make as a product or SaaS.
Will do on Monday.
I've always tried to not be too overreaching and fair to the client. Still, my terms already state that common code is used in all projects, so parts of the code is licensed to the client. I've not gone as far as to put restrictions regarding reuse or redistribution, though. I'm going to review my current terms and consider making some updates to be more protective.
Depends on location. My last PHP job was more than 50% over that. But nothing makes sense in the bay area.
I have a few friends that think this way and personally I don't even try to argue anymore. IMHO a programmer is a bad one when he/she starts to blame another language for his/her bad coding habit. 
Here's a sneak peek of /r/Python using the [top posts](https://np.reddit.com/r/Python/top/?sort=top&amp;t=year) of the year! \#1: [Automate the boring stuff with python - tinder](https://gfycat.com/PointlessSimplisticAmericanquarterhorse) | [358 comments](https://np.reddit.com/r/Python/comments/7kpme8/automate_the_boring_stuff_with_python_tinder/) \#2: [MS is considering official Python integration with Excel, and is asking for input](https://i.imgur.com/l2f9Zvb.jpg) | [419 comments](https://np.reddit.com/r/Python/comments/7jti46/ms_is_considering_official_python_integration/) \#3: [Python Cheet Sheet for begineers](https://i.redd.it/4iklecheyw601.jpg) | [129 comments](https://np.reddit.com/r/Python/comments/7mwgtw/python_cheet_sheet_for_begineers/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/7o7jnj/blacklist/)
Senior PHP devs make more than that in my city.
I have experience with high-traffic sites in PHP. And sites that have made quite a bit of money written in it. Just like any language, there are good and bad examples. I'm currently involved in a PHP project that is using CQRS and micro-services. It really depends on what you're doing and how.
Hate Magento so much. Nice folks to work with but good hell it is back asswards 
&gt;PHP has gone through so many iterations and here we are at 7.2, there are namespaces, traits, classes, composer, big frameworks, companies backing it etc. I mean any language that really competes with PHP has equivalent features, and in fact usually had them earlier and/or have other things over PHP. In my experience having met and talked with a lot of devs from various backgrounds: a lot of the people that hate PHP will just interpret that sort of argument as meaning you don't know that many, if any, other languages. &gt;Security issue? Security is never an issue for us. It's the developer who never treat data input carefully enough to prevent it. The 'only a bad craftsman blames his tools' idea is also not convincing to anybody that actually doesn't like PHP: the PHP hammer counterargument is something of a joke in some programmer communities - I can even find you a guy that *likes* PHP who owns an actual 'PHP hammer'. 
&gt;In a lot of places they've resorted to using varto make the code more readable and terse, which takes all the arguments about type safety being a major advantage of C#, lights them on fire, and chucks them out the window. I'm not sure you understand the purpose of type inference. `auto` in C++, `var` in C#, just omitting a type entirely in Rust - in all these languages the purpose of this is to ask the compiler to figure out what the type must be from how it's used and compile exactly the same as if that type were specified explicitly in the definition of the variable. If there's any ambiguity about what type something might be, it's a compiler error because it can't make a verifiable correct choice about what type it is.
Would you call someone a bad chef if they complained about being asked to work with [this](http://i.imgur.com/z2ECD7S.jpg)? A bad carpenter if they didn't want to use a saw with no guards? Tools definitely can be better or worse than others in specific cases, or just in general. Arguing the merit of specific tools is something not only accepted but arguably encouraged in many cases.
I love Node for a web backend. More than PHP for anything that I would want websockets for, but I still use SQL for the databases. I think of Node for online games, high amount of small bits of data sent, or just needing a constant connection to a server. PHP for things that need to run and then end synchronously. Sometimes that is all you need, and it is a heck of lot easier to structure a multi site setup with PHP. 
&gt; It's annoying You may feel this way.
Honestly I wouldn’t even know what to do with that many users. Throwing hardware at it only gets you so far.
Well it's correct that PHP is probably the most hated language. It's extremely abstracted and teaches bad programming habits, not to mention its performance overhead and awful syntax. It requires a lot of memorization or looking up documentation because of the ridiculous number of built in functions that you are *required* to use. And things like associative arrays make it seemingly attractive, but in reality just cause confusion for most developers. There is far too much abstraction of lower level code, and very little control. It's just not a good language.
Well... it's fair to ask. It's easy to find warts all over. Differing parameter order for needle/haystack sorts of things. I don't really care about those but it seems to really bother some people. I care about deeper, more integrated flaws. In no particular order here are some more consequential flaws that will be difficult to fix but I hope possible in many cases: - We segregate symbols by type, both inside of classes and without. This caused our language to grow unevenly and without cohesion and has a lot of impact: - We had to have unique syntax instead of unified syntax for each symbol table. One such example is `$this-&gt;method()` vs `($this-&gt;property)()`. - We have class autoloading but not function or constant overloading. - For a while we had `use NamespaceName\SubNamespace` or `use NamespaceName\ClassName` but no equivalents for constants or functions. - Sometimes the symbols have different error mechanisms, such as classes in a namespace erroring if they can't be found but functions and constants falling back to the root namespace. - We can't use function names as callbacks without reaching for strings, and methods require a weird array construct. - Differing case sensitivity between constants, variables, functions, and classes. - Call-by-reference has no indication at the call-site. This is fine in compiled languages which see the declarations before a function is used, but in PHP we cannot know if the parameters we pass will be altered or not: function f(callable $g) { $a = 42; $g($a); // will $a be modified? } This makes reasoning about code more difficult and makes peephole analysis and optimization more difficult as a consequence. - Arrays as our only core data structure. At first this makes things convenient but eventually it becomes frustrating. Should `$array1 + $array2` work as a dictionary or a vector? This duality applies to nearly every array operator and function. - When you start building your own types you lose a lot of support from the standard library; can't do `map`, `filter`, `reduce`, etc on custom collection types out-of-the-box. Arrays have their own world with lots of functions and support and when you start doing your own thing with objects you lose a lot of value of the standard library. - Variable scoping and closures. I don't have time to properly complain about this right now but we have to close over variables by value or by reference. I think better options would have been to close over variable itself or the scope it is in. This is closely tied to how the engine works which also makes reference unsavory in general. - We have bits and pieces to enable functional programming but when widely applied it often becomes worse than using the imperative counterparts. Don't have time right now to give specific examples but try doing an `array_filter` into `array_map` into `array_reduce` compared to just doing everything in a loop. - The fact that we have so many errors and warnings in our language and core library that we have an operator dedicated to silencing them is... enlightening, at the very least. - Our userland functions and internal functions have a number of observable differences. Two fairly common and consequential examples: - Internal functions will return null and continue on type mismatch (after notifying the error handler, of course) whereas userland functions throw. - Passing too many parameters to an internal function will immediately return null with a warning. In userland functions there is no warning and the extra parameters are simply ignored. I think that's enough for now.
There is a reason that person is teaching at a fake school rather than working in industry 
This. Learn this skills. Forget the religion.
You are comparing a simple (and broken) tool with a programming language. That's why I don't discuss anymore. Are you really a programmer/developer? For how long? 
Universities employ people that don't have to be correct in order to stay employed. Don't be surprised when you find idiots in environments like that.
Look. PHP was born in a time when the internet was something people were still trying to find “best practices” for how to use. Shit needed to get done and people rose to the occassion and built a thing to facilitate. Since then there’s been many other languages, frameworks and even adoption of programming paradigms that have refined and simplified life for developers. The way that professor demeaned an entire ecosystem is a reflection on that professor and their taking-for-granted all the pain that got us to this point where we have the freedom to choose any number of languages or frameworks that suite our fancy, PHP among them. Don’t take it personally, instead recognize how confidently that person can deride years of innovation and learn why they feel so confident doing so - if there’s something there, learn from it; if not, then you will be safe in the knowledge that you’ve explored their own point of view and will have developed your own. There are an indeterminate number of ways any one problem can be solved - you are already comfortable solving them in one fashion, be proud of that.
&gt; I have never seen it require so much code to do something as simple as translate an HTTP request to a JSON response. Using [JsonResult](https://msdn.microsoft.com/en-us/library/system.web.mvc.jsonresult.aspx) is too much code?
Since when was a university a "fake school", as for the industry nonsense, I hate to break it to you, but industry is no different from anything else, there are plenty of inept people there as well.
He said in his post &gt; Sadly in my country people tend to go to university only to actually get a degree, because it's highly unlikely the lecturer will teach you something practical. 
That doesn't make it a fake school, merely that maybe he should of looked to a more a vocational type course than a degree at a university.
It’s not just people from US who participate in that survey. I’m pretty sure that in less developed countries PHP is more popular because LAMP stack is much cheaper than Windows Server etc. And salaries in those countries are lower. And there are “PHP developers” who install Joomla on shared hosting. Where I live market is pretty crazy. Salary for Senior PHP Developer role in one company maybe even more than 100% higher than in the other. Because a lot of software houses just do the same kind of low scale projects one by one. There are seniors devs with 7+ years of experience who just changed framework from CakePHP to Laravel now stopped deploying over ftp. We are interviewing people with almost 10 years of experience working currently as senior devs that don’t know what OWASP is. I work with people who are recommended by recruiters as “strong mid, possibly senior” that don’t know how xdebug works. ¯\_(ツ)_/¯ 
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
Well I heard one of the profs hates sublime text ... and does not have anything against visual studio code or atom. Also there is a tendency to have strong opinions about something. Really hard to fight and this is an example of that.
&gt; I was wondering if PHP might be a great choice for me in 2018. You are in r/PHP. That's actually not the best place to get an unbiased answer.
Well to be fair OP also said that PHP itself is among the worst popular programming languages, irrespective of code quality. Which I completely agree with. Parent posted some examples.
Granted, but lets not pretend C# and Java are any better.
You will meet this opinion tens of times in your life (and it is true opinion, PHP is not the best language but none is). Leave it. They are academical, probably with poor salary. Think that with PHP you will be earning much more than they are now with their C or Java. Don't use this as an argument when discussing with them, don't be asshole. Just keep it in mind. Bitching about PHP is probably the best part of their professional life, don't ruin it to them
If you can get good, steady work as a PHP dev then good for you. But, rather than take this subject up in a PHP forum, you should email these lecturers and ask them for why they said this. Get their reasons for saying this about PHP and get their recommendations for other languages. It's a fact of life that you will want to look at other languages at some stage. Bringing this up in a PHP forum seems like you're just after confirmation of your own beliefs. As I said, if you can get good and stable work with PHP then good for you. But don't make the mistake of thinking you don't need to look at learning a different language.
Academics like languages that stems from theoretical constructs, rather than from practical concerns. A guy I worked with actually had a teacher tell him that "Prolog is the best tool to make database frontends"... I've found that the best teachers when I went to university were those who came from the industry, not from the academic world. They had a better grasp of real world considerations.
That's without taxes though. 
&gt;In a lot of places they've resorted to using `var`to make the code more readable and terse, which takes all the arguments about type safety being a major advantage of C#, lights them on fire, and chucks them out the window. You misunderstand what `var` does in C#. It's a type inference feature that allows your code to be less unnecessarily verbose while keeping all the advantages of type safety. `dynamic` is what you would do if you actually wanted to bypass static type checking. 
We discussed the actual php matter here. But what about the actual person? In my opinion you have 2 types of teachers generally. The ones who are highly motivated and the ones who ended their career and want to still make money of it without to much hassle. Sounds like your guy is the latest. 
Oh, academics. As they say, “He who can, does. He who cannot, teaches.” What they teach on computer science courses often has very little to do with the real world field of software development. Assignments are necessarily simple programs that just need to check the right boxes, usually solving a simple problem. There’s a whole class of real-world problems you almost never experience in such a setting. Like needing to build big and complex systems, building things in an extensible fashion, struggling to find and hire people with the right skills, multi-year maintenance and change management, etc. For simple, isolated programming assignment, they are kinda right. PHP is not a great language choice. Considering the language alone, there are better choices for almost any kind of program. Where PHP shines is when you want to build something for the web, using some of the great frameworks out there (Symfony, Drupal, Laravel, etc.), and you want to be able to hire people with at least some of the basic skills. So PHP sits right in the academic blind spot. Because it is “shit” for their use case, they assume it is “shit” for everything.
Yeah, if you do webdev you basically sign up for this, I've heard criticizing of PHP, asp, asp.net , JavaScript even css... For some people a programming language is like a sports team. Php is basically the black sheep of the programming world, every you go people will bash it, and yet we are here
Also, if you work with PHP for 6 years it wouldnt hurt to get some experience in another language
Shit or not I still get paid to write and maintain it. 
Още по-зле - в ПУ :) Иначе записах само за дипломата, тъй като бакалавъра ми е нищо общо с тая сфера, а има работодатели, които все още сметат дипломата за плюс.
A scholar will appreciate a language based on a single programming paradigm or a cohesive combination of features. PHP isn't that. Java and C# did spend a lot of effort in the design phase of the language. PHP7 doesn't improve this aspect, so I don't think it's a matter of them not being up-to-date.
&gt; I'm really fed up with all the constant bashing on PHP and I have no idea how we can change that. Lets be real, PHP has always been *extremely* tied to web processes. It has never done well as an all-purpose language... people don't write daemons/services or GUI applications with it... even *javascript* has that now and javascript is *way* worse overall as a language! I think that's why PHP still gets so much shit. 
Oh man, can you imagine what the state of PHP would be without all Facebook's modifications being pushed upstream? 
&gt; Throwing hardware at it only gets you so far. For the language it's easy... just use expensive-ass load balancers and scale horizontally... the harder part is making sure your backend storage scales too and is redundant and doesn't serve up older cached data. 
&gt; expensive ass-load balancers *** ^(Bleep-bloop, I'm a bot. This comment was inspired by )^[xkcd#37](https://xkcd.com/37)
That's a terrible outlook on things. I use knowledge from college all the time... not in simple "how to do a for loop properly" ways, but in overall architecture design ways which is far more important. 
lol... called out by a bot, what a time to be alive. 
Usually people who teach, dont like PHP because it has no design, and lots of warts. Its very unpredictable too. You easily find why such a large % of developers hate PHP simply by doing a google search. PHP today is most popular in the web, becuase of wordpress, and the other cms`s. Not so much in applications, most people seem to choose a saner language for that purpose. You rarely find PHP outside websites, there is literally no development going on afaik.
I feel like its less about PHP and more about the inescapable fact that some people are foolhardy and dogmatic in their thinking
So you want to discredit WP devs, then still use their metric as PHP popularity. Remove &lt;shitty php cms&gt; and PHP usage on the web is close to none.
FB does not use PHP in a traditional sense. Looking back PHP was a big mistake for them, they have literally spent millions of dollars trying to fix their stack. They even ended up building their own inhouse language, hell they even call it Hack.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [The mean teacher](https://www.reddit.com/r/lolphp/comments/83mpw3/the_mean_teacher/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Lol, no. I bet if you removed WordPress, PHP would still be the most popular web language.
Wp, Drupal and Joomla (and the rest smaller ones) alone is probably 90% of total PHP usage on the web. With the same logic i could say JavaScript is used in 99.99% of all websites. PHP has use in websites, and thats were it shines. Just copypaste some code and ftp it to some shared host.
But most of those websites are WordPress, which is a security nightmare. So yeah that's where they're coming from.
And then there's the myriad of web frameworks and e-commerce platforms.
[Symfony removed support for HHVM last year](https://symfony.com/blog/symfony-4-end-of-hhvm-support) so I'm guessing it'd be just fine. 
Sure there is. Now you enter the realm were PHP is less used, people are not starting new projects with PHP today in the same rate as back in 2002. The requirements changed, the web evolved but PHP stagnated and never fixed its bugs and still has the same crappy stdlib without any improvements. There is so many better options today there is no benefit of choosing PHP. Sure for a mostly static website with some forms PHP still does a good job. But for a complex business logic heavy application, PHP is a dead end.
Look, please keep using PHP as much as you like. What i want from my tools are consistency, performance, robustness and a good feature set. Thats also what paying customers deserve. I should be able to trust the tools im using, and not have to deal with errors directly related to PHP, just last month there was a bug one of our legacy systems (still using PHP), where two dates were compared, and because of the timezone PHP calculated the wrong year as a response. Imagine! Two dates were off by one year! The diff was actually 17 days. I also remember this one other time someone had used the PHP ”immutable datetime” class, and god that was terrible! Turns out PHP had a bug that allowed immutable dates to be mutable and could be modified inplace. The horrors are countless. Call me inexperienced if you want, but after we started porting away from PHP all these weird edge case bugs have dissapeard. A strang side effect? Or PHP?
Sounds anecdotal to me.
BURN!
Never heard of CS program at a reputable university here in the states that teaches courses in anything other than Java, C, C++, or Python.
If you think PHP 7 was an upgrade and is amazing you should really look around development happening in other languages. There is so much cool stuff beeing written and awesome reasearch going on in other fields and languages. Youll be amazed.
If you have that much experience, you should easily get a job in a company with a more sane stack.
Thats a good comment, and is my opinion too. Its just so hard to explain this to PHP users who defend it till the end. The same goes for many other languages too.
FB does not use PHP. They have inhouse custom language, Hack. Last i heard its mission was not to maintain 100% PHP compability.
a not very popular university (Harvard), but still in the US https://www.youtube.com/watch?v=gwUEjgbs02w
Everytime someone makes this argument its about money? Like wtf? How about other aspects to work, like really enjoying it? How about building some really cool stuff (not that new clients lame website for the 100th time) like deep learning? How about some IOT devices? How about some real time apps? How about a custom GUI for a soundboard? How about mobile apps? The list goes on.. There so much you can do, but none of this is possible (realistically) with PHP. And yeah, as you like money, how about getting 50-100% better paid.
PHP is totally wrong language for academia. PHP untill few years back lacked AST. So no researcher could meaningfully contribute to PHP while still getting some material for academic papers. PHP has awful stdlib, so it's not good fit for internal tools. PHP also was focused on web dev while alternatives would fulfill any other area some researcher may pursue. Finally PHP mental model is nothing special. Nothing to extend out research. Java, Python, JS, C, Haskell, Lisp/Schema... They score favourably in at least some of those metrics. As for work outside Academia. PHP == web dev. Even there there are better paid options. So as usual, take multiple factors into account.
Nope, php is server side so users can't change session variables unless they manipulate input you're using to get those session variable values 
thank you muchly!
Sessions are how it's done. Look at the session cookie and read how it works. It's just an id, the data in the session is stored server side.
If it's any consolation, I'd take PHP over JS any day of the fucking week. 
Harvard Extension School to be exact. Wasn't able to verify if it even applies toward a CS degree, but didn't look too hard. 
Hello, Could you very briefly elaborate on why php is one of the worst popular languages?
&gt;I've been a PHP dev for around 6 years now, some of which I've spend time developing in Python, but it's just now that I've had the time to start a masters degree. Sadly in my country people tend to go to university only to actually get a degree, because it's highly unlikely the lecturer will teach you something practical. Sounds like you're in the US maybe? but if not should this be surprising? University's aren't necessarily doing a great job educating people especially in Computer Science and from my experience at school they didn't care to give a shit about "Web technologies" and would be surprised to see that they do now. Most Colleges introduct you to C/C++/Java and maybe if you're lucky Python at least but still they're all in relation to basic desktop applications to build up the concepts and theory of programming which I would say can be done in any language really if you wanted to and PHP would probably be a very easy way you would think given it's history and comparison to other pre-internet languages they like to use C/C++ and hell even Java. If you look at what has been built on PHP there are plenty of big successful projects and companies still utilizing it, just because it's always been the "gateway" language to the internet doesn't mean it's just old, outdated and buggy. I mean if you want to be realistic ther are plenty of bugs in all languages, some are by design and improved on and some are just bad developers that don't know the right way or possibly were educated in the wrong way and only taught to think in one way thanks to their University! TL;DR Unless you actually find that your educators know what they are talking about and can translate that knowledge into a realistic job setting then take what you get out of your University with a grain of salt, remember sadly it's just to get a piece of paper saying you "Did" something, not "Did you actually learn and did I gain anything out that $20K,50K,100K I spent..."
Well you can have client side sessions with encrypted cookie content but server side is how it's usually done.
Client can’t really get at those, except, maybe if you have register globals turned on or something silly like that. 
That stawman arguement doesn't work in a thread on a PHP sub where you can see PHP Devs discussing it's pros and cons btw. But go one believing it brings no value, it makes no difference to your life. 
If your site uses HTTPS (and it should), be sure to use [session_set_cookie_params](https://secure.php.net/manual/en/function.session-set-cookie-params.php) with the "secure" flag to true. This ensures your session cookie won't be sent from the browser to your host over plaintext HTTP and helps prevent session hijacking a'la Firesheep. While you're there, you should also use the httponly=true flag, which prevents your session cookie from being seen by any javascript on your page, again a security measure to reduce the exposure of the session ID without much/any downside.
Got any suggestions? I've been buried in 70 hour work weeks the past year or so that I haven't really had time to smell the flowers
Don't even need two variables. Just a user_id and if not set = user not logged in. 
Well, I've been playing with Django, Go and Node.js a bit on my wee vps. But like Carl Brutananadilewski, I work outta the home, so I'm more of a consultant and I'm using jobs availability as an index of how much freelance PHP work is out there.
FYI, register globals was deprecated in 5.4
Right, and most people get Auth out of the box with the framework of their choice. Not sure what this guy’s working with if he’s rolling his own. 
Right, and most people get Auth out of the box with the framework of their choice. Not sure what this guy’s working with if he’s rolling his own. 
You know, in certain parts of the world, finding a web dev job that's not in frontend and not PHP is limiting your choice of place to work to single digits. And remote, a lot of the time, is not really a great option too. With PHP there is a huge market and a huge demand. And there is a certain top level slice of PHP dev that requires you to know everything a Ruby or Python dev needs to know about software development. Hell, most of the time the problems you solve are not related to a language at all. And then there is performance - 7.x versions of PHP are faster than Python and Ruby, and that's without doing any out of the way optimizations like Python's PyPy or using alternative Ruby interpreters. And then there is PHP-PM process manager that speeds things a lot and still maintaining the ease of use that other languages don't have. And then there are frameworks and/or systems that actual clients use, and honestly, the amount of software on PHP is just staggering outweighs other languages in web dev scene. There is also lately quite a lot of high-quality products coming out in PHP scene. Is it flawed as a language - yes. But JavaScript is even worse, but without it you cannot do anything in the frontend. Every language has its flaws.
I tend to think of PHP as everyday tools. It has nothing remarkable about it (although there are some interesting things coming into it recently), but it does most of the jobs just fine and it is more or less depends on the skill of the user.
It pays me just fine, even better than most of my peers. But I also spent 12 years not just knowing PHP in depth, but also how to design applications and general software building concepts, understand servers and how the cycle works, that a lot of the time trouble is with the database and that there are right tools for the job. There are queue servers, Redis can do remarkable things if you use it to it's full potential and knowing the ecosystem in general and keeping tabs on developments, tools and always dedicate time to learning stuff. A lot of people just don't do that, regardless of the language. And so they are not paid that top dollar.
Whatever they have used in the start, would end up in the same bucket as PHP did. Facebook is on that rare scale, where all the tools we are used to would just fail in the end and they will have to roll their own solution anyway. Google also has designed a language or two. Apple, although a bit different, also has designed 2 languages (Objective-C and Swift). Most big companies essentially design their languages, frameworks and other solutions that work for their specific business usage.
If you're using sessions ever, for anything, you're doing it wrong.
Why whould ”any language used in the start” end up in the same bucket? Google building languages is understandable, they are on a few magnitudes larger than facebook. They actually have a use case. Same goes for apple, with ios/osx. Its not like all big companies build their language. Why should they? FB built it because they __had__ to build it. Its not all about speed either, youtube runs on Python, that is not a fast language like C. Still you dont see youtube writing their own ”hacklang” they seem to do jusy fine with puthon/c stack. 
Not everything can be, or should be, solved with frameworks.
Let me guess, your IDE of choice is also Vim?
Sublime text 3 actually.
Pornhub is based symfony no?
I don't understand why PHP couldn't handle machine learning aside from performance, which would exclude every interpreted language.
I generally hear stylistic complaints about PHP - things that generally don't affect you at all unless you chose to use those features (like the comment about weirdly specific functions). Some languages have actual practical differences like Go having better threading support or node's ability to support many concurrent operations or C++ being a compiled language with better performance potential. If a good developer decides to write clean code, would it look better in [newest fad language] than PHP? I don't think so. Every language provides the tools to write good elegant code. There are only very rare cases where the language you pick would make a difference.
The [PHP Weekly](http://phpweekly.com) newsletter does a great job with curating new PHP content. Check out their [archive](http://phpweekly.com/archive.html) to see past issues.
I love when people make incredibly final comments like this. There has to be a sub dedicated to this king of ignorant shit. 
I could make a whole blog post on the topic and then maybe you'd come around, but why waste so much time on a bunch of thankless fucks. Keep using your sessions, see if I care.
Blogs in general aren't worth reading. They're finally cancer. Clickbait nonsense. There are occasionally informative articles posted, but you can find them by searching for whatever it is you might need.
What are the alternatives?
Успех! Гледай да губиш възможно най-малко време с него. Никой не му пука дали имаш 3 или 6. А за PHP-то, ги остави лекторите да си живеят в заблудения им собствен свят, добре им е там. Има достатъчно работодатели, които си плащат добри кинти за PHP инженери. И ще има още повече. Мисля, че ако не беше PHP, друг език щеше да получи същия хейт/отношение.
Thanks for this, it looks like a "mine of articles", definitely worth subscribing. 
I prefer developing directly in ones and zeros. Kinda relaxing.
Here comes one of them, now.
So, not an IDE.
Asp.net and java are used for a lot of websites. In my country those and php are the most used languages.
My lecturerer did almost the same, many jokes about how terrible PHP is but in the end he taught us how to use it properly and I will always remember PHP fondly ❤️
No one’s claiming that it is a lack of raw intelligence that’s the problem. It’s not that CS college professors are unable to acquire the skills and experience it takes to be a good software engineer. It’s more that they have no incentive to, and therefore generally don’t. They are like physicists are to structural engineers. Both are important fields, both you don’t want your average physicist building your bridge anymore than you want the average CS professor making decisions for your large software project.
Doesn't exclude Python. Basically: bindings and a [pre-existing community](https://www.amazon.co.uk/s/ref=nb_sb_ss_c_2_17?url=search-alias%3Dstripbooks&amp;field-keywords=machine+learning+python&amp;sprefix=machine+learning+%2Caps%2C285&amp;crid=2OHD3OYTJJQVY).
Well, he's just a troll. I've probably been to some of those subs before.
You should've said you're in Bulgaria. As a fellow Bulgarian to another, honestly our high education, especially for comp sci, sucks. So I wouldn't put much weight to what opinions your lecturers hold. 
What features or changes are you all looking forward to most in future updates of PHP? Even if they have never been announced or discussed, what changes do you think would benefit the language the most? 
I have a question about classes...right now I have just a large functions.php file that I include in basically every php file so I can call to those functions.. I'm wondering would it be better if I go through that functions file and group similar functions into a bunch of classes in their own files? I haven't done any work with classes.. And I'm still trying to wrap my head around functions vs classes. Like should every function be contained in a class no matter how small or big that function might be? I've only been working in php for a couple of years so I still feel fairly new to the language and come from 10+ years in cobol. 
6 figures here in North Texas. 
It’s just where, who and when you should use PHP. Not why your lecturers are against it and use them in the wrong use case.
Your pretty much on the right track, not every function needs to belong to a class but sooner or later a function will find a friend or need to be broken up into multiple functions to allow it to be extended. It is very easy to get too carried away and end up with deeply nested classes on projects that dont need it. If your functions.php file is not a hindrance, keep it. as parts of combined code start to get convoluted consider breaking it out into its own class. 
Generics
Yes. And then graduate to using an autoloader and forget about including all of those class files :)
I'm not exactly an expert, but I'll give it a go. If you're thinking only in terms of function wrappers, you may have not quite grasped the fundamental ideas of classes yet. It's best, in my likely flawed opinion, to consider a class as an entity. It can have methods/functions, data, containers. It fills some logical niche in your application. As an example, you might have a class called employee. Each employee will have a name, badge number, email, whatever. You'll then want methods for getting and setting those pieces of data. Then you might have another class called hr_manager that, amongst other things, manipulates employee objects. There might be yet another class just for generating reports that is used by the hr_manager. And so on. In case you aren't familiar, and object would an instance of a class. The item from the blueprint, as it were. Ultimately the strength comes from having highly contextualized data and functions. Some things might be a lot more abstract, and similar to being just classes that are function collections, like a database manager class, or what have you. I don't see much benefit to wrapping single functions in a class. I'm sure that if I'm wrong about any/all of that someone will correct me, but it's my current perspective.
Having a `functions.php` file and including it manually is very old school for PHP. You could group them into utility classes, but that's not what classes are for. I don't know anything about COBOL, but it sounds to me like you need to read up on object-oriented programming (OOP) in general, otherwise you can safely ignore classes. Modern PHP is very much about OOP and *autoloading* classes (rather than including by hand), so unless you're just writing loose scripts you most likely want to learn it. There's a lot of good information on [phptherightway.com](http://www.phptherightway.com) if you really want to get deeper into PHP.
Multidimensional arrays are a nightmare in php from the memory point of view... But very easy to use.
Main one is that it's not meant to use a video card, second is the way it does math. Those make it much slower ( had 16 servers dual cpu x5670 do in a week what 3 year old video card did in 4h...)
Arrow functions have been proposed. Looking forward to those.
Developers who frequent WordPress: what is your opinion regarding it as a developer? How do you go about solving your day to day problems? Do you hack away at the code or do you make plugins? Thankful for any insight.
Hating on PHP and then recommending Java, pfff... PHP used to be shit, 5.6 was kinda OK, and now it has become a decent language.
For building themes I use the Advanced Custom Fields plugin. I try to avoid most plugins out there. Just don't trust them.
A VP who has outdated knowledge on PHP wants our team to switch from PHP to .Net. We have hundreds of sites currently in PHP and our team is very reluctant on the switch. Anyhow, are there anything that we can do in PHP that we can't do in .Net? Is .Net a purely compiled code? Or can we keep using include files and embedded scripts like we do in PHP if we switch to .aspx files?
.Net? Why?
Lol, if you have to use an IDE for php, then you've got bigger problems than only knowing how to code with framworks, son.
It's more about the underlying thought about how ideology can make people convinced of one point of view, dismissing others - even though those other opinions are also valuable. I think that the example of type system vs unit tests is the perfect example, as that exact discussion happens a lot within the PHP community.
Those who can do, those who can't teach. Just ignore him while agreeing to his face. Hey good grades then do whatever you want afterwards.
The irony of him picking to talk about unit tests and type systems is that the more accurate terms for what's happening in our heads is that we use examples to build mental categories. The joke being unit tests are examples, and type systems are categories. Anyway, that aside, yes, people subdivide patterns into categories and they hold categories are absolute (although they never are in practice). Thing is without categories you wouldn't be able to put your pants in the morning, we need them in order to organize and classify the world into simpler ideas we can work with in our mind. And the bigger question is, OK, now you know people hold certain ideas as absolute when they're not. But what would you do about it? Start explaining to the person you argue with how their brain works? That's a battle you'll lose almost every time. The real lesson is when you see a stupid argument (such as unit tests vs. types), just nope the fuck out of there and save yourself the effort and time, and invest them in something better.
He's absolutely nuts to ask for such a big migration. Tell him the language doesn't matter that much, but the quality of the code does. If he still wants to continue this, find another job. It's not worth the stress this will cause.
I only use WordPress for clients that want to manage the site themselves in the future. The biggest problem with WordPress is being limited by the GUI/control panel. Learn the php/sql/js behind it and you can create what you truly want instead of what WordPress will let you do.
TL;DR in 1998 we had plain HTML rendered server side and sent to the client in 2008 we got a lot of client-side rendering making a web-server to be simply a REST service sending only data. in 2018 to reduce a lot of client-side rendering we have to render HTML server side and sent to the client 
Meh. Overall engaging, but much longer than it needed to be.
Amen
+1
Really dislike the idea of running V8 in a PHP env. 
Just curious, why? 
How would you deploy a php site on a LAN windows server? Would you guys use IIS? XAMPP / WAMPP?
I dunno, was it any bigger a mistake than, say, Twitter being written in Ruby? ie that most tools just didn't scale to those levels.
It feels like running a headless browser to render the components to HTML.
You should create a website and add a documentation. I like this app starter.
Let's not forget about latest Debian 9.4 "Stretch" release - https://www.debian.org/News/2018/20180310 . It comes with support for PHP7 also (But 7.0.14, not 7.1 and 7.2).
There's enough time to update to 7.1 or 7.2 before December. That's why Debian 9 is also a good solution at this moment.
Yes it is
This is Amazing Video Course That Shows You How To Make Native Mobile Apps In Minutes Without Coding Even If You Have Not Touched A Computer Before. You Can Make Such On All Platforms; Android (Phones And Tablets), IOS (Iphone And Ipad), Windows And Kindles Stores. MOBILE APPS DEVELOPMENT IS CURRENTLY THE BEST JOB IN AMERICA (CNN) A GREAT OPPORTUNITY I was a reading a piece on “THE BEST 100 JOBS IN AMERICA IN 2017” yesterday on CNN website, and guess what? Number One (#1) was MOBILE APPS DEVELOPMENT. You can search this info on Google So, you can see that mobile apps development is still an emerging business with huge and limitless opportunities Over 40 billion mobile apps were downloaded in 2016 and it's project to be over 100 billion downloads this year. So, are you ready to profit from this money? SOME FACTS YOU SHOULD KNOW FACT 1: Successful businesses are utilizing app PUSH NOTIFICATIONS to massively increase engagement and conversions FACT 2: Text alerts are gradually fading in water. Users actually like and respond to PUSH notifications. Users response to PUSH NOTIFICATIONS IS OVER 95% FACT 3: China’s Single Day on Nov 11 2015, was the single largest online retail day in history. Alibaba alone saw sales of over $14.3 billion that day. This is 5 times the amount of money made during cyber Monday in the U.S FACT 4: And just like the giants of alibaba, Small Businesses And Marketers Are Experiencing The Exact Same Trend A Recent Survey in the United States shows that over 80% business owners want a mobile app for their businesses, but they are scared of going for it because they are under the impression that it's only affordable by big companies with big budgets And they are correct, because, before now, hiring an app development team is very expensive, time consuming and complicated. It can cost up to $5k - $50k, and take anything between weeks, months and even years to correctly build an app. The majority of entrepreneurs are already very busy running their businesses and do not want or need additional stress from the complex, time-restricting process of building complicated apps. But Businesses have no option because Mobile Phone usage keeps rising. NOW, LOOK AT THIS THIS MEANS SMARTPHONE APPS HAVE BECOME A KEY MARKETING TOOL FOR COMPANIES OF ALL SIZES, INCLUDING SMALL BUSINESSES. AND WITHOUT AN APP OF THEIR OWN, BUSINESSES GET LEFT BEHIND – AND SWALLOWED UP BY THE COMPETITION. AND NO BUSINESS WANTS THAT! IT’S AN UNDISPUTED FACT THAT MOBILE APPS INCREASE ENGAGEMENT WITH CUSTOMERS. THEY BOOST REPEAT VISITS, AND PERMIT A WIDE VARIETY OF ONLINE TRANSACTIONS… BUSINESS BENEFIT MASSIVELY FROM THE THE DEPLOYMENT OF DISCOUNTS, LOYALTY CARDS, PUSH PROMOTIONS, ECOMMERCE TRANSACTIONS AND MORE. APPS BREED LOYALTY AND INCREASE CONVERSIONS. APPS ENABLE DIRECT, FAST CONTACT WITH CUSTOMERS AND THIS IS REWARDED BY SPEEDY RESPONSES FROM BUYERS. APPS HELP CREATE BRAND IDENTITY. SMARTPHONE ICONS HELP BUILD BRANDS BY PROVIDING A VISUAL DESIGN THAT CUSTOMERS RECOGNIZE. BUSINESS KNOW THIS. THAT’S WHY MOBILE APPS ARE IN SERIOUSLY HIGH DEMAND. BUSINESSES NEED THEM. THEY CAN’T AFFORD TO LET THEIR COMPETITORS GET ONE BEFORE THEM. AND ARE WILLING TO PAY ANYONE WHO CAN HELP THEM BUILD THEIR APPS FAST AND RELIABLY. AND THAT’S WHERE YOU COME IN. THIS COURSE EXPLICITLY EXPLAINS EVERYTHING YOU NEED TO SUCCEED IN THE MOBILE APPS MAKING BUSINESS. IT COVERS: 1.) You will learn how to make -Restaurant Apps -Real Estate Apps - Magazine Apps -E-Commerce Apps -Game Apps etc. 2.) You will also learn Special Marketing Secrets: GETTING CLIENTS You will be shown our special secret of getting clients around the world from the comfort of your home SPECIAL MESSAGE You will be given a special type of message that you can send to your prospects that will make them get back to you in a hurry PROPOSAL TEMPLATES You will be given proposal templates that you will just put your name and company name and send to your clients/prospects ACCESS OVER 150,000 PROSPECTS You will be shown how to get access to over 150,000 Restaurants worldwide ready to pay you PRICING SECRETS You will be shown a special pricing secret we use to get almost every prospect, such that no one tells us no SPECIAL SOFTWARE BONUS AT THE END OF THE CLASS, YOU WILL BE GIVEN OUR SPECIAL LEAD GENERATING SOFTWARE THAT YOU CAN USE TO GET LEADS OF PROSPECTS, BASED ON NICHE AND LOCATION AROUND THE WORLD. THIS SOFTWARE IS WORTH OVER 199 DOLLARS, YOU’RE GETTING IT FOR FREE. THIS IS EPIC. DIFFERENT WAYS OF MAKING MONEY FROM MOBILE APPS There are thousand and one ways of making money from mobile apps. Some are: -From Clients -From Google, via admob -From in-app purchases and downloads -From Apps Flipping etc. ALL THESE AND MANY MORE. PROCEED TO TAKING THIS COURSE AND UNLEASH YOUR UNLIMITED WORLD OF POSSIBILITIES WITH MOBILE APPS 
My next PHP chatbot? My first you mean! :) Not something I have need of yet, but maybe in a year or two. Thanks for the book. I've signed up and look forward to receiving more in due course.
Don't get me wrong, but I am not sure how this is related to PHP? I mean you showing of how some things on Magento works and the features may be very usefull for someone using Magento, but that is Magento related, not PHP. 
This is blog post spam by a bot.
Wordpress carries a huge market share and an old way of doing things. We use it only when it´s a client´s requirement (it´s quite often tho). If you really have to use it, try to learn the tools the main objects and its public API gives you to solve problems (WP Query, filters, actions, themes overrides) and try to avoid at all costs free or non official plugins. About solving day to day problems, we always try to figure out what´s the correct tool/method to solve the problem (*where* to solve the problem is important in Wordpress), and how to use the good actual PHP/general programming practices in the Wordpress context. It takes more time than simply hack some template or add snippets to functions.php, but in the mid term you will build a more solid way of work that avoids in a big part the common problem of a always updating platform.
&gt; Those who can do, those who can't teach. Not really, being a competent dev in industry does not require someone to be a genius, I am pretty sure if someone has the mental capabilities to get their PhD then they have the ability to "do" if they so wanted, and let's face it there are plenty of people who "do" are frankly terrible, especially when it comes to PHP.
Hehe you're right, "first" would be fit better many times :-) Thx a lot! Let me know if you need anything then.
I wonder though why we've got a plenty of mods yet this shit is all over the place. 
Thank you, this is the point I try to offer, to talk to them about business value, but the person on the other side still needs to know how to frame the conversation. Are we aiming toward business coaching, design, development, sales, a product or something else. I can say "I am from a web development agency, we can improve your XYZ" then "So let me know what problems you are having with costs there" but it tends to be one or two questions in, they ask, so where are we aiming at, whats your service. Saying "development" can put some managers off with not liking talking to computer people. So I need to find a line to tread before I can suggest a solution to their problem.
I've been using botman since v1 and I'm greatful for everything's that gone into it, but I'm skeptical what the courses can actually provide. Botman is fairly simple, the documentation is good, I can't see what the benefit is (I say this after seeing ALOT of marketing for this, otherwise I would have just moved on without a second thought)
Well, one way you can see the benefit of it is to sign up to the newsletter...
That's right 👍
Hey, with "courses" do you mean my book or the BotMan video course? Regarding my book, I can say, that knowing how to build a chatbot is just half the way. It is important to know why chatbots are such an important topic and how a chatbot could be useful to a service, company or person. This is a big part of my book as well as real chatbot examples and tutorials. I am also not only focusing on BotMan and show some basic PHP stuff as well. If you already got everything you need to rock your chatbots projects than that's nice. But in general there almost no good resources out there that cover the topic from thinking about a chatbot idea till finishing it; especially for the PHP world. That's why I am writing this book. Additionally, I still see a lot of people struggle with many BotMan scenarios. You can still help us in the BotMan Slack channel or forum :-)
crazy, isn't it? There are other things that seems contradictory in client side JS: 1998 - Mixing HTML, inline CSS and inline JS is super easy 2008 - Never mix your PHP with HTML, it's a mess, also use unobtrusive JavaScript and modular CSS 2018 - Mixing JavaScript with HTML and CSS is just fine, we call it JSX 
&gt; every day people write horribly insecure code in other languages This implies that it is equally easy to write insecure code in every language, which is not-even-close to true. Yeah - you can write insecure code in languages like Java, Rust, or Python, but you have to go out of your way to circumvent all the language features that try to prevent you from doing just that. Compare to languages like C, where the standard string handling library has buffer overflows built right into it. PHP is definitely closer to C in this regard.
meanwhile in my country everyone just know when you make a website you go php. they doesn't even know there is ruby/python.
Experian has a Java website. They didn't update a library with a crucial flaw that they had months of warnings about. Having one of the more secure technologies isn't going to matter if there's a glaring weakness in your overall execution (ie, like being cheap in paying your talent).
Good point, any site that takes off is going to get re-written whatever it's originally written in. Start with what you know.
16.04 nearly shipped with 5.6 instead of 7.0.
* strongly typed class properties: `public string $firstName;` * passing objects by value (and not by reference / symbol) by default * array/collection of strongly typed objects
LOL wtf, i should go back to PERL!
Ah, person who doesn't read whole post but still responds like an idiot in the php subreddit. classic
Not related to PHP, but why is shallow learning curve a good thing? It's a horrible thing. This is exactly what leads to eventually shitty devs. Then you end up with people on your team who take weeks to grasp even basics of Rust or Haskell. Learn the hard way, it's the only way to become a good programmer. 
Any functional language would like to have a word with you. 
That is a whole lot of work just to get a perceived (not real) increase in speed on the client side.
Because we have a sister department that develops most of the internal applications in .Net. They are more influential since they have the "real" programmers and they work very closely with management. Our department is in charge of external (public-facing) sites. And we work closely with end-users and webmasters who use our CMS. Oh and we're a "Microsoft shop". Anyhow, any thoughts on my original question?
Hehehe, hammer is a hammer, one hammer has a nice handle, costs the same, and another has shit handle - only you would pick shit hammer
Unfortunately, quitting is not a good option for me at the moment. The elders in our team told me that this fight has been going on for years. And it recently re-surfaced because I submitted a request to go to a PHP conference, which the VP had to approve. So we're trying to improve our code by learning more, but even that is being blocked.
Because programming is not an elitist sport. It's a tool for achieving things in the world, for disseminating ideas, and even for thinking. I want everybody to experience it, without the unnecessary hair shirt. Because if it provides business value, I don't care if it's made out of knitting needles and punch cards. Because technical debt is a lie. I met a woman once who started out as an architect, and was (by the time I met her) doing really interesting things with living wills. If her introduction had been spinning up a MEAN stack she'd probably be there still.
That was so gnomic I don't know what you mean. Something about monkey patching and side effects, I assume?
Yeah, still working on the reading comprehension, huh?
Ik work for a WordPress agency, meaning I only do WordPress sites. The best approach, I think, is to make a plugin out of the thing you are trying to build. Also, try to wrap WordPress functionality into your own classes. This way you dont have to work with the wonky WordPress codebase. When wrapping WP functionality its a lot easier to apply Design Patterns and create clean and SOLID code.
Yeah, I was explaining that to someone the other day. PHP doesn't hold your hand, so if you want to build something well, you have to do it yourself and not count on PHP to catch it for your or remind you of it. So yeah, this is how shitty PHP devs end up with something like "arr" inserted into a database column. It's also why good and experienced PHP programmers can make really good money fixing the broken crap from amateurs.
Maybe they like where they work, or there they're settled down and there aren't a whole lot of good options to switch to where they live. Shitting on someone for the language they use professionally is silly and ignores all the possible non-dogmatic reasons they use it.
PHP isn’t exactly in demand anymore. Unless you work for a wordpress scrub.
How is it a good entry-point when you can just use NodeJS? You don’t have to learn a new syntax. 
looks good, thanks
NodeJS has its uses, but it's not something I'd teach beginning developers. Also, why are you assuming that beginning developers already know JavaScript?
&gt; passing objects by value (and not by reference) by default No, thanks.
Data sources like the TIOBE Index and the Stack Overflow Developer Survey disagree with you. PHP remains in the top ten languages in terms of activity and job availability. Sources: * https://insights.stackoverflow.com/survey/2017 * https://www.tiobe.com/tiobe-index/
no
Define "good programmer."
It's the cornerstone to front end development, that's why.
The WordPress ecosystem, while large, is not the only significant PHP-based area of activity in the professional world. Ever heard of Laravel?
Let me rephrase, then. Why do you assume that beginning developers are already familiar with front-end development?
I suppose you don't HAVE to learn front end development if you're just going to be a back end dev. Most of the online courses on web development typically teach front end basics. Just the way it is. 
Why are you assuming that most developers come to the profession from online courses? What about traditional education and in-person bootcamps?
Dow Chemical developed their own process automation language to control their manufacturing operations called MOD5. Sometimes it just makes sense, but for a lot of companies it doesn't.
Enums. Not SplEnum, but actually implemented in core as its own keyword.
**Spotify Labs:** https://labs.spotify.com/ Excellent general technical articles. **Netflix Tech Blog:** https://medium.com/netflix-techblog Detailed write-ups of solving specific, hard problems. **Code as Craft:** https://codeascraft.com/ Etsy's technical blog. Some good data articles, among other things. The New Stack: https://thenewstack.io/ More of an aggregator than anything else, but the articles are usually interesting.
Invision Community? (formerly Invision Power Board)
https://slack.engineering/taking-php-seriously-cf7a60065329 this article is a goldmine &gt; Taking PHP Seriously &gt; PHP gets several things very deeply, and uniquely, right. &gt; I claim that PHP’s simpler “think; edit; reload the page” cycle makes developers more productive &gt; Having the option of gradually migrating a project to Hack, in case it grows larger than you first expected, is a unique advantage of the PHP ecosystem 
Check out the libraries section: [https://jwt.io/](https://jwt.io/)
Did. Have you used any of those? Would you use them again?
I did a code audit for [lcobucci/jwt](https://github.com/lcobucci/jwt) libraries in 2015: https://paragonie.com/audit/UGCwpFmaIkQ085l7 Their code has changed since then, and PHPECC has since fixed their side-channel vulnerabilities, but I still recommend only using HS256.
&gt; there is not a single serious company that would use that silly language https://stackshare.io/php/in-stacks#/
Honestly, no. I think JWT adds a lot of complexity to a project. Sessions solve most problems rather well.
And you shouldn’t, the rendering app should be a microservice and you should communicate via HTTP with it. Its way easier that way
I don’t think they are mutually exclusive. They can both be good entry points depending on your overall objective. A single syntax for both front- and backend dev is certainly a plus for learning JS. There are pros and cons to both, again, depending on your long term objective. 
It’s definitely an important part of most front end stacks, but you can also build a really beautiful, responsive, and performant front end with no JS at all. 
1. http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/ 2. http://cryto.net/%7Ejoepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/
Yes, but this is Magento.
This is from laravel 5.4 but the process is still the same (build code just moved out of the repo in later versions) https://github.com/laravel/framework/blob/5.4/build/illuminate-split-full.sh
Facebook's source is not publicly available
Splitting your project into multiple composer packages only makes sense if those components could be used separately. If they are either useless on their own or always need to be used together there is no point in splitting them up and you're only going to cause a massive headache
The great irony is that PHP is far more similar to Java than any other language I've seen: C(++), Go, Python, VBScript, JavaScript. Only C# seems similar, but my memories of that one are hazy.
IIRC, fabpot or somebody in the symfony team has a git repository of an app dedicated to splitting a repository.
That's a whole new level of stupid. You want server side randering ? Guess what's PHP do.
damn you beat me to posting that.
Everyone is an aspiring Jeff Bezos here, they have to think about the scale, see? Think of all the datacenters storing them sessions! Kidding aside, I'm sure none of the people downvoting you have anything even *close* to the architecture and scale that makes JWT a better option than sessions.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [psr7-sessions/storageless/.../**limitations.md** (master → fb06d6e)](https://github.com/psr7-sessions/storageless/blob/fb06d6ed1426f84299a538bc49c6af4756b2f205/docs/limitations.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dvliz7d.)
Even just using a setup with a single non-scaling Heroku dyno makes JWT more appealing than having to maintain a Redis instance.
TIL who Jeff Bezos is.
JWT is stateless: tokens are immutable and signed. You don't modify existing tokens, which is a big win when having to authenticate information that crosses multiple service layers, as you can be sure that the information wasn't modified, except for layers that have access to the signing key.
Or you can not use Redis.
You'd have to deploy a shared storage somewhere anyway, and that's the usual mess anyway. I prefer pushing the race conditions on the client, since I overwrite the session only for auth or auth refresh, and even simply have separate cookies for CSRF tokens.
&gt; You'd have to deploy a shared storage somewhere anyway, and that's the usual mess anyway. You don't have to deploy shared storage anywhere. 
Yes - a dyno is a volatile container that may be scrubbed at any time. Want a locally reproducible example of this? A simple `docker run some-nginx` with no volumes attached. No scaling, no webscale, no buzzwords bingo and no Bezos. Reducing I/O is almost always an advantage and reduces I/O related failures: in this case it comes with some compromises (described somewhere in this post), but the remaining I/O is on `/dev/urandom` (for the entropy) rather than on your session storage.
&gt; This has been discussed ad-nauseam. For the 80/20 scenario, JWT works just fine, and those articles just pushe the usual fud. Those are articles discussing the security flaws of JWT and offering other cookie based solutions. If your security strategy is "80/20 is good enough" then that's hilarious. You just let 20% of the attackers in, good enough!
&gt; You're out of your mind. No, I just simplified all my ops by paying 7 bucks a month instead of having to run behind upgrades of my environment, which just gets rebuilt when a new security advisory is out. &gt; JWT related failures Unknown to me. Didn't manage to get race conditions on auth or csrf, and trust me: I test my stuff accurately. Instead, I had loads of: * disk filling up quickly * network between php-fpm and storage failing (if shared storage) * session file collisions (yep, ext-session used to be much worse) * file locking issues * lost session data (concurrency again, server-side) * slow storage * unreliable storage * storage being wiped out by ops, leading to actual loss of money As I said (probably too mildly) above: I'm not banging rocks together over here. Solutions get built as exploratory first (I, @malukenho and @lcobucci went on and built the thing for fun first) and then they turn out to be a better fit for real-world scenarios that don't need to come from planet hackernews. 
None of the articles above describe actual security issues, just the fact that more stale state can be part of the network interaction. I'd rather share a specific JWT tokens passed through multiple layers than give read access to my storage to my entire infrastructure. &gt; Next time, read what you're replying to. I read those articles when they first came out and also had lengthy discussions with the author, which was pretty much closed for consideration of real use-cases and advantages. 
&gt; No, I just simplified all my ops ... And you keep talking how any move sideways from JWT would make your life hell. Some "simplification" that is. Give me a fucking break. Also you need to focus, nobody is arguing about what *you* personally do. I'm saying the vast majority of PHP apps have access to a local filesystem, a scale that fits in one server and a session isn't a problem in the least bit. That's a fact. And how you specifically choose to twist yourself into a pretzel over your specific project is none of my interest. &gt; disk filling up quickly Your disk... filled up quickly... due to fucking *session files*? That's it, I'm out of here. Was noice talking to you.
 &gt; And you keep talking how any move sideways from JWT would make your life hell. No, I'm just saying that I'm trying to improve things, but apparently understanding that `Request -&gt; PubKey -&gt; Response` is better than `Request -&gt; SessionStorage -&gt; IO Response` is hard for PHP devs. &gt; Your disk... filled up quickly... due to fucking session files? Yes - ever had a spike of users? Or a bug in session management? Or do you always work with trivial scenarios? Shit happens: reducing how much it happens is a big win.
&gt; None of the articles above describe actual security issues The article literally spells out "security issues" in its content before it starts listing security issues. I told you to read before you knee-jerk, you knee-jerked again and didn't read. Something's wrong with you. 
Regrettably, banks aren't exactly the paragons of security engineering.
&gt; No, I'm just saying that I'm trying to improve things, but apparently understanding that Request -&gt; PubKey -&gt; Response is better than Request -&gt; SessionStorage -&gt; IO Response is hard for PHP devs. Sessions are the only source of IO, is this the bullshit you're trying to peddle right now? No database, no files, no cache, no nothing? Try peddling that bullshit elsewhere. I love me a stateless service as much as the next guy, but in real world apps, those are few and far between, especially when you're close to the user agent (i.e. the web request/response cycle). &gt; Yes - ever had a spike of users? Or a bug in session management? You honestly sound like someone who has a dozen accidents before they even put their pants on in the morning. No I just do the math how many users I expect at most, how much disk space I want, and I don't have stupid problems like this.
Don't see any security issues exposed in the article. * The stale data problem is well known and affects scenarios where you'd need to selectively kick out users, which is implemented in ~0.1% of all websites I know of. * The rest is vulnerable because they simply don't expire anything at all, often not even having a mandatory login between sensitive operations (CSRF protection alike). * If you send cookies without TLS (Secure-Only) you are a muppet anyway * If you send cookies without HTTP-Only you are a muppet anyway * If you use md5 for authentication of your tokens, you are a muppet anyway. Might as well use `uniqid()` for your session identifiers. As far as I know, the only obvious security issue of JWT is with downgrade attacks, which is related to mis-configuration (lots of weak algos allowed by the spec, which is something /u/sarciszewski is trying to fix with a new spec).
&gt; snail-pace development of PHP to even bring basic language features in (it only got type hints for strings a couple of years ago Now compare it with other dynamic languages. Neither python, JS, ruby have typehint support like PHP has. Actually I know no other dynamic language except PHP which have it. And it has support for non-scalars since PHP 5, which was released 14 years ago.
The new spec, for reference, is https://github.com/paragonie/paseto
Ack. Still a good example of how much organisations invest in these features. I'd rather have TOTP 2FA implemented by websites before dealing with this stuff tho (Reddit, you listening?).
A loose checklist of everything I want that I rarely see: * TOTP 2FA * HTTPS everywhere, with TLS 1.2 minimum, HSTS and Expect-CT headers * Password resets that employ challenge-response authentication (sourced by the OS's CSPRNG) rather than instantly resetting then emailing a new password, which can furthermore be either encrypted with GPG or opted out of entirely (for power users) * Session cookies that use the HTTP-Only and Secure flags * Bonus: Same-Site Cookies * Content-Security-Policy headers
&gt; only source of IO, is this the bullshit you're trying to peddle right now? No, I'm just removing one concern here. Of course your average app will have more. If you just have a process with a counter and listening on port 443 then the I/O is just the actual network to the client. Or are you just implying that since we already have I/O, adding more I/O is just acceptable? I don't think it is. &gt; But when you run everything on cloud containers, I guess they don't give you lots of disk space to play with, huh, Mr. I-Simplified-My-Ops? I simply deployed the JWT stuff for my clients there. Yes, I simplified some stuff, it's part of my job :-)
&gt; instantly resetting then emailing a new password argh
Yes
"Yes"? So that's your response. "Yes, I just said more I/O is bad, but I'll add more I/O to every Request, and also have to decrypt and validate or cache that thing every time instead of using it trusted local storage directly." "Yes". OK.
Btw, the stable release is still the same one you audited - we didn't release `4.0.0` yet.
 &gt; "Yes"? So that's your response. Yes. I'm indeed trading less I/O endpoints for more CPU workload and added I/O on one endpoint. It reduces points of failure and it is not as CPU intensive as you think (tested/verified/etc. Bring your own benchmarks if in disbelief). 
http://books.goalkicker.com Thank me later.
That's exactly what I'm doing. 
Awesome. Exactly what I wanted to know, much appreciated. 
[removed]
Impressive, given the traffic that site must get! Happen to have a reference for it? I’ll edit my comment to include it.
No.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
SensioLabs has a service written in Go that Symfony uses. They graciously allow Laravel to use it too. It's very fast. Much faster than other solutions we were using before.
You deserve more upvotes 
And so only someone who starts writing Assembler as their first language fits this description?
Clean Code, Robert C. Martín Not PHP, (in fact samples are in Java) but it is one if the best book I've read. The theory in that book will serve you well in the PHP world. Also search for SOLID principles. If you study them, you will become a very proficient developer. Hope it helps 
I get the sarcasm here, but Assembly is a great way to actually understand computers work and that knowledge is invaluable, especially when it comes to optimizations like understanding when your processor will executive something using simd or avx. 
Maybe I'm missing something but can't you just straight echo out your JavaScript? If not why?
&gt; Yeah - you can write insecure code in languages like [. . .] Python, but you have to go out of your way to circumvent all the language features that try to prevent you from doing just that. It's basically just as easy to write insecure Python as it is insecure PHP. In both languages you have to call functions to escape data for HTML output, and both languages provide them. In both languages you have to be careful not to string concatenate user input in SQL queries, and both languages provide ways to do prepared statements instead. There seems to be a better *culture of education* about these things in Python but that doesn't intrinsically make the language itself better for security compared to PHP. ----- Now with that said I haven't seriously used Python for web development; I typically use it for CLI scripts because I like its argparse library. If the above is incorrect please link me to more resources.
I wonder how up-to-date the PHP resource is. Anyone gone through it recently?
I've used [firebase/php-jwt](https://packagist.org/packages/firebase/php-jwt). It's the one Google uses for the APIs for Google Cloud Platform, and it's really easy to work with.
Maybe share what you've tried and/or where you're getting caught up? Deploying a Symfony app is no different than most others. Copy the code in place, make sure your document root points to public/ or web/ (depending on Symfony version), and you're done if you use Apache. Otherwise you'll need to configure your web server. See https://symfony.com/doc/current/deployment.html and https://symfony.com/doc/current/setup/web_server_configuration.html for more information. 
Another option for a functional full stack web project is Haskell, specifically miso or reflex.
vBulletin or phpBB?
I grabbed a book from my local library 12 years ago and thats how I started. Went through half the book doing all the samples by hand, modifying them, even the dumb loop examples. It was this one https://www.amazon.com/PHP-MySQL-Web-Development-4th/dp/0672329166/ref=pd_lpo_sbs_14_img_1?_encoding=UTF8&amp;psc=1&amp;refRID=MX0CNNA5F6P8BBSAD4J7 I'd start by rummaging through your local library. The book will act as a lecture, you can use google for the rest. It's best to have a project in mind that you will build. It was at least motivating for me knowing that once I got through enough of the book I could actually build what I wanted. Wasn't pretty to start, but it worked.
While I do agree on all the technical points of these two articles what they basically say is that: Because plain old sessions already exist one should not use any other technology to achieve a similar thing. This I do not agree. It is kind of same as saying that since battle proven Perl cgi-bins already exist and one should not use PHP to generate HTML. As you know I am happy user of stateless tokens, they are not just JWT :)
The way I do it is create the client account under the domain foo-xx.com in WHM, then in that client's cPanel, create an addon domain for foo.com. Addon domains have configurable document roots, so it's easy to point it to any directory.
[removed]
For anyone interested, here is the open source tool (developed by Symfony's creator) that you can use to do the same: https://github.com/splitsh/lite
PHP worked very well for them so it helped them earn million dollars and a lot of users which then helped to create their own language. It depends on the perspective Mr, Keep calm and stop acting like you've got everything figured out.
No it did not work ”very well” at all! The rewrote PHP not once, but three times. It was obviously the wrong choise. 
How does it work?
is it the same one Symfony use (and the same SensioLabs' one Taylor mentioned above about being graciously allowed to be used by laravel)? Or is it some "lite" version of it? Just curious.
[This is you](https://i.redd.it/2k1ut81gpcl01.png)
[removed]
Right, I missed this one. Though, I tried both, and I couldn't find a downloadable version. They seem to be Saas only, so requesting the source code is probably pointless. If I can get the code, I'll include them. 
Usually it is some automated script - at Spryker, we use a cronjob based substree-split tool in Python: https://blog.spryker.com/how-to-smoothly-release-split-repositories The best way is to use the same structure on nonsplit-side, but as subfolders, this way the split is an easy copy-paste.
vBulletin has no free version, so I can't say. phpBB is not in the top 100. 
great candidates : ph7cms : top +100 Magento : top 30 X-cart : top 10 !!!! Invoice ninja : top +100 Prestashop : top 100 Chamilo : top 50 Moodle : top 10 If you have worked with all of them, you like gigantic code bases :) 
The big issue many people, including me, have with .net is that it is microsofts poster-child for embrace, extend and extinquish. None of the languages under the .net umbrella has been made by microsoft. All they did was make it incompatible to the original, trying to force partners to use it exclusively, in the hope that it would destroy the competition. Why code in an open and free language, if you can just go to Microsoft and pay for a certificate every couple years, that gives you a shiny plaque that you can hang on your wall? I personally don't even care about how these languages are as languages. They are stolen with the intent of harming the industry and to make money. Developers pay microsoft for the privilege of being authorised partners, while working their asses off, to convince customers to buy more licenses from microsoft. If that was my life as a developer, I'd seriously ponder over life-choices. 
ahah
I'd call it "unbiased inquiry" giving his own top10 would already point people in a certain direction. Leaving it open has a greater chance of giving unexpected results. 
3 things: SEO: a server side rendered site is easier to be read by crawlers (even tho Google runs Javascript), faster first load: if you have to wait for the HTML, then the JS and then the API responses it might take some time to see something, rendering the first page on the server is just a way to increase perceived speed. third, browsers without Javascript: most people don't care about browsers/clients that don't support Javascript, but they do exist
Those who can't govern: govern
Out of curiosity, how much does such an audit cost?
Interesting, back in the day the bulk of their business was licensing the source code. How times change!
Well, C# was developed by Microsoft and it’s a great language compared to for example Java., IMO. F#, LESS and TypeScript are also amazing languages being developed by Microsoft, afaik. And Visual Studio is a great IDE that really speeds up coding and helps increase code quality, compares to for example Eclipse or Sublime Text. I don’t really understand what you mean by ‘stolen languages’ or ‘renewing certificates’ to be honest. 
Causing a massing headache?
Apple did not design Objective-C. They inherited it when they acquired NeXT, and popularized it because NeXT’s platform became the basis of the Cocoa framework. 
I'm using Lcobucci JWT, works as a charm. https://github.com/lcobucci/jwt
The main issue is, that microsoft, instead of contributing to already existing languages, rather appropriates them. Since Microsoft is one of those companies that requires you to be a partner, to sell their applications and .net is the chosen framework for all microsoft tools, most "microsoft partners" sell microsoft solutions that they customise using .net. I just dislike microsofts history of trying to sneak licenses into everything. They have a shitty track-record when it comes to that. Copying everything anyone else has made, just incompatible to the original and to be paid a fee for. Sure, the languages are free.. But what do you use them in, on and for? microsoft products. 
I read that as fapbot lol
That's beside the point. Don't deflect. Different pedagogical methods can train programmers that are effective at their jobs. There is no one true way. There isn't even one ideal way, given that there are multiple desirable outcomes.
You're not the only one...
I laughed lol
Thanks for the reply!
Thanks for the reply!
Right - but things like (for example) PHP's inconsistent error handling make it more likely that you will compromise your server by not handling a potentially dangerous error condition. Or PHP's weak typing and type coercion will often do surprising things that will cause a program to continue working when the user gives malicious input when a stronger-typed language like Python would throw an exception. &gt; better culture of education about these things in Python It's more than just the culture - The design of the APIs in the standard library, the idiomatic way that Python encourages users to solve problems (The Pythonic Way), and the documentation itself all lead the user to be secure-by-default. Take Python Stdlib's Sqlite3 module - [The documentation](https://docs.python.org/3/library/sqlite3.html) says right near the top in the examples `You shouldn’t assemble your query using Python’s string operations because doing so is insecure; it makes your program vulnerable to an SQL injection attack (see https://xkcd.com/327/ for humorous example of what can go wrong).`
25K a year??? haha, are they counting indian code farms or something?
Well, *this one* was free. From the PDF: &gt; This document describes the security audit of Luís Cobucci's JWT library by Paragon Initiative Enterprises. This library was chosen by several members of the PHP community in response to an invitation to nominate libraries for a complementary source code review. When shopping around for a code audit for sodium_compat, I was quoted figures as high as $4,000 per person-day, with a minimum engagement period of two weeks and an assignment of three consultants. (Back-of-the-envelope math yields: $120,000 for two weeks of their time.) We *do* have a standard B2B rate (which follows the demand curve), but we're open to negotiation. Open source projects get an automatic discount. We're also a bit picky about the work we take on. Given the choice, we'd rather give a discount to a team whose work is more interesting and/or yields a higher net social good, than do uninteresting work for demanding/abusive clients at our standard rate. Autonomy and ethics are rather important to us, after all. :)
In my opinion, QA is something that can’t really be overdone. I’ve been involved in projects where professional QA teams spent months combing over every inch of the application and *still* missed bugs that were lurking right under our noses. QA is and should be an ongoing effort. I believe in QA pre-deployment and post-deployment. If it’s starting to feel like overkill, you’re probably getting close to the level that is required to find issues before your users. **Shameless Plug Below** Shameless plug: this is why I started https://bastions.co. I think QA should be performed on production websites, especially those with business-critical sales pipelines that must stay running.
I thought it was clever to cut the example down to the important methods that were the eye opener for me : may be not so much, in fact. The example is directly extracted from the README of the github repository, and it has the other mentions. That may be clearer. 
But there aren't multiple desirable outcomes. Either you are a shitty dev or not. Simple as that. 
I'm glad you plugged that! I may have clients that are interested in using something like that. I have set up tests using StatusCake a time or two but that's a little cumbersome.
The underlying subsplit tool can be found here: https://github.com/dflydev/git-subsplit However, be warned that as projects scale, the broken nature of git's core subtree command will fill up your inodes and slow down over time.
&gt; In my opinion, QA is something that can’t really be overdone. I'm guessing you don't have projects where clients have budgets and losing money on your end isn't a concern. I get that QA can end up saving money in eternal regression rounds, but there is a point of diminishing returns and QA efforts in the real world may end up being cut off before then due to budgets.
Is the Blogger namespace in your autoloader config?
In the composer.json file? If so I have it as “ BloggerBlogBundle\\”: “src/Blogger/BlogBundle”
Thanks for the interest! If you have any questions about the service feel free to PM me. I made it with ease-of-use in mind and tests only take a few minutes to setup.
But that's not the namespace you're using. Try `"Blogger\\": "src/Blogger"` 
Here's the even worse news: Code quality testing overlaps only slightly with browser-based integration testing. It won't catch feature bugs or business rule errors that are syntactically valid. I'd propose that real-world user testing is much more valuable than static analysis. And I think static analysis is very valuable! 
Hack has an average US salary of $108k
 &gt; How Much is Too Much QA? I have a whole talk about this. This short answer is that when the costs outweigh the benefit, you've got too much QA. Benefit: Probability test prevents bug occurring in production * cost of fixing bug in production Cost: Cost of writing test + cost of maintaining test Trying to calculate this equation depends on lots of things. For example, how much do bugs cost you if they are found in production. For banks which can lose their reputation for being secure places to store money, then the cost of a bug being found in production is very high. Also, if the project has a good chance of being cancelled soon (e.g. due to lack of funds) even though spending more on QA could save money long term, if there is no long term, then it's a waste of effort. Even if you can't tell exactly where you are on the value curve http://docs.basereality.com/ValueCaseForUnitTests/#/9 , you should be able to tell roughly where you are (press right a couple of times). 
Wikipedia is. https://github.com/wikimedia/mediawiki
Good point. 
That's a good question. 1. Leap of faith. That's the hardest part. I had to just take the risk and do it. I hated my job at the time, which made it easier. 2. Know your local devs and make sure they know you and your skillset. They will send work your way. Maybe just a job/client they don't want or don't have time for, but be gracious for all of it. Make sure you show your appreciation. I budget 5% of the first project from a referred client for this. Someone referred me a $17k project and I bought them a very nice drone, for example. Work will flood in once people know you need it and are appreciative to get it. 3. Pair up with the people who have complimentary skills. Find a couple of front-end devs you respect and outsource that part of the work to them. They likely don't want to deal with backend stuff, and they will outsource to you. Learn each other's deliverables. Hold them to a high standard and make sure you deliver to them in the same high standard. 4. Load balancers — These are devs who do the same job as you. Sometimes they will get overwhelmed or have a tight deadline and need you to jump in and help on part of a project. Other times you will need the same from them. You help each other balance out the peaks and valleys of workflows. You can also learn a TON this way — seeing how someone else solves a problem. A good way to accomplish all of this is to find a coworking space. Most of them will have a pretty good community of freelancers who work together this way. Some other pointers if you go this route: 1. Never price war with someone. If a potential client comes to you wanting a second estimate on a project, you either match or exceed the estimate of your fellow dev, even if you are desperate for work. You'll 2. Never steal leads/clients. I'm sure it seems obvious, but I've seen it happen a few times. You know someone is pitching a company and so you decide to pitch them too. Very uncool. 3. Don't send bad referrals to other devs, and let people know if they sent you a bad referral. If you have a problem client, let the other freelancers know so they don't end up with a bad client. If someone approaches me for a project and I know they haven't paid another freelancer, for instance, I will straight up tell them they had better pay their bill if they expect anyone in town to ever do work for them again. That generally results in payment ... and then I will request the entire amount up front for any work I do. That usually does not work out, and I'm okay with that. 4. **Do billing the right way**. All the newbs get this wrong, but it's not that hard. Let's say the project is $12k... - 50% up-front on all projects, so $6k. Be responsible and put that in some kind of escrow account. You will have to refund it if you are unable to complete the project for some reason (like you get in a bad car accident or something). If the client cancels the project, you get to keep the deposit. This is fair, as you have likely cleared your schedule for it and need time to find a new project to work on. Be sure to hand over all the work you have done, functional or not, to the client. The deposit covered the cost. It belongs to them. - Invoice monthly for the work you do. Show the full amount due on the invoice, say $1000. Have a line item showing a 50% credit on each month's invoice paid from the deposit – so transfer $500 from escrow to your operating account. The amount the client actually owes is the remaining $500. By the time you reach the final invoice, you should be using up the last of the deposit. It doesn't always come out this way, but it should be close. - Give clients 30 days to pay. I don't know how many times I've seen people try "due on receipt" or 15 days, or whatever. It doesn't work like that in the corporate world. They have a monthly schedule. Just get used to it. - Late fees. I've seen some crazy shit here. Standard is 1.5% monthly — that's 18% APR. You want it to be a number that's a deterrent, and even a little insulting, but not relationship-ending. The idea is, "*you are not a credit card, but if they treat you like one, you will behave like one*." If you have a client with a credit card at 29% APR (assume every startup), you just became a bargain. So adjust the rate upward slightly to send the appropriate signal to the client that you don't want to carry their debt. Be forgiving of lateness due to bureaucracy ... government agencies and large accounting departments may not be able to get you the first payment for 60-90 days, but they will pay like clockwork thereafter. Be cool about it. - Don't worry about stacking late fees. In fact, don't worry about anything. If an invoice is 45 days past due, stop all work on the project, and let the client know you will not continue until all outstanding balances are paid. Always be calm, firm, and informative. Don't get angry or emotional. - If an invoice is 60 days past due (issued 90 days ago), you cancel the project, send the client an email letting them know it has been canceled due to non-payment and include all the work you've done to date. **Always be calm, firm, and informative. Don't get angry or emotional.** Inform the client that their deposit will be used to pay all outstanding balances and that you will keep the remainder per your agreement. See how easy that was? You didn't get screwed. It didn't ruin your day. Take a victory lap and start on the next project. I hope that helps. Best of luck! 
When some municipalities tried to replace Microsoft Office with open source products Microsoft said "people should have choises whatever they want, they should not prohibit any products". I think you can say similar thing.
[Steve Jobs on OOP](https://fossbytes.com/steve-jobs-tells-the-best-definition-of-object-oriented-programming/) OOP solves some problems but you already solve these problems in languages like C and Go; [Uncle Bob's history on OO](https://youtu.be/t86v3N4OshQ) You will understand it better when you face those issues.
The value of unit tests comes from establishing correctness of units. The entity giving you a paycheck doesn't directly care about this; your code should work but they don't care about the units, they care about the use-cases. From this thinking you should care more about use-case testing than unit testing. In my opinion efforts to properly fix issues raised by PHPStan, Phan, and Psalm is important. In my experience these are bugs just waiting to happen. Modifying code to prevent false positives is less important, and is somewhat risky; if there was no bug but you modified the code there might be one now.
https://github.com/statwig/statwig StaTwig: a console tool to compile Twig templates into html views. It takes all the files from the root of input directory (e.g. index.html.twig, contact.html.twig) and compiles it using Twig templating engine to the output directory (index.html, contact.html). You can use is for static page generation and I use it for creating tachyons/bootstrap templates (no need to repeat full html markup).
Why aren't the components just not included in the main repo and pulled in by composer? What is the benefit of using symphony's service?
A performance update to the SPL Datastructures would be nice as well as support for ALPN in the SSL context.
“Does a thing” though can expand pretty quickly to “does a thing in this case” and so forth. Uat is a god send when properly done. First rule: find an issue, prove it with a test, fix the issue, prove it with a test. 
To quote /u/FruitdealerF "Splitting your project into multiple composer packages only makes sense if those components could be used separately. If they are either useless on their own or always need to be used together there is no point in splitting them up and you're only going to cause a massive headache"
&gt; does a thing in this case That case had better been defined in the scope if they want it under the current budget and timeline. I'm sure I'm not alone here, but I pushed very hard for well defined scopes and holding ourselves and our clients to them. It helps that my company works on time and materials. We do not give away work for free unless we absolutely have too because we shit the bed somewhere along the way. Not every company is like that though.
Oh God that change would break so many things in existing code bases. 
if ($workOrder-&gt;isClosed()) {} This looks fine to me.
I see. It might have some parts that you mention, like aggregation - kind of. But it's doest build anything or create based on any configuration, like my or yourse link. It's rather combination of pipe-line - router - builder. Collector is rather specific pattern, as it collects operation and performs. Doesn't build, doesn't use fluent interface like builder does. That's why I ask for specific example in PHP code (code class, not theory) . Builder is something like this: - http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/query-builder.html - https://github.com/rectorphp/rector/blob/master/packages/RectorBuilder/src/BuilderRector.php
&gt; Collector is rather specific pattern, as it collects operation and performs. Doesn't build, doesn't use fluent interface like builder does. I'm not sure about your angle here. Your examples demonstrate fluent interface a.k.a. method chaining: $firstRector = $this-&gt;builderRectorFactory-&gt;create() -&gt;matchMethodCallByType('Nette\Application\UI\Control') -&gt;matchMethodName('validateControl') -&gt;changeMethodNameTo('redrawControl'); You collect and perform. A builder also collects and performs. What it performs, as I said, is typically building an object. Sometimes the builder and the object are combined in one, but that's a very subtle difference and I don't think it warrants discussing it like something entirely different. The QueryBuilder you're linking to seems like the same thing you're doing. How is Collector different here? 
Yeah, I think MEAN is the future but there aren't enough devs with the skills, so companies are paying a premium for it at the moment. I guess in five years more devs will have moved over and it'll be a bit more even.
Drupal: at least it's not as bad as SharePoint
Make `getStatus` private. Just expose answers to the questions actually needed. Your example would refactor to if ($workOrder-&gt;isPaid()) { // ... }
You could make use of a [http://php.net/manual/en/language.operators.bitwise.php](bitmask) for the state, just ensure you account for logic to cancel states out when there's a conflict, ie setting a flag of "closed" should remove the "in progress" flag. class WorkOrder { protected $status; const IN_PROGRESS = 1; const CLOSED = 2; const PAID = 4; //const NEXT_STATE = 8; //const NEXT_STATE = 16; /** * @return bool */ public function isInProgress() { return ( $this-&gt;status &amp; self::IN_PROGRESS ) === self::IN_PROGRESS; } /** * @param bool $state set to false to remove the flag */ public function setInProgress( $state = true ) { $this-&gt;status = $state === true ? $this-&gt;status | self::IN_PROGRESS : $this-&gt;status ^ self::IN_PROGRESS; } /** * @return bool */ public function isPaid() { return ( $this-&gt;status &amp; self::PAID ) === self::PAID; } /** * @param bool $state set to false to remove the flag */ public function setPaid( $state = true ) { $this-&gt;status = $state === true ? $this-&gt;status | self::PAID : $this-&gt;status ^ self::PAID; } /** * @return bool */ public function isClosed() { return ( $this-&gt;status &amp; self::CLOSED ) === self::CLOSED; } /** * @param bool $state set to false to remove the flag */ public function setClosed( $state = true ) { $this-&gt;status = $state === true ? $this-&gt;status | self::CLOSED : $this-&gt;status ^ self::CLOSED; } } $work = new WorkOrder(); // Set the Paid + Closed Flag $work-&gt;setPaid(); $work-&gt;setClosed(); var_dump( $work-&gt;isInProgress() ); var_dump( $work-&gt;isPaid() ); var_dump( $work-&gt;isClosed() ); // Remove the Paid Flag $work-&gt;setPaid( false ); var_dump( $work-&gt;isInProgress() ); var_dump( $work-&gt;isPaid() ); var_dump( $work-&gt;isClosed() ); 
The method names looking correct for me, but I would move the constants to the status it self. So you can do it like `public function isClosed() : bool { return $this-&gt;status === Status::Closed }`and the status is just a plain Status class with these constants and possibly with a `__toString()` Magic Method. If you use [MyClabs\Enum](https://github.com/myclabs/php-enum) you just can extend it with the Enum class and it should implement everything you need. You just need to put in the constants.
Then you start testing if things are !isClosed, then someone "helps" by making an isOpen method, then you may have [clopen](https://en.wikipedia.org/wiki/Clopen_set) stuff.
**Clopen set** In topology, a clopen set (a portmanteau of closed-open set) in a topological space is a set which is both open and closed. That this is possible may seem counter-intuitive, as the common meanings of open and closed are antonyms, but their mathematical definitions are not mutually exclusive. A set is closed if its complement is open, which leaves the possibility of an open set whose complement is also open, making both sets both open and closed, and therefore clopen. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
My preference would be to go with `-&gt;isClosed()` and explain the business logic in documentation. I usually don't like excessive commenting, but this kind of business logic is what it's good for. I guess a call like if ($workOrder-&gt;getStatus() === $workOrder::PAID) { echo "all paid up!\n"; } would express exclusivity, and would be less tightly coupled than `WorkOrder::PAID`.
sharepoint must be really really bad then
If you're still writing `array()` in the current year, you're doing it wrong.
Bitwise operators are witchcraft
MEAN is not the future. Mongo had it's 15 minutes of fame until people realized most dbs actually do need to be relational and Mongo is bad at that. Angular is still being used but IMO it's on it's way out as well in favour of React and Vue.
A few other items I'll throw in. While PHPUnit is a life saver I've been wanting to use JS Unit Testing for a while to test the whole shabang. Unfortunately, I haven't had the opportunity to implement. Also on my todo list https://github.com/php-vcr/php-vcr for testing APIs. 
This isn't API, it's an object method. And an expressive one, at that.
I don't see any PHP salary info
If it wasent supposed to be used, it would have been deprecated.
OK, so both the multiple `isSomething()` method approach and the single `getStatus()` approach are fine. The `isSomething()` convention doesn't require or suggest that multiple of those methods might return true at a given time. If you have lots of statuses it may lead to lots of `isSomething()` methods which are pointless boilerplate if the code that checks status in this way is rare. But if you have a small number of models, and the `isSomething()` methods frequently come in handy then it's a perfectly fine API shortcut to make code clearer and more succinct. Regarding coupling to the WorkOrder class, you're already coupled to it, by means of calling its methods on `$workOrder`. So you're not *extra coupled* by referring to its constants. If you suspect in the future you may want to have multiple `WorkOrder` implementations, you can refactor `WorkOrder` to be an interface that defines these methods (empty) and these constants, and implement it in multiple classes (for ex. `DefaultWorkOrder`, `TestWorkOrder`, `DoctrineWorkOrder` etc.). The rest of your code won't have to be changed, and at this point you'll be coupled only to an interface (which is fine).
You don't need bitwise operators if your status modes can't overlap. That's a completely pointless overcomplication. Also stop trying to hide the constants. You don't need to hide them.
That’s maybe more of a status naming issue than anything else, IMO. And within reason, it’s reasonable to assume people working with this have at least some domain knowledge, which helps fill in any gaps. The API is overall a very good and simple encapsulation of object state. If anything, I’d try to remove the “fallback” that exposes the actual state value. 
Under `What Languages Are Associated with the Highest Salaries Worldwide? - United States` PHP is not on the list because its not in the top 25.
What the hell is that website? Totally unusable. I can't use arrow keys to scroll because they take over my down key with a stupid search box.
I've wrestled with status fields many times, and I've noticed that each status change is usually caused by something becoming true that wasn't true before and that the current status can always be derived from these facts. In this case, your facts are if something has been paid and if something has been closed. These are two different pieces of information. Your business rules may currently state that one implies the other, but this may not always be so. Even if that never ends up the case, you still have placed several pieces of information into the same field, overloading it. It's much better to place each fact into a separate column. In your case, the columns would be `paid` and `closed`, which can simply be booleans. For these, they presumably happened at a specific time. I like to go one step beyond the booleans and make these into nullable timestamps. This way, you can still read them as booleans (thanks to type juggling) but you can also find out when an order was closed or when it was paid. Code that's dependent on `status` can still work. All you have to do is introduce the `getStatusAttribute` method and have that calculate what the current state is. I imagine that for you this would be a short list of `if` statements. For querying the database, you can still easily find paid orders that aren't closed, closed orders, in progress orders (neither paid nor closed), etc. As a bonus, your queries for simpler things (e.g. find all orders that have been paid) will be straight-forward and will not have to account for a (potentially growing) list of status values.
**Introduction to Algorithms** Introduction to Algorithms is a book by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. The first edition of the book was widely used as the textbook for algorithms courses at many universities and is commonly cited as a reference for algorithms in published papers, with over 10000 citations documented on CiteSeerX. The book sold half a million copies during its first 20 years. Its fame has led to the common use of the abbreviation "CLRS" (Cormen, Leiserson, Rivest, Stein), or, in the first edition, "CLR" (Cormen, Leiserson, Rivest). In the preface, the authors write about how the book was written to be comprehensive and useful in both teaching and professional environments. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
Thank you so much. 
It's fantastic. The book takes a while to digest, but is well worth it. I'll be keeping my copy on hand indefinitely.
Which edition?
Read clean coder. 
Undefined, please define.
Holy shit this thread. I hope none of you get paid to do this.
I've used various "metrics reporting tools" (like the ones you mentioned and others), but I never found them to be really useful. What was really useful: - `phpstan` and increase the level as you go along - use something like https://styleci.io/ =&gt; don't have your developers spend time formatting code, auto-reformat it and be done As others already pointed out, there's always the economic factor to weigh in. I only work on long-lasting (multiple years) projects so this is my rule: - any manual test performed is a loss - any automatic test written is a win
Sounds like a prime candidate for the stage pattern. See https://github.com/sebastianbergmann/state.
As someone making over 100k a year and still have headhunters calling, I feel comfortable with my decision. If anything, learn Kafka or just the basics of a pub/sub system and Hadoop. If there was one other language I would want to be motivated to learn it would probably be Go and perhaps machine learning with it. 
[Coding Interview University](https://github.com/jwasham/coding-interview-university) is a good resource. 
Thank you so much! This is exactly what I am looking for. 
Essentially a data strucutres course goes in this order Big O, Big Theta and the horseshoe. Sequential, Insertion, Bubble, Merge Sort. Implementing your own version of linked list. Implementing your own version of Stacks and Queues using either a linked list or an array. Implementing your own General Tree or a Binary Tree. Implementing a heap. Heapsort Implementing a hash function The whole purpose of Big 0 and all these data structures is to give you an idea of how long it will take and what will be the best structure to use to store your data. I think python is one of the better languages to learn data structures in. Its easy to make a quick classes and stuff. It will be helpful if you go over discrete math. You dont really use it much in data structures but it gets really helpful in algorithms. 
I'm learning Java, Is it good choice to understand the data structure with Java? 
In the end, its whatsever works best for you. I learned it in Java too :)
This is looking very nice. Since the bigger companies not really looking for Web Developers, but more Software Engenieers, I like the comment about reading more about this topic.
Thank you, Which edition do you recommend? 
Look at what internet has done to us.
That one class is direct copy of upcoming symfony feature. It's a pending PR. Symfony mandates usage of array() and I don't want to diverge from original patch.
Normally you would do a risk analysis for the software and changes the high risk parts first. 100% code coverage can be done, but is it really necessary? Of course the tools will help you to improve the code, but do it wisely. You can have code that is 100%, but doesn't do the job. Or code that has some flaws according to those tools, but works a 100%. Which one do you choose? What i do, is when I have time left at the end of the day, is to improve the software, but is is not my main goal. The main goal is always: working software
I’d consider renaming ‘closed’ to something more clear. What does it mean when a workOrder is closed in business terms. In progress and paid are fine but why is the workOrder closed? Is it because it was cancelled, progressed and paid or...? Making it more obvious what closed means will help you a lot.
I would use the symfony workflow component since this is mainly a business flow requirement. If isPaid() do this. If isClosed() do that. The docs include an example exactly related to statuses. You can find it here https://symfony.com/doc/current/components/workflow.html
If you are using Laravel: https://github.com/tymondesigns/jwt-auth
Thank you.
+1 for string statuses. Moreover, some RDBMS like Postgresql allow you to declare ENUM types. https://www.postgresql.org/docs/10/static/datatype-enum.html You can have efficient storage AND readability of string values. Bonus: you can sort them according to their declaration order.
I would razer implement JsonSerialisable and keep properties private :3
JSON was an example. One of countless. 
[removed]
This is great
&gt; These are two different pieces of information. Your business rules may currently state that one implies the other, but this may not always be so. Even if that never ends up the case, you still have placed several pieces of information into the same field, overloading it. You claim OP has overloaded the field by placing "several pieces of information into the same field" based on a pure speculation that "it may not always be so". Nothing ever in software is guaranteed to be "always so", but you can't claim the current design has a flaw based on a hypothetical future change that OP may be in the better position to know if it's likely to occur or not. Until then you're just making state-keeping in the object more complicated for no reason. Don't gold-plate your objects. It just means more bugs for no reason.
&gt; since PDO and mysqli_* fail silently when you execute multiple queries They don't. [Running multiple queries with PDO](https://phpdelusions.net/pdo#multiquery). With mysqli you must follow the same approach
&gt; mandates There's that word again.
This is a weird behavior. Usually, function and class definitions can be out anywhere in the file within the parent block (not inside if/try blocks for obvious reasons) and they'd work. 
Keep migrations as short/atomic as possible. Ensure you have the reversing queries. In any case, if a migration fails, you NEED a developer in front of the console handling things. So, in the worst case scenario, simply executing manually the reversing queries one by one, and if you are lucky, just execute the migration in reverse mode.
Great post. Could you elaborate on how do you fix the price for the work you do?
yes, but: DELIMITER ;; CREATE TRIGGER trigger name BEFORE DELETE ON table_name FOR EACH ROW BEGIN THIS IS NOT VALID SQL END;; DELIMITER ; this is as short as it can get for a trigger, but it's 3 statements, the first and the last will obviously succeed, but the trigger errors. It will fail silently (since the first statement was successful), and we have no way of knowing, unless we manually check the trigger to validate it... this is the actual use case we are currently having problems with.
this
got a working example?
As long as your respect some basic OOP stuff, you will not encouter this. You ALWAYS wan't to have all classes, abstract or not, interfaxce or not, each in his own file. One class/trait/interface per file.
I just had these recommended to me: [Algorithms Part 1, Coursera](https://www.coursera.org/learn/algorithms Part1) [Algorithms Part 2, Coursera](https://www.coursera.org/learn/algorithms Part2)
The reason why classes can sometimes be referenced prior to their definition is *early binding*. Early binding binding is categorically performed only for classes which do not implement interfaces or use traits (but may extend another class). During compilation any class that does not inherit (and as such has no dependencies) will be early bound, as well as any class that does inherit, but those parent is already bound (either through early-binding, or because it was already defined prior to the compilation of the file). As such, in your example the classes A, baseB, B, baseC, baseD are subject to early binding. The classes C and D are not, as their parents are not bound yet at the time when they are encountered. The example using D still works because the class D is bound prior to use at runtime. The example using C does not work, as class C is used before definition. There is one more subtlety involved here: Early binding is not performed if the class already exists, in which case binding is always delayed until runtime. This little tidbit is what makes the situation hard to fix, as many sensible ways to do this (say, just hoist *all* non-conditional class definition to the start of the file, in the correct order) would be BC breaking.
https://www.coursera.org/specializations/data-structures-algorithms
It's best practice in any OO language.
Source?
Years of experience. You want to have your code organized. Folder structures are important too.
"Dudes opinionated advice" then become "best practice" and almost "OOP itself". Then comes PHP and breaks the illusion: http://php.net/manual/en/language.oop5.anonymous.php
You can't compare pears with apples. An anonymous function has the same application as an anonymous class, and really has other use cases as typical classes, interfaces and traits. I never said this is OOP law, I talked about the OOP world in general. You're right though, it's not part of OOP.
Thank you very much, that's a very clear explanation.
One important thing to note, is that migrations do not run in parallel. There is partial ordering there. (That is if it do matter we know which migration to run first, but it don't order is undefined, and can be any) However migrations do not run in parallel. So there is no race condition possible between different migrations. If above holds true, then you can structure your migrations so that each step is executed if and only if it's dependencies are met (that is, you add column content to another if both columns exists, etc.). You also have to keep track of progress made. (Which queries failed, which where skipped?). If all steps succeeded, then migration succeeded. If some failed, you revert those that succeed (that is those that took effect). Ofc. for permanent steps, you need to keep temporary copies at hand to have true revert capability.
Read the rest. I'm not going to diverge from original patch unless necessary.
cool, that might solve this part of the issue
 $sql = &lt;&lt;&lt;SQL SELECT * FROM users; ALTER TABLE thisdoesntexist ADD COLUMN id INT; SQL; $stmt = $pdo-&gt;prepare($sql); do { $data = $stmt-&gt;fetchAll(); $err = $pdo-&gt;errorInfo(); } while ($stmt-&gt;nextRowset()); never will the $err contain any error info
Hi, one the maintainers here, what kind of help are you looking for? We have an IRC channel #reactphp on freenode and you can always raise an issue on Github.
You forgot an `execute` call in there. $sql = &lt;&lt;&lt;SQL SELECT * FROM users; ALTER TABLE thisdoesntexist ADD COLUMN id INT; SQL; $stmt = $pdo-&gt;prepare($sql); $stmt-&gt;execute(); do { $data = $stmt-&gt;fetchAll(); $err = $pdo-&gt;errorInfo(); } while ($stmt-&gt;nextRowset()); or even simpler $sql = &lt;&lt;&lt;SQL SELECT * FROM users; ALTER TABLE thisdoesntexist ADD COLUMN id INT; SQL; $stmt = $pdo-&gt;query($sql); do { $data = $stmt-&gt;fetchAll(); $err = $pdo-&gt;errorInfo(); } while ($stmt-&gt;nextRowset()); 
Probably nothing wrong with it. Besides it somewhat going against the architectural grain of PHPs synchronous nature. Hence we went with NodeJS for async as more support and the whole language is based around async execution. Hopefully in the future when PHP has full native support for async it will be a different story. I always keep looking but never find much hope beyond the async and await reserved keywords. PHP 7 now having an event loop and stuff is a good step in the right direction too I feel. ReactPHP doing a great job at proving PHP would be better with it than without.
Eh, I think by "any OO language" you are really thinking about Java specifically, or languages conceptually close to Java (into which category PHP falls as well). There are however many object-oriented languages (or languages with object-oriented aspects) where having a one-to-one mapping between classes and files would be atypical. For example, in C++ it is quite common to define many classes per file. In Rust this is true to an even larger degree. There files correspond to modules which typically contain multiple related class (=enum/struct/trait) definitions. Personally, I consider this to be the superior model, as the one-to-one mapping of classes and files causes unnecessary boilerplate and maintenance burden.
The bar is higher to get started then for example a Laravel or a Botman, because you have to run your own server and need to know some devops for that. But projects such as [PHP-PM](https://github.com/php-pm/php-pm) make that a lot easier. (Assuming you're running it as a application server, you can build async queue consumers in it as well.) And to be fair we're gaining more and more traction =D
Python has officially had typehint support for a while (2015 I think) - https://docs.python.org/3.5/library/typing.html.
You shouldn't have problems with that : if your SQL is wrong, it shouldn't escape the developper's env. I guess ou could add a few manual check and you are probably able to flag the migration as a failure tho. But to me, the only "failure" allowed to happen on prod, is a data-related failure (for instance i had a migration failure while converting a table charset because it contained 0000-00-00 datetimes, only in production)
No wonder it doesn't give you any error. you are only preparing a query but never executing.
exactly 
$status is private, i can't see any set methods and there is no ability to override it. Also, don't use self::, use static:: instead so it lets you override the status in sub classes (assuming you may wish to do that of course?). Following OOA&amp;D practices you are violating the single use responsibility if the class names are anything to go by. Status should be it's own class and since workorder would "use" a status you should pass it in via aggregation. This would also assist when producing mock objects for unit testing. Also be handy to throw in a bit of defensive coding. Here's a quick example (although by no means complete and I've rushed it so there are likely further mistakes I'm sure people will pick out). &lt;?php /** single responsibilty i.e. handle a work status **/ class WorkStatus { /* shame we can't set constants to private in PHP */ const UNDEFINED = 0; const IN_PROGRESS = 1; const CLOSED = 2; const PAID = 3; private $status = 0; public setStatus($status) { // Defensive coding switch ($status) { // failthrough expected case static::IN_PROGRESS: case static::CLOSED: case static::PAID: break; default throw new Exception("Unknown status code: {$status}"); } // save status $this-&gt;status = $status; } /* by accessing in this way we shield the constants, provide context AND allow flexibility e.g. to override, defensivly code, unit test, implementing logging, etc without exposing such to the userland code */ public function isInProgress(): bool { return $this-&gt;status === static::IN_PROGRESS; } public function isPaid(): bool { return $this-&gt;status === static::PAID; } public function isClosed(): bool { return $this-&gt;status === static::CLOSED; } public function getInProgressStatusCode(): int { return static::IN_PROGRESS; } public function getPaidStatus(): int { return static::PAID; } public function getIsClosedStatus(): int { return static::CLOSED; } } /** follows the law of demeter and maintains single responsibility i.e. manage a work order */ class WorkOrder { private $status; public function isInProgress(): bool { return $this-&gt;isInProgress(); } public function isPaid(): bool { return $this-&gt;isPaid(); } public function isClosed(): bool { return $this-&gt;isClosed(); } } Just noticed there's no way of setting the $status within the WorkOrder class... told you there are errors... hope it's a starting point :D 
did you try calling $stmt-&gt;errorInfo() again after the loop? That's where the error will be available
1. delete it from here and reask in /r/phphelp 2. indent your code with 4 spaces
If you need to elude only the row with de id #7 replace if ($row['id'] &lt; 6) with if ($row['id'] != 7) 
yeah, no errors available
this did the trick, enabling exceptions I finally got an error.
It's not even an implementation detail, nor is it in any way required for PHP. It's just an agreed upon style choice.
Odd. Why am i thinking of the box **trolls** film right now...
The Art of Computer Programming -Knuth
Remember you can use an array $banned_id = array(7, 13, 40): and... if (!in_array($row['id'], $banned_id)) to avoid easlily certains ids, such as #7, #13 and #40 on my example
In Java... ;)
just after your while() if($row['id']==7) continue;
No. As one of the minority who actually own this rather than just pretending to, I would never recommend it to someone who wants to " learn Data Structure and Algorithms in PHP language". It's a great resource for people who want a really deep understanding of the theoretical underpinnings of the subject, but is almost impenetrable for someone who's not already comfortable with various aspects of compsci. FFS, step one is to learn assembly language for a non-existent computer architecture. And it certainly won't give anything like the quick and appealing "I've read the first two chapters of this book and now I know how to do a preorder tree traversal, and how to calculate the shortest path in a network". And then if you're hooked and want to know more? Buy TAoCP.
Eh, same with all books. Get the latest edition if you can.
The language is more or less irrelevant. I would probably do the work in PHP so learning the language doesn't get in the way of learning the algorithms.
Whether it has been paid and whether it has been closed are two different things. Two different facts. They should each have a separate field. I've been down this road before. Status fields have almost universally caused me pain, whereas breaking them apart into component fields has yet to cause me any pain. I get that you want to make the data be structured in such a way that invalid states are logically impossible. I feel the same way, which is why I always use foreign key constraints and freely apply unique indexes. But there's also a good reason why there should be one and only one fact per field.
I am not, though there should be many resources in Hindi and Bengali.
Those are just annotations, they don't do anything in runtime.
I like this also... except a ; in the first line you posted :-)
Python is an exception to this. It's common (and considered best practice) to group related classes into a single file (i.e. a module).
If the status has meaning outside of this class, then exposing `getStatus` makes sense. Otherwise, these aren't meant to be handy shortcut messages, they're meant to encapsulate and give meaning to the status inside of it. This doesn't need it's own class if it's just representing a property's value, as your response implies. 
Generally, the purpose of abstraction is to make things simpler, not to make things more complex. Hiding a single status value and masking it as seemingly independent boolean flags achieves the opposite effect: it makes the model state appear more complex than it is. If there's a specific reason to hide the status, so you can change the internal representation of these `is...()` getters, yeah, I get the theoretical situation. But the practical situation is that OP has clearly implemented a `getStatus()` method and they haven't suggested that the status is to be hidden, or that it's meaningless outside the model.
I didn't say it was easy, but it's thorough. Volumes 1-4A are sitting on the shelf behind me and one of my favorite profs actually has a dollar from him.
PHP 7 doesn't have a built-in event loop, but it might change in PHP 8.
Great and accurate post. The most important thing to make sure all this works is to have it down on a contract which could be just a list of terms, along with the project specs, payment schedule, deliverable schedule. Make sure it’s all down on writing, otherwise you don’t get jack say in anything 
Ah, I didn't even tried both errorInfo() and exceptions. In the tests I did above I had exceptions disabled. One more reason to always keep PDO exceptions enabled, I guess.
https://github.com/derekhamilton/glove Laravel Glove: Exception handling library for custom error pages and exception handlers. I found doing the setup for getting custom responses to exceptions a little more tedious than desired, so I put this together. Primary features being This means - Custom error pages that don't need a handler - just point to the view in the config - Status codes and log levels specified in the config - Simple interface to implement that lets us return a response and be done - Cascading handlers simply by omitting a response There's fairly comprehensive documentation on the github page. 
If I had a Knuth dollar, I think I would genuinely put it on my CV.
Traditionally, PHP applications are run via Apache/Nginx and those are forking and killing PHP processes on each request
PHP is interpreted and not compiled. That leaves your sourcecode fully visible if a server is compromised. Yes, you can obfuscate code, but obfuscated code is easily unobfuscated. To me that's a security issue.
ASP.NET is compiled when it is deployed. That gives a little more protection to your source code. In PHP most people just deploy plain, unencrypted text (.php) files. So if a server containing your php gets compromised the hacker will get all your code and also probably be able to read the DB connection credentials and access your database which will also be in plain text or poorly obfuscated code. 
I'm chill, I'm just saying we should be careful in making assumptions from so little information. Part of the game here on Reddit is people making bold assumptions about things they don't know, allowing them to clear cut solutions to problems... different than the problem being discussed. The result is just advice that's not very good at best, or confusing and misleading at worst.
Security is an issue if you're storing code and database information in plain-text files on a server. Anyone who compromises your server will have easy access to your code and database.
yeah, and the code is stored on the server in plain-text files..
I'm from Bangladesh. 
&gt; It often comes from directly translating what the business does and how it thinks into code without stopping to decompose the information and processes into their base components. [...] From my perspective, it's a common pitfall that developers fall into and I want to dissuade anyone from going down that route [...] You're seeing it as a bad thing, I see it as a good thing. I can say it's a good thing because it results in simpler software, both simpler implementation and simpler APIs that cleanly translates the intended domain behavior into domain services in code. Bugs and unintented situations are less likely that way. You think it's bad because we need to "decompose the information and processes into their base components". But the base component of a workflow process is a workflow chart, and you move from node to node on the chart. That *is* the basic component. You're not decomposing things into basic components, it feels more like you're addressing edge cases which don't exist, because it feels more complete this way. It doesn't sound like a benefit for anyone involved. Where the benefit? 
The prof in question has a *string* of credentials after his name and I'm pretty sure he's most proud of that dollar. I would be too.
I know it's design decision. Design which is sure a hell lot easier to implement than real typehints evaluated at runtime, like PHP has. PHPDoc exists since 2000 and this provides no advantage. So my point still stands, no other dynamic language has better typehints than PHP.
That's not really the issue. If you have access to the file system it's game over, regardless of what you're using.
The updates the pseudocode in version 3. It became much more readable. 
The performance gains are not the same on a real-world application compared to a fresh install. There will be diminishing returns as your application code becomes slower than the framework bootstrap code. You are going to see maximum performance gains when there is basically no application code (fresh install) and the entirety of processing just the framework bootstrap code.
I simply install vendor packages as source rather than dist, for our company vendors. That way you'll have full git repositories in your vendor directory pointing to the correct remote. When you change anything, simply commit and push. If you want to work against a specific branch, I always set an additional version constraint in the dev requirements. E.g. in require it'll say "vendor/package": "^1.1” and in the require dev it'll say "vendor/package": "dev-feature/ISSUE-1 as 1.1.0”. then after the vendor package is merged and tagged, I remove the dev requirement. As soon as the package contains the new version, a composer update will run successfully. 
I use SmallTalk. What's a file?
Quick reminder that, no matter how well designed the migration, MySQL doesn't have transactional DDL, and implicitly switches to auto-commit at the first encountered DDL statement. My first suggestion is to use whatever you like for migrations, as long as it is PostgreSQL :-P 
Definitions are processed before statements, but still in order. That means you can istantiate a class at any time, but you can't define subclasses until after it is defined.
If you’ve logged in then it’s generally successful ...
You can make a constant private starting from php 7.1
So you run: composer require bla/xyz 1.2.3 --prefer-source and then you go to vendor/bla/xyz and you make all changes there and then you commit and push from there? And in the end: composer update bla/xyz 1.2.4
Also check out (which you will by following Coding Interview University) the youtube channel [Algorithms and Data Structures](https://www.youtube.com/user/algorithmscourses/videos)
And how do I know that? 
At work we use an enum library ([marc-mabe/php-enum](https://github.com/marc-mabe/php-enum)) which has an `is` method so you can do this: if ($workOrder-&gt;getStatus()-&gt;is(Status::PAID())) { Seems to work fine.
With your eyes usually
I define both local and vcs repos in composer.json as follows: "repositories": { "local-libs": { "type": "path", "url": "../lib/*" }, "vendor/foobar": { "type": "vcs", "url": "git@repository/url/to/foobar.git" }, "vendor/bazqux": { "type": "vcs", "url": "git@repository/url/to/bazqux.git" } } And then, before installing composer dependencies on staging, CI runs composer config repositories.local-libs --unset 
With php? 
WUT
It's my first one cool library.
Yes
Stackoverflow
&gt; The dev requirement with alias allows the version to resolve as available. So where do you create the dev-feature/ISSUE-1 as 1.1.0? is "dev-feature/ISSUE-1" a branch you created in vendor/bla/xyz's git repo? 
&gt;On the performance part - it already wipes the floor with Python and Ruby and it's still improving. Performance is a bit of a red herring on three fronts. Firstly being faster than 2 of the slowest languages doesn't mean much, PHP is still a slow language and basically lumped in with Python, Perl, Ruby, etc as a slow language, pretty much every other language that gets used for the web is faster than this group (Javascript, Go, Erlang, Java, c#, etc). Secondly speed of the actual language doesn't directly transfer into performance as a whole, which is why if you take Django for example (one of the slowest/heaviest Python web frameworks) it outperforms one of the slowest heaviest PHP frameworks Laravel, see - https://www.techempower.com/benchmarks/#section=data-r15&amp;hw=ph&amp;test=fortune&amp;l=hr9uyn&amp;f=zik06v-zi8rnj-zik0zj-zik0zj-zijbpb-zik0zj-zik0zj-bun , because there a lot more to the performance of the whole system than whether language X can plot a Mandelbrot Set faster than language Y. Lastly and perhaps most importantly, base performance is largely irrelevant. I mean look at Python as a whole, it is one of the most used languages (top 5) according to most indexes, is heavily used in machine learning, data analysis, robotics, automation, etc, yet everyone knows it is slow. But outside of a tiny amount of edge cases that does not matter, because the strengths of the Python ecosystem far outweigh the low baseline performance, like how readable, concise and easy to learn it is (whilst still being well designed), how fast it is to get stuff done in that langauge or the huge amount of libraries/packages that are written for Python. And it is also that ecosystem that allows Python to mitigate its slow performance in all but edge cases, heavy lifting needs to be done in machine learning, no problem the de facto standard libraries are written in c++ for Python, or if your web app needs huge scale no problem use pypy (Python version with a JIT compiler), or use one of the asynchronous options Gevent/Tornado, etc or if you profile your code and find some bottleneck that is python, then use Cython to rewrite that small part and get silly levels of performance (Cython is a superset of Python that compiles down to C other than a small part of it, that you can then import like any normal module to your Python project). I apologize for rambling.
Right so creating something awesome and cool is the first/easiest step. From there on you need to keep it maintained, use it (a lot) your self, write blog posts/articles about it show casing different uses an why it's awesome. And be very patient, it can take months before people notice it, and then even more months before one of them will use it in a project. And then, if they like it, tell there friends. Patience is your best friend as a starting maintainer
It's nice but I am surprised that composer does not support this feature.. the thing with CI seems like a workaround..
The same way you would with eyes. What do you look at to know if you're connected ?
Well, the company I'm doing my thesis at is using it! I think Laravel and CakePHP have gained popularity, but I think Symfony still has a solid following
/r/phphelp 
I filled it out for you
I don't think this is true. There are plenty of shops using Symfony that I know if. Laravel is a newer framework though, so I do hear more news about it.
You can also use reflection to change the `logger` into a mock object. This is generally frowned upon since it bypasses the public api of the SUT. However it is no worse than the anonymous sub class solution, which does the same thing. Another solution is to have the `Logger` object expose a static `setInstance` method. This method could be used to inject mocks or other testable objects. Doing this requires Logger to be "designed correctly" but allows you to test `dateCalculator` without modifying the public API. 
This one I do not understand. Drupal is not my tool of choice, I am very meh about it. Share point though I would never work with. They are leagues apart in my experience and I can not say I know many other devs who would disagree.
Static methods aren't harmful, static state is harmful. When you're implementing pure, stateless routines, writing them as static methods (or functions) is a natural solution, and they're also naturally testable (you know, pass input, check output is as expected, done). Going into this rabbit hole of trying to inject and mock static methods demonstrates either the person needing that is using static methods incorrectly, or they don't know how to test very effectively. But describing static as some sort of sin is also highly dubious. We love Functional Programming, right? Well guess what's Functional Programming made of... libraries of functions... which pretty much operate like collections of static methods on a class.
When something depends on a static debug logger, you can typically granularity configure the verbosity and operation of that Logger from an API on the logger, rather than messing around with the logger dependency of other methods and classes. That's what I would do, it's what I'm doing actually, and I've yet to see any problem with in.
Convert to a CSV and use http://php.net/manual/en/function.fgetcsv.php is probably your best bet.
Oh, I see the missundersting now :D that's is builder, agreed. But that's just example of produced code to collect. There could be `return new CustomRector` instead. Collector pattern refers to this part: https://www.tomasvotruba.cz/blog/2018/03/08/why-is-collector-pattern-so-awesome/#3-does-collector-scale
Now you are just saying nothing.
I'm glad you came one later to bust my balls about this. It was very important.
This is a great library. I haven't used it for reading Excel files, but it makes creating custom, well formatted, Excel exports pretty easy.
they already have the stable version, and yes, this library is my goto when dealing with spreadsheet files!
Yes! Prevent static / global state, leverage dependency injection (and interfaces/adapters), limit inheritance and you're off to a good start. Also: static constructors are useful for adding context and reducing cognitive load of a (large) constructor.
This depends on location. Symfony is still very much alive and kicking for complex applications in Europe. That being said, I prefer Symfony over Laravel as it fits my vision on software better. I think both (and others) can co-exist.
Have you posted this to r/symfony?
I'm not sure that's very objective thing, especially without hard numbers. When you have a persistent process serving multiple requests, many things you *have* to do in a normal PHP app, that would slow you down, like I/O, don't have to be done in a persistent app. For example instead of caching data to files, or using external out-of-process services like Memcache and Redis for this, you can just... keep it in a PHP array. It's now in local memory, ready to use. The moment the environment initialization is no longer a bottleneck, the incentive to grow your environment, in returns of reducing per-request computation and I/O becomes significant. To truly compare you'd need to have two apps designed for their specific environments in mind, not just a traditional PHP app slapped into ReactPHP to save you from the bootstrap.
Java is an excellent choice and IMHO one of the best for this type of stuff. 
I really appreciate it, if you suggest me a language which will scale without any rewrites or hassles at the scale of Facebook.
Look at your php.ini way at the bottom
So many levels of nesting. So little extensibility :(
Basic rewrites will probably always be neccessary. But a rewrite is not the same as writing your custom langauge.
Algorithm... if(true === true) return false;
What's that?
Thank you.
Great approvement!
Isn't a Symfony recipe some kind of bundle feature? It creates files at the right place by using composer require package
I know there are settings for exif, opcache, mbstring, gd, curl, openssl, but that does not tell me anything related to my issue. 
I did, but thanks for the tip!
Awesome!
Since functions can be namespaced, do you see a reason to still rely on static class methods rather than plain functions? You're right that stateless static methods can act like pure functions, but why misuse the static system while there is a perfectly fine solution to handle these cases: functions? 
What is your PHP version? Recent versions of PHP no longer have the mcrypt extension. It has been deprecated before and removed in 7.2, I believe. That might be your whole problem
Function autoloading is still missing from PHP.
doesn't have YET
Aaaaand 2.9 Mb of stuff (excluding trackers that are blocked here) to load a page :-\ 
I'm not related to it. I just like the design, the user experience, and even if the page size is quite bigger, it loads fast enough. The thing I like most is that they are still using Wordpress for the backend. Obviously, a supercharged version of Wordpress.
Go for Java - if you are familiar with OOP and if you like it then go for it. For web development there is awesome Spring Framework.
In Germany, loading that page costs 0.03 € of my mobile plan (and some swearing) :-P I know I'm being the usual jerk, but it's just a damn static page, c'mon! =_=
You might also have a look at Spring boot, which is an opinionated version of Spring. Try to use it with Kotlin. Some IDEs have features for Java to Kotlin conversion.
That sounds expensive :D Don't they offer unlimited internet data in Germany for mobile packages? (I'm talking about T mobile/Vodafone/Orange or whatever big Mobile Carriers exist in Germany)
Seconded. Firebase lib is extremely useful, although does require a few abstractions for dealing with selecting a key at runtime.
I´ve been in the same spot for a while. As others have already mentioned, Javascript is probably your best choice, given your fears about "wasting time". The time I spent trying to understand better the language and its unique features gave me a huge boost when I aproached to other interesting tools like VueJS or Angular. And that´s the big thing for me: it gives you the *posibility* to move part of your logic outside the traditional server side, and that´s interesting and valuable for some projects. Aditionally, I think that really different languages (Haskell, Go) are the ones that can give you a broader understanding of other programming paradigms and aproaches.
More languages you learn, easier it is to learn more. Learning a language you don't end up using much isn't a big waste, it still expands your experience and gives you insights into how to try and do things different in other languages, and once you pick up a few languages well enough you'll feel comfortable picking up more as-needed later. If you want the obvious choice for web-dev: javascript. If you want the most safe for programming jobs in general: Java. If you want something considered fairly easy to learn and very popular in general but not in web dev in particular: python. And although this is just an opinion, I'd say learning a language with a bigger ideological difference from the OOP/imperative focus of all the previously mentioned questions would have the most meaningful impact on helping you become a better programmer in general: maybe a lisp (racket is a good language to learn from the lisp families) or an ML (Elm is a whole language specifically for making browser apps' frontends, so it's also a potential plus for a web dev.)
Yeah, they just started with that: I'm planning to give away a kidney to get one of those...
I'd go for a closer to the machine language, some of them are very high level and not so hard. For example, Rust and Go are probably good choices. For others, I'd like one day to give a go C#, Kotlin, Java. Don't stick to web, learn statically typed languages for a change.
JavaScript for the work Kotlin and rust for the fun
A few days ago, someone post this link and its wonderful: http://goalkicker.com/ Free updated programming books in PDF
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; Since functions can be namespaced, do you see a reason to still rely on static class methods rather than plain functions? Of course: 1. Classes can be autoloaded on demand, functions can't (please don't cite the incorrectly named "autoload" feature of Composer, those aren't loaded on demand). 2. With classes it's much easier (and cleaner) to separate common functionality between static methods in a class as private or protected static methods. With functions this mechanism is missing, so you have to go by convention, say, another namespace. 3. In some cases it's possible to retain static state that doesn't produce side-effects, for example memoization (common in FP). With classes you have a place to store this state as protected/private properties, with functions there's no such place, aside from $GLOBALS, which isn't namespaced and it's accessible to everyone (so, that's very messy). &gt; You're right that stateless static methods can act like pure functions, but why misuse the static system while there is a perfectly fine solution to handle these cases: functions? There's no misuse. That's the very purpose of static methods. They come from Java which doesn't have functions, as they've decided they'll have classes as the basic unit of computing, and when they need context-free functions, they'll make methods (for reference, see the Math class in Java, which is very similar to Math in JavaScript). So, first, there's no misuse - that's the purpose of the static members. Second, functions aren't perfectly fin, due to the limitations I listed above.
I'm learning Rust at the moment: - It's modern language, like Go. There are many things that feel good and contemporary compared to PHP, which has a baggage of 20+ years of backwards compatibility. - It compiles to WASM, so there's still the possibility to do relevant things with it in the web world; the new Firefox rendering engine is written in it; GitHub is making a successor to Atom with Rust, it's safe to say it's a relevant language. - It's syntax is within the C family, so coming from PHP, things feel familiar. - One of the core features of Rust is its type system. Something I personally would love to see improve in PHP in the future. Because Rust is so young, and didn't have to care about backwards compatibility, they were able to do such nice things with the type system. When looking at Rust I often wish that PHP could be more like this. That probably will never be possible though. - It's also more a systems programming language, but that shouldn't stop you from learning it. IMO, web development should move more towards a system where there's the main server in PHP, and different services, modules or micro services in other languages that PHP can use.
I will just let it more clear on README.md thx
Start here: http://www.phptherightway.com
Some observation while diving into it as a new user: - As said, make plugins much more prominent. - https://reisraff.github.io/phulp/#!/plugins doesn't tell me much what a plugin does. I recognize keywords like "less" and "scss", but what is "filter" or "dest"? Should I care? A better description would be nice. - Project readme says "Create your Phulpfile:". What's that? Be more explicit. E.g. "Create a configuration file phulpfile.php in your root directory:". I saw it described in the docs eventually, but if you're referencing it make clear how to create it. - I started with https://github.com/reisraff/phulp-minifier but saw no output and was confused. As a new user I had to dive into the code to discover that I was supposed to call "-&gt;pipe($phulp-&gt;dest(&lt;mydir&gt;));" - Make use of github/composer tags. The main package has tags, but when I click on those (e.g. https://github.com/topics/phulp) it was the only repository. It would be nice to discover more of the available ecosystem (i.e. plugins).
Yeah, it sucked when I went to uni there (erasmus). I rented one of the uni managed appartment. In my home country (with unlimited data plans) I usually use just above 1To every two months. The internet plan allowed for 5 Gb a week (~21Gb a month), then cut the line until next monday. Didn't know about that. Burnt it all the first day. I ended up to 12 Gb a week (prof plan) a month later in exchange of some pen test of the uni network (which was crap, some of the most used router - canteen - had no real firewall). Had to redefine the word necessity in Germany.
As someone who also started with PHP, there are a couple of things that make sense to me. For one, a good front-end framework like Vue or Angular. No matter what server side language you use, you can still use the front-end frameworks which gives you versatility across platforms. Secondly, a server side language. I've moved into C# on the .NET framework which I like because it is applicable to both native applications as well as web. Also, with .Net Core, you can run it on a variety of OS's, so you are no longer locked in to a Microsoft environment. It is also still a widely used Enterprise language which has its own benefit. In any case, I would look for things that are pretty broadly adopted and not necessarily whatever the latest and greatest is. If you pick something that never becomes widely adopted, you'll spend time on something you have little use for. If it's just learning for your own edification though, go wild. //My 2 cents
Python is a fun language to be comfortable with. You can write powerful programs pretty quickly. Great for prototyping.
&gt;I unironically browse the Internet on my phone You deserve what you get.
Fun. How does it performs versus base64 on data size ?
Terribly.
Truth. This is pretty much what happened to the letter. All my clients are scattered around the globe. This client is the first in over a decade to be a local client, simply because I market globally rather than locally. I like it that way too, no one will ever say "hey, come by for a meeting". I like being able to not have a "professional" appearance and certainly don't want to waste my time travelling needlessly to a meeting when it can all be done over the phone. But with this client, they found that I was local to them, called one day, and the rest is history. The first phase was completely rewriting the code from the previous and shoddy developer. I created from the ground up a new system, and they were quite happy - except for the costs. They weren't happy about my hourly rate, and this became a stress point. We reached a point where there was so much friction when it came to invoicing that I walked away explaining that I have clients that never complain and even pay a retainer for services, and called the project toxic. About a year later, I hadn't heard from them, but just as you mentioned, during that time they tried to hire an in-house developer who wound up never accomplishing anything, and they had to let them go. Then they called me back, making all sorts of promises to pay without complaining the hourly and to also pay on retainer. They admitted that it is hard to find real talent in the industry. At some point during this return, they brought in someone else in-house to assist. This is what spawned this thread. Originally, the new dev was working on a different section of the application, but has recently been encroaching on the territory I've been working in. This lead to my current concern. We spoke on Monday and I expressed my concerns, which this thread helped me get in order. They agreed to work towards a solution and had another meeting yesterday in which we all defined pecking order and how best to handle updates and versioning. This is great, as the client is listening and understanding, and we are working and making this all fit together.
&gt; Static methods used in production code are hamful in context of growing codebase. Not only because of global state, but because being hardcoded dependency, and it can become a debt that is very hard to get out from. I already address global state, I said "static methods aren't harmful, static state is". So let's get state off the table, we don't disagree there. Static methods don't imply static state. As for them being a "hardcoded dependency", you have plenty of hardcoded dependencies in your code. Every time you write a typehint - that's a hardcoded dependency. Every time you use a built-in function - that's a hardcoded dependency. You can't make everything configurable, that's a fact of life. The trick is to choose wisely what should be configurable (or "injectable" if you prefer that word) and what simply doesn't have to be. And as you yourself say, guessing wrong is not a complete dead-end, if you write code in a way that's susceptible to easy refactoring. &gt; Utility classes are dangerous and pretty much useless, unless raising up to some (both) stable (and) standard. The default assumption is that code that's used by multiple parties doesn't just change arbitrarily, so "stable" is assumed (as stable as any code is). As for "standard" that's very subjective. If you write a utility class to be used within a specific library, then it only need to be "standard" within the library. That's a low bar that's easy to clear (you almost clear it by default). As for them being "dangerous", I don't know, you have to be specific what the dangers are, and what are some less dangerous alternatives. If we take the infamous StringUtils as one example, what would you replace that with? A String object? That'd hardly help, would it. But I'm listening. &gt; No anti-pattern, language construct or paradigm is becoming a problem right away. At the root level you don't have architecture yet, and design patterns are not direct problem solving algorithms - you can go without them, but you'll miss the point where you shouldn't. I didn't discuss any design patterns, and you didn't name what anti-pattern you're referring to, or what the perceived problem is supposed to be. Virtually all platforms in existence have static elements in them. Be it OOP, be it FP, be it procedural languages, make your pick. So if you'd just call the existence of stand-alone functions or static methods an "anti-pattern", then it's an anti-pattern with no counter-examples. Let's take one example I mentioned. Java's `Math`. If that's an anti-pattern, what's the alternative? &gt; Don't place static method calls next to functional programming, because you open door to dismiss all design discussions this way I've no idea what you're talking about. Functional programming is chock full of standalone function calls, which are identical to static methods in OOP. It's not me placing them together, they stand together conceptually regardless of our opinions.
I just want to point people to https://gist.github.com/joepie91/7e5cad8c0726fd6a5e90360a754fc568 You don't necessarily need wildcard certs. In other news, ACMEv2 support is coming very soon to Caddy. https://github.com/mholt/caddy/pull/2072
"This is so stupid, it’s awesome" said Arne Bahlo on Twitter https://twitter.com/arnebahlo/status/973464419442315264
Why does Ecoji make more sense when it's human facing data? Instead of a mere 64 "simple latin alphabet" (ASCII) characters, you're now dealing with images, many of which are very similar and the display of which can vary from system to system. Base64 was never designed for either "human facing data" or compression. The entire purpose of base64 is to allow transmission of data over transports which may only be able to deal with (basic) ASCII characters and avoid delimiter collision issues (CSV / TSV, translation of line endings).
Said some nobody with less than 1K followers on a 9-year old irrelevant social media account on the Internet.
Ecoji is way more fun, so maybe people would actually verify hashes! Seriously though you are correct, different fonts could be a serious problem for verification. Personally, if I were to ever offer Ecoji for verification purposes I would also offer base64.
&gt; different fonts could be a serious problem for verification Fonts doesn't matters. Charset does. This encoder works in a single charset, while base64 was built to avoid this issue.
Are you salty, saltub ?
I updated the Ecoji readme with a disclaimer about the implications of different fonts and similar emojis. Ecoji is fun, but security trumps fun, so I updated the readme.
This is the best tl;dr I could make, [original](https://community.letsencrypt.org/t/acme-v2-and-wildcard-certificate-support-is-live/55579) reduced by 57%. (I'm a bot) ***** &gt; We&amp;#039;re pleased to announce that ACMEv2 and wildcard certificate support is live! With today&amp;#039;s new features we&amp;#039;re continuing to break down barriers for HTTPS adoption across the Web by making it even easier for every website to get and manage certificates. &gt; ACMEv2 is an updated version of our ACME protocol which has gone through the IETF standards process, taking into account feedback from industry experts and other organizations that might want to use the ACME protocol for certificate issuance and management some day. &gt; Wildcard certificates can make certificate management easier in some cases, and we want to address those cases in order to help get the Web to 100% HTTPS. We still recommend non-wildcard certificates for most use cases. ***** [**Extended Summary**](http://np.reddit.com/r/autotldr/comments/84n137/acme_v2_and_wildcard_certificate_support_is_live/) | [FAQ](http://np.reddit.com/r/autotldr/comments/31b9fm/faq_autotldr_bot/ "Version 2.00, ~296667 tl;drs so far.") | [Feedback](http://np.reddit.com/message/compose?to=%23autotldr "PM's and comments are monitored, constructive feedback is welcome.") | *Top* *keywords*: **certificate**^#1 **wildcard**^#2 **ACMEv2**^#3 **HTTPS**^#4 **Web**^#5
Good point, I forget that the world has not completely moved to utf8 yet. Base64 works almost everywhere without problem, attention to detail is probably still needed with EBCDIC :)
&gt; in search of a problem with no obvious practical application One application I thought might be fun is a URL shortner that uses something like Ecoji. However, I don't know if it would work. I suspect folks here would know what the problems might be. Something like http://es.io/🎌🚟🎗🈸 
Python / Django is a joy for Web development. And also check out the Django Channels app which adds realtime/websockets features to Django.
Except for fax machines, nothing is future proof.
Using [Flask](http://flask.pocoo.org/), for example :)
Nice. Wordpress is awesome. All my clients are on it and happy :)
base64 is.
Thanks for the advice. I've done that... 
&gt; So I shouldn't mind adding more on top of that (untill they're stateless of course)? I've mentioned standard ones btw. To make the claim "you're adding on top of that" we need to see the alternatives and how they help you decouple your code. You can turn a class of static methods into a class of instance methods. That gives you the ability to make multiple instances of it, but if it has no stage, that's meaningless. You can also refactor the class to be an interface, and a class implementing it, but if you are quite certain the functionality is local or universal and you will never need alternate implementations, that's also meaningless. So what else you can do? Let's talk specifics here, instead of just repeating "static bad!" in a 100 different ways. &gt; They're hard to change as any hardcoded part of code spread all over codebase - don't act as you don't know that. The word you use betray the problems in your software architecture. "Spread all over the codebase". So this tells me you have a large monolithic codebase in mind. The problem isn't necessarily the use of static utils, but the fact you're not writing modular software, that can be refactored one small module at a time. &gt; Alternative is using built-in (ugly) standard lib or making it part of implementation - even at cost of repetition. That's... wait, when I said "propose an alternative" it was implied that I'm asking for a better alternative, not a worse alternative. Are you kidding? Which is more hardcoded - referencing a static method 10 times, or copy/pasting the same code 10 times? Spend a moment reflecting upon this before you start hammering the keyboard. &gt; I know; all; the one that makes them anti-pattern. What you should've understand from that sentence is that Your claim about static methods can be made about any of them in limited context. This sentence doesn't make sense. I asked what anti-pattern you're referring to. "All" is not an answer.
I understand that this is about a speed up for running all the test. But I do not understand why this should be any different for a CI build compared to, for instance, a developer who wants to run all the unittests to check if his changes did not cause any regressions. Everyone (both CI and developers) would benefit from phpunit-slicer to execute the slices in parallel automatically by just calling phpunit-slice in a single command. This could be accomplished by phpunit-slicer by, for example, forking into multiple processes executing the individual slices. Something like this ./vendor/bin/phpunit-slicer --number-of-slices=3 |`-- ./vendor/bin/phpunit-slicer execute-slice --slice=1/3 |`-- ./vendor/bin/phpunit-slicer execute-slice --slice=2/3 `-- ./vendor/bin/phpunit-slicer execute-slice --slice=3/3 Please note that I do not want to give the impression that this package is useless. But compared to splitting your tests by group manually, I feel that the only benefit it gives is that the number of tests per process is more evenly distributed. 
Python, and C
There are probably 20 PHP jobs for ever 1 Java job. Furthermore, with good design principles and knowledge, you can easily become a Director or CTO since the majority of PHP developers will be either self taught or clinging on to old ideas and paradigms.
Ruby. But not Perl. I don't know a single person still doing Perl. I would also recommend Ruby.
Hmm! Immersing thanks, i learnt something new today. 
More than a language i would choose a new technology, for example Android Developtment with Java is very entertaining
&gt; you're not writing modular software, that can be refactored one small module at a time. One small module with all the utility classes it drags behind? - Right. I'm not writing these kind of modular software.
An alternative https://github.com/paratestphp/paratest
No, your code has no dependencies, I'm sure. Your code is directly etched in silicon and runs on low-voltage power generated by the ambient quantum foam fluctuations.
The downside is that neither C extensions nor most PHP libraries were designed to work with an event loop, unlike with node.js. 
&gt; One small module with all the utility classes it drags behind? - Right. I'm not writing these kind of modular software. No, your code has no dependencies, I'm sure. Your code is directly etched in silicon and runs on the kinetic energy generated by ambient quantum foam fluctuation... You once again you unintentionally betrayed your ignorance on software architecture here. We don't write modular software to reduce the total number of dependencies in our project. We do it so the project is made up of encapsulated units, which can be maintained and refactored independently from the other units, as long as you maintain the public API. Which also means you can change the dependencies of module Foo without affecting other modules that depend on module Foo, as long as you preserve Foo's public API. Also, in most projects utility classes are a small % of the codebase, because the higher level a component is, the more likely it is it'll have state, and then making it static is no longer recommended. Utilities are intended for lower-level stateless reusable code. So it doesn't fit to use expressions like "all the utility classes it drags behind".
If you have a bunch of different mutually exclusive statuses, modeling it as a state machine is generally a great way to go. This avoids having to add checks like this because you explicitly model each possible transition.
&gt; But I am a Web Developer. I earn my money only with web content and I want to do my projects within the web, so currently I don't need to learn something else, because I already know the languages that allows me to everything in the web with the easiest way around. No need to learn Python, Java, Ruby&amp;Rails or whatever. I suggest you take a look at [Phalcon](https://phalconphp.com/en/) if you truly believe there's no reason to supplement your PHP knowledge with other languages. 
It is 7.0. I dont have any requirements for the latest and greatest php. But another comment on this thread has a good hint for me.
Do you know "Clean Code" book? This is shorter, about PHP and with examples. https://github.com/jupeter/clean-code-php - great places to start
[removed]
Cool thanks I will check it out! 
Awesome thank you!
I wonder if his belongs here anymore, given HHVM has completely given up on *being* PHP.
Hello, Response to comment on the article page
Thanks for the feedback. I'll look at adjusting the initial code using a single route handler
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I really don't think that exclamation point is warranted. Does anyone who doesn't work for Facebook even care?
If you are willing to spend $15, subscribe for a month to [Laracasts](https://laracasts.com/). It is focused largely on development using the framework "Laravel", but it is not exclusive to that. There are several free lessons, including the first one of [this series](https://laracasts.com/series/object-oriented-bootcamp-in-php) which I think will perfectly suit what you are looking for. If you like it, subscribe and watch the whole 10 episode series. It will take a couple hours and you'll be much better off. Watch more of the series on the site and you'll pick up quite a lot.
&gt; Yet, I see thousands of repos and gists setting up Pimple and Monolog. It's unclear how this relates to your question. You see thousands of repos do what exactly? Pass the container to constructors? &gt; To make use of the container-di/logger, I would need to call the container inside classes and that does not sound right. It would be injecting the container-injector. Why can't you fetch the logger in the model constructor and pass the logger directly? &gt; But if we are not to inject the container inside a class, why are there so many Pimple service providers/repos that suggest calling Monolog via Pimple? Can you link to an example of a repo "suggesting" that?
I really like codecourse.com. Alex is really good at explaining and breaking things apart. He has some a couple of good projects on there you can follow along with. He explains Laravel, js frameworks like vue and even creating your own framework from scratch. Check it out!
Try using a command bus pattern. It can really help focus on separating data from operations.
http://www.phptherightway.com/pages/Design-Patterns.html Design Patterns: Elements of Reusable Object-Oriented Software book is available at Amazon. No monthly subscription. Don't waste your money on these monthly subscription service.
OO design and class responsibility is hard to do right. There's no "correct" solution. It depends entirely on what your application is doing, how you personally think about code design, and how others on a team you might work with think about it. I use four questions as my guide to determine if my code is well designed: 1. Can I easily test it? 2. Is my implementation as dead simple as it possibly can be? 3. Do the related collection of classes I've designed present a simple, intuitive API that is easy to work with? 4. Is it easy to understand what the hell the code is doing? If so, then I consider the code well designed. SOLID design principles, general concepts like polymorphism and encapsulation, and design patterns are tools that *may* help you achieve those goals if applied correctly, but they should not be goals in and of themselves. If you start thinking about the structure of your code as "It has to be Open-Closed this, and abstract factory that", you will end up writing some really gnarly, incoherent code. ***Don't implement patterns and principles for the sake of implementing them***. 
&gt; Why can't you fetch the logger in the model constructor and pass the logger directly? That is precisely what I do. 
If that’s what you do, your question is very unclear. 
I'm having trouble following exactly what you mean. It might help to include some examples of what you're seeing in outside repos and what you're doing in your own code. I'll take a shot without those, though. You should define an instance of monolog, as well as your controllers and other classes as services in pimple. The pimple configuration should take care of injecting the services into the constructors of your controllers and model classes. You do not need to inject the entire container into your classes. Here's a simple example that I hope illustrates what I'm saying: // Configuration $container['logger'] = function ($c) { return new Monolog(); }; $container['welcome_controller'] = function ($c) { return new WelcomeController($c['logger']); }; $container['emailer'] = function ($c) { return new MyEmailLib($c['logger']); }; // WelcomeController.php class WelcomeController { function _contructor(Logger $logger){ $this-&gt;logger = $logger; } function helloAction(){ $this-&gt;logger-&gt;alert('Saying hello.'); return Response('Hello, World.'); } } // MyEmailLib.php class MyEmailLib { function _contructor(Logger $logger){ $this-&gt;logger = $logger; } function send($to, $body){ $this-&gt;logger-&gt;alert('Sending email to ' . $to); return mail($to, $body); } } 
Thank you! I think I need to find the balance between doing things the correct way but not overdoing it.
If you are concerned with riddling your controllers with loggers, you can look into injecting it in the component that actually executed your controllers. If that isn't possible, you could look into AOP. I'm not too familiar with pimple and it might be easiest in your case to solve that with a decorator for your controllers. See aspect oriented programming and the decorator pattern.
A proxy might be even simpler than the decorator in your case.
Use PDO.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I prefer vanilla mysql_functions. The best is to start with basic user input.. something like $query = mysql_insert("INSERT INTO users SET username='{$_GET["username"]}', password='{$_GET["password"]}'");
Strictly speaking, for the queries shown in this sily article, PDO calls would be almost identical. Yet nevertheless, I second the advise in general
There are certain issues in your article(s). First and foremost, the error reporting is completely flawed. Some PHP users have a notion that a beginner's code should have intentionally placed commands to report errors. In reality, it's but a delusion, and a harmful one: - First, PHP can report errors by itself, no assistance required. - Second, all noobs take this ugly approach as an example to follow and replicate it in their production code. Please read the article of mine, [PHP error reporting basics](https://phpdelusions.net/articles/error_reporting) mysqli_select_db() is a rudiment and should be thrown away. As it's said in the other comment, the simplicity of mysqli is a deciptive one. When it comes to the real life code, involving prepared statements, mysqli turns into a great struggle for the noob. Better to teach them PDO from the start. 
here goes a blood bath...
Oh, don't you worry! In step 2 I talk about escaping.. It's easy. foreach($_GET AS $i =&gt; $v) { $_GET[$i] = mysql_escape($v); } Taken care of bud! My server is hardened from a clinic I took online a few years ago so I don't need to worry about encryption.
&gt; I just completed a 5.6 -&gt; 7.2 jump on a 10 year old codebase last week I just completed a 5.5.9 -&gt; 7.2 jump on a 10 year old codebase last week, either :) My problems so far: - moving mysql to mysqli, - no mcrypt, used PHP polyfill, - no php-clamav, used clamd + socket client, - my Exceptions handler stopped working, as they couldn't caught throwable, - my classes had some reserved keywords like "Object", had to rename them. So far looking good. Migration it's really smooth experience.
and here goes another... Neither mysql_insert nor mysql_escape are "vanilla mysql_functions" for starter. 
That’s why he aint hacked yet
Mess with the best, die like the rest... naw sayin?
I would do it in one go, less time investment.
To tell you truth, the folly about password hashing is not the only one in your fabulous posts. I dunno whether you're lived on the Moon for the past 20 years or just joking, but just to let you know - whatever *mysql_insert* and *mysql_escape* are anything but "vanilla mysql_functions" - speaking of the latter, there is no such thing in PHP at all: care to open your eyes: http://php.net/manual/en/function.mysql-query.php - this foreach stuff mysql_escape below is an ugly mocking of the magic_quotes feature that has been removed from the language LONG time ago. - die("Error!!!!") is a ridiculous way to report errors 
I'm not even sure what's the purpose of the log here. If it's just a debug logger, mine's deliberately static, so it doesn't have to be injected (you only need one debug logger per project anyway). If it's an application event system that's the domain logic depends on, then I make an effort to inject it properly.
I meant mysql_escape_string(). It's hard keeping track of all the people I'm helping online getting into PHP you know? die() is great, it tells you when there is an error.. what's the problem???
I do. HHVM is the greatest motivation to make PHP better. Those benchmarks before PHP 7.0 put pressure on PHP to be faster and evolve in architecture: scalar typehints, strict types and AST. So I hope they keep up great work with HHVM :) 
10 years working with Drupal, numerous contibutions, modules, I do maintain lots of sites using it, and there is no surprises for me: Drupal is complex, overly complex under numerous API's and very long to learn and masterise. Most people use it instead of a framework for very simple use cases because Drupal is very fashionable and their clients ask for it, disrespecting its primarily use case, which is editorial websites. The end result is very often that technical teams that don't know the tool are forced to use it, and they do it wrong because nobody took care of train them, ending it in very expensive and very buggy Drupal sites, and tech team that end up resign for their job, disgusted by the huge project failure they just had. Believe me, I do often personally expertise/audit Drupal sites done by other companies, sometime rejoin the team and help them get the project done, and I did saw it, a complete team quitting their company because of such project. I'm not preaching against Drupal, it has valid use cases where it works marvellously, but it's definitely not a golden hammer and a huge lot of people use it where they should not.
oh. you're helping people online? poor creatures. I'm not sure they'll be able to recover in their lifetime
You're wrong, Wordpress is the most hated platform/CMS. And the main reasons for this are: 1) It uses PHP (which is good) 2) It's the most popular/user friendly/security tested CMS (which is also good)
It is user friendly, but it's not a CMS.
You're right, its a blogging system platform but lots of peoples use it as a CMS also.
Windows phone was on that list? People use these? People have to develop for them? Wow. As for Drupal. Never had to use it and I skim right past those jobs because I don't want to learn something massive and niche like that. Is it worse than Magento?
http://www.phptherightway.com/
Go to the library and skim through some books to you see something you like. If its a few years older thats okay, use the internet to catch up from there. Many many years ago I taught myself with this one https://www.amazon.com/PHP-MySQL-Web-Development-4th/dp/0672329166/ref=pd_lpo_sbs_14_img_1?_encoding=UTF8&amp;psc=1&amp;refRID=MX0CNNA5F6P8BBSAD4J7 from a library. I like free shit though.
Other than creating fun projects, you can also help others by answer [questions tagged with PHP on Stackoverflow](https://stackoverflow.com/questions/tagged/php). It forces you to explore new problems, reading and stepping source codes of big frameworks, through the exploration you also learn new coding skills from professional programmers, like the smart use of bitwise operator that amazed me the first time I saw it.
I do not know why people hate Drupal, never used it. But I can tell you that one of the biggest reasons why people hate Sharepoint is the fact that you have plenty of people certified as "Sharepoint experts" who can't read two lines of code to save their lives, and get paid handsomely because "MS certified me with your money". Met around 15 "Sharepoint experts" between consultants, contractors, and normal employees in companies I either worked in or with, from these, 3 knew how to code in Sharepoint, everyone else would drag and drop their little boxes and set their flows and then yell at whoever dev (not me) that they needed to "CORRECT THIS SUPER URGENTLY". The funniest situation I remember was this dev I knew who kept switching to code view because his "Sharepoint Expert" constantly got the name of her fields wrong, and instead of him correcting it on the GUI, he would just switch to the code view and correct the names. He was earning about 60% of what that "Expert" was earning. I chuckle when people talk badly about the php community and php in general, hope they never have to deal with the SharePoint professionals I met (except for those 3).
I'm guessing this is a "PHP The Wrong Way" spoof account?
yeah, looks like! 
[I'm just using everything I've learned here...](https://www.reddit.com/r/PHP/comments/25mdqi/10_things_i_learned_from_rphp/)
`mysql_*()` has been removed from PHP 7. This is why people are suggesting your examples are controversial. You should be using either `PDO` or `mysqli_*()`. Notice the `i` in the name. It's important.
It's the same thing for Wordpress.. The amount of big ass sites I've made in Wordpress which very last function is a blog (if even having one) is hilariously high.
Render arrays, poor documentation compared to Symfony and Laravel, the REST support has a lot of quirks, not adopting PSR-2 code style like WordPress, etc… 
&gt; If you're comfortable using bleeding edge technology like php7 It's been deprecated in PHP 5 as well. Also PHP 7 is not "bleeding edge". It was released in 2015. It's now 2018, and it was already followed by several stable releases like PHP 7.1 and PHP 7.2. Even tardy platforms like Ubuntu and Debian have picked up PHP 7.2 recently in their LTS releases. &gt; but you need to support the clients on PHP 4.x and PHP 5.2 still OK, you're trolling. You can't be serious. Look, you can listen to feedback. Or you can just keep saying stupid shit and people will laugh at you. Choice is yours.
Build something.. that's the best way to learn. The first thing I did 16 years ago was "I'm going to build a website in PHP that can do this, this and this." Then I went overboard and made a point of sale *shrug*
Whatever man, this whole industry is so toxic. I try and step in and help someone writing an article on mysql functions and I just get blasted. I have like almost 25 years experience in PHP/FI. I think I know a thing or two about those mac operating systems you're talking about... and they definitely don't include PHP 7.1 or 7.2 in their yum updates.
I didn't blame you for *trying to help*, I'm just telling how your help is inconsistent with modern security and standards. &gt; I have like almost 25 years experience in PHP/FI. I think I know a thing or two about those mac operating systems you're talking about... OK, shit I'm ready to bet a lot of money that you're trolling. Thanks for the laugh, though.
Defining a CMS as such is reductive. Basically, I was doing the same mistake a few years back, but you can define what is a CMS only by comparing the existing solutions and their features. Doing so, I would define Wordpress (I mean, a vanilla wordpress) only as being a blog engine rather than a full blown CMS with advanced features as you would await for. Nevertheless, reading https://en.wikipedia.org/wiki/Content_management_system we could categorise somehow Wordpress as being a CMS, with only one of all the enumerated features. So to conclude, I would say that either you see Wordpress as an excellent blog engine and editorial site, or as a very bad CMS.
**Content management system** A content management system (CMS) is a computer application that supports the creation and modification of digital content. It typically supports multiple users in a collaborative environment. CMS features vary widely. Most CMSs include Web-based publishing, format management, history editing and version control, indexing, search, and retrieval. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^| [^Donate](https://www.reddit.com/r/WikiTextBot/wiki/donate) ^] ^Downvote ^to ^remove ^| ^v0.28
D7 was the pinnacle. However many other frameworks have leaped ahead, unencumbered by legacy requirements. It seems like Laravel, Symfony, etc. have traded off support of older PHP versions to make their systems easier to deal with.
Been reading a ton of this and I think its exactly what I've been wanting. Thank you!
Cut the crap, Wordpress is a CMS. A limited one? sure, but a CMS none less. Stop the bullshit please.
It is a CMS. You can define your own content types. People use it as a blogging platform because it comes configured for blogging.
Poor child.
&gt; Poor child. You are the kid who needs a good slapping for lying.
1. dump MYSQL 2. install PostgreSQL.
&gt; The truth is a wordpress with a few modules would deliver a similar experience with a much better and straightforward backend. Nope
"bleeding edge". Who are you kidding? PHP7 is a safer, faster and better PHP.
I pretty much agree with you. Drupal has such a steep learning curve, and the state of documentation in D8 is woeful. It's so easy for a Drupal project to devolve into a total mess. I think things will improve, particularly with the introduction of much more modern PHP practices, but it's glacially slow. When it's used properly it's very good, but that's incredibly hard to do even for experienced developer teams. Having said that, there's very little out there that can give you so much functionality and configuration out the box, particularly open source
kudos on the trolling man :D 
read this thread further, there's more!
&gt; can you tell how much knowledge is recommended to have to start freelancing with php? Go to any freelancer websites, register and watch different jobs. Ask your self, could you do the most of them and can you compete with the others enough, that you get each month enough money back to survive and pay taxes?
Sounds like most Oracle consultants too. Or maybe just consultants in general. Oh god, flashbacks to Accenture, nooo....
Have you considered another occupation? An artist, a fitness coach, an insurance agent perchance? 
Ehh. What are you doing on /r/php asking for salaries in other languages? o_O And without providing up with your location... This is not /r/wildwildguesses
&gt; there's very little out there that can give you so much functionality and configuration out the box, particularly open source I do agree with you about this, even if, in my opinion, Drupal core dev until a few years back (even after releasing Drupal 8) still did focused on useless or not-so-important features and lost precious time that could have been used to polish its UI. Now it seem they have changed and step by step improving the product, which is great, but too late in my opinion. Anyway by trying to fit "modern PHP" into what is being called "drupalisms" it made the product much more complex than it should be. There's a lot of API's in there that could have been built simpler while retaining the same level of features. For example, the whole Entity API is a practical joke, although it has already been fixed in some ways. The whole entity-ception, seriously, it's overused and terribly opaque for newcomers, it's just pure offuscation.
I once met a former consultant who basically bragged about not understanding anything about NetWare when he took a project and just leafed through their admin guide on the ride over to the customer's place.
It's a blogging platform that's been hacked to look like a cms, which is also it's greatest limiter when you really try to use it for something other than blogging. It has a technical ceiling and if you haven't hit that ceiling you haven't used WordPress enough.
My thoughts exactly. The post pretty much had everything in it needed to trigger the "real" developers. You don't get this sort of thing by accident. Well done indeed.
&gt;&gt; it’s fairly impractical to write Hack without using PHP libraries at the moment &gt; We’re doing a lot of work on making the second point not true I don't quite understand. Are you rewriting a ton of popular libraries in Hack? Will there be well-maintained ORMs and API integrations for existing services from other companies and YAML parsers, logging providers etc.?
&gt; This is like someone asking if learning how to use a hammer is "worth it", because someone told them carpenters make good money. &gt; I want to become a freelancer because working for a boss and 9-5 is killing me. That's not really a good reason to learn to be a programmer.
On the second thought, may be he has sort of dyslexia, starting with one sentence and finishing with another, and just can't help it. Sort of what Doc from The Boondock Saints had.
There's a lot of work, many people are making good money from any type of programming. But keep in mind that the entire industry is a tough one, you'll always be learning. If that's not your thing, fine, but choose something else. If you like digging into things, if you like logic, if you like to understand other people's problems and helping then figure it out and (possibly) fixing them, this field might just be a good fit.
I'm curious, what is the technical ceiling for Wordpress? I mean, for example, what did you run into that couldn't be done? I've been using it awhile and haven't run into anything yet that couldn't be done, but if there is a limit I'd like to be aware of it.
This technical ceiling you're talking about is as high as your understanding of Wordpress inner working. If you think Worpress is just good for blogging and portfolio websites, you clearly have no understanding of its customizability.
As addition to FrenkyNet's comment there will be days you'd rather prefer digging trenches on a street than looking for bugs. But the result of fixing one is quite comforting. Even when you notice you've wasted hours in order to change a single line of code. So yes, if you like everything FrenkyNet's says... this will be probably a world you enjoy in the future.
True, however those languages also adopted modular design; so you are encouraged to think in terms of small problems, which is where dynamic languages really excel. Similar to PHP though, [Microsoft went and solved JavaScript's lack of scalability](https://www.typescriptlang.org/) about 5 years ago; and was so well received by the community that today [TypeScript is more popular than JavaScript](https://insights.stackoverflow.com/survey/2018/#technology-most-loved-dreaded-and-wanted-languages). As I said though, my problem isn't necessarily with PHP; it's with people masquerading around as experienced software engineers, without even a basic understanding of software engineering principles, or care for security.
So if both Drupal and WordPress are so godawful, and we don't even talk about Joomla anymore; what other options are there for a good and user friendly (in the sense of content management) CMS?
&gt; Drupal is very fashionable lol
Casually I've been looking for libraries that implements merkle-trees, the same algorithm that works for the Blockchain and seems to be some pioneers working/playing with that. For example https://github.com/pleonasm/merkle-tree Obviously won't be as fast as C implementation but I've never underestimate the possibilities. The algorithms are language agnostic, so no matter what language you use, the important thing is to use it in a manner that covers what you need right now.
I was being a sarcastic dick, but thanks for bringing that to my attention, I've not looked into merkle trees much so it'll be interesting to see how they've implemented it.
What's wrong with Accenture? Generally curious since I've only been working professionally for a out 7 months now.
The latest version of Drupal is now based on Symfony. Also there is no way [Wordpress adopts PSR](https://make.wordpress.org/core/handbook/best-practices/coding-standards/php/)
Thanks for saying this. I bet you $1,000 no one uses Mongo or Angular in 10 years. React has already eclipsed Angular for example. There is no future. Software changes every 10 years. Learn how to learn, not specific frameworks.
D7 was a dumpster fire.
They hire the cheapest people they can get straight out of college and give them a crash coarse in programming for a month then assign them to projects. The people that move up due so via company politics. It's basically the kind of company you hire if you want a half-working insane minimum-requirements system that you'll have to hire others to fix afterward. 
PSR has been dead since the SJWs took over and kicked its founding member, Paul, out.
I once had a client insist I build them a resume and application system in WordPress, which later needed things like time tracking, certifications, etc etc. In the end they had maybe 6-8 pages of content that WordPress was actually good for and a year worth of development on a system for HR.
Second that here on the documentation. It is inexcusably bad. Part of the reason for this is that a lot of Drupal developers have the mindset that you must learn to speak Drupal and their unwillingness to bridge the gap between Drupalese and natural language. When there is documentation, it's often written towards those who already have a deep understanding. The community seems pretty unwilling to bring people in. There are next to no good free resources, and the paid services of businesses like Drupalize.me fall far short in quality of free resources you can find for most other frameworks. Also, theming in Drupal is just awful. You have to crawl through so many necessary layers of templates to get to the fields. Most of the time when I'm developing with Drupal, I feel like I'm working against it, not with it.
"This is probably largely due to the fact that Drupal has gone after the enterprise market and there is a much smaller number of installations it can potentially reach." .....or it's because many fanboys respond to issues with "Drupal isn't wrong; you are!"
Didn't know they made that update! Thanks :)
We’re not cloning any libraries, or aiming to create replacements for the entire PHP ecosystem; ultimately, for hack to be successful, there will need to be a community creating and maintaining libraries. That said, we feel there is a baseline of functionality that must be available before we can expect that to happen - and we’re not there yet.
Actually, for a long time, Drupal documentation always has been very good, especially the API documentation in https://api.drupal.org but I agree regarding the community documentation on the main core Drupal site.
I help a company develop some websites using Wordpress, how do you keep everything updated and working?
&gt; It's because when you start to get into it's inner workings it starts to fight you and show you it's limits. You don't fight WordPress; it will always win. Go with the flow and use it for what it's good at - content. But if you want to turn it into a custom application, then you will have a big fight on your hands.
yah that was my conclusion
Ah that sounds interesting yeah, I'll check that one out. Reason I'm asking is that my father's e-commerce site is long overdue of some serious updating. Had a small agency build it quite a few years ago and they went with drupal + ubercart. It's worked, but god it has _issues_.
Sorry to be a party-pooper, but this already existed: https://github.com/jwage/phpchunkit Also, full disclosure, I'm the maintainer of Paraunit, an other PHPUnit parallelization tool: https://github.com/facile-it/paraunit
&gt; .....or it's because many fanboys respond to issues with "Drupal isn't wrong; you are! When you treat a CMS like a religion...
I think it was marketed as a Wordpress competitor and it shouldn’t have been. It’s also old enough to have horror stories, and it’s likely that most people who remember hating or being confused by Drupal haven’t touched it in years. 
&gt; both Drupal and WordPress are so godawful Hey now. Let's keep the focus on Drupal. WP has got enough hate. &gt; good and user friendly Good, in what regard? Good for budget? Good for users? Good for developers? There are lots of "good" and they don't always have the same goals. Both of their code-bases are like a time machine to methodologies of days gone buy with modern practices starting to get put in. WordPress is more user friendly than Drupal but Drupal offers more options out of the box. From a development perspective, they both have their issues. Just depends on what a dev has experience with. Plus, I work at a place that does stuff for clients. Time and materials. I can't go dropping in some third or forth tier CMS just because it tickles my developer jollies. We stick with Drupal and WordPress because they have name recognition, documentation (better for WP), and third party support. 
Why don't you ask your seniors for resources? That way it will be most relevant to your employer
Some of those horror stories are still true though.
Fuck'em. When I make WP I use PSR.
I have asked and got nothing back :( 
Seems like an inspiring work place
It has been a learning experience...
The short answer is Drupal allows you to use it as a framework when it should really just be a CMS, but when you use it as a framework it quickly becomes a disaster because people mostly just make custom modules and there's little structure to anything beyond "this is a class with all this module's functionality" A lot of agencies will also use Drupal when building one-off stuff because it's free and pretty easy to set up and you can find low-level PHP developers to work on it, which usually leads to the issues I mentioned above. I've interviewed so many Drupal developers and they range from people who only know CSS and how to make themes and install plugins to mid-tier PHP developers who have never worked outside of Drupal. Drupal itself is also frustrating for anyone who has worked with more modern PHP frameworks because everything is structured in a way that worked great in like 2008 but has since had better solutions. So much weird magic and random functions running without much indication. I don't know if D8 is better about that stuff, I haven't had to work with it yet, but D7 could be a weird nightmare when you wanted to track down something.
Don't forget TYPO3 :D
Can someone ELI5, because i literally cannot see the use case?
While Wordpress definitely has it's place and it's more often the right choice instead of Drupal. You'll never see something go as wrong as Wordpress when it's not used for its proper purpose. Its backend is far from straightforward and I've never seen such horrendous DB management. It all comes down to the right tool for the job.
I work Drupal all day everyday and know it in and out. Every word you said is true, and I don’t even recommend it for enterprise level anymore. I think Laravel and Symphony are better solutions, and Craft is pretty capable as well. There’s just rarely a reason to start a new Drupal project anymore. 
I’m a Drupal dev. What can Drupal do that WP can’t? 
Well first there is a huge difference between D7 and D8. At least D8 *tries* to be OOP. While I think Drupal is moving in the right direction, I think it is poorly designed and dragged down by shitty legacy developers who refuse to learn good modern programming practices.
There are still lots of issues. Not adopting PSR-2 is bad, regardless if Wordpress does it. The render arrays are hideous. Also the crazy reliance on things like hook functions makes things clunky and nasty. I will say D8 took a leap in the right direction though.
Imho php has serious flaws because it doesn’t follow sound principles. But that doesn’t mean you can’t use it. Facebook is not a no name company and they use php. Some people in college have no real world experience and only evaluate things from their narrow perspective. To avoid getting angry and avoid negative attention towards you I suggest you look down on them for being so ignorant and dogmatic. Draw confidence from your real world experience 
Just because there are great features in other languages doesn't mean that their release announcements belong here. If PHP takes some features inspired from Java for example, Java announcements wouldn't be appropriate here.
&gt; Hey now. Let's keep the focus on Drupal. WP has got enough hate. I'm just going off the 'popular opinion', I work with WordPress regularly; I personally don't hate it, though I certainly don't love it either. &gt; Good, in what regard? Yeah I should have specified a bit further. I'm pretty much in the same boat as you are, so In my case good and user friendly mostly refers to the UI for non-technical people. I mean, one of the main reasons WordPress is so popular/requested is that despite its flaws it has a very easy to use/understand UI whereas for example Drupal (at least the one site I've worked with that runs on Drupal) is rather unintuitive.
Yes, but Java doesn't support PHP 5.6 and PHP7, does it? Stop being so smart :)
Many to many relationships. WordPress has a great plugin for this called post 2 post but the developer has abandoned ship making it a risky addition do a serious site. 
&gt; based on Symfony Uses a few Symfony components would be more accurate. It's not using Symfony as a framework, not at all.
Then you just pick it up and maintain it yourself. 
I could help with PSR12 with https://github.com/symplify/easyCodingStandard/, but didn't find way to reply (on mobile).
I had discussed this with my coworkers when I saw the stackoverflow report. I think this is a CMS problem in general, as sharepoint and wordpress are both ranked pretty badly as well. First, most CMS work isn't solving interesting problems, it's setting up yet another e-commerce store / content site with a few forms. Secondly, there are a lot of bugs; most sites we build have half a dozen module patches, because the modules are usually built by other developers trying to get thier own projects done and not dedicated to work on those modules. Outside of their own use cases there are lots of edge cases that don't work, cause other problems or just plain don't work with other modules. And I need 300 such modules to build a site sometimes. A good example of this is Drupal 8 Commerce, where pretty much nothing works for my country (which is the United States), and we had to recreate practically every piece just to get a working store with pretty basic functionality, and I live in the biggest economy in the world. Third, powerful CMS's need a lot of layers and complexity, which makes working with them challenging and tedious. If I build something myself, I understand all the parts, and can easily add or change things at any time or work with the data directly. With Drupal, I have to deal with the many layers of abstraction, and just getting a field in the database to display on in some template can be challenging because it's nested 9 layers deep in an array or isn't available in the current template, or fiddling with display suite and views, when all i want is to display the results of a basic query.
That pressure is definitely needed. It seems like the PHP community has gotten much more responsive to changes finally, and so this work can take place on PHP itself. You're right that it definitely served a purpose in its day.
[Nice.](https://i.imgur.com/6zeve8L.gif) 
If the code isn't rewritten to take advantage of all the hack-specific features, it hardly seems like a useful benchmark. I would definitely be curious if someone's actually profiled this to figure out what specific optimization HHVM is using that speeds up Laravel so much, and whether that's been addressed at all in Laravel 5.6.
Not promising this, but: - YAML parser feels like the kind of thing we're likely to provide; I think we'll be considering this when we look at adding JSON handling to the HSL. - An ORM of some kind is on the todo list, and would likely look like https://github.com/hhvm/hack-codegen/tree/master/examples/dorm ; if we do this, it would likely - at least initially - come with an explicit reduced expectation for support. The idea would be to give an example and potential starting point for community solutions. We're unlikely to tackle logging for the same reason we'd want a reduced commitment to an ORM: we have strong ideas about how some libraries 'should' be designed in Hack, but this is largely based on our experience with Facebook's www. The more high-level something is, the greater the chance that this experience doesn't line up with what the community needs. For example, if we were to do an open source logging solution, this would be heavily influenced by our experience with Scuba - I'm not sure how usable the result would be for existing standard practices on AWS. If we happen to get it right, we'd revisit support expectations - we just don't want to commit to supporting something for years if we think there's a high chance that we've got it wrong, taking away from more important work. This is also a chicken-and-egg situation - a reduced support statement makes people less likely to use it.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [hhvm/hack-codegen/.../**dorm** (master → d3b65b5)](https://github.com/hhvm/hack-codegen/tree/d3b65b5e2caadb4b58611bdcee179687947acb83/examples/dorm) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dvt0qis.)
&gt; They hire the cheapest people they can get straight out of college and give them a crash coarse in programming for a month then assign them to projects. BTW if anybody is wondering, this is literally true. I used to know one of their new hires, and she told me about her series of one-week courses in various languages. This was her first exposure to programming.
Ahh ok, now I see.
&gt; I don't know a single person still doing Perl. Booking.com is written in Perl. But yes......avoiding Perl is a good life-choice.
I acutally meant *I don't know a single person still doing new stuff in 2018 using Perl*. ;) There is for sure software from the '90s written in Perl.
ACF handles relationships just as entity references fo in Drupal. 
Do you know if there was a technical reason it was designed this way originally? It does seem rather unintuitive.
10 years ago drupal had a better query builder GUI than anything there is today (And it's gotten better since then). It was also the only option for complex custom field setups and did all of this with point and click. Nowadays the custom fields aren't such a big deal since every other CMS has them too, and views are something you set up once and never touch again. It's aged as poorly as wordpress, but it didn't have the popularity to keep it going. That said, if it's the second most hated platform that's because there are surprisingly few PHP devs that have had the misfortune of working with magento...
I like how the old behavior was carefully documented, and then for years (until now) no one thought "wait a minute, this doesn't make sense, we should fix it!"
Funny, my company uses both Drupal for it's fwd-facing site and Sharepoint for internal documents. We're just on the shit end of the stick I guess
No bro it's because of the steep learning curve. Learn 2 program!!!11eleventy11
I mean that's pretty impressive. His client must have been an idiot if he couldn't tell their consultant was probably dumber than they are.
Ha your first sentence threw me off until I realized you meant it as in "eating five whole sticks of butter in a row is impressive."
It's good to have another static analysis tool but now with Psalm, Phan, and PhpStan I'd like to know: 1. what features sets one apart from the other? 1. Are they complementary? 1. Is one more easily configured?