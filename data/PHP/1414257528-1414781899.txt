That's why the audience for that document is the developer. By that time there should have been enough use and functionality specification done, they're on board with the plan.
&gt; I love symfony as a library, not a framework. I honestly don't like a lot of the mvc frameworks these days. They're so damn worried about being uncoupled that they've lost sight of what makes a framework actually useful, which is very quick development with reusable tools. With ZF1, I can literally add a public method to a controller, add a view file, and I'm done. No routing, not worried of layout definitions, the action is completely unaware of the view (it's just part of the framework to load the view with the same naming scheme as the action) You should take another look at Symfony. /** * @Route("/something") * @Template */ public function someAction() { // ... } Bam. Done.
The top-level vendor namespace is required by PSR-0/4. The second-level package namespace is optional, because a vendor is free to namespace its own code however it sees fit, provided that it follows the rest of PSR-0/4. From an autoloading standpoint, it doesn't make a bit of difference. The recommendation of `\Vendor\Package\...` comes from the fact that if a vendor has more than one package and *doesn't* use this form, then it is vulnerable to naming conflicts across its own packages. For example, `\PHPixie\View` in one package would conflict with `\PHPixie\View` in another package, if both packages were dependencies of the same 3rd party project. Thus, it's recommended that you use the `\Vendor\Package\...` pattern to remove the cognitive overhead of manually ensuring that none of your packages have any conflicting names.
You can achieve the functionality you've given in the same way in Symfony. For instance, using @Route and @Template annotations in your controller. 
I work professionally as a Symfony developer at an agency and can say without a doubt that once you're past that initial 'wait, how do I do this, and this?' phase, it gets trivial to do almost anything in Symfony, and it's incredibly easy to extend. IMO, Symfony is less opinionated than Laravel, and it makes it more suited for a wider range of projects. At the end of the day, you can probably get the same out of both frameworks, but I'd prefer Symfony because I know that Symfony is an incredibly robust framework, it's well tested, well written, and has a large user base. I've always been put off of Laravel because all the beginners do start with it, and some of the concepts within the framework put me off. Symfony has a mature ecosystem and user base.
If you can get the same out of Laravel where are the large, highly trafficked, fully featured sites built in it? If there are none are there any on the way?
Symfony lends itself to large, highly trafficked, fully features sites out of the box practically. The concept of things like Bundles is baked in so tightly that you basically have to use them - that modular structure for example is one reason why Symfony is great for large applications. Whereas (at least last time I had a look into Laravel) the process to create some kind of bundle/module is quite a bit more difficult. Laravel seems to lend itself to rapid development of medium sized applications. Perhaps more things like blogs and the like out of the box. EDIT: Just had a look again, and the process to make a 'package' at least is the same as it was before, and does seem to be less intiutive compared to Symfony. But then again, maybe I'm just used to Symfony - though it is as simple as `app/console generate:bundle` in Symfony XD
Play is really dope. I used it once to interface with a jar via php and it was so easy to setup and get things done.
I chose ZF2. Am I experienced or beginner?:)
I've never used Symfony, but does it parse doc block and do a bunch of behind the scenes binding based on them as if they were decorators in other langs? That doesn't look appealing to me
Well, I believe the intent of OP was Laravel **and** Angular, yet it was worded Laravel **or** Angular. So you did literally deliver what the OP wanted, but not in the spirit of the question, which you had to imply. Seeing that you did exactly as OP asked, I'm going to give you an upvote for good intentions.
He definitely said "or" nor does the intent come off as "and" at all.
Having a client sign off on a technical document that they don't understand is an unconscionable contract and only makes them uncomfortable...unless they're a technical client . Ergo it's a dumb exercise ...even though it is a valuable spec for a developer.
&gt; Whereas (at least last time I had a look into Laravel) the process to create some kind of bundle/module is quite a bit more difficult. What? Not it's not. It's as difficult as creating a separate composer package. Actually creating some kind of bundle/module in Laravel is way easier than Symfony. &gt; EDIT: Just had a look again, and the process to make a 'package' at least is the same as it was before, and does seem to be less intiutive compared to Symfony. But then again, maybe I'm just used to Symfony - though it is as simple as app/console generate:bundle in Symfony XD php artisan workbench vendor/package --resources
I've built sites that average 150,000 unique visitors a day on Laravel 4. Soon to start rebuilding a multi-million dollar a year company's sole revenue making platform on Laravel 5. That being said, I do know one of the biggest sites on the internet is using Symfony2.
OK that looks promising. I will look into that. Thank you. 
Well, if we're going to use the mentality of most of the people in this sub, you're a total noob, because only experienced users use symfony and the framework you choose defines 100% of your skill level.
You contradicted yourself a lot right there - "It's as difficult as creating a separate composer package.", "Creating some kind of bundle/module in Laravel is way easier than Symfony.". Creating a bundle in Symfony is a lot easier than creating a composer library. \*shrug\* From what I've read it seems you have to manually register your package in your application when it's been created too, and it doesn't provide as much in a package when it's created in comparison to Symfony bundles. I can't really say much, as I've not put much time into Laravel at all. I attempted to get into it, but didn't like how it worked and I'd already been using Symfony for a while. It brought nothing new to the table for me. No features that made anything easier, no new features, and it seemed to use less mature alternatives for things. I much prefer Doctrine / Twig over Eloquent / Blade - perhaps part of that is personal taste. I'd try it again some time if there were some compelling reason to try it, but from what I've seen, it's very flavour of the month - as a lot of frameworks tend to be - Symfony is something I can trust, that is way easier to use for me since I know how to use it, by now it's all just second nature.
&gt; With ZF1, I can Sounds like you're just using what you're familiar with. We've got guys at work that refuse to move off Win XP, just sayin.
&gt;&gt;&gt; but does it parse doc block Yes, and it's called annotations. 
I wouldn't choose ZF1 for a new application, but I still respect its simplicity. Also, I have a windows xp user two desks down from me, so I know what you mean..
I have a completely different take on this. I am used to developing in Laravel and then I took over a project that uses a custom framework and old original mysql_query stuff for database. This obviously needed to be replaced but the framework is too far gone to switch. So I looked at other database wrappers and chose Doctrine DBAL. I hate it. I mean, the documentation is awful for a start. No concrete examples on how to do basic queries, nothing. The examples are half assed to say the least. As someone who had never used Doctrine, it was just a horrible experience. Switch back to Laravel Eloquent. DB::table()-&gt;where()-&gt;take(10)-&gt;get(). So on that, how you (or anybody) can prefer Doctrine over ANYTHING I just can't comprehend. I had the same experience with Twig vs Blade a while ago too. Twig = awful explanations in the docs. Blade = simple. 
Which one? 
I dunno if nobody cares, nobody feels the overhead, they don't cost us anything. But I can see that it might not be a good thing to aim for, for a new API meant to be solving problems, I can see that we might feel the overhead for a new API ... Also, it is a bit gross ... just because you saw someone else picking their nose on a train one time, doesn't mean you should go around picking your nose on trains ...
I hate annotations. They're just wrong. 
I kind of like keeping the routing together, away from the controllers, so I can see the big picture routing map in one place. Controllers bringing their own routes along feels like it could result in conflicts.
I felt the same way at first, but it's a really really nice way to do things, and now the official best practice http://symfony.com/doc/download-best-practices-book/ I've not had any conflicts, if your resources are similar enough to have the same name then they might be the same resource?
Doctrine DBAL != Doctrine ORM. I'm not sure where you looked, but the Doctrine documentation is pretty good: http://docs.doctrine-project.org/projects/doctrine-dbal/en/latest/ Besides: Doctrine ORM implements the DataMapper (DM) pattern whereas Eloquent uses ActiveRecord (AR). DM models are just so much easier to test that I don't use AR-syle ORMs anymore. EDIT: Updated docs URL.
The beauty of a non-opinionated framework such as Symfony is that you can do it either way. You can use annotations if you want, but you don't have to. You can use Yaml or XML if you want, but you don't have to. You could even use plain PHP if you want, but you don't have to. &gt; Controllers bringing their own routes along feels like it could result in conflicts. I'll also add that controllers and whole bundles can be assigned a routing prefix. For example: /** * @Route("/blog") */ class PostController extends Controller { /** * @Route("/show/{id}") */ public function showAction($id) { } /** * @Route("/new") */ public function newAction() { } } ...and... # app/config/routing.yml acme_hello: resource: "@AcmeHelloBundle/Resources/config/routing.yml" prefix: /admin
YouPorn.com Do a google search, the lead engineer gave a talk at a conference about it. Edit:// I did the search for you http://www.youtube.com/watch?v=RlkCdM_f3p4
The routing prefix looks handy. In Laravel you can nest the routes into wrappers with prefixes, and also put other options in there too, such as "must be logged in for everything under /admin". I guess this may be getting to the crux of the question: when the options are left wide open, experienced developers have the freedom to structure their project in the way they feel is best for that application, given the experience they have. Beginners would tend to get lost right at that first stage, and really prefer to have their hands held at least a little bit to lead them to something that works quickly.
I never said anything about creating composer libraries being hard - I simply stated it's nowhere near as easy as creating a bundle in Symfony. &gt; you don't HAVE to register anything in Laravel's service providers... Those are only if you want to add any extra stuff, facades, etc... You can create anything and just use it right away. I don't really know Laravel - as I said - what can you use straight away without registering anything? Just so there's some comparison, in Symfony you: * Have a services file set up, and registered in your application ready to be added to. * Having a routing file set up, and registered in your application, ready to be added to. * A default controller, with a default action which will work without doing anything. * A basic configuration extension set up, and registered in your application, ready to be added to. * A basic unit test to run with the default controller. * A basic twig template I'm in no way saying Laravel doesn't do these things, as I don't know, I've not looked into it. I'm just saying it's nice that Symfony provides all of those things, and the correct folder structure without you having to do anything. You can run that command, and it'll have everything you need to actually see a page which is pretty neat I suppose.
[Standards](http://imgs.xkcd.com/comics/standards.png)
Well, I guess I see your point.... By that time, they trust us or they don't, and we're committed as an agency to operating in good faith. In other words, if something's missing, we don't know it's missing either. I've never had anyone object to that, in practice. If somebody really put their foot down about it, I guess I'd probably propose to collaborate with them to come up with some language that works for all of us.
Exactly. That's why these are mutable. It' will be easier to override an existing one than create a whole new set =)
I'd love to actually see some statistics on this. It's a commonly held thought, n00bs use laravel, experienced developers use symfony... but there seems to be a lack of evidence beyond anecdote.
Laravel does the same thing.
So you're saying, there are no experienced developers in PHP? Or did I miss the announcement that they're porting PHP to the browser?
Where? 
I know they aren't the same. I chose DBAL to avoid the need for annotations and spending hours building up the models when I could just use the query builder in DBAL. Perhaps it is subjective but the documentation in my opinion is awful. You need to look at the API to figure out what is possible. As a comparison, whilst I know that Laravel's documentation leaves much to be desired, the Eloquent docs are much more concise. 
&gt; Everybody can join the conversation or initialize a discussion of a new standard This is already the case with FIG. Anyone can start or join in discussions on the mailing list and IRC channel. The [PSR workflow](https://github.com/php-fig/fig-standards/blob/master/bylaws/004-psr-workflow.md) specifies that only the 2 Sponsors need to be voting members - the Editors and Contributors do not need to be. This ensures that there's an actual interest in the PSR from voting members and that there's someone in charge of the voting process, etc. who knows what they're doing. &gt; Only people who actually develop relevant packages get to vote. So if your project is a router, you don't get to vote on an view template standard. Because obviously people who develop and maintain router projects never use view templates in any of their projects or works. o_O &gt; We get standards faster You get a lot of crappy, not very well thought out "standards" faster, which are replaced so fast no one can keep up, so everyone stops bothering. Either that or you never get anything done because you spend too much time arguing with people who don't have a clue what they're on about. Either way, there's no improvement over the current situation. &gt; No membership rules, you vote with your project on a specific standard and then you may never be involved in another standard again. You do have membership rules. So far I can see at least: * Must be a contributor to an existing project * Members cannot vote on standards not directly related to the purpose of their project Also, the lack of rules leaves massive ambiguities: * How many projects can a member represent * If a member can only represent one project, are their voting rights restricted to the scope of that one project regardless of any other projects they may be involved in? * If a member can represent multiple projects, how many votes do they get? 1 per member or 1 per project? You should also really talk to /u/philsturgeon and co about why those bylaws exist and what was happening before they existed. From the conversations I've "overheard" it was one of the major reasons many of the PSRs have been so slow and FIG appeared to be getting little useful done for a good period of time. You should make sure you don't simply repeat the same mistakes all over again.
To be honest it's been two years since I tried Twig so it might have changed, but I found it difficult to understand the concepts. Blade makes things easy. Templates are clearly explained. In Twig I found it to be the opposite. It seemed backwards. Passing data into a view seemed backwards. Again, I haven't looked recently so I'm not sure now. I really disagree about the documentation for Doctrine. Take a look at Eloquent documentation and see how it compares. Doctrine's is just a mess. Examples are unclear. Also, to even use Doctrine ORM you need the stupud annotations and have to mark out your database schema. If you add a field to a table, you have to add it to the model file as well. Not good. That's another point. I shouldn't have to Google how to do things in Doctrine. I didn't in Eloquent. Active Record is a lot simpler to use than Data Mapper. They both have pros and cons. I'm sure Laravel breaks those principles in more than one place but people still love it. 
They're really just another config format, so it comes down to whether you prefer separate config files or including your config next to the related code. Each has pros and cons. Either way you parse some text in a known format to generate config data. I don't think there's anything more inherently wrong with annotations vs any other config format, except perhaps when you are writing true library code and leaving the handling of configuration up to the user of the lib.
The "build passing" image is just that. An image. There is no build, there are no tests; nothing to pass or fail.
&gt; Why not just do the sane thing when it seems sane? And ultimately, that's the basis for PHP's type system. Try to do the sane thing, and error if you can't. What? That is the *complete opposite* of PHP's type system. It has *dozens* of insane type juggling ~~bugs~~ behaviours and it is *always* silent about it (which you acknowledge in your post)! It *never* errors out for a scalar type mismatch. It *might* raise a notice (not even an error/exception) but you can't even rely on that without checking server-wide configuration (php.ini) PHP's type system is many things, but *sane* isn't one of them. Not by a long shot.
You realize that many of the top websites in the world use PHP? Are you saying that they aren't experienced developers?
It's the official best practice as far as it's how they do it, they realise that it's completely personal taste. For me docblocks make little sense as routing configuration, and make for ugly code (even worse in entity definitions)
I stand corrected, my apologies!
symfony was THE ONLY choice back then and it was a good choice. even with its steep learning curve (subjective), people were still picking it up. now we have laravel, and we see a lot of php developers picking it up for different sizes of projects, lots of blog posts and packages are going around, big adoption. it will take some time before this generation of laravel developers matures with the framework. i think we as developers like to keep saying "use the right tool for the job", but at the end of the day, when faced with a project where we are required to have absolute confidence in our code/work, we will always have the bias to go for the tool that we're most familiar and confident to work with. it's not that symfony or laravel is better than one or the other. both frameworks are good choices, it all just comes down to which tool are you more confident in using for a particular type of job. any tool is just as capable/powerful as the person who wields it.
That's similar to what we are doing at [container-interop](https://github.com/container-interop/container-interop). It's basically a pre-PHP-FIG work, to discuss and try out standards. Though we are targeted at DI containers. I'd say yeah go for it but do it for meaningful things with a clear goal and clear needs. Don't do it for every topic "just because we can". It needs to have sense IMO.
One thing I can say for sure: do not upgrade to ZF2! We did exactly that in our current company; migrate a website from ZF1 to ZF2. Apart from learning new good practices like dependency injection, it has been nothing, but a pain. Many cool things they had in ZF1, they removed in ZF2 or made it a lot harder to use or made it restrictive. Also, everything is a lot harder to use than ZF1, and there hardly is any documentation or online resources for everything. It did not make anything better at all. So either stay, choose SF2, or choose Laravel.
Yes, i meant Or. 
If you want anything like performance, stay away from Doctrine. It's great for building small apps but it doesn't scale at all. I'm a fan of ZF2. It's the most "enterprisy" of the current frameworks.
you can still get performance with doctrine. It depends on how you use it, and how you cache. and Symfony is just as "enterprisy"
Ok thanks. I was curious about Apigility (based on ZF2), have you had any experience with that?
Laravel 5 is using annotations instead of the routes file. http://mattstauffer.co/blog/laravel-5.0-route-annotations
Its cool, but it gets kinda limited the more complex the api gets
Laravel packages and Symfony Bundles are not equivalent. You can't approach Laravel with the same mentality that your application should be divided up into a bunch of different "bundles" outside of the backbone application like in Symfony (which you yourself just explained are practically required). Laravel imposes no such structure on you. Packages in Laravel are meant to be re-usable libraries, not different components or modules of your application. You often make packages through Workbench, and Artisan does indeed have a simple command to generate package scaffolding for you.
There's always annotations.
&gt; They're really just another config format No, they are a bolted on userland pseudo-language with different syntax, documentation, and stability / maintenance cycles than the core language you're working in. It's like throwing executable Ruby in your comments so that some of your application can be executed by Ruby, and some of it by PHP. Want a config? &lt;?php return [ 'my' =&gt; 'config' ]; There's your config: its PHP. Everyone who works with PHP, knows PHP. They know what is and isn't valid syntax. Errors are caught in a clear and straight forward way instead of whatever the annotation parser decides to throw. You don't need to read the library's documentation on what keys/values are valid for the annotations, and then have to go read some separate third party library's documentation on what the syntax actually is.
This is not a good analogy as Laravel comes wired for many "advanced" practices out of the box (IoC with auto resolution by default in many areas of framework, back-end agnostic job queue system, etc.)
It's optional, like Symfony. You can still use the routes file if you want.
All the developers you listed were Symfony core contributors before Laravel 1.0 was even released.
For now. It's forcing a rather unclean solution by default. If it's a comment it should not be used as code.
I have mixed feelings about it. I'm not really comfortable either with comments being executed as code but as far as cleanness and finding the controller method that belongs to a route, with the artisan routes command it's not very difficult.
It's a bit weird getting called high profile in this context. I'm definitely not the only person advocating Laravel, and I'm definitely not only advocating Laravel. Symfony is an amazing set of components that you can slap together to build powerful systems, but that assumes you have the know-how to slap them all together. Laravel - much like the whole family of CodeIgniter, Kohana and Fuel before it - gives you the kitchen sink and holds your hand enough to let any beginner get going. It's more opinionated in how things fit together and therefore help juniors out a lot. Beyond the beginners, it's great for RAD and you get a lot of stuff right out of the box, so you can build prototypes incredibly quickly - much like Rails. More advanced folks stick around with Laravel if and when they agree with those opinions, or if they can mold those opinions into their workflow. When they want to break out of that then they pick a workflow that is component based. In a lot of those instances, many of those components come from Symfony but increasingly they come from multiple sources like Aura, Orno, Hoa and The League. I don't think that Fractal and JMS Serializer offer the same functionality at all. It can be quite hard to understand the purpose of Fractal, but once you get it - if you need it - it's a f**king godsend. I built it to solve problems for me that I'd suffered with every API I ever built. If it doesn't sort you out then no worries, different tools for different folks. :)
Ahh so you map the same prefix to both and hope the autoloader will look at one and then the other to find classes with the same prefix but different location? Yeah, I guess that works. :)
It's not just a Symfony/Doctrine thing, you know. http://en.wikipedia.org/wiki/Java_annotation http://msdn.microsoft.com/en-us/library/ee256141(VS.100).aspx 
This is exactly why I don't like Symfony as a framework. They try to do far too much magic. Under the hood, Symfony as a library is great, but as a framework it's painfully restrictive. If you approach Symfony as an abstraction on top of php where your work must be compiled into php and regularly cleared, then it might not be as bad. I'll take the example you provided to explain a couple of my issues with it more specifically. I obviously don't have to do what you did, but the Symfony team advocates it which is where my issues are based. 1) Programming via doc-blocks: This is just stupid, lazy programming. Even if everybody agrees to call them the same name, annotations, that doesn't make them good. Debugging a stack trace with annotations can make you long for a roof to jump from. Comments are for information and clarification of the code and shouldn't actually be part of the code. Java annotations, which apparently are where this originates, are not in comments, but instead are supported features of the language. Annotations in php are worse than shoe-horning a hippo through a doggy door. If you can't strip out all comments and have the program run, then there's something wrong. In order to accomplish this, heavy use of reflection must be done. Not only must the controller be reflected, but the doc-block must be retrieved, parsed, interpreted, analyzed, and executed. The only way this can even be considered sound is if heavy post-reflection caching is done that effectively builds out a whole new application based on your comments; this is what Symfony does indeed do. Annotations really smell of rotten eggs when I see them. It's as if somebody was writing a comment saying what type of object should be used for phpdoc and decided to be lazy and use that comment as their code so they don't have to properly account for dependency injections and the likes thereof. If php supported annotations like java does, then it would be a different argument, but having executable code inside a comment which, by language definition, is supposed to be ignored by the interpreter is straight up stupid. 2) Violation of SOLID design: I'll keep this one relatively short, but the controller knows far too much about the application and has far too many responsibilities with your small example alone. The controller not only knows the action, but also the routing information and template. Components such as controllers and presenters should be the most boring parts of an application and should also know next to nothing about the overall application. Many pull the "testability" card here and although that's a good card to draw, such coupling for a controller makes the overall maintainability a nightmare. When it comes to enterprise systems, I will recommend Zend Framework and Symfony. This is because of the sound state of the code in their libraries over whatever issues I have with either as a framework. If I know I have to touch the code for any reason, I only recommend Zend Framework because it allows me to easily get rid of the "magic" that it uses. I can always use Symfony as a library if I need to. Symfony is the Rube Goldberg enterprise framework.
Stay with your current framework, and if you're having issues with your ORM then research ORM solutions to determine what's best for you. ZF2 is not an upgrade of ZF1, but a complete rewrite. Switching over from ZF1 to ZF2 wouldn't bring you the same problems as saying switching to something more different like Symfony and its caching, but you'll wish you hadn't tried switching. If you were to start over, I'd recommend using ZF2, but you're not starting over so don't do it. Stay away from Laravel completely. Laravel is essentially a usability wrapper on top of Symfony and is best for small projects and people without much experience. Since you're already using ZF1, then you're already beyond their target audience. If you're wanting to use Laravel for something enterprise, then just use Symfony instead. I'll intentionally skip over ORM recommendations because it's more dependent on what you're doing than what can be said about frameworks.
According to the latest best practices, bundles in Symfony are also supposed to be reusable libraries, that can be detached from current application.
Thanks for the response. I am certainly receptive to the idea of staying with ZF1 - obviously less effort. However, do you have any advice on implementing better dependency injection in ZF1? Also, what would be your preferred ORM to use?
While I completely agree with you on there being problems in the type juggling currently, I'm pretty sure Anthony was referring to the *intent* of PHP's type system when he said this. And, if we're being fair, PHP is actually very smart in this regard *in most cases*. We just need fix it so that it's that smart in all the cases. But that's going to be a huge BC break, with very hard to locate sources in existing code.
How about some http://www.slideshare.net/mobile/guilhermeblanco/orm-dont-kill-your-db-developers-do ? :-) 
That is an interesting question. As ocramius said, functions can't be autoloaded, which is a shame. *Caveat: I'm an ancient programmer. I may not know what I'm talking about.* I've employed both methods for using function libraries - static final classes and namespaced functions. From the perspective of using an IDE, there may be little difference in their use. Be it `Str::special_upcase()` or `&lt;namespace&gt;\special_upcase()`, the result is largely the same, and the IDE or editor (I use PHPStorm) can help with hints in both cases. The difference being that static classes don't need a `require` or `include` to load the function/methods thanks to autoloading. So - for me at any rate - I tend to lean toward static classes. Not in all cases, but generally. What I wish for is that namespaced functions could be autoloaded as required. There may be a long wait for that. 
If you're pulling mysql why not just do a group by? SELECT CONCAT_WS('-',`year`,`month`,`day`) as `date FROM ( SELECT YEAR(`date`) as `year`, MONTH(`date`) as `month`, DAY(`date`) as `day` FROM table GROUP BY YEAR(`date`), MONTH(`date`), DAY(`date`) ORDER BY `date` LIMIT 14 ) as t1 Then simply run some PHP code to fill in the blanks in an array of dates if need be. You can always be more specific about the limit, I just did 14 because that's 2 weeks or more of date data. If you really need to find the last monday and don't have access to DateTime or even with it you still need to do some logic. Get the strtotime of what "last monday" will return. Then simply do a check against it's time frame between the current timestamp. // Always make sure your time zone is set if not by your php.ini date_default_timezone_set('America/Los_Angeles'); $lastmonday = strtotime('last monday'); $time = time(); $timediff = time() - $lastmonday; if ($timediff &lt; (86400 * 6)) { // Adjust the time returned by php by negative 7 days. $lastmonday = $lastmonday - (86400 * 7); } echo $lastmonday; 
&gt; but as a framework it's painfully restrictive Restrictive? It doesn't impose much of anything on you. Not annotations. Not ORMs. Not templates. You could forgo them all if you wanted to. &gt; Comments are for information and clarification of the code and shouldn't actually be part of the code. Java annotations, which apparently are where this originates, are not in comments, but instead are supported features of the language. So, if tomorrow PHP started treating docblocks specially, distinct from comments, then you'd be OK with it? Well, good news, PHP already treats docblocks specially. It's about time we move past thinking of docblocks as comments. &gt; controller knows far too much about the application ... The controller not only knows the action, but also the routing information Finally a fair criticism. And I recall the people behind Symfony discussing this same issue on mailing lists. As I recall, the consensus they reached is that annotations are appropriate only for end-user code, and for the reasons that tjohnell described above, because ultimately a framework should enable quick and simple development, and annotations do that.
I've been looking into using a Data Mapper for some new projects instead of a typical ORM, but I'm a bit hesitant to just write an entire data mapper on my own. Do you write one 100% yourself, or do you build on top of existing tools (excluding PDO)? And if you do, what would you recommend?
Of course I never said they wouldn't have. He asked why more developers that are experienced choose Symfony
&gt; But that's going to be a huge BC break, with very hard to locate sources in existing code. It doesn't have to be. Introducing proper, strict scalar type hints will allow people to bypass juggling completely and make this a non-issue. Those who think the *idea* of juggling is a good thing (like you, Anthony and many others) can keep using the old behaviour with no BC breaks. I truly believe this is the best way forward and I'm far from alone in this (see the comments to [this](http://nikic.github.io/2012/03/06/Scalar-type-hinting-is-harder-than-you-think.html) post).
&gt; With a statically typed language, if the types don't match, it's up to you to fix it. For small systems, this is easy to do. For large systems where the developer has intimate knowledge of the system, it's pretty easy to do. But for a junior developer, it can be difficult. For a new programmer, it can be down right confusing. So basically once you're beyond a junior developer you should start considering other languages, since working in them will be more trivial and less error prone. PHP was just your introduction into adult-programmer-world. I love the type system in C# and I've always hoped PHP would get support for or implement a similar system aswell. "a1b2c3" + 1 giving an error makes sense to every person with common sense in this world, whereas knowing what PHP will exactly do really is a mystery and I can't start to imagine when this kind of behavior is exactly what you want (and if it is, explicitely asking for this behavior will be much clearer). Someone with a WordPress plugin might have a difficult time fixing a type error, but without the error message he never would have known there was an error. Worse, the system might be really big without automated tests and he might never get to test that part of the code. So now your incompatibility of plugins slipped through while a strongly typed system would have caught it.
The same argument can be made for config files in yaml, XML, INI, ..., any other format. Even using your example of native PHP you still need to know which array keys to use for valid configuration, and it's not exactly the two-step research process you make out. Symfony and Doctrine both clearly list the config in various formats in the exact same place for example. In fact my IDE of choice understands annotations and will even offer auto completion so I do less looking up with annotations than any other format aside from XML (which has the same benefit). As for the argument that you shouldn't have to learn another syntax, the reason things like yaml and annotations exist is because they are easier for most humans to work with. Of course you could use PHP for everything, but in the end it's no different if you use any other format including annotations. They are all parsed to PHP anyway, it just comes down to which you find easier to work with.
Strict typehints would only bypass type juggling at the function boundary. That's just a small piece of the puzzle. Typehinted arguments could change types at any time during function execution, and would still be at the mercy of type juggling rules in expressions. IMHO, the best way forward is just to fix the underlying type juggling rules such that there is never any data loss without a hard error/exception. If we're ever going to do it, now is the time.
Ah ok. I thought you were implying that experienced developers tend to choose Symfony only because they are wedded to it already. I was just pointing out that the people in that group have most likely explored Laravel but still prefer Symfony.
Perhaps yes, I was actually reinventing interop with a larger scope. Right now they seem to be working on DI only. It'd be nice if this could expand to cover more things.
Just started a port of a very plain mapper system using PDO under the hood from Aura v1 to v2: https://github.com/auraphp/Aura.SqlMapper_Bundle And I mean *just* started; no docs. However, the tests are all in place with 100% coverage (or very close) so I think it should not be *too* hard ti figure it out.
Well, I think that when he said "no documentation" he just meant that he would have to do extra work to make the original documentation mean something. He is right in my opinion. If you did a str_replace on the docs for DB::something() and reolaced DB with it's actual class, then that would be proper documentation. There should be a toggle to view docs with Facade or Class. Nobody is saying it is any more difficult that Symfony. Just highlighting a current problem. Man people get so defensive of Laravel. 
&gt; IMHO, the best way forward is just to fix the underlying type juggling rules such that there is never any data loss without a hard error/exception. If we're ever going to do it, now is the time. This *could* work but there is no way an RFC for this can get the 2/3 votes required, not even for PHP 7. Even though we are more than a year away from 7, "guys we are breaking too many things" posts have already started appearing in internals.
https://github.com/angelov/eestec-platform here's something i've been working on lately. Its using laravel 4.2 but i plan to upgrade to 5 soon
&gt; What are some scenarios in which static methods/members are beneficial over namespaced entities? Maybe "easier to implement", but never "beneficial". All that Static/Global State stuff is hard to test against, so it propably is a good habit to just stop doing it. Regarding the autoloading: Maybe you have some core class you always load when using your namespaced functions. You could piggyback your funtions into that classes file, since you can define multiple namespaces into one php file. But seriously, dont do it. You can always inject some strategy/behaviour-pattern instances into the place you use it. and then you can test and replace them with ease.
Fair enough. So, the packages you make are meant to be used in a way akin to vendor packages in Laravel? In Symfony at least you have the option of having a modular application of your own code, and using vendor code the same way with bundles.
never touch a running system.
Symfony still is a good choice. I think the reason people think it had a steep learning curve is because it was a bit different from PHP frameworks that came before it - now that the concepts used in frameworks like Symfony are much more widespread in the PHP community it has made learning to use frameworks that use those concepts much easier. I do actually agree with what you have said here, that people will choose what they are most comfortable with. I may however argue that in some cases you don't have that luxury (and to be honest, I think this is a good thing). For instance, I work at an agency, most of the work I do is with Symfony projects, but we'll do other projects in things like Silex if it's more appropriate, and occasionally, we'll even just flip the whole thing over and use Java (something I'm not particularly comfortable with yet). For freelance, or personal projects, I wholeheartedly agree. 
I haven't used `require_once` since ages now, and I don't want to get back to the dark era when it was a requirement.
Powers some huge companies/sites in South Africa too...
Laravel it's not stable. Soon will be Laravel 5.0 with major changes. No roadmap, Otwell doing what he wants when he wants. Symfony has roadpmap for years, long term support, you can relly on Sf2. I like so much Laravel's simplicity but it's sooo unstable. Today L5.0, i next year perhaps 6.0 and everything once again from begining like with 3.0, 4.0 and now with 5.0 ;(
I always wondered how this process looks on high traffic websites and this was really helpful. Thanks!
I think they get defensive because it receives some absolutely insane FUD from developers who basically act like snobs about Symfony. mnapoli's FUD is one such example. &gt; There should be a toggle to view docs with Facade or Class. And I would say there should also be a *complete rewrite* of Symfony documentation to be more terse and scannable like Laravel's.
#3 without a doubt. Separate files would be a nightmare to maintain. It would be like creating a separate template file for every row in your database.
My personal take is brand the library name but keep the method names sane and meaningful.
&gt; I don't understand what's so scary about this. PHP has plenty of examples of dual, redundant procedural/OO APIs already, and nobody seems to care. It's not a problem of having 2 different looking APIs. It's having 2 different looking APIs **that fundamentally behave differently**. One with context placed on the caller, and one on the callee... Two conceptually different type systems, not dependent on what types you use, but how you call them. And if that doesn't sound scary...
Small working groups work on the sections they're interested in then bring them back to the FIG. Making a 2nd FIG doesn't help anything. Go and work on a Task Runner working group - as we suggested multiple times when you guys were flooding the FIG mailing list with discussion about it - and bring it back when its ready for a Entrance Vote. I've asked you to do this a few times. :)
Hi all, thank you all for your advice, i'll go for solution 3. i've created .ini files containing key:sentence. i've split the files so each controller loads its .ini
Im pinhing brady every day for a pre draft vote. (( He said he'd start it 3 days ago (
It is certainly not limited. I have built an api for a very large site in it and it went very smoothly.
I did PHP work for Ubisoft for 2 years. No web culture there though, so don't think my answers would mean much in the sense of community implementation, but glad to answer any questions you have anyway.
Thanks!
Well, yes; that part of it definitely sounds scary to me. Crazy scary. And it's exactly why I'm against the [safe casts RFC](https://wiki.php.net/rfc/safe_cast). If that passes, we'll have not 2, but *3* APIs trying to solve the same problem, but all behaving in fundamentally different ways: 1) `(int)` and `intval()`, 2) `filter_var(..., FILTER_VALIDATE_INT)`, and 3) `to_integer()`.
in my experience it's the reverse. experienced dev always wants the non-monolithic framework, but they can't just switch. that means they are stuck at symfony or zf. they cannot "choose" since its never an option. it's not just frameworks, same can be said for languages. some want to switch from java to python or whatever. they just cant.
Too lazy to write it again. I'll just link you my comment. http://www.reddit.com/r/PHP/comments/2gn5z3/what_is_your_a_favorite_libraryframeworkpackage/ckkzoje
There was a post on /r/battlestations today that was posted by a Yahoo employee. http://www.reddit.com/r/battlestations/comments/2kd2od/my_yahoo_battlestation/ Seems to me like he/she uses sublime. Maybe you could try to contact that person.
That's not what stable means. 
How would you document an API ? And for the sake of simplicity, lets say of a single package, not a full framework.
Found your post via Twitter just now. Since you didn't get many bites when you asked this, here's a new resource. See my posting history for a newly released PHP and SQLite tutorial. It's free, no sign-up required. 
&gt; If you have no intention of maintaining some code you've written for the long term, just say so. And don't submit that package to packagist please.
But you could choose to autoload the file with composer right?
At my work the flow is pretty much: * Branch off of dev * Write what needs to be done * Push and make a pull request * Merge into dev If job A requires work from job B that's in dev then we just go to something else. When its about time to really put things into QA (we usually unit test everything before hand) then we update our dev server. Once that gets approved we merge dev into master.
&gt; Strict typehints would only bypass type juggling at the function boundary. This would already be incredibly valuable; at least compared to having a logical type error propagate into the function body. If inside a function body you (e.g.) apply `+` to strings, and lose some data, that is (a) a local implementation issue and (b) statically detectable. Almost everyone who uses PHP to write nontrivial programs does this already anyway. Unfortunately we are forced to depend on doc comments (error prone &amp; redundant) and static code analyzers (often imperfect) to verify correctness. Furthermore, it seems obvious (at least to me) that only strict scalar type hints would be consistent with OOP type hints. After all no one would expect `function( Foo $foo )` to accept anything but a `Foo`. It will not accept a structurally identical object, nor will it try and deserialize a string into a Foo!
Seems I should have included a sarcasm tag...
I wonder if you misinterpreted my statement. My objection is to requiring advance knowledge of Symfony (or ZF) to understand the individual docblocks. Docblocks are excellent, the problem is that ZF, and apparently Symfony, do not use them correctly. The Java documentation is a good example of this approach done correctly.
PHP has a built-in number formatter. http://php.net/manual/en/class.numberformatter.php
There are many things you may want to do with currency values beyond putting the comma and decimal in the right place. Check out the link in the description for examples.
Got it now and I agree with you. The " *advance knowledge* " he talks about, probably refers on how to instantiate/get different dependencies that you need in order to work with an object. If you want an Email instance, which needs a UserInterface, which needs a VoterInterface, which accepts an array of options, etc, a new user will have a few question like: - what options are available for VoterInterface ? - what classes implement UserInterface ? etc. In that case not the API documentation is the problem, but you looking in the wrong place. Those things should be found in documentation, cook book, whatever. I guess you could also [put some of that information in the docblock](https://github.com/gentlero/bitbucket-api/blob/master/lib/Bitbucket/API/Repositories/Repository.php#L85-L92), but that depends of the team/personal taste
you mean auto-munging? I'd personally stay away from any such editor.
You could do email sending yourself in PHP. Don't use `mail()` under any circumstances though - use a proper library like PHPMailer or SwiftMailer. You need to do multi-part email and handle your own unsubscribes. That can be a simple link embedded in your email that users can click on to remove themselves from your database. That said, can you not open a dialogue with MailChimp to explain your high unsubscribe rate? It does sound plausible for your situation. 
&gt; This would already be incredibly valuable [...] The end result is valuable, yes; but strict typehints are the wrong way to get that result. If, instead, we fix the root cause of the problem (unreliable type juggling in certain circumstances), then there is no need to have strict typehints in the first place. After all, what good does it do to enforce a strict integer type at the function boundary if nothing implicitly cast to an integer could ever result in data loss? The result is the same - your function always receives an integer. The difference is *huge*, though! Fixing the type juggling rules allows for more reliability *outside* of just function boundaries, while still allowing people to typehint their functions and reap the same reliability benefits. As a bonus, this is more consistent with "the PHP way." &gt; Furthermore, it seems obvious (at least to me) that only strict scalar type hints would be consistent with OOP type hints. That's a matter of opinion. Fixing the type juggling rules could pave the way for some really awesome, flexible functionality like this: class Foo { private $value; public function __construct(int $value) { $this-&gt;value = $value; } public function __fromInt(int $value) { return new static($value); } public function __toInt() { return $this-&gt;getValue(); } public function add(Foo $foo) { return new static($this-&gt;getValue() + $foo-&gt;getValue()); } public function getValue() { return $this-&gt;value; } } // Here, the string '2' is implicitly cast to an integer, because // Foo::__construct() has typehinted int. $two = new Foo('2'); // Here, Foo::__construct() wants an int, but is given an // instance of Foo, so it tries to call Foo::__toInt() $two = new Foo($two); // Here, Foo::add() wants a Foo, but is given an int, so it tries // to call Foo::__fromInt(3), which returns a new Foo instance $five = $two-&gt;add(3);
Or at least used a [sarcastic font](http://www.urbandictionary.com/define.php?term=Sarcastica)
*Here's the Urban Dictionary definition of* [***Sarcastica***](http://www.urbandictionary.com/define.php?term=sarcastica) : --- &gt;Font used in internet conversation to denote sarcasm. &gt;Most browsers, IM clients and email applications do not have sarcastica installed thereby leading to ambiguity and confusion in text based conversations. &gt;Sarcastica was invented to prevent these situations by the Minister of Practicality in 2010 and has yet to find mainstream adoption. Despite it's practicality and usefulness universal adoption was deemed to be 'a whole thing'. --- _Sam: What are you doing tomorrow?_ _Frodo: Heading off to Mordor to destroy the One Ring of Power and save the world from the Dark Lord's wrath. Wanna come?_ _Sam: WTF? You serious?_ _Frodo: nah, kidding. My sarcastica font isn't working again._ --- [^(about)](http://www.reddit.com/r/autourbanbot/wiki/index) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autourbanbot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/PHP/comments/2k54sy/teh_playground_is_getting_an_overhaul_please_help/clkijyh) ^| ^(**Summon**: urbanbot, what is something?)
I like Mathias' library, as well as [Sebastian Bergmann's virtually identical library](https://github.com/sebastianbergmann/money). One thing I don't like about either of these, though, is that because they work with the smallest denomination of a given currency, it's very easy to do things like this and shoot yourself in the foot: $fiveDollars = Money::USD(5); // Wrong! This is $0.05, not $5.00! Another thing to watch out for is that they both represent amounts as PHP integers. Since the amount is also represented in the smallest denomination for the currency, that can lead to relatively small maximums on 32-bit platforms (e.g. ~$21.4 million USD).
Another PHP framework, they're breeding `;-)`. Out of interest, what does Cygnite do differently from, say, Symfony, Laravel, Zend and _&lt;insert favourite framework here&gt;_? I wouldn't have thought there's much space for another one, tbh. 
Thanks for the reply. I have opened a support ticket explaining the situation, hopefully they look at why people unsubscribed, not a single person said it was spam or that they didn't sign up. I did think about sending the emails myself, and that was how I built it originally, but within the first day I switched to MailChimp as the mailing list got into the thousands. I hadn't anticipated these numbers so I hadn't thought of a way to stagger the emails, pretty sure it would have just timed out. Even if I staggered the emails they'd have to go out pretty quick as the item is only available for 3 hours, wouldn't I be at risk of getting my server IP blacklisted?
Just signed up to take a proper look, the issue with Mandrill is they have an hourly quota. So right now it says it will take 2-3 hours to send 1000 emails. That can become faster as my account reputation increases. Considering the item in-game is only for sale for 3 hours I'm not sure it'll work out with Mandrill. Seems to be targeted at transaction emails rather than bulk as fast as possible email.
This works fine with SB's library. $fiveDollars = Money::fromString('5', new Currency('USD'));
Personally I'd be surprised if a high unsubscribe rate was enough to get your MailChimp account closed alone. Have they confirmed this to you or are you just guessing? As others have said, you need to open a dialogue with MailChimp - find out the reason why you got booted and make sure you read up on the best practices and make sure you adhere to them. You should ensure that you send an opt-in confirmation email that users have to respond to before they start receiving emails from your service. This will stop both accidentally incorrect email addresses as well as (for free services) spam / malicious registrations adversely affecting your reputation. If you have thousands of subscribers then I think you definitely need to be using a service as dealing with things like IP reputation can be a major headache. The problem (or one of them, anyway) isn't the rate at which you can send emails, but the rate at which major services such as Hotmail will allow you to send emails to them (especially when you don't have any reputation, or worse, have a negative reputation) and all the steps you have to follow (SPF, DKIM, feedback loops, etc) to minimize the problems you'll have. Services like MailChimp should either handle these directly for you, or give you instructions on how to set up your DNS, etc correctly.
Maybe something like Amazon SES? http://aws.amazon.com/ses/
I can answer this one for you quite easily. It's different, because in the future you might be using one of your mentioned frameworks (or maybe you are using one already). But you will never use this one.
You are not entirely out of your gourd. When you start down a path of extreme denormalization like this, consider your query cases carefully. Document stores (like MongoDB et al.) make it very easy to think that you will be able to find whatever documents you need to find in a performant way and that is not always true. As long as you don't need sophisticated search within the JSON portion, that sounds like a viable option. If you have the option of using Postgres for your backend, you can also look at the `hstore` and `JSONB` features. `hstore` is strikingly similar to MongoDB and allows you to dump a bunch of key/value pairs into a single column and gives you some tools for querying those values directly (again, performance varies depending on use case). JSONB is a binary JSON format that essentially allows Postgres to store and retrieve JSON values very efficiently, though they are always presented to the client as text, so it's basically free from your perspective.
As of right now MailChimp have suspended my account, they said it was because of a higher than average unsubscribe rate. I've submitted a ticket to request they re-enable my account, explaining the situation. So there is a chance I'll be allowed to send again but I'm looking for a plan B in case not. I haven't used the opt-in confirmation, users are added straight away, thanks for that suggestion I will implement that now. 
We're using NoSQL, but it looks like there ,ugh be some jsonb stuff in there we can use. I'll need to do some more googling though. In either case, I don't think I'll need to do much, if any, searching inside the JSON strings. So far the it's purely extra data that's not even 100% necessary for things to make sense to the user. Just stuff to make their lives a bit easier. Edit: I'm an idiot, it's MySQL.
Uh, if you're using NoSQL, then how is this even a question? A document store, by its very nature, doesn't enforce a schema (at least, I thought that was the whole point). If you're using something like MongoDB it may make sense to save that unstructured portion as a subdocument with actual keys so that you can make better sense of it later, rather than saving it as a string that needs to be extracted and parsed as JSON in order to do anything with it.
size of the site does not determine the complexity of an API.
From experience I found out that the quota increases fast.
Using Single Table Inheritance? http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html
You would be surprised at the number of managers I have met that would be completely up for that. "Why re-invent the wheel, let's leverage existing software!" ... what could go wrong. :-)
Agreed. My quota jumped from the default (I think 300/hr) to nearly 5000/hr in a matter of days.
You should have everything ready before creating a video. Also, the audience is tough here, and I think they'd pay more attention to an spoken tutorial.
knowing the latest framework can get you a job, but it wont help you increase your income.
If you want to increase your income learn a new language instead. Developers with multiple languages can earn more than a developer with a single language. 
I'm going to go ahead and call it. It's not why, but who. The answer is /u/jeffreyway. Fact of the matter is the man has built a fantastic resource, and his evangelism has contributed massively to the frameworks adoption. No other framework has a resource like [Laracasts](http://Laracasts.com). This massively reduces the barrier to entry to begin building something cool. Also, as Laravel was built with the symphony components, it's likely 'feeding up' into the Symphony community - mastering Laravel means you learn quite a bit about the underlying packages, and the way Laravel was put together. Sure, a lot of beginners are choosing to start out with Laravel, and good for them - it's likely a good place to start. That doesn't somehow make it a 'toy' or 'beginners' framework - a good PHP developer is going to be able to write a good PHP application. 
I think we can agree that weak (coercing) hints would be useful only if no data is lost. But how are you going to "fix" juggling? Does `"foobar"` no longer coerce to `0`? What would be the "fixed" way to type juggle: `"0" == "0.0"` or `"10" &lt; "2"`? What happens when I do `$two-&gt;add("3")`? The current solution is to use operators (`===`) and functions (`strcmp`) that are strict or at least explicit about types. If you do not use them, your program is wrong. If you use them only when necessary, you will sooner or later end up making a mistake. The only realistic alternative is to consistently use the strict approach. This is not how php was designed, but in reality this often becomes "the php way". Type juggling will never be "fixed". It is fundamentally broken for a system to try and deduce intent where it is ambiguous. Granted, it *might* be improved and predictable enough (especially at function boundaries) for weak hinting to be useful. But `"foobar"` no longer coercing to `0` would have to pass a vote first. On the other hand, strict scalar type hinting would work *right now*. It is also predictable *and* backwards compatible. (Btw, your fromInt/toInt proposal is magical behavior that could work wether scalars coerce or not. The toString mechanism is basically the same, and can be found in many strictly typed languages.)
And what exactly in php is so complex you do not think it can handle? It does not restrict your api in anyway. It simoly provides the tools to ensure a high quality and proper api.
Lots of things can throw exceptions, so how I decide where to use try / catch blocks? Do I only use it in places where I think it's *likely* for an exception to be thrown? Using them everywhere seems like it would get messy real fast. Do I use set_exception_handler() for the entire page and then try / catch for special situations?
I've had a lot of success using the git flow model of branching. It isn't too much different than what you are currently doing. The main difference being that master is strictly for production pushes, feature branches are for QA and develop becomes a regression testing branch or quick fixes. [Git flow](http://nvie.com/posts/a-successful-git-branching-model/)
Serious question tho: can I ask why? I tried Laravel and Symfony 2 and it's a real pain to learn (I guess it's just at first). My first MVC framework with PHP was CakePHP but it was so brutal. So far Codeigniter gives me what I want: the basic MVC structure and leaves the rest for me. Edit: Actually wait. I just remembered a couple of things. No unit test and migration that barely works come to mind. But is that it?
&gt; how I decide where to use try / catch blocks? Do I only use it in places where I think it's likely for an exception to be thrown? No, only where you can do something out of it. Like displaying an error to the user, or do something alternative. Say you have blogging platform, you have several layers of abstraction, Models, Controllers, Views, etc. If you have some hypothetical "getBlogPosts()" function, it won't make sense to catch a possible "Database not found" exception there. What should this method do, then, return nothing? Instead, you catch that exception on a higher level, whenever you have the chance of doing something useful with it, like displaying the problem to the user (in this case, for example, in the controller layer). try { $controller-&gt;dispatch($request); } catch (\Exception $exception) { // Render the exception to the user } In other cases, you might want to take decisions based on an exception, if you're doing HTTP requests, you might want to retry a couple of times before giving up. * &gt; Do I use set_exception_handler() for the entire page I don't think it's necessary, specially if you use a modern Framework. I would otherwise try to catch the exceptions in a context where makes more sense. The exception handling function would be called then with no context and this encourages bad habits, like globals or singletons. In old "grown" codebases, or code that don't follow MVC or some kind of sane structure it might be useful as a "last defending line". ^* ^\(Note ^that ^feature-reach ^HTTP ^libraries ^like ^guzzle ^can ^handle ^retries ^themselves)
Think about it more in terms of a guitar. In this context, Laravel might be a Fender Stratocaster. If you play, it may very well have been your first instrument - they're consistent, there are a ton of them, you can find them anywhere - and because of that they've got a reputation for being a starter guitar. However, a ton of famous musicians use them from Eric Clapton to Eddie Van Halen. As you play though - you might find out that there are a few quarks to that you don't like - maybe you make a Frankenstrat like Eddie did. Or maybe, one day you hear a hollow-body Rickenbacker and that's the sound for you. At the end of the day, it's the chops that you develop and the with that instrument that ultimately determines if you sound good. 
This is not a problem, until you get to 10000 rows in a regular database and then you want to start considering breaking them up into separate tables or something similar. Edit: Yeah...even with nosql you'll tank your efficiency by putting it all in one table, but it will take much longer.
We're basically doing GitFlow, and it's fine. I'm really trying to figure out how to get our mobile apps to be able to test each feature without having to dump all of the features into a single repo and server. 
biggest con, it's an old fashioned dead framework.
Why does === require objects to be the same instance? I know it's in the documentation, but I don't understand, in theory, why this is false: new \DateTime('2014-05-12') === new \DateTime('2014-05-12'); On that same token, has there ever be an internals discussion regarding magic methods for __equals and __null? Comparing objects, even with ==, can also be very fragile and it'd be awesome to be able to write custom logic for it.
&gt; I'm trying to figure out a way to get each feature QAed in some logical fashion The code you release is in one master branch though, so that would be the ideal place to do QA (which I assume is UAT or some sort of business testing after unit etc passes in dev). Perhaps some sort of code freeze/merge window would work? E.g. on Mon night, whatever is in QA branch is locked down for testing, then released on Wed morning and devs can again push features up for testing.
There's no simple answer to all of this, but since you are dealing with an API, you dont necessarily need to test each feature from the mobile app(s). APIs can be tested in several stages, unit testing, integration testing, etc. Each component should be able to independently tested, and when those have been verified, a feature branch can be merged into develop that your mobile app can interact with. The *best* solution we were able to come up with was to have a suite of bash scripts that could deploy a feature branch to our testing server with a custom dns entry (feature-a.testing.example.com). This way we could run our unit tests and use a REST client to interact with the actual endpoints separate from all other features. The bash scripts would clone the repo into a new directory, add a virtual host, add the dns entry in Route53 and load a db if needed. Obviously, none of this is quick and easy to set up, but it may give you some ideas on how to improve your workflow.
I understand the mechanics of why it happens that way, I just don't understand why that's the way the language decided to handle it. Why compare the references and not the actual values? It seems inconsistent with the way non-objects are evaluated; even strings, passed by reference, evaluate as identical.
Imagine you have two User objects, each of whom have the same name, same birthday, etc. (Let's assume you don't have a unique ID on them for whatever reason). So although all their properties are the same (using ==), they don't represent the same User (===). As an aside, this special treatment of strings also holds true in JS, which actually has strings as true objects. Also note that comparing objects with === is faster, because all you have to do is check that they point to the same spot in memory. With ==, PHP has to recursively check that all properties are equal.
Its going to be a bad idea to stick everything in a single table you will have a ton of redundant data and you wont use all of what SQL has to offer need to normalize(putting data in separate tables) your data by doing that you will be able to efficiently pull up data. try looking at how to use foreign keys and local keys and how to use JOINs. 
Yes Mathiasverras money is being used by different projects :-) .
Yes, this is usually the way to go. One table, but multiple classes. If you are using Laravel: https://github.com/intrip/laravel-single-table-inheritance Or Symfony2/Doctrine: http://doctrine-orm.readthedocs.org/en/latest/reference/inheritance-mapping.html#single-table-inheritance
Last week I had a bad case of making stupid mistakes. Is there something that can warn me about what to test for with certain PHP functions that people tend to make mistakes with? Linting helps a ton with this really.
You can't === two arrays to check if they happen to match (or, at least I don't THINK you can do that, and I certainly wouldn't get into the habit of doing that). An object isn't a typical type so there's no obj1 === obj2 in terms of the values they store. === is all about the values, not some abstracted collection of values all individually matching against another abstracted collection of values. The exception to that are strings, but strings are always the exception to the rules because of the specific utility they provide over having to deal with an array of chars. The whole point of strings are for them to be the exception. It would make less sense for PHP to be able to === for different objects that happen to have the same values. An object reference is akin to a pointer, so if they aren't both referring to the same object then of course it's going to be false.
What you want is inheritance. You have a class "Message", and then a subsequent set of classes that adds info to the class "Message" (FacebookMessage, TwitterMessage, ...). In relationnal database, there is no clear inheritence, but there are some ways to do it: 1) Do a simple table with all the fields you need. Basically, your table will looks like: * id * message_text * message_date * facebook_user * facebook_foo * twitter_user In the case of a Twitter message, the "facebook_*" fields will be null. 2) Make a table for each class, and then, in the "child" tables, put a foreign key to link to the "parent" table. In your case, you'll have 3 tables: messages: * id * message_text * message_date facebook: * facebook_user * faceboo_foo * message_id twitter: * twitter_user * message_id 3) The third way is a variation of the second: you still have one table for each "class", but you put your foreign key in the "parent" table. messages: * id * message_text * message_date * message_type * message_type_id facebook: * facebook_user * faceboo_foo twitter: * twitter_user One entry of "messages" will have the id of a row in the "message_type_id" field, and the name of the table it refers in "message_type".
Just received a reply to my ticket. They won't re-enable my account as they have to enforce the industry standard when it comes to unsubscribes. They also said its a transaction email, despite it being sent once a week to the whole list in one go. 
check out [laravel](http://laravel.com) 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Date format by country**](https://en.wikipedia.org/wiki/Date%20format%20by%20country): [](#sfw) --- &gt; &gt;This page gives an overview of [date formats](https://en.wikipedia.org/wiki/Date_format) by country, for the [Gregorian calendar](https://en.wikipedia.org/wiki/Gregorian_calendar) (see [other calendars in use](https://en.wikipedia.org/wiki/Calendar#Calendars_in_use)). (For time as well, see [Date and time representation by country](https://en.wikipedia.org/wiki/Date_and_time_representation_by_country).) &gt;==== &gt;[**Image**](https://i.imgur.com/fkVUZPu.png) [^(i)](https://commons.wikimedia.org/wiki/File:Date_format_by_country.svg) --- ^Interesting: [^Calendar ^date](https://en.wikipedia.org/wiki/Calendar_date) ^| [^ISO ^8601](https://en.wikipedia.org/wiki/ISO_8601) ^| [^Address ^\(geography)](https://en.wikipedia.org/wiki/Address_\(geography\)) ^| [^Date ^and ^time ^representation ^by ^country](https://en.wikipedia.org/wiki/Date_and_time_representation_by_country) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clkz3vu) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clkz3vu)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Autoloading is probably main advantage, as others mentioned here, I also haven't used requires/includes in years now.
Always use the best tool for the job.
&gt;Nothing needs fixing here &gt;Nothing changes here What if those were usernames? password hashes? product ids? Sometimes strings just *happen* to look like numbers. &gt;Yes, that's the hurdle. It's a large BC break, but I don't know anyone who doesn't believe it would make the language better. I'm sure enough contributors consider BC important enough to vote against. This is why the "benefits" of improved juggling are a moot point. It's not even going to happen.
I personally do not know exactly how customer data is structured in MailChimp, but I do work for a different (for the sake of this discussion unnamed) ESP. We would at least temporarily disable the account as well if there are constant high unjoin or bounce rates. But if there is a good reason for those to be happening as in your case, we would try to find a solution that better fits your model. What I would recommend, is that you do not effectively unjoin the records, but instead remove (or set) a flag that prevents further communication until the next time it actively is required. Imagine it as two ways top stop getting emails: 1) button with "i no longer need to be reminded of this game" as a kind of "soft-unjoin" which removes the record from the active list 2) button with "i no longer wan to receive any information" as the real unjoin and make it less prominent than the other one to recommend only clicking it if it is indeed a real unjoin. As said, I do not really know of the details on MailChimp, but this approach should work in most ESP. PSA: As for others recommending sending mass mailing through mail() (or similar), do not. If you use an ESP (and there are relatively cheap ones) you get a lot of features, like bounce analytics, deliverability monitoring and a lot more. If for example you send mass mailing as "send and forget" (what mail() is), if you get lots of bounces, your IP will be blacklisted on various lists and nobody will get mails. Or you usually send 1k mails a day and then there is a massive campaign with 100k on that IP - right into the ISP blocklist with that one. ESPs prevent that from happening by providing metrics of results and helping to better prevent such stuff from happening.
You can compare two separate strings in JS. It is Java in where they'll never be equal when comparing with operators.
Just use sendy.co. I've used it on some fairly large subscriber lists and its worked well.
It's only ever been in 1 format with the exception of one post (which wasn't posted by AutoModerator). Feel free to check the [history](http://www.reddit.com/r/PHP/search?q=PHP+Moronic+Monday&amp;sort=new&amp;restrict_sr=on&amp;t=all). I'm British so have always used d-m-Y. Not going to change it again ...
No it's not. http://book.cakephp.org/3.0/en
If you don't know CakePHP then the biggest con would be learning it. If you do know CakePHP then there isn't really any con. Take a look at [CakePHP 3](http://book.cakephp.org/3.0/en), it is currently in beta, but it is already very stable and should be out be the end of the year.
My thoughts: 1. They are NOT bad practice, and are used extensively by different PHP projects. 2. They are called heredocs and come from the Bourne shell (the main shell used on Unix systems before Linux). 3. Basically in English you can think of it like this: variable = {everything until you HEAR these characters} so: $var=&lt;&lt;&lt;SQL some sql statements here can be as many lines as I want SQL; or $html_var=&lt;&lt;&lt;HTML some html here HTML; is all good. Note the formatting is a little funky in that there cannot be whitespace before or after the &lt;&lt;&lt;LABEL on the first line and also the LABEL; on the last line must start at column 0 and also cannot have any whitespace behind it (spaces, tabs etc.). It must start at column0 in the document even if the $var=&lt;&lt;&lt;EOF starts at column 8 or 12, so the start of your block can be indented equal to everything else but the end of the block is always on column 0. Its not really much of a problem as soon as you understand this is just how it works. Also, fyi they are great for PHP templating (inserting variables into your html output), as follows: $name="Bob"; $address = $db_row-&gt;address; $mainmerge_str=&lt;&lt;&lt;EOF &lt;div class="mail_label"&gt; &lt;p&gt; Dear $name &lt;/p&gt; &lt;p&gt; $address &lt;/div&gt; EOF; echo $mailmerge_str; Note in the above example we could have just echoed the heredoc out: echo &lt;&lt;&lt;EOF stuff to be echoed including $variables EOF; You can also include more complex variables inside the heredoc block using {}, as follows: $name="Bob"; $address = $db_row-&gt;address; $mainmerge=&lt;&lt;&lt;EOF &lt;div class="mail_label"&gt; &lt;p&gt; Dear {$name} &lt;/p&gt; &lt;p&gt; {$db_row-&gt;address} &lt;/p&gt; &lt;/div&gt; EOF; As you can see, I am a fan... :-) 
Hey, just move to ZF2/SF2 (really up to you, I prefer ZF2, as I like to control everything instead of learning how to configure a bundle). Add some JavaScript to this (jQuery + Backbone or Angular) and you're ready to go for some extra cash :)
For key-value pairs Redis is the obvious choice though. Much faster than hstore.
&gt; You can't === two arrays to check if they happen to match This is actually possible. $a = [1, 2, 3]; $b = [1, 2, 3]; var_dump($a === $b); // outputs "bool(true)"
Huh, it's very similar to the PayPal API (which is so awful). They seem to have an internal repo and issue tracker but still accept PRs. Though there is some attribution still.
It is actually useful sometimes. I did this recently when comparing data structures to check whether anything's been updated or not. eg, query a DB, build an array, sleep, then query again and use `===` to see whether anything's changed.
Exactly, by defining the namespace in autoload-dev you keep it out of production. It probably has negligible performance difference, but in my mind, anything that is for dev / testing / qa automation should never go to production. Why make namespace an exception? I mean, in the end this is all just personal opinion. Even psr-N is an opinion/consensus - do what works best for you / makes the most sense for you ( within reason).
Yeah, I'm sure it is. But inevitably it's PHP stuff like this that somewhere somehow has an edge-case where it all goes wrong and then it ends-up in lolphp as a reason why PHP is the worst thing to ever exist all worship python python ruby node python... etc. And to look at it another way, to me it's odd that you CAN do this but not the same with objects. In my mind it'd be cleaner, clearer, and better if it was just left to dedicated functions to test if arrays match, and then we wouldn't have questions like this one about objects and ===. There would be more consistency, and a clearer line between different basic data types and more abstracted data types.
It's still in dev, and has been for years. Meanwhile other modern frameworks have taken over, and have so for years. Truthfully it seems they are having a hard time getting talent to really finish it off. I'd call that dead. Even though yes, it's far enough to come along that a release may occur, but it's too little too late. The thing about dying frameworks, if they were popular, kind of go out kicking for quite awhile, due to interest in maintaining legacy applications.
Considering that it's really hard to disable eval (and not possible without extensions), then it's not a big deal. Yes, defense in depth. And you can disable eval. But if you're disabling eval because people are injecting code, you're already done. If they can get code on your server, disabling eval is not going to protect you in the least. The only way without a remote-code-injection vulnerability that disabling eval is going to save you is if you're passing user input directly into eval. No matter what you disable, you'll never be able to save a developer from themselves. So no, I think disabling eval is a red herring. I think the more important thing to do is audit code regularly. I also think that the more important thing to do is prevent the RCI in the first place. After all, it's [pretty trivial](https://github.com/Ocramius/ProxyManager/blob/97ef3af0d96422d85359bed980241bff2b9c879e/src/ProxyManager/GeneratorStrategy/EvaluatingGeneratorStrategy.php#L49) to emulate eval even if it's turned off...
Hopefully we can move away from Magento all together. I just wish Sylius was a bit more mature.
I like the idea of including it somehow in the Composer process, but I'm not sure history tracking is a good kind of thing to push into the json config. In my opinion the `composer.json` file is more of a "current state" kind of thing and less of a history. I wonder if something else could be added, maybe a `security.json` or something that could piggyback on tagged releases to check the commits included and their messages for a special kind of string match ("fixes: ...." or something).
Are you encrypting passwords? If so, what type of encryption are you using? What other data are you passing into Sessions/ Cookies? Are you ensuring that nobody can spoof the login forms or attempt to inject nasty SQL into the forms? Lots of questions, but answer those, and we'll be able to more accurately tell you if it's secure.
mathiasverraes/money and sebastianbergmann/money are the best we have right now. Things I dislike about them: 1) The use of integers internally instead of depending on bcmath (The limited precision here can and will bite you, especially if you need to change it after the DB already has values) 2) Hardcoded, randomly-gathered currency list. I believe that the currency list must be auto-generated from a trusted source (ISO or CLDR). That's what my library does: https://github.com/commerceguys/intl For currency conversions you will want to use https://github.com/florianv/swap
Mandrill is for sending important emails pertaining to users' accounts such as resetting their password, new orders, shipping updates, etc. It's not for sending bulk at all. You're likely to get your sending rate lowered to 5/hour or completely banned if you send bulk.
Post the code so we can check it out
It's really hard to tell without looking at your code. I'm far from being an expert in php security but I know the basics. Security is ~~an art more than~~ a science and requires practice and attention to details. If you store passwords, hash and salt them using the latest functions available. Avoid doing your own stuff. Salting using current microtime and md5 after is bad. Acutally using md5 for anything is almost certainly a bad idea. A simple solution is to use password_hash (which includes salt automatically if none is provided). Always look for the most recent tutorial/information you can find on this subject. What kind of session are you using? I'm biased towards saving sessions in the database for multiple reasons. In my most recent project I had sessions saved in the database on login, expire after X amount of time (or on specific behaviour requested by the client). The session ID was associated with the user IP so every time you look at a page inside a restricted area it looks for your IP and the session id to see if they still match. I'm sure there's a better way but that's the best I could come up with on my own. Go read about XSS (cross-site scripting), specially if you have a CMS, and CSRF (cross-site request forgery). Also you need a good grasp of social engineering. It's one of the main way to bypass security. Avoid secret questions when the user forgot their password, for instance.
Don't encrypt passwords, hash them!
That's the great thing about standards! We have so many to choose from. And if we don't like any of them, we'll just make a new one!
More info (if &gt; 5.5): http://us3.php.net/manual/en/book.password.php
&gt; dont need a uber secured system. What's the URL to your site again? 
Looks good. I had only [one issue](https://github.com/Vectorface/dunit/issues/5). Btw, do you support semver ?
Get an array of octets: explode('.', '123.456.789.444'); Result: array (size=4) 0 =&gt; string '123' (length=3) 1 =&gt; string '456' (length=3) 2 =&gt; string '789' (length=3) 3 =&gt; string '444' (length=3) Cut the last octet off: implode('.', array_slice(explode('.', '123.456.789.444'), 0, 3)); Result: string '123.456.789' (length=11) Return the last octet: implode('.', array_slice(explode('.', '123.456.789.444'), 3, 1)); Result: string '444' (length=3)
Thanks, edited my post
Don't forget to check the results $ipaddr = '123.456.789.444'; $octets = explode('.', $ipaddr); if( !isset( $octets[3] ) ) { // Something went wrong, IP might not be valid! }
What's the deal with the font? It's [hideous](http://i.imgur.com/gpWIbaQ.png).
.. and on this shitty laptop monitor the grey is hard to read.
I see what you did there.
Put your code on pastebin.com or something and show it to us.
Are you providing a "remember me" function? Are you setting ANY cookie data other than the normal PHP session ID cookie that gets set?
Though your font-rendering looks really off there, I never really noticed the custom font myself (Sintony). Have removed it since.
&gt; Considering that it's really hard to disable eval (and not possible without extensions) I know this is a bit offtopic, but the fact that eval (or isset, empty, etc.) *can't* be disabled via php.ini just because they are language constructs is a bug in PHP. From a userspace POV, there is no difference between internal functions and language constructs, so `disable_functions` not supporting eval is a leaky abstraction.
I think the fact that `disable_functions` exists is the leaky abstraction. It's one reason making portable PHP code is a PITA. Because system admins who think they know what they are doing randomly disable crap that has no business being disabled. Especially in the case of eval, because it can be simulated trivially: function eval2($code) { $file = tmpname(); file_put_contents($file, $code); $ret = require $file; unlink($file); return $ret; } You wind up with systems like this: https://github.com/kriwil/OpenX/blob/6804041a8f74d80f6fae4df3320576cc3bba06ff/pre-check.php#L252
If I un-whitelist your site's javascript, the text looks fine.
So, has PHP really changed? The last time I used PHP was around the time PHP 5 first showed up. I remember it as *okay*, but really frustrating at times. I've in the meantime switched to the ASP.NET MVC and I like it. Recently, however, a friend has pointed out that PHP is "much better" now and that there are some great MVC frameworks such as Laravel and Symfony. A coworker has claimed the same. Is this true? If so, any recommendations for me on how to "restart" myself as a PHP developer?
Whats the most important trick to learn regarding PHP? 
Here is why: http://www.google.com/trends/explore#q=symfony%2C%20laravel&amp;cmpt=q You will start seeing more projects in laravel than symfony in the coming years. Given that laravel's popularity continues to be larger than symfony. This does not at all mean that laravel is a better framework than symfony. 
It's hard to educate people who are resistant to it. Seems like a lot of people just want a stack-overflow style answer so they don't have to understand anything.
So I see we are on the same page :-)
Its on my localhost ;)
I am making a CMS for school. I have lessons in PHP. The teachers also learn how to secure your stuff. I basically use the encryption of the phpMyAdmin database system for passwords. So far the only thing I do with session, is just to check if the username is set. My question was:"Just checking if the username is set, is that good enough to login? Or am I missing a major thing?".
Yes...? We weren't discussing disabling eval, I specifically started with "this is a bit offtopic" :)
This is the only thing in the session on all pages except login.php: &lt;?php session_start(); if(!isset($_SESSION['username'])) { header('Location: login.php'); exit(); } ?&gt; The username is set afer you login with the correct password.
This is the only thing in the session on all pages except login.php: &lt;?php session_start(); if(!isset($_SESSION['username'])) { header('Location: login.php'); exit(); } ?&gt; The username is set afer you login with the correct password.
https://github.com/magento/magento2/blob/master/README.md Never used Magento before... after reading that, I have no intention to try it.
How are we meant to advise on this question without code? Put yourself in the shoes of readers, and ask yourself how you would begin to answer this. NB: any time you ask a question on any board relating to code, please show the relevant part of the actual code you are talking about.
If you need to compare two strings and relate them strictly as strings, there are already ways to do this in PHP. As I said, nothing changes. I won't argue whether or not it's *going to* happen, because that's a pointless discussion. I'm only offering up my opinion on what I think *should* happen.
Sure, cause the Javascript is what loads the custom font. In my experience, browsers on Linux are often pretty shitty at rendering webfonts, but that may be cross-platform.
In short, as long as you escape and quote properly and use an ASCII-compatible character encoding for your MySQL connection, you're actually fine. But still it's deprecated so try not to use it if possible.
Please use filter_var, inet_pton etc. functions for ipv4 validation. Because of this code true for 999.999.999.999 blocks.
mysql_query is not deprecated for security reasons. It's just deprecated, like posix regexp was : it's an old extension, replace by mysqli. Using mysql or pdo will not automaticaly protect you from SQL injection. It help only.
 echo '.' . end(explode('.', '123.456.789.444'));
Link seems to be broken. Heres a fixed one https://github.com/michaelbasford/php-cli
We'll need to see the actual log-in system too. 
Exactly. Saying you don't need a uber secured system shows some serious lack of awareness. The most common vulnerabilities exist because someone thought "nobody will do that" or "we'll do it later just before deploying to production".
This is getting annoying..!
It'll be interesting to see where it is in another year or two...if you look at the trends for those two and add in Zend Framework and CakePHP you'll notices the same kind of upward trend over a year or two then it starts to level off and even drop. I think with the emphasis that's being put on package-first development vs full-stack these days in PHP, I can't think of any other full-stack frameworks that would be right there along with Laravel. (yes, I know Laravel is largely made up of various components, I'm talking about it as an end result not the pieces).
What do you mean? Can you just give me a step by step walk through of what I need to do exactly? I don't know what you mean by "log files". I only do FTP, so use FTP in your response plz.
&gt; possible duplicate of [eval base64_decode php virus](http://stackoverflow.com/questions/5922762/eval-base64-decode-php-virus) ? ---- And disabling eval would indeed just be an unreliable workaround. Even though the larger part of obfuscated code uses that, it's not really uncommon to see variations of `include("data:,$code")`, `create_function()` or just writing the payload to temp. files - which is basically all that differentiates `eval()` from `include()`. But getting back on topic, these days it's simply too convenient to install an arbitrary run-of-the-mill PHP script. Which is why the unenthused user base does it, then even expects copy+paste help-me quickfixes when something goes haywire. (I hereby presume newcomer-coded scripts are less frequently affected by common exploits despite ignoring pretty much all safe coding advises, simply due to being custom-written.)
Looks good! Out of curiosity, why not Cilex? https://github.com/Cilex/Cilex These kind of look like they accomplish the same thing.
Thanks. I wasn't aware of Cliex, this is just the way I've being doing it. After a setting up the same thing for a few apps I decided to make it a package.
I don't know about that blog post. Open source just means the source is open for all to read. I don't think open source developers have any further obligations than that.
It's a pretty standard-ish license though. Not too far different than GPL. They don't you adding to the code and then suing them for using your contribution.
I think there's a gray area in the term bulk email. From my understanding, you cannot use Mandrill to send newsletters. It's fine to send lots of emails with them, but they must have content that is specific to the recipient.
Of course you can. That's what we make a living by. We help our customers send newsletters to their customers every day. We offer the same services as campaignmonitor and mailchimp. And there is no issue using Mandrill for this - at all.
Alright thanks for clearing that up. Mailchimp just writes the copy on Mandrill's site to make it sound like it's against their terms, even though they just say don't send spam or put SSN's in emails.
of course, sorry :)
Magento is the best option there is, from a business stand-point, currently. I'm just starting to work in it, and I'm not enjoying it. It's a mess, and the documentation sucks. Hopefully Sylius will be the next big thing, and not suck.
forgive my ignorance but what do you use instead?
Here's a few (simple, yet effective) things to try: ONE. Make sure the cookie didn't get stolen On login store the IP/User Agent string with this code: $_SESSION['ip'] = $_SERVER['REMOTE_ADDR']; $_SESSION['agent'] = $_SERVER['HTTP_USER_AGENT']; Then check the data with each request like this: if( $_SESSION['ip'] != $_SERVER['REMOTE_ADDR'] || $_SESSION['agent'] != $_SERVER['HTTP_USER_AGENT'] ) { session_destroy(); header('Location: login.php'); exit(); } TWO. Regenerate the session ID If the session succeeds, call this function: session_regenerate_id(); This will change the session ID on every request and make stolen cookies (even ones with the same ip/agent) useless. THREE. Don't let people idle for too long On login store the time. Also do this if the session validates. $_SESSION['lastActivity'] = time(); Check the time with this: if( $_SESSION['lastActivity'] &lt; time() - 900 ) { session_destroy(); header('Location: login.php'); exit(); } 900 seconds = 15 minutes. ...these still have a few pitfalls, but will work for a beginner. EDIT: roodit turned all my numbers into "1."
Wouldn't the logical extension of "educate, don't mediate" be to teach them *why* eval is ~~evil~~ dangerous and, rather than disabling it, writing code so it's not included. That also avoids the issue of emulation. I say this because I had a similar reaction to /u/andrewjsledge, which is "well, believing that you've caught all the possible ways of injecting code is as bad or worse than not making yourself vulnerable to eval-based attacks and saying you're done." Otherwise, it wouldn't be "FIEO" it would just be "FI". If you're trying to say that in this post, I think it could be clearer.
The article explains it &gt; Where you might be used to fork a project, update, send a pull request and get proper attribution, in Magento 2 the last part is completely missing. They take your submission, incorporate it in the code base and on Friday they push a big commit with no reference to the original corporation whatsoever. This is not about personal ego, but rather about building something together and getting attributed for it.
The problem wasn't that eval is dangerous. It's that they had a Remote-Code-Injection vulnerability, which was used to upload an eval statement (it could have just included native code). So disabling eval, or removing it, isn't solving the underlying RCI vulnerability, but is just removing the attackers code (which (s)he can simply re-inject, since the original vulnerability is still present).
I used to work in engineering at Y!, but that was 5+ years ago now. At the time, the delicious team has just adopted Symfony, and all our PHP work was following their lead. The Answers team were rebuilding in Symfony, and our team were using it too. It was enough to swear me off ever using Symfony again. Yahoo! would typically have they own versions of things that were slightly different from the open source versions, either to improve security, or performance, or to integrate with some sort of Yahoo! platform internally. Every technical decision in that environment is lead by one of those factors - security and / or performance. And advertisers. Even if that results in a sucky UX. When you're the size of Y!, security and performance can never be comprised, but user experience can be, so. Tools wise, we used CVS for version control (even though subversion was dominant and git was gaining traction in the outside world). Most engineers used Eclipse or something based on it. Quite a lot is use used MacBook Pros running VMware. Skill level varied depending on role, but everyone was pretty great at their jobs. You get a lot is specialists, as its a very specialist environment. For example, our team had a guy whose job was to keep the build running. Full time job, and he worked hard. As I say, this was going back a few years. Happy to answer any questions, without revealing anything Y! would consider confidential.
What's your ip?
A registry/service-locator would be far better than the approach you're suggesting.
We shouldn't be defining whether or not something is open source based on how it's developed, but rather by whether or not the source code is made available to the public by the developers. Even if there is no roadmap, no issue tracker at all and no revision naming, it is still open source. You can still download it, fork it and change it. I don't see being able to push your changes back up as a requirement in the end. There was open source before GitHub, and I'm sure that not all Open Source Software was easy to push changes up to. But the basic idea of being able to fork the code into your own is all that's needed in my opinion
&gt;Magento is the best option there is, from a business stand-point, currently. Is that just in PHP land? If there are better alternatives in other languages then I'd honestly say that it would make more sense to learn another language in order to use another e-commerce solution than to bother fighting with Magento and it's non existant documentation.
That that is pretty neat
I'm going to go ahead and assume that most people (myself included) are wondering when such a thing would be needed. Does anyone have a practical use case?
Ah, ok, misunderstood the nature of the vulnerability. Never mind then.
?
Good luck. The curve is steep but once your figure it out its pretty simple and very powerful.
Mine too. I'm working on it as much as possible.
It's needed in big data environments, that of course are not a common environment... Or say you want to be able to cover a lot of bit streams for a big window fitting the data into memory. In these situations you can't simply store all last N bits.
The code looks really bad. I mean apart from the config hell and the fact that you are not writing code but just editing config files to get stuff done. class DefaultController extends Controller This is really bad. From your example it looks like your Controller class is where all the contructor dependencies are declared. So all you controllers have the same dependencies... Your controllers (and most other classes) should be stand-alone and have their own dependencies declared. If you need your twig, you ask for it in your contructor where you need it. Same goes for all other depndencies. I don't care what Fabien Potencier or other framework guys say. This is just bad OOP. Please give [this](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) a read and then reconsider your choices. If you are not sure how to wire things up together properly, maybe give [this](https://github.com/PatrickLouys/no-framework-tutorial) a read. I hope this did not come across too negative or offensive. I just spent way too many hours debugging obfuscated code like that to not care.
I have been trying to understand the exact roll of services. Can you expand/explain what you said?
So, speaking from an adapted and abbreviated DDD set of philosophies, I'd say that I personally wouldn't use that kind of API; for a few reasons (I'll make a bulleted list as to not be long winded). * Factories are good and should be used when the workflow for creating "brand-new" objects is too complex than simply using `new`. * Factories generally don't have knowledge of the persistence layer * Repositories generally have full knowledge of the persistence layer * Repositories could lean-on factories to produce entity objects based on entities already stored in the persistence layer * Thus, a factory could be utilized (as a dependency) in your Repository implementation to produce ready-to-go Entity Objects It feels a little backwards to have a Factory that consumes a Repository and can produce an Entity (from the repo) based off an Entity Identity (prob a surrogate key in your case). I'd much rather be asking the Repository (ie: the collection of entities) for a specific Entity: $entity = $repository-&gt;findEntityById($id); // or $repository-&gt;find($criteria); where Criteria might be abstracted / non-persistence specific // Or in context: $cow = $cowRepo-&gt;findCowById($cowId); My factories might have methods like this: $entity = $cowFactory-&gt;createWithData($data); // where data might already be mapped // or $entity = CowFactory::createWithData($data); // or, even this (if the code base was small/trivial enough) $entity = Cow::createWithData($data); // sometimes I have generic enough factory i pull in via a trait Basically, there's lots of places where a factory could exist, but in any case, I'd expect them to be fairly unaware of the persistence in that case. I'd let my Repository fully understand the persistence and mapping mechanics. tl;dr: let the repositories interface be responsible for obtaining existing entities, not the factory.
&gt; This is really bad. How can you expect that not to come across too negative or offensive? I think Benjamin is more than familiar with SOLID and OOP, but probably thought the Hello World example didn't really require an architectural masterpiece.
Thank you, that was extremely helpful - especially the bit about looking at it backwards. Really glad I asked :) 
It is bad for the reasons I mentioned. If nobody says anything, how do we stop these bad practices from spreading? New people will read and copy code like that. They deserve better. And if the hello world already looks like this, honestly I don't want to see the rest of the code...
Indeed, that's just php land. I've done some research and Magento appears to be the only one worth doing. Don't use opencart. Ever. Ever. 
Ruby has Spree, and it's very decent (Sylius started by copying its general architecture I believe). I especially like their docs. Python has nothing worth mentioning.
 var_dump($var);
What fucking moron is doing eval(base64_decode())? Did I miss something?
Are you copying and pasting that code on every page? Just put it in it's own file and do include 'file.php'; Also, don't store passwords, store their hash. Hash your passwords using password_hash(). Verify your passwords using password_verify(). This way you don't need to worry about using a secure algorithm or keeping track of a salt. 
&gt; I basically use the encryption of the phpMyAdmin database system for passwords. What does that even mean? You change the database column type? Thats not a hash. Sounds like someone could easily decrypt it.
Changing the session id on every request is all well and good until you start doing any AJAX calls. Apart from that, looks like sound advice. 
To summarize everything everyone wrote, **the single code snippet you posted is secure**. No one can inject session variables directly into an otherwise secure webpage or else the entire web would be vulnerable. So if everything else is flawless security wise throughout your entire site, only users with `$_SESSION['username']` set would access that page. Now, the entire login process and database structure, which you haven't posted may not be secure, and may allow an attacker to change his/her username. Other variables or events you are handling on the server may also allow an attacker to change the session variables. So it is not enough to say "Yup, looks good" when there are literally thousands of other mistakes you could make that would make it insecure. Summary: Snippet=secure, rest of site=?
True, as composer descriptors were just intended for conrete package version subsumption. To avoid bloating them up too far, a `provider-includes:{}` might help. If it were feasible for singular packages.json then a `security.json` would make the best approach. An ad-hoc `"extra": {"include": ["security.json", "history.json"]}` might make sense for use-case brevity. I'd personally lobby for inclusion of a complete history still for self-interest. Specifically [releases.json](http://fossil.include-once.org/freshcode/wiki/releases.json), as to encourage having an actual changelog (which are extremely rare still for common PHP projects' release processes). In the context of security advisories, I'd say it even makes sense to provide a more complete history. The CVE repo only lists critical and uncovered security issues, but even trivial logic bugs may regularily amount to security issues outside of a library/packages context itself.
 php example.php 3000 10 0.01 ... N: 1599 Predicted: 7906 Real: 7919 Error: 0% That's not actually 0%.
Basically what ralphschindler said. Personally I would only use the term Service for functionality in my applications that is periphery to my application. E.g. a typical service would be a MailerService that represents an abstraction to some 3rd party thing, i.e. SMTP, Mandrill, mail(), etc.. My application would have to send out email but it's not part of the core business logic, e.g. calculating invoices or what ever. The term "service" is often used in the context of dependency injection and "wiring' of the container (hello Symfony). In the Java world they have a better word for what we in PHP call a service, in Java they call it a "bean", or Java Bean. In your situation, I would only ever have a factory if the creation of Cow objects is very complex. There is no other reason to have a factory. E.g. you have a Menu with default MenuItem's and each of the MenuItem's has a number of default MenuItemOptions. The create a new Menu object you could use a MenuFactory that would create this complex structure. Instead of Service, I personally prefer to use the term "Manager" for my business logic "services". E.g. I would have a CowManager which is responsible for all the management around cows. However, the actual retrieval and persistence would happen in the CowRepository. class CowManager { public function createCow( $name ) { $cow = new Cow(); // or $cow = CowFactory::create( $name ); return $cow; } public function getCowById( $id ) { $cow = $this-&gt;repository-&gt;getCowById( $id ) return $cow; } } As you can see, all your other business objects only ever talk to the CowManager in regards to Cows. Only the CowManager knows about the CowRepository and the CowFactory is simply there as a helper to abstract away the complex Cow creation. Hope this makes sense... 
This sounds like something I'd refer to as "public source". As in the source code is viewable publicly, but its not greatly inspectable nor contributable. Open source only in looks, not in spirit.
Not useful, but prototypal-like inheritance implemented in PHP: https://github.com/danielmunro/phrototype/blob/master/src/Phrototype/Phrototype.php
It's a Go. It takes some learning (I recommend the video training series), but once you've figured it out, it's very adaptable, reliable, and secure.
192.168.0.104 
ISO 8601 is the international standard way of rendering dates. Please don't be a nationalist about it :(
 error_reporting(E_ALL); 
If you want to jump into frameworks Laravel is pretty awesome. Jeffery Way has a great starter tutorial (as well as an amazing site in general) here https://laracasts.com/series/laravel-from-scratch I started writing PHP around 5 years ago and Laravel has seriously made it fun again.
This is fine to verify the user has authenticated. The underlying session system from php will take care of that by doing this. I read a few of the comments and it is a little concerning how you store your passwords "encrypted like phpmyadmin". You should never store your passwords in a non-hashed format, even then you should be salting it. If you're just doing this for fun, why not use an established framework with established guidelines for doing things like this? Eg. laravel, symphony, etc. The only attack your check is vulnerable to from what I can tell is a session hijacking. You can help prevent this by doing a couple things: store the useragent of the original login or perhaps the ip address in the session and verify those match in this check here. I believe there is an example in this thread showing something like that. If you do add the ip address check, keep in mind some people's ip addresses change often, and users with proxies like tor will basically be unable to use your site if you implement that. The sky is the limit, don't set your aims low because you don't NEED that, instead aspire to something you will learn from, and grow from there :) 
I actually kind of disagree here, and I’m not sure why an “or” terminology is being used here. Too much discussion seems to be around whether to block the injection site or the ability for the code to be executed. Surely the only question is which to fix… first? Unfortunately, neither is trivial to fix. While there absolutely shouldn’t be a code injection vulnerability many of them live on third party software. I used to run commercial forum that needed to be updated to prevent vulnerabilities in the code that handled user avatar uploads. It wasn’t exactly practical for me to fix that on their behalf. 
I hate listening to experts! Why is other people's expertise that they've built up over many years of intimate and high level work with a specific technology supposedly "more valuable" than my ignorant opinion that I haven't thought through properly?!
Edit: [Here's a better explanation from a source much more knowledgable than myself](http://martinfowler.com/bliki/EvansClassification.html) Good response, but it is only partially accurate. A CowService shouldn't exist, since its name says that its only a service for doing stuff with Cows. Here's a slightly more in depth explanation. Quote from DDD by Eric Evans &gt; When a significant process or transformation in the domain is not a natural responsibility of an ENTITY or VALUE OBJECT, add an operation to the model as standalone interface declared as a SERVICE. Define the interface in terms of the language of the model and make sure the operation name is part of the UBIQUITOUS LANGUAGE. Make the SERVICE stateless. Services are supposed to be places that incorporate logic that doesn't fit nicely inside the scope of a single domain entity. That doesn't mean all logic that pertains to a single entity that doesn't nicely fit in that entity goes inside a catch-all service. So by this definition a CowService is a bad idea. In this case you have a couple different services. CowRepository for finding all (or a specific subset of )cows that have been persisted to a db or still exist in memory as well as persisting it (some might argue persisting entities should be a separate service). You might have a CowTraderService, that allows farmers to trade cows, since $cow-&gt;trade($trader) does make much sense. You could have a CowFactory that knows how to create cows, but has no contact with the CowRepository since it doesn't need to know anything about persistence, just creating an object (that may or may not be persisted at a later date).
You can use JSON data type in postgres! i sometimes need to do that to save time and code, you can even query on that JSON field. Have a look here: http://clarkdave.net/2013/06/what-can-you-do-with-postgresql-and-json/ and here: http://stackoverflow.com/questions/18067165/how-to-use-json-operators-on-json-typed-column-in-postgresql-9-3
we have a more complicated flow but it was much faster and less conflicts once u get used on it. Server repo has 3 branches: - Production (prod) - Candidate release (ca) - Dev every developer had his/here own repo. - everytime anyone start working on a new feature pulls server/ca to his/her own master branch, lets say (developer1/master). - the developer then branch from master do what ever needed and push to developer1/issue-123 - someone merges developer1/issue-123 to server/dev - QA the stuff there and then rebase the commits into one and cherry-pic them to candidate release, QA again then push to production. Less conflicts, peer code review, less bugs and issues, and a better aligned team.
Try this thread: http://stackoverflow.com/questions/3243900/convert-cast-an-stdclass-object-to-another-class
&gt; I personally prefer to use the term "Manager" What does you cow manager do? That is the primary objection to using "manager" -- it has no meaning. Now, I don't think "service" is all that much better, but at least it doesn't promise to "manage" anything.
Yes I agree, make your own class that does this for you and use it as a custom library for yourself. Its the same idea of feed a man a fish, teach a man to fish. In this case, teach PHP to json_decode_object :D
Welcome to programming, where sometimes you have to program programs. Although you can probably find some json to object / class examples out there, you can't expect to have a function that just intuitively takes some arbitrary representation of an object and builds it in such a way that it works the way your program needs it. These objects may need methods, behaviors, validations, various protection/access levels, etc. If you just need a simple object that represents a simple row of data, it's easy enough for you to write or find a function that does what you need. If you need a full fledged object, then do what you're doing already. Edited to fix the "woke up in the middle of the night so I better check reddit" spelling. 
Yes, coupling your controllers to your framework is bad. I guess you never had to migrate to another framework? I had the pleasure and it ended up in a complete rewrite. But that was not even my argument, I was talking about the controller dependencies. I guess this is why all those frameworks use the service locator antipattern. It is one bad practice to cover up another which ends up in a lot of tight coupling and obfuscated code. If I have to go look in another class just to see what the dependencies of a class are, then I am doing it wrong. It should be clear on first glance. Which is why it should be done through simple constructor dependencies. And by the way, php-di is a bad example too. It is advocating the service locator antipattern. Else, use $container-&gt;get() in your controllers (but avoid it in your services) but keep in mind that your controllers will be dependent on the container You should NEVER pass in your DIC into your application. For a good implementation have a look at [Auryn](https://github.com/rdlowrey/Auryn). There is a reason why this "perfect" OOP exists and books like [Clean Code](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) were written. Good practice leads to maintainable code. Keep downvoting me, looks like a professional approach to software development is looked down upon here. No surprise other developers don't take the PHP community serious.
No, a REAL hacker would use TracerT and find his IP next time he goes to Google.
My CowManager creates, deletes, updates, milks, herds, transports, sells, combines, etc... I.e. cow related business logic. If something is called a manager, what would you expect it to do? This is a serious question because to me the word "manager" communicates the "intend" of its function. 
don't be naive, there are tons of php experts out there, to whom we all follow through social media to get updates, links to thier blogs or sites. One does not neccessarly need to post 24/7 to teach anything to pass information. I see those spam fests as nothing more than an effort to get adsense clicks.
I don't think that's the correct distinction on Services. You could expose CowManager as a Service, but CowManager is not a service by itself. The service layer is there to provide easy access to components from other components, typically by building them for you and handling all of the dependencies. The difference is obvious here: // no services $this-&gt;cm = new CowManager(); $this-&gt;cm-&gt;setRepository(new CowRepository(new DB())); $this-&gt;cm-&gt;createCow('lucy'); // exposed as a service $this-&gt;getService('CowManager')-&gt;createCow('lucy');
&gt; DDD Development Driven Development?
As stated in earlier comments, there is no issue in using Mandrill for bulk and generic mails.
To me a "service" is any type of object that is available through a service container. I can wire up a CowManager in a service container with all its dependencies. 
If you had so much trouble rewriting the controllers in your migration, then maybe that's because they contained too much logic? And are you seriously using that sentence, extracted from all context, to say that php-di is a bad example? Let me post [the full paragraph](http://php-di.org/doc/getting-started.html): &gt; ### Get objects from the container &gt; $foo = $container-&gt;get('Foo'); &gt; But wait! Do not use this everywhere because this makes your code **dependent on the container**. This is an antipattern to dependency injection (it is like the service locator pattern: dependency *fetching* rather than *injection*). &gt; So PHP-DI container should be called at the root of your application (in your Front Controller for example). To quote the Symfony docs about Dependency Injection: &gt; &gt; You will need to get [an object] from the container at some point but this should be as few times as possible at the entry point to your application. &gt; For this reason, we are trying to provide integration with MVC frameworks (see below). &gt; To sum up: &gt; - If you can, use `$container-&gt;get()` in you root application class or front controller &gt; - Else, use `$container-&gt;get()` in your controllers (but avoid it in your services) but keep in mind that your controllers will be dependent on the container Anyway I think there is no point discussing anything further given how much bad faith you display.
The error is rounded, 13/7919 &lt; 0.5%
I recommend you taking a look at the JMS Serializer. It works with annotations so you can choose yourself what you want to have in your object. 
No, no. Use, debugger, and you almost never need `var_dump`; 
I was looking for something similar and ended up using this package. Works great. 
Once you're good with essentials, use an IDE (PhpStorm or at least NetBeans).
Is there a phrase we can use that relates to an Open Source project being open with the community? Open Source has a simple definition but this doesnt involve community, collaboration or planning. We say "free as in libra" or "free as in beer". What if there were phrases like "Open Source as in code" or "Open Source as in community"? (Maybe a better word is needed instead of community.) I think if we had a simple common way to differentiate the 2 types of projects then firstly there'd be no delusions of how a project was run and secondly projects that were doing code dumps may be encouraged to involve community more. A difficulty would be defining shat constituted an "Open Source as in community" project. Contributions are a must. What about public issue trackers and planning? What about knowledge parity between all collaborators (i.e. no secrets)? Perhaps a single phrase can't encompass the wide range of possible ways a project can be open. In that case, perhaps a range or a set of agreed bullet points would work.
Found a good article addressing my case to some point: http://www.testically.org/2013/01/15/4-simple-tips-to-avoid-fat-controllers/ (examples for Symfony, but the concept is universal)
I actually agree with /u/ForeverAlot - when I see classes which are named SomethingManager I consider it to be a code smell; the term manager is simply too open-ended to describe anything about what it does - it conveys no intent and no semantic meaning to the reader! In reality, most often when I see a *Manager in a codebase it's a class that has no single concern - otherwise it would be easy to name it after that concern and/or pattern used (eg CowFactory, CowRepository, CowAdapter, CowSerializer etc). Unlike the hypothetical CowManager these classes convey the the purpose of the class as well as delineating what functionality may and/or may not be present.
Again, it was submitted by another user, not ircmaxell. You don't really have an argument here. 
First of all, ircmaxell is far from an asshole, he is a contributing member of the community. Secondly, I don't mind seeing posts from the same source assuming the post is on-point and relevant to the community. Finally, [the posts aren't submitted by ircmaxell himself, but rather by other community members](http://www.reddit.com/domain/blog.ircmaxell.com/), meaning that it's relevant and in-line with the community's general interests. 
Depends what sort of mistakes you're making. I find an IDE helps remove most of the stupidity, ie showing me unused variables and mis-spellings
You might be interested in [JMS Serializer](http://jmsyst.com/libs/serializer) or [Mantle](https://github.com/kleiram/mantle) if you're looking for something a bit more light weight (disclaimer: I wrote Mantle).
I don't believe controllers need to be 100% decoupled; it's simply not always practical. It's excusable provided your controllers are thin enough. However the "config hell" sentiment I 100% agree with. Full-stack symfony apps often obfuscate dependency injection with tons of boilerplate code.
Prestashop has come a long way, so compare them maybe. But I evaluated both a year ago (so not Magento 2) and surprisingly I never found how to do some basic things like applying a discount on a cart based on products attributes (e.g total weight). Magento fails in other aspects* like you can't delete orders (wtf) and orders status are weird (can't close or cancel them easily). But it was for a small company so I couldn't spend a lot on paid extension, but it has worked well for a year now. [Magmi](http://wiki.magmi.org/index.php?title=Main_Page) was a life saver. How many times have I contemplated starting a new ecommerce solution. You know the one with amazing coding, easiest extension api, the best templating in the world etc. But lets be realistic, it is way hard and more than ever in a world where you need rest, responsive and mobile design, performances, especially if you target a Php/Mysql platform where the main paradigm is still stateless/request based. *three years ago I lost numerous days debugging Magento because it couldn't correctly calculate VAT. How can an ecommerce solution screw that ?
findFirstEarliestBucketIntersectingInterval =/
I saw some missing documentation, is this what you refer to? Or are there other issues as well. (is the code production ready?)
Oh man you made me laugh out loud. I need to rewatch that video.
I disagree with this: &gt; Security is an art more than a science so here are a few key elements Especially considering you admit that you're not an expert in PHP security. How can you know it's not a science if you aren't an expert in it? All these semantics aside, the most I could agree with you on it being an art is when one starts getting into the area of predicting future security vulnerabilities. All known security vulnerabilities can be patched; there is a solution to every one (thus, science). The unknown ones? Sure, that could be described as an art I guess, in that it's the way you code your apps or set up your server that makes it future-proof. But even that's a stretch; you use (scientific?) principles to apply future-proofing, not necessarily and especially not only creative skill. In that sense, it's a hard science no matter which way you interpret it (even a scientist's microscope may be artistically designed, but at the end of the day, art isn't going to help him enlarge a microscopic object).
You'd be surprised. Pretty much every ecommerce solution has VAT issues, especially around discounts. We're redoing taxes for our own ecommerce solution (Drupal Commerce, about 50k live sites) and releasing the actual logic as a separate library, but needed to hire our own VAT expert before we got all of the tricky details right. 
And a plethora of other concerns but remember this guy is a beginner and the advice is geared as such - if you asked him if he made any AJAX calls he'd tell you he didn't have AJAX's number.
I like how absolutely everyone in the world uses DMY, whether it's in reverse or not, at least as their primary format. . . Except the USA.
Yes to be fair it's hard because each country does it differently AND PHP is quite weak with numbers/floats. I work on an payment solution and some weeks ago we had a rounding bug that lost us some money.
Domain Driven Development
Maybe I misunderstood the question, but you want to translate json response to an object in PHP? You just do it like this: $x = json_decode($jsonResponse) and you get an stdClass Object. 
You could try querying the server for a result set once the user has entered the first two characters, that should narrow it down somewhat.
:) Fixed.
Now I think about it I agree that after the first character there is no real need to query again yet, but after the second character I think I want to try to do it after every single keystroke. I will be implementing this during the day to see if this is viable. Thanks for your reply!
But what is the actual benefit of tighly coupling controllers? Instead of writing a few more lines of code in your controller you end up hiding your dependencies in config files. class MyController extends Controller { public function show() { $myService = $this-&gt;serviceLocator-&gt;get('myService') $data = ['myServiceData' =&gt; $myService-&gt;getData()]; return $this-&gt;render('myTemplate', $data); } } It's shorter but you have no idea from looking at that code of what the dependencies are. I have to open multiple files (DIC config, the Controller class) to get an idea of what's happending. Testing this will also be horrible and if someone adds a new dependency to the Controller class because another controller needs it then all my tests will break. public function Presenter { private $templateHandler; private $response; private $myService; public function __construct( TemplateHandler $templateHandler, Response $response, MyService $myService ) { $this-&gt;templateHandler = $templateHandler; $this-&gt;response = $response; $this-&gt;myService = $myService; } public function show() { $data = ['myServiceData' =&gt; $this-&gt;myService-&gt;getData()]; $content = $this-&gt;myService-&gt;render('myTemplate', $data) $this-&gt;response-&gt;setContent($content); } } Here everything is clear and testing it is a breeze. Extending all your controllers from a base controller is just a bad idea. It does not make sense at all.
Security is definitely a science - people who know far more than most of us produce papers every day showing that X is bad practice and Y is significantly better. If you implement the best practices, you'll be secure. If you don't, and go off and do your own thing because "I think it'll be better this way", or you fail to keep up with the best practices, you won't be secure. Knowing how to implement those best practices in a way that is readable and won't accidentally leave you insecure if you mistype one thing is potentially an art, in the same way that software engineering in general is an art. If you're given a codebase, figuring out where the security issues are likely to be is also an art. The specific details of what you're supposed to be implementing? Definitely the result of a science.
I was speaking in framework-agnostic terms. I might for example write `public function myController( \My\Application $app )`, and then use `$app-&gt;templates` or `$app-&gt;someService`. This is convenient when writing the controller (less boilerplate) and the routing (you need only configure a single dependency). You do pay for this convenience in testability and OO purity. I would *not* do the same thing with Symfony's container. I agree with you, the code becomes unclear. That is actually a general problem with these key-based, configured containers. They are unnecessary, error prone abstractions; and they do not allow static code analysis.
I'm not a big framework fan in general, but Symfony generally added masses of overhead to both page build performance, and to development workflow. It was just a mess that hindered way more than it helped. I've no idea about the percentage of graduates, but I suspect it depends on who hires you. I was unaware of any policy either way. I don't have a degree. But then I don't think I was ever even asked about that. I'm not sure it has much relevance. Given two young developers presenting the same working knowledge of PHP, one with a degree and one without, I'd be far more sceptical of the graduate. With a self-taught dev, you know they've got what it takes to keep learning because they have a track record. With a graduate, their track record doesn't reflect the future. Will they be able to keep learning, or do they need to be spoon-fed everything like at university? What is it about their personality that made them carry on in education for another 3 or 4 years rather than getting to work? Are they work-shy? It's a gamble. Once you've got a bit of experience, no one cares about your education.
I've done this before for a similar situation. PHP actually has a pretty robust imap/email system. Here's a great composer package :) https://github.com/barbushin/php-imap Basically, set a cron to run a script which checks for new emails. In your case you could simply ~~explode()~~ str_getcsv() the message body and get a super sweet array:) 
Yes and it is not a problem though. The build statuses are provided by [Docker Hub repository build details](https://registry.hub.docker.com/u/brunoric/hhvm) and inserted manually in the documentation. I am also developing a little tool to handle Docker Hub web hooks and soon it will be the automatic way to handle that statuses. But thanks, I added this information as a note in the README.md to make things clearly.
That's stupid. You could just create empty interfaces from the start.
Have you read internals? 
Don't forget to put an index on that database field :)
It manages entities of the type "Cow". It's a bit vague but not entirely meaningless. I also use the Manager suffix for these types of things, so does Doctrine (I think). For me, these are usually the highest level services in my domain that expose functionality to Commands and Controllers and whatever part of the application layer.
+1 for the Manager suffix. I think it communicates just enough intent.
If you are working on a small library your line of thinking may be correct. But what if it's going to be 500+ classes? are you going to create 500 interfaces for everything right from the start? Obviously not, you would try to create interfaces only for things that would need them (e.g. thing that are actually going to be dependencies of other things). but how would you find those from the start? You only need interfaces for things that may have different implementations, when you are "interfacing all the things" you are just wasting time. That is why nt using "Interface" suffix is important. If there is only a single implementation and you are sure there is going to be only one you use a concrete type. As soon as a different implementation arrives you swap the concrete type for an interface. This is simple, fluid and results in only as much interfaces as actually needed.
While it is possible to set up manually, I would just use an inbound email processing service. It handles checking for email, parsing and calling your application with the data in a sensible format. One example is [Postmark](http://developer.postmarkapp.com/developer-process-email.html).
&gt; when I see classes which are named SomethingManager I consider it to be a code smell; the term manager is simply too open-ended to describe anything about what it does - it conveys no intent and no semantic meaning to the reader! Considering the purpose of these high order services is to encapsulate and expose parts of the domain to the application layer that are grouped according to entity, I guess the other options for naming them might be... - CowService - CowHandler - CowController - CowFacade (ha) - CowProxy (also ha) But really, if you have interface Cow and a class that is responsible for managing all operations associated with a Cow, I don't see how the term "Manager" is too vague. You could make the argument that this is a super class with scope gone wild and for that reason inherently bad, but I don't think that's true so long as it's a properly composed interface of many smaller parts. I think it makes sense to expose consolidated domain functions to the app through classes like this. In my experience it has worked out quite well. These classes are basically pseudo-controllers, the only difference is they don't specifically deal with HTTP requests.
It's on the to do list! :)
Seems like we are mostly on the same page. If you haven't, have a look at Auryn. It will resolve your dependencies automatically so you won't have to configure the dependencies for each class/route.
If it's your code =) what if you are developing a library that other people use? No IDE will help you change their code. I'm not saying that the advantage is that huge. But using the Interface suffix has 0 advantage. I'll take a small advantage over a 0 advantage any day.
Agree, and by some bizarre coincidence I just blogged about this exact same thing the other day with the same conclusion. &gt; Prefixes and suffixes in type names don’t carry any domain significance. That's really the guts of the whole thing right there. Shameless plug, here's my article on the subject using a Repository example. http://www.codenamegary.com/2014/10/when-to-interface/
&gt;But what if it's going to be 500+ classes? are you going to create 500 interfaces for everything right from the start? This is a strawman. You don't build 500 classes or interfaces right from the start, you break things down and focus on smaller chunks. When you do, you define an interface which you then create concretions against. &gt;If there is only a single implementation and you are sure there is going to be only one you use a concrete type. As soon as a different implementation arrives you swap the concrete type for an interface. This is simple, fluid and results in only as much interfaces as actually needed. And rewrite the class itself, *as well* as every class which has that class as a dependency? Yeah, right. The problem with coding against concretions is that you don't code against a contract, you code against implementation specifics. 
Thank you. I have been thinking about writing the same thing for a while. Interfaces deserve to be treated as first class citizens in OOP. Hungarian notation really has no place in PHP.
I find myself torn on this topic. On one hand, in the libraries that I use, I prefer the Interface (and other) suffixes so that I know what I'm dealing with right away when I pull it in to my project code. On the other hand, I know my own projects inside &amp; out, and could drop the suffixes for easing future changes. I think it boils down to a personal preference / intended audience. For example, Symfony developers will already be used to having the suffixes, so Symfony modules should probably follow suite, etc.
You should name your classes, traits, interfaces, etc. so they show the intent of the function they perform. Some examples: AbstractBase UserManager UserManagerAwareTrait MailerDriverInterface UserEntity Everything is basically a class so you want to be explict when something is not a class, trait and interface, or when something is abstract and should not be instantiated. Short names are stupid. Use names that make sense today and in 6 months time and beyond. 
I would recommend a different approach. Don't try to learn framework X, Y and Y. They will all be outdated soon and you will have to start all over when you try to learn the next cool thing. Instead work on becoming a better developer. Work through [this list](http://stackoverflow.com/a/16356866/2834339). There are a lot of cheap framework X developers out there. But there is a severe lack of good developers in the PHP world (and probably everywhere else). Also, if you have good programming skills in general they are easily transferable to another language, with just framework skills you are not flexible at all. A decent programmer will pick up a new framework pretty fast anyways if he chooses to do so.
&gt; If it's your code =) ?? &gt; what if you are developing a library that other people use? No IDE will help you change their code. Semver, if you break BC, you make it a major version. Then it's up to them to use a proper IDE and refactor their code. &gt; I'm not saying that the advantage is that huge. But using the Interface suffix has 0 advantage. I'll take a small advantage over a 0 advantage any day. Well, yeah it has its advantage. When I'm reading code, and it says I need to inject a `Spell`, how do I know if it's an interface or a class? I'd have to go directly to your Spell class to know. When you refactor from abstract to interface by using the same name - how do you know which part has been refactored or not? They all look the same. 
This comes up [fairly often](https://www.reddit.com/r/PHP/comments/2d5f6n/should_all_interfaces_abstract_classes_andor/) around here, and it seems like it's always the same argument advanced to support this, an argument that ignores what interfaces actually are. Interfaces make a promise of *how*, not *what*. That may seem like a small distinction at first, but if you reason through that logically you'll see why you should be using the interface suffix (because your methods aren't expecting "an object that represents this thing", they're expecting "an object that promises to act like one of these things acts in the context I need it"). 
Apparently some people in here could need some introduction to fundamental programming principles: http://www.objectmentor.com/resources/articles/ocp.pdf http://www.objectmentor.com/resources/articles/dip.pdf Also, for those of you who didn't read the article and simply think this is about not suffixing interfaces, it isn't. Dracony's arguing that one should depend upon concretions. 
The article's not even about what you name interfaces, it's about depending on concretions.
&gt;You are taking this argument the entire different direction. No, I'm not. You said it in the article and you reiterated it here again in the comments. You're arguing that one should depend on concretions and then change to an interface only after you've discovered a need that the original concretion didn't cover. This is tremenduously idiotic, IMO. &gt;My take was that without the suffix it's easier to refactor and to add interfaces as you go And here you reiterate the same thing again. 
So instead of interfacing all the things, abstract all the things? You replace one tedious job with another.
No, dracony is not arguing that. Dracony used that as an examples on how not using suffixes makes it easier to refactor code among other things. Dracony is arguing solely the suffix, not coding practices
Dracony is full of shit. &gt;The Fairy class is relying on a concrete Spell implementation right now, but let’s suppose that doesn’t suit us anymore and we want to make Spell an interface [...] Changing the Spell type into an interface could be done in one place. You don’t need to change the classes depending on it. and &gt;If there is only a single implementation and you are sure there is going to be only one you use a concrete type. As soon as a different implementation arrives you swap the concrete type for an interface. This is simple, fluid and results in only as much interfaces as actually needed. 
To further this line of thought, if you're developing a component and it's unclear to you up front what types of interfaces you're going to need (not necessarily knowing everything those interfaces provide, but at least knowing what interfaces will exist), I'd argue that this is a pretty strong code smell that you're attempting to add too much functionality to a single component and should refactor to smaller components with less responsibility. 
Indeed. This is where the Single Responsibility and Interface Segregation principles come into play. This is another instance where what dracony's arguing for completely falls apart.
FTFY: Domain driven design. 
You must have misread: Quote form the article: &gt; This allows for a much faster prototyping, since you can start with concrete classes and then switch to interfaces as you go. I was talking about "prototyping" and the process of development. The end result should obviously depend on abstractions. Basically my point was that you can start using concretions and finish with everything interfaced and not only *after you've discovered a need that the original concretion didn't cover*.
I thought we're trying to get away from using and advocating magic?
So /u/Nicoon 's original question still stands then, that is, why not just start with interfaces? Why bother writing a bunch of abstract classes if you're only end up turning all of them into interfaces?
Yes! I should have googled.
If I understood correctly, OP is looking to decode the JSON as an instance of a specific class, not stdClass. 
This is complete non-sense. It's not a problem having a suffix or a prefix for interfaces - that's just naming conventions and it boils down to personal preference, just like tabs vs spaces. The real problem is not having interfaces in the first place, and relying on concrete implementations.
What you're proposing is idiotic precisely because you start off in the wrong end of the stick. You start off with coding against a concretion, and as such your implementation details is very much likely to bleed over to the dependency, creating code smell. Since you're coding against the concretion and then swapping it out against an interface, the interface inherits the concretion's API. This is very likely to create problems with SRP and ISP. 
Here's another great read on naming interfaces [Sensible Interfaces](http://verraes.net/2013/09/sensible-interfaces/)
You completely missed my point. Writing this code isn't hard, I've already done it. But native functions are written in C and are significantly faster. Why can't I expect that? PDO::fetchObject handles this just fine with DB query results, and it exists because it's way faster than looping through an array from the DB and setting an object's properties.
This is the way to go. In addition, use Redis or memcache as well to cache queries and remember to index the table properly. Just for context, the number of items you're searching against is quite small in the context of what a database can handle. 
Saying that you should be able to immediately see the dependencies of a class just by looking at its constructor, is not correct and undermines the purpose and functionality of that object. There are definetely situations where constructor dependencies are only half the story of that class; some dependencies are passed as runtime constructor arguments while its other dependencies are pulled/set from the container. I'm also wondering if named arguments that can pull additional arguments from the IoC actually changes the notion of what a controller is these days; there is now greater assurance of only providing what is needed. And from the application's point of view, a controller is and will always just be a callable type. 
Why not? json_encode and decode exist in the language, and are heavily used to translate back and forth. Someone created these because it's an often seen problem, and the conversion is way faster as a native function written in C than as a function written in PHP. PDO::fetchObject exists for doing the same with MySQL data, so why not have a native function for mongo data or data acquired through an API?
Don't worry /u/Nicoon, he writes unit tests *after* the code to make sure the implementation works :)
echo strrchr("123.456.789.444", ".");
What /u/maktouch has said in reply to this comment already pretty much sums up the argument against, but I'd like to add; what if a library you're using decides to swap out an abstract class for an interface and they're not naming things with pre/suffixes. Imagine you're expecting a 'FrostBolt' and you've extended that supposed abstract class 'Spell' (not that you'd know from the name), that 'Spell' abstract class has some functionality baked in - the vendor then decides to provide an interface for that class, and ditches the Abstract class. Your code may just magically keep working, or at times may break. Not being explicit is how you end up with unicorn behaviour, and we don't want unicorn behaviour in code - it makes things harder to debug, and develop.
From a /r/PHP perspective, there's not a whole lot you can do. You should definitely have an index on the column you're searching, but that's kind of a given. If this was /r/javascript or /r/webdev, I would suggest that you implement three conditions: * Load the results via an AJAX call, not a pre-computed array [http://jqueryui.com/autocomplete/#multiple-remote](example). 1) You don't want to give away your entire dataset and 2) It adds to your download time. * Implement a timeout that waits 300-500ms before doing the call to the server. Each time a keystroke is entered, reset that timeout. This way if I type 5 characters quickly, you will only do one request, not 5. Play with the timeout until it feels fast enough. * Require at least 2-3 characters before you will make a request. If I type "Am" and you have 1000+ results to show me, autocomplete is of little use. And one PHP tip I can add is to put a limit on the number of results to return. There's no reason to return 50 autocomplete results because it will be unusable anyway. Limit your results to no more than 10/15 depending on how the UI looks.
How well will you know your code a year or two from now? How well will another developer know your code if they have to work on it? Your code may be considered 'vendor' code to them.
It should be the first thing you do, if you are concerned about performance.
https://github.com/dracony/PHPixie-Core/tree/master/tests I'm not sure if I'm willing to call these tests. They're so simplistic that it wouldn't even matter whether they exist - they don't really test anything anyway. 
So now that you've given up on the "refactoring" argument, why wouldn't you give the object a semantically correct name? Are you trying to make sure your code fits on a floppy disk or something?
People can date their diaries with "0x1C, MMXIV, Year of the Chupacabra, 10th Luna," if they want. But software developers need to use a standard that works across time zones, nation states, DBMS, programming languages, software, etc. Yes, the way the US does it is wrong and my buddies think I'm a communist for insisting YMD. I bask in the glowing warmth of validation by the ISO, string sort-ability, consistency with positional numbering, handling of timezones, etc. Arguments from people who defend their local conventions tend to be something like "My nation state's dad could beat up your nation state's dad." If you want a really sad story, Microsoft Excel has no idea what the hell to do with an ISO8601 string.
yes, it may not be the best translation but you know what I mean.
&gt;Ad hominem. Classy Ad hominem? It's clear that you have absolutely no understanding what the term stands for. But sure, entertain me. Show me where I've claimed that your argument is wrong, not on the basis of the argument itself, but based on some irrelevant fact about you personally. 
Oh, I definitely knew you were being sarcastic. Just figured I'd have a look at what his tests actually look like.
I was referring to the "full of shit" directed at me as a person rather than the article
Which totally isn't an ad hominem. It would've been had I said "Dracony's full of shit **therefore** his argument is wrong". I can talk smack about you all day without it being an ad hominem.
Semantic here means that a Spell type represents a domain entity, while a SpellInterface name carries information which is irrelevant to the domain. Especially since everything has to depend on the interfaces in the best case anyway, what is the point of that suffix ? If you know that every dependency is an abstraction because thats how you built it.
&gt; MailerDriverInterface Just to play devil's advocate, wouldn't it make sense, semantically, to ask your container for a MailDriver rather than a MailDriverInterface? I mean, sure the Interface suffix is more explicit but in the grand scheme of things I just wonder if it's really of any value. I get what you're saying and there was a time when I praised and abused the Interface suffix I've just fallen out of love with the Interface suffix specifically over the past year or so. The blog post that /u/SkyRak3r posted below does a much better job of explaining it than I can. http://www.reddit.com/r/PHP/comments/2kk4v2/naming_interfaces_in_php_or_why_you_shouldnt_use/clm31e1
Sic semper tyrannis
I was wrestling this recently and came to conclude that best-fit short names are preferable to verbose descriptive names. And that six months from now, although it may not seem as easy to recall, at least you're not locked into a particular notation but its intent instead. I also decided that rather than having 'UserManagerAwareTrait' it would be better as `ManageUser`. I prefer all the use trait statements to be consistent and not have the term Trait, similar for interfaces. Interface suffixes can be used as aliases when it is neccessary to resolve naming conflicts within a particular class.
I disagree. Interfaces should be interfaces, and parent classes should retain the "base" name. Admin extends User implements UserInterface vs Admin extends BaseUser implements User I much prefer the first one.
Googled it. I stand corrected. At any rate talking smack about someone aint cool either
kind alike android. aosp is technically open-source, but google keeps very tight control on the development process.
Not every one of those 500 classes is going to be injected into other classes, so no, they don't all need interfaces.
I think the moment you are passing one class into another, you need an interface. Once you create the interface, there is no real reason not to add the Interface suffix, because it *is* now an interface.
Use [Sphinx](http://sphinxsearch.com/) to do the searching side of things, to limit the impact on your database. Similar to Redis/Memcache, it can store the index and provide super fast responses over huge datasets. I set up a cronjob to re-index every so often to keep on top of new additions (if there are any/many) 
If it's your code, keep it to yourself. If you have published it and expect other people to work with it, then expect every criticism and opposing argument levelled at you regarding everything you write. Sure, it's your project and you are in charge, and so long as everybody knows that, then that's great - they play by your rules or GTFO and play by the PSR rules elsewhere. So yeah, do what you like, and if you don't agree with a convention other people are following, then that's fine. Just so long as everyone knows where they stand and where people are drawing the line.
&gt; And most of the topics are stupid stuff that doesn't matter. What's an example of a topic that wouldn't be "stupid stuff that doesn't matter"?
This cron would have to run every 5 minutes or so if OP wants it to appear "immediate".
If you are torn, just take what [PSR](https://github.com/php-fig/fig-standards/blob/master/bylaws/002-psr-naming-conventions.md) recommends and move on. It's one problem done, dusted, agreed, shared and out of the way.
This topic perhaps?
yep, ours runs every 2 minutes. We were lucky enough to be able to host the email account on the same machine as the script - the script itself then pings another connector on our main systems. We looked into writing a small daemon to check and ping but ended up using PHP for it all as it worked as promised :)
I would argue that "a set of behaviours" is still a "what" and there is othing bad in having a PersisitingModel, UserModel, FieldsModel interaces that even though thy don't map to a single entity still describe parts of it.
You're correct, I should clarify that actually. All of my *application* dependencies are injected in the constructor. `Input` is one of Laravel's Facades/Proxies and it's what tightly couples the controller to the framework in this particular example.
I always use a slight cooldown on it using javascript. The bigger the database is, the higher cooldown you want to have. It's basically: user pressed a key -&gt; queue lookup function to execute in X miliseconds -&gt; user pressed a key -&gt; cancel previous queued function -&gt; queue lookup function to execute in X miliseconds -&gt; repeat -&gt; user stops typing -&gt; timed function gets executed.
In Uncle Bob's words (because you brought up SOLID): "I prefer to leave interfaces unadorned. The preceding I, so common in today’s legacy wads, is a distraction at best and too much information at worst. I don’t want my users knowing that I’m handing them an interface."
You can use [str_getcsv()](http://php.net/manual/en/function.str-getcsv.php) instead of explode().
So you would like this subreddit more if it had a greater number of posts about why you don't like this subreddit. Okay then.
You don't want all your packages running on `dev-master`? `/s`
You should be ashamed of yourself for stooping so low as to engage in juvenile, ineffective ad hominems. Really?
This also helps tremendously with focusing on separating your API from your implementation. This probably isn't much of a concern if the application is light but for libraries/packages/modules being used by a third party it can be really nice to have a well defined API exposed via contract, and then default implementation that uses either a proxy or delegate. You can use composition freely without modifying your API and refactoring is a billion times easier. If you have some functional or behavior testing in place to ensure quality, you can usually see a faster release cycle as well.
I don't use laravel, but afaik you can just skip the "Facade" and inject it properly. I think Taylor Otwell even recommended that somewhere for non-beginners but don't quote me on this.
I missed one negation...sorry
Hi hopeseekr. Abducted any children lately? 
Full of shit is more an expression than talking smack, though. That is, what you're saying isn't correct (as I've demonstrated). 
What about the fact that your IDE tells you what something is as soon as you start typing it? Or when you type "implements" you immediately get a list of interfaces, regardless of naming convention? It's like naming tables in the database something_something_table, and columns some_kind_of_column ... a bit dated.
It is possible to write C extensions, to get your "fast native function". 
Maybe it's me being an idiot but wouldn't that require everything to be in quotes or wrapped in something?
We use SOLR for our search and facetting, so it made sense to use it for autocomplete too. We've got ~90 million documents in our search index, which is around 200GB in size. Autocomplete is really quick, especially as we've done some optimisation of the path it takes through our web app framework.
Now this is a truly ridiculous claim. What do you mean by "they don't test anything" ? How come it wouldn't matter if they existed? they test exactly the functionality of the class they are testing. If you wan't more complex tests feel free to look at: https://github.com/PHPixie/Database/tree/master/tests/PHPixieTests 
While we're here, I want to ask how to `composer update` in a way such that only required packages that are not in composer.lock yet, or their version in composer.lock are outside the version range defined in composer.json. So say this is my one year old composer.json: "require": { "a/a": "~1.0" "a/b": "~1.0" "a/c": "~1.0" "a/d": "~1.0" "a/e": "~1.0" "a/f": "~1.0" "a/g": "~1.0" "a/h": "~1.0" "a/i": "~1.0" }, And say I want to add "a/j", "a/k" and "a/l" with a version of dev-master, and say I change "a/a" to use version "~1.2" (composer.lock has, say, 1.0.1) because that version came out not long ago and I want to use it. So without having to manually specify every package with e.g. `composer update a/a a/j a/k a/l`, what simple command could I run here that would install "a/j", "a/k" and "a/l", and upgrade "a/a" (because 1.0.1 falls out of the range now), but would leave all the others alone and not upgrade them?
There are more reasonable thoughts on the matter courtesy of Mathias Verraes http://verraes.net/2013/09/sensible-interfaces/
Yeah, I like the "extras" idea that could lead people over to the security.json. I wish there was a good way to have it somehow automatically generated when the fixes are put in...devs are notoriously lazy and anything that could be done to make it easier, the better. It'd be nice to have it driven from the commit messages but that might require a separate tool to make that happen. I wonder if some kind of job type could be added on Travis or Scrutinizer that could make that happen...
&gt; Everything is basically a class so you want to be explict when something is not a class, trait and interface, or when something is abstract and should not be instantiated. Strongly disagree. Do you name your variables `$intAge` or `$userObject`? or `$iAge` or `$oUser`? Most likely not. But this is a naming convention called [Hungarian Notation](http://en.wikipedia.org/wiki/Hungarian_notation). Why have we moved away from it? Because it's redundant and error prone. Calling something a `UserManagerAwareTrait` is redundant because you can find out it's a trait from somewhere else. And saying `MailerDriverInterface` is only needed if you have a class called `MailerDriver`. But then either the interface isn't needed (because you only have one driver) or you're poorly naming the class. Instead, I'd rather see the interface called `MailerDriver` and then implementation called `SmtpDriver` or `MailChimpDriver`, etc. Interfaces describe abstract concepts. And as such they don't need the further abstraction context that calling it an `Interface` adds. Name them well in the first place, and you don't need `Abstract` or `Trait` or `Interface` in your names...
Wow! that's really awesome!
Direct link: http://www.tuxradar.com/practicalphp
You can use `@stable` to get the stable version.
[Nope.](http://codepad.viper-7.com/HXdN3R) The $enclosure parameter is for when your segments contain the delimiter, or for newlines.
This here is the way to do this so that you don't generate huge amounts of load - something like 150 to 250 milliseconds should be about right for the delay.
Im not sure it can be done fully automatic, but you can call composer update &lt;package&gt; &lt;package N&gt; &lt;packages&gt; Packages that should be updated, if not provided all packages are. And * is also useful composer update &lt;vendor&gt;/* This will update all the vendors packages
I havent seen many packages that actually use branch-alias, so I dont think its the best thing to use
Thanks a lot for your reply! Lots of useful stuff in here I hadn't thought of yet :).
Thanks, but &gt;without having to manually specify every package with e.g. composer update a/a a/j a/k a/l
I use Netbeans currently. From what i have seen, PhpStorm is pure sex? And i am sure i will buy it soon.
3.0.12: https://github.com/phpbb/phpbb/blob/release-3.0.12/phpBB/composer.json 3.1.0-RC6: https://github.com/phpbb/phpbb/blob/release-3.1.0-RC6/phpBB/composer.json Apparently the Symfony bits are new to 3.1.
Good on them, makes me a little excited to play with phpbb a bit.
Don't just rely on key presses, what you really want to do is throttle the request to fire so many ms after the last key press. As OP is using jQuery he should look at: http://benalman.com/projects/jquery-throttle-debounce-plugin/
I can, correct. But the class behind the Input facade is still specific to Laravel, so that doesn't make my controller any less dependent on the framework. The equivalent function for a Symfony controller has a three line difference, and changes to the `response()` function would be about the same. Sure, I could ditch the use of HTTP-specific facades, write a controller interface, and write a Laravel-specific controller implementation. But I just don't see how it'd be worth it.
&gt; so I can see the big picture routing map in one place `php app/console route:debug` That's the best/easiest way to achieve that with Symfony. It reflects the routes as Symfony sees them, not as you believe you've organized them.
Read ircmaxwells comment he posted in this thread. The suffix may be trendy but it's not supposed to be there. Think of Java, it relies heavily on all kinds of interfaces and it doesn't have the whole suffix thing. 
The failing is likely because the time limit has been exceeded. You probably need to to raise http://php.net/manual/en/function.set-time-limit.php As for making it faster. I don't Rabbit MQ is your solution. Without knowing much about the structure or you db or the queries.. I would look at the your queries and see if you can improve them. Are you repeating the same query over and over? Ie you have a query in a for loop? if you do.. there is probably a better way to do what ever you are doing. Is your db indexed well? 
If its just one process a week then a queue wont do anything to help. Queues are for controlling the rate at which lots of heavy process get processed. It also means you can move the more demanding parts of your code out of its normal flow and just put a job on a queue to do that bit later. For example, you have a user registration that requires them to upload an image of themselves. You then do some server side processing of that image as well as saving all their other data like username and password. The image processing slows down the time it takes for that request to end and scaled up could cause problems. So you take the image processing out of the registration and instead just put a job on a queue to process image x for user x. On the queue side you can control the rate at which these jobs get processed thereby allowing you to scale more effectively. In your case you just have one job that runs once but consumes all resources so a queue would do no good here. You could change your approach and have incremental statistics or data-gathering running during the week as jobs and then one job at the end of the week to amalgamate the results. 
I'm sure the additional overhead of Phalcon will make a huge difference for his 50 user project.
It's really easy to implement too: $(function() { var autocomplete_timeout_id = -1; var autocomplete_field_value = ''; $(formSelector).on('keyup', fieldsSelector, function() { autocomplete_field_value = $(this).val(); clearTimeout(autocomplete_timeout_id); if(autocomplete_field_value.length &gt; 2) { autocomplete_timeout_id = setTimeout(function() { perform_autocomplete_query(autocomplete_field_value); }, 500); } }); }); I tend to keep my javascript a bit tidier by wrapping that code in an object instead of a global function, but you get the point.
&gt; The problem is that these posts have been suggesting things like "Disable eval()" and "Disable base64_decode()" as possible solutions. And while tecnically that would work, it completely misses the point, and does nothing to protect users. The problem with burglaries is that people have been suggesting things like "lock your doors when you go out" and "get an alarm system" as possible solutions. And while tecnically that would work, it completely misses the point, and does nothing to protect your neighbors.
Haha, very funny analogy :D
&gt;Now this is a truly ridiculous claim. Not really. &gt;What do you mean by "they don't test anything" ? How come it wouldn't matter if they existed? they test exactly the functionality of the class they are testing. I mean that they are extremely simplistic and don't test anything beyond basic use, which would be invoked in your framework anyway on a normal execution. There are no tests checking edge cases. There are no negative tests. Looking at your tests, you're essentially treating everything like a key-value store, not really testing anything beyond whether the methods have been called. What you should be doing is testing their full range of behaviour. 
How is this not testing behavior: https://github.com/dracony/PHPixie-Core/blob/master/tests/requestTest.php Seriously man, you're overdoing it
**A**. They force you to think about the goal of your objects by defining their public interface. **B**. If you're typehinting interfaces in your methods then you can easily swap out different implementations. Example time! I have an event listener that listens for a "user.registered" event which requires a **UserMailerInterface** in its constructor and calls **sendConfirmationEmail($user)** on it. My first implementation used Mailgun behind the scenes. I've been having trouble with Mailgun and wanted to try out Mandrill so I created a Mandrill implementation of the interface and updated my dependency injection container to use that instead of the Mailgun one and I was done. I didn't have to touch the actual event listener class. I also plan on decorating the Mandrill mailer with a **UserMailerTimer**, which will implement that interface, so I can track how long Mandrill is taking by sending timing stats to my StatsD daemon. I can do all that because I've typehinted that interface in the listener. The listener doesn't care *how* it needs to send a confirmation email, just that it has an object that has that capability(ie. you've defined the **sendConfirmationEmail(UserInterface $user)**method on the interface). [Here is some pseudo code to illustrate.](https://gist.github.com/dadamssg/763a0b45e99e518c4d07) Defining interfaces also encourages you to start coding very small classes that do very few/focused things, which is great for composition. You don't need to interface absolutely everything though, just the pieces that you might want to change in the future. For example, the **NewUserConfirmationListener** and **UserMailerTimer** objects. Those guys really don't *do* too much. They're just the necessary glue and don't rely on any specific implementations. I don't see any reason at all to define interfaces for those. 
The error is then 0.16%, which is definitely non-zero. Calling it zero is very disingenuous. You'd never write on a benchmark where your code took 490ms to run that it took 0 seconds. It's simply not true.
&gt; Calling something a UserManagerAwareTrait is redundant because you can find out it's a trait from somewhere else. Do you think these suffixes might be more appropriate in a language such as C++? Where mixins and interfaces are still declared as ordinary classes? Would a suffix help convey the purpose a class is meant to serve?
While there are a lot of opinions about unit testing, I would say it's safe to assume that there are some common reasonings behind unit testing: * A well-tested codebase allows for easier refactoring * Prevents bugs that can be detected automatically There are also concepts to keep in mind while writing tests: * Arrange, Act, Assert(, and Anihilate... not normally used) * Write for an audience * Test the interface, not the implementation There is a lot of tests in the PHPixie framework that do not follow the guidelines of Arrange, Act, Assert. An example is here, but I can assure that there are plenty more and in other components: https://github.com/PHPixie/Database/blob/master/tests/PHPixieTests/Database/ConditionsTest.php#L43-48 The second rule is to write for an audience. When I open these tests, I have no idea how these components are suppose to be executed. Looking at other projects with unit tests (especially in TDD), the tests are a clear guide as how to use the objects. It is very clear to look at the test and understand the intent of the author, and makes it easier when the next contributor (or future you) comes to add new changes or refactor. Unit tests should also be testing the API, rather than the implementation detail. Doing this couples the unit tests to the production code, making refactoring much harder as tests break when you do changes. An example of this is found: https://github.com/PHPixie/Database/blob/master/tests/PHPixieTests/Database/ConditionsTest.php#L24 While a lot of these concepts are prevalent in the TDD cycle, they are general enough to apply to cases where unit tests come in. When I look at tests that do not follow these concepts mentioned, I see a test that partially tests some functionality. I do not feel confident that the code is well tested, which forfeits any attempt I would have at adding a new feature or refactoring code since I could easily break something. The gained confidence from unit testing is lost, which renderers the tests impractical and normally ends with them being thrown away because they get in the way.
You can't. When I started with Composer I was very surprised to discover this shortcoming.
I'm probably thinking way outside the box here, but it might be possible to build a script that generates a new composer.lock with the differences that you seek. Then if you `composer install`, you'll get the new stuff but the old stuff won't change. At that point though it might be better to submit a pull request and implement the feature directly into composer.
&gt; https://github.com/PHPixie/Database/blob/master/tests/PHPixieTests/Database/ConditionsTest.php#L43-48 It's a factory method test. It tests that a correct instance is created, that it has default parameters and that it passes along correct parameters. This the most adequate factory method test you could come up with PHPixie Database methods deal a lot with inner query state, manipulating query builder back and forth. The "result" they produce is manipulated state of other things. That is why there are so many non-intuitive tests. There are of course tests like those you'd like to see. try looking at Parser tests to have a more clear input-output situation. The reason why more obscure tests are there is because I'm going for 100% code coverage. Libraries that don't go for 100% and choose to cover only the obvious use-case input-output stuff obviously have have more readable tests. So the case here is not that my tests are not readable or to complex. the case is that in addition to what people usually test I ALSO included tests for more obscure parts to get 100% coverage
Thanks for your comment. We will soon post updated version of tutorial.
Perhaps slightly more justified, but it's still trivially easy to see that it's a class with nothing but virtual functions, hence it's an interface. So I don't think I'd do it in either case, but I can see more of an argument made for C++...
I disagree with the notion that you're automatically poorly naming the class if you can't come up with a better name for the implementation that isn't identical to the name of the interface. This may often be the case, but *always*? Call me skeptical. I will say, though, that when this situation occurs, it's more often due to not following the interface segregation principle than being a bad namer.
&gt;tell me more it's green! ^^[blacklist](http://www.reddit.com/message/compose?to=classhole_robot&amp;subject=racistfascistsnobs&amp;message=!blacklist)
In my opinion, the end goal is to have a well-organized code base that is easy for developers to understand and contribute to. Both conventions (and maybe even others) have their pros and cons, but those pros and cons will depend on the *people*. Use what works for you and your developers / users. In the end, your code doesn't care. Your developers do.
&gt; That is all part of the game. right? It shouldn't be. That's the *entire point*.
You should go look at the Internals threads about phpdbg, then come back and tell me straight-faced that Internals isn't a horrible working environment. Also, it's not that he can't handle people disagreeing with him; he simply chose to quit interacting with it. He still contributes valuable feedback to RFCs and such; he just doesn't post it on Internals.
&gt; This may often be the case, but always? I didn't say *always*. It's a guiding principle though. Everything is always a tradeoff. Heck, you can find samples of my code where I break that easily. But in general, I think it's a really good rule to follow. Break when you need to, but understand why you're breaking it. Don't just break it because you give up before you even try.
Well, one use case that was very helpful recently - I implemented a repository interface that depended on data pulled from a 3rd party website. This is all fine and good, but the 3rd-party website is kind of slow, so it was impacting the performance of the application. Since I coded to an interface, instead of having to clutter my repository with caching code, I implemented a cache decorator and had my Dependency Injection container supply the decorated repository. Not only was that cleaner, but if I decided to change the data source of the repository, I wouldn't have to touch the decorator itself.
As someone who believes in using the absolute simplest of environments for projects when ever possible, I love this. One less set of dependencies needed just to manage..... other dependencies.
Can you elaborate on reasons not to use opencart? I hate Magento with a passion. I need to refill my Xanax scrip any time I work on it. I've got some friends that want to use Opencart and I'm eager to see if it's worth suggesting. I'm sad inside that you feel it's not.
I've updated the script with a 2 decimal precision error. However let me outline that also 0.16 is "not true", since 13/7919 has an infinite amount of decimals. 0.16 is a rounded value, as it is 0. It depends on the precision you want, together with the representation you want to give.
A factory alone? No. That implies that the factory has database knowledge, which it shouldn't have. Should a repository in combination with a factory and a data mapper be able to reconstitute an object from ID? Yes.
Its a pity how redundant most of the talks in PHP world are. Obviously there are always some awesome stuff, but for the most part it's reiterating basic things over and over again. Very disappointed with Sebastian Bergmanns' talk. As the man behind phpunit you would expect him to talk about some interesting testing setups or whatever. Instead his talk is about a basic pattern you can read on wikipedia on =( I hope one day conferences won't admit talks on patterns, solid practices, framework intros etc. This is just redundant 
It is really two tests though. One test is something like testDefaultPlaceholder and the other is testGreaterThanPlaceholder. Tests should be independent of each other. In this particular example, it is probably not an issue because placeholder seems immutable, but in examples where state is held, there could be a state change between the two assert calls that are being done and cause the test to fail for no clear reason. &gt; Libraries that don't go for 100% and choose to cover only the obvious use-case input-output stuff obviously have have more readable tests. I don't agree with this at all. The goal of tests should be to aim for 100% coverage. If you're only testing common things, how will a developer be certain that a less common feature is working when the tests don't specify this? Besides, the more tests that there are (assuming the tests are needed and not extraneous), the more clear the intent of the library is and functions as a usable code example documentation. Saying that the tests in PHPixie are more readable or less complex than say a project like [Fitnesse](http://www.fitnesse.org) is like saying a book has a better story because a 4th grader can read it. It is how the book relays information that is truly important.
Can you set it up so that it updates your Bower packages as well when you run *composer update*? That would be neato!
Composer lets you execute commands after an install or update is complete. Presumably you could use that to execute the required bower commands.
Oh cool, I didn't know that. I'll have to check that out!
Why doesn't someone just write all these tools in C or Python and we'll never need this sort of thing again ever?
The [eol](http://php.net/eol.php) page has existed for a long time, but until now there wasn't an easy to find / read timeline for currently supported versions. php-internals discussion: [Gmane web](http://news.gmane.org/find-root.php?message_id=544E129C.8060000%40php.net) / [news.php.net](http://news.php.net/php.internals/78384)
We need Gower.
You could do a quick stripos with both the needle and haystack having the colon's removed. $pos = stripos("001122334455", "1223"); That way if the returned int is odd you know you're bolding "1:22:3" vs even's "12:23"
You do just fine Davey. I don't always strictly agree with some of the organizations you're involved with but it has always been clear that your priority has been to build a better community. That's something I can get behind.
That will tell me where it starts, then I could add an opening bold tag, move X chars more to the right and add the closing tag. Adding the colons back then become a problem.
I would tread carefully. This kind of objectification joke didn't work out well for Uncle Bob, and wouldn't work for you had you an equally high profile. I'm all for analogies which bring a point across. Except when they compare the disposability of a woman with that of a cache layer (especially, as the analogy goes, you made the choice to commit)...
Well, what you could also do, which is rather dirty: $mac = '00:11:22:33:44:55'; $input = '1223'; $regex = '('. implode(':*', str_split($input)) .')'; $mac = preg_replace('/'. $regex .'/', '&lt;b&gt;$1&lt;/b&gt;', $mac); [It works though](http://3v4l.org/mD0Bu)! I can explain it a little further if needed. 
Use it to create your replace string: $search = "1223"; $newsearch = ""; if ($pos % 2) { // Odd $newsearch = substr($search, 0, 1); $search = substr($search, 1); } $chunks = str_split($search, 2); $newsearch .= (!empty($newsearch) ? ':' : '') . implode(':', $chunks);
Hmm... bummer. Do you know if these flaws were addressed in version 2 which they recently released?
When you say "our servers" do you mean production environments, not development environments? You don't need node.js on your production servers to use bower. You can use bower, on your build/deploy machine, prior to deploying the application to production servers.
Congratulations! You trolled the noob on his first post! You win the internet! If you aren't trolling you completely missed the point of the post. The analogy was that divorce(in many cases) is ugly, painful and to be avoided, and so is the refactoring of 1000's of references to caching functions. The rest is sugar to drive home a point. The narrator had a 7 year "relationship" with APC, then had the relationship turn sour. Seven years is not what I would call disposable. 
Who's Gower? Jack Gower? :P
I was actually wondering about @maskalor's comment on Sylius' maturity.
ohhh... sorry
Thats cool but I think that their SSU (Security Support Until) is rather weak as hell. Unfortunately so much work is being done per distro rather than in the main tree.
&gt; Break when you need to, but understand why you're breaking it. Don't just break it because you give up before you even try. To me, it's much worse to have inconsistent naming than it is to use affixes where they aren't strictly necessary. I also find it much easier to read code that I'm unfamiliar with (or have been away from for a long time) when it follows this convention, as I'm not consistently having to bounce around the project structure to grok things (the consistency also helps here, to a lesser degree).
I agree building a better community is a noble cause. Having a strong community is how Linux has become what it is today.
This is because CentOS is RHEL. RHEL does not upgrade major versions of **any** software during the product lifetime. Security patches are backported by the maintainers without bumping the version number. This policy is present in *all* "enterprise" Linux distros. They're now doing a thing called "[Software Collections](https://www.softwarecollections.org/en/)" that provides namespaced versions of newer major versions of a wide variety of software, including PHP. The PHP maintainer for the Fedora project also [runs his own repos](http://rpms.famillecollet.com/) of modern PHP versions for older RHEL/CentOS versions.
Security Support Until?
A lot of code remains the same, but pretty much anything new is built on top of symfony. That's why its 3.1 and not 4
This will install every new stable version, even major ones that break BC. For example if you use `"symfony/yaml": "@stable"`, when v3.0 comes out with BC breaks then kaboom! So no, you shouldn't do that.
Is this really a big deal? Doesn't everyone running production PHP just add the webtatic or remi repos anyway? 
Move away from CentOS or compile from source - no biggie.
How does that work for security updates though? What if PHP 5.3 gets a vulnerability, but the PHP team won't fix it because it's not supported? Does RHEL come up with their own fix? 
Generally, they backport the fix from the lowest supported version (right now that'd be 5.4 or 5.5, depending on whether the fix is considered important enough for 5.4). Sometimes that's just applying the patch, sometimes that's a bigger job because the code has diverged. That works well when there's only one branch's difference in support, but gets harder the further back it has to be backported: RHEL 5 still has PHP 5.1.6, for instance, and that is probably a fair challenge for some fixes, given the code drift over the 6-8 years between 5.1 and 5.4/5.5.
Lets say that there is a critical security bug for PHP 5.4 in 12 months. Redhat will figure out a way to patch that. Also the LTS distros don't upgrade to bugfix versions but just backport everything.
If you're not able to get critical development tools on development machines then the policies are the problem, not the resourcing. If you're referring to actual servers... They don't need or want Node. 
Agreed. It's not just PHP. I've had colleagues in the .NET space who refuse to use anything out of the .NET tool chain. This has limited their selection at best, and limited them to tools that were out of date, incomplete, or broken, in some cases. Backend and frontend are different fields. If you limit your frontend tooling to what the backend supports then you will inevitably miss the industry-wide best practices. 
no i think he meant grower. 
So what do you use for things like concatenating JavaScript files, compiling Sass, mini/uglifying, etc?
I compile from source
A task runner (Bldr), JShrink, phpsass/less.php, matthiasmullie/minify
Interfaces can come in handy when you have two or more pieces of data that may come from completely separate sources (say different tables or models) and you want to treat them exactly the same. For example - imagine you have 2 classes: `EmploymentHistory` and `EducationalHistory`. One explains where someone might work, and another explains where they've gained their education from. There are nuances and slight differences between them, and that's fine - your tables should match the business needs as close as possible. Example classes to represent them: class EmploymentHistory { public $company_name; public $job_title; public $start_date; public $end_date public $location; } class EducationalHistory { public $college_name; public $course_title; public $start_date; public $graduation_date; public $address; } Say you need to merge these into a single list and order them by the ending date, (and assuming you don't do this with an SQL UNION), you'd have to perform `instance of` comparisons or lots of `if (isset($object-&gt;graduation_date)) { ... }` style code. Then try outputting this merged list into a view file... you have a title, secondary title and the starting and end dates and the address. The code becomes messy, unreadable, difficult to extend and unworkable. _This is what the interface can solve._ How? Define an interface that can be used to access information on both classes: interface HistoryInterface { public function getTitle(); public function getSubTitle(); public function getStartDate(); public function getEndDate(); public function getLocation(); } The interface is a little more general but that's fine - it's can hide the nuances of the data. Now, let's apply that interface to the classes: class EmploymentHistory implements HistoryInterface { ... properties ... public function getTitle() { return $this-&gt;company_name; } public function getSubTitle() { return $this-&gt;job_title; } public function getStartDate() { return $this-&gt;start_date; } public function getEndDate() { return $this-&gt;end_date; } public function getLocation() { return $this-&gt;location; } } class EducationalHistory implements HistoryInterface { ... properties ... public function getTitle() { return $this-&gt;college_name; } public function getSubTitle() { return $this-&gt;course_title; } public function getStartDate() { return $this-&gt;start_date; } public function getEndDate() { return $this-&gt;graduation_date; } public function getLocation() { return $this-&gt;address; } } You can now treat both classes exactly the same way - and you're abstracted away from the complexity of that class. The interface basically just applies a contract - just build these functions, and return whatever attribute is closest match. Another benefit is that this extends into future. Imagine that in 6 months time, you need to add another class and you can't remember how you did it. But you build a new `TrainingHistory` class and need to figure it all out. It's as simple as reading the interface, finding out where the interface is implemented elsewhere, and you can see how it all fits together. Simply apply the `HistoryInterface` to the `TrainingHistory` class, return the related attributes and you're done. Hope that helps! 
Btw for those who don't understand spanish, it is just a wrapper for the new SDK, you will be able to use it with Codeigniter. I think the most important of the post is the embedded GIST, just remember it is a very lite library so can use it and modify it.
It's restrictive in the sense they recommend the annotations and they recommend what's effectively programming via yml and recommend a manual clearing of the cache for many different changes. This can be beneficial, but it's still a restrictive abstraction. It's similar to rails in that so long as you stay between the bumpers, it'll all work out fine, but stray a little in what you're wanting to do and you have a headache. I agree with internals that docblocks should have a different token and processing than normal comments. This is extremely beneficial in developing a program to document and analyze the code via reflection instead of having to manually reparse each file. Using this in production code is a hack to incorporate a feature into the language that's not implemented. Annotations aren't supported in php, but by utilizing reflection you can simulate annotations. If internals came out and introduced java-like or c#-like annotations in an upcoming version, then I would salute them. Docblocks are literally documentation-oriented comment blocks. Comments are to help describe the code, not be part of it. Hacking around a language to include a feature it doesn't support is still a hack. I can completely understand why the Symfony team did annotations for controllers to make them easier to use and other projects use similar docblock programming too, but I absolutely disagree that this style of annotation within comments be used at all. Each new type of annotation system is creating a new language dialect that pretends to be php. If they want to incorporate annotations, then convince internals to incorporate them instead of having internals [reject them](https://wiki.php.net/rfc/annotations) or formally fork the language. This is the approach that facebook did to introduce static typing and they eventually spun their dialect into hack.
Nice one. Learned a bit about the generators https://github.com/sebastianbergmann/state
&gt; It's restrictive in the sense they recommend the annotations That the community is favoring annotations doesn't change the fact that you can choose what config format you like, even plain PHP. Headache free. &gt; and recommend a manual clearing of the cache for many different changes Clearing cache is the deal-breaker? Your rationalizations are getting silly. &gt; If they want to incorporate annotations, then convince internals to incorporate them So annotations enabled internally by PHP is okay, but annotations enabled externally by a library is not. Your objections are becoming arbitrary.
Haven't been able to install it on OS X since v3.1… Tried again today but without success. Everytime I give a look at the homebrew repo on GitHub there's more and more issues and nobody seems to get it to work.
You're a bit of a catalyst for me. Thanks for posing the question in this thread and subsequently following up. While I'm still going to go off UNIX timestamps for processing, sure, I think I'm going to start outputting YMD where I can get away with it.
CentOS 7 is out, you know right? 
Even if distros dropped python 2, it'd be easy to install it manually because each version has its own executable and environment - unlike certain other scripting languages!
I used Netbeans too, and yes, PHPStorm is better in many ways.
[Assetic?](https://github.com/kriswallsmith/assetic)
I'm asking specifically what this user uses. :)
Sweet, will take a look 
An interface just is a contract that a class must adhere to. What this means is that any class that ```implement```s an interface must provide the methods defined in that interface. Here's a nice example: [psr3 logger interface](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md#3-psrlogloggerinterface) Now you can use any logger that implements that interface and know it will work as expected: public function foo(LoggerInterface $logger) { $logger-&gt;alert('moo'); // this may send smoke signals for all we know, but we don't care!!! }
The *nix tool `cat` is actually short for concatenate. Sass has a C executable you can compile pretty easily: https://github.com/sass/sassc It is **really** fast. Minifying/uglifying JS is the only one I think you *need* NodeJS for. You didn't mention it but Autoprefixer also falls into this category. You can tie all of these together with makefiles, and use `inotifywatch` to get grunt-like auto-recompiling.
This is something I wish the wordpress team would start doing. 
So we are putting abstracted html within PHP functions now? I might have completely misunderstood the purpose of this and please someone enlighten me if I have but it feels wrong.
https://github.com/mkoppanen/php-zbarcode 
I was a bit curious about the versioning too, thanks for the insight. Do you know if it sticks to SemVer (that would mean there's no BC break between 3.0 anb 3.1, just added features) ?
This looks a good work from Scrutinizer. Just want to emphasise that **such services can spot something you may have missed, but they can't tell if your code is actually secure**.
I still find it weird to have to rely on 3rd party repos for such major updates. If anything happens to that Remi dude, the whole thing is fucked.
Tell that to my client... A major OS revision update usually takes them 6-12 months.
Aww, my old workplace that uses 4.x will be highly indifferent ;)
Note: these statistics are probably biased towards old/bad installs. Diligent sysadmins that keep `X-Powered-By` and `Server` headers hidden are more likely to keep their PHP installation up-to-date.
Indeed, some distributions backport fixes (security fixes, mostly) to older versions of PHP, which are still the ones they officially support. For example, Redhat does that for some PHP versions that are used by the entreprise-oriented RHEL. Still, even if PHP versions provided by those distributions doesn't necessarily suffer from some security problems, they do not have the recent features and additions, like Generators and the like.
Forgot about those, thanks for the correction!
Me too! Gentoo for the win~! I always have the most secure of, well, *everything*! and if I want to be bleeding edge, I can install multiple versions of PHP simultaneously and switch between them trivially. I even emerge HHVM directly from github. [and none of that systemd nonsense, unless, you know, one wants to use it.]
I found keeping clients up to date is **so** much easier with a rolling release distro, like Linux Mint Debian.
Is there any reason *not* to migrate to HHVM at this point? Anyone experienced any major drawbacks?
Are you just echoing it out for HTML? In HTML, newlines are treated equally to space. You must call `nl2br()` to convert newlines to `&lt;br&gt;` tags when echoing the text out.
So actually upgrading PHP to apply the changes made and tested by many members of the PHP internals community is considered insecure and instable, but having a few RHEL people try and patch things intended for later PHP versions by the internals community, is considered stable? I don't get it.
if you have a root server you can "pipe" the incoming mail directly to a php script without processing it to a mailbox or imap this is very convenient especially for high amount of incoming emails, for your case it probably makes no difference, if you have a good admin that can pipe an incoming mail to a php script then this might be slightly faster in development, but we are talking hours faster, not days. 
I saw this but when I was looking at the files I didn't see any php files. I don't really understand how its implemented. 
They can't break backwards compatibility by upgrading, say, PHP 5.1 to 5.6 on their long term support products (so they have to backport security fixes). For more information, see https://access.redhat.com/support/policy/updates/errata But as /u/McGlockenshire said, RedHat has [Collections](http://developerblog.redhat.com/2014/06/04/red-hat-software-collections-rhscl-1-1-now-ga/), which offers more up-to-date software: &gt; Red Hat today announced the general availability of Red Hat Software Collections 1.1, the second iteration of Red Hat’s comprehensive suite of powerful web development tools, dynamic languages and open source databases. Delivered on a separate life cycle from Red Hat Enterprise Linux with a more frequent release cadence, Red Hat Software Collections puts the latest stable open source runtime components, as tested and verified by Red Hat on Red Hat Enterprise Linux, in the hands of developers faster, accelerating the creation and deployment of modern web applications.
This doesn't surprise me at all. There are lots of people who have legacy code out there. They get "marooned" on old versions of PHP because of breaking changes between major versions. Some don't upgrade because they are afraid their old code won't work, others because they know it won't work. Business reasons/fear often keep them from investing the time to do the upgrades necessary to advance to another major version.
My company is porting over 50 sites to HHVM, about 5 are finished, including one with ~300,000 visitors/month. Right now, there is a serious blockage with Doctrine2 and HHVM, but apparently unreleased bleeding-edge Doctrine fixes it. Overall, tho, it seems almost everything is working for your standard, run of the mill custom developed site. MediaWiki, Joomla, Symfony2 without Doctrine, phpunit, all work. On average, we're seeing 40-60% faster page loads and more user acquisitions. The page load times for adequately coded pages is more like 20 ms (once the JIT cache is warmed up) vs ~70 ms for PHP 5.5. The server currently has been up ~90 days: * PHP 5.5: 23 processes @ 256MB each = 5.9 GB * HHVM 3.3.0-dev [last updated 7 days ago]: 1 process @ 8.6 GB. PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 6036 hhvm 20 0 8567992 48180 14424 S 0.0 0.3 85:44.66 hhvm Since only ~25% of the total source code has been deployed to HHVM, I am currently concerned why HHVM ends up using so much memory, because on a script-per-script basis it seems to consistently beat PHP. It's my hypothesis that this represents opportunistic caching and that overall memory requirements will not highly increase as the rest of our sites are ported over. If not... boy, needing more than 20 GB of RAM to run our code could be a serious hinderance to full adoption, something we've set a goal of Dec 2015 for. 
[Great job on the mobile support guys.](http://i.imgur.com/METvWLE.jpg)
Yes it echoes it in html. How do I call n12br()?
No surprise indeed. But, still, I find interesting to know what's available on servers out there (for example, when you want to develop an open-source library, it could help you define the minimum required version of PHP you'll be targeting)
It's a php extension. 
No, quite serious. https://medium.com/@assertchris/words-69bc28587993
&gt;Still, even if PHP versions provided by those distributions doesn't necessarily suffer from some security problems, they do not have the recent features and additions, like Generators and the like What about LTS systems which can't upgrade their PHP versions through official distirubutors sources. If you run a few servers with PHP 5.3 you will have to develop against it and if your applications are developed against PHP 5.3 you don't want to test all your applications after an upgrade of your servers. I would love to use PHP 5.6 with all its coo new features. But what can I do? Cool new features for the devs is not that big of a reason in a business decision like that. Edit: Actually there is one advantage of newer PHP versions which my boss accepts: Our applications are considerbly faster with it. I also use it locally because Xdebug is also running so much better and you can use watches without breaking your debugging session.
The same way you call all your other PHP functions
For the future, please post these in /r/PHPhelp, as mentioned in the sidebar.
It's NL2BR, not N12BR.
Some say - no surprise. I say: it's a shame and fault of enterprise linux companies, especially redhat! In their stable RHEL 6 the only option is PHP 5.3.3 with backported patches. Sure, some say that You could add other repo and have fun with php-next, but in enterprise world where everything needs to be standarized it's a shame that there are no official repos for newer versions of stable PHP. 
 $html = nl2br($database_string); http://php.net/manual/en/function.nl2br.php
This. Emphasized. And upvoted. Big time.
So, it's possible to force PHP to ignore a typehinting error and continue executing. This seems to ignore all such errors. Seems to me that you'll get none of the benefits of type hinting. At runtime you don't enforce type hinting and static analysis tools will complain with false positive errors when you pass NULL. Am I missing something?
It's rather funny You know. I have one app that is virtually unchanged from time where PHP 4 was starting to be popular. Sure, it has no OOP in it, but it was made with one very important point: only best practices go in in. With all those upgrades of PHP only handful of changes were made and those were just warnings. If we didn't change code when warning arose, I bet we would deal with errors on next php upgrade. All that business fear is because nobody did the right thing in first place. I remember back then, people used @ in front of everything just to silence warnings instead of fixing problems and on the next upgrade that bit them hard, thus creating fear :)
RedHat has [Software Collections](http://developerblog.redhat.com/2014/06/04/red-hat-software-collections-rhscl-1-1-now-ga/)
I'm not sure what a "BC Break" would mean in the context of a full-suite software like a bulletin board and phpBB 3.0's near-complete lack of an API.
&gt; A 7 year relationship is not disposable. Dumping her cumbersome butt (your words) because you're found a newer, better something is absolute disposability. It doesn't matter if you recommend doing this after 7 minutes, 7 days or 7 years. &gt; 7 years is not a short term relationship. Tell that to everyone celebrating 37 years of commitment (married or otherwise). &gt; The whole point of those post is not treat your caching like a relationship That may be what you set out to demonstrate. That you chose a poor analogy, which compares people to things you can just do away with on a whim, is another story entirely. I understand that you think Redis is a better fit for your interpretation of SOLID principles. Just use better examples. It's not like we're running out of them. &gt; as a way to build your own brand at my expense You are trying to make your content more entertaining at the expense of a patriarchal "joke". That is at the expense of women (people in general). I shared my thoughts with a few women before ever committing to post this. Had they counselled me to drop it I would have. Perhaps your writing could benefit from some similar review...
Yeah I guess you're right. I think what I meant by "it's an art" is it's more complex than it's individual parts. Which also fits for science. I'll change that part in my answer. Thanks for the feedback.
Your title could have been more descriptive. You should have mentioned SSL in the title and that it's more a web server question than a PHP question.
How are there 36 instances of PHP6? And how is it that only 34 of those are running 6.0? What the fuck are the other two running? This data seems legit.
&gt; Still, even if PHP versions provided by those distributions doesn't necessarily suffer from some security problems, they do not have the recent features and additions, like Generators and the like. Yea and? If im on a secure 5.3 php im likely using something like drupal7 and not drupal8 ...big deal. There is little visible enduser whizz-bang iget inherently from updating php versions. Quality software can be made with any version of a language.
 throw new Exception($message, 0, $level, $file, $line); [Ehm ...](http://us1.php.net/manual/en/exception.construct.php)
The migration from 4.x to 5.x was such a hassle for many small companies. The company I worked for very nearly went out of business over lost revenue and downtime. From that jaded management perspective it makes sense to avoid upgrading PHP in the future, as most small clients care more about avoiding downtime and paying difficult to justify bills than they do about patching potential security holes.
For PHP there is http://websec.io/2013/12/06/Iniscan-Security-Best-Practices-phpini-Scanner.html For mysql, mysqltuner.pl But remember security is an ongoing thing, not a one time scan.
It says it replaces \n with nl2br(). But I want to be able to copy paste text from Word into the database which contains enters.
If you rely on a PHP extension it might not be ported over yet.
I guess you'll have to compile it. Or find a solution you can run from a command line like : http://zbar.sourceforge.net/ use shell_exec() to call that thing and get the response from it
I've got several clients on Modwest, those fucking bastards are currently ADVERTISING the fact that they use an unsupported version of PHP. Fucking ridiculous. From http://www.modwest.com/webhosting/: &gt; Scripting &amp; Software: PHP 5.3.18 I'm slowly migrating them to other hosts, but sheesh... it's incomprehensible. It's gotta be one of the worst hosting options available, in terms of what you get for your money.
Further in the post, the story teller has developed co-dependency issues and CANNOT be without a significant other(caching solution). So they HAVE TO FIND A REPLACEMENT before they can leave the current significant other(caching solution). You are missing the forest for the trees. You are not event picking the right trees. Why aren't you talking about the storyteller's co-dependency issues as well? Because, it would shoot a huge whole in your argument? 
Nope it says &gt; Returns string with '&lt;br /&gt;' or '&lt;br&gt;' inserted before all newlines (\r\n, \n\r, \n and \r). Those are the command codes for RETURN/ENTER etc
I agree in those cases someone did the "wrong" thing. If "you" code the "right" way from the start you usually avoid breaking changes. But, sometimes you inherit code that wasn't done "right". Then... well it gets messy from there...
I hide them so I don't always have to update PHP, as most kids rely on a explicit PHP version. Guess that just makes me superbad.
this guy's error handling function is just fundamentally broken... he should learn to read the documentation.
No surprise. Breaking changes cost money to fix.
The fact that PHP lets you do that is fundamentally broken as well... PHP should learn how to implement proper error handling...
idd.. he not only manages to write a botched error_handler, but doesn't even know how to throw an exception... I think he never heard of this new thing called "documentation"
Maintenance? http://youtu.be/zGxwbhkDjZM?t=25s
but... if you intercept the error handeling and then handle the error wrong yourself, of course it's gonna be handled wrong... The fact that it is possible, well... that's another thing, but the documentation clearly describes this, which makes it correct behavior. The docs clearly say __it is important to remember__ that you are doing this and should pay attention... but it is by no means "*magic*" FYI, i'm all for changing errors to exceptions, but again, this is not magic. edit: another excerpt from the docs, all from the frist 3 paragraphs: &gt; __it is your responsibility__ to die() if necessary. If the error-handler function returns, __script execution will continue__ with the next statement after the one that caused an error.
Assetic. It ships with a whole bunch of compilers in PHP that just work out of the box. Does cache busting, can append a random query string at the end of the asset call while in development mode to make sure it always busts the cache and compiles on every request for you. Assetic is kind of a pain in the ass to use though, so I've written my own very simple glob/concat/cache/busting tool that just makes use of third party compilers the way Assetic does. I also avoid working with Sass and Less if I don't need them (and with the right CSS structure and a smidge of discipline on a small/medium site, you don't really need Sass or Less).
that's more of a stack architecture and doesn't have much to do with php. "Sessions in the cloud" means you'd have several app servers running the same php app and they'd all use the same database(or read slaves) or cache for sessions. Pretty much any ORM will allow multiple database connections so you could write to the master and read from a slave. What limitations are you referring to?
&gt; If the error-handler function returns, script execution will continue with the next statement after the one that caused an error. Just because a behavior is documented doesn't mean it's not horrible or broken...
how would exceptions not fit this use case? Exception is thrown, script execution is halted immediately, you can catch it if you want to display a nice error, or you can let it crash it you want.
&gt; [...] you can catch it [...] That's how.
Thanks, it works.
Why this header is enabled by default? It does much more harm than potential benefit.
Yeah, getting this stable is definitely on the team's mind. What often happens is that it will be working and then some innocuous-looking change will break OS X support and no one on the HHVM team will notice for a while. We're working on getting a real CI system set up so that breaking changes are detected and blocked from being committed in the first place.
I feel like this is becoming unproductive. I'll try to rephrase my point simply. Hopefully this is just all a big misunderstanding. :) If I want to write a technical post about engine mechanics and compare the destruction of an engine to violent assault of a person then I may be technically correct. But it's still a horrible analogy, and completely unnecessary. I think I understand the purpose of your article, but the analogy you are using is about the casual disposal of one technology in favour of something that can offer you a better solution. There is absolutely nothing wrong with that except when you personify the thing you are casually disposing of. You make the object of your disposal a woman. I loved your post about writing and making and learning from it. I sincerely appreciate your willingness to share. Like you suggest; it's best to avoid flame wars. That's not what I'm trying to do here. Nor do I care if people see my name on this except that I want people to think well about the analogies they use. This isn't just a problem about a single post. It's a culture we all know needs to be adjusted. What else can I say? Sorry to have upset you. As far as the technical content goes; I think you have good points. I just think you picked (and are trying to stick to) a really bad analogy, for the sake of humour. That's the thing that I think is a problem. 
well, it may be __horrible__, but it's certainly not *broken* or *magic* imho. In the same way, it's not because something can be improved upon that it's broken.
[This was posted recently](https://security.sensiolabs.org/)
True. But if PHP 5.6 is installed pretty much nowhere, frameworks and applications (symfony, laravel, or drupal, ...) cannot use features of PHP 5.6. Same for 5.5 or 5.4, btw. Of course, developing quality software is possible with PHP 5.3, without features of &gt;= 5.4. But, if you knew you could use some stuff of 5.5, which would help you code faster or write code that is easier to maintain, would you not do so ? (like, for example, Generators)
You're having more user acquisitions over a 50ms differential? Really?
If you have traits which depend on properties / methods not available during writing of their code, you have badly designed code. Same thing for "reverse polymorphism" when you call method which you expect to be implemented in child class (and is not declared abstract in parent).
&gt; not available during writing of their code The experiment isn't about code written in the future. It's about creating a contract between traits and the classes which consume them.
There's a CSS tweak drifting out to the mirrors now that should fix that. Sorry that slipped through the gaps — I was mostly making sure the calendar worked when I looked at my phone yesterday.
tl;dr: my main concern is with easy or accidental handling of critical errors. The real problem is almost entirely covered by the combination of Pokémon exception handling and every exception in PHP extending `Exception`. There is a certain class of errors that I want assurance gets to propagate *very* far up the chain, to the point that we are essentially dealing with a system crash. Running out of memory is one example of those errors, but there is some disagreement about where to draw the line. I am firmly of the opinion that the example here, which is a gross abuse of a tool that exists purely to provide correctness guarantees, belongs with those errors. If you make every type of error easily catchable, e.g. by extending `Exception`, I do not have that guarantee, because even if userland handles exceptions responsibly, PHP core does not. It might be possible to solve the problem by introducing a new, catchable exception class and have `Exception` inherit from that -- [Java does that](http://docs.oracle.com/javase/7/docs/api/java/lang/Throwable.html) (and D) and it mostly works, despite wanton Pokémon exception handling. It lets us do minimal recovery even in the face of critical errors but it also introduces the risk of us finding ourselves in the same situation three years down the line. The WSOD is, of course, a terrible alternative, but I will more easily spot that during development than I will an ill-placed catch-all silently swallowing a critical error.
But it does exist at runtime. Those interfaces have to exist, and therefore they have to be implemented by the class. All the code that is run (and is required) already exists when `secureTraits($this)` is run. Any runtime/user-land solution to this is worse than language support. The post does point that out though...
Sure we all would. You're simply looking at the problem from a Developer standpoint of "ease of code". Updating and managing PHP instances across fleets of servers (or any library for that matter), not to begin talking about updating running webapps to newer php versions and through end-to-end testing of the app after update -- can be _monumentally_ difficult. From a sysadmin perspective the difficulty behind to "just update it so its better for me" on many systems can be overlooked by developers on both shared servers and dedicted systems.
5.3 because nobody wants to give up magic quotes http://us2.php.net/manual/en/info.configuration.php#ini.magic-quotes-gpc
And you did not hear of empathy. We all make mistakes when we write code and that is not a big deal because we can fix them, which I don't know how much applicable is to a person character.
This is a good point I've considered. It always makes me wonder why someone hasn't copied his model for the Symfony folk. I'd imagine enterprise adoption is much more vast, which means they'd be willing to pay more for training materials. Seems like a sure business at this point.
/r/sysadmin ? 
My last three jobs have been privy to 5.0 -&gt; 5.3 upgrades and those upgrades were of 5.0 code that was previously 4.* code. That same code is harder to upgrade to 5.4+ because of some of the deprecated features. We're talking 50k+ LOC that needs to be rewritten (not refactored) before it can run on 5.4. I don't think many orgs are going to do that until they get pwned by a vulnerability.
PHP is fundamentally broken and should be replaced. FTFY.
Of course I'm looking at things from a developer point of view -- I'm a developer ^^. Still, I'm convinced updating is not easy from a sysadmin point of view, and I know that updating (and making sure everything still works perfect) is not that easy from a developer point of view either: I have migrated several applications (and servers) from 5.3 to 5.5 this summer, and it required a bit of work, mostly to ensure things didn't break. Happily, migrating from 5.3 to more recent versions is far easier than migrating from 5.1 or 5.2 to 5.3 was -- as long as your applications and libraries are developed keeping some good practices in mind (and not doing things that have been considered as *bad* for a while), which was the case for applications I migrated this summer ;-)
Apparently you can do an in-place upgrade of 6 to 7, but I haven't had the courage to try it on a running system yet.
JShrink
I feel for you; traits can be used in horrible ways. That's not at all what I'm encouraging here though. This POC actually encourages better design when using traits. 
I'd love to be on newer versions of PHP, but I'm a developer first and foremost, and a system admin second. We're a small company, and taking time out of my day to upgrade servers is time I can't be spent writing features that our users need. In order to use PHP 5.4 or better, first I'd have to upgrade off of Ubuntu 12.04 LTS (which doesn't end support until 2017). As long as Ubuntu makes sure security fixes are backported into PHP 5.3, which they do. There is no reason for me to spend the time to upgrade. I'd love to install Ubuntu 14.04 LTS, but to do so I'd have to upgrade a test server, and then deal with configuration compatibility changes because there always are some. Then I have to get a testing group to test our huge website full of custom code to make sure it still works, as well as watch error logs for deprecated features and errors. It's at least a month long project to do right before it gets pushed into production. Then I have to spend a weekend I'm usually off doing production server upgrades. I went with Ubuntu LTS because I don't have to spend a month or more out of every year doing server upgrades and testing new PHP versions. Instead, I can do it every 4-6 years. Sure, I don't have all the fancy new PHP features, but I can get more actual development done which means my users are happier and get the functionality THEY need faster. The problem is even more pronounced than normal, because PHP missed Ubuntu's LTS feature lock by a matter of weeks. Ubuntu was left with the shitty decision to ship an LTS with 5.3 or delay their usually clockwork LTS release schedules to support 5.4 and honestly shipping with 5.3 was the right decision. This guarantees that Ubuntu LTS users are going to be 2 years delayed in getting a PHP upgrade, minimum. Plus, lots of LTS users are going to prefer to upgrade every 4 or 6 years, not every 2. As long as they're getting security patches, they're happy.
At my company we host several servers. The oldest ones are on php 5.2, the bulk is on 5.3 and a small portion is on 5.5. While I would love to have everything on 5.5/5.6 it's a humongous job to migrate and test all of the +/- 700 websites / apps on recent php versions. This amount of work is not necessarily paid for by our clients and new development on projects is always going on. At the moment we are migrating the 5.2 servers to ubuntu 14.04 lts with its supplied 5.5 version. You can not negate the amount of effort it takes to that. But at some point you will have to do it, because the security support stops. We have a decent sized team of developers +/- 15 devs, but they are all busy with new projects / paid changes etc. It's difficult to make management see the need of updating. From a business perspective it only seems to cost money. 
In a language where there is no method overriding with different signatures, being able to change *constructor* signatures is a *huge* feature. Imagine the following *extremely common* scenario: class Entity { protected $name; public function __construct($name) { $this-&gt;name = $name; } } class Person extends Entity { protected $age; public function __construct($name, $age) { parent::__construct($name); $this-&gt;age = $age; } } How would you implement `Person` without changing the constructor signature? You either need to be able define multiple constructors with differing signatures (not possible in PHP), or you could skip the signature all together and use `func_get_args` (which defeats the point). I realize the problem with `new static()` is valid (especially since the keyword `static` doesn't really [mean](https://bugs.php.net/bug.php?id=62333) [static](https://bugs.php.net/bug.php?id=45159) in PHP), but this "__ConsistentConstruct" only works for a few cases and is not a generic solution. The *ideal* solution would be a combination of supporting method overloading and removing the distinction between `self::foo()` and `static::foo()` (and make both behave like the latter) but I realize it is way too late to break BC :)
&gt; If we didn't change code when warning arose, I bet we would deal with errors on next php upgrade. This. The company I work for recently upgraded a PHP 4 server to PHP 5, there were a lot of things that broke, but it was all either shitty programming, like (and I shit you not) relying on the server's IP address to be a certain value for the database connection to work, or stuff, as you say, that could have been prevented by following the warnings. My predecessors, however, coded with error_reporting set to 1. I always crank it to the max I can get it, except of course when working on a legacy application...
Chris, this became unproductive for me the moment you turned this into a personal attack on my character on Medium. That was unnecessary and self serving. I appreciate the fact that you are trying to take a softer tone. I think you seem like a very smart guy. You seem like a passionate guy. I can appreciate that. In time I could come to respect you. But, the fact remains, you made public, personal attack on me. I cannot undo that. You chose to fixate on one element of the story without consideration for the context. In the case of my blog post. It is the context that is important. "The Narrator" flawed person,as is with most any story worth reading. "The Narrator" is in a long term relationship. The relationship is failing. "The Narrator" has become dependent on being in a relationship(having a caching solution). They cannot survive without being in a relationship(having a caching solution). &lt;-- This the key to all of it. That is why the story works. "The Narrator" seeks to move on and discovers moving on is going to be horribly difficult. Your whole premise is very valid IF ONLY IF the "The Narrator" is able to continue without being in a relationship. In the story, the sex of "The Narrator" is interchangeable. I told it from the reference point of a man, because I am one. CAN you honestly say that you would have taken the same objection to this story if I had posted http://timrash.com/women-dont-married/ first? I am not innocent in this.. I should not have dismissed you as troll. I made that mistake. I will learn from it. I should have dealt with you less dismissively.
I'm not sure I understand what you're getting at. The code you posted is both valid PHP and valid Hack, and is indeed a great example of why we allow constructors to be overridden with different parameters. The only thing that Hack won't let you do without `__ConsistentConstruct` is call `new static` inside the `Entity` class hierarchy.
I'm a bit exhausted, so I guess I wasn't able to explain myself. I was trying to say that instead of adding things like `__ConsistentConstruct`, a better approach would be supporting proper overloading (multiple methods with the same name but different signatures, like in Java). That way, the following code would *always* work, even with `new static`: class Entity { protected $name; public function __construct() { // Nothing } public function __construct($name) { $this-&gt;name = $name; } public static function makeNew() { return new static(); } } class Person extends Entity { protected $age; public function __construct($name, $age) { parent::__construct($name); $this-&gt;age = $age; } } $foo = Person::makeNew();
I'm not sure it works in any context. If a major version of software is released and the old version is supported for a year, that does not make it unstable. 
You mean that in 10 million websites there are **2** that run a weird PHP version so that means the whole thing is no reliable?
Here you can find quite good stats about wordpress, php and mysql versions: https://wordpress.org/about/stats/ every time when your wordpress installation checks for updates, it sends those info to wp.org. As WP is really popular, this way they collected very credible data. 
Wow. I feel like you are our sys admin. Me and our sys admin are the only ones who know that there is something after php 5.3. I also feel like everyone else in my company is just happy not to learn something new...
Did you had to rewrite 50000 loc or was the whole software 50k loc? I think our biggest projects are around 70k loc.
For us it isn't about being happy not learning something new. No one else in the company does programming. We're a tiny development team of 4 developers and a manager. Only 2 of us actually use PHP (myself and my coworker). The 4 of us design and code completely custom in-house software for 200-300 employees, and an online storefront for our customers. The problem is the month I spend upgrading our servers is a month I'm not spending making features that get us more customers. It's a month I'm not spending making our 200-300 in-house users more efficient by giving them better tools to handle orders. On top of that, our testing group is just a small selection of customer service representatives. Having them spend 2-3 weeks doing testing of our website is 2-3 weeks they have to take time out of their day and not help customers and not help handle orders. 
What you describe is called overloading and is part of polymorphism. It has pro's and con's tbh. It can be a great tool to be specific about what's possible, but it also carries the risk of abuse and have one class define multiple roles which can be created via different overloaded constructors. So it makes it more tempting to break SRP. Then again, I'm not a big fan of having my language try and protect me from myself. -edit- derp, this is mentioned in the first paragraph of the article. I should really start reading the links before reading the comments. 
Ok, an analogy: Before the annealing process happened in the motorcar industry, if every 1-2 yrs the controls were moved around (instead of a wheel, let's try levers!) and best practices for driving the thing changed such that you had to relearn how to drive every year or two, would you consider the design of the motorcar "stable"? I wouldn't. I think this is his point, not code stability for a specific version.
&gt; What you describe is called overloading and is part of polymorphism. ... yes? I do know that. Did I claim otherwise? &gt; It can be a great tool to be specific about what's possible, but it also carries the risk of abuse and have one class define multiple roles which can be created via different overloaded constructors. I don't think having different constructors automatically change the role of the class. As for abuse, *any* feature in *any* language could be abused if you really wanted to. That's no reason to reject a feature :)
Except when one throw code on Reddit to show it off, they could at least make the effort of posting *correct* code.
Vanity, plain and simple.
wtf would anyone downvote this?
We've discussed adding overloading to the language (which this basically amounts to). The problem is existing PHP semantics -- you're allowed to call functions with the wrong number of arguments, for example, and PHP will ignore any extras, and if you pass too few will just set the params to null. It's unclear how this would interact with your proposal, and if it would lead to surprising behavior, particularly when mixing PHP and Hack code. All of our previous attempts have lead to similarly surprising behavior. Edit: For example: class C { public function __construct() {} } class D extends C { private $x; public function __construct($x) { $this-&gt;x = $x; } } new D(); This isn't valid Hack, but it is valid PHP, and so we have to worry about making changes like what you propose: before, we'd call `D::__construct` with `$x=null`, and with your proposal, we'd call `C::__construct`. There are other problems too I think, but that change is a huge one. That aside, I'm not particularly convinced by your example anyways. What is the value of `$foo-&gt;age` and `$foo-&gt;name`? I guess they're just null? Hack allows you to have members that must always be initialized to non-null values, doing this by making sure you always call the constructor -- it's unclear how that would interact with your proposal as well.
I always add a PHP 5.4 requirement to my libraries, even when I can avoid it and make it work on PHP 5.3. No point in degrading my code to support someone's bad decisions, no matter how excusable.
Hi, Thanks for the reply. Should I give queues combined (e.g unsub, sub, call API) or make queue for each of them? Also, I'm using Iron.io push queues (mostly for mailing stuff) but I'll probably use Rabbit/Beanstalkd and Supervisord. We have Supervisord installed on both servers anyway. I didn't want to rely on queues alot because Iron.io (or amazon alternative) would bill us too much and I didn't want to deal with monitoring myself. (I don't want to play sysadmin to be honest.) I guess using queues for those tasks will be really helpful. One thing though. (it is 2am here and I've been working since morning so this may be a dumb question) Do queues support retries when they doesn't get the preferred response? For example, I want my queue to run all the time until it receives 200 OK as a response. Probably after like 5 tries, it may move onto `failed_tasks` group. Also, do queues execute in the order they're given? We currently use events widely. I can also use Eloquent events for certain events such as creating and updating, but so far our Eloquent repositories handle them just fine. I may refactor it to rely on Eloquent events one day. :) You can provide more details about your stack if you want. There may be some things I can use myself.
&gt; That aside, I'm not particularly convinced by your example anyways. What is the value of $foo-&gt;age and $foo-&gt;name? I guess they're just null? Hack allows you to have members that must always be initialized to non-null values, doing this by making sure you always call the constructor -- it's unclear how that would interact with your proposal as well. Well yes, `age` and `name` would be null, as all non-initialized variables are null by default. I also realize this conflicts with PHP's existing semantics; my proposal was more for Hack's strict mode. &gt; Hack allows you to have members that must always be initialized to non-null values, doing this by making sure you always call the constructor I guess I don't see the point of enforcing this. What's wrong with having properties set to null?
Same is done in nginx and apache by default no?
What is the meaning of this? Cause I can not see a reason for it. So if someone could explain it to me, I would be greatful. Also, what PHP versions does support this?
There was some tool we use as part of the build / CI process that didn't like this syntax, even though it's perfectly valid from PHP 5.4+. I think it was either PHP Documentor or PHP Mess Detector. You runtime version is very clever and interesting, but I don't think I'd was to have a workaround for a missing language feature like that :-)
One of the definitions of divorce is to make or keep something separate. And one of the definitions of marry it to unite or combine something. The author is not making an analogy to a relationship between persons. If someone was offended by the authors choice of wording then they have a poor grasp on the English language. 
I'm pretty sure `composer update --lock` will do that. It basically updates the lockfile in line with the composer.json file - such that it will keep installed packages at the same version, install new ones, remove deleted ones and update the metadata/hash.
"Critical, patch your sites now". That was two weeks ago. I guess people downvote you because you made us think there was a NEW vulnerability, and thus we clicked on the link only to see it's the same bug as 2 weeks ago. "Reminder: there was a critical SQL injection vulnerability discovered in Drupal 2 weeks ago, don't forget to apply the patches." would have been better. 
Yep. And most pieces of blogging software somewhere, and all kinds of other things.
We started with Iron.io, but switched to Beanstalkd because queues are vitals to our operations and during the 3 months we used it, it had problems 4-5 times. We also had an issue where Iron.io basically DDOSed us, but that's a problem with any push based services. You should definitely start to play devops though, it's an awesome skill/mentality. &gt; Do queues support retries when they doesn't get the preferred response? Yeah, the queues gets deleted when you call `$job-&gt;delete()` in the task. You can check for the HTTP response and act accordingly. There's also `$job-&gt;release();`, that will push the job back to the queues again. &gt; Probably after like 5 tries, it may move onto failed_tasks group You can set that up, `php artisan queue:work connection --tries=5`. &gt; Also, do queues execute in the order they're given? Yeah. I recommend you make 2 queues connections, and start the worker like this: `php artisan queue:listen --queue=high,low` It'll process the high priority first, and process the low when the high is empty. &gt; You can provide more details about your stack if you want. There may be some things I can use myself. - HAProxy -&gt; Nginx -&gt; PHP-FPM/HHVM (I got half nodes running HHVM, it's still segfaulting for some reason). - NodeJS for Engine.io - CDN is Cloudfront, Storage is S3. - Beanstalkd for queues. - MySQL as truth store, Redis for cache+fast-store+pubsub, Elasticsearch for search+centralized logging, and currently replacing Neo4j with Cayley for graph. - Logstash+Kibana for logs - Nagios - NewRelic - Deploy and provision with Ansible
Yep... 100%. That RFC you reference which was posted here a few weeks back is probably the single greatest feature that could hit PHP7, and I really hope it does. Having two versions of error handling behaviours in PHP really does get me upset at times. Also - that link of yours is the older exceptions for PHP 5.6 this is the latest one proposed for PHP7. https://wiki.php.net/rfc/engine_exceptions_for_php7 
What does this statement even mean? This all comes down to application architecture. &gt; support sessions in the cloud this issue has been solved years ago - roll a session handler that persists to DB/Memcached/Redis/SimpleDB (if going AWS). I would doubt any framework - even home rolled variants would have this as a stumbler - and even if it does - the memcached PECL extension can handle this transparently. Also, you might want to look at things like [Elastic beanstalk](http://aws.amazon.com/elasticbeanstalk/) - although I find the PHP framework around this (Apache/blah) a little limiting for any real use.
I think it's just for the lulz
I bet that update was fun times. I've seen code with files that each had error_reporting(0); and in config there were disabled display_errors and log errors. Fun times.
Yeah sorry about that. I didn't read the article before commenting, so then felt like a douche for pointing it out. But I dislike retconning what I wrote so just added the edit note. As for abuse, fully agree with you everything can be abused. I'm struggling to find a good example of where I'd prefer to have an overloaded constructor instead of creating a factory though. But doing most of my work in a language which doesn't have that feature might contribute to that. Not that that would also be a reason to reject a feature. Heck 'goto' got added and I think that has far more potential for abuse. :P
I must have missed the post here.
Yep. Meta generator elements, headers, etc. I decided to use wp on my new site and its a b@tch and a half to get it to where it doesn't identify itself as WordPress (including hiding the admin to a subdomain, killing the meta tags, modifying the cookies and asset paths). Ach.
Easy to say, but I'm still managing a cPanel with magic quotes on PHP 5.3 (just one.. all my others are up to date) because if I didn't, all those customers would simply find another host as opposed to changing their code.
I don't really buy that it does harm. If you know of the security flaws in 10 different minor PHP versions, why wouldn't you just try them all? It's not like it takes hours to scan a site for vulnerabilities.
TOP LEL
I would love to know why your app works on 5.3 but not 5.4.
For what it's worth, I upgraded a server (several sites and thousands of lines of PHP on it) from 12.04 to 14.04 in about an hour, with no trouble at all. I'm sure your situation is different but there's no way it will take you more than a couple days. Seems to me that waiting even longer just gives you an even harder upgrade task down the line, rather than two small simple ones.
What's with the weird indentation in your code?
Hmm, good question. It looks alright in my editor. No idea why GitHub displays it that weird. Any pointers in the right direction?
"Undergoing a period of rapid innovation?"
It's because you mix tabs and spaces. Try to stick with one format.
I have my IDE set to make my tab key just do two spaces instead of a tab. This way it is the same no matter where I paste it. 
While that may be true, they are also not taking into account the fact that huge swaths of software *cannot* run on higher versions of PHP. If you look at https://www.drupal.org/project/usage/drupal you'll see that there are over a million servers running drupal 6/7. Neither of which can run on a php version greater that 5.4 without a fair amount of hackery. 
Good thing i already patched everything back then. Out hosting provider sent us a scary e-mail and for a second i thought it was another vulnerability.
He's saying bower written in Go. As in, its a statically compiled language, continuing the original joke (even though Python was mentioned?).
This isn't a job board. Try elance or something and find an overseas dev for $2 an hour.
you should first check if it is empty or not quick example if(!empty($_GET['id']) { //checks if id is set $page = $_GET['id']; } edit: also there is a sub reddit for this kind of stuff, /r/phphelp
 $page = $_GET("id"); This can't work. You're accessing an array, the parens tell php you're trying to access a function. Use $page = $_GET["id"]; instead. The "Content Encoding Error" problem often occurs when using ob_gzhandler() and you somehow wind up using multiple (or broken) content encodings in the same output. It is an error which is produced by the browser, and not by PHP. Is there more code in your file(s) that you're not showing us? It's possible xampp is doing something screwy to force compression on the content, which would be pretty strange because using PHP to compress content is pointless as every web server is capable of doing this more efficiently. I personally don't use xampp or anything like it, so I can't comment on how they configure things. Try removing the closing ?&gt; tag, does the error persist? [This stackoverflow post](http://stackoverflow.com/questions/6402806/php-output-buffering-content-encoding-error-caused-by-ob-gzhandler) outlines a reliable way to try to get more information on why the browser is puking on the content.
Lulz? No way. I'm rewriting my whole company on this framework. Serious business.
The fact that this is getting criticism shows just how far PHP still has to go. Too many people in this industry seem to think they can just “roll their own” when they want an emoji. But if you want your emoji to be testable and production ready you should absolutely be using a proper emoji framework. Stop re-inventing the tiny picture of a wheel, people.
&gt;I'm struggling to find a good example of where I'd prefer to have an overloaded constructor instead of creating a factory though. It doesn't have to be either/or. The factory, in its various methods, can simply call new Foo() with different signatures for __construct(). Yes, with a factory you can emulate overloaded constructors fairly easily, but I still think overloading makes the code a lot cleaner. &gt; Heck 'goto' got added and I think that has far more potential for abuse. :P Indeed. I'm still waiting for someone from interals to come out and say that was only a joke and they got carried away :)
Their site is designed like they would advertise PHP 5.3.18
This is amazing.
I recommend sublime text as an editor. Get it, install the plugin package manager, then use package manager to install sublime lint, then install php code sniffer linter for that. This will give you real time cues as you type for coding standards. It will solve your indention problems as well as hint you towards writing code compliant with the PSRs. Then use package manager to install docblock, git, and git diff plugins if you decide to stick with sublime. These will show you inline duffs and auto-parse and generate docblock shells based on your code. Super easy!
What is a valid and unrelated observation? ORMs for $700 Alex.
It was many years ago, so I don't remember much, except the fact it took more time than 5.3 -&gt; 5.5, sorry. There was a thing about call-time pass by reference, which we used in several places and became deprecated with 5.3, if I remember correctly. We've also met some problem with mysql old passwords -- switching to mysqlnd, they are not supported anymore. Migrating one big application from 5.2 to 5.3, we've had a few memory_limit too ; but that may also because we swiched from 32bits to 64bits at the same time (and using mysqlnd didn't help, most probably). 
As far as I can tell, Assetic's minifiers are just PHP wrappers around the Node binaries using the Symfony process component. For example, [the UglifyJS2 filter](https://github.com/kriswallsmith/assetic/blob/f8a41b17522dadccbaeb422d4c6617b46c4c52f5/src/Assetic/Filter/UglifyJs2Filter.php#L80-L150).
The article you're linking too says "By Daniel Cid on October 15, 2014 . 7 Comments".
"Find out in 30 yrs!" 
Yeah, [originally](https://github.com/laravel/framework/blob/c75735eff4e1f0ac96ce8fd7dd46ef14415cf994/src/Illuminate/Exception/Handler.php#L130) it was ErrorException, I just wrote gist wrong. Next time I will copy-paste code. In fact this mistake doesn't change original idea to shot yourself too much - it doesn't matter what kind of exception is thrown, while in gits demo no exception is thrown at all, so with the same success empty anonymous function may be used: set_error_handler(function () {}); P.S.: thanks for paying attention to code! I just fixed this in gist.
That error handling function is not mine (thankfully) and in fact it may be even empty anonymous function. I just share the concept that it is possible to violate what written in documentation. Not good, not bad. But when it happens inside some bunch of code and you don't see all in one place, it looks very strange when you get NULL for type hinted argument without default value, isn't it? 
Is the name supposed to be a jab at Laravel or am I missing something?
Just stop calling them emojis! Emoji is a standardized design pattern that is absolutely different from the smiley thing being used here. Using that word will just confuse the hell out of newbies when they later want to learn a proper framework implementing Emojis correctly!
Consider using http://cs.sensiolabs.org for easier fix. I wish you could stick with PSR-1, 2 . Tab length differs on editors. So spaces looks nice to me.
Fixed the indentation issue in the last commit to GitHub. Thanks for your comments! I have always used 2 spaces instead of tabs, but seems I missed a setting in Vim to expand tabs, since switching to that editor. But hey, the whole point in making this website was to learn more about using Vim, so I guess this issue adds to the experience ;)
Seriously? You are commenting in a thread about a page for Vim configurations and your idea is to recommend a different editor? I was looking more after an answer like that: http://vimrcfu.com/snippet/92
Depends on your eCommerce platform, which should be a decision you make based on a lot more than what the cart looks like. It's also unlikely that the cart of the platform will look like this, so no matter which way you go you will probably have to hire a developer to customize the platform you have to look like that and have that layout. 
More of this please!
Interesting approach: makes me feel like I didn't help you enough on IRC though (as those really are all fixable annoyances).
*Open source* is not a verb.
Because it uses features that were deprecated in 5.4? I know that's what we've run into with a couple of projects. Some of those deprecations are easy to grep for and fix, others not so much.
Yes, he should check his code before making it public, but we could resume ourselves to give him a heads-up when we see a mistake and not assuming from the start that he doesn't know how to throw an exception. &gt; That last one was clearly an Archer reference You make to much assumptions. Regarding the OP that he doesn't know how to throw an exception and about me that I have time to watch every single TV series. Like I said: more empathy and less assumptions.
The little golden centipede with a laser gun extends the container, kills the exit man.
They're much more like static word proxies.
 echo "string:$a integer:".($a*1)."\n"; echo "string:$b integer:".($b*1)."\n"; string:0e462097431906509019562988736854 integer:0 string:0e830400451993494058024219903391 integer:0
Even using a completely pre-built platform is typically complex when you start customizing things. You said in your other comment that you are using wordpress, and already have a cart. But what are you using to get the cart? Is it a plugin? If so, which one? Basically we need more information to help out here. We don't know what your site is made up of already so we don't know how to advise you to move forward. If you have have shopping functionality on your site already and just want to add categories to the side, that will still require a developer but is much easier. If you don't have shopping functionality already, then you will need something to handle that. Something like [WooCommerce](http://www.woothemes.com/woocommerce/), considering you are already using WordPress. Be careful not to underestimate the time and cost to get "simple" things done. Something that seems simple may actually be incredibly complex. Categories for example, it may just seem like links on a page, but where do the categories come from? Are they in the database? Do they need to be automatically generated or will they stay the same? Where do they go when you click on them? Do you want a product count next to the categories? Etc.. Simple things can often be more complex than we initially imagine.
In other words, only use the equality operator when you know that you want special-case behavior (e.g. `'0' == false`).
Looks like zero to the power of x compared to zero to the power of y. Either that or very similar. PHP will classify something that looks like a number as a number, unless you use three equals which does a type check, if I recall properly.
Paul I attended your talk and enjoyed it thoroughly. I'm trying to get my team to refactor our code. Since revenue is our priority and not clean code, it's somewhat of a battle. I'm trying to isolate areas where revenue and site performance intersect so at least both sides can bo happy. Any tips on convincing others to refactor would help... Also, I'm curious about the performance and memory usage of your code before and after the refactor. Do you have any metrics?
Instant full stop and turn around to OWASP while reading this: "A year and a half ago, I was very proud to announce a new initiative to create a database of known security vulnerabilities for projects using Composer."
Alot?
Note that if you're comparing hashes, encrypted values or other strings that need to be secure, using === or strcmp() can make your application vulnerable to timing attacks. You can mitigate this by hashing both strings with something like md5, or better, compare both strings character by character without returning early. PHP 5.6 users can use http://php.net/manual/en/function.hash-equals.php Also have a look at Symfony's implementation of comparing strings in the security component: https://github.com/symfony/symfony/blob/v2.5.6/src/Symfony/Component/Security/Core/Util/StringUtils.php#L28-L65 
How hard would it be to fix the root cause in say a bc breaking version like php7?
It indirectly requires PHP &gt;=5.4.0
Yes, duh.
I offer Enterpwise™👍 support for $1,999 per week.
Dude, if it was really enterprise it would be: Enterpwise™👍 support? call us on 1-900-LAR-VELA
This was probably also mentioned today because the Drupal project officially released a PSA earlier about it: [Drupal Core - Highly Critical - Public Service announcement - PSA-2014-003](https://www.drupal.org/PSA-2014-003)
is_numeric("0e462097431906509019562988736854") =&gt; true It's a number with exponential part. Both are 0 because 0 ^ n = 0. It's an edge case. As /us/mongbatstar says use strcmp() or "===".
CPanel backups on dropbox[1] are probably easiest to do by setting your backup directory to some mount point that's FUSE mounted to a dropbox account. I'm not sure if a (presumably web based since you're talking about a PHP script) service is the best way to do that. You may be doing it wrong if your script takes backups on its own instead of exec()'ing pkgacct. CPanel does backups and restores well enough on it's own, IMO. [1] Why would you do this? I suppose dropbox works as the poor man's remote backup system, but there's no way I'd put client data on it.
PHP type-coercing is a lovely thing, haha. PHP will convert your strings to boolean, int, float, whatever whenever it thinks it can do so. Here is a bug report on your issue. https://bugs.php.net/bug.php?id=54547 According to the devs this is a documented feature here: http://php.net/manual/en/language.types.string.php#language.types.string.conversion Solution from the devs is if you want to compare strings as strings use strcmp(). Here is a little more info on strcmp() vs ```===``` See the marked answer http://stackoverflow.com/questions/14711474/strcmp-vs-vs-in-php-for-checking-hash-equality
I think OP already knows that much. OP is asking why, and that's cool. 
It's amazing how you keep confusing 'Naming conventions **for code released by PHP-FIG**' with the real PSR. As @dracony said, it's **their** code.
Certainly. While server-wide response times (all pages over multiple sites) have decreased, on average, by 50 ms, we certainly ported over the CPU and memory-intensive web apps first (biggest bang). For complex calculations, we have seen average response times drift from, at one extreme ~45 seconds [offloaded to gearmand] to 2.7 seconds running directly from HHVM, to around 200-300 ms optimizations across the board for operations that handle large datasets. With logged in users, we experience the most benefit, and that is where we see the most growth: activity of logged in users.
Well, in that case you're definitely excused! :) I am in the progress of applying "php-cs-fixer" to my code base right now, so there should be improvements to coding standards and readability pretty soon. Additionally I'm investigating the best way to incorporate this into my workflow. Either as autocmd in Vim or pre-commit hook in the repo.
http://i.imgur.com/sTHTkda.jpg
Neat! Love this. Going to play with it.
Get off your horse, not everyone was born a god at programming like you.
In the end, it does matter, because you (or someone else) will be maintaining that code in the future. I prefer common sense over forced conventions. Don't get me wrong, i'm a big fan of PSR-2 and other coding style recommendations, but in my team we only follow the guides that make our job easier.
dude, it's reddit, not your private school where we all wear the same uniform...
o_0 WordPress and RESTful API
Whenever I hear about the people who wrote facebook, I am reminded of a story about the site's early days. Dustin Moskovitz knew Mark Zuckerberg and wanted to help out but didn't know anything about programming. He went home over summer break and that fall approached Mark telling him he'd learned how to write Perl. Mark said "the site isn't written in Perl!" but took Dustin on anyway. I always laugh when I think about that interaction. "Dude, I learned Perl over the summer so I can work on facebook!" "Dude, the site isn't written in Perl!!!"
Better use function isset or array_key_exists I recommend to use some frameworks (Symfony2, Laravel, Yii, etc. )
It's a little better than that time ExpressionEngine tried to pretend they could do it. http://www.venveo.com/articles/building-a-restful-api-with-expressionengine-templates
&gt; tried What is the problem to use Symfony2 with FOSRestBundle? Or use Sliex framework?
the fix? relatively simple, getting the fix approved and merged in? well... https://bugs.php.net/bug.php?id=3066
How would you ever fix this and not break PHP's weak typing?
Sorry, but as a Zend® Certified Emoji Engineer®, you clearly don't know jack shit if you think the plural of "Emoji" is "Emojis". In Japanese, there are not singular and plural forms of a noun. It's not not "1 Emoji, 2 Emojis", there is just Emoji.
REST is an architecture, not a protocol and it was never standardized. Stateless, idempotent should be the basis of this kind of architecture; PUT, DELETE and all these shit are just here to identify the service, but it's not a convention, it a "de facto standard". "GET http : / / domain/user/add" or "GET http : / / domain/user/delete/2478" is not "wrong" If someone wrote "DELETE/PUT/POST/GET" in a book or on a blog, it does not make a standard.
Aren't the *usages* of these (DELETE/PUT/POST/GET/PATCH/etc) defined in a standard?
&gt; How are there 36 instances of PHP6? Back when PHP 6 was a thing, some people, who probably weren't very smart, decided to use the development branch in production.
That's a good point, but in my opinion, the fact that the bigger picture is fucked doesn't just let them off the hook. If they can't afford to do it right (plenty of hosts offer side-by-side PHP versions), they should just close up shop. They're damn sure not going to make it with their Python 2.5 offering. But again, this is just my own perspective - I'm sure I don't fully appreciate the deeper challenges of running a hosting business. Either way, I still stand by my statement that it's probably the worst hosting you can get for your money.
Yes, this is the HTTP protocol (but not for "PATCH"): http://www.w3.org/Protocols/rfc2616/rfc2616.html (for PATCH, see RFC http://tools.ietf.org/html/rfc5789)
No one said it was a standard. No, it isn't "wrong", but you can't call it RESTful, either. The term RESTful should be reserved for things that stick to the original paper describing REST. Anything else is REST-like at best, and totally-not-REST-like in your cited examples.
I do and I did, and it did indeed output "OneTwo" but with a space between.
Updating...
From the answers here, I understand that PHP is attempting to convert both strings to a numeric value before comparing them. But even with PHP's weak "==" comparison operator, if both variables are strings, isn't it supposed to compare them as strings? I thought it would only convert them to numeric values if one of them was already an integer or float value (not a string). 
So you already know the answer Edit: I suck at typing
and because most people are using HTTP for REST services you can refer to the HTTP standard for REST usage - although I do get what you are saying. REST is an architectural style not a protocol.
From your link... &gt; As of PHP 5.4.4, a change was made which causes two numeric strings which both overflow and appear equal numerically to be compared as strings instead. Before this change, even these such strings were compared numerically. So doesn't that mean that after 5.4.4, this problem shouldn't happen? Since they're both defined as strings, the comparison should be comparing them as strings now, not numbers. But the code linked in the original post says it's running on PHP 5.5.1, so the comparison should be done as strings, not numerically. So what's going on then?
You know the best people to advertise PHP work to? PHP developers! This is the same reason I sell meat to my local butcher, and deliver my mail man's mail.
domain is redirecting to your blog
I tried running it again and it threw all sorts of errors. Took me half a minute to realize it tried running it as C not PHP. Time for either mid-afternoon coffee or a nap.
The question is based on type juggling around comparison operators. When comparing a bool and another type, both sides of a comparison are cast to bool. The truthiness of an string, except an empty string, is true. See the Comparison with Various Types table [here](http://php.net/manual/en/language.operators.comparison.php) Your question belongs in /r/PHPhelp
&gt; *two numeric strings which both _overflow_ and appear equal numerically* That's the thing - the hashes do not *overflow* when converted to numbers. `0e9999999999999` is still `0`. The change you quoted was made to stop strings pretending to be humongous integers from comparing equal. For example, see the second line in http://3v4l.org/ulqj3 - those two numbers have the same double representation, so the pre-5.4 code compared them as numbers, but the updated code does not.
Forgive my ignorance, but why not domain/user/2478/delete ? Just trying to learn something here, - to me it would be more logical if you "apply" deletion on the "object" 2478. Not move the object one level down in the path just because you delete it.. 
PHP seems to only compare things as strings if it failed to convert the variable to another type first. One of the php's weak-typing gotchas. Makes some things very annoying when you really want strong-typing.
Deprecations don't cause any problems (you're not showing notices on live sites I hope!). You can upgrade to 5.4 and start work on moving away from the deprecated features. That's the whole idea of deprecation, to give you a window in which to update your code *before* the feature is removed.
Every time I've dealt with adding a composer.lock file it has resulted in me telling myself I'll never add it to another project. It basically comes down to... * That file is a nightmare on diff'ing. Cause of merge conflicts? composer.lock 9/10 times sigh. * Someone on the team forgets composer install vs update and commits the new updated lock file by mistake * With the lock file the team becomes lazy in terms of updating the packages to the latest stable. They'll treat it as if they've just cloned the whole repo and it is set in stone for life and will never change. Edits: Clarifying points.
Because REST uses HTTP methods (verbs) to do things. There is an existing HTTP method "DELETE". Why re-invent it in the URL (*/delete/*) instead using the existing HTTP method? You can also think about it as you'd think about any other abstraction. You abstract the verb away from the URL and use the generic HTTP verb (method).
I've started making a personal rule of refusing to use code that doesn't doesn't conform to PSR0 or PSR4. It is 2014, please namespace. I'd suggest reading [this over](https://philsturgeon.uk/blog/2014/10/php-wars-attack-of-the-clones).
&gt; That file is a nightmare on diff'ing If a diff ever comes up (which has actually been pretty rare) I just scrap it, run an update, and commit the new lock file. &gt; Someone on the team forgets composer install vs update and commits the new updated lock file by mistake Most of my team doesn't even know how to use composer. I wrote an all-in-one CLI tool based on Symfony console that handles everything. *I'm* the only one that runs 'composer update'. &gt; With the lock file the team becomes lazy in terms of updating the packages with @stable; They'll treat it as if they've just cloned the whole repo and it is set in stone for life and will never change. I don't think tags are much of an issue if you never distribute your software. If you do, you should be adding them for the public, not for your internal team...right? Presumably you will keep your own projects compatible with your own projects, so you should almost always be running the latest.
Phil, could you elaborate a bit on API versioning? It's not very clear to me how to version an API. I mean - HATEOAS states it's better to do it via content negotation (accept/content-type headers). On the other hand most sites version their API-s by changing URL-s. I'm having hard times to see the pros and cons of either method.
Thats just... just PHP
Not sure who you are arguing against here or how or why. The linked article did not say it was a protocol, or a standard. It said it was an architecture. &gt; In practice, basically everyone uses HTTP. And since we’re discussing the creation of an API that conforms to REST rather than a system architecture based on the principles of REST, HTTP is a solid assumption on our part. **Update:** Holy shit I just saw this. &gt; "GET http : / / domain/user/add" or "GET http : / / domain/user/delete/2478" is not "wrong" Well, yes, that _is_ wrong, in that it is not RESTful and further more it is a terrible idea in general. 1. You are adding actions to your URL instead of letting the HTTP verb do that for you. 2. Google can crawl that shit and empty your content. This happened to one of Rackspace's systems.
When I was writing the API Versioning chapter for my book I found a lot of good content in this article. http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html They all have pros and cons, but only one of them can be considered RESTful. Versioning specific resources with an accept header instead of one API-wide version is the strongest approach, but it's tough to implement. 
Always commit composer.lock for applications. Never commit composer.lock for components.
I love REST as a paradigm but I can't help myself commenting on HATEOAS. I find this idea terrible; like yet another step back into useless complexity. It feels like the same fight than the one between XML/DTD/SOA vs. straight forward JSON behind human readable URL. Please let me finish before downvoting. First the claim &gt; Your APIs should do this. There should be a single endpoint for the resource, and all of the other actions you’d need to undertake should be able to be discovered by inspecting that resource. My answer is why? API are not made for humans but programs. As a developer, I want my programs to be simple, light and easy to understand. If I go on the HATEOAS way, I can't simply build up an icon URL by adding "/icon" to a photo URL. Now I have to write a program that will parse the photo metadata and look for a "icon" hyperlink. The problem is that by doing so, I don't remove any technical dependency. It only moves an initially hardcoded behavior (says {$rsc_url . "icon"}) into another (says $downloadedRsc["links"]["icon"]) My claim is that programs can't "discover" links like humans do when reading web pages. A program must relay on some sort of contract, saying for example that icon links are typed/flagged with some "icon" metadata (à la &lt;link rel="icon"&gt; ). So here is the result: instead of hardcoding a relative url, one hardcodes a hyperlink "class" that the program must find in the initial resource to eventually retrieving the same url. Think about it. It doesn't change anything. One may argue that the presence of a typed hyperlink in a resource might indicate that the operation is relevant and permitted. Fine, but I could as well directly ping an harcoded relative URL to "discover" this information. I feel sorry I can't explain better my thoughts. Do anyone know some well written criticisms about HATEOAS and why REST without hyperlinks is not so bad? 
Don't use traits to compose classes. There are other ways to achieve "composition" (delegation, strategy pattern,...). Use traits to help with [cross-cutting concerns](http://en.wikipedia.org/wiki/Cross-cutting_concern). Make them self-contained and testable. Maybe we'll get grafts at some point: https://wiki.php.net/rfc/horizontalreuse#grafts_-_class_composition_not_implemented
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Cross-cutting concern**](https://en.wikipedia.org/wiki/Cross-cutting%20concern): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), __cross-cutting concerns__ are aspects of a [program](https://en.wikipedia.org/wiki/Computer_program) that affect other [concerns](https://en.wikipedia.org/wiki/Concern_(computer_science\)). These concerns often cannot be cleanly [decomposed](https://en.wikipedia.org/wiki/Modularity_(programming\)) from the rest of the system in both the design and implementation, and can result in either *scattering* ([code](https://en.wikipedia.org/wiki/Source_code) duplication), *tangling* (significant dependencies between systems), or both. &gt;For instance, if writing an [application](https://en.wikipedia.org/wiki/Application_software) for handling medical records, the indexing of such records is a [core concern](https://en.wikipedia.org/wiki/Core_concern), while [logging](https://en.wikipedia.org/wiki/Data_logging) a history of changes to the record database or user database, or an authentication system, would be cross-cutting concerns since they touch more parts of the program. &gt;==== &gt;[**Image**](https://i.imgur.com/mnYMVu9.png) [^(i)](https://commons.wikimedia.org/wiki/File:AspectWeaver.svg) --- ^Interesting: [^Aspect-oriented ^software ^development](https://en.wikipedia.org/wiki/Aspect-oriented_software_development) ^| [^Aspect-oriented ^programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming) ^| [^United ^Nations ^Population ^Fund](https://en.wikipedia.org/wiki/United_Nations_Population_Fund) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clokkkb) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clokkkb)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
So thats kinda the point. You can make yourself a JSON API. Or a HTTP API. Or whatever you want to call it. Without using HATEOAS you cannot call it a REST API. You don't need to call it a REST API. You can make a XML-RPC API or a SOAP API too. Calling it the wrong thing misleads people and that just a pain in the dick.
I see you haven't been bit by the "Shit, something changed between my commit and deploy" issue yet, or you just super strictly version your required packages maybe? I admit, this has only happened to me once, but it was enough that the composer.lock was committed forever and always, from that day forward. EDIT: Or maybe you mitigate this risk some other way?
&gt;PHP seems to only compare things as strings if it failed to convert the variable to another type first. This begs the question: Why?
PHP's "weak typing"? Do you mean type juggling, or not having to specify types on function definitions and variables? The latter wouldn't go away when fixing this; the former would, and that's a very good thing because it's a really, really awful idea.
to a newb, the composer.lock file is super confusing. Thanks to this article, I now have something to send some very specific people who are confused about what Composer is and how it works. Cheers!
Would you care to elaborate on why you shouldn't commit composer.lock for components? I'm curious.
By design. PHP is a weak-typed language. The developers decided, for better or worse, that strings would be converted to other types for comparison, if possible, before comparing a string as a string. The exception is if you use a literal comparison such as ```===``` or a string function. As long as you are aware of this everything works as expected. I admit it would be nice if it tried string as a string before attempting conversions to other types. :/
Wow. That's pretty impressive!
In nearly every language, an equivalency operator (=== in PHP, == in Ruby, strcmp in c) use a short circuit evaluation. In Ruby, the comparison operator might be coded like this: return "not equal" if a.length != b.length a.length do |n| return "not equal" if a[n] != b[n] end return "equal" The problem with that is, when comparing "azzz" and "bzzz" to "ayyy", the first answer will take longer to run that comparison, because 'bzzz' will return on the first run through that loop, whereas getting the first character correct means it will loop again. With the first character known, you can test "aazz" through to "azzz" and shortly you'll know the second character, and so on. The timing difference is tiny and yes, over a network connected to a busy server this is not likely exploitable. But it does represent a channel that can be exploited under a number of circumstances. The Cryptopals challenge asked people to actually write an exploit for this. 
Here I was, gitignoring the lock file. Woops
That's thing. It would make sense if you said "it's weak typed, so if you try to compare a string to an integer it will try to coerce one of them", but I can't see how it made sense to say "if you try to compare a string to a string we should try and coerce to an integer first".
My main issue with this aspect of composer is the terminology. It's established that "install" means do something from scratch and "update" means updating something pre-existing. But that's not at all what it means in composer land. "**composer install**" should be more like "**composer sync**" and "**composer update**" should be "**composer install**" or "**composer rebuild**" (or something) IMO. Besides, the way composer handles this as a dependency manager breaks from most (all?) other dependency managers I've ever used.
I actually disagree with this. If you don't commit it for the component, then the components dependencies can be updated outside of the component authors control (desire/ability to keep up with changes). Having said that, the component `composer.lock` is ignored when you include it in your `composer.json` anyhow...
Does this ship with Compoji? I can't see the Emojis so I might need to run `Compoji requiji emoji/emoji`
Well it turns out that the paper doesn't talk about HTTP methods or about structuring the url. You _can_ conform to REST _and_ break the rules of HTTP. If you want to put the method in the url and use `POST` for everything, it can still be restful as long as you are transfering resource state, guarantee idempotence, etc. It may not be the most appropriate way to design a REST api on top of the HTTP protocol, but it's not persé wrong from a REST perspective.
Congrats, you made the term REST so specific that no one is eligible for using the term anymore :S. Or you can look at the real world, see how the term REST is _actually_ used by 90% of the population.
Components should really be linking against exact versions (at least to the minor version) of their dependencies, not `dev-master`, `1.*`, etc.
REST is not a badge of merit that should be easily accessible to those who try hard. It's a specific term for a specific thing that people have misused. It's like the Oxford dictionary adding a second definition to "literally" that means "figuratively." Just using a word wrong for a long time doesn't mean that you're right about using it anymore.
Inventing new verbs is ok. Injecting verbs into the URL and ruining the concept of resource URIs is not. They are different things.
If you commit the composer.lock file for a component then you are requiring a VERY specific version of a component, which drastically increases the potential of dependency hell. The ruby community has had Gemfile and Gemfile.lock for years. They are identical in this regard. They commit Gemfile.lock for applications, and ignore it for Gems. We have no reason to do anything any differently. 
https://www.reddit.com/r/PHP/comments/2kt4cw/composer_its_all_about_the_lock_file/clos5jf
I dont understand. You can absolutely add new verbs if you feel like doing that, but you don't need to as most of those can be handled through the HTTP specification as is. Shoving verbs into the URL is not impiricly a bad idea, but it makes it JSON-RPC and not REST. That's ok, just don't say it's REST. Because it isn't. :)
It does talk about a URL representing a resource, and that resource does not changed based on the action. So `/foo/X/delete` is a different location based on the action.
That's the best way to get into dependency hell… - I require component1 which requires v1.1.1 of component2. - But I also require component3 which requires v1.1.2 of component2. v1.1.1 and v1.1.2 are probably completely compatible, but composer install doesn't work… So no, don't require exact versions in libraries. Just pay attention at your dependencies changelog and try to do something that makes sense.
Actually, if you read the oxford dictionary on "literally" you will find that it does include using literally in figurative contexts. And it should. Language and definitions of words evolve over time, and there's many other examples of words of which the definition changed over time, due to a different common use. You literally couldn't have picked a more perfect example: http://blog.oxforddictionaries.com/2013/08/literally/
Cool, this is awesome! Did not know you could do it in pure PHP
I explicitly specified to minor version. My examples said not to use dev-master or major versions.
Well, I don't know if it's HATEAOS or what, All I know is that as a developer, I create an API that I believe a developer would enjoy using, and would be as simple to work with as possible. I provide 'links' and other data that support the links... for instance, this is how I provide pagination for my APIs... "pagination": { "totalItems": 471, "totalPages": 5, "currentPageItems": 100, "itemsPerPage": 100, "pages": { "current": { "number": 2, "url": "?search=foo&amp;limit=100&amp;page=2" }, "previous": { "number": 1, "url": "?search=foo&amp;limit=100&amp;page=1" }, "next": { "number": 3, "url": "?search=foo&amp;limit=100&amp;page=3" } } } as you can see, the pages are very simple to use, I provide not only the link to the pages, but the page number themselves. I do all my relevant information this way. If I have a blog post, I'd provide the post itself, if there are comments that are attached to the post, I'll either provide the comments in the data, or a link to where the comments can be retrieved. Personally I think it's a very nice way of writing an API. I try to be verbose and organized with my APIs, what's a few extra bytes when it could make for an easier implementation for a user.
I know that it does... I used it for that exact reason. I disagree with the way that happens in the dictionary, but that doesn't mean we can start bastardising specific terms in computer science too.
It's a great step in the right direction. :)
You may disagree with how that happens in the dictionary, but you're speaking in a language with an insane amount of words that have gone through that very process, and were probably met with some resistance by some language purists ;). Sorry to break it to you, but if the majority uses a word 'incorrectly', over time it will become correct.
Sorry, a little drunk and realize I didn't finish. Basically what I mean is if someone's claim to fame (lead dev) is WordPress I'd probably expect nothing more than where you're at
Honestly the same would apply to minor versions *in most cases*. Take Symfony YAML, which is used by many projects. If components start requiring specific minor versions of this (2.1, 2.2, 2.3…) then it will just bring troubles to users. We have to use good judgment, but when a dependency strictly adheres to semver, we should try to require major versions, e.g. like this: `~2.1`.
I don't get it I can't find "Pure PHP" on Packagist, how can I use this `header()` function!
If it's important to your that your job is an environment for you to grow as a developer (it should be) and you've truly given your best effort to improve that environment and it's fallen on deaf ears, then haven't you already made your decision?
Thanks. I'll look into the call by reference thing. I don't remember seeing that in the migration docs. 
At the very least this place has given you some valuable experience. You now know the questions you need to ask in your next interview and what type of work to avoid. I think people forget that an interview is a 2 way conversation. It isn't just the employer checking you out to see if you're the right person, it's for the prospective employee to gauge whether they think the job is right for them. You also currently have the luxury of being paid a wage, which you can use to support yourself while you look for something better. I would start looking straight away. Your expectations are not high at all - the kinds of things you seem to be after are not unreasonable. And when the newbie junior seems to care more about modern practices than the grizzled veterans at a company it's a sure sign something is up.
Agreed. REST is being relegated to a buzzword for recruiters to search through resumes for (like asking "do you know AJAX? What about JavaScript?")
In my (albeit, limited) understanding of HATEOAS that is the idea - you create a "self documenting" API. Can I tell what's going on in this example? See other actions? All without needing to refer to documentation? In this example, yes. 
The final thing I will say here is that while popular culture moves words along at a pace that May or may not be acceptable to many, computer science terms do not change over time regardless of popular misuse.
I don't see how traits are a bad fit for this. 
+1
You have no idea what you're talking about.
Well, we'll just axs the futurama people about that ;)
I agree that automated "discoverability" might not be that useful for short lived web applications, but the absolute resource urls can be really helpful. It lets you move things around really easily: * Move resources to/from cdns. * Extract microservices gradually from monolithic applications. * Correct early mistakes in url structure or adapt url schemes to application changes. It also gives you the ability to browse the api (with something like JSONView). It doesn't solve all problems but a few ground rules and using a standard like JSON-HAL gives a lot of flexibility.
In this case, mongbatstar would be suggesting using === or strcmp() to compare md5s, not to compare the original strings - which would be exactly in line with your suggestion. 
Your expectations are not to high at all. That is where modern software development and PHP are headed, expecting anything less is just plain wrong. The best you can do is keep learning modern PHP on your own while freelancing if you can. Start looking for a better job and tell your next employer what you expect from your job. Junior developers like you and me should learn otherwise we wont be relevant in the future. Goodluck
What if everyone in the future gradually began to use the word "head" instead of "butt"... ... and "butt" instead of "head"?
Does this mean that embedding of related resources in the result (rather than providing a link to the API endpoint that provides them) goes against REST?
Thanks for good link! I gotta get your book, too:) There are a few important API-s to be designed. I better do it right from the start this time.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Side channel attack**](https://en.wikipedia.org/wiki/Side%20channel%20attack): [](#sfw) --- &gt;In [cryptography](https://en.wikipedia.org/wiki/Cryptography), a __side channel attack__ is any attack based on information gained from the physical [implementation](https://en.wikipedia.org/wiki/Implementation) of a [cryptosystem](https://en.wikipedia.org/wiki/Cryptosystem), rather than [brute force](https://en.wikipedia.org/wiki/Brute_force_attack) or theoretical weaknesses in the [algorithms](https://en.wikipedia.org/wiki/Algorithm) (compare [cryptanalysis](https://en.wikipedia.org/wiki/Cryptanalysis)). For example, timing information, power consumption, [electromagnetic](https://en.wikipedia.org/wiki/Electromagnetic_radiation) leaks or even [sound](https://en.wikipedia.org/wiki/Acoustic_cryptanalysis) can provide an extra source of information which can be exploited to break the system. Some side-channel attacks require technical knowledge of the internal operation of the system on which the cryptography is implemented, although others such as [differential power analysis](https://en.wikipedia.org/wiki/Differential_power_analysis) are effective as black-box attacks. Many powerful side channel attacks are based on statistical methods pioneered by [Paul Kocher](https://en.wikipedia.org/wiki/Paul_Kocher). &gt; --- ^Interesting: [^Timing ^attack](https://en.wikipedia.org/wiki/Timing_attack) ^| [^Cryptanalysis](https://en.wikipedia.org/wiki/Cryptanalysis) ^| [^Power ^analysis](https://en.wikipedia.org/wiki/Power_analysis) ^| [^Acoustic ^cryptanalysis](https://en.wikipedia.org/wiki/Acoustic_cryptanalysis) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clp04cs) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clp04cs)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
In any other language, the existence of such a bug, the super-secret "feature" associated with it, and the batshit insane response from the devs would all be grounds for immediately forking the reference implementation and starting a crowd funding effort to have the original maintainers shot.
If you are patient and you glue enough dildos onto the face of an angry, diseased bear, you will eventually create a functional sex toy.
"Sync" sounds like it syncs from upstream. It becomes simpler if you think about composer just from the lock file and forget composer.json. Install means "install the version in composer.lock". Update means "update the composer.lock file".
&gt; You also currently have the luxury of being paid a wage Don't undervalue this, either. I think most of the stuff I've learned has been in my own time, while my actual workplace did shitty practises because they had work to do. Legacy projects, established workflows, ingrained practises, etc. Having a job, past experience, etc, is worth a lot. As a worst case you can find an area that your senior isn't "pro" in, like front end, or databases, or whatever, and focus on that.
If you are a young developer capable of learning new skills/languages/frameworks, why would you choose to start a career using PHP? Yes, you'll be able to find work, but you will be damned to spend your most productive years in the company of only the most borderline-retarded of developers and organizations. Just because Facebook's guts are (still) ~mostly PHP does not change the fact that the entire language is a simmering pile of donkey-shit hacks and bad practices. It can be argued that just working professionally in the language marks you as the bad engineering equivalent of a Typhoid Mary in the eyes of any technically knowledgeable manager.
Phil that is incorrect. When you are using a library as a dependency of your project, its composer.lock is not read by composer, for it has no effect what-so-ever on dependency hell. (what leads to that is bad version selection with * no ~, read my blogpost). The role of the composer.lock for libraries is to help your contributors work on the same versions that you are working as well as keep your Travis CI commits using the same versions you were coding against. Gems and composer packages are different not all the same rules apply. While there are arguments for keeping the lock file, "dependency hell" is NOT one of them.
They should not actually, they should be using the appropriate semver selective version: ~1.2 (&gt;=1.2.0, &lt; 2.0) or ~1.2.3 (&gt;=1.2.3, &lt;1.3) This makes it possible to avoid dependency hell. And allows composer to work out versions with more flexibility. The kicker here is if libraries decide to ignore semver, then its anyones guess and no practice will save us from hell.
TL;DR: PHP is a bad joke of a language; the awful "skills" PHP developers have to learn in order to use the language mean that they are poison to any organization/project not inhaling paint thinner.
A bad programmer will write bad code in any language. A good programmer will write good code in any language. Yes it is easier to write bad code in PHP, it let's you get away with a lot more, but only bad programmers will be writing bad code in the language...
&gt; It can be argued that just working professionally in the language marks you as the bad engineering equivalent of a Typhoid Mary in the eyes of any technically knowledgeable manager. If a manager that's hiring a developer has a viewpoint that narrow, maybe it's a good thing that he'd disregard you, as working under that manager would be a dead end. As iterated below, good programmers write good code regardless of the language. A bad programmer will still write bad code in C#, Java or APL. 
While I agree with your general sentiment, it is physically impossible to write good code in PHP. No matter how well-architected and carefully implemented your project is, the language itself is guaranteed to fuck you sooner or later. For example, you carefully determined all of the possible error flows that your implementation could trigger (and you properly handle all of the associated exceptions) - great! Did you also take it upon yourself to un-fuck the myriad of poorly documented (if at all) places in the core language API that can/will still trigger error signals instead? You did?? Wow! ... how about *fatal errors* that bypass the handling all together? How about the get_last_error() style calls in dozens of different frameworks, many of which will fail (even expose security holes), all completely silently, unless you perform a synchronous call to the check method after every API invocation.
A quick search on Google and you will find flaws in the core of any programming language. It's not really fair to judge PHP based on that, if you aren't going to judge the other based on the same criteria. Google: java sucks c++ sucks ruby sucks python sucks
I am not putting forth any claims that any other languages are flawless, or even close. I *am*, however, arguing that PHP is, by far, the single worst language in widespread use. I base this assertion on both personal experience, but, more importantly/convincingly, on the utter mountain of objective evidence of PHP's failures. You don't need to look much further than the [entire subreddit devoted to pointing out PHP's ridiculous flaws](https://www.reddit.com/r/lolphp/). If you want precise (and devastatingly thorough) reasons instead, there is a quite well-known article available here: http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/
yes, it actually has an effect instead. an indirect one. if you commit your composer.lock in a library, only developers of that library will be using the same version. that eases that library development, but you are not actually locking those dependencies for your library end users. this hides potential incompatibilities in the library development process. i.e. if library L requires dependency D version ~1.1, and locks to 1.1.0, having a composer.lock won't prevent an end user developing application A, requiring L, to obtain D version 1.2, but it will prevent your developers from obtaining it. that means that library end user could end up with dependencies issues most likely before library developers.
Section 5.1.5 Uniform Interface. Fielding calls the Uniform interface, "The central feature that distinguishes the REST architectural style from other network-based styles." At the end of the section he says "In order to obtain a uniform interface, multiple architectural constraints are needed to guide the behavior of components. REST is defined by four interface constraints: identification of resources; manipulation of resources through representations; self-descriptive messages; and, hypermedia as the engine of application state." Given your example, it's pretty clear you don't understand the full benefits of HATEOAS and that's probably because you haven't had the chance to work with a well designed REST API. 
&gt; Most of what I have learnt is self taught. I have studied modern php concepts, OOP principles, SOLID Principles, PSR's, and I have created a few applications. I will add in there testing (PHPUnit, Behat, etc.), MVC, basic SQL and basic front-end technologies and you can land any junior position. Everything else you will be able to learn on that position, if you are lucky you may land a job that uses current/popular technologies. Good luck!
I think always/never commit really depends on how you test/deploy. Before deploying, I always run a full test suite - including functional/integration tests - which indirectly tests my dependencies as well. I then **rsync** the files over to the production server. This ensures that regardless of the version installed, dependencies are properly tests before being put in to production. In this case, I see little to no benefit for checking in the lock file.
&gt; getting "surprise" versions while working on a separate issue is bad for open source, your contributer is now not sure if he broke it or something else did. well, arguably it's even worse if the ones who get surprise versions are the library end users: all they see is your library not working properly, and most of them won't have a clue that the problem has been introduced by third party dependencies, their not supposed to care about those at all, they didn't even require them, YOU (library mantainer) did ;) at least library contributors supposedly know where to put their hands on, and have all the interest to report a problem to their upstream dependency providers if that's the case; an end user most likely won't even bother to report the issue to you, library owner, in the first place.
end users only get new versions when they deliberately do composer update, this is why we run composer update at specific moments and run our tests. Notice i'm not saying you should not run tests to ensure library updates are compatible. I'm saying that not having a composer.lock does not give you this and is not the recommended way of doing this. Not having the composer.lock file gives you chaos, testing new versions is a side effect of it, and it only happens if you are actively testing/coding and doing CI. If you are not it only adds a new variable to anyone contributing. Just because someone is submitting a bugfix does not mean they will, or care for, fixing other issues your library has.
What do you mean by complexity? If you imply that the application features a single consistent set of resources, then you've just agreed with me. Because I agree that hyperlinks between loosely coupled resources are good. But being forced to pollute an initially consistent set of structured resources with inner hyperlinks, that's too much. My opinion is that hierarchical URL forging is 100% equivalent without the bloat, like in my /path/to/photo ==&gt; /path/to/photo/icon example. * need to move things? (mistakes/cdn/sub-services). Use permanent redirection, like sites do with pages. Relay on the client ability on remembering redirection so to limit bandwidth usage. * want to skip documentation? don't explore a messy graph of hyperlinks. just read the source of a working client. Much more informative. As a matter of fact, browsing an API is quite useless. It reminds me SNMP and how telecom people used to think SNMP was supposed to be simple. SNMP is a protocol which allow to get/set values in a tree-like structure of nested-objects and also to "walk" (browse) the whole tree. Is that enough to let developers code SNMP clients? No. Is provinding the tree schema (ASN.1) could help? not so much. Why? Because most of the time, available content/actions dynamically appears or disappears depending on a bunch of things in a large context. Only a true documentation with sequence charts can tell how to use the API. Contrary to what HATEOAS supporters claim, a browsable graph of hyperlinks isn't equivalent to an interface contract or at least the source code of a reference client. So I disagree it solves relevant problems. It's only toying. It doesn't worse the wasted bandwidth/ressource/CPU/RAM/human-time it leads to. Just look at famous REST API like [this one](http://pubs.vmware.com/vcloud-api-1-5/api_prog/GUID-F994A1B9-DB91-4223-9E45-6BFA9B6231AF.html). Can we at least agree the resulting protocol is extremely bloated? (the xml dump are summarized in this doc because real responses body are much longer and unreadable) 
Why my example is wrong? Also I worked with this API during a few months http://pubs.vmware.com/vcloud-api-1-5/welcome/welcome.html ; it is known to be a well designed REST API. I only see bloat.
No, the only reason it's considered a number is because 0 is followed by e (exponential). If it was any other letter this would not happen. To many people it's not clear that the "e" is a exponent declarator
I have some level of understanding of most those but the problem is in learning testing ie PHPUnit, Behat etc. For some reason I just cant get to focus on learning that. I recently started learning testing and I will keep on learning till I get it right. Thanks for the pointers.
&lt;Customer explains the spec that was sent and what he needs in a lot of detail&gt; Developer in India: We are develop your application to satisfy all your needs. Do not worry sir!
You could have sane type coercion, and not the bat-shit crazy type coercion. If both variables are strings, compare them as strings, there is nothing to coerce.
That *seems* to make sense, but falls down quickly. In PHP, strings, numbers and numeric strings are supposed to act the same. If `1 == "1.0"` and `"1" == 1.0` yet `"1" != "1.0"` it would be a problem.
&gt;In PHP, strings, numbers and numeric strings are supposed to act the same. And that is insane too. Javascript has weak typing, and it is not nearly as bad as PHP.
I don't really have an answer to that. I pointed out some ways I have found them to be helpful, but if it doesn't work for you - feel free to not use them. There is a pretty small overhead I think and for the apis I have built [the benefits](http://soabits.blogspot.no/2013/12/selling-benefits-of-hypermedia.html) have usually outweighed the drawbacks, but not all apis have the same requirements.
http://en.wikipedia.org/wiki/Directory_traversal_attack 
So what language are you using out of curiosity and why hang out here with the dregs as you see them?
&gt; You can upgrade to 5.4 and start work on moving away from the deprecated features **if management grants you the hours to do so**. FTFY. I agree with what you say, but when a codebase suddenly starts generating a bunch of NOTICEs, you often run into "well, it's not really broken NOW so just ignore it" from above. You and I agree that that's not the best way to handle it, but try convincing management (and the customers)... 
Thx, this helps explain
Wish I could
pity. if that's your codebase, damn, i don't know what to say
Since you are already familiar with Laravel use that to get into your PHPUnit testing. Do some searches on unit testing in Laravel.
I wouldn't worry about being experienced with testing. As a junior dev I would list unit testing as a "nice to have", but not a requirement. Ideally if you can at least write one or two very basic tests, even if they don't have any useful applications, that will be enough to show you have a basic understanding of what a unit test is. As huebro mentioned, some understanding of MVC or more generally how an applications can be structured will definitely help you. Looking at your post I think you will be ready to take on a junior dev role - and will actually be better than most people applying.
How can these people not see the need to update their code? It's not as if this is a topic reserved for programmers with an in-depth knowledge of the language, help is everywhere.
Even though you have the skills and know-how to make the changes, there are still many novice PHP developers, who don't understand this nor have they even heard of the issue yet.
My bad, I was trying to think of a more suitable word for it, I guess "files" would be more precise. It's still ridiculous though, the change isn't that difficult.
Convert your errors to exceptions with an error handling function...oops, looks like someone doesn't know what the fuck they're talking about
You're a turd, a troll, or both. What is clear is that you're a novice who has no idea what you're talking about and running around espousing opinions you've read in the oft incorrect lolphp sub
deprecated
It varies from job to job obviously but I would say that having a basic understanding of the principles of PHP and a willingness to learn. I think if you were to go into an interview for a junior position and display that, while you're not particularly experienced, you are up to date with modern concepts, you would be considered. An important thing is that, while you may be more comfortable using a particular framework, you don't rely on that framework and would be willing to be dropped into another framework, or a custom PHP library. Learning about things like Composer and PHPUnit would be a big plus, too.
Someone with a good understanding of PHP could probably move to another language quite easily, but I fear that being a total prick is a little harder to overcome.
true, I have played around with fatfreephp an symfony2 before but I settled on laravel as it feels more "natural" to be. Because of it I have learnt alot about moderm php. I am willing to learn hey...it seems thats all I am doing these days. I have a bit of trouble grasping PHPUnit and testing but I am working hard on it. Thanks
This isn't the right venue for this question as it doesn't have anything to do with PHP. Also, I doubt you'd find any consensus in this matter. 
Deprecated functionality leads to its depreciation :)
You could still just use Angular. It's not like 1.x is going to disappear off the face of the earth any faster than it would have. Knockout is a good one, too.
Meteor 1.0 just came out as well, but it seems to be a full stack.
I'm looking for responses from specifically the php community. Also I'm not necessarily looking for consensus, only discussion.
It would be interesting to build a tool to scan GitHub and try to find which of those have SQL problems - although of course that's not limited to mysql_ functions. It's perfectly possible to use PDO and mysqli and build something insecure. 
Meteor is server side, pretty happy with my PHP stack.
I don't think so. The link is the important bit, but allowing something to be embedded is fine.
This really is the most important thing. If you want to learn you're ready.
&gt; It just makes you come across smug and sound elitist. Only just spotted this bit. How about fuck off. As I said to you on twitter, if you were clicking through a file system and you clicked into "Users" then saw a folder called "delete", you wouldnt expect clicking that folder to delete a user. This is what your URI resource says to people. Even adding a v1/ prefix and a v2/ prefix is widely agreed to break the idea of REST because it moves resources to a new location. A location of an item should never change. Ever. You are wrong and you're mad at me for not accepting your wrongness. I can't do that, but that doesn't make me an elitist. 
Because I respect the developers in it, I think they're pragmatic.
I think you are a little over zealous. This super-secret "feature" is documented in the official PHP documentation. There isn't anyone to blame but the programmers that got bit in the ass by the feature for not reading the docs. I do, however, wish strings were compared as strings before any type-coercing was performed.
If it doesn't affect then what is the reason of commiting it?
deprecated functions eventually become invalid/non-existent features down the line. a function with depreciated value/use doesn't imply eventual invalidity :)
A junior dev potential has to: * Be willing to learn (which is different from SAYING they're willing to learn) * Have an interest in becoming a programmer (which is *literally all* a college degree tells me) * Pass the "could I sit next to this guy all day?" test. I can turn somebody who passes those three tests into a programmer.
A related question is: Is the company ready for a junior developer? In many ways it's more important. A junior needs help and time should be put aside to help them grow. If a company can't do this then they shouldn't be hiring a junior.
* Pass the "could I sit next to this guy all day?" test. How does this apply to say a Remote position. How would you test this. I have thought about it and I would most likely gain more from a remote job. Most companies here do Joomla, Drupal and Wordpress work. I am running away from that. Is it even possible to get a junior remote job?
I have seen a lot of companies jumping into the EmberJS boat. I dont have a lot of experience with it though but from what I have read and heard its great and stable. 
Do you always develop with `error_reporting(0)`?
I'm hiring for a junior PHP dev (central Virginia area), so I'll share what I'm looking for: * A fundamental understanding of the request/response model of how a web browser works. You don't have to know the http spec, but I like to see that you know that http is stateless and the techniques to provide a stateful user experience via the session. * Know when a form should use GET or POST for its method, bonus if you know ways to prevent double submission of a form. * Given a server side or client side way to solve a problem, know some trade offs for both paths * Most importantly, exhibit a curiosity about how to build good software. What I really like is the x-factor of being able to listen to the stuff that users don't say because you often need to probe the user story to avoid building the wrong stuff. In my experience if I build just what they ask for then over half the time it will be wrong in the end. I'm not searching for someone who has prior experience building apps from napkin to capital-Production and maintained three versions of updates. I'm not looking for the person who lead a team of six developers or is a rock star. I hate job descriptions that seek out alpha level talent at entry level wages. That said, I've been really discouraged in my interviews with candidates. I ask them to tell me about a challenging programming task they overcame and almost all of them answer vaguely or fess up that they haven't really programmed much. If you can tell someone with enthusiasm about how you solved problems, learned new things and feel empowered to do greater things you are on the path to a great career in software.
I hear it's only suitable for SPA's tho...
OFC i do when writing random dream code in a textarea. Why would you not?!
I personally wouldn't hire a remote junior. Juniors need a whole lot of hand-holding, that's just part of their role. Every junior I've worked with where I couldn't walk to their desk and sit with them eyeball to eyeball, it hasn't gone well. "Could I sit next to this guy" includes all the gut-feel intangibles of hiring somebody. Will their personality fit with the team? How's their attitude? Can we chat about common interests at the water cooler? Do they smell? I guess that last one is no biggie if the position is remote...
That's the kind of detail I am looking for, thanks for sharing. Too bad you are looking for someone in the central Virginia area. Only if you would consider remote **hint** lol
React + hiphop, because nobody has mentioned it yet.
So why bother? All you did was introduce bugs, no readability improvement at all and the massive vulnerability is still there.
Do you use that stack on your company's project?
&gt; I'm not entirely sure what we gain from weak typing other than less work for people who are too lazy to understand how data types work and therefore want to pretend everything is a string..
Reformatted it's much more readable and easy to understand, but no less scary. Whoever wrote this is either highly incompetent, or is purposely inserting security holes. &lt;?php if(!isset($_GET['p'])) include 'pages/home/home.php'; else{ if(isset($_GET['l']) &amp;&amp; $_GET['l'] != '') $page = $_GET['p'] . '/' . $_GET['l'] . '.php'; elseif(isset($_GET['p']) &amp;&amp; $_GET['p'] != '') $page = $_GET['p'] . '/' . $_GET['p'] . '.php'; include 'pages/' . $page; } ?&gt;
Which I believe can be simplified down to: &lt;?php if(empty($_GET['p'])) include 'pages/home/home.php'; else{ if(!empty($_GET['l'])) $page = $_GET['p'] . '/' . $_GET['l'] . '.php'; elseif(!empty($_GET['p'])) $page = $_GET['p'] . '/' . $_GET['p'] . '.php'; include 'pages/' . $page; } ?&gt; Very WTF territory here.
Sometimes, the 'company' has its part in the code too. If you ask a guy that just went out of school to code something, without any code review from anyone... well, you can get that kind of code. Of course, if it was produced by a guy with 10 years of experience, it's another story.
Would you still use it if you were starting a large new project?
This. My job is 90% research and learning as I go. Problems change, tools change, technology changes, you have to be willing to roll with it all and keep learning. When I interview junior dev candidates, I will gladly hire a self-made dev over someone with a CS degree if they demonstrate that they are good researchers and can work through problems. If I have to send you a link from "Let me Google That For You", you'll be shown the door.
~~The problem with replacing isset with empty is that you will get notices if $_GET['p'] is not set.~~ No it doesn't Still...I hate notices. Every PHP notice kills a kitten.
Yes, that breaks weak typing. I refer you to my original question.
This is not true. Empty works the same as isset except anything falsey (0, null, '') returns false as well. http://php.net/manual/en/function.empty.php
I agree, which is also apparent when there are very few weakly typed languages. 
And this is why people hate PHP devs. 
What could possibly go wrong...
your gonna get hacked
 If ($_GET['ImAhAxx0r'] = 'TRUE'){ giveAccessToAllMyTHings(); }
I'm sticking with Laravel + Angular 1.3. It's great. The main features I love about Angular are: * very simple two-way data binding * directives * mandatory DI, * "declarative" application design (a.k.a no need to juggle selector patterns throughout the app) Angular 2.0 is a ways off yet, we're talking about *at least* a year, during which the project's trajectory will likely continue to change. Also, nobody is forcing me to upgrade to Angular 2.0. 2 year EOL on Angular 1.3 doesn't concern me; it's just a .js file, not an operating system. I'll judge Angular 2.0 when it's ready for release. 
This sounds to me as if it could be a [XY problem](http://meta.stackexchange.com/questions/66377/what-is-the-xy-problem). What's the underlying problem you are trying to solve? 
I think you're underestimating the complexity of the implementation of large application front-ends, even those that aren't built as "javaScript apps" (which is a thing now I guess).
I guess you're looking for this: http://php.net/manual/en/function.imagefilltoborder.php
Not enough *faces*^from^the^french^façade
But I can't read page `0.php` in your second version. It's similar, but not the same.
Nope. `empty()` does not return notices on unset elements or variables. That is one of the beauties about it.
Error messages slow down your server (in this case posible undefined variables), and may keep increazing the size of that 10GB error.log file, if the server is configured to save the errors instead of showing them.
I stand corrected. I have no idea why I thought empty would return a notice if the variable wasn't set.
...OP could accidentally give away where this code is residing...?
OK but that's still no reason not to upgrade, the app still works. Remember that this thread is about people still on older PHP versions. Upgrading from PHP 5.1 to 5.6+ is very unlikely to cause *errors*. Let's say PHP 7 removes the mysql extension, you could still keep migrating to the latest 5.x version. When you hear that v7 is going to remove mysql you start working on switching to mysqli/PDO, since upgrading here *will* break your app. &gt; but try convincing management Or don't tell management and make it part of regular refactoring; gradually refactor over the next year.
The original code used `isset()` to check for the existence of the two keys in `$_GET` before attempting to reference them, whereas your code will throw a notice if either key isn't set.
FYI,`isset()` will also return false for null. For example: $derp = ['a' =&gt; null]; var_dump(isset($derp['a'])); Would output `bool(false)`
That's correct, and hopefully everyone is rotating their logs at an appropriate rate. Sure you should use filter_input instead of $_GET but I wasn't trying to be picky with the OP. The replacement of isset and an empty string check with empty() made things simpler to read which was worth showing. But then, maybe some are not aware of filter_input... so good on you for hinting at it.
The #1 skill I expect from a junior developer is [the ability to research](http://www.reddit.com/r/PHP/search?q=junior&amp;restrict_sr=on&amp;sort=relevance&amp;t=all).
Hah fair enough! :) That's certainly true, I can name a few others who've been worse to work with. At least the ModWest guys are nice to deal with, can't complain too much about that. Just wish they'd offer better server-side options.
I don't quite get why you are talking about the "real world" vs HATEOAS. I don't need real world examples since I have actually built HATEOAS APIs that helped solve real world problems. And I don't understand why you refuse to believe that other people find the exploitability of urls useful - I do, and the teams I have worked with do. As documentation and when debugging. I agree that it's very hard to build an automated self adapting HATEOAS client, that's why I just focused on the benefits of using full resource links. You don't get full decoupling, but at least the client handles (semantic) resource names instead of having to keep track of the API url structure. You are right that there would be a lot of requests if the clients navigated through the API to find all resources. I usually provide a few shortcuts, like a (cacheable) list of resource types at the starting point and links to grandparents and/or grandchildren where needed. With a HATEOAS API you get a lot of benefits with the drawback of slightly more verbose responses. It also has the benefit of a few [documented media types](http://sookocheff.com/posts/2014-03-11-on-choosing-a-hypermedia-format/) with [tools](https://github.com/mikekelly/hal_specification/wiki/Libraries) that make creating and consuming resources easier.
True, and that's kind of confusing behavior. I find empty to be more useful than isset a lot of the time because of the empty string case. $arr = ['a' =&gt; '']; isset($arr['a']); // true empty($arr['a']); // true 
Except your entire post is arguing the opposite (that the use of mysql is not depreciating).
It's not 126 projects. 126 repositories have the words "mysql" and "query" in their title/description, nothing to do with code.
&gt; Are my expectations to high? No. Nobody else is going to look out for your career, only you are. And your career is how you build a stable financial future for yourself. So your expectations are perfectly reasonable. &gt; Is this just how it is in the real world? Yes, like anything in life, quality and quantity are inversely proportional. For every solid agency to work for, there are 10 that are "meh" at best. You have to spend time networking and getting to know people. Go to local developer meetups / groups and just meet people and talk with them. You can get a feel for which companies are good to work for, and which ones aren't. &gt; I feel like I'm only going to pick up his bad practices... How much freedom do you have to do your own stuff? Do you HAVE to do it his way? 
Is there a way to get github to return only repositories where the code matches? Maybe an API way to get a list of all files?
I think this is so gonna get hack-raped
Very mature! But then, I'd expected that from you. There's no concept of folders in urls. That additional meaning that you add. Furthermore, there's no folders in the resource identifier from the dissertation. The fact that that meaning is widely applied to HTTP-based RESTful services, and it's widely accepted as a best practice, does not imply that changing the meaning of the URL makes it less restful. The sentiment that you're repeating is widely copied in books and otherwise though, do you base your opinion on that, or on the original document? Back to your original statement: content-negotiation is _not_ a requirement. That's another requirement you added so you can discern what you call restful and what you don't call restful, but has no basis in truth. I'm not mad, but I stand by the fact that you have very little to gain by pointing out what's RESTful and what not. I do think it's elitist. If were talking about what anyone _should do_, we'd have a very different conversation and probably fully agree with each other.
Computer science example: MVC. How that architecture and term is used today is very different from how it worked in the smalltalk days.
You missed the point by such a stretch I don't even know where to start. Read the dissertation. The url is not the main point of it, it's a very small aspect of it. Important points are transfer of resource state, statelessness, idempotence and addressability. The 'internet as a whole' does not do that correctly. The read-only internet perhaps does, but that's just a subset of what REST is. 
How does one get the chance to prove that can pass the 3 tests? I want to become a programmer but I've spent my whole adult life in a different industry and I don't know how to get that first shot.
Even if the URI is not the HTTP URL the URI must not be mixed with the actual action. In the example Phil used ( /foo/X/delete ) the foo/X is the URI while /delete is the action and you just shouldn't mix them both in one place. So if you want to have URI in the HTTP body or something like that it's ok, but you shouldn't mix the actions into that URI,
OOP and SOLID are great, but I'd add SQL fundamentals to the list. If you can understand and use basic SELECT/UPDATE/INSERT/DELETE and JOIN queries, you should be good, but I'd be hesitant to hire a junior PHP developer that wasn't familiar with those SQL concepts.
While I appreciate your willingness to share...that php code is terrible. Also, why is half of it in gists, the other half not?
You called me names, so I told you to fuck off. That's how that works. Martin Fowler has my back here, since 2010. http://martinfowler.com/articles/richardsonMaturityModel.html I'm not saying anything controversial or even debatable. I'm saying that you can make an API but unless its actually a REST API then maybe don't call it that. People call it REST just to be cool, and that's just not what it is. You don't mind if people misuse the term, and I do. It's not even meant to be a big fight, just a quick "Hey, keep this in mind." If its one guy on Reddit v Martin Fowler and a shitload of well respected books on the topic, then I'll be taking the latter side rather confidently. 
I use Angular in the backend. I hate it. On the frontend, I went from jQuery -&gt; Backbone -&gt; React. We're sticking with React and refactoring the whole site to it. It's amazing. My difficulty was with integrating different data source (ajax + sockets) and keeping a sane state. With react, it's honestly a piece of cake. Let me know if you want to see the site. 
Supporting articles. http://restcookbook.com/Miscellaneous/richardsonmaturitymodel/ http://martinfowler.com/articles/richardsonMaturityModel.html http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven I like the last one, by Roy Fielding, who says that unless its hypertext driven then it's not a REST API. That means links, and various other HATEOAS concepts. Without that, its just an API. Old conversation. Nothing surprising. This was posted purely as a reminder.
I'm 100% with you that you _should not_ do that. But I can't find anything in the dissertation that tells me you _must not_ do that. And that's my main point. There's lots of things that people call RESTful that aren't, and in the case of /user/philsturgeon and many others, there's also lots of instances of people making claims about how a service _must_ behave to call it RESTful that are wrong. I agree that mixing the action in the url is not a good idea at all... but piping everything through a RPC service (as long as that RPC service *just transfers state, is idempotent, etc), this RPC service can still behave as a RESTful service and can be called RESTful. I think 'putting the action in the url' was a bit of a poor example, because I realize I'm breaking some well-established principals of good RESTful / HTTP design.
Well it's not the first time you told me to fuck off, so it's not a shocker. Disrespect is your thing, so that's what you get. Your first point was about content-negotation. We can go back to that. What if I only use 1 media type and I'm on my first version of my API / mediatypes. I have no need for content-negotation yet. Why in your opinion can I not call my API RESTful point?
It was this point in the conversation that I should have just linked you to [this article by Roy Fielding](http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven) which agrees with my above comment 100%.
[Even with strcmp you have to be careful](http://danuxx.blogspot.com/2013/03/unauthorized-access-bypassing-php-strcmp.html). Use === everywhere, == is broken.
And you'll probably keep finding it more useful until you run across one of the zero cases, at which point you'll tear out your hair and never use it again.
hahaha.... https://www.*****.com ...ooops I think I gave it away
I'm taking a different approach on this one. I'd say, for a junior development position, all I'd care about is a demonstrated ability to program in some language at a decent level (program flow, loops, ability to solve dinky fizzbuzz type whiteboard problems, general idea on why architecture matters, basic SQL). When I took my "junior web developer" role 12 yrs ago, all I knew was C and win32api programming, which had nothing to do with the web (although I did previously write CGI apps with CGIC and knew enough HTML 3/4 to get by, which is likely what helped land me the job). I learned PHP in a few days. You can too. Anyone saying you need to understand OOP, design patterns, version control, frameworks, HTML5/CSS/JS inside and out, complex database techniques, etc. is describing an intermediate to senior developer. /guy who hires people.
This is from a company that has "experience" developing websites
I would either use multiple images or SVG and JS. It seems weird to use PHP for this.
Im not really a fan of either. It just creates a lot of ambiguity and extra validation in any meaningful application. You dont really ever know what is being passed into your functions. You can only assume and hope you're right, or write a crap ton of validation/conversion code everywhere. I would like to see a php where everything is statically typed, unless you need otherwise. Then in those rare cases you can pass anything and validate. As opposed to having to validate everything BUT those rare cases.. I like how php does type hinting for classes, but why they don't allow it for scalar types is totally beyond me, since that would literally give everyone what they want.
Thanks for taking the time to actually listen to my response ;) I agree that RPC _can_ be much broader, so to make an RPC service compliant with the REST architecture, there would have to be several really strict rules in how this RPC service may behave. For instance, the RPC service may only define 4 methods: 1. create 2. update 3. read 4. delete This RPC service would also have to ensure idempotence, and perhaps every first 'argument' to every function call must be something that looks like a URI. Only when all those conditions and all the others from the dissertation are satisfied, only then you could really claim that an RPC service is RESTful. After all, HTTP itself is also a form of RPC. There's a method, there's arguments (url, header and body) and there's a response. Only when you strictly follow certain rules of rest, you can call a HTTP service RESTful. I agrue that RESTfulness can be achieved using other transports and tunnels, even if that tunnel is counter-intuitive and inelegant. To put it differently, if I can accurately pipe a fully RESTful HTTP service through something that on the service doesn't look restful, that service can still be RESTful, even if I choose to abuse HTTP methods, urls and anything else I can get my hands on.
&gt;Im not really a fan of either. It just creates a lot of ambiguity and extra validation in any meaningful application. I think that depends. If you are writing scripts or for the web, you almost always know what type of data your environment is providing you. I love dynamic and static typing equally, I think they both have their place, but I see no place for weak typing (type coercion) at all.
True =) Now I'm firmly under the impression that Phil really misunderstood your point =)) He does that sometimes =\
I don't think I am. I have done plenty of large applications, and don't get me wrong, I understand the value of a good library/small framework that offers tools that supplement existing standards to save time. Most of theses frameworks though are less about improving productivity and more about making something new "just because". If a developer puts even a little effort into properly structuring their code, and even just remotely understanding what they are doing, rather than just slapping code everywhere verbatim from bad samples out of tutorials they googled, then most of these "frameworks" wouldn't exist.
Well, I posted another solution to the security issues. filter_input works too.
If you're using Imagick you can use the function [Imagick::floodFillPaintImage](http://php.net/manual/en/imagick.floodfillpaintimage.php) An online example of it in action is here: http://phpimagick.com/Imagick/floodFillPaintImage
Content negotiation, to me, encompasses the versioning of specific resources. If you're not specifying the representations of requests and allowing for a response with a different representation then you are ignoring the RE of REST. This whole thing is about you wanting to call your API a REST API when it isn't. Why is it so important for you to do that? Not being REST is fine, you just use a different name. HTTP API is just fine. _Sidenote: I presume you deserved it last time. I'm rude in response to rudeness. I think diving into a conversation calling somebody "smug" and "elitist" should expect a reply devoid of unicorns and rainbows._
Hey, I would like to see the site. :)