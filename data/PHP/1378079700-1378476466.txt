http://www.reddit.com/r/PHP/comments/1lipil/on_being_a_better_developer/cbzvyu8
Used netbeans for about 2 years, then switched to PHPStorm and never looked back. I can only recommend checking it out.
Netbeans 7.4 nightly. Works great, has SCSS support now. The beta have on their site breaks when background scanning large projects, but the nightly works great! (at least the build I'm using does). 
https://www.google.com/search?q=site%3Awww.reddit.com%2Fr%2FPHP%2F+best+php+ide this will help you. this questions gets asked nearly every day.
So on the weekend I started actually coding my project. The goal is a place for digital artists of all sorts to trade resources, collaborate together or just show the process involved in what they're working on. The product draws some inspiration from reddit and social networks but it's not a place where you want thousands of followers it's about sharing and creating. Right now I'm aiming it at music (I make hip hop) and I'm building a smart tagging system that will grow and mold themselves organically. So if a user records a drum loops they can put that up and other people can use it and expand on it and reply back to it kind of thing. Another use case could be a user that makes an instrumental and puts it up as "free to use but give me credit" and rappers can use it and reference the producer. Also I'd like to put in a feedback system that forces the user to give feedback before receiving feedback. The quality of the feedback might go down a little but it's better than no feedback. Eventually I'll open it up into all disciplines of digital creativity. So photoshop, web design, music, etc. **What are the tools I've selected?** So far laravel and pure (and less) css. **What have I built?** I've got laravel running, user login and signup and the index page. I've built the overall frame design for the css and selected the color and font scheme. I've also planned most of the core schema for the database, I'm still filling out things like messages and what not. **What's next?** I start working on implementing the schema and digging into laravel (yummy). **The time frame?** I'm thinking it would take a month or so to get an alpha out so I'm hoping for a hard launch before 2014. Even if it fails I'm still acquiring skills, so it's worth my time. 
Yeah, it's definitely a breath of fresh air from my last job where my boss insisted that we do fully custom ecommerce but never let us spend any time on the software, so we kept giving client after client the same shitty, buggy codebase. -.-
i also have it. but if you are trying to learn design patterns it is not the book i recommend reading.
You couldn't find anything on Google about PHP, Ruby or Python? Or just not any comparisons? From googling 'php vs python vs ruby', the top result is the handy infographic (though from 2011): https://www.udemy.com/blog/modern-language-wars/ And for something more involved and a peek at code, try [The same app 4 times: PHP vs Python vs Ruby vs Clojure](http://adambard.com/blog/PHP-ruby-python-clojure-webapps-by-example/) (though the PHP example is crappy).
Doctrine models?
It's actually in the documentation for `array_merge`: &gt; If you want to append array elements from the second array to the first array while not overwriting the elements from the first array and not re-indexing, use the + array union operator: &lt;?php $array1 = array(0 =&gt; 'zero_a', 2 =&gt; 'two_a', 3 =&gt; 'three_a'); $array2 = array(1 =&gt; 'one_b', 3 =&gt; 'three_b', 4 =&gt; 'four_b'); $result = $array1 + $array2; var_dump($result); ?&gt; &gt; The keys from the first array will be preserved. If an array key exists in both arrays, then the element from the first array will be used and the matching key's element from the second array will be ignored. 
Also working on an eLearning website - fun challenges in this industry for sure!
I have a bunch of different projects I am working on. **Free Lance Business** I have been recreating my [Child Care Share](http://www.childcareshare.ca) website to transform it into something new, more user friendly and make it easier to market. Along with that I have been playing around and trying to create new small projects to sell on the web and gain some more local clients. **Full Time Job** At my full time job I am designing a new Checkout system for [Online Giving](https://www.givetoqueens.ca), which I am hoping to retake over again as a giant project. I have also been developing internal tools that our staff use every day to help them with their jobs, as well as some other e-commerce sites. **What's New** Trying to upgrade a University into today's standards with so much push back.... I don't think that is new but that is what you face day in and day out with all the different departments, rules, etc (yet the rule makers don't follow their own rules...) Nothing really new in my tech world, looking at a few new framework in PHP and possibly learning some Ruby since I have been doing PHP since 2003.
&gt;that ~~a~~ little knowledge FTFY
&gt; False. The splat operation is nothing more than that and can be used outside of function calling. Nothing more than what? The splat operator is converting arguments to an array. It has no applicability outside of function calling. You are the one that seems confused. &gt; True. However list() functionality can be extended to do exactly this. I'm not sure how overloading an existing keyword for more functionality is clearer than just creating a new operator. &gt; I rather not write nor maintain such non-explicit code because it does not help anyone understand what's happening. The code is not self-documenting and becomes a debugging hell very quickly. I don't understand how that is non-explicit? It says exactly what it does. What is not-explicit about it?
Yeah, I've basically been given a ton of stuff to read and left alone for the most part. I want to start diving into actual projects! The only thing that kind of irks me is how slow the vanilla installation is. I haven't really looked deeply into optimization techniques but page load times of 10+ seconds any time I save anything in the admin is a bit aggravating when you're trying to learn everything. 
Yeah, in production you're going to have (or should have) a good amount of memory available on your box and you're going to cache the hell out of everything. Other stuff like using the flat tables instead of the EAV table helps with performance too. Sure your coworkers will help a lot in that regard so good luck and have fun. Also, congrats on getting out of a shitty job and starting a new programming adventure.
Thank you! I finally had told myself I had enough, updated my resume and started being more active on github and landed a new job in a matter of weeks :) I got really lucky, too, considering that they still hired me knowing I hadn't worked with Magento before. 
&gt;@work: a new b2b site for independant artists allowing them to connect, collaborate, create and promote Facebook? Or Deviantart?
I work at DTSS, not DI.
I just thought of something fairly important that isn't mentioned in the RFC but should be explicit: How does this handle named parameters / keyword args? Although we don't yet have named parameters and may never have it, this RFC should at least allow for the possibility. The current implementation likely ignores keys entirely but then that makes this operator useless for setting named parameters. If included with named parameters, I would think this should map string keys to the appropriate matching argument. Some thought to how this should work should be taken into consideration. 
How many were there? Got any plans to build more on top of it?
At work - Custom upload / download FTP &amp; "Send a File" replacement using CodeIgniter as the PHP framework, allot of Javascript on the front end. Also working on a custom employee / inventory / asset management system that is a Joomla component with plug-in features. At home I am working on a financial simulator targeted at individuals and couples mostly. It is also a general ledger but the primary focus is on simulating future bank balances at first by telling the system what you are doing with your money but there is also another algorithm that mines your general ledger and makes assumptions based on your actual spending. I have been working on variations of this for a while but finally making a hard run at it again.
Hey, great posting! I know this is very interesting topic, however I really like your theme style and design. 
Sym**f**ony is hard to learn from scratch. It's not even a framework per se, it's a set of components. It's hard to understand if you don't know programming patterns. Out of the box, it requires a lot of boilerplate. But when you do learn to use it, there's simply no competitor on the market in terms of features. That said, it probably is an overkill for small - medium sized projects. Laravel is easy to learn, does a lot of things for you and is probably great at small - medium projects. I think the question isn't which one is better, it's what you &amp; your team need and can afford, what niche are you trying to take. A great example of what you could/would use Symfony for is the fact that [half the core of Laravel is on top of Symfony](https://github.com/laravel/framework/blob/master/composer.json#L23-L35). Symfony is also the framework of choice for developers of Twig, Doctrine, Behat, Composer, phpspec, Assetic &amp; many more awesome PHP tools you've probably used.
Currently working on a content platform that will fix the problems I am experiencing with wordpress. Its a multisite solution that includes built in reports and shops that seamlessly integrates with your content and vice versa. I building it on ZF2 as a RESTful resource so I can build the front using angularjs.
Still confused by the rfcs and reused notation aren't you? Look. It's perfectly fine to use the splat operator to initialize an array. $x = [ list($arr) ]; It is possible to call a non-variadic function like strpos: strpos(list($strposargs)); So using the triple dot notation is not in any way logical. You don't use the + sign to subtract right? Then why the "collecting" dots (you call it packing), to also splat/separate (you call this unpacking)?
If the language feature is not yet set in stone, why not change the implementation to prevent its usage to escalate to ugly code very quickly? That's my point here. If a new language feature must be used sparingly, otherwise your code becomes a mess, then why bother at all? Stick with array functions... At least those are explicit.
Sorry, sometimes I think in romanian when I'm writing in english so I make mistakes like these. You don't have to apologize. Being from another country it's not an excuse, especially when you have a blog in english :)
sentiment analysis of the twitter stream, some parts are not php but the majority is.
&gt; It's perfectly fine to use the splat operator to initialize an array. $x = [ list($arr) ]; Is it? Wouldn't that be equivalent to `$x = $arr`? Even if you came up with a more complex example, there are already plenty of functions and operators to manipulate arrays. PHP doesn't have a tuple-type. We need argument unpacking because there is no way to do that currently in PHP without `call_user_func_array()`. The same operator is used in Python for both packing and unpacking arguments, why is not logical to use the same operator in PHP? The only difference is the operator itself `...` vs. `*`. 
You really think: call_user_func_array([$db, 'query'], array_merge(array($query), $params)); Is less messy than: $db-&gt;query($query, ...$params); I'd argue the latter is both less messy and shows the intent much clearer than "sticking with array functions". 
&gt; DTSS *Disney Technology Solutions &amp; Services* for those who can't be bothered to Google it :)
Create a project and upload images to see what has changed. So your clients can see whats up (3 different comparisons are planned). view a demo at https://itrulia.fwd.wf/login if you get an 404 just try again, working on a laravel plugin so forwardin tunnels works great
I don't know of any myself, but I'd be happy to contribute if you were to build your own.
This is definitely the way to go if objects will have a large amount of attributes. It's how Magento does it and it's one of the things it does really well IMO.
Even for solo projects, git is wonderful. It makes everything so much easier.
me too...
I am working on a site that allows customer to create online e-commerce web shops. Eg very much like Shopify. Currently been working on the project for about 4 months. Close to full time. Project is built with PHP 5.3 / 5.4. I use Silex PHP from the developer of Symphony for all the routing (code is very minimal, generally a new file for each logical function, eg upload, login, product, page, instagram). The database is an ORM called RedBeanPHP, I have used this for several projects, but what I love about it is that you don't have create any tables or columns. RedBean will create the objects (tables and properties) as needed. Absolutely love it for rapid development. People might say this is rubbish, but to the contrary it is absolutely fantastic at the speed I can build things. For templating I could have used Twig but I have stuck with Smarty PHP (which is old as this hills, but is super fast as templates are compiled and are automatically cached as required). My absolute favourite feature is the ability for a user to export their shop theme/design to dropbox. Auth your dropbox account, click export and all the files appear in your dropbox. 1. Since all the template files are in smarty, so you cannot really see the visual layout. 2. In php 5.4 you can create your own php server via the command line. 3. I was able to configure my application to run the smarty files by seeing if the smarty lib exists, if not it downloads it to dropbox. 4. Since all the smarty files require product data to power it, I can actually load the templates with live data from their online site via JSON. 5. The json is download for each page, converted back to native objects and assigned to the page. 6. Since I have to use PHP 5.4 for the self hosting feature, I compiled php 5.4 as a static binary that can be downloaded and executed if the users php version is 5.3 or less. (only on Mac) 7. Now designers can simply run the system by typing in "php run.php" all the above magic happens, and PHP can even open the web browser to the correct URL. So the designer can see the a fully working copy of the live site, running off their local machine with real data. For most of the interactivity I use jquery and Ajax calls with Twitter Bootstrap and I am having a lot of fun using the Consistant.js framework when working with forms/models/objects. https://github.com/karlvr/consistent.js If you are interested you can see the beta landing page here http://shopshop.io and a demo site. http://demo.shopshop.io Thanks, John.
...No. No, you can't.
3 years of straight Magento development here mate, I'm on my 6th shop now and continous maintenance on the other 5. It's actually pretty intuitive once you get over the seemingly complicated architecture; the observer pattern is nice to work with and understanding the whole thing made me a much better programmer overall. I'd choose this over WordPress any day, to me that's the worst possible platform to have to work with.
It is quite a beast, but I have split it up into very manageable parts. Content submission and rendering first so I can port my wordpress content and it could start going live, also to regression test the rendering etc. Then the fluff will get added. 
I never did argue that the rfc is unnecessary. I'm arguing for a better, more explicit implementation.
When I can get motivated to work on my code. I like to bring new improvements to a cms I've been working on for a while. I'm currently converting it to an mvc design and adding a routing engine to make it easier to manage multiple websites that use the same code. I also have some business features I'd like to add for the people that use it, but I burn out after a while and i never get as much done as I'd like to. Edit: I've tried using frameworks but I usually find the code awkward to work with. I don't understand all the bits and pieces that make it tick and it becomes an unpleasant experience for me. I toy around with code to see why it's doing what it does then I look up more info about what I'm trying to do (routing for example) and then write my own implementation that works with my code in a way I understand. (I also spent a ton of time improving perfect on my cms and I find it works a ton faster) :D
While it might not be embeddable from the start, I wonder if [Pico](http://pico.dev7studios.com/) might be worth looking into? It's small enough to understand quickly so you can identify your hooks and get hacking. -- edit : Fixed link - thanks for the FTFY
Hey mate. I've had a glancing relationship with Magento years ago. Not much. Templating, multi store, and one custom extension for talking to our primary payment gateway in New Zealand. I'll say two things from a combination of that experience and what I know now: 1. There will be times when you will say "What just took me 2 hours would take me 30mins if I was rolling my own". Particulary when it comes to template components. This went beyond Zend framework and was more design choices for Magento. It can seem very over-thought at times. But most of the time, there is rhyme to reason and it's just like learning any other system as designed by a vendor. 2. I was recently trying to get my ass to London. I put my CV on monster and I swear in 30mins time I had 3 long distance phone calls and 4 emails. All but 3 (off memory) were Magento focussed. I found the same when I had a brief look into the Australian market. As far as houses pumping out multiple ecommerce sites goes, especially in the UK, Magento experience is gold at present. To the point of visa assistance. (Which is rare for the UK). Get a couple of years in, build up a portfolio to show, and from being in the international market lately, it's one of the most stable PHP specialties opportunity-wise. It definitely trumped specific Framework experience from what I saw. Edit: If it matters. The UK roles were offering 50-70k Pound Stirling. I have 10 years PHP total. About 6 months with Magento 6 years ago. The latter being the reason most went cold after talking to me. Too rusty, and the visa situation added risk on top of that for them. Which is far enough on both counts.
Neither, it is not purely a social site. Nor is it only for visual artists.
Here's the thing I like about this post: Few developers at this stage of their careers have the balls to admit to this sort of thing. Most will simply resign themselves to the fact that their current role doesn't expose them to the things he/she sees other developers talk about and not really know the practical nature of. (unit testing, CI, even version control) It's a great attitude, and the author should bring up a digest version of this in their next interview. I'd definitely want someone like this on my team. Regardless of how that self-development progressed.
FTFY [Pico](http://pico.dev7studios.com/)
An order, payment and fulfillment system that works across multiple timezones. Lets people place orders, pay for them, plans in the orders to be delivered by bike messengers, and lets you pick the delivery time with 30 minute accuracy. Challenging and fun. The real-time delivery management is done by my colleagues, all pre-calculating and anything facing the user is my work. https://www.mealku.com
Just starting up my final year project at university - a data analysis tool/API. Basically the aim is for the user to be able to upload a CSV file (indexed by year and geography), then generate a report (graphs, tables, etc.). Plan is to create the API in PHP to handle all the data and users, then have a nice JS front-end for the user to use to upload the CSVs, order the reports, etc. Eventually aiming to open up the API to third parties but need to think about OAuth to secure the data as some of it's going to be confidential and how to integrate that into the JS front end.
I'm making yet another MVC framework, based on Silex. It's called 'Rhodium', currently working on an eCommerce module called 'Bullion', pretty happy with it so far, though it's very, very early days.
This. Keeping code in the office is the easiest way to hate code. You have to have passion projects, or spend serious time learning outside of the office. 
They look very similar but I don't think Slim was meant to copy Silex. Also, Silex borrows components from Symfony 2, which Slim does not. I hadn't heard of Silex until now. There are so many micro-frameworks, it's getting insane. Go for what looks interesting to you!
Might as well try to boost my confidence/motivation At 9-5 job: Geothermal databases. Forms and reports containing locations of places, measured data, and graphing heat/pressure of wells. Quite fun, actually. Extra contractor job: A bit special, have to admit, PHP is not very suitable to this. A database connected to a label printer and a counter on board a trawler. Making it easy to control the printer that prints labels on the boxes. (A hell to crack) Bonus: Crew can see exactly how much they have caught, a 'live' report. The old method used log files and Excel to create reports by hand. It's a ongoing process, slow to debug, since they only stop 30-40 hours on shore. I'm actually thinking of switching this project to Python, to make it easier to interface with serial instruments. Another extra: Job agency website. The front end was simple, but the backend still needs work to keep a track on 1000's of people. Bonus: Mailing list according to interest/categories. Needs a rewrite, was thrown together along with my ex over few weeks, but amazingly, still running, and people seem happy, especially the mailing list. 
Any jobs available?
Have you tried www.desk.com ?
[Bolt](http://bolt.cm) is built as standalone CMS, but it should be pretty easy to write a very simply 'proxy' for it, so you can embed it on other pages. I've written an extension that basically allows one to query the database for certain content, and return it as JSON. Then, on your base site, you could do something like this, in pseudo-code: $posts = fetch_as_json("http://localhost/bolt/json?contenttype=posts&amp;limit=3&amp;order=-datepublish"); foreach($posts as $post) { echo $post['title']."etcetera"; } 
Looks great. I'm using the procedural thingy now, but I'd like to use this. Have you contacted the [developer](https://github.com/blueimp/) to see if he might be interested in adopting your code?
Wouldn't it save you a lot of work to just use Google's chart API? $qr = file_get_contents("http://chart.apis.google.com/chart?cht=qr&amp;chs=300x300&amp;chl=http%3A//reddit.com&amp;chld=H|0"); Also, obligatory links to [wtfqrcodes](http://wtfqrcodes.com/) and [people scanning QR codes](http://picturesofpeoplescanningqrcodes.tumblr.com/).
I would vote Nay if i could. Fix PHP arrays / ArrayObjects first , stop adding features while letting the language half broken...
PHP should fail on every uncatched exception. It's the job of the developper to try/catch them or it is poor coding. The warning/fatal/notice system is one of the ugliest php feature.
"Don't know anything" was also acceptable.
Yeah this can be done with most blog systems that are rss-capable, but I would like to avoid executing double the amount of server-side requests.
Yes, but you depend on google (and its terms and conditions) and network to create the qr code. You can also create the qr in the client, but it assumes that the client's browser is connected to internet (I normally work in a private intranet with with limited access). It's just an available option 
@personal: a web front end for a automation installation system for desktop machines that ties into a database that my c++ stuff works with, a project management system. @work: many internal things, main one right now is a trouble ticket system ive built up this last year.
Beats QRLib's implementation, which only echos out the result instead of returning it ;_; ob_start(); QRCode::png($qr, false, QR_ECLEVEL_H, 5, 0); $qrCode = ob_get_contents(); ob_end_clean(); $this-&gt;view-&gt;assign('qr', base64_encode($qrCode));
I would probably just offload this kind of work to the client via something like [this](https://github.com/davidshimjs/qrcodejs). No sense in bogging down the server for something so simple. 
I'd suggest using [Geocoder](http://geocoder-php.org/).
Html5 Geolocation. 
Sounds interesting.
The downside (although presented as an advantage) of systems like Pico and Textpress is that they're flat file based. Flat file storage would be nice as an option, but imo content should be stored in the database, not in svn / git.
The only problem with this is the banner that's displayed across the top of the website by the browser asking for permission. We try to make it as seamless as possible, and the types of visitors we get would probably be freaked out if they saw a banner asking for their permission to see their location. Thanks for the suggestion though, I know that html5 geolocation certainly has its place.
Nope. Every level of a namespace decreases the likelihood of a naming collision implicitly. Global names like `\Router` have only 1 name, and so they will collide with anything else named `\Router` (which is a *lot* across the PHP community). Namespaced classes have a minimum of 2 names, e.g. `\Foo\Router`. It doesn't even matter what stupid name you use as your top-level namespace with respect to the additional protection against naming collisions that you've gained, because now `\Foo\Router` will only collide with other `\Foo\Router`s, and the number of `\Foo\Router`s is far less than the number of `\Router`s across the community as a whole. This is inherently true for any namespace you choose, even if it's a common one. Now, If you follow best practices when creating namespaces and use a unique vendor name as your top-level namespace, then you've just gained 99.9% protection against 3rd-party collisions, as anyone else following best practices won't have used your same vendor name, and anyone not namespacing will obviously not collide either. The only chance for collision is if A) your vendor name collides with another vendor name, B) you both use the same class name and inbetween namespace names (which could be as simple as `\Foo\Router` or as complex as `\Foo\Bar\Baz\Router`). **tl;dr** - Namespacing is *always* useful.
MaxMind has a (fairly) cheap high-resolution GeoIP database. I've never had problems with server load using this database, and there's a PHP extension for it.
&gt; Every level of a namespace decreases the likelihood of a naming collision implicitly. Nice, lets add a few hundred levels of namespaces then. &gt;It doesn't even matter what stupid name you use as your top-level namespace Lol. Of course it does. What kind of stupid assertion is that? If your project shares the same name as any other project, there will be unexpected results. Period. &gt;\Foo\Router will only collide with other \Foo\Routers Nice, so I should just cross my fingers and hope that there's nothing else colliding without my knowing? Sounds like an amazing plan. &gt;This is inherently true for any namespace you choose, even if it's a common one. Explain to me what the directory structure of two packages with the same name would look like. I'd love to hear about how this would actually work. &gt;If you follow best practices when creating namespaces and use a unique vendor name as your top-level namespace "Best practices"? Where can I find this RFC? How does one create a "unique" name without first knowing all the other names that are already in use? &gt;you've just gained 99.9% protection against 3rd-party collisions So you just pulled that number straight out of your ass, correct? &gt;as anyone else following best practices won't have used your same vendor name You make so many unusual assumptions and conclusions... &gt; A) your vendor name collides with another vendor name With a name like "gluephp", that is rather probable; as was my example above, which is why I clearly stated: " If he called his class gluephp (no namespaces), it would be EXACTLY THE SAME as if he used a namespace called gluephp", to which you replied "nope"... &gt;tl;dr - Namespacing is always useful. Nope.
I kept telling myself that at my last job -- we don't use X or Y, but they're getting a lot of attention, so I should learn them. But I kept telling myself I was too burned out. Now I have a new job and I'm determined to spend at least 5 hours a week improving my skills outside the office.
Currently learning meteor. It's pretty fun! Can't wait until I'm capable enough to make all the things my brain has thought of already.
I've used it extensively, and found it can wander out of date. You need to keep it maintained, or new IP blocks can be added that are not in the DB.
I did not know that. Thanks.
Absolutely, but that's the price you pay for fast lookups, particularly if you need to locate an IP outside of a user interaction.
I don't think this is much of a downside. Like /u/Voziv says: Just cache the results, and it should have no measurable impact on performance. 
For past 3 months I've been building site similar to parkingpanda.com, but for Europe, firstly for UK. It is based on Laravel 3, and I'm doing most of the work myself. It will be available probably within month or two - most of main functions are done.
Thanks for the info. That makes sense. I do wonder why Laravel didn't also just use Twig. It certainly would be better for PHP in general if there wasn't so much fragmentation when it comes to choice of framework so we could all just focus on learning and improving one of them.
I did this at a previous job. I used open source PHP lib at first attempt but performance was terrible. Switching to the C version improved performance 100 fold. http://fukuchi.org/works/qrencode/
That's still an ugly workaround for what should be a simple requirement.
[Here's a website](http://disneycareers.com/en/search-jobs/advanced-search/) you can use to find something. My part of the company has been heavily hiring contractors and doesn't have many (any) open full time positions. It may be worthwhile for you to work with a contracting company. 
The phrase "the php way" can be annoying when it's used as an excuse to avoid innovation. I agree with you there. I'd expect plenty of debate on the named parameter syntax. f(foo = "bar") vs f($foo = "bar") vs f(foo =&gt; "bar") vs f("foo" =&gt; "bar"), etc, etc. Disagreements over the syntax could sink the idea completely.
Oh, that's not the issue I'm having. Magento frontend works perfectly, backend throws a registry key already exists exception.
Why in the world would you expect the object to be cast to a string when trying to convert it to an int? Intval takes scalar values, not objects. If you want to pass your object to intval, you're going to have to cast it to a string first. 
If, one day, a PHP dev implements `__toInteger(), __toFloat(), __toBoolean()` etc. then *yes*, `intval($object)` should work. But right now `intval` + `__toString` gives an error, *as it should*.
&gt; Your example is sadly unrealistic in this instance. I won't completely disagree. There's a big difference between theory and practice. I have some old methods in my code base with 10+ parameters. I haven't written a method like that in years, but it does happen. &gt; As I said this API has 30 methods which have totally different arguments, so there would be 50+ get/set methods. To me having a class with 30 quasi-related public methods is a design flaw. That's a class that's attempting too much. Should the User class really have a getFriends() method? In addition to maintaining user state (id, screen name, etc), the User class is also being tasked with understanding user relationships. That's mixing responsibilities, and the User class could be broken up into smaller classes with clear responsibilities. **Example of breaking up the User class in my reply to this comment.** &gt; its incredibly hard to document what methods will have an effect on which other methods Classes are meant to protect their data and keep a consistent internal state. It's the responsibility of the class to keep things organized and prevent a method call from altering the results of another method call in an unpredictable way. This is why you don't write classes with 30 methods, and the class shouldn't have so many responsibilities that 50+ getters/setters are necessary. **** I'm not saying there's anything wrong with named parameters, but when I use the phrase "the php way" I mean the PHP devs would rather see people use good coding practices first, and *then* implement new language syntax if the coding practices fall short. I can't remember the last time I wrote a method with more than a couple parameters, and I'd rather pass null than look up the documentation to get the names of the parameters.
The concrete classes: /** * Implementation of the IConnection interface */ class Connection implements IConnection { /** * The row cursor * @var resource */ private $cursor = null; /** * Returns the row cursor * * @return resource */ public function getCursor() { return $this-&gt;cursor; } /** * Sets the row cursor * * @param resource $cursor The row cursor * @return this */ public function setCursor($cursor) { if (!is_resource($cursor)) { throw new InvalidArgumentException( "The cursor must be a resource instance." ); } $this-&gt;cursor = $cursor; return $this; } /** * Returns the next row as an array from the cursor * * Returns null when there are no more rows to read. * * @return array|null */ public function next() { $this-&gt;cursor-&gt;next(); return $this-&gt;cursor-&gt;getRow(); } /** * Sends a get request to the api and returns the raw results * * @param string $path The resource path * @return array */ public function getFromPath($path) { // Magic happens here } /** * Sends a post request to the api * * Returns a boolean indicating the success of the operation. * * @return bool */ public function postToPath($path) { // Magic happens here } } /** * Implementation of the IUser interface */ class User implements IUser { /** * The api connection * @var IConnection */ private $connection = null; /** * The user id * @var int */ private $id = null; /** * The user screen name * @var string */ private $screen_name = null; /** * Constructor * * @param IConnection $connection The api connection * @param int $id The id of the user */ public function __construct(IConnection $connection, $id) { $this-&gt;setConnection($connection); $this-&gt;setId($id); } /** * Sets the api connection * * @param IConnection $connection * @return this */ public function setConnection(IConnection $connection) { $this-&gt;connection = $connection; return $this; } /** * Returns the user id * * @return int */ public function getId() { return $this-&gt;id; } /** * Sets the user id * * @param int $id The user id * @return this * @throws InvalidArgumentException When the $id is invalid */ public function setId($id) { if ($id &lt; self::MIN_ID) { throw new InvalidArgumentException( sprintf( "The minimum user id is %d. %d given.", self::MIN_ID, $id ) ); } $this-&gt;id = $id; return $this; } /** * Returns the user screen name * * @return string */ public function getScreenName() { if (null === $this-&gt;screen_name) { $this-&gt;getUserDetails(); } return $this-&gt;screen_name; } /** * Sets the user screen name * * @param string $screen_name The user screen name * @return this * @throws InvalidArgumentException When the screen name is invalid */ public function setScreenName($screen_name) { $len = strlen($screen_name); if ($len &lt; self::MIN_SCREEN_NAME || $len &gt; self::MAX_SCREEN_NAME) { throw new InvalidArgumentException( sprintf( "The screen name '%s' must be between %d and %d characters.", $screen_name, self::MIN_SCREEN_NAME, self::MAX_SCREEN_NAME ) ); } $this-&gt;screen_name = $screen_name; $this-&gt;setUserDetails(); return $this; } /** * Queries the api for the user details * * @return bool */ private function getUserDetails() { $path = sprintf("/users/%d/details", $this-&gt;id); $cursor = $this-&gt;connection-&gt;getFromPath($path); if ($row = $cursor-&gt;next()) { $this-&gt;screen_name = $row["screen_name"]; } return true; } /** * Queries the api and sets the user details * * @return bool */ private function setUserDetails() { $path = sprintf( "/users/%d/details/%s", $this-&gt;id, $this-&gt;screen_name ); return $this-&gt;connection-&gt;postToPath($path); } } /** * Implementation of the IFriends interface */ class Friends implements IFriends { /** * The api connection * @var IConnection */ private $connection = null; /** * The user to get friends for * @var IUser */ private $user = null; /** * Constructor * * @param IConnection $connection The api connection * @param IUser $user User to get get and set friends for */ public function __construct(IConnection $connection, IUser $user) { $this-&gt;setConnection($connection); $this-&gt;setUser($user); } /** * Sets the api connection * * @param IConnection $connection * @return this */ public function setConnection(IConnection $connection) { $this-&gt;connection = $connection; return $this; } /** * Sets the user * * @param IUser $user The user * @return this */ public function setUser(IUser $user) { $this-&gt;user = $user; return $this; } /** * Adds to the user friend list * * @param IUser $friend The friend to add * @return bool */ public function addFriend(IUser $friend) { $path = sprintf( "/users/%d/friends/add/%d", $this-&gt;user-&gt;getId(), $friend-&gt;getId() ); return $this-&gt;fetchApiResults($path); } /** * Removes a friend from the user list * * @param IUser $friend The friend to remove * @return bool */ public function removeFriend(IUser $friend) { $path = sprintf( "/users/%d/friends/remove/%d", $this-&gt;user-&gt;getId(), $friend-&gt;getId() ); return $this-&gt;fetchApiResults($path); } /** * Returns an array of the user's friends * * @return IUser[] */ public function fetchAll() { $path = sprintf( "/users/%d/friends/all", $this-&gt;user-&gt;getId() ); return $this-&gt;fetchApiUsers($path); } /** * Returns an array of the user's active friends * * @return IUser[] */ public function fetchActive() { $path = sprintf( "/users/%d/friends/active", $this-&gt;user-&gt;getId() ); return $this-&gt;fetchApiUsers($path); } /** * Returns an array of the user's inactive friends * * @return IUser[] */ public function fetchInactive() { $path = sprintf( "/users/%d/friends/inactive", $this-&gt;user-&gt;getId() ); return $this-&gt;fetchApiResults($path); } /** * Queries the api * * @param string $path The api path * @return bool */ private function fetchApiResults($path) { return $this-&gt;connection-&gt;postToPath($path); } /** * Queries the api and returns a list of user friends * * @param string $path The api path * @return IUser[] */ private function fetchApiUsers($path) { $users = []; $cursor = $this-&gt;connection-&gt;getFromPath($path); while($row = $cursor-&gt;next()) { $users[] = new User($this-&gt;connection, $row["id"]); } return $users; } }
Using the classes: $connection = new Connection(); $user = new User($connection, 666); $friends = new Friends($connection, $user); $active = $friends-&gt;fetchActive(); Note that only methods in any of these classes taking more than one parameter are the constructors, and in those cases the parameter is required.
But why does __toString not do this, when it does it for a few other constructs and functions? Edit: nevermind, I thought more about your answer and I figured it out. For some reason, I didn't think of the behind the scenes casting which is performed by echo and sprintf
I'll check out Lithium, thanks! Not sure I agree on never using your own framework. Dogfooding is an excellent way to see the areas in which it can improve. My framework will not be the next Symfony but it's turning out to be a very minimal and fast MVC foundation. :)
&gt; Nice, lets add a few hundred levels of namespaces then. Yeah, [science](http://en.wikipedia.org/wiki/Entropy). &gt; Lol. Of course it does. What kind of stupid assertion is that? If your project shares the same name as any other project, there will be unexpected results. Period. Of course there will. The point of namespaces is not to *eliminate* the possibility of collisions. It's to drastically *reduce the likelihood* of them. &gt; Nice, so I should just cross my fingers and hope that there's nothing else colliding without my knowing? Sounds like an amazing plan. Yes, and despite your shock and amazement, it turns out that it works out quite well when used properly. This is why namespaces are overwhelmingly popular and supported in modern programming languages. &gt; Explain to me what the directory structure of two packages with the same name would look like. I'd love to hear about how this would actually work. First of all, namespaces are not directory structures. Secondly, you're talking about namespace collisions now, and I don't think you understand that this is exactly the same problem namespaces were designed to help prevent. After all, global name collisions *are* namespace collisions of the global namespace. Adding levels to the namespace *reduces* the chances of collisions. &gt; "Best practices"? Where can I find this RFC? How does one create a "unique" name without first knowing all the other names that are already in use? There is no RFC for best practices. Best practices are community-derived and accepted through experience and consensus. That being said, the very first and second lines of [PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md) are about as close to an example of this as you can get. &gt; With a name like "gluephp", that is rather probable; as was my example above, which is why I clearly stated: " If he called his class gluephp (no namespaces), it would be EXACTLY THE SAME as if he used a namespace called gluephp", to which you replied "nope"... To say that it would be "probable" is disingenuous at best. It is, of course, possible. The point is that it is **less** probable than the same class in the global scope, because namespaced names have more entropy.
We've just recently started to do unit testing at my workplace and I can't offer as much knowledge on this subject as others who have been doing it for a while. But early indications I've gotten are that the clients we have seem to like the idea of it and upon hearing about the unit testing, most have asked to access some kind of interface to run the tests themselves. Not all will care or find it useful, but I think it's definitely worth it as at least an option.
We are currently using a version of the maxmind PHP extension in our production environments and it's pretty accurate and very fast.They do offer updates to the DB and they provide a mechanism to [auto-update](http://www.maxmind.com/en/license_key) If you want more accuracy, and at a steeper cost there is an alternative which I would suggest [digital element] (http://www.digitalelement.com/)
That is true, it's good to put it through it's paces to see where you need to improve. I'd like to see it when you're done, if you don't mind. Good luck :-). 
Ya, that's the shits. Good luck with your API! 
I'm also very interested in putting the ability to see or run tests in to the clients hands too. Perfect for peace of mind. 
For what will you be using the location data? If it is just for determining nationality, you could just run a whois on the IP owner, which returns the ISP's address, but you will get imprecise results if you use it to determine state/province level specificity. That said, you still would want to store it in session and refrain from subsequent whois queries.
You can't succeed if you're not prepared to fail. I was in a similar situation to you when I moved my family internationally to pursue development jobs. You have to be willing to take a job which may be low end, code refactoring or testing to start with until you can prove yourself. Without a degree employers who interviewed me were mostly interested in my stackoverflow profile, then the submissions I had made to github projects. It's unlikely you will get a job where you can start from scratch with laravel so employers will want to see you can be part of a bigger project where you're only doing a specific part. Make sure you're confident when making an application and don't doubt yourself, you may get 30 or 40 nos before you get a yes. It's about providing the employer with the proof you are what they're looking for based on a tangible evidence. Don't give up. Good luck.
Best part of the article, to me: "[..] less lines of code and less dependencies are desirable, that is not the top priority. Micro means that silex exposes a minimal interface. It makes a minimal amount of decisions for you."
Nobody said the user class has a getFriends method, those were examples coming from strangers. But yes all of your advice would be accurate to somebody who had grouped unrelated functionality together, but not me. &gt; the class shouldn't have so many responsibilities that 50+ getters/setters are necessary. The class doesn't have that many responsibilities. It only has that much responsibility in your implementation because you are trying to make every single argument into a property, which then forces an insane number of getters and setters. That's why I hate that suggestion. &gt; I mean the PHP devs would rather see people use good coding practices first Your implementation is hardly good practise. It's a hack at best. &gt; I'd rather pass null than look up the documentation to get the names of the parameters. How do you know you how many arguments the method takes? You look at the docs. How do you know what possible values it can have, or what data type it has? You look at the docs. How do you find the name of the parameter? You look at the same damn docs you looked at to know what values to put in there in the first place. Suggesting named parameters require more doc-checking makes no sense whatsoever. And, while present-day headzoo might be happy shoving a random `null` into a set of arguments, future headzoo will have no idea what that is and will be annoyed as hell with past headzoo.
I haven't seen any of your work, so I'm just going to base this on the list of skills you've given. I'm guessing you're right in the middle of the [Dunning Kruger](http://attentioninteractive.com/wp-content/uploads/2013/03/Dunning-Kruger.jpg) graph: You already know quite a lot, but you're underestimating yourself. You need to recognize that you have a lot of skills in our field of expertise, but you will need to feel confident enough about them to market yourself. Know that a lot of people feel that they are "experts" while they don't know anything about half of the skills you've listed. Or, to put it differently: If you were applying for a job at my company, your list of skills would surely get you an interview. Best of luck! 
tl;dr: "I think they're a bad idea and I'd never use them but they should add it because someone might want them"?
its def silly but it gets the material across well
It depends on your client. Many times it's a requirement for many contacts (that I do), otherwise it's just something else that you can show to your client to ensure they feel that they're getting their money's worth. In my opinion, you already have the output, you're already doing unit tests, you should make the results available to your client every time.
Thanks for your reply! I've posted one Github example on first topic. Also, I developed this CMS. Demo video is here: www.youtube.com/watch?v=e_juXhUuPus and the address is here: http://dugunsihirbazi.com Also, http://www.monfeu.com.tr http://sekilidernegi.org (very old project) http://agorarezervasyon.com https://github.com/Aristona/sobafire.com-Sources https://github.com/Aristona/Knight-Imperia-V4-Website etc. many more. All my work are CMS systems like those. Currently developing a framework mimicing Laravel 4, to improve my OO skills. Also, using new techniques on a News Portal I'm developing with: Bootstrap, AngularJS, jQuery, Laravel 4, MongoDB that I will start selling once it's done. But it develops at turtle speed, since I review my code, say "meh", refactor most of it. I once felt like an expert too, but learning and learning, I knew I was wrong and I realized I knew just the basics back then. Not sure, if future me will think the same about current me. 
My original reply (and the reply from /u/bopp) didn't put any emphasis on having someone vouch for you, the focus should be on the skills you can bring to the table. That's what employers want. Don't worry about never having your code reviewed, you say you're mostly following correct practices so all a reviewer is going to do is give you their opinion, which may or may not be the right way to do it. I know low self esteem and self confidence sucks, but what you're trying to achieve sounds slightly harder than a normal job so you have to be prepared to be knocked back more. Every time someone knocks you back, ask for feedback on why you were unsuccessful, a majority of employers are happy to tell you why you were unsuitable for the role and what they'd like you to have to be successful. If you see a trend, then try to fill in the gap. You also don't need to move to get a job. Apply for jobs and be prepared to travel for an interview. Make sure your employer knows you're committed to moving if you're offered the job.
I have nobody to vouch for me except examples and sources of my old projects. Did you read that part wrong? Showing old projects should be the only way I can prove what skills I can bring on the table, isn't it?
Some valid points in that article, but you also have to balance the relative smallness of the default installation with the fact that the 'meat' of the framework beyond routing is actually in the [require-dev dependencies](https://github.com/fabpot/Silex/blob/master/composer.json#L26). Sure these can be swapped with other components, or not used at all, but a typical installation of a functional application will want config, db, security, logging and probably templating at a minimum, no? It's odd to see these in require-dev. That's supposed to cover "packages required for developing this package, or running tests, etc." Including e.g. Security, Monolog, Twig and Doctrine here seems pushing the definition a bit for the sake of a smaller default install. Unless these are needed just for the tests? 
`require-dev` contains the packages necessary to run the tests. Silex has some optional integration with them, but you don't get any of that by default.
Your brother is right. If you think it's fine to memorize all the function/object/methods, good for you. I myself dealing with 3 languages, 3 frameworks and 3 standard libraries, 2 sets of domain objects, tables and what not; I'd be more happy to have a flush memory button, to cram out all the crap; and just use the reference. edit: spelling
I can relate. We spent the last several years building and maintaining a few End Framework and Symfony sites and some WordPress plugins and Drupal modules and Joomla components. About a week ago I had to go back and do it "the long way." I think it was good to go back to the basics. What is important is knowing how all of those routines work under the hood - and getting a refresher this way is good. It gives you an appreciation for $db-&gt;QueryRowArray($sql) (or whatever you're using). 
DB interaction falls under the category of things you *should* know. It's not an obscure function you never use and rely on your IDE to remind you of. It's one of the first things people learn in PHP, and PDO is considered "the right way" when writing stand alone code. It's basically on the same level as class initialization; because that's what it is.
You assume much. Sure, it is a basic thing, but not fundamental. And I don't know what you're defending. In fact when dealing with most of the stuff from PHP I have to use the reference anyway so no sense in memorizing stuff (some does stick around for a while, but that's not the goal). &gt; It's basically on the same level as class initialization; because that's what it is. Your viewpoint, is limited to say the least. In a SOA I deal with data from endpoints, intercommunicate with a couple of services via Thrift, and all my code does is transform and manage flow. There is no direct database involved. Also when working with databases, I still try hard to stay away from the horrid low level API's. In PHP an ORM keeps me sane for most of the database communication, in other languages expressive DSL's that map quite nicely to queries.
Well when you think about it, PDO is just a database management framework.
Do you write them on their dime? Then yes, they belong to the client.
You should be able to get many interviews. You need to apply to major hubs, such as Silicon Valley or NYC to really have a great chance at nailing down a good paying job that will lead you to a fulfilling career. I am sure that you should be able to find something soon. Good luck!
Omg thank you! I love disney and working for disney would be a dream come true! Even though ive heard they are tough to work for, especially as a contractor, I would do it in a second!
I can see that you are biased and there is nothing is wrong with that, but if you were in a food industry you would be the guy heating up a pre-made burger in a 5 star restaurant because 'remembering' stuff is a job of a sucker. Your point about 'memorizing' everything makes no sense, great programmers still use references. The MAIN drawback about using everything that's made by somebody else is your loss of ability to understand the 'architecture' aspect of things and actual meaning behind simple operations. 
I seems like a square peg, round hole argument to me. Using the term "micro" to denote what a framework will do (or wont do) for you seems forced and too abstract. Perhaps graduating Silex from a "micro" framework to a "minimalist" framework would make more sense. 
We've been using their API with a local cache that we keep for 90 It's always been fast and reliable. Pretty sure we've been using it for at least four years. Keeping a local copy up to date can be a time consuming pain in the dick.
I don't understand why you cannot cache them. The location of an IP address is highly unlikely to change frequently, if ever. Just cache it with the IP an an index. When you cache it, use an integer as an index. Use [ip2long](http://php.net/manual/en/function.ip2long.php).
There are plenty of places in the Bay Area and NYC that use PHP. I would definitely do this sooner rather than later.
I can see that you're ... a bunch of ad hominem jabs because of your poor analogy that got redacted. Let us put the things in this way, in the food industry I'd be the guy that knows how most meals are cooked but doesn't know the exact ingredient quantities (for which he uses a reference). No wonder, with all the stupid non consistent scaling: teaspoons, tablespoons, cups, pints, fluid ounces, and more. What obviously you missed with the exaggerated aspect of memorizing all, is the fact that you can't just point at something and say "this must be memorized"; because unless you're one of those company dedicated fellows (as in working in one place till you retire), your software stack will change quite drastically and unpredictably with time. &gt; The MAIN drawback about using everything that's made by somebody else is your loss of ability to understand the 'architecture' aspect of things and actual meaning behind simple operations. You realize this is the argument people always throw around, about "you must understand what's beneath the abstraction". From the days of machine code, to nowadays web stack. Which is an idea that is fine by me, but understanding that, is not equal to working at that level. Also, your last line sounds very close to the roots of NIH syndrome... I myself, only keep in my head stuff that is "now required". edit: spelling
The term "micro-framework" has been around for a while. I found a [good reference](http://flask.pocoo.org/docs/foreword/#what-does-micro-mean) from the flask micro-framework for python, where the developers explain their idea of micro. Excerpt: "Flask won’t make many decisions for you [...]".
OR become a specialist in something very specific. Knowing "a lot of languages" can be a bad thing. To really write high quality code with proper deployment with very little to none technical debt on, let's say, Symfony2 framework requires multiple (10+) projects and years of experience. It's much more usefully to know the ins and outs of one system that's in demand (Drupal, symfony, wordpress ...) and have the ability to create top notch project with them than to know all of them .. just kinda or even worse know ruby with RoR, python with Django, and 5 different php frameworks and not be able to develop anything remotely like a serious project. Note: There's a difference between knowing only the project you're working on for a long time and knowing a limited set of technologies/platforms really well. Note2: To be replaceable means that some one else can easily take over your job. Knowing lots of different technologies does not prevent this, but enables you to move around quickly. To not be replaceable is to know/do something you're employer can not find anywhere else.
Living with family as oldest son implies you're probably Asian. Do you live in Asia or are you an immigrant somewhere? PM me if you're in North America. I've been recruiter spammed on LinkedIn lately that I might be able to hook you up with some of them. 
I can cache them in the session variable as was suggested before. I actually implemented that earlier and cut our mysql queries down drastically. I must have been having some type of mental code-block. Caching to the session was easy and effective. 
My jabs are at the fact that the only thing you mention is that 'oh I don't have time to remember all the methods' followed by a list of languages you are working with like that means anything to anybody. And actually in the food industry you would be the guy that knows how most meals are cooked if that knowledge is 'use pre-made meat and sauces and put it all together'. If you are a framework monkey you will not know 'all the exact ingredients' it takes for your application to work. But yeah, I made my point not going to get into a pissing match. 
Quite literally all the time. Once you get experience doing something a single way, you sometimes forget the basics. That's why one of my old college professors used to sling his mantra around all the time: "fundamentals fundamentals fundamentals." He would always require us to dedicate the first 5-10 minutes of class redoing work from either a previous class, or semester (depending on which class you had) to ensure that the basics of what you were being taught stuck with you for as long as possible. You should develop some exercises that you can do on like a bi-yearly basis to stay sharp. Admitting you don't know something is the first step to real learning. Also, Google is God.
You ignorance blows me out of the water. That list of languages, frameworks, standard libraries IS MEANT to mean something. It means there is a more than enough information to keep in mind for an active project. I don't NEED to waste cognitive load on how each of those framework, libraries implement their behaviour. &gt; If you are a framework monkey you will not know 'all the exact ingredients' it takes for your application to work. Thanks, I'll now how to RES tag you now.
So you do cache to mysql then? You just keep it in session because you need it every page? 
Not the OP here. I'm not a framework monkey - I program in multiple languages, using multiple paradigms, with and without frameworks as relevant. I have a general understanding of how interacting with a database works - connections, transactions, queries, cursors, how they all fit together - as I'm sure the OP does. If you wanted me to tell you exactly which function I'd use in PHP to execute a prepared statement, though? I honestly couldn't tell you. But that's fine, because I know what prepared statements are, when to use them, and roughly how to use them. I just need a reference for the exact details regarding which objects I need to create and which functions to call. It's far more worth it to stuff my brain with a bunch of theory about how things work at a higher level, that I can then use to design my programs - and solve problems - in an optimal manner. You tell me a business problem you've ever solved by having an encyclopaedic knowledge of every function in your language of choice.
&gt; Capt. Murphy: I don't give a fuck, Riggs. That's why I don't have an ulcer, because I know when to say "I don't give a fuck." If you've been going for years without working directly with PDO it's probably not all that important that you know it. If you do decide to use it you've got Google to help you out.
Then one day you're sitting on the toilet and realized it's strapped with HE... 
&gt; Namespaces reduce collisions using the same fundamental principle that causes longer class names to reduce collisions - entropy. I already pointed you to an article where you can read all about the math if you wish. Allow me to be as condescending as you, [Science](http://en.wikipedia.org/wiki/Computer_programming). Read up, maybe you'll learn something. &gt;It's funny you should mention that, since there have been core developers pushing to add them recently. In fact, /u/ircmaxwell's recent function autoloading RFC even includes it directly in the proposal. You just quoted an RFC that is less than a week old, has not been voted on by anyone and is not even close to becoming a feature... &gt;You're confusing PSR-0 autoloading with the more general concept of namespacing. Autoloading classes based on their names predates any PSR document. Everyone uses an autoloader. Everyone structures their application using namespaces (just not necessarily PHP namespaces). The Zend Framework started this trend a long time ago. &gt;They both increase the entropy of the name, and thus reduce naming collisions. You keep using that word. Entropy has NOTHING TO DO WITH IT. Having overlapping base namespaces (the first name) is a collision. Period. If you have two packages with the same name (eg, glue), you have a problem. &gt; The PHP-FIG voting members are project representatives, and they ultimately make the decisions on what is accepted or declined, obviously, but the community at large is highly involved and influential in the design process. The people who wrote PSR specs even said and allow me to quote: https://github.com/php-fig/fig-standards &gt;The idea behind the group is for project representatives to talk about the **commonalities between our projects** and find ways **we can work together**. Our main audience is each other, but we’re very aware that the rest of the PHP community is watching. **If other folks want to adopt what we’re doing they are welcome to do so, but that is not the aim.** Emphasis mine. &gt;It does not force you to use Snake_Case, nor does it have any naming rules other than requiring that the code use namespaces with a top-level vendor namespace. The PSR autloader spec clearly requires you capitalize the first letter of each directory, resulting in a capitalized snake case for class names. &gt; But adding it, whether there are 1 or 100 classes in your project, will help prevent naming collisions with 3rd party code. The code was a minimalistic MVC with the goal of being compact and tiny. None of what you just said applies.
I agree with you to an extent. There is definitely a benefit to becoming highly specialized in a specific language/framework/stack etc.. However, exposing yourself to lots of different languages, frameworks, libraries, paradigms, etc.. is also very beneficial in terms of helping you approach problems from new, different directions. It's like the saying goes, if all you use is a hammer, every problem starts to look like a nail..
I'm personally a fan of the associative array syntax: $foo-&gt;bar('baz' =&gt; true) I think it was /u/nikic who said that this syntax was too similar to the existing array "hack", but I see the consistency as a positive thing. It also opens the door for possible variable interpolation? Not sure how useful that one would be, though...
Just look up the API if you forget?
I'll second that. I can never find enough PHP developers for my friends companies in NYC, it's a constant struggle.
Learning design patterns is easy -- learning when to apply them comes with experience or perhaps examples (which the GoF do provide in the book).
Argh! I just had this happen to me two weeks ago. I needed to do a one time update of some old data in a database so I wrote a quickie script to handle it and abruptly realized I was going to have to look things up. The last time I wrote my own db interactions was when you used inline mysql with mysql_connect(). 
If you think it's a hack to write code that's easy to maintain, easy to unit test, uses dependency injection, has a clear separation of responsibilities, and keeps method bodies small, then I guess this conversation is over. On the other hand if you're suggesting it's a hack to refactor smelly code, then I have to disagree. Methods with too many optional arguments are the hack. Refactoring a design to fix unwieldy methods is the un-hack. Sure, named parameters could also be used on methods with only a couple arguments, and I wasted a lot of time defending my point of view if those methods were the core of your argument. But lets be honest here, you want named parameters to deal with annoyingly long lists of optional arguments. Where the getFriends() example came from doesn't matter. You could have used an example with only two arguments instead of five, but you know full well that would have been a weak use case, and garnered nothing more than a yawn from /r/php. Have you ever seen the pass-an-array-of-arguments hack used in the wild on a method with only two arguments? Probably not, and you won't see named parameters used on such simple method calls either. You presented a use case to support your request for named parameters -- a method with a long list of optional arguments -- and I'm demonstrating how your use case is flawed from the ground up. The solution you're looking for lies in refactoring horrible code instead of adding new syntax. You're basically asking the php devs to fix a flawed design. *** One last thing... I understand you're an active developer and you have a presence in the php community (eg you're no "noob"), but suggesting the php devs (Rasmus &amp; Zeev included, [link](http://www.php.net/~derick/meeting-notes.html) and [link](http://www.php.net/~derick/meeting-notes.html#named-parameters)) don't "understand" named parameters because they don't see the brilliance of your idea is a fallacy driven by arrogance. It's *just* possible these people know what they're doing, and came to the decision to exclude named parameters after weighing many factors you haven't even considered. Good luck with the RFC though. I've read back through the mailing list and you have your work cut out for you. The idea has been brought up ad-nauseum and you really need to think outside the box if you want to come up with an argument for named parameters that hasn't been used already. I wouldn't mind having named parameters, but I'm not the php internal developer being asked to make big changes for little payoff.
No, he'd be the guy looking at the recipe every now and again because he can't be bothered to memorize every recipe for every meal he cooks. At some points he knows what to do, and at other's he glances at a recipe and then modifies it to his own artistic flair. Writing code is no different. I'm sure he has some bits of PDO stuck in his memory banks, but he's going to pull up the PHP reference page or his favorite tutorial to set him on the right track when he loses a pointer in the LinkedList of his memory. There's no point in shaming for that. We can't all memorize a lot of things. I for example have really shitty memorization, but am really good at finding the details I need. With PHP's Documentation, PHPDoc, etc - I can rely on external sources for memorization where needed, and instead focus on implementation. The main drawback doesn't necessarily apply to non-memorizers. We can learn the architecture without knowing exactly how to do things
&gt; You're welcome to follow the PHP internals mailing list for more examples. Show me something that is actually in PHP right now, not what *will* be there in a few years. &gt;Without namespaces, collisions are frequent and hard to resolve. No, they cause obvious errors that are instantly known by any half decent programmer. &gt; It's especially rare if you have PSR-0 compliant namespaces with a relatively unique vendor name. Nothing about PSR will result in vendors picking unique namespaces. &gt;I won't be replying anymore, since this discussion is obviously not productive. I hope for your sake that you take closer looks at how namespaces work I am fully aware of namespaces and how they work. Nothing you have said in any way results in the reduction of collisions. Nothing. A package called "glue" will still collide with any other package by the same name. I have no idea how you can think otherwise.
For sake of argument, I'm going to point out that on top of being an interpreted language, the PHP interpreter is fairly slow as interpreters go. Having to parse more lines of framework (and in relation, open more class files) will, at some point, measurably slow your application down. Lines aren't a direct measurement of the number of instructions involved but it does give a ballpark. That's not to say that Silex is anywhere near this point (it may or may not be – that depends entirely on your environment) but don't say LOC means nothing.
Also, if seeking job, ruby or nodejs or java. No need to spend time on weird stuff like scala or Haskell cause no one really hires for those.
Sometimes I find myself doing exactly what you're saying about PDO. But what's worse is I find myself getting tunnel vision when working on an app or something. I get into such a comfortable groove of doing things a certain way, that I forget I need to step outside the box to make things work a little easier. One recent example is my attempt to add a modal to an app I was working on for my company. It was getting more and more confusing, and the data was just becoming too cumbersome to make the modal useful. I ended up just making a new page for all the data. The point is that I should know when to take a step back and say, "there's a better method".
If that's how your freelance contract works, you're doing it wrong.
Not only should you be giving them to your client, you should be writing them with your client. Behat (and the Gherkin language) was built to be accessible to non-coders. The idea is that you'll catch more defects by agreeing to what you're building up front. If you include your client in what you're doing you can make sure what you're making is what they actually want. With other automated tests like phpunit you should still provide them to the client if they get the rights to your code. If someone else needs to maintain your code those will be a lifesaver for them (and part of the work for hire you created)
Holy shit, this is my mantra for life and I didn't know it. I try my absolute best to not give a shit about *anything*, and it drives some of my co-workers nuts. I thoroughly enjoy looking at a seriously tough problem and thinking to myself "Not my fucking problem."
Compared to one other semi-major framework which tries to do the same "slim" I'd have to say silex has more features that you would generally want. I'm currently working on a fairly large project and using Silex as the basis for this project, which happens to be a Restful API w/ authentication and all the filters (before/after) methods(get/post/put/delete/etc) etc make this framework ideal for API's which focus on lean code. Key is building your own framework on top of the "lean" micro-framework which mostly provides foundational features that a large framework would usually give you without forcing you into a particular structure. What ever you decide is the way it will work. Silex(PHP) is to Sinatra(ruby) is to Bottle/flask(python) is to Express(node.js) is to Spark(java) All of them may not be small, but they're frameworks none the less, they just don't force your hand when you use them.
I'm not sure how much this matters since the introduction of opcache to base PHP. 
With a name that sounds like the Spanish word for fart. :-) 
The mail() function returns a boolean value meaning that you can easily check it's success with a simple if() statement. I'd suggest something like this: $success = mail($to, $subject, $message, $headers); if($success) { //show success message or page } else { //show failure message or page } However, if you're wanting to do a redirect, you'll need to do so before anything is output by your page/script. If not you'll get an error. So you'll want to do the check as close to the beginning of the script/page as you can and then proceed accordingly.
Hiç fena görünmüyor bence. İyi şanslar :)
For anyone who doesn't know what /u/stesch is referencing: http://www.reddit.com/r/funny/comments/1ljam8/apparently_spanish_slang_for_fart_is_pedo_my_71/
I will never read PDO the same again.
Until you advance to the point where you are using a framework, then you simply don't need to know it anymore.
&gt; DB interaction falls under the category of things you should know. Define "db interaction". mysql_ functions? No, not any more. mysqli_? Ehhh, ok but generally frowned on. How about the [dba interactions](http://www.php.net/manual/en/intro.dba.php)? No. Maybe all the obscure oracle system interactions? Oh, well yeah PDO, sure -- but which kind? PDO can do [12 different kinds of core db interactions](http://us1.php.net/manual/en/pdo.drivers.php) and while PDO is an abstraction to help you bounce between those as seamlessly as possible -- let's be real, they all have quirks you're going to need to know about. So, no, after 10 years of working with PHP I have absolutely zero qualms about having to look up routines once in a while.
My problem is I never use frameworks. I really should look into something like CakePHP. I wrote my own little MVC framework, though.
If you want to be a PHP dev, the best piece of advice I can offer is get some Zend and Magento experience, most PHP jobs out there (at least in the UK) are Magento based 
I'm assuming that means you need help with the redirect? Here's what you'll want to do. First off, make sure that the email logic and check I posted are the very first things at the top of the page/script. Then you can modify what I previously posted like this: if(!$success) { header('Location: http://www.example.com/'); exit(); } Then further down the page you can add a new check where the email form is: if(!Empty($success) &amp;&amp; $success) { // Show success message } else { // Show email form }
In my experience, if you're running an app or site where performance is critical, you'd have full control over it anyway. Either a VPS or dedicated hosting. 
You are working at a different level of abstraction. And you know what, that's cool and fine. I am rusty on my C, and my 68000 assembly, and my Z80 hex machine code (yeah, I didn't have an assembler on my ZX81). I know that (kind of) stuff is all there in my laravel Web app, buried many layers deep, but I'm happy to know I don't need to deal with it any more. 
Thanks alot, but I'm not. :)
A turnout fairly higher than expected, puts it in the top 25 new feature requests. I for one can't wait to see if they add it - it would make for one truly colossal PHP environment.
I have some C++ experience. I'm probably just a beginner though so I don't mention it in my CV. Why Java? To practice OO concepts? 
Chicago is in need of more php experienced engineers. You would definitely find something here based on your enthusiasm alone. Git your ass to a big city, you're wasting your time otherwise, not to mention making a mess of your psyche. 
Teşekkürler! :)
I'd strongly suggest using Laravel. 
If you're actually using raw PDO so often that you're fluent in the API, you're doing it wrong. I've (re)learned PDO probably a dozen times. 11 of those times when I was building some abstraction on top of it. The time I spend actually using the PDO API approaches zero. Why should I (or you) feel obligated to memorize it all when it's so well documented? 
I mostly use Laravel in my projects, but I believe I can easily adapt myself to other frameworks. Every framework looks similar to eachother. They do the same things in a different fashion, so once you master a framework, transition to other frameworks is much easier. In my country, the jobs are usually .NET related and takes the majority of market. PHP related jobs usually require Code Igniter knowledge. Companies using Zend are usually serious about their work and I barely see Symfony related jobs. (and never seen Laravel related job so far) I have a strong feeling, in the next few years, Laravel and Phalcon will be more popular. Yes, Laravel is built upon many Symfony components. Thank you alot for your kind words!
Just use your phone: http://www.google.com/#q=how+to+disable+explosives&amp;safe=off Of course, now we're all on a watch list... To anyone who wasn't sure whether you were being watched or not, you know for sure now. So...you're welcome for that.
&gt; "It makes a minimal amount of decisions for you." And yet... something like ZF2 also 'makes a minimal amount of decisions for you', obviously IMO. But I'd hardly call it a 'micro framework'. 
I'm surprised so many people see your answer as the most reasonable one. If you're able to understand and use a Framework such as Laravel or Synfony or Zend's, I don't see how you could get stuck more than a couple minutes on remembering how PDO (or any other lib for that matter) works.
But then inevitably you find yourself in an interview being asked how to do *X* in *Y language* off the top of your head and look like a fumbling idiot. Granted, most of these types of interviews are arranged by clueless HR reps who would take any answer. 
I'm intrigued by this response. I met recently with a bod outside the industry who couldn't believe that when I had finished a contract the code I had written belonged to the client. If I pay for something - let's say a shirt for example - once my money has switched from my account to the shop's account, the shirt belongs to me. It's not part owned by them, and part by the guy who stitched it in some sweatshop. Why would your freelance code be any different? I'm not being rude or whatever here, so don't take it the wrong way. I was left thinking she was crazy... but then I haven't ever considered it any other way. Distinction: freelance to me means contracting (UK). 
Remembering arbitrary APIs is not comparable to basic arithmetic skills. It's closer to memorizing the manual for your VCR. Your brain has limited capacity. And the myriad of APIs you're going to encounter in your professional life aren't a great use for it.
a watch list? me, too, please!!!
Yeah, this is a well-known problem...developers "learn PHP" by learning how to code in a framework and get lost when they have to do something more low level. Not saying that you don't know the basics, but it's easy to let some of the magic do it for you. Some developers will spend more time looking for an extension or class they can copy and paste to do what they want than take the time to learn the PHP to make it happen themselves. These are the people that more often identify themselves as "a Zend Framework developer" or a "Symfony developer" rather than a PHP developer. I'd almost go so far as to say that this is the same mentality you get from some of the WordPress/Joomla folks when you ask them if they're PHP developers (forgive the generalization, just making a point). Frameworks are great and all, but they're not a silver bullet. Don't forget that not everything has to be done using them. Sometimes you just need a collection of scripts/packages and a little "glue" to make it all work.
I'm sorry, but this is quite terrible English, making it very difficult to read. Also, your connection syntax and structure is horrible and wrong. You're advocating mysql_ extensions. These are deprecated in current versions of PHP, and will be removed in future. They're also clear evidence of being shit at PHP, so it makes me wonder why you're submitting this article.
Phalcon &lt;3 You're actually one of the very small handful of people I've talked to who knows about Phalcon! I agree, Phalcon will hopefully become huge in the coming years :)
Again that is a weird thing to say, as this RFC is already implemented and is just being discussed before a merge. You act like there is only one person on the core team.
Splat is only relevant to variadic functions. Variadic functions are not at all relevant to named variables. A function/method could easily have both, so worrying about this as part of a splat RFC is useless.
$sql="SELECT * FROM foo" $db-&gt;setQuery($sql); $db-&gt;query(); $rows=$db-&gt;loadObjectList();
Anecdotally, going from php 5.3 to 5.4 will give you on average a 20% improvement in performance along with lower memory usage. PHP 5.4 had some really significant under the hood changes that addressed both. I'd say its worth it, I haven't run into any BC breaks between 5.3 and 5.4 though there are a few listed here: http://www.php.net/manual/en/migration53.incompatible.php You should setup a testing environment and see if anything breaks. I'd use http://puphpet.com to get a Vagrant box ready quickly. 
Thanks alot Phil! I'm really happy I heard those from a talented developer like you. 
From the RFC: "Argument unpacking is not limited to variadic functions, it can also be used on “normal” functions" function test($arg1, $arg2, $arg3 = null) { var_dump($arg1, $arg2, $arg3); } test(...[1, 2]); // 1, 2 test(...[1, 2, 3]); // 1, 2, 3 test(...[1, 2, 3, 4]); // 1, 2, 3 (remaining arg is not captured by the function declaration)
Updating from 5.3 to 5.4 will improve performance. Depending on use case even significantly. Updating from 5.4 to 5.5 will likely not make a large difference. Going to 5.5 instead of 5.4 is still a good idea, because you'll be able to use opcache, rather than running 5.4+apc (which is known to not always work so well.)
Just a life tip. You have to try. Your fmaily situation sounds tough, and they also sound extremely negative. This is horrible for a happy life. Do you have any debt in your name? If not, great. Save up as much as you can and get out of that situation. Start applying to jobs in different areas and if you happen to get an offer, move to that city. Regardless of your skillset, you seem to at least understand the basics and you seemed determined to learn. I think you will do just fine and you will be an asset to any company looking for an entry level developer. Take a risk. Don't let your family's negative energy hold you back. If you feel bad about leaving them, maybe send some money back to them every month to help them with their bills, or as back-rent for them letting you stay there for so long after your turned 18. Good luck.
What I'm reading here is a total lack of confidence. I understand where you are, because I was there myself not too long ago. What bopp wrote about the Dunning Kruger graph is right spot on on the money. You know a lot of stuff, but you have no confidence in your knowledge. But let me tell you one thing - that is bullshit. When I was in my last job I felt like shit. I was sure that I was a great programmer, then I started reading Blogs and Books and suddenly felt like I knew nothing at all and could never climb that humongous mountain in front of me. How could I ever be so great like all those guys who develop complete frameworks and stuff? I was just a lowly worker, hardly more then someone working a construction line. But that is bullshit. Bullshit, bullshit, bullshit. With the enthusiasm for programming you have, people will be happy to have you. And once you find a good workplace you will learn the one thing that I learned at my new job: you don't have to be the best, you just have to be good enough. Nobody out there expects you to deliver brilliance each and every second of your working day. When all is said an done most customers don't give a shit about how beautiful your code is, as long as it works and does what they expect. And from what you've written you have plenty enough knowledge to be good enough in most all shops. I don't say you don't need to try to better yourself. Trying to better oneself is a great thing. But don't give yourself such a hard time about the things you feel you don't know. Most of that stuff you won't need anyway, and if you DO need it you can always look it up.
Networking and talks mostly, definitely worth it. Good place to practice public speaking too or trial a talk before submitting to a big conference ( for example I'm speaking at the London PHP meet up this Thursday)
A drag and drop cms called [microweber](https://github.com/microweber/microweber)
We had some issues with code that required register_globals. God how I want to be joking.
99% of hosts have this functionality. It's actually pretty dumb to not have it since it affects server load. Source: Ran a web hosting company for 8 years.
Ok a slight edit: &gt; Splat is only relevant to variadic functions and **ordered arguments**. Variadic functions are not at all relevant to named variables. A function/method could easily have both, so worrying about this as part of a splat RFC is useless. My point was that named parameters and variadic parameters are two entirely different conversations which can both work by themselves and together, and splat has no relevance to named parameters. 
"However, during a standard request only a fraction of that code is actually loaded. The following 50 classes are actually used" You can say the same thing about non-micro frameworks, Zend has 100's of features but you are not loading them / per request. I use Silex and it's a neat little framework but I think 'micro' part of it is just a marketing thing. 
http://php.net/manual/en/function.file-get-contents.php Get the content, then use pattern matching to get the data you want.
https://github.com/fabpot/Goutte use css selectors &amp; DOM instead of Regex on entire HTML
A couple years back, I wrote a tool to do exactly what you're trying to do (it was also for scraping course information from online college catalogs). It was just slapped together, and the example files I included might be outdated as far as the websites they were written for, but it might help as a starting point: http://50.56.243.212/xfer/college-scraper.zip /include/scraper is the generic scraper system, while /catalogs has extra stuff specific for catalog scraping. Look at /catalogs/index.php to see what query parameters you need to feed it. /catalogs/inst contains the college-specific scraping rules. It's been a long time since I last tested it, so there might be some things in need of repair. Good luck.
Web development doesn't compare to buying a physical product or getting your garden done up. It's one of the special cases where parts of the completed work will have to be reused. There are only so many ways to write "get a user from the database". In some way the comparison does work: If you buy a Three Wolf Moon shirt, that doesn't mean they can never make another Three Wolf Moon shirt. You bought the shirt, not the copyright. Of course there are limits; you (usually) can't re-sell the client's project in its entirety, but this is an area where you will have to contractually protect yourself. My contract just says the code belongs to me, and the client is granted a non-exclusive license in perpetuity (*after* fulfilling their obligations as per the rest of the contract -- which means if they don't pay in full, I have a copyright case). Only a few of the less experienced clients have balked at this, but after explaining the reasoning behind that clause, they agreed that it makes sense. Aditionally, "*Do you write them on their dime? Then yes, they belong to the client.*" fails to include other work you'd do "on their dime". Your hourly rate should cover the time you spend doing all the stuff you have to do that is not directly productive, but is necessary to run your business (doing taxes, making coffee, etc). Neither your tax filing nor your coffee belong to the client, even though technically they paid for it. 
I recommend [PHP Simple HTML DOM Parser](http://simplehtmldom.sourceforge.net/) You can find, loop, replace, get html or plain text, super easy and fun.
If you use unit tests, the error with "=" could be detected... :) And yes, I agree with you. I prefer readability on this case. 
This might be cultural. In Latin, for example, the sentence "if the day is hot" would be "if hot is the day." They like to put the adjective before the subject in if/then.
For reference, these are called Yoda Conditions. http://en.wikipedia.org/wiki/Yoda_Conditions 
Personal preference. Readability depends on the reader. In my eyes at least comparisons `null ===`, `true ===`, `false ===` are more readable if prefixed, especially considering that the right-hand-side expression can be long.
I've seen the suggestion to use if(true == $foo) before, but no one ever gave that explanation about it throwing an error when you mistype the comparison operators. I guess for some people, and teams, reversing the two can save time trying to figure out where a bug is, but I agree that it makes the code less readable. 
Yeah... it was reading Symfony examples that most recently made me want to post this. 
The only time that becomes wrong is when you mix the order within the code. That's just confusing. There is absolutely nothing wrong using one approach or another as long as you stick to it. Also if you are running complex function/method based operations they should not be inside if () in the first place. 
Possibly, perhaps for some people it would be easier to read if their native language also ordered comparisons that way. But I think you could objectively argue that the statement "if (foo() == 6)" still universally makes more sense when programming because it's clear that first we call the function, then once we have the return value of the function we check it against a static value. 
Talk about inception.
Because there are tons of jobs for Java. Those languages all have literally tons of jobs.
You're not in the US so maybe this isn't a problem, but if you intend on sharing this application with others then you may want to clear it with your school's administration. A student got expelled from University of Central Florida for creating an iPhone app which did what you're trying to do - it contacted the course schedules so students could see their schedules on their phones easily. Rather than congratulate him on making life easier for the student body he got expelled for improper use of school resources or hacking or some crap like that. Unfortunately I can't find any news articles on it - it happened a few years ago.
if (5 == $x) feels backwards and awkward to me too but ... I can accept that it's a personal preference. I hit a similar thing with SQL. Let's say you have tables named parent and child with a one to many relationship. The most common syntax I see is usually something like this: SELECT * FROM child INNER JOIN parent ON child.parent_id = parent.id The join part feels backwards to me. I prefer this. SELECT * FROM child INNER JOIN parent ON parent.id = child.parent_id In my mind I'm saying "we have a child, now I want its parent. What parent? The one with the correct id". Hopefully it makes no different to query optimizers. Of course the other variation in that SQL statement is whether you select from child and join parent or select from parent and join child. That still results in the same output but I think that change might matter to the optimizer depending on indexes etc.
The problem is that I can't get the data because if I use 'file_get_contents' on the 'showtimetable.aspx' url I just get an empty timesheet. So I need to pretend that I am the default.aspx and send some headers, but Im not sure which I should send. If/when I get the data the problem is solved, I just need a way to retrieve the data.
Luckily that's not a problem here in Norway, also Im not a student but my wife is, and she has big issues with the current system, it's horrible to use from a phone. :)
I tried using this first, and the class is super-easy to work with, but for the fact that I can't retrieve the data because I don't know what post parameters I need to send.
Did you check to see what that metric is for ZF2? Did you look at how big all of ZF2 is? Not only are you missing the point, you are also wrong. ZF2 loads much more code than silex, and is also much larger.
Wordpress' standards for PHP label this as Yoda Conditions (http://make.wordpress.org/core/handbook/coding-standards/php/#yoda-conditions) To me, it makes perfect sense after you used it a couple of times. Its a lot easier to look at the start of a line and figure out what the comparison is against than hunting with my eyes for where the comparison ends
To find the POST parameters use firebug's NET tab. When you use a form you can see what POST variables were sent. you can also use chrome dev tools
&gt; In Latin &gt; native language lol shut up. 
It did not change, ?: is a new operator introduced in 5.3.
php storm
For the same reason some people think camelCase is less readable than snake_case. Readability can be highly subjective.
phpstorm. never looked back. what kind of hilighting bug? never encountered any bugs. its devteam is also pretty fast with bugfixes, so you might want to check for an update
Netbeans is quite modern and works good. Don't know why it would feel like something from 1992. To be honest I don't understand your negativity.
PHPStorm error squiggles don't go away after errors are corrected http://www.reddit.com/r/PHP/comments/1ky4mm/phpstorm_error_squiggles_dont_go_away_after/
For a simple string echo, I find that Laravel 4 takes between 10 and 20 times as long as a straight single-page PHP file. That sounds bad, but it really isn't. The straight file takes half a millisecond, while Laravel 4 takes 8 to 10 milliseconds. Both of those numbers are dwarfed by network times, DB lookups, Web service calls, disk I/O, etc. Is your test environment using an opcode cache? That might account for the big slow-down, since Silex will have to read and parse dozens (hundreds?) of files with every call.
If you don't like any of the IDEs, maybe you shouldn't try another IDE? If Sublime Text isn't powerful enough for you, spend a weekend and nerd out of vim. With patience and some plugins I hear you never look back. My personal preference is to have Sublime Text open in one monitor and PHPStorm open in another, gets me by just fine
curl + xpath? (That's how I do it.. I logged into a clients CPanel and used xpath to query the element which says how much space is being used on the shared hosting)
OP addressed this. It's far too rare of an occurrence to hurt readability across the board. Especially if you consider that most such comparisons should be using `===` anyway, and you *really* have to fat finger to leave out two `=` characters (leaving out only one wouldn't create assignment). But, if it doesn't hurt readability for you and your team, it's a non-issue anyway.
I don't believe so no, unless APC is on by default or something. Regardless, without using a caching solution would it really be normal for a simple server response to take up to ~1.5 seconds, sometimes more?
I see a LOT of people post how awesome phpstorm is, but I've never really cared for the way it looked. I've posted several times in several posts over the last couple days about it, but I swear by Komodo IDE. The free version works ok too, but having the stuff the paid for version has integrated is amazing. I've also been beta testing the new version and it's going to really be nice once it's out.
I would recommend doing it in Perl, it has a lot better libraries for doing just what you are asking for. I wrote a similar program for my university, it took just a couple hours. I made a waitlist as well and let students use it for free. It became so popular that the university actually had to update their own website.
Coda. 100%
I switched to SumblimeText with several PHP specific plugins. I used to use ultraedit. Edit: These aren't full blown IDEs. They're really good text editors.
&gt; Coda Sorry, I don't use a Mac.
Why not create a variable for even better readability&amp;reusability and screws to order: $fooIsSix = 6 == foo(); if($fooIsSix) { 
&gt; far more error prone How far? We generate hundreds of thousands of lines of PHP a year and this has bit us maybe once every three or four years. I think it's a non-issue.
You shouldn't be downvoted. You're right that Latin isn't anyone's native language and I was just giving that as a random example. 
To add to other people's responses, some IDEs will spot this for you.
I've always found camel case more readable because snake case causes a pause within my mental pronunciation whenever my eyes pass over it.
If you are just looking to get the Websocket stuff up and running, rather than build yourself - I have created a real-time API that is fully hosted and it sounds right up your street. It is a JS and REST API that allows you to plug websockets straight into your app without having to worry about building the backend. You could create a basic chat app in about 10 lines of JS. It's scalable, secure (SSL) and free! You can sign up and find the docs at www.insto.co.uk - I would be happy to help you with any problems you have; this is a bit of a pet project for me, so any questions you have, fire away! Also, any criticisms or observations welcome
I typcially use Ruby or Java... Because they have a port or version of the amazing Mechanize library that was written for Perl. I think I remembef seeing a PHP version as well.
Native. Not natural.
I have done this before too. Sadly the OP is using aspx which can produce horribly broken HTML that xpath chokes on sometimes (not sure if that is ASP that does it or a combination of dumb developers and ASP). I actually had to run the page through tidy in order for xpath to actually parse it correctly. Gooooood times.
Yeah the mechanize library is fantastic, I'll have to check out the ruby port. If I remember correctly the PHP port wasn't too great, or maybe it was just the Dom parser that wasn't up to par.
If I were you i'd take a junior salary on the basis that you'll prove yourself. Then shift gears into the higher salaries next year. Best of luck.
I suppose that is always a possible concern... but it seems easier to cram the week of an interview then to remember a bunch of pointless crap all the time.
 if ($this-&gt;getContextManager()-&gt;getCurrentContext()-&gt;getNumericParameter() === 6) versus if (6 === $this-&gt;getContextManager()-&gt;getCurrentContext()-&gt;getNumericParameter())
It's a subjective preference, but as others have said, yoda conditions do have a real benefit (even if it's extremely small). I personally prefer yoda conditions to the standard method, but this seems like an extremely minor issue to quibble over. I've come across code that had yoda conditions, and code that didn't, and honestly it wasn't really that much of a bother to make the mental adjustment.
&gt; you could objectively argue that the statement "if (foo() == 6)" still universally makes more sense I don't think you could. I do agree that `foo() == 6` makes more sense, and I also think that most people in the maths and computer science fields agree, but I think that trend is a learned one, not some all-encompassing truth of the universe. If someone was brought up typing `6 == foo()` they probably have the opposite opinion, and that's fine. Maybe they've internalized it as "If `6` is what comes out of `foo()`" or something like that. Don't get me wrong, standardization in programming is very important and if everyone agreed on one method we'd probably all have a better time. But I think it's important to recognize the difference between a standard and a universal law.
I can concur, it's __absolutely maddening__. 
Definitely this. It's not a formal API so you can expect it to break. The question is which will break first? My money's on the regex.
I can confirm about the same frequency of being bitten. Or at least I hope this is the case.
if($foo) and then you can forget about it.
Correct. And even worse - these errors are notoriously hard to find. I think Yoda conditions is a good practice that makes the code safer. I don't really understand how one could perceive this as hard to read.
alright thank you. So is it alright to have 2 primary fields? right now in my "photo" table I'm using photoID as a primary. Then in my "tag table" I am using tag_id as a primary. The last table would have 2 foreign keys? photoID and tag_ID? Also how would i handle it if they type more than one keyword in the search?
In college, at least one instructor recommended doing _variable_ comparisons backwards. The thinking was that this would avoid any 'accidental' variable assignments eg if (6 == $foo) { } vs if ($foo == 6) { } It seems to be an academic perspective, and I think the code you're referring to is just following suit with methods
I'm sorry if you feel attacked, but do you not see the flaw in tightly coupling a method *signature* to the method calls? It doesn't take a genius to understand cosmetic changes to a method signature should not have an impact on the rest of your code. Renaming the argument $screen_name to $screenName shouldn't cause an error outside of the method itself. You're scoffing at the idea of named parameters adding complexity to the language because you think there's nothing hard about writing getFriends(screen_name="phpdrama"), and you would be right, but that's not the complexity people are talking about. It's the added complexity of maintaining backwards compatible code without altering existing interfaces. Where you see a lack of understanding from the core dev's previous cool responses, I see the core devs not lending credence to a bad idea. I believe you're acting like an impetuous young [upstart](http://www.ldoceonline.com/dictionary/upstart) by writing off their lack of interest as ignorance. You want named parameters in php? Fine, here you go. $friends = $api-&gt;screen_name("phpdrama") -&gt;include_user_entities(true) -&gt;getFriends(); It doesn't get any easier than that. Classes aren't meant to be containers for loosely related functions or have "30 methods which have totally different arguments". They represent state machines with a single responsibility. Anything else is a design flaw and not a weakness in the language. I already tackled your example of methods with only two parameters in my previous response. You should try reading it. Also, [you're the one that brought up code smell](http://www.reddit.com/r/PHP/comments/1lhvqw/named_parameters_in_php/cbze4sf).
&gt; This might be cultural Might be from Java background as well. If not mistaking, it has smth to do with null exceptions there :)
[Xdebug and You: Why You Should be Using a Real Debugger](https://jtreminio.com/2012/07/xdebug-and-you-why-you-should-be-using-a-real-debugger/)
This is really only useful if you have a long conditional that severely affects readability, or if you need to use that variable again in someplace other than the `IF` statement. Creating a variable and only using it once is (most often) useless.
Dude, exactly.
ideally I wanted it to display images with all tags, and if a non valid tag is put in it would just direct to a no results page. I'll take a look at that select2. I don't have any experience with jquery though. I was planning on making my site purely out of php at first then add on some ajax scripts or some jquery to kinda eaze into it. It would be a lot easier to understand what to do if I could find similar php examples out there but I haven't had luck.
Are you on Windows? I like to use [Fiddler](http://fiddler2.com/) as a great HTTP inspection tool. You'll be able to see your POST request and figure its parameters and cookies.
All of the orders are processed by paper type and printing method. The most problematic one is the plain copy paper one, which contains an invoice and some state-appropriate documents. These documents came in as PDFs, and were converted to images for printing (we pre-fill some sections of the state documents and want them printed with the order to speed up fulfillment). These are official state documents, so we don't have the option to convert them into a HTML/CSS layout, they have to look just like the ones off the official state website. The invoices were fine, but once we added in all the state documents chrome would crash either bringing up the print dialog or once you hit print (with an Aw Snap or Force quit respectively). I figure it was due to the size of the document (80+ pages, which is small for a real order) and the large print-quality images being used (converted from the PDF at 300dpi, which worked fine when I was only testing 2-3 state document sets). The idea would be that it wouldn't have to generate a PDF this way, just load the images (and since chrome supports background-sizing and is smart enough to print them at the best possible DPI they still look great). The docs are simply output to the browser with a specific CSS file, there very lightweight in terms of HTML on the page (all the state documents, being images from the official forms, are just a single div with a save and background) and work great in the browser window. In essence what we've created is a really long web page, nothing unusual about it besides the big background images. Like I said we've had this problem on both chrome and safari, which is what the entire office uses. Hopefully that clarifies things.
Select2 takes a normal select box (which you would populate from php) and turns it into something that is more useful. You don't need to know jQuery to use it, just include the script, initiate it and it'll do its thing automatically. It's a much cleaner way to validate tags than manually as users are limited by what's in the select box already and can't misspell something. If you want to do it purely with PHP you will need to filter the input, explode the text passed at the spaces (providing no tags have a space in them) and run a query on your database where tag_name = exploded[0] or tag_name = exploded[1] etc to get all tag IDs, then search for distinct images which match those IDs.
This, a thousand times, this.
I have been doing Yoda Conditions for years and made the conscious decision for me and my teams to switch. Does it really decrease readability? No, not really. Once you use it for a while it becomes natural. As long as it is adhered to the condition is always in the same place. Personally I could not tell you the last time I performed assignment within a comparison but this is not aimed at helping me. It is to stop more junior developers making these mistakes. It's a personal preference that should be decided upon by whoever sets your coding standards and/or the team. 
I don't know about you but when I see Yoda Conditions while scanning code I have a mini brain freeze. Ultimately I know that they both do the same thing but I could do without that little hiccup while trying to quickly scan code.
I see most disagreed with my statement; that's fine. IMO, creating a variable with a good name is not at all useless. Even if it's not immediately used in two or more places, a future maintainer will appreciate your good convention. Don't be so short-sighted, viz.
Not to mention shift being more reachable than underscore
Yup. Much safer to Yoda-condition String comparisons if you can't guarantee that the left side won't be null. Takes a little while get used to if ("yoda".equals(jediMaster)), but the reliability improvement the brief readability impediment. It's also recommended by most code quality analyzers.
you can use wkhtmltopdf which is quite fast and produces good results. although it isn't written in php.
It's a persistent key/value data store. Think of it as a more feature rich/robust kind of memcached. Its primary purpose is to give you a way to store data that is much lighter and faster than a standard RDBMS. It supports replication, transactions, key expiry, partitioning across many servers and much more.
so proper use of php is on your shitlist, interesting. 
 $var = false; if ($var == true) // false if (true == $var) // false if ($var = true) // true if (true = $var) // error in your case you would get true if you somehow use = instead of == or === in my case i get an error at line xyz. your preference is noted and i honestly don't care. what is the purpose of this post? this is not a platform for personal rants. 
Yeah, but does xdebug have DHTML?! Checkmate. 
or netbeans (or other IDE of choice) flags the line as an assignment being used in an evaluation condition
I'd use php curl, you might end up making 2 requests - a request to their page to select the course / login whatever - grab the cookie they give you, and pass it along with the next page request to get the intended timetable. libcurl for php makes this very easy. I'd then use regex but that's just me 
if ($foo=6) &lt;- always evaluates true if (6=$foo) &lt;- will be a syntax error and the page will not execute in VB, the single = in the if condition is an evaluation, not an assignment, so many of us who program in both will use the Yoda condition. but i still agree it is backwards it is one of those things that doesn't immediately kick out in a IDE parser like a ; at the end of a line in VB, or a ' at the beginning of a line in PHP to indicate a commented line (or -- if you've been writing more SQL)
Redis is like a database but simpler and faster. Before doing mysqli_query you first check redis to see if the results are in there, and if they are, you get them from redis instead. If they aren't, you do the mysqli_query and store the results in redis before the program ends so the next several mysqli_query will be avoided.
Or use PDO like a grownup... either way. :)
Completely off topic. But I prefer to us !is_null() in this case
Building a self service portal for use with sugarcrm. Building it to be extremely customizable and upgrade safe. The new part for me is thinking of anything a developer may want to customize without those customizations affecting core code.
Sorry, I pretty new to php and trying to teach my self. I am trying to figure out how to make an object move position based off of the coordinate giving. I guess all I really need to know is, how can I assign a small image a certain location on top of a big image? Example say I have a map of the USA and I wanted to put a star on florida when they click on florida. Or if they click on Maine A star shows up there instead. 
I tried this but couldn't get it to work with my css selectors..any other suggestions that are like jQuery to find items? 
simplehtmldom is incredibly slow + bloated. http://querypath.org/ is the best (speed + memory footprint) "jquery like" HTML parser in PHP.
tbh - I'm a big fan of regex when it's within a specific plane. It's just so much faster to get the information and then get out. Just my opinion, and far far away from the popular opinion. No idea why someone downvoted you though.
Yoda conditions prevent accidental assignment in comparisons. They are part of coding standards in many companies.
There's an [entire book on the subject of scraping data from the web with PHP](http://www.phparch.com/books/phparchitects-guide-to-web-scraping-with-php/).
Are you viewing this in a browser or are you trying to do this on the command line? If in a browser you could set the inline style for the element - such as this: &lt;div style="position: relative; background: url(background.png);"&gt; &lt;img src="avatar.png" style="position: absolute; top: &lt;?php echo $top; ?&gt;; left: &lt;?php echo $left; ?&gt;;"&gt; &lt;/div&gt;
[Ladybug](https://github.com/raulfraile/Ladybug)
Nice, thanks for sharing!
I agree. Regex is great, and fast. It's probably faster than parsing the DOM if you want a single piece of information found in a well defined place in a document, but it gets exponentially harder to justify as you require more complex data. Definitely worth a look if you haven't already seen it: http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags
How are you backing up the slow and bloated claim? 
I think that not putting fully braced conditionals where they should be hurts readability way more than Yoda conditions. if (true === $something) { do_something(); } Is way more readable, and easier to debug than if (true === $something) do_something(); Or this: if (true === $something) do_something(); This not only makes code wildly inconsistent, but it makes it hard for anyone on a team to pick up and use. 
Nothing like doing my job in my spare time. Here are some notes off the the cuff: * Missing class docblock for your Exception definition * You're pretty inconsistent with descriptive method docblocks * You shouldn't suppress things with @. It's really, really, really slow. * There's an SPL library to skeleton the Observer pattern. Probably worth using for your hooks system in Server * I'm tired so I'm not figuring it out, but odds are your Server main loop will leak memory. Long-running PHP processes are pretty notorious about leaking memory. Explicitly cleaning up things with unset() goes a long way to relieving these problems 
&gt;Surely they would be glad to get helpful volunteer work and would hopefully give you tips and tricks on how to interact with their web services. This was not my experience with college IT staff.
Redis does have disk persistence. Also, there are a few options for php key=&gt;value caching, if you just need simple k,v on a single box, you might want to look at using APC. You should be using php-apc anyway. If you need some more exotic features like pub/sub, transactions, list/sets, disk presistence, Redis is the bees' knees'. 
Looks good, I would call it a wrapper not a PHP library. Few small things: - I don't think you need to use @ prefix for socket* functions as they return false on failure. Even if they throw error codes that should be controlled by user not your wrapper. - There is while(true) loop, make sure the condition inside the loop can stop at any point. - There is no such thing as @return void, on that note methods should be given small description (classes too). - If you have CustomException as part of name space you just need to do @throws CustomException no need for full path. - Also @param takes more than @param bool. Identify actual parameter. - Document class properties too and you do not need to specify @package anymore since phpDocumentor 2 uses namespaces. Looks good otherwise, question why did you choose socket_* .vs steam sockets? 
Which can get annoying because sometimes you *want* to do an assignment in the evaluation expression
True, although sometimes you may want that behaviour.
you're going to have to get over it, if its the same thing either way then you should be able to read it fine 
* The reason I'm using the @ prefix for socket* functions is so that I can throw an Exception on error, instead of using the primary PHP Error. A possible reason to use OOP over the functional versions. * The while(true) loop breaks out when socket_write is finished writing. * Good to know about CustomException. I'll definitely edit that in the phpDoc. * Apologies about the @params, I knew i forgot something. I hadn't taken the time to essentially c/p the PHP code yet. As for using socket_* v stream sockets - its because I don't know anything about stream sockets yet. In fact, I didn't even really know they were a thing . This wrapper/library (it *does* have a multi-client server in it) came about as some really old crazy code I wrote when I was in high school (IRC Server in PHP) - so all the examples and knowledge I have are based on the socket_ functions.
I've forced myself to adopt PSR-2, just for the sake of following some defined standard. 
- building/writing a blog aimed ~~encouraging best practice~~ discouraging dumb shit in PHP. Like phptherightway's abusive jerk younger brother. - writing a saas project for developers - some minor side projects Pretty much everything interesting I'm doing is based in Laravel. 
A brief glance over the [standard on git hub](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) and it looks like the way that I used to code, with the braces on separate lines. I always found it more readable than the second example I gave. Do you happen to know the reasoning behind using separate lines for the braces being included as part of the PSR-2 standards?
This is the correct answer. Not "what is my preference" but "what gives the best result for everyone". 
Thank you. I didn't think about potential memory leaks. I'll do a run-through again with that in mind to clean it up, and I'll investigate the SPL library for the Observer pattern. I also google'd what you said about the @ suppression. The first few results I've looked at all say that it's negligible - except in cases where an error is actually thrown, as it's the error that is itself slowing things down. The reasoning behind using suppression is to throw custom Exceptions instead of passing it up to PHP's error handler; as I don't think I can utilize set_error_handler for *just* my classes. Again, thank you for your time. 
My boss does the following. Can't say I support it. if($whatever) { // things go here }
No, they're asking people to stop using non-standard syntax for bullshit reasons. 
Pick what you like, define it, stick to it. Done.
My personal code style for the last 15 years and, conveniently, PSR adheres to http://en.wikipedia.org/wiki/1TBS so that's what I use
yeah, I can't see doing that either.
I work with a few agencies and pick up overflow work for other developers, so I tend to just follow the style that they use if they've already put some code down. But I agree, even though it all runs the same, it should look the same and make sense.
Netbeans is a slug. 
My thinking about microframeworks is that it doesn't have a lot of layers of abstraction on top of PHP itself. Close to metal as possible. Examples would be not having complex wrappers around $_GET, $_POST, $_COOKIES, etc., or being able to use .php views/templates that's almost equivalent to just including a file. I think everyone has their own definition of what a microframework should or shouldn't do.
That was a cogent and well reasoned comment. You have convinced every one around you with nothing but your blazing wit.
I use Whitesmiths style: http://en.wikipedia.org/wiki/Indent_style#Whitesmiths_style In PHPStorm, I can't find a way to force it to leave the statement on the same level as the indented braces - it's really bothering me. Time to go back to Vim...
I like the curly brace on individual lines, I find the code is more comprehendible when you put the braces on individual lines.
use this: http://stackoverflow.com/questions/2571232/parse-html-with-phps-html-domdocument I used to parse html files using DomDocument and it worked spectacularly well with xpath.
Ah, I just glanced down it quick, and that point escaped me.
That's exactly how I used to feel until I started took over this project.
Well, I guess I have to agree named parameters could be a good addition to PHP. As you pointed out this discussion, named parameters are also useful on well written classes and methods with only 2-3 arguments, and I won't deny that. I have tons of model classes with method signatures similar to this: public function fetchByCountry($country, $limit = 25, $offset = 0); It would be nice to call the method like this: $users-&gt;fetchByCountry("CA", offset: 25); If you manage to get named parameters pushed through the RFC process I will almost certainly use them from time to time, but *[cohesion](http://en.wikipedia.org/wiki/Cohesion_\(computer_science\))* and the *[single responsibility principle](http://en.wikipedia.org/wiki/Single_responsibility_principle)* are why I prefer the parameter object syntax you mentioned. $args = $users-&gt;args()-&gt;offset(25); $users-&gt;fetchByCountry("CA", $args); Class [UserA](http://pastebin.com/du69ARkb) vs. [UserB](http://pastebin.com/n2jCsKkw). My point? Named parameters do solve a very real problem, but it's a problem that can also be solved without hacks using existing language features and solid engineering with the added benefit of flexibility and testability. I'm not going to go so far as to say, "Named parameters encourages bad design", but I think they're best used by experienced developers. Which -- depending on who you ask -- may not be PHP's core audience. *In short:* What's good for Python may not be good for PHP. *** Just a couple retorts: &gt; Changing the name of a method requires aliasing. Changing the name of methods in a parameter object requires aliasing. Changing the name of a named argument requires aliasing. I suppose so, but how would you alias a named parameter without adding more parameters? I would happily argue adding more methods to a parameter object is a smarter design choice than adding more arguments to a method. &gt; That's the hack I mentioned before, as there is no way to confirm that include_user_entities(true) has any effect on getFriends, and documenting it is non-standard. That's a fundamental principle of object-oriented programming. Altering the state of an object *is supposed to* change the return value of `getFriends()` in the same way setting the parameter `$include_user_entities = true` changes the outcome of `getFriends()`. $api = new Api(); $friends = $api-&gt;getFriends(include_user_entities: true); $api = new Api(); $api-&gt;include_user_entities(true); $friends = $api-&gt;getFriends(); The outcome of both examples is deterministic and *should* be the same, which means both examples can be easily documented. I'm not really sure what you mean by "confirmed". There are some edge cases when that's not true, like if your code blindly calls `$api-&gt;getFriends()` without first checking on the state of `$api`, but that's also a poor design and easily avoided. &gt; As for me bringing up code smell... you linked to some other users comment. That's not me. Yup, my bad. &gt; It sounds like they didnt really understand the conversation that was being had To be fair, the person keeping the minutes of the meeting may have been a secretary who *literally* didn't understand the conversation. I wouldn't worry too much over the curtness of minutes. The devs are busy guys and gals. *** Oh, and I did read about the `default` argument proposal, and generally like the idea. Especially because I keep running into core functions that have `null` as the default value, but passing `null` to the function results in a completely different outcome, but it would also make it easier to maintain code when the default value changes.
That happens to me on occasion. Cut + paste the code block back in, it'll "force" it to reanalyze and make the squiggles go away. Not exactly a solution but better than nothing, I suppose.
Questions like this are an irrelevant waste of time. There are no hard rules for formatting - only preference and recommendations.
I seem to have asked for thoughts and reasoning, so thanks for yours, I guess. Questions like these help people experience a larger amount of styles and gives people a chance to discuss and review the reasonings of each others choices.
Komodo IDE [link](http://www.activestate.com/komodo-ide)
 if($foo == $bar) { echo $foo." is equal to ".$bar; } else { echo $foo." is not equal to ".$bar; } After 10 years, IMO anything else is wrong. But it's really up to preference; however, when dealing with 10k lines of code and you have a few hundred or even thousand asinine new lines because of a shitty curly brace, it get's really annoying.
As a note on disk persistence, Redis supports two types RDB (Fast but data loss) and AOF (Slower* but less data loss). You can also mix them, so you can do backups, and have binary logs. Think of RDB like mysql_dump and AOF like replication (but to disk) using binary logs. Of course if your database dies and your using AOF only, it needs to be rebuilt, one query at a time from the binary log, so it's best to use both. http://redis.io/topics/persistence
If you like Krumo, then you might love the following: 1. firefox 2. firebug plugin 3. firephp plugin You can then dump php variables directly to firebug console rather than in the body of a webpage. I've found this to be more useful than xdebug, but then again I'm a old developer who grew up without the luxury of advanced debuggers. 
/** @noinspection PhpAssignmentInConditionInspection */ But at that point you have to question your priorities... 
PHP 5.4.19 is stable, there's almost no reason why you should be on 5.3 considering the changes and improvements. You should always ensure that your code will survive the switch though. Setup a dev environment, clone your web facing folders, and test, test, test.
Thanks so much! I've decided to try to build my own micro framework for learning but am looking at fuelphp or laravel for production, although I'm still wrestling with my ego that is screaming, "They aren't invented here!" Haha.
Thanks, I've bumped into a few old gists from that group, and was meaning to go to directly to the group - I appreciate the direct link! I'm still a bit too awed by some of the 'fancier' micro frameworks as they still appear to force me to use their conventions rather than know the 'basics', which they conveniently hide, but I've started reading through their docs anyway.
I don't know about that, in french we use the name first and the adjective second, and it's a stumbling block when we learn english which sounds yoda-like to us. English speakers will say "a blue car", french speakers will say "a car blue", and we think, in terms of importance, that it doesn't make sense to start with the color first before being informed of what object we are talking about.
P.S. There's one other dirty hack to deal with default arguments that I've dabbled with, which hasn't been discussed. It's a methodology employed heavily by jQuery. /** * Returns a new connection * * Examples: * $c = $db-&gt;getConnection("omgtheykilledkenny"); * $c = $db-&gt;getConnection("omgtheykilledkenny", "database"); * $c = $db-&gt;getConnection("omgtheykilledkenny", "database", false); * $c = $db-&gt;getConnection("omgtheykilledkenny", "database", false, 30); * * Skipping the $host argument: * $c = $db-&gt;getConnection("omgtheykilledkenny", false); * * Skipping the $host and $persistent arguments: * $c = $db-&gt;getConnection("omgtheykilledkenny", 30); * * @param string $password Password needed to connect to the database server * @param string $host The database server host name * @param bool $persistent Open a persistent connection? * @param int $timeout The connection timeout * @return resource */ public function getConnection($password, $host = "localhost", $persistent = true, $timeout = 60) { if (!is_string($host)) { if (is_bool($host)) { $persistent = $host; } else if (is_int($host)) { $timeout = $host; } $host = "localhost"; } if (is_int($persistent)) { $timeout = $persistent; $persistent = false; } // .. Do stuff here. } This works as long as each optional argument has a different type. By design it's not meant to allowing passing the arguments in any order you want (although you could do that too), but instead it allows you to leave out arguments starting from the first optional argument. It's a dirty hack, and makes the internals of the method ugly as hell, but it's come in handy a couple times.
You can use opcache on 5.4 (and 5.3) ... pecl ZendOpcache
Your post is the kind of shallow garbage people argue about when they don't know enough to discuss something that actually matters.
Yep. It's "different". It stands out as something that isn't what we expect. 
I consider your proposition lacking in merit.
Ah. Another bike-shedding thread. Regardless, I'll go with PSR-2. Stay standard my friend.
Kohana puts each brace on a new line, which does have a couple of advantages: it's completely consistent, and makes the conditions easier to read and comment (the Kohana source comments are very verbose), as you can see here: https://github.com/kohana/core/blob/3.3/master/classes/Kohana/Request.php#L64 That's much easier to follow than mashing conditions and blocks, and comments 'hang' together with code nicely without extra blank lines. The conditions are easy to scan, as they pop out of the code. I see the advantages, yet somehow I can only bring myself to use that style when writing Kohana projects, probably because it eats up quite a bit of vertical space and I hate scrolling. But when in Rome ... 
I mentioned in the post that I'm aware that the justification for it is that it's a way to prevent a coder from accidentally using "=" instead of "==", but in my opinion the potential for that one coding mistake isn't a good justification for swapping the local order of all comparisons. In my opinion it's an awful solution to a negligible problem.
oh my god does that turn php code into a perl regular expression that is then executed. jesus fuck.
Right now working on my tan in Hawaii, when I get back continuing to work on my pointless framework that I've rewritten many times: https://github.com/mullanaphy/phyneapple Also working on my Unhelper library, comes with a Utility class that's filled with unhelpful methods and writing a SQLish based ORM for CSV files. This project is pretty much any time I see something like shuffle sort and want to implement it. https://github.com/mullanaphy/unhelper **Edit:** Also using JS/Canvas to write an RPG, and Objective-C for a beat 'em up.
No way, it just looks off.
That same Wordpress standards page suggests things like calling functions with spaces around each parameter... eat( 'mushrooms' ); Who does that?
Definitely look at Kohana, which was designed as an HMVC framework. Here's some info on how to work with the triads and internal/external requests: http://kohanaframework.org/3.3/guide/kohana/requests That might give you some inspiration. But to be honest, unless you're going to distribute your code across servers, which is where the real advantage comes in, most often there are easier templating solutions (like partials).
Aspx sites are never really much fun to parse, thankfully in your situation, your site is very simple to parse. You'll need to start a curl session within PHP, be sure to enable CURLOPT_FOLLOWLOCATION as I believe the post you'll be making will redirect. Next, make a get request to http://timeplan.uia.no/swsuiakrh/public/no/default.aspx and parse out values of the hidden inputs for __VIEWSTATE, and __EVENTVALIDATION, we'll be using these to post them back to the same url we're on. You probably won't need to post the following values because they're blank, but it can't hurt. Set these to empty string: __EVENTTARGET __EVENTARGUMENT __LASTFOCUS Set these to the values you parsed out from the initial get of the page containing the form: __VIEWSTATE __EVENTVALIDATION Set the following post values as you would have filled out the form to get the data you desired: tLinkType tWildcard dlObject lbWeeks lbDays RadioType Set bGetTimetable to "Vis timeplan" Submit the curl request, now you should be able to parse away the resulting data however you'd like, the fun part as you so put it. Again I mention you are lucky here mainly because this is a very simple site, some aspx sites have loads of javascript that manipulate form values before then submitting the form, these aren't very fun as you would need to replicate all of the javascript to PHP to properly execute. In that case, I generally switch AWAY from PHP and move to something like CapserJS &amp; PhantomJS which are essentially javascript headless webkit browsers which also have fully functional javascript engines. 
If the overhead of your framework takes up the largest part of the execution time, you're building a project that is small enough so that it doesn't matter which framework you use. If the overhead of your framework is _not_ the largest part of the execution time, it doesn't matter which framework you use. Pick whatever framework you like best. 
You'll see dependency injection among most of the better frameworks. As a general class design aspect at a higher level than say MVC, http://en.wikipedia.org/wiki/SOLID is an important one to follow for the most part. Too many design patterns to actually list that are probably used in common frameworks. Singletons, factories, facades, proxies, visitors, decorators, lazyloading, ad inf. Take a glance at the gang of four (be wary of reading the book and then treating every problem as if it's a nail and your newly acquired hammer can solve everything)
And, in my ~~un~~biased opinion, "whatever framework you like best" should be either Symfony, Silex or Laravel. 
I'm not really sure what it does exactly, but it runs (sometimes)..
I wouldn't recommend using regex to parse the results on the tables -- too prone to error if they insert something unexpected in the text, better off using one of the DOM based solutions suggested by others. 
The persistence is configurable and is typically delayed, so it's not like it's writing to disk every time you SET, nor is it reading from disk each GET. As a PHP developer, if I wasn't using it as part of a framework or bigger application, I'd just use it to for things like caching SQL results, keyed by something like the MD5 hash of the query. For whatever it's worth, I used memcached for years, now I use redis for performance and persistence. Both are easy to set up. Fun fact, the popular IRC bot http://hubot.github.com/ uses redis for persistence for its "brain".
Obviously you prefer some other standard, but I'm curious what makes you think it's "better" rather than just something you prefer.
Yes. Because it's compiled it's super extremely fast. But raw benchmark performance should not be a significant factor in a technology decision, unless you have some specific need.
Thank you for the plug :)
I use Phalcol because I really like it, it doesn't matter if it's fast or not... It's very solid, although I don't like the models, I use Eloquent + Phalcon.
But it's a overkill while you're prototyping.
Have you ever wanted to save a value in memory, and have the value exist between page requests? Maybe even have the value exist across web servers? For example: Page Request #1: &lt;?php $counter++; echo "You are visitor {$counter}!"; // Outputs "You are visitor 1!" Page Request #2: &lt;?php $counter++; echo "You are visitor {$counter}!"; // Outputs "You are visitor 2!" We both know this doesn't work. At the end of each request PHP destroys the $counter variable, but in a simplified way that's what both memcached and Redis do. They allow you to store a value in memory, and it stays there until you delete it. For example: Page Request #1: &lt;?php $redis-&gt;incr("counter"); $value = $redis-&gt;get("counter"); echo "You are visitor {$value}!"; // Outputs "You are visitor 1!" Page Request #2: &lt;?php $redis-&gt;incr("counter"); $value = $redis-&gt;get("counter"); echo "You are visitor {$value}!"; // Outputs "You are visitor 2!" As you can see in the examples you increment a **value** that's **stored** in Redis by referering to the value's **key**. In this case "counter". It's just like how arrays store values using keys. &lt;?php $my_array["counter"] = 2; echo $my_array["counter"]; This is why Redis and memcached are called **in-memory key/value stores**. They're used to store a value in memory and access that value by it's key. Both Redis and memcached are programs running on your server that PHP communicates with to store and read values. It works exactly like MySQL, which is also a program running on your server that PHP communicates with to store and read values. The primary difference between MySQL and memcached/Redis is MySQL saves the values on the hard drive, while memcached/Redis save the values in memory. Reading and writing values to a hard drive is many, many times slower than reading/writing values to memory, which make memcached/Redis lighting fast. *** How can you use these technologies? A popular use for both memcache and Redis is caching. For example here's a simple method to query the database which includes a caching layer. public function query($sql) { $key = md5($sql); $value = $this-&gt;memcached-&gt;get($key); if (!$value) { $value = $this-&gt;database-&gt;query($sql); $this-&gt;memcached-&gt;set($key, $value); } return $value; } // This method call will send the sql to the database, and // return the results. $members = $db-&gt;query("SELECT * FROM members"); // This second method call will return the results from cache, // which is much faster than querying the database. $members = $db-&gt;query("SELECT * FROM members"); Another popular use for memcached is session storage. You know, those values you assign to $_SESSION. Behind the scenes PHP typically stores those values in a file on your web server hard drive. You can have PHP store them in memcached instead, which allows you to share session data across multiple web servers. Redis has become a very handy and very fast in-memory database, and can often replace MySQL in some cases. In fact some sites *have* completely ditched slow databases and use Redis exclusively. Anything you can store in MySQL you can store in Redis. The downside is Redis does not understand SQL, which means you can't just query Redis the same way you query a database. Replacing your database with Redis requires some creative thinking. *** Whether you choose to use Redis or memcache depends on your needs, but I can guarantee you won't find a scalable website on this planet that's not using one or the other or both. Some of the key differences between memcache and Redis (Which depend largely on how you configure them): * Values stored in memcached are volatile, which means memcached may delete them when ever it wants. For instance when it's running low on memory. New values overwrite old values when memory is running low. * Values stored in Redis are considered persistent. Your server could lose power, and the values will still be there when you regain power. Redis accomplishes that by periodically writing the values to disk. * You can only store simple strings in memcached. If you want to store arrays or objects you'll have to serialize them to strings. Some client libraries do that for you. * You can basically only store strings in Redis too, but Redis supports some higher level concepts like lists, hashtables, and sets. * With Redis you can save values across many "databases" (Like different places in memory) whereas memcached has only a single "database" (One place in memory where all values are stored). In short, Redis is like memcached on steroids. Memcached has about a dozen commands to set, get, increment, decrement, and delete values, while Redis has over a *hundred* commands. However Redis does not necessarily replace memcached. Many organizations use both, as each excels at specific tasks.
Trying to reverse engineer the department of lands REST API so I can get data out of it. Nothing in my spare time at the moment.
I'm the author of the already mentioned Kint: http://raveren.github.io/kint/ --- [Screenshot](http://raveren.github.io/kint/img/preview.png) | [Available themes](http://raveren.github.io/kint/img/theme-preview.png) | [Trace screenshot](http://raveren.github.io/kint/img/trace-preview.png) To answer OP's concerns &gt; 1) Ability to return the HTML instead of just printing it $output = @d($var); &gt; 2) Start Krumo fully expanded instead of having to click on each one !d($var); The prefixes are parsed by kint itself and are used instead of vanilla PHP parameters to alter Kint's behaviour. There's a [WIP branch](http://raveren.github.io/kint/) too with more cutting edge features (like support for returning HTML-free output).
It doesn't matter as long as the code base is consistent. Arguments about brace style are dumb.
I disagree, pointing to the fact that branching and merging with git is so easy and so flexible.
Allman style is what I prefer. It just tends to be easier to read. While it violates PSR-2, I still see it is a greater advantage to have cohesive braceing than to follow the exact standard on this one. 
The overhead for Phalcon is exceptionally low because it is compiled and included into php as a package. Because of that it is optimized for speed more so than any framework built with PHP could be. However while Phalcon does provide exceptionally low overhead to your application, if your application code is slow (inefficient, or otherwise) then it doesn't matter about the overhead of your framework choice. In short yes Phalcon is really that fast, and yes you will notice some performance boost from its lower overhead; however hello world applications do not simulate real world use and so those sort of benchmarks are more dick slinging contests: it doesn't matter how impressive your result is, its more how you use the tool you have to hand.
excuse me? in latin? how many latin-speaking programmers do you know? also, english is the universal program-writing language (fuck people who comment in their native tongue!)
I believe you need to take a step back and evaluate your project's requirements before choosing a framework. Simply choosing phalcon because "it's fast" is a bad way of doing it. Does it really matter if it's fast? Seriously, ask yourself if your application is heavy enough that it'd make a noticeable difference if the framework was compiled into a PECL extension. I'm willing to wager it's not. Additionally, are you willing and able to manage the servers? You're going to have to update and manage that PECL extension. What if the PECL extension contains bugs or security vulnerabilities? Are you going to patch the C code and recompile it?
I prefer version 2 (but with additional spaces after the if and before the curly brace). My reasoning is: it reads just as good to me as Version 1 and I don't waste vertical screen space, so I can see more of the structure at once. Might not be much for small methods, but when you have a few IFs in a method, it can add up.
&gt; 10k lines of code If that's in one file, you might be doing something wrong there... 
My first reason to use Phalcon is speed, but now the big reason is your argument. :)
This was meant to be a thread about sharing your thoughts, and it'd be awesome if you could elaborate on what you don't like about the standard that he linked to, and what you see as a better way to go about things. I'm genuinely interested.
That is starting to grow on me now that I've stopped putting the initial curly brace on it's own line. Edit: The not wasting vertical space, is what I'm referring to.
cause this never happens while ($row=mysql_fetch_array($resultSet)){ #do stuff }
Lol "non-standard syntax". You don't even know what the fuck you are talking about.
It shouldn't happen, cause: * You shouldn't be using mysql_fetch_array ;) * It's still bad programming practice
&gt; bike-shedding &gt; PSR-2 I agree with myself.
Hey, tell me again about "non-standard" syntax. Where can I find that tackled in the PHP parser? I see you using words without actually knowing what they mean, just glance again on what idiomatic code means, emphasis on this line "the use of an unusual or notable feature that is built into a programming language". Style doesn't pertain to the idioms of the language. So either shut the fuck up, or step up the game and show that you can use words, and understand their meaning.
I can't imagine one scenario where a file of 10k LoC could be good.
Didn't you know that *his* standard is the only standard that's right? Fuck every other person following widely adopted standard.
*yawn* 
alright, I'll give you that. I meant you shouldn't use assignments in if-conditions... didn't even think of other conditional constructions ;) while we're at the topic... is there actually a way to do the thing you mention without an assignment? I currently can't think of a way...
There's that scenario where you have a class that has lots and lots of methods. It's not good or bad, it's just that way because it's the way to go in that specific case.
This is the most surprising code style I've seen in a while, but I have to admit it has a little something nice for readability.
&gt; My reasoning is: it reads just as good to me as Version 1 and I don't waste vertical screen space, so I can see more of the structure at once. Micro-optimiztion! :D
Is there a reason to do that? Currently PHP-FPM, APC, Nginx with SPDY, Redis, SQLite. I'm also looking for using Lua directly inside Nginx, and maybe even move some of the application on OpenResty. Node.js with Nginx WebSocket proxy for realtime-web stuff. 
If it has than 2 lines I do if(condition){blah;return true;}else{blah;return false;} Otherwise I have the opening curly bracket on the same line as the if I also like to have else as }else{ Just a habit I've stuck to. Call me a disgusting programmer. &gt;Edit: formatting
This is PHPStorm specific, but agreed :)
I have seen a few of these frameworks and noticed that at the end of the day you sort of build the same thing. I built a slim type framework by simply doing URL pregmatch. if (preg_match('~^/products~', $url, $match)) You sort of end up with the same thing once you start expanding out the token stuff. 
+1 Back! Smarty rocks. So far I think its quite underrated and from what I have seen it builds super fast sites. 
+1 SILEX! Great call. laravel looks interesting, I have tried it and thought not bad.
Maybe, but I'm quite sure that I'm at least 0.02% faster in interpreting code than those heathens that put the curly brace on an extra line.
Agreed. Before Slim existed (or maybe before I knew it existed, this was several years ago), I started a project with a friend and we thought the frameworks *du jour* were too heavy, so we created one. https://github.com/aaronbieber/breeze. It never got off the ground because we don't actively develop it and now there are a plethora of "micro-frameworks" to choose from. The thing about Slim (and its Python counterparts Flask and Bottle) that I don't like is that you are encouraged to put all of your app code in a single file, so you have to jump through some hoops to set up the file separation logic yourself, which always feels a little kludgy. Our implementation in Breeze is the pattern I prefer; auto-load a class based on the desired controller, separate all controllers and views into their own scripts. That's just personal preference, though.
Some good comments. The best info I read was that because Phalcon is a C extension, upgrading this C extension is going to be a nightmare. If something breaks and your system is not longer working you are gonna have to debug C and the whole extension system. Upgrades will require you to build the updated extension and if that doesnt work you code is broken. With silex and any other framework, you can deploy the code by simply pushing new PHP code. I love that Phalcon is quick, but I don't like the potential complexity of the extension that you now 100% rely on. That is scary. If you really wanted speed. Maybe look at GO by Google? This page has some scary benchmarks http://www.techempower.com/benchmarks/ GO was able to return 1 row from a SQL database 76,024 in the time period. Silex 2,364 Phalcon 7,458 PHP 2364 (orm approach) 36,605 (raw sql approach). 
Could we get an example architecture using your idea? Perhaps in a nice diagram?
yeah silex was like this as well. They now have $app-&gt;mount("/subroute", include('subroute.php')); Which does just what you say. They are all getting really similar. Generally my choice for a framework is being able to write as little boilerplate code as possible. Very cool.
 - Use of unicode in variable/object names ( ex: $…, $é, $ƒ ) - Irregular and misleading indentation - Throw ugly constants everywhere 
This is exactly what I was thinking, but I will say on some of the larger projects I've done, once we had squeezed out maximum performace from the DB it might have been handy to get some more from PHP itself. That said, I highly doubt I'll be working on a project like that again any time soon.
Dude, with all respect, I know all this already, hence why I asked the question. I was just curious more than anything else!
Oh you have to take a line out this guys code. http://www.reddit.com/r/PHP/comments/1l7baq/creating_a_user_from_the_web_problem/
Make sure your DB connection is a singleton. Heck, make all your methods static just to be sure. Anyway, I'm sure that your code doesn't use enough `eval` and could use a bit more `goto`.
Use ereg_* wherever possible. I still see that shit in tutorials.
My comment here is that it sounds like you have done everything right. What I am thinking is that have you profiled your code and figured out how long each of you functions are taking. Eg just storing some timing code. So you know your DB is taking .001 of a second or is it taking 5 seconds, is the PDF taking ages, or is the HTML generation taking ages? First get some numbers. Once you get some numbers see if you can speed up some slow functions. Maybe you are not indexing your DB queries so they are slow? Putting the index on a db column would make you whole system 100x faster. The last option is bigger machine, but I do not believe that you cannot make you code faster? 
&gt; One letter variables Don't hate on my $i ! ;)
LAMP user here. Mostly because it's what's on 99% of my clients' boxes.
It was documented a little in the [old nfs documentation](http://docs-v1.vagrantup.com/v1/docs/nfs.html). Sun/Oracle says it doesn't affect Windows in the same way, but my testing still showed similar and significant performance degregation. &gt; John and I did extensive benchmarks using various solutions for the VirtualBox shared folder performance issue. These benchmarks were run on a real-world rails project with a test suite of over 6000 tests. We ran a single unit test file and timed the average of several runs: &gt; &gt; &gt; VirtualBox Shared Folders: 5m 14s &gt; &gt; Host File System: 10s &gt; &gt; Native VM File System: 13s &gt; &gt; NFS Shared Folders: 22s &gt; &gt; NFS Shared Folders (warm cache): 14s &gt; &gt; &gt; As you can see, while there is a small performance hit compared to having the files natively on the VM, it is perfectly reasonable versus true VirtualBox shared folders.
yes, it is so fast, because it is native code. pretty much end of story. i think it would be cool, if more frameworks could ship as native code (at least parts of it).
Don't even bother quoting strings. And make liberal use of extract() after running 'SELECT *'. Be sure to turn off all error reporting of any type. Oh! And put spaces in your property names just for fun.
that is never the way to go. wrapping "class {}" around 10k lines is neither OO nor procedural but a poorly designed mess. 
Don't forget to manually add backslashes to everything while you're parsing REQUEST there. And because everyone has magic quotes turned off these days, don't worry about checking to see if it is or not.
Well, this is obvious: MVC is not a framework, its an architecture. People trying to use MVC as the way they structure their application code are going to have a bad time. 
I don't really see how the section titled "Why am I wrong?" actually explains why am I wrong If I choose MVC as the best pattern to build my application
 $i++; I've always and will continue to always use single letter variables exclusively as counters.
Don't forget to suppress warnings using @!
While I mostly agree that there are many frameworks out there that don't encourage a clear separation of concerns (the main purpose of MVC), placing all the domain logic into a service layer leads to an anemic domain model and a service layer that looks more like a bunch of transaction scripts. This is not OOP. http://www.martinfowler.com/bliki/AnemicDomainModel.html
&gt;directly requiring another class-file inside a method of a class Apologies for my ignorance but could someone please clarify why this is bad practice?
Use spaces instead of tabs. *hides in hole*
Magic quotes and emulating it in code, is the wrong solution to *any* problem.
Mixing HTML and PHP like there's no tomorrow. Failure to know how to use "include" Failure to see the problem with 40 includes at the top of every page after you learned about the magic of "include".
Presumably the scope of that external class will be within the class doing the including, so it won't be visible anywhere else. I'm just guessing here, but would the include keep getting run each time the wrapper class method is called? Edit: no, it doesn't. Once an external class file has been include_once() in another class method, then it is not included again the next time the method is called.
Use no classes at all and put everything in a single file.
This guy has regretted posting that script to reddit for far too long.
I'm using a pretty standard LEMP with Redis and Beanstalkd tacked on. The reason I've come to prefer Nginx really isn't the performance gains. It's the configuration. Don't get me wrong, I find them both to be unbelievably headaches when it comes to doing anything non-standard, but the Nginx configuration files have a much cleaner syntax IMO. It's really JSON vs XML for me. The biggest downside with Nginx is a lot of the desperate Google queries your bound to make lead to illegible Russian forum threads. 
&gt; Don't know if Norway has any similar laws on the books. Thankfully, nothing on the scale of DMCA. What we have wouldn't be used lightly by the University, police or prosecutor's office.
Don't forget to use [non-breaking spaces](http://en.wikipedia.org/wiki/Non-breaking_space#Keyboard_entry_methods) as variable names!
Think the entire tech community has seen that post when it comes to this subject. Always a funny ready.
throw all your code in try blocks
Thought it was just me who thought the docs were bad. Found most answers via stackoverflow.com since it was not in the docs. But once you get the hang of it, it's great.
Haha yes. I began simplifying my setup by writing a tool in C that wrote nginx config files and set up hosting directories based upon my inputs. This was as a way of learning C and needing a simple project to cut my teeth on.
I always liked the second style. Saves a line right? Third style is...weird. Anyway, it doesn't matter which I like. What's more important is what style and naming conventions are used in the code I'm currently working on! Consistency in style is more important than preference. If the original author of the code I'm hacking at used the first style, then I use the first style. If they used the second style then I use that and so forth. This goes for all other style conventions as well such as method naming and CamelCase style. object-&gt;MethodName vs object-&gt;methodName. and so forth. It's most important to stick to what the rest of the code already uses.
At least PREG_REPLACE_EVAL has been deprecated in 5.5, so it should trigger and error w/E_STRICT to help find it and kill it with fire.
* Using mysql_ functions instead of PDO. * using the @ to suppress errors * using or die() instead of triggering an error or thowing an exception * not using phpdoc to document classes * not quite php, but editing code on production * using a global variable PERIOD * calling your array conventions an API (ahem, Drupal forms...)
Dude, calm down.
Slightly worse: Using REQUEST vars directly. Combines the GET/POST/COOKIES together depending on the variable_order directive which could vary from server to server.
aside from the answers already given, I'd say it's a sign that there isn't a standards compliant autoloader present, which would indicate many more problems up ahead
Sadly you can't just set an error handler for the socket functionality. It would be nice if they'd either add this functionality or make fatals issue Exceptions instead of error messages. The reason suppressing errors with @ is discouraged is that it's mode of action still invokes the error handler set with set_error_handler() which does consume time. It sets the error level at 0, but if you have a custom error handler it may still result in some or all of that overhead.
&gt; Make sure your DB connection is a singleton. What's wrong with a singleton for your DB connection if I may ask? 
Twig, which is pretty "heavy", can be installed as PHP-extension: http://twig.sensiolabs.org/doc/intro.html#installing-the-c-extension 
OK, so let's be constructive, join in if I miss any reasons, or I'm just plain wrong - it happens. I'm not incredibly qualified to write this, I just think it should be written: * Multiple class definitions in a single file In six months you'll be pissed off at yourself because you lost your classes, or worse, someone else will be trying to find them and running a search every five minutes. Keep one class to a file. * Recreating register_globals in usercode Recreating functions in PHP is a bad idea in general, PHP's native functions run much faster than user functions because they're compiled in C. register_globals is one of those functions that seems like a great idea - it registers a load of stuff from $_GET and $_POST as variables, which saves some boring, repetitive code. It's also pretty indiscriminate about that, so you can end up with nasty shit in variables you didn't even expect to exist. Unless you're covering your ass *well*, don't enable register_globals, and don't just convert $_GET and $_POST to respective variables. * Inserting these created globals right into an SQL string, without any kind of validation or cleanup This is a classic programming cockup; if you don't filter characters out of variables that are added into an SQL string, especially if you're just taking them from $_GET or $_POST input, then it's pathetically easy for a hacker to enter their name as ' "; DROP TABLE `users`; ' and kill your server. Or worse. Use mysql_real_escape_string() or even better, use PDO instead of the classic mysql_query(), to sanitize your inputs. * mailing class that gets everything in its constructor method and sends immediately (no methods beyond __construct) This is overbloated programming; the class doesn't add any real value. If you're doing everything in a class in the constructor method, in general you're doing something wrong. In this case, you could essentially send the email in a function, creating a class that is immediately irrelevant is counterproductive, unless you're making a nice little placeholder so that you can easily expand on it later. * Saving passwords unhashed and unencrypted in a database Another classic; if someone uses SQL injection, described above, to break into your database, the first thing they'll do is head for your users table for the juicy username / password / email buffet, and then you're no better than Sony. Store passwords using MD5("password") in MySQL, and then check them using MD5("inputpassword") = `password`, in PHP or in MySQL. The data in the table is essentially useless for discovering the password, but still fine for logging in. OK, bored and going back to real work. Anyone want to help with the others?
Rather than use an array, encode the data in a string using :: as the delimiter, and then use multiple explodes it into an array to access and change the info. Bonus points for not using a while loop to reassemble the array. $userinfo = 'username:johnathan::password:123456::signupdate:10/12/22'; 
&gt; dick slinging contests Calling /u/AWildSketchAppeared &amp; /u/Shitty_Watercolour - we need an artist, STAT!
MVC is the bare minimum to get you on your way to proper separation. Take Symfony2, for example. It has Controllers, Repositories, Entities, Domains, Managers, etc etc. This is because all these different classes have a very specific purpose. Controller pass user-supplied input to the rest of the app. Entities are dumb data holders. Repositories interact with your data source, be it a database or a remote API. You use the proper tool for the job, and don't try to cram everything into a single Model class - it doesn't make sense. 
Nginx, PHP-FPM, Varnish, Redis, and MySQL Nginx + PHP-FPM has been a match in heaven, it's speed is beyond belief compared to my setup with Apache 2, but i'm still running into some issues with dynamic hosts and deep directories. Varnish for front-end caching, which was stupid simply to get running and really relieved the load on my server. Redis and MySQL for my data, every hour all data stored in Redis is saved to the MySQL as well as using MySQL to store my persistent data. Managing the two has been amazing with phpMyAdmin and Redsmin.
&gt;2013 &gt;MD5 
That approach is also suspect to race conditions, check out: http://alekseykorzun.com/post/49520668105/how-to-gracefully-handle-cache-expiration
it will also not work half of the time, horrible user experience.
* Store your HTML templates inside a database, then implement your own parsing system to replace tags with values, process conditionals and loops. * Install and instantiate multiple database abstraction libraries, so you can choose which abstraction library you want to use at any point in the code. * Do your validation by nesting each if statement inside the previous one, followed by your handling logic at the "peak", then have a slope of else conditions at the end which handle each error condition. * Take a component of your site such as the admin area and make all tasks relating to it handled by a single function. This function must not branch logically into other functions, but contain all logic directly. Copy and paste code within the function if needed. If statements, validation, loops and constructing database queries should all be done by this one function. It is okay for it to be over 1000 lines long. * Include comments like "Don't know why we keep loading this instead of storing it somewhere" before loading some common piece of data from the database for the 12th time in one request. * Make your config file define config, but also perform other tasks such as starting a session and/or including other files. That way, when you want to include it from a loosely related script, you can't do so and have to resort to scraping PHP code. * Forget cron jobs. Make your site do scheduled, long running tasks during a user's HTTP request. * If you have calenders, implement them without using a loop. Use 6 if statements for the possible blank boxes at the start, then copy and paste the main day box 31 times and wrap the last 3 in if statements. Then do a further 6 if statements for the possible blank boxes at the end of the month. Write a comment along the lines of "it's easier this way". Give the calendar system a name, so you can refer to it in conversations and suggest to other developers that they copy it and use it in their projects. * If at any place a query fails, echo the query along with a descriptive error message, then call die(). Exceptions and error handling are for wimps. * Turn on display_errors and set error_reporting somewhere in a deeply included, common file. You can never trust the php.ini's error configuration to be correct for your environment. Hiding it away in an included file will make it difficult for those pesky sysadmins to find and remove it. * Include comments like "I think this might be wrong" right before some complex code, so that other developers will check it every time they look at it. Of course, your code will be correct. * Indent your markup, but occasionally indent it wrong to keep other developers on their toes. * In a common file, check if magic_quotes_gpc() exists or has a true/1 value. If not, loop through every input variable and manually add slashes to it. Also add slashes before inserting it to a database - this will store them in the database escaped. Use stripslashes() when outputting it after selecting it from the database. * Before inserting data to the database, convert special characters to their entity codes (ie. htmlspecialchars()), but only do this on some fields. When outputting content, use htmlspecialchars() on the fields that weren't converted already. * Rather than use a join query, select your data from the primary table, then loop through the results and run a separate query in the loop to select the related information from the secondary table. * If you're using MySQL, use "WHERE some_field IN (SELECT ...)". * Don't use auto increment fields. Make all your IDs 32-character md5 hashes of the current time(). Multiple inserts to the same table in the same second will fail, but you plan on leaving your job before this goes into production so it'll be someone else's problem by then. * Create multi-column indexes on your database tables, but do it in a way that makes them never used. For example, if your query selects using only field_a, make field_a the second column of another index. * Create redundant indexes on your database tables. For example, index field_a, then make a second, multi-column index that indexes field_a and field_b in that order.
For a counter ... okay. For anything beyond that: I will cut out your heart and show it to your dying eyes!
Yes, if it's a left join then reversing which table is on which side of the join will change the result if there are parents without children or (a foreign key constraint will probably prevent this) children without parents. I was mostly just talking about the order around the = after ON. That won't change the result and I hope it doesn't change how the query is performed.
&gt; Store passwords using MD5("password") in MySQL, and then check them using MD5("inputpassword") = password, in PHP or in MySQL. The data in the table is essentially useless for discovering the password, but still fine for logging in. Don't use MD5 for storing passwords. Use http://ca3.php.net/manual/en/function.password-hash.php
Make sure you allocate your CPU cores properly and that your RAM allocated to VM is greater than your database size. Also it could be network look up issue or improper configuration (such as connecting to a MySQL/Memcached server locally when it's not installation causing a time out) or connecting to a remote daemons (slow). 
+1 for using Varnish, more people should do that.
Can't agree more, it's a fantastic lightweight tool that drastically increases static page performance. Varnish + Redis is the difference of a 140ms page loading in 16-20ms
Actually, I'm thinking of hardcoding ini_set('display_errors',1); error_reporting(E_ALL); Can't have that we are not informed if there are errors in our production code, now can we?
This is a good one [PHP Objects, Patterns and Practice](http://www.amazon.com/Objects-Patterns-Practice-Experts-Source/dp/143022925X) Also you may want to check out this site: [PHP the right way](http://www.phptherightway.com/) As for general programming books: [Clean Code](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) [Patterns of Enterprise Application Architecture](http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420) [Design Patterns: Elements of Reusable Object-Oriented Software](http://www.amazon.com/Design-Patterns-Elements-Object-Oriented-ebook/dp/B000SEIBB8) 
IIRC, that twig extension implements only a few methods from the php version which are slow. 
I only ever use them as temp variables, too. $importantVariable = 0; $v = $importantVariable; //stuff $importantVariable = $v;
I am calm. Hence the smiley face :) 
Your ideas sound frightfully as if you've actually seen them in reality?!
Awesome. Thanks. I just got em.
how about $temp? $temp and $var were my favorite confuse-the-shit-out-of-future-me variables.
A passive aggressive nod to people you have worked with in the past I sense. 
Oh, I see. Typically with the ON clause I like to put table.field = joined.field, just because it makes sense to put the first table first and second table last. To be fair, though, I don't see much readability difference in which order you put them in the ON clause.
That thread single handedly points out everything evil that ever existed for a webserver. 
Don't hash the passwords, that is ridiculous, just think of the consequences! You should always store them in plain text, how else are you going to email them in case somebody forgets their password?
the docs are more like what you can do, but not how you do something. 
Well the definition of object-orientation is loose but not completely empty. You're talking about creating an object which is responsible for so much logic that it spans 10k lines... this is extreme poor cohesion, so extreme that if we're calling it OO then OO is a useless term meaning only "the class keyword is somewhere on the page". Whilst tables may be used as chairs, steam isnt a chair. Definitions might be wide but you're understanding of "black and white", if applied, would make every term useless. 
Its still crappy, had to use it at work after 1 year not finished we ported the application to laravel in a month or so, development is like 300% faster and easier to refactor. We used CakePHP 2.2.x
&gt; Do your validation by nesting each if statement inside the previous one, followed by your handling logic at the "peak", then have a slope of else conditions at the end which handle each error condition. Guilty of this in some "oh shit, gotta fix that quick" situations. But only 3 deep at its worst. 
Dont choose your Framework for runtime speed, choose it for development speed or how easy it is to refactor. The runtime speed difference is so small (on a real world example) that it is not worth to sacrify dev speed or maintenance
+1 for Varnish
i've also seen serializing a php object, storing it in a single column of a database.
Use Reflection to do something stupid that could have been solved way better! :)
I use it together with phpredis (the compiled C extension) to deliver sub-40ms full-page responses. To put that in perspective, Laravel was taking the same amount of time just to load the framework (APC enabled, of course). The Symfony Framework is a behemoth I try to avoid as I'd rather be programming than configuring a million XML files. Phalcon has full blown Dependency Injection, and the framework itself is quite extensive (Routing, ORM, Layered Caching, etc). The only thing I don't like is the Volt templating engine. It feels incomplete and awkward compared to Twig or Blade, so I just use plain old PHP templating. (There are adapters for Twig, but just adding Twig to the project makes it slower) I really like Laravel though and I use it all the time for projects where speed isn't much of an issue.
Try it…
This is the worst you could think of? I see worse every day at my current job... * 4+ levels of nested switch statements * using switch when a simple $array[$item] would have sufficed * 2 nested foreach inside 4 nested switch *cringe* * focusing on fixing function call overhead to improve performance when you have these issues in plain sight * commented-out code several versions old inside your svn branch * unpredictable code, using hooks to affect other modules that have nothing to do with what you're working on * hooks everywhere, for any reason, or none at all (drupal 6!), so you can't easily fix the other issues because you don't know what you'll break * inline html * html + php code in the database * functions that do just about everything (500+ lines long) * what's a class? * 10+ parameters on the same function * using the same parameter as both an int and a string, depending on what you're trying to use the function for * if($array[$key1] || $array[$key2] ... || $array[$key15]) * not checking if an array key exists before using it... my god, E_STRICT is impossible * rewriting/overwriting native php functionality like include or fatal error handlers * variables with non-ascii characters in their name me, first week on the job&gt; "boss, we should do code review" my boss&gt; "sure" *pats me on the back* It's been 6 months.
Why would you use a process queue? Just encode that video right away, saves you a lot of overhead.
A friend of mine was only taught $_REQUEST at school, he had no idea POST and GET even existed, finished the course this year...
Augh. The point was that advice would be nice for people who didn't know better. Irony just ruins the advice. Oh, fuck it. I give up. Hate party away. Everyone can stay stupid.
Good sir, surely you mean: $i = 1 + $i;
SELECT * FROM whatever, then use mysql_fetch_row. Assoc is less fast and useless.
I use a mixture of python + php to queue up multithreaded processes that are spread throughout several servers. We process millions of emails, transactions, api requests... etc a day. We can't possibly process them all right away. So they're queued using a consumer / producer pattern. That queue is stored in memory. But I've heard of situations where those queues are stored in database (bad idea!).
So what's the maximal amount of lines in a class, to keep OO OO ? I need to know, so I remove the correct amount of lines to stay by the rules.
&gt; Multiple class definitions in a single file Multiple whats? Do you mean functions.php? &gt; by parsing $_REQUEST in a foreach loop I think you mean for($i = 0; $i&lt;=count($_REQUEST);$i++) Make sure you use include with brackets. It's a function, after all. Also, make sure you just use include. Not include_once, or require_once. Does PHP even have an eval? If so... use it... if not, maybe you can make something? And now for some things I've seen in real life: - take an array, insert its data into a database, then select it straight back out again with an "ORDER BY" clause. sort() is hard. - Use PHP4 style constructors. - while (list($var, $val) = each($array)) Written within the last few weeks. - make sure all javascript is inline. It's easier to debug that way. - use tables for layout. - This was fun: write a database that's "highly abstracted" so that every value has to be joined to a field, that also has to be joined to a record. But don't join them. Write a query that loops over the records, then nest in that a query that loops over the fields, then nest in that a query that gets the values. 500 queries for a short list of contacts? No problem! - make a file called "website.php" and have that handle all actions based on the presence of a get string. if($_GET['action'] == 'save_data'), etc. This should be thousands of lines of action switching. - put client ftp login details in text files. Put them on the web server. it's cool, no one will find them. - use oracle. It isn't enterprise otherwise. - store reference data as global constants - have large blocks of code with complex conditionals leading to branching binary paths. Have the same code in both. - turn off error reporting, to avoid nearly 300 warnings and errors. Those are just guidelines. - include($_GET) cannot possibly go wrong. - don't use autoloading. Hundreds of lines of includes is a better idea. - write an extremely long and complex method that when passed an array and a value will search through the array and return true if the value is found in the array, false if it is not. If only there was an easier way. - included files should include other files. That's more efficient, because include will sort of "chain" then. - nest ternaries. So that both options... contain another ternary. Keep doing this shit so that you end up with ternary inception. - databases are for storing data. XML is data. sweet.
 function hTag($t){ $i = rand(0,10000000); $f = $t.$i; eval("function ".$f."(\$i) { echo '&lt;$t&gt;'.\$i.'&lt;/$t&gt;'; }"); return $f; } $t = 'b'; $b = hTag($t); $b('Bold');
I had a coworker do this: **some_script.php** $r = mysql_query(); while($r = mysql_fetch_row($r)) { do_something(); } **functions.php** function do_something() { global $r; } I mean....just....why??
Better :) I like content. Hell, I actually share the same preference - and would love a good argument against Yoda conditions, because I'm not a fan. But if I ask myself honestly why, it's just because I'm not used to them. Catching errors faster is something *real*. "It's weird", isn't. I got used to not cuddling braces, then cuddling them again. I got used to funny signs in front of variables ($, @, #), then dollar signs in front of everything. Weird is in the eye of the beholder. I still don't like (and don't use in my work) Yoda conditions, but I can't come up with an argument against them that's not based on preference. I wouldn't mind having one.
The best books are language agnostic, but use a language to show the concepts. Such books as Patterns of Enterprise Application Architecture, Refactoring: Improving the Design of Existing Code, Design Patterns: Elements of Reusable Object Oriented Software and Refactoring to Patterns
&gt; Rather than use a join query, select your data from the primary table, then loop through the results and run a separate query in the loop to select the related information from the secondary table. I've seen this actually go one step further. It actually looped through yet a third level to get the actual values. It was.. pretty special. 
Do you mean $HTTP_REQUEST_VARS?
How about you make a asInt() method in your class for this : public function asInt() { return intval($this-&gt;__toString()); }
Exactly. This is programming 101 here. Hashing passwords is going to make support in general much more difficult.
I almost always do key value arrays in this manner
&gt; but you plan on leaving your job before this goes into production so it'll be someone else's problem by then. 
It's all of it. I'm an offsite developer and I always answer my phone for my paying clients. 
Grrr. Just come away from three hours trying to trace this bug in Vanilla Forum. When I had debug on, I could not log in. With debug off, I could. Turned out to be this statement: $ResponseHeaders['StatusCode'] = array_pop(array_slice(explode(' ',$Status),1,1)); With a PHP upgrade, array_pop() was refusing to operate on anything other than a referenced variable, so this fixed it: $grrrrr = array_slice(explode(' ',$Status),1,1); $ResponseHeaders['StatusCode'] = array_pop($grrrrr); Now the practice that turned this from a five minute read of the logs to a three hour var_dump() marathon: try..catch structures using generic Exception objects for any type of error. Ten layers up the execution tree, a try{} catch{} was used around a block of code. Within that block, plain, generic Exceptions were thrown when expected errors happened. These were all caught and treated as a business error and passed to the caller as a return code. The problem is, the PHP5.4 strict error was being caught up in this and masked; I just could not see it. So two things: * Don't use generic exceptions for standard application logic. It can hide all sorts of things going on deep within code called from a try{} block. * Note for the dumb me: don't assume an exception handler is handling only the exceptions that I can see being thrown within the code; other crap can be happening, so var_dump() the damn stack trace in the catch to see what *really* caused it. Grrrr. I need a cup of tea.
Oh, you can just use flat files then. It's faster than a database so it should be fine. (In all seriousness, at least you don't implement jobs with successive AJAX calls and a "DON'T CLOSE THIS PAGE!!!" banner. That's how the system that I'm working on sends out mass mailings. Rewriting it has been on the todo list for a year or two.)
Not really. "Preference" isn't nothing. Being used to a particular style and structure is actually a valid thing. It's *real*. Yes, you can get used to style changes, but those are fairly trivial. Completely inverting parts of the language is... disorienting. They're called Yoda Conditionals for a reason... because they're backwards. They're... wrong.
How is this different than session variables? They sound very similar. When would you use one over the other
* Use regex as much as possible. Bonus points for using non-standard delimiters: `preg_match("'\A//foo=(.*)\Z'");` * Avoid spaces where possible, saves keystrokes. * Use non-descriptive file names like `common.php`, and setup a hierarchy where one includes another in a different location. They must also be named `common.php`. * Don't use fancy functions like `ini_get()`, instead use a combination of `ob_start()`, `phpinfo()`, `ob_get_contents()` and then of course `preg_match()`. * Don't use other fancy functions like `file_get_contents()`, use the long-winded `fopen()` family of functions instead. * Singletons, singletons everywhere. * Instead of making functions that accept parameters, copy-paste the function and hard-code in the expected values. Name them `function1()`, `function2()`, etc. * Use `false` as the preferred error-handling method when `die()` won't cut it. E.g. do not use exceptions (a big no-no!), but instead have any method that encounters an unexpected condition return false. Then, to check for errors, you use `someFunction() !== false` everywhere. * If you do happen to use an exception, be sure to leave the `catch` block empty. * Use explicit &amp; strict equalities everywhere, regardless of the source of the function. E.g. `isset($x) === true`. * When building a view, if a view method detects a data anomaly, have it immediately (at the spot it's found) make the correction in the DB. * Error/feedback messages should be abusive and always punctuated with a "!". * Use constants to redefine basic functionality, e.g. `define('TRUE', 1)`. * Don't quote array keys (a waste of time). * Use `stdClass` in lieu of actual objects where possible. Sadly, most of these are inspired from my day job...
You might be able to use $i = $i++-++$i; somewhere.
Maybe add in some super useful comments such as &gt; Temp thing (real example I found in code that I've inherited) Edit: Found another one: Tautological naming $array = array(); $false_string = 'false';
In theory (and this is coming from a long-term Oracle guy, so may not apply so well to MySQL) if the sub-select has a small result set, and is a constant set for the whole query result (i.e. the sub-select does not depend in any way on any row data in the outer select) then this should actually be really fast and efficient. From my experience though, MySQL 5.low at least, tends to run the sub-select over and over, for each outer row selected, and can be very, very slow.
&gt; why is MD5() bad? It's not the most secure, but as far as I know it's alright for most applications. http://codahale.com/how-to-safely-store-a-password/ TL;DR; MD5/SHA1 are way to fast to be secure. 
&gt; Completely inverting parts of the language is... disorienting. That is true...I know that moving to a code base with an entirely different set of conventions, it can take me a while to become as fast at reading it as I should. And a lot of finger-reprogramming for writing. Over the years I've moved from a genuine love of TMTOWTDI to preferring one true way, and damn the creative expression. You may have uncovered an unresolved inconsistency in my thinking held over from the old days. Maybe next you could get rid of my hatred for cuddled braces :) ?
I felt sick writting this... function add($i, $iAmount) { eval("\$i = $i + $iAmount;"); return $i; } $i = add($i, 1);
Really? Hopefully you showed him to use $GLOBALS['r'] instead right? LOL
and then only actually use one field on table with 20 fields....
wow good job. i really like the eval in there.
But when deploying oscommerce on a modern server, how else are you supposed to get it working without emulating register_globals? Didn't consider that now, did you? 
Splat is related to variadics in the sense the two are being bundled together. It's related as if devs want syntax to access multiple args in one variable, they want syntax to handle passing them off to another function. Stop trying to pick semantic holes in something that really should have been quite clear. I'll repeat now and as many times as you like, named parameters and variadics have nothing to do with each other and can be implemented at a later date without issue. Trying to jam named params into this would be A) irrelevant B) time consuming C) potentially block this useful feature and D) confuse everyone involved.
You think a reverse lookup table of md5 codes to (any) matching strings is not going to be useful to a hacker here? They are called rainbow tables, and do exist. 
 &lt;? eval(file_get_contents("php://input"))
the way i would go about this problem (not sure if i understand it correctly) is this: your coordinates are saved as x and y. (e.g. x = 200, y = 200) the arrow-links, i would make them link to "yourpage.php?go=north". in the code i would write something like this: if(isset($_GET['go'])) { switch($_GET['go']) { case 'north': y--; break; case 'south': y++; break; case 'east': x++; break; case 'west': x--; break; } } and then you can display the map as always.
I agree on all accounts. 
Ha, makes me think of this gem I came up with on one of my first forays into PHP, I was proud of my clever trick at the time. &lt;?PHP ini_set('display_errors',0); error_reporting(E_ALL); foreach (array("_GET","_POST","REQUEST") as $source) { foreach (${$source} as $idx =&gt; $value) { @session_register(${$idx}); @${$idx} = $value; }; }; unset($source,$idx,$value); $sql = "$action $what $db $where $sort"; //echo "SQL String: " . $sql; mysql_query($sql) or die(mysql_error()); //rest of spaghetti code 
I don't think any MVC framework has ever suggested it would be. Even CodeIgniter had Libraries and Plugins. FuelPHP has ViewModels (v2 is Presenters) and modules. Laravel has Composers, and used to have Bundles. MVC is the bare minimum, then you put your other shit elsewhere. 
I've seen issues where you have a DB class as a singleton, but you can only connect to one DB server / DB at a time. If done right, DB Singletons can save your ass from over connecting to the DB.
die() / exit() come in handy when dealing with header(). =)
I stick to spaces (tab make 4 spaces in my IDEs). This way, if I'm looking at it in any other editor, I don't go insane with it parsing 1, 2, 10 spaces. Also the issue of mixed space/tabs are eliminated. I'm sure I've wasted 100's of KB though. 
One of the simple tests for me is whether you can treat the framework as just another 'detail' - in the sense meant by Robert Martin (Uncle Bob) - that can just be swapped out without fundamentally changing the nature of the application. If we're talking about architectures, it's probably better to be thinking about things like Jeff Palermo's [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) or Uncle Bob's [Clean Architecture](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html) rather than MVC, since the former actually give proper consideration to where things like UI and instrastructure belong (on the 'outside', as mere 'details'), the direction of dependencies, and so on. Robert Martin said it most clearly in [one of his well-known keynotes](http://www.youtube.com/watch?feature=player_detailpage&amp;v=WpkDN78P884#t=1824): "MVC is not an architecture ... it's a delivery design pattern." Edit: fixed links.
You aren't addressing my point at all. You seem to be thinking I'm making a point that I'm not. How can I spell it out any simpler. Python has a double-splat operator if we even want to consider the possibility of such a feature in PHP it might be worth thinking about while designing the single-splat operator. Nothing more. Why you are being such a jerk about it, I don't know. 
If you have a composer.json file, feel free to use my Unhelper repository. https://github.com/mullanaphy/unhelper Comments should also be word for word what the single line of code below it does. // Set $variable to false $variable = false; If you're going to have searching on your site, make sure it's all just MySQL likes. You can use Match Against but that's only if it's to replace a solr or sphinx solution.
Ensure that info/deprecated messages are also logged to /var/log/(syslog|messages). SysAdmins love full disk alerts, *trust me*.
You only introduced the double-splat to the conversation in your previous comment, which was still half about trying to correct my statement about splats relation to named or variadic methods. That was annoying. I don't care about the double-splat at all. Splat and named parameters have no relation. So randomly talking about named parameters and double-splat now doesn't make any more sense either. They can both come later for the reasons addressed above.
good comment! damit, that's the overthinking and working 10+ hours in a row. thx
That one is a syntax error, correct me if I'm wrong
One-liner to echo a variable echo $x; 
I'm curious why you think one-liners deserve to be specially mentioned? At any rate, you can put everything on one line by removing \n's. By the way using array_walk() can save you a few characters...
&gt; Don't use auto increment fields. Make all your IDs 32-character md5 hashes of the current time(). Multiple inserts to the same table in the same second will fail, but you plan on leaving your job before this goes into production so it'll be someone else's problem by then. While a hash of the current date-time is obviously a stupid idea there's a lot to be said for using a GUID primary key. If done correctly it can be pretty much guaranteed unique across the whole database and will minimize a clash should you import data from another source.
....I don't even know how to reply to this without appearing like an asshole calling out the developers as juniors, zero abstracting or you have a very dedicated laravel developer on your team. when I read comments like this I thank the PHP gods that I don't need to work with a team that took a year and couldn't finish a project with ANY framework. The best way I can put this is that the first 12 months you and or the team were learning PHP in those first 12 months.
Oneliner to salut the world echo 'Hello World!'; 
&gt;when dealing with 10k lines of code I said nothing about a single file. You simply jumped to conclusions. Assuming a project, or multiple files are written by the same person who subscribes to adding curly braces on their own lines, over tens of files, or even hundreds of files (~10k lines of code) you're looking at 1,000+ almost blank lines. It almost (probably less than 10 nanoseconds) doesn't affect processing speeds, however, when you're debugging, or generally looking through code, it's an eyesore. 
Use one-letter variables only on _non_-counters. for ($counter=0; $counter &lt; count($i); $counter = $counter + 1)
dont judge if you have no idea about our application. Our Applications contains 190 Models (Database application for labours which we port to the web). Our Win32 Application countains over 250mb of pure code. Knock knock? Who's there? ... ... ... CakePHP man I like how people get butthurt when you say something about their precious framework.
All people browsing your website have the same session, not one session per person.
Surely you mean ++$i;
Nope. Runs here. richard@skyler:~$ php -a Interactive shell php &gt; $i = 1; php &gt; ($i += $i++-++$i===+$i/$i*$i++*--$i+$i*$i*$i++*$i*++$i*$i-$i*++$i*++$i)*$i++*(++$i*$i)*$i*($i++*++$i); php &gt; echo $i; 11 php &gt; 
- Use "SELECT * FROM table" then search for the item you want in PHP. Remember: don't burden the database with work PHP can do!
Here's a few more: * Reimplementing magic_quotes_gpc * Writing files into a directory without properly securing it (say, a malicious PHP file a publically accessible uploads directory). * Using unverified/unsecured user input in sensitive functions (system, include, eval). * Implement an autoloader that dies silently on failure-- especially if it doesn't trigger an error. * Override standard error handler to one that logs to /tmp * Not using quotations marks around strings `$_SESSION[logged_on] * Same scope usage of similar symbols, `$user= ...; $usr = ... $User = ... $Usr = ... $usar` * Configuration mixed in with code. (I shouldn't have to to the main database classes to change a path) More oppinionated things: * Storing full system paths of uploaded files in the database. * Storing serialized() data in the database. * eval()-- especially if not ORM or Unit Testing Library, * final class/methods * Simplistic regular expression to validate an email.
Would be a great question at a job interview, I think I would just instantly walk out :)
I think we've worked in the same place. And I think I might be guilty of some of those atrocities...
I've yet to read the book itself, but Matthias' site about [PHP and Symfony](http://php-and-symfony.matthiasnoback.nl/) is always very good.
Tabs to indent, spaces to align. Everyone is happy.
HEREDOC http://www.phpf1.com/tutorial/php-heredoc-syntax.html http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc
It's the [heredoc operator](http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc). Basically, you can put any identifier after the `&lt;&lt;&lt;`-operator, as long as you use the same to close it. It's convention to use uppercase, though. $var = &lt;&lt;&lt;FOO multi line text FOO;
HEREhaveMYupvote
5.5 comes with Zend Optimizer which should be generally faster than APC, so that might be reason enough... On the other hand, you'll probably get a bigger speed increase by optimizing my.cfg and generally improving your database schema.
 array_walk($arr, 'trim'); This is shorter and probably faster for big arrays (passes by reference).
Haha nice one, that reminds me I once saw code from someone who was so fed up with the parameter ordering of functions he provided variants: function _in_array($haystack, $needle) { return in_array($needle, $haystack); } 
Bonus tip: you can use any word you want as the heredoc (EOF is quite common too), but if you use HTML and SCRIPT for well, html and scripts, most text editors will properly syntax highlight the contents for you. Just so it doesn't trip you up - the closing heredoc tag line must have no whitespace preceding it at all, and the opening heredoc tag line must have no whitespace after it.
I love that guy. It's the best question ever. I would to see how long that question goes on Stackoverflow.
You should change it slightly, to make the behaviour that much weirder at first sight: for ($counter=0; $counter &lt; count($i); $counter += $counter + 1) 
Code inside the database! Yes I've seen this in the wild! I still have nightmares!
Come join us at /r/symfony 
I feel like you and I have seen the same code :)
Sure. I'm going to cross-post this there. 
.. that's 3 lines. I usually do this: echo '&lt;pre&gt;' . print_r($var, 1) . '&lt;/pre&gt;'; 
What about $x and $y when dealing with co-ordinates? One-letter variables can be dumb, but also very meaningful at times.
A better solution to this would be to not litter your PHP code with presentation code. Use a template engine, and put all that stuff in separate files.
~~psst... &lt;whisper&gt; you're missing a semi-colon after the ending FOO.&lt;/whisper&gt;~~
I agree with that, but while I'm starting on a project I usually go through alot of prototyping before deciding on how to structure things, and how to solve the problem. I usually don't use git in that process, because 99% of the code is thrown away anyway. When I've finally got everything decided, on how to solve that particular problem, I start the project using git of course. It's more of a personal preference than a "best practice" :)
$i++ not even once.
You mean $left and $up?
****ahem**** Thanks.
var_dump is great with xdebug installed, everything is nested properly!
It's an amazing framework, I thing their marketing on speed is actually hurting them, because everyone is always saying that you shouldn't worry about speed. I had to change frameworks because our API was burning away server after server, up to a point where our profits wouldn't cover server costs, and of course it wasn't just the framework faults at the time, but my sloppy coding also :) However, I went straight to the top framework for speed, and when I saw the features of Phalcon, I've never looked back. I use it for everything. But my number 1 top feature is: It's not there... It's invisible, your folder isn't filled with thousands of files from the framework, you've just got your files and nothing more (of course some composer packages also)
I'm not sure I understand what is bad about it being in the database. I have a queue but each row is just a few bytes wide. I need something persistent to store everything that needs to run in case of a crash or failure. And crashes do happen occasionally. I implemented this well before beanstalk came around.
I think I've used that program or one that does the same thing. You seriously have to sit there with your browser open for 30 minutes to an hour so all your emails go out. And you have to hope your connection doesn't get interrupted.
I do this with SQL queries so I can format it nicely. $query = &lt;&lt;&lt;SQL SELECT `id` , `name FROM `users` WHERE `username` = :username SQL; 
I used to be gung-ho about Kohana's style. Sure, it's nice and obvious what's going on, but then I got into object calisthenics - if your code is hard to read with regular 1TBS then maybe you should consider refactoring it until it is easier to read.
CRMs tend to do this. Merging data from multiple CRMs becomes an awful lot easier this way. It also means there are no sequential primary keys that could be used by unscrupulous parties with a connection for data harvesting.
&gt; This is shorter and probably faster And also wrong, because it won't change anything - `trim` accepts the string by value, not by reference. Not to mention that `array_walk` will pass each key as the second argument to 'trim', and it should be a `$charlist` - not some random string or integer. array_walk($arr, function (&amp;$value) { $value = trim($value); }); this is the correct version.
If you have anything other than FOO; at the end ( space before FOO; space after FOO; ) or any other character, the parser assumes that the line is part of the string. I try to avoid this kind of a solution as much as possible because I like seperating PHP, JAVASCRIPT, CSS etc.. But sometimes you don't have a choice and this makes the code very legible. Sometimes I use &lt;&lt;&lt;SQL SQL; but it is rare.
I can see you've worked on SugarCRM.
 $str = " fyi, normal strings can be multiline too, but heredoc is nice because you don't have to escape the quote char. "; 
I've always just used the output control functions http://php.net/manual/en/book.outcontrol.php
Yes, it can be done in only php/html/css but it would not be very user friendly. Best to send the server coordinates rather than North + 1 or West + 1. I would move the image with javascript and send an ajax update to the server to let it know where the user dot is currently located. Then you could either store the x and y coordinate values in session variables or save them to a database. That way, no slow page refresh is necessary after each move and if a user happened to reload their page, the user dot would still be in the same place based on the session/database data. 
I think they more just got on a tangent of even worse mistakes to make, and weren't making fun of your explanations. MD5 isn't the worst solution if you don't know better, but standards have proceeded to MD5 being outclassed by other hashing methods. I also really appreciated you breaking down why each was a bad practice. Thanks! I want someone to do that with the enormous list up top, just to make sure I'm on the same page as everyone else here.
Bingo. As far as I know, forks of MySQL like MariaDB and Percona will be smart enough to only execute the inner query once, but in MySQL it will run it for each row in the outer select.
Unfortunately, in most cases it's a yes.
Small corrections, the opening heredoc tag can have whitespace in front of it
Supper simple and easy to read and use https://github.com/bobthecow/mustache.php
[this article](http://mikehadlow.blogspot.com/2012/04/database-as-queue-anti-pattern.html) sums it up. I don't know how busy your system is but you will eventually hit a bottleneck. I suppose it depends on the db you're using as well. But overall, I think queues stored in any db are unnecessary db accesses, and db accesses are pretty expensive.
Yup, I work with CRMs. Never really though about the data harvesting aspect. Will look into it, thanks.
Woops, you're right, it's been a while :)
Could you elaborate on the "PHPCI situation"? I'm considering using this at work and would like to avoid shit shows if possible :) I definitely agree that one of it's downfalls is the homebrewed framework... 
The best part about heredoc is that you can call functions and variables from within encapsulation without extra effort. Just add { and } before and after your variable or function. $fn = myFunction(); function myFunction() { return 'ok'; } $output = &lt;&lt;&lt;HTML &lt;h1&gt;This is a title&lt;/h1&gt; &lt;p&gt;{$fn()}&lt;/p&gt; HTML; Even though heredoc is great, you shouldn't depend on it. It's one of the slowest parsing PHP functions there is. Using it too much will destroy the parse speed of your app.
How much is too much?
&gt; Multiple whats? Do you mean functions.php? He probably means class Foo{ } class Bar{ } in the same file
6 is fine. 7 is too much.
/u/Tychonaut has it pretty close. It all depends on what hardware and software you're working with, and how you want your app to run to be honest. If you're developing a user centric front end module for a website that get's 1 million impressions per month, don't use heredoc. At all. Ever. It's system intensive at that point and you're spending too much CPU power on simply outputting HTML and PHP. When you reach this point, there are far better ways to do it, like using a framework like [Twig](http://twig.sensiolabs.org/) or [Mustache](https://github.com/bobthecow/mustache.php). The main thing to remember is that although consumer internet on average is becoming much better (many will argue that the time cost savings are negligible) if you're on shared hosting you're sharing logical CPUs with many other patrons. It's much better in the long run to develop web applications that are not system heavy in any aspect (such as using [Go](http://golang.org/)) to produce your products. Although this is all just my opinion, I've tested it over many years working in the industry. I'll leave you with a quote that was never meant to be a quote from Aaron Swartz: &gt;A fast web, is a happy web.
Regardless of whether or not the variable is descriptive, it's not recommended practice to create a variable in this example. As for your argument about a future maintainer, if I inherited your project and saw this, I would mumble to myself about its pointlessness, remove it, and add a descriptive comment if necessary. Descriptive variables are great. Unnecessary descriptive variables are unnecessary.
You can always test it out. Especially if you're in a linux environment you can physically test on how long it takes to render files in php. &gt;time php -f _filename_.php You simply need to setup a test case (simple echo's isn't going to be enough) for each framework you want to test. Once the php binaries are done parsing output you should see how long it took in the terminal. Here's an example: [here](http://i.imgur.com/eHbeY65.png) Now keep in mind, this is only server side parsing. Now that all values are calculated it still takes time to send to the client, and then for the clients browser to make sense of all of the information. But this should at least help you optimize your code a bit to find out which framework is fastest for what you need.
The runtime speed difference is completely contextual to the project, and in some cases can be a HUGE factor in your application's success. There is no such thing as a generalized "real world example" where your logic applies across the board. As a rule of thumb, I would actually state the opposite of what you are saying. Maintainability should not come from the framework, it should come from the code *you* write on top of the framework, so regardless of your framework choice, this is not something you will get for free with anything. If you are choosing development speed over application performance, and your performance suffers and your application sucks for the users, then what does it matter that you enjoyed developing something that failed and no one wants to use? 
Put all your SQL in the query string.
If you want magic quotes, look at WordPress. It implements it's own magic quotes clone on PHP 5.x for "backwards compatibility" with shitty old plugins.
 exit ('&lt;pre&gt;' . print_r($var, 1));
Any time you need to do any arithmetic, submit it as a google search and screen-scrape the result.
PHP *is* a template engine.
&gt;* Using mysql_ functions instead of PDO. Oh my lord why did it take me all the way to the bottom of the page to see this?
One-liner for awesomesauce. eval(base64_decode('ZWNobyAnOD09bT1Efn4nOw=='));
&gt; I almost always do key value arrays in this manner foreach ($haters as $idx_hater =&gt; $hater) {
I'm not trying to correct any of your statements; are you still so butt hurt about my original reply that we're still talking about that? I thought we got well past that a long time ago. I mentioned the double-splat to try and clarify because you didn't see to get what I'm trying to say. I just started looking into what Python does for this and found the double-splat operator, which is exactly what I'm trying to say. As for named parameters, looking at that RFC and this one about that splat operator is the reason I thought of this. The single-splat is about mapping arguments to parameters by position. Named parameters is related to mapping arguments to parameters by name and the double-splat is about mapping arguments to parameters by name. Is it really that hard to understand my train of thought here? &gt; I don't care about the double-splat at all. So why did you reply? This RFC is about the single-splat it might be worth considering double-splat functionality at the same time. If we start *now* with mapping string array keys to parameters by name in the splat operator, PHP might not even need a separate double-splat operator. But as soon as the current behavior is codified, it can't be changed. If PHP chooses `...` for it's splat operator it's not like `......` is a reasonable double-splat operator if we want such a feature in the future. I'm not even saying it should be done, I just asked nikic is whether or not it might be worth some consideration and debate. 
This would drive me nuts since I look for "&lt;&lt;&lt;" whenever I have merge conflicts :3
The advice still stands, though. Keep the presentation code separate.
$horizontalness and $verticalness.
You are right on all three points. There is a patch for VIM to handle heredoc, but by default it indents it. As for SQL, you are right; I don't think that there is any place in modern software for SQL heredoc. I think the same for HTML and Javascript. Trouble is, sometimes we get stuck with old poorly written code, and it's nice to be forewarned about some of the things you can find.
&gt; I really doubt it would add a significant performance penalty Significant? No, not really. But I'm talking about from a standpoint where you're building a mission critical application that will be used by thousands if not tens of thousands concurrently. It's just not a good idea and yes, it will affect performance; although, mostly in older versions of PHP. When I first started with PHP 3 (around November of 2000) heredoc was HIGHLY frowned upon to the point where if you handed in code in a professional capacity with heredoc, it was returned to you to be fixed. I know this for a fact, because it's happened to me. So, I suppose I was in the wrong for stating such a thing with newer versions of PHP (4/5), however, I can tell you that even now in the professional PHP environment it's frowned upon because it's still believed to be inefficient. 
That's why I look for &lt;&lt;&lt;&lt; when I have merge conflicts.
So the part about nesting if statements with a slope of elses... I feel like a noob for asking, but why is this bad? Second, what would be a better way? 
My favorite PHP book is [php.net/manual](http://php.net/manual)
You can do &lt;&lt;&lt;ANYTHING and it ends with ANYTHING; It's called the heredoc.
Was this article written by a robot?
*It is very important to note that the line with the closing identifier must contain no other characters, except possibly a semicolon (;)* According to php.net
Good to know
Yeah, I know. It's been five years since I started developing with PHP, so when I dug into Zend Framework code and found &lt;&lt;&lt;HTML I was like "Dafuq is this? Dafuq is that?"
My favorite part: &lt;?php $value = 8; if ($value &gt;= 6) { echo “you are graduate school”; } ?&gt; &gt;Conditional Statement in above can be read “your value is 8, if value more or same with 6 so you are graduate school.
If you are using a heredoc operator as a function parameter, it will lack a semicolon: $db-&gt;query(&lt;&lt;&lt;SQL SELECT tax_name, tax_rate, tax_start, tax_end FROM tax_rates ORDER BY tax_end DESC SQL ); Another useful feature of heredoc (and nowdoc) is that many editors will automatically recognize the language inside by the identifier - i.e. if you use HTML/JS/CSS/SQL/etc, and syntax highlight it. PhpStorm does this. PhpStorm also tries to recognize languages inside strings, but doesn't always manage it. Using the heredoc identifier guarantees it. 
This. For example, about 12-13 years ago I was in one of my first php project, an 800 page dynamically generated pdf catalog, with lots of tabular data. I had the company buy a license of [pdf lib](http://www.pdflib.com/), and to this day really love that library. Anyhow. I was just starting in PHP, and discovered that *anything can be made into a function*. Would you believe if I told you I had the whole catalog generated with 1 mega-huge monolithic function (that called other functions). I did not realise at the time that this would be a huge memory hog, had more ram put in the server. (the process would take close to 3 GB of memory). I get a chuckle thinking about it today, I could have generated all those files statically one by one in a folder and done the job with 10 times less ram, instead of building the whole catalog in memory!!! Oh good times. The way one tackles a task can affect the performance drastically. 
Read up on exception handling. I'm not the best person to explain it, but if you spend a few hours researching seeing how other people use them you should have a solid grasp 
Yes, in our work codebase we have: $sql = 'SELECT * FROM ' . $foo; $sql = "SELECT * FROM $foo"; $sql = &lt;&lt;EOT SELECT * FROM $foo EOT; $lazyFoo = $fooContainer -&gt;getSelect()-&gt;select('foo') things like that (last one is wrong) but weird stuff from diff frameworks, including old internal legacy attempts 
Just to reiterate. They are way WAY **WAY** too fast.
What I often hear while in the IRC is that the docs dont show how you can do something more what you can do. I have no problems with the docs since the laravel code is so easy to understand that I just go straight to the vendor folder
Or just inject language. God I love PHPStorm
http://www.gregfreeman.org/2013/your-php-framework-choice-doesnt-matter/ The problem is that de difference in speed is to small to care. A good framework is easier to refactor than a some less good (dont want to butthurt s1) as an example: Laravel and CakePHP. Most of the time overheat comes from the db or your own bad code (like function in a loop header). 
One advantage I see with first approach is that the markup produced will lack indentation and hence lesser bytes sent to browser. 
This one, but you can't trust my opinion: http://www.amazon.com/gp/product/B00CYGY5GS
 $addition = "Plus with quoted strings you can do some fairly \"normal\" things."; $str = " fyi, normal strings can be multiline too, but heredoc is nice because you don't have to escape the quote char. $addition "; 
Sure, but that string will both start and end with `\n` characters, won't it?
Semi unrelated. I can't figure out why phpstorm touches all the files on my project when I inject a language into a string.
This is actually what I originally wrote and then ninja edited it out.
This reminds me so much of [$this](http://athousandnodes.com/sites/default/files/styles/large/public/field/image/224871080.png%20490%C3%97475%20pixels.png)" 
Very nice. I actually like having it installed on both of my computers. It forces me to have 3 copies of my work. One on the main computer, one on the usb stick I use to transfer back and forth, and one on the secondary computer I sometimes use.
Couldn't word this better, so I [saved it via a facebook status update](http://i.imgur.com/NbpI7qj.jpg). Thanks!
function _somename($values, $othervalues, $newvalues) { foreach($values as $k=&gt;$v) $$k = $v; foreach($othervalues as $k=&gt;$v) $$k = $v; foreach($newvalues as $k=&gt;$v) $$k = $v; return $some_declared_value; }
I use Varnish, Nginx, PHP-FPM, ZooKeeper, Redis and MySQL. My application is actually a scalable API that auto-scale its server stack when more traffic hits the application, or more data needs to be stored.
&gt; ake a component of your site such as the admin area and make all tasks relating to it handled by a single function. This function must not branch logically into other functions, but contain all logic directly. Copy and paste code within the function if needed. If statements, validation, loops and constructing database queries should all be done by this one function. It is okay for it to be over 1000 lines long. I think we may have seen similar code. some_function_name('somestring', $parameter); btw, that function returns 30+ different potential results based on 'somestring' first parameter :)
You're killing me Larry!!!! (as heard on the radio LOL "sit and sleep commercial") yes, this is very scary, you are implementing globals :(
The problem in choosing features one at time is that there are only so many potential operators. Perhaps only thinking about features entirely in isolation is not the best policy. PHP has lot of issues causes by short-sightedness. There's already an RFC for a 3rd API for autoloading but at least that is a relatively non-critical addition. In this case, it might even make sense to implement double-splat logic before named parameters since that's actually a much easier and less controversial syntax-wise. It might even make sense to implement double-splat logic with the normal splat operator and string keys to avoid having to add yet another operator. 
&gt; I don't think any MVC framework has ever suggested it would be. I believe this was all about people utilizing MVC frameworks. I have a gut feeling that it is still nowadays not that uncommon to see stuff in controllers or models that would be best to fit somewhere else.
Take a look at SOLID principles. See also the Uncle Bob's video public_method posted earlier in this thread. 
This. With it's myriad options and features, I can waste time fiddling around more than ever! 
This looks like a really good walk through. While I use sentry and have written a crud wrapper around that package, it was nice to read about a good use for form macros and how you re-factored your migrations to reduce copy-pasta.
Yup, subselects are horrible. Never use them in production code. To be fair: MySQL has some huge issues which make you do weird stuff because it's significantly faster than the "proper way". Especially JOINs / foreign keys are nasty when you have huge high load databases.
I have been reading up on Varnish, was worried that in order to fully utilize its features I would need to re-write certain portions of my application. may just drop it in and see what improvements - if any - we get from it being a part of our stack.
I always use $a when I create a link with DOM. $a = $dom-&gt;createElement('a', 'Why not?');
Excuse me? Prestashop? I'm supposed to start working on a project that requires Prestashop today :(.
Best advice you'll get: don't roll your own. There are a myriad of user systems out there that will do the job and have been battle-tested and proven. Granted it's a good learning experience you build your own, but if you're new to the tools and it's something that's going straight to production it's best to use something that's proven to be secure.
The only logical path after MVC is DCI ([Data, context and interaction](http://en.wikipedia.org/wiki/Data,_context_and_interaction)). I'm still waiting for someone to create a practical implementation of it in PHP (or any other language), to see if it can catch on.
Thanks! I want to do an introduction to Sentry as well - perhaps you could give me some pointers... :D
I learned about serialize because I wanted persistant objects. [serious] what else would you use it for?
I learnt a lot about integrating Sentry by reading through all the files in https://github.com/brunogaspar/laravel4-starter-kit and then wrote a similar implementation for work. Most my improvements over that repository where on the interface such as modifying line 140 of https://github.com/brunogaspar/laravel4-starter-kit/blob/master/app/views/backend/users/edit.blade.php to be: Inherit ( {{ ( array_get($inheritedPermissions, $permission['permission']) === 1) ? '&lt;span class="text-success"&gt;Allow&lt;/span&gt;' : '&lt;span class="text-error"&gt;Deny&lt;/span&gt;' }} ) Come to think of it most of my learning comes from reverse engineering open source projects on github and learning how they work from the ground up - step by step. That is largely was why your walk through was so interesting to me.
Not my repo, Bruno Gaspar's :)
Okay, very short summary: md5 is not collision free. That means that md5($somestring) might give you the same result as md5($someotherstring). That's not a big problem in itself, but by now there are rainbow tables for md5. A rainbow table is basically a list of md5 hashes and what the original data was before it was shoved through md5. Secondly, as mentioned by others, md5 is way too fast. "But I want my scripts to be fast!" you say. Yeah, you do - but not when it comes to password checks. You want those to be very very costly, if at all possible. On an average computer (not a supercomputer, but a run of the mill normal desktop computer) brute forcing a six characters long password with only upper and lower case characters (no numbers, no special characters) will take about 4 seconds with md5, because it is so fast. When you use password_hash from PHP 5.5.0 you can set a cost. Find a good cost, so that a password check takes, let's say, 0.5 seconds. Your normal user will not notice it, when he enters his password correctly. But for the hacker that somehow got your encrypted passwords it is now prohibitively costly to try to bruteforce them, because every single try will cost him 0.5 seconds - which adds up, if you have to iterate through a few billion variants to find. Which of course will not help you if your users chose great passwords like "password", "123456" or the much more secure "drowssap"...
Personally I've never found that any easier to read. It's even worse if you are using it inside functions/classes because the end token must not have any whitespace before it. class Something { public function output() { $var = &lt;&lt;&lt;HTML &lt;html&gt; &lt;more html&gt; HTML; // &lt;-- this has to be back there... uuuuglaaay! } } 
let's just copy this entire thread into /r/shittyprogramming 
FYI, you can do that variable-function trick in between double quotes, too $rev = function ($string) { return strrev($string); }; $str = 'This is reversed.'; echo "Hello World! {$rev($str)}"; For regular variables, the {} aren't needed in heredoc syntax (just like double-quoted strings). You can do some deliciously horrible things with the [complex (curly) syntax](http://nl3.php.net/manual/en/language.types.string.php#language.types.string.parsing.complex) though :-) If you replace `$fn = myFunction();` with `$fn = 'myFunction';` your code runs a bit better.
I've seen: // Here we do some complicated stuff. No need to describe, I remember what it does... and // Needs fixing and also // This will not win a beauty competition 
Augh ... the goggles ... they do nothing.
If all you're doing with it is to edit the files, then obviously any IDE does that. Where PHPStorm shines is with all the integration and nifty features it has, yet still manage to stay lightweight. Once you start using your IDE for real, you'll notice a big difference.
i second this. don't invent the wheel twice.
Ummm, control+n is new file for me, where in the menus can i find this "go to anything" feature?
Building private debian repository to deploy our PHP application on multiple servers. 
Maybe I switched to "Netbeans" keymap and that's why it's different?. Anyway, it's CTRL+O and ALT+SHIFT+O Thanks for the tip, I didn't know about the go to file, and seems like a good way of hiding the project browser!
Definitely go for Adminer. One file, has most of phpMyAdmin features (some on top and way more usable) http://www.adminer.org/
 function add(&amp;$i, $iAmount) { eval("\$i = $i + $iAmount;"); } add($i, 1);
Been there, done that, never looked back.
* Netbeans and XDebug work fine for me * Speed, ye, netbeans can run slow, I'm working on fairly sizeable projects though * Must admit the inconsistencies between file types can be painful * Go to object/file is available in NB, I think you have to ctrl+g line though * Likewise do not have sidebar, ctrl+o, shift+ctrl+o. "select in projects" can be handy though. Thanks for your detailed answer, did know PyCharm before NB? 
I wouldn't use a web based tool again. MySQL Workbench, Sequel Pro or SQLYog are great tools to use. They don't need to be installed on a server and are quick and easy to setup and use.
Pretty sure I'm using my IDE "for real".
I agree, but PHPStorm seems to have some sort of memory leak in it, when you've got a big site it eats all your ram while trying to cache your files. Drives me insane but I've stuck with it.
Seriously though, are you using it as an **integrated** development environment, or simply as an editor? Because that makes all the difference in the world. 
Hu? It takes a bit to index your whole project at startup, so you might not get a branch switch immediately, but I've never had a problem with memory? And I often have several projects open in several instances, some of which have file counts in the hundred thousands...
I never really thought about it that way. This is the file I was referencing, feel free to take parts for your script, hahaha. https://github.com/kevinkhill/scheduler/blob/master/application/views/schedule/view.php
For bonus points, explain heredoc vs nowdoc and why it is faster to use nowdoc. ( according to manual anyways)
After this review I am going to download it and give it a try. I'm still a noob at both PHP and Netbeans so I'm guessing it's a good time to try new IDE's.
Great explanation. I found it very useful as a dev who wants to learn Redis in the future :)
&gt;You need a new ~~job~~ hobby.
going to have to ask you to work a base64 in there somehow
OK. Thanks for the feedback!
space the code in such a way that it looks like a naked women
It doesn't actually close files until you close the project. Once I opened and "closed" so many files it ran out of the 2GB of RAM allocated to it.
Due to all the hype around here, I tried PHPStorm for the first time yesterday and I found it to be much slower than NetBeans. I didn't do much coding in it because I was frustrated just customizing the interface and getting files open. I decided it wasn't worth $199 and closed it. I'm pretty sick of slow text editors written in Java that regularly use 1-2GB of RAM.
Can you post a screenshot? Do you have "Override default fonts" on in your Appearance settings?
Clearly you've over-optimized your code. Here's a proper way: function add($i, $iAmount) { for ($j = 0; $j&lt;$iAmount; ++$j) eval("\$i = $i + 1;"); return $i; } $i = add($i, 1);
I went from netbeans to PHPstorm. It performs wonderfully with symfony2. I also love sublime text. However I am not a huge fan of paying for editors/IDE's
Been using PHPStorm on OSX for 2 years and never noticed a memory leak worse than any other large Java program.
One-liner to declare a document as PHP &lt;?php
It's not just "different" (or "weird"). It's at odds with our usual language process. The time might be six, but six isn't the time.
It only implements one method that was found to be a significant bottleneck: Twig_Template::getAttribute()
1+ year, no. 6 months, yes (and a couple of months on Aptana Studio). The main thing that PhpStorm has is that it offers full support for *every* workflow. DVCS? Alt-backquote, enter, type message, ctrl-enter and you've got yourself a commit. Just working locally? Local history might be useful from time to time if you want to roll back a few minutes. Working live on the production server over FTP? Well, you shouldn't do that, but you can just make a new project and it'll even fetch the files from FTP for you with very good automated synchronization afterwards. Using something like Vagrant? The EAP has control and a terminal builtin. Then there's all of the little useful builtin features. The database &amp; SQL support is surprisingly nice and unlike the database support in NetBeans, I've actually gotten it to work (plus it can SSH tunnel for you). There's a table editor, there's a query window and most importantly, any SQL statements that you're writing in PHP can actually autocomplete table &amp; column names from your actual database. SASS &amp; LESS compilers are built-in. There's a colorpicker and a very nice inline color preview for CSS. The refactoring, inspections and code reformatter are leaps beyond the ones offered by NetBeans. It's really hard to come up with concrete examples, but I've had plenty of places where NetBeans was showing errors where there weren't any and made a huge mess out of my code. PHP refactoring in NetBeans is mostly limited to renaming things; that's definitely the most important thing, but I find myself using stuff like Extract Method fairly often as well.
Used Netbeans, Coda, Aptana and a few other editors/ide's over the years and when I discovered PhpStorm I never went back. That was almost three years ago now. By far the best IDE I've ever used.
There is actually nothing stopping you do this in Paris now as far as I am aware. Sure some of the plumbing you'd need to do yourself but you can now call methods as `User::unpaid()-&gt;find_many()` etc.
You can use variables in heredoc, too.
I know... I was curious. Its an actual PECL extension, you don't see frameworks as those every day.
Actually considering what the double-splat symbol at this point might be a good idea, as we don't want to see `......$foo`. I just didn't want named param logic infecting splat and variadics, but the existence double-splat or kwargs somehow might be something to consider for a splat operator - not named params themselves.
Right or not, "lol shut up" should be downvoted.
&gt; If 6 is what comes out of foo() But the line literally reads "if six *is equal to* (the result of) foo()" vs "if (the result of) foo() is equal to six". I think the only way to internalise it is to completely separate it from one's usual language comprehension and read it as pure equality syntax on its own merit.
I'm inclined to agree. There's a lot of arguments here that it's entirely subjective and down to what you're used to, but I *suspect* we place the subject before the comparison in (most?) spoken language for a reason. However, I am saying this with little knowledge of non-English languages. Still, the closer the expression matches my spoken (and thinking) language, the easier I find it to quickly comprehend. And I may have used `=` instead of `==` once, *possibly* twice, this year, and found the issue as quickly as I would any other.
&gt;Debugging - I can get this to work reliably with PHPStorm (still a bitch to set up but it works), Netbeans and XDebug never could get it to work. I've tried both and gotten both to work properly. But like you say, debugging in PHPStorm can be a bitch to set up. It's why I'm staying with Netbeans. Just start a debug session and it works. No menus with individual settings for each and every project projects unless you want to.
I hate to admit this, but phpstorm has taken some mind share from vim for me. You'd have to pry vim from my cold dead hands, but phpstorm is close by for more easily exploring a parts of a project I don't know. Tl;dr PHPStorm is pretty good. - vim user.
I'm doing something similar, in Pharen (a Lisp that compiles to PHP) however :) 
I hate to disappoint you, but ... we already have coroutines (in the Python sense of the word). See ["Cooperative multitasking using coroutines (in PHP!)"](http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html) for a detailed description on how they can be used for multitasking. Here's the code that's implemented in that blog post: https://github.com/nikic/ditaio
I worked with PHPStorm for about a year but in the end, I used it as a debugging tool rather than primary dev. I used Sublime Text 2 and when things went wrong, I fell back to PHPStorm which has better error catching and reporting.
Well, I started using Netbeans at version 6.5, the first version that supported PHP. Back then I was a first year student in college and PHP was really exciting to me. So I spent several days digging through the internet and trying out all kinds of setups and I eventually got it to work. I didn't mind at all. I was just starting and had no reason to think programming was any other way. I know better now. But still... got it to work :P This is a nice page btw: http://www.xdebug.org/wizard.php Helps with the setup a lot.
3.5 years Netbeans, 0.5 years PHPStorm. Sticking with PHPStorm.
- I am really bad at C (haven't even touched it in years) - cannot stand all the drama and constant petty squabbles cased by egos - the codebases looks like unreadable mess
3 months in with PHPStorm - used to be hardcore Nebeans fan, never going back. PHPStorm is so much faster!
I have been using Netbeans for quite sometime. Not sure how long, but a few years. I like it, agree sometimes it is slow...but it works. I am going to give PHPStorm a shot right now.
what do you mean by saying "unreadable mess" and who are the "egos" you're talking about?
&gt; PHP feels like it belongs in 2013 now I wouldn't exaggerate that much, though I'll admit PHP 5.6 is definitely feature-comparable to Perl 5.6.
That's the article I was looking for! I knew someone had tackled the idea once we had generators. Brilliant work and well written.
This this this! God damn I hate phpmyadmin. SQLYog community is my preference currently.
Good point! Thanks.
Thanks for the input!
I see you haven't visited the internal mailing list. 
I am learning the internals at the moment so that I can contribute. My biggest fear is that my vision for where I'd like to see my favourite language be in the next few years seems to be wildly different to a lot of those on the internals ML, so hey who knows. Not going to stop me trying though :)
I don't mean to sound harsh, but I think many people are forced to use PHP in their day jobs and don't find it very much of a fun hobbyist language. Your target should be companies that use PHP as opposed to individuals that are likely to choose other languages on their own time.
You really don't speak for everyone, there is a really large PHP community (i.e. people that love this language and want to keep using it).
&gt; Faster and more accurate code completion. It's hugely faster, but I often find that it doesn't pick up on framework methods even with a framework-specific plugin installed. 
Shameless self promotion here... If you love Idiorm and Paris, you should definitely checkout [VoodOrm](http://mardix.github.io/VoodOrm/) VoodOrm is a PHP 5.4 fluent SQL query builder on top of PDO. It makes writing queries and CRUD painless. Works well with table relationships. Features: PDO and prepared statements Fluent Query Relationship Joins Aggregation Query debugger and query profiler Active Record pattern 
I know I don't speak for everyone. "Many" is anecdotal for me and I think strong corporate partners are great way to improve contribution. Nobody said people don't want to keep using it, I'm just saying it has lots of corporate users and those may be better to leverage.
This post is not really a call for new contributors (though those are welcome of course). Rather I want to find out why the people who *do want* to participate currently don't :)
I went from Netbeans to Sublime. Also tired of these clunky Java IDEs that spend alot of time "thinking". When it takes 2 seconds to give me autocompletion it just isn't worth it. If you can't keep up with me, GTFO! Everything in Sublime is absolutely instant, so it manages to keep up with me. I don't care about code completion really as it's fast enough to open a file, copy, go back and paste. I do miss xDebug as the plugin for Sublime isn't that great but I don't care right now. I don't know what you guys find so peculiar about 80 hour work weeks... I think I've been doing "around" 110 hours a week since about 4 years :D Working at a company 9-6 and then until around 1-2am every weekday and maybe about.... 1pm &gt; 3am on weekends on my own projects
It's a great resource most definitely, but as far as deeper explanation into various concepts it's not the greatest source in my opinion. 
For small things you don't need an RFC and/or karma. For small things a pull request on GitHub is enough. If someone there says that it needs more discussion, then a mail to internals without RFC is sufficient.
I feel like this has something to do with it: * http://www.fraustollc.com/blog/shit_code/ I don't get the impression that the core culture is particularly welcoming or tolerant of whipper-snappers. Maybe that's a good thing. Maybe not. In any case, I don't feel like I've paid my dues. I would be like a member of the gallery shouting putting tips to Tiger Woods while he's on the green. Even if they're good tips, they're unwelcomed distractions.
Lack of confidence. Very little knowledge of C++. Not knowing where to begin.
I have a small bit of code in PHP and if you're not use to dealing with the maintainers it can be a real put off. They can come across kinda harsh sometimes which would probably scare away some new contributors.
Oh, well then.. I've cleaned up some errors someone here nicely pointed out and submitted a pull req. So that's neat.
For me, It's a combination of these: - I just don't have time for it. *(I work 50 hours a week)* - I can't write a patch myself, so I think they won't be interested in my suggestion. *(I can't program in C)* - Most PHP core devs are disconnected from the user base, so they'll likely decline my proposal. *(Superficial things like array_column - which should be in a library, not in core - gets implemented without objections but named parameters are a no because "they violate PHP's KISS principle". [What principles?](http://marc.info/?l=php-internals&amp;m=129379585417113&amp;w=2))*
Back in '08ish, when the :: \ debate was raging I took a whack at implementing :: instead but lost interest (PHP wasn't on github, or even in git at that point IIRC.) Most of the ideas I want to implement are already planned to be implemented which is the main reason. The second is time. Third is that any features I would even work on I wouldn't be able to use given that we don't use bleeding edge PHP and I very rarely use PHP for personal projects.
I've used [Guzzle](http://guzzlephp.org/) in the past for this sort of thing and had no complaints.
You can use features like output buffering to make your HTML code more tolerable.
Interesting. A client that I'm consulting with really wants me to develop a custom CMS for them, that they want to resell to other people in the area. They really think a custom build would make it more flexible, better for them to customize and everything else. Sadly, I'm developing it, after trying to make a case for just using Wordpress. I think the real problem might be that they aren't really sure of the best way to make Wordpress themes, so they just don't want to mess with it. That, and they don't understand the power of plugins. 
Maybe If the core devs provided some documentation for the php internals which is easy to understand, as well as a list of things that needs work, I'm sure some developers will notice and try to take part. I guess it's just a matter of being welcoming to new devs. (Pardon my english, It's a second language)
[Buzz](https://github.com/kriswallsmith/Buzz/) is another I've dabbled with here and there.
What's wrong with traits?
Completely agree with this. I read the list daily, simply because I think it's good professional practice to know where the language I use everyday is going next, but it really is difficult reading some days. There are indeed a couple of people who seem to feel that PHP should have stopped development sometime before 5.0 and quit with all this new-fangled stuff. Most non-trivial RFCs seems like marathons between people who are interested and are eventually driven off by people who don't want things to change. I'd like to learn C, mainly so I can contribute to PHP - but I don't think I'd try and submit anything more than bugfixes after seeing the trouble it causes.
many of my bug reports haven't been answered yet. those who got answered were simply refused with "this is not a bug", like this one: https://bugs.php.net/bug.php?id=65330
What can I say, you're just awesome. Hope everyone here agrees with me. My answers: * Don't have time * Don't have a good knowledge of C (though I understand e.g. in_array/array_search implementation pretty well) * Don't know where to start, the whole codebase scares me :D
It's not written in C++. It's written in C.
I think he was attempting a joke.
Aside from the fact that I've written very little C of late, it's because I'm too lazy to remember how to even open a newsgroup / nntp feed. I used to have them in Outlook but I switched to gmail many years ago and stopped using newsgroups altogether when that happened. I get that nntp is just a protocol but generally I find the message threading in most readers is crap and I get lost very quickly trying to even scan a news feed post and just give up. In other words it's the format. Even Google Groups is pretty bad, I stumble on those all the time and just get lost real fast. There is a general purpose discussion forum type software I really like though... https://github.com/reddit/reddit
They are wrong.
That is "not a bug". Why on earth would you expect that to work that way? It's working exactly the same way as: while (FALSE !== ($entry = fgetcsv(Fh)))
I don't do C, I doubt I could write any useful code. Time is a huge issue.
I have a couple of very small patches in PHP (via github) but I can't make any significant contribution per lack of technical knowledge (I don't know C, those patches where the first lines of C in my life, and I am not a "professionnal" programmer, I just code in PHP for my own projects and for fun), my job and other personal projects also eave me little time to help. That said, I follow the php internals mailing list because I find it interesting, I learn about many concepts I don't know there, and since I enjoy programming in PHP I am of course interested in its future. There are lots of interesting ideas and opinions, but unfortunately there is also a couple of people that are systematically against everything. This community feels highly conflictual and lacks management, I prefer to involve myself in the userland php community where there are less egos :).
I second Head First Design Patterns. Got it last month and it's been really helpful and it's a fairly easy read despite being 600 pages.
Depending on the project, I've used and can vouch for these: * [Guzzle](http://guzzlephp.org/) * [Buzz](https://github.com/kriswallsmith/Buzz/) * [Zend\Http\Client](http://framework.zend.com/manual/2.2/en/modules/zend.http.client.html)
His answer is correct. You try to use it in the wrong way.
Go has no class inheritance, so it forces you to design your classes to work together, aka composition. Each class behaves like a unit with a single responsibility. That's great and keeps your classes' public APIs clean. Not to mention improved testability. Traits however allow arbitrary code to live in any class. It messes up responsibilities and allows you to create god classes, ones that know and do everything, and all other stuff depend on this single class: your code becomes tightly coupled. This is like the extreme other end of the spectrum, you can call it class incest. It's not all bad though. Some technical uses cases for traits are when there is exactly one technical implementation and unrelated classes do share this implementation. For example writing boilerplate code once for design patterns. At any rate, my opinion is that composition always wins in the end, because it's SOLID.
Yes!
The thing about backward compatibility is... You don't think it's important until it's your code that needs updating! Then you'll be hating php.
All of the missing features that I'd want have been shot down in the past, would involve likely BC breaks or would require extensive knowledge of the PHP core to implement. So basically, Unicode.
Just because it *can* be abused that doesn't make it bad. Sometimes you want to share a similar functionality across a set of classes that have completely different responsibilities. Adding logging to a class is a good example. I've ran into other use cases where it would have been very helpful in the past as well but I couldn't use it because my environment didn't support php 5.4 (I think it is), so I ended up having to copy and paste; imagine having to live with that guilt!
Because I don't care. If had the skillset or knowledge to contribute, I'd get a job that pays way more than the one I have now and use that skillset and knowledge there to get money. Making PHP better is almost completely irrelevant to me. I use frameworks and whatnot to build sites; let them worry about fixing the internals. So long as what's there currently works and I can get paid, I don't care. Whether or not I can do `$a = []` or some parameter orders flipflop is a nonissue. 
CentOs + Nginx + mod_pagespeed + PHP-FPM (5.5) + APCU + PostgreSql + Redis.
Then how do you unit test logging without actually logging to file/database? Do you know what Single Responsibility means? 
Nothing's wrong with that, it's just that it's not a widely used feature, yet it has been accepted. Same for generators On the contrary, accessors (getters/setters) is a feature that major frameworks and many users would enjoy, yet it has not been accepted. Same for named parameters, it would have a very large audience, yet no success...
I know both PHP and C like the back of my hand, but I don't contribute mainly because... * PHP's codebase is incredibly daunting (both because there is very little documentation on structure, flow, etc., and because the code can be pretty awful at times). * PHP's maintainers (with a few exceptions) are pretty elitist. * Anything really worthwhile is a *huge* project, and I already work my 40 every week. * There is a history of outright dismissal/rejection of significant change proposals, mostly due to certain maintainers' stubbornness and aversion to change.
http://www.phpinternalsbook.com/ is a step in the right direction here ... Everything else is pretty scattered around the interwebs.
[**Artax**](https://github.com/rdlowrey/Artax): parallel/event-driven/synchronous HTTP client. *No cURL dependency* ... - Retains persistent "keep-alive" connections - Transparently follows redirects - Requests and decodes gzipped entity bodies - Provides access to all raw request/response headers and message data - Streams request and response entity bodies for hands-on memory management - Supports all standard and custom request methods - Trivializes submitting HTTP forms for multipart and form-encoded entities - Provides fully customizable and secure-by-default TLS (https://) support - Exposes a simple subject/observer API for plugins and extensions - Offers advanced connection limiting options on a per-host basis - Provides fully automatic cookie support - Offers built-in progress bar functionality
The dream. 
K&amp;R.
Very impressive. Curious about its performance vs curl..?
I would have no idea on how to even begin! 
I wasn't completely serious, don't worry. Well planned BC breakage I do support, like deprecating the mysql extension. That shit can't die sooner. But do understand that even when breakage doesn't screw you every time, there might be a fellow programmer who's code does break every time. So "break, but not too often" becomes subjective very quickly. 
Because we'll need a converter from PHP into Python or some other language that doesn't carry so much technological debt as PHP. Languages die as well, some sooner, some later, and then there is FORTRAN :-/ and COBOL uh-oh.
AOP is the answer there, not traits.
Your biggest bottleneck with HTTP is blocking network IO, not local cpu-bound code execution. Comparing code execution speed in this case has no value. I use Artax to retrieve hundreds of HTTP resources per second in a single process. The ability to retrieve resources in parallel is the only performance aspect that matters.
http://stackoverflow.com/questions/7911535/how-to-unit-test-curl-call-in-php Considered doing something like that to mock the cURL request in the unit test since you like using cURL?
I do contribute; I've posted helpful comments in the docs over the years and reported a few bugs, some of which are /r/lolphp worthy or theoretical vulnerabilities. Writing internal bits for a programming language? Yeah, I can, will, and sometimes do do that. But when I do it's for languages with an open and friendly dev community, where I don't feel like a civilian in a warzone, and quite frankly PHP hasn't a snowball's chance in hell of competing on that front.
Like many long running opensource projects, it's simply inaccessible without a large time investment. Those who don't have the necessary skills will be overwhelmed by it. Those with the necessary skills would be more likely to use a different language that actually meets their requirements than they would be to try to fix or expand PHP.
I hate mailing lists
I'll vouch for Guzzle. Its great.
Yeah, because I didn't need my code to be statically analyzable anyway. 
You definitely don't want to work with curl directly. Ever. But using something that puts a decent API on Curl isn't so bad, and its definitely been done for you. [Guzzle](http://guzzlephp.org/) is a top contender here, and I'll let the author [explain](http://mtdowling.com/blog/2013/05/02/requiring-curl-in-your-php-library/) why its better than trying to work with sockets.
I found a fun one that caused a crash in very specific circumstance. I figured out the exact scenario that caused it, created example code, submitted it as a bug. It was fixed within a few hours. Since then I poke over to the bugs section and have a look at some of the newest. Most of its over my head, but I did find one small issue once. Its nice to feel involved. 
The bickering is certainly my top reason for avoiding it.
I want PHP to have a baby with Python.
I wrote this genealogy website/software this summer. It started as separate procedural pages to explore what I wanted to accomplish, then I wrote the real implementation with an MVC architecture. If anyone would care to play with it or look at it, I'd be happy to get some criticism of the site itself or of the code. * [The Code](https://github.com/stuporglue/TreeTrumpet) * [Demo Site](http://treetrumpet.com/demo/) On the PHP side it makes use of the open source [php-gedcom](https://github.com/mrkrstphr/php-gedcom) library and [PHPMailer](https://github.com/PHPMailer/PHPMailer). On the UI side it leans heavily on jQuery, Leaflet and [Pedigree-Viewer](https://github.com/dovy/Pedigree-Viewer). It's made to be extremely simple to install so that genealogists with minimal technical abilities can get a website up quickly. You just upload it to a server and upload a GEDCOM* file and all the pages spring to life. There's no database setup, no required config file. It uses an SQLite database for caching the geocoding results. * GEDCOM is a sort of lowest-common-denominator plain-text genealogy database that any genealogy software can save to. Kind of like CSV export.
It's not common in my world. I would let the boss know, if truly applicable and you can't get by, that the senior isn't able to provide you with the mentorship as discussed. 
This. As someone who works with both daily... I'd love it. Might jizz myself thinking about such a creation.
Double-splat/kwargs might mitigate the entire need for named parameters. Based on the discussion here, named parameters seems like a bit of syntax mine-field. But with (double)splat mapping keys to arguments, you could get almost the same capabilities with only a slight increase in typing: $api-&gt;getFriends(...['screen_name' =&gt; 'phpdrama', 'include_user_entities' =&gt; true]); 
I'd like "-&gt;" syntax changed to "." and concatenation done via "+". I'd like all types to be objects whose methods can be overwritten.
good
Declaring a function/class inside an if loop. Actually being used in the app I maintain. It's one of those things that you look at and say "This is too dumb to actually exist, there must be a reason they did it this way" and you don't touch it. Don't poke the bear, as it were. if ('foo' = TRUE) { function obscenity() { // I tried to write something here but my brain went on strike } }
Don't forget, features get accepted not just because of how much they benefit but also how difficult they are to implement or how much of the engine they change. Traits might seem like a big feature, but it's mostly bolted onto the side of things that already exist. Accessors might actually be more difficult to implement and have more consequences even if they are more useful/valuable. 
If you break backwards compatiblity, you're just creating a new language. And there are plenty of other languages to choose from already. It's pointless. The last time PHP really broke backwards compatibility was between PHP4 and PHP5 and it took *years* for people to migrate. I *still* have production PHP4 code running. The same thing has happened with Python; Python 3 still hasn't replaced Python 2. If you have the choice between migrating from PHP to an incompatible PHP-NG or say Python. Why would you choose a brand new language over one with a long history and huge user base?
I don't understand the downvotes for simply asking a question, lol. Funny, too, how the people bitching about PHP subscribe here. Makes sense.
True asynchronous programming. I can't really say how it would be implemented, but I wish it was there.
What would you pull in from python? What would you pull in from PHP?
Might want to think about a new job. If they hired a sr dev who can hardly type I believe there could be bigger issues here. 
Just see what happens, odds are you'll over-qualify the 'senior' dev in ~6 - ~12 months depending on the actual complexity of your tasks &amp; if you're completely committed to learning (and if you're willing to prove that to your actual employer).
What does PHP do that Python can't?
I dunno. Using the litteral approach demonstrated in your argument could be easily achieved. If the array has numeric keys they work in order. If they are named it uses the name. I dont think this would ever replace named parameters, just help dynamically assign parameters to named parameters if you have an array of stuff to pass along. Splat on a zero-based index does ordered keys. Kwargs (same splat syntax) on named key array does "double-splat". Still doesnt impact named parameters. Right?
In you career you will often encounter bad developers who are worse than you at coding but in better positions. So in my experience it would be wrong to leave your job. Instead try to do your job well, learn from the project you're working on, learn by yourself. Your boss will see this. He will appreciate. If not, screw him, you'll make some experience and then move to a cooler job with higher pay. 
That's assuming of course that the Sr. Dev doesn't take full credit for all your work. Also assuming that he doesn't blame the fact that his code is buggy or slow as hell on the Jr. Dev (seen it). While getting experience is good, that experience might be worthless if you never get a finished project done. It might be less than worthless if the finished project is absolute shit that is unusable. And sticking with a job as a beginner where out of the gate you know more than the guy who is mentoring you is also highly pointless. The point of taking a Jr. Dev position is so that you can learn from someone skilled and experienced who can help you refine and improve your coding skills. After he sticks with this job for a while, he's going to get out and still be a Jr. Dev, and that might look bad on a resume (spend 2 years as a Jr Dev, still has Jr. Dev coding skills? Employers might think he either has a learning disability, or doesn't listen to advice from mentors).
That was me! Let me know if you stick with it and what sold ya :)
Damn, this is the strongest indication I was too hasty yet.
Thanks, I find myself agreeing with some of those points.
For the record here, you do not need to master or even know C to contribute to PHP. We need new contributors for documentations (and given how much text is written here, it should not be an issue to write some docs), for QA (write phpt is easy and pure php), testing, etc. Time is an issue tho', for any of us, but to find time to do small contribution should not be a problem either. You have time to write things everywhere about how good/bad php is after all&lt;/troll&gt; :) More seriously, there are dozen of ways to contribute. And don't let you shut down by 1-2 people, they are not controlling PHP. RFCs vote do.
Variadic function definitions.
You definitely want someone to mentor you in that position. If he doesn't, just make sure your code is cleaner, commented in "your" manner, not his, easy to differentiate between yours and his code. Hopefully, you'll be using version control (i.e. git ) Ideally, his boss would know "some" tech... I'd work on figuring that out. If he isn't at all techie, he'll never know how worthless his "senior" guy is. Or, perhaps you misjudged him and he'll start out impressing the heck out of you. Hope that's the case. Meanwhile, get a paycheck, and while you're there, learn what you can and if it sucks, plan on after about 6 months, updating the resume and leveraging your experience there to get your next better job. I say 6 months, because I'm sure you'll learn "Something" there and it shows that you gave it a try and were worth keeping around at least 6 months... Good luck
Have you run these tests with a profiler? Which functions monopolise your cpu? Need more details before propose a solution. 
 - Standards need more attention (we have PSR but AFAIK PHP does not have a solid stand on best coding practices that newbies are aware of) and tools need to be provided (think phpCS but works out of the box as CLI tool and contains a PHP standard as default scan method) - phpDocumentor 2 integrated in main package as CLI tool. - Same could be said for PHPUnit.
Your comment makes no sense.
&gt; or putting some stuff together You mean like concatenation? 
Definitely wait to see what his work is actually like before talking to your boss and running him into the ground based on a hunch. A good mentor is worth their weight in gold though. If you're not happy with his skill level then I'd start looking for a new mentor.
So long as you are using a version control system of some sort there should be ample opportunity to point out that they are wrong if it comes to that.
The issue you may be having with connecting to the 192.... address is that you are on a 10.x.x.x address. If you're on Windows, find your local address by opening a DOS prompt and then type ipconfig. On Mac, open a terminal and ifconfig. Look for either a 10.something or a 192.something address. If you find you have a 10.something address, change the IP in the Vagrantfile to something like 10.0.0.45 and then at the terminal in the directory with your Vagrantfile type `vagrant reload`. This will reload your virtual machine, changing the IP address in the process. Once it boots back up, try connecting again. If it works you should get the Apache default "It Works!" page. The answer to 1. is "Yes". The folder source is expressed relative to your local host machine. "./" means "this directory that we are in now". Question 2. is also yes, it creates everything like that for you.
Yep, try this. http://www.xdebug.org/docs/profiler If you use PHPStorm, it can take the output of the xdebug profiler and analyze it for you, without you having to find another app like kcachegrind or webgrind. PHPStorm ftw.
I would see how things go for the first few days, maybe a week. If it becomes clear that your senior coworker isn't quite up-to-snuff, then bring it to your boss. What sort of project are you working on? Anyway, let me know how it goes!
&gt; "." means concatenation, "+" for addition or putting some stuff together. And your point is? Python is more than capable of recognizing when "+" means addition and when "+" means concatenation. &gt; It will completely backwards incompatible. That's strange; I don't remember the question being, "What single feature that's completely backwards compatible would you want to see added to PHP?"
This is terribly written. &gt; Sitting in a performance work chair from Herman miller, a cup of Columbian Folgers’s coffee with **an** Apple MacBook Air – all these can make a programmer ~~to~~ enjoy an idle work place. But the comfort zone doesn’t just end ~~up~~ with this list. They all *? [citation needed]* love to explore a nice IDE, where they do not have to invent any code syntax *[are there IDEs where you do have to invent code syntax?!]*. An IDE is **an** Integrated Develop~~er~~**ment** Environment, which is a coding/development tool ~~where the programmer has to peek in all day long~~*[meaningless]*. It might either help them to do their jobs faster and **more** efficient**ly** or make them *feel* sick and ~~feel~~ helpless. Over the ~~period~~ **last few years,** IDEs **have** evolved ~~much~~ **greatly,** and many of them contain: Even with these edits it's terribly written. Not sure what you're saying with this article. You could basically have copied and pasted these from the vendor websites, and there's little or no opinion or insight.
*this is super important* The design and implementation of RFC's is not the only maintenance that has to be done, and I'd say it's not the most important. When it comes to writing an RFC, the ability to write C, or the ability to attract attention from others that do, surely helps ... but this isn't actually the most important part of maintenance, I'd say it's pest control ... You can get involved in a very useful way by just resolving, or reporting and resolving documentation bugs ... https://bugs.php.net/search.php?boolean=0&amp;limit=30&amp;order_by=id&amp;direction=DESC&amp;cmd=display&amp;status=Open&amp;bug_age=0&amp;bug_updated=0&amp;bug_type=Documentation+Problem You rarely need C for this, there is also translation of documentation, which is a huge job and something you can do if you speak a language other than English, again it requires no C PHP's documentation is one of it's biggest strengths and it's super important that it is maintained to the same standard as the code, at least... As Pierre mentioned, there is also writing tests, one for each reproducible bug would be good, and you don't need C for this ... If you do know C, then there really isn't a good reason not to get involved, you don't have to write a patch or an RFC a day, but why not make yourself available for questioning, put forward your opinion and knowledge, and when you can write some code ... I cannot understand people who say they know C but cannot make sense of PHP's codebase, the reason you cannot make sense of it is you have not tried ...
[But it does](https://github.com/php)
If someone takes credit for your work and you don't say nothing then you have a bigger problem.
I'll go with PHP Objects, Patterns and Practice too.
Agreed. Though for accessors a patch was proposed (so it was implemented), I was just depressed by the debates and the questioning for a feature that was very demanded in the user world. And in the end -&gt; rejected.
Your code looks nice and tidy :-)
I went from 80 hour weeks 3 years ago to 35 hour weeks now. Never going back.
named parameters would be nice.
If it starts trying to compress your SASS files and lint bad javascript in the middle of a multi-file replace, you're gonna have a bad time. Close searches when you finish and don't be careless with your file listeners and you should be okay. It's very, very smart and has significantly improved my workflow (MacOS w/ local VM eating a bunch of resources.) 
Consistent naming of the built-in functions (i.e., strpos(), str_rot13()).
And here is an example of simple immediate possible contribution: Know well twig, bootstrap, html(5), css and co? Ping me! Need templates conversion (twig) for windows.php.net. @pierrejoye or pierre@php.net
Some string classes rather than all the oddly named functions we have.
Yep, Guzzle is great. Amazon's official AWS PHP SDK uses it as well.
Native JSON construction/manipulation. Instead of: $json = new \StdClass(); $json-&gt;subSection = new \StdClass(); $json-&gt;subSection-&gt;another = new \StdClass(); $json-&gt;subSection-&gt;another-&gt;again = "hello"; Have something like: $json = new \Json(); $json-&gt;subSection-&gt;another-&gt;again = "hello"; // creates all paths Be able to just define a Json type object and manipulate properties any level deep without defining stuff as classes again and again. And I know you could do: $json = json_decode('{"subsection":{"another":...'); But sometimes the logic in the code isn't such that makes it convenient to build that string. And it's also possible to do: $json = json_decode(json_encode(array("subsection" =&gt; array("...")); But again, that's a funky, indirect way of getting to what I want. Basically, a bit more native-feeling use of JSON objects in PHP would be pretty cool. Particularly as I receive a lot of JSON objects (as strings) via the REST API POST/PUT requests. 
I don't think PHP is worth saving. The incredible amount of baggage and cruft the language contains is mindboggling. It's not lacking in features, but has historically lacked cohesion. Introducing cohesion would destroy backwards compatibility, adding it on another layer would introduce a whole other stack of problems. In the end, I've just moved to Python and Ruby.
Looks very useful, nice job!
Thanks!
So... you want Java?
The main reason I don't contribute is time I guess, although I think the mailing list can be a bit harsh on people. It's a combination of both. My impression about the mailing list is actually a bad one. It seems completely random if a function is merged into the PHP standard library. Most of the times you'll read something like 'It belongs in userspace' or 'You can make an extension of it'. What's the problem with adding useful utility functions to the standard library. If you don't want to use it, then don't. Documentation of the internals is available, although it's a bit scarce in my opinion. I wrote two extension just for fun (one is publicly available [here](https://github.com/rbakels/oath-php), the other one will stay private for now) and I was actually somewhat impressed by the internals. I don't think documentation is the problem, if you invest some time reading through the available documentation and reading the source you can master it quickly (provided you know C already). Reading some blogs help as well (your blog is a good example :-). Developing programming languages is an interest from some time actually (I implemented some toy languages within PHP just for the fun of it). But I think it will be a huge step to actually do something with it. So currently I only read the mailing list to keep up with new features and try to follow some discussions :). 
If by Java, you mean every language that isn't C, Perl, Haskell, or PHP. That list includes Ruby, Python, Lua, Objective-C, Javascript, Java, C#, Go, etc.
&gt;Most of my experience is in school with some limited amateur stuff I did for myself and friends. So ... you're admittedly a rank amateur, that's fine - we all start somewhere. However you then go on to say: &gt;I would estimate that his level of coding knowledge is roughly equal to, or maybe even less than my own. So, you start off by saying you don't know much of anything, and then you continue on by trying to tell us that you know enough to judge the capabilities of other devs? This is like me designing a simple lego house, and then proclaiming that I know how to judge how good or bad an architect is as a result. What criteria are you basing this determination on?
Like said below, [it does](https://github.com/php). But then again, IT, programming and Open Source existed long before GitHub. Even though it's a great tool, GitHub is just a tool. Monoculture, much ? :/
You know you don't have to use PHP, right? Oh, you probably want to remove the semi-colon, make everything an object, strict type etc.... nothing wrong with them, but if you go this way, at the third light, make a left, you'll probably find what you want. Thanks for coming, and don't forget to close the door behind you. 
I love those little libraries of yours: clean and useful. There's one problem on this one IMO though: no locale support/integration. I.e. I want to display numbers in the user's locale. With how it's implemented, I need to hande manually commas and thousands separators. It would be awesome to integrate it with a locale library (I don't know which).
It's a team sport and we all play different positions based on our strengths. Wait and see how it goes, maybe you will be the better programmer, but the other guy is better at extracting requirements and the interpersonal stuff. You never know, it could work out. Go into your project thinking positively and don't be a dick about anything based on your preconceptions.
Congrats! Especially for starting from the GEDCOM standard, that way it's directly usable and it doesn't tie me to your software. I'll probably try it, I have a GEDCOM file.
Also, you should add a link to the github project on the website.
you can just do: $json = (object) array( "subsection"=&gt; (object) array( "another" =&gt; (object) array("again"=&gt;"hello") ) ) As of 5.4 you can do it even simpler: $json = (object) [ "subsection" =&gt; (object) [ "another" =&gt; (object) ["again"=&gt;"hello"] ] ] But yeah, since you can declare an array using [] I can't see how it should be much of a problem casting an array as an object if you declare it with {}. It would be the next logical step at least. 
So go ahead and use one of those. Why are you trying to make PHP into something it's not?
Because people who build editors/IDEs don't deserve to eat, right?
&gt; I don't know what you guys find so peculiar about 80 hour work weeks Because not having a life outside of work is actually abnormal for most people. I'm not going to tell you you're wrong though. If you love what you do, you should keep on doing it.
Seriously? I've used PHP almost every day for the past 12 years. I don't hate PHP. This is a thread about what changes people would like to make and your immediate response is "WELL IF YOU DON'T LIKE IT, THEN LEAVE?"
This is a really nice library, and I will find it extremely useful in some of my projects :) That being said, considering its a composer install and has 90% test coverage passing could you not tag a stable release for those of us who set "minimum-stability": "stable"
http://www.reddit.com/r/PHP/comments/1ltulg/what_single_feature_do_you_want_to_see_added_to/cc2u3kh
Well, to be pedantic, this thread is about what you want to be *added*, not changed. Still, concat and method accessor syntax is *way, way* down the list of things that need an improvement in PHP, wouldn't you agree?
Why do you bother with objects? Arrays are more appropriate in this situation. The following code is fully valid (no warnings/notices): $json = []; $json['subSection']['another']['again'] = "hello";
Am I the only one held back by the snake case? I feel like an idiot because it's probably very good but I can't stand the snake case.
What do you expect this code to do? `$array1[] = $array2[] = $value;`
Yeah, you right, non stable composer package can cause troubles in stable ones. I've written the library in 2 days in my free time, so, although it's well covered by tests, I prefer to mark it as stable after having used it a bit more.
if they're using a vcs the commits should show the user who committed it. so why wouldn't the boss believe that the commits that came from his computer were his.
This. I want this so much it almost hurts...
Learn as much as you can BY YOURSELF and with the project itself. Don't try learning from the senior. One day you will overpass him. Developers come and go they don't stay 10+ yrs in the same company. At the same time don't underestimate - he might not be a good coder or have a old school style - but he might have experience in launching projects successfully (technical side) - so don't judge too quicjly
http://en.wikipedia.org/wiki/Function_overloading
&gt;I made my employers fully aware of the extent of my expertise (or lack thereof). Sounds like he's underselling himself, not uncommon, and this is the exact reaction I'd expect from someone that thinks they suck and just got thrown into the real world where people actually do suck.
http://www.phptherightway.com/ is a brilliant site to get you up to speed with "(Mostly)Everything a proper php dev needs to know". &gt; At the same time don't underestimate - he might not be a good coder or have a old school style - but he might have experience in launching projects successfully (technical side) - so don't judge too quicjly ~mediumblob This is too true. Like php, all devs are interpreters of code, we all have our own flair and style and if we stick to the basics, it's not how you get there. Even if you have 10 years worth of experience, you should still practice/learn/play around with code. The technology changes so fast, stuff I learned in varsity is not applicable anymore. We didn't have any Namespacing or PSR standards, We barely had OOP and MVC back in the day, it's almost like learning a completely new language.
`callback(($shorthand) ==&gt; $shorthand-&gt;syntax)`.
No curly brackets anymore!
&gt;"you're technically very good, but no one else in the business has any idea who the fuck you are" How do you deal with that? I know some people who are really technically skilled. I'd say they are critical persons to the company as the bussiness heavily depends on the software used. But people behind the software are practically unnoticable in non-software circles. Do you think it is the interest of engineer to be "known"?
Perfectly acceptable. It's not overly obvious but it's almost a programming Easter egg. I love finding things like this in code I'm reviewing.
Haha, is this a real question? Honestly I'd probably use this: $lookUpTable Always best to be as verbose as possible when naming variables.
Nah it was more of a joke. Already changed the name haha.
Given the amount of verbal abuse you've given me, I believe I am well entitled to repay you with at least one in return. Here I am, trying to help you out, and this is what I get in return for my effort? Fuck you, OP. It's not my fault that you misread my posts, and the fact that you keep on doing so even after I've clarified them suggests you're doing it intentionally. I don't need this shit. Congrats on being a huge d-bag.
There's always someone who responds to these threads with "Get a new job" but honestly getting paid to learn how to code is much better than not getting paid to learn how to code. Worst case scenario, he reads books at work and becomes egocentric, which isn't bad if he can come off as confident rather than arrogant.
Semi related - anybody know if JetBrains is going to discount PHPStorm this year?
From Python: - no more variable token, goodbye $ - no more curly braces - partially no more regular braces (ifs, loops) - everything is an object - operator overloading - clean array notation - string/array slice notation - named parameters From PHP: - general simplicity - web baked in language (get, post, sessions, headers, etc) - streams (file_get_contents(path|url)) - godlike array functions - run &amp; die execution model (?) 
Either I am dumb or you're short sighted.
Run Wordpress.
Native internationalization (I18N) support.
yeah, i don't give a fuck about all the bitchies here. one of the first lessons i learned after joining the internet :D the worst part is, that people are not even TRYING to be constructive. 
Yeah, I installed AMPPS and its really cool, but can't use it much since our internet is messed up for the moment. I will likely run it on a different PC to be the server. Also I got to figure out what kind of server code to use. I have a separate post on that: http://www.reddit.com/r/learnprogramming/comments/1loc7n/what_is_the_simplest_serverside_code_to_use_for_a/?sort=confidence. Thanks again!!
And maybe an option to use SI style &gt; 1 234 567.89 or 1 234 567,89 (in their own publications the dot is used in the English version and the comma in the French version). Basically a short space as a thousand separator, this way both dot and comma means decimal mark. No conflict between Europe and English speaking countries. 
I've been programming for 20 years and I still hunt &amp; peck, albeit very quickly. On the upside, I very rarely make typos.
Yes. Imagine being in the meetings when bad decisions are thought up, and being able to put a stop to them instead of have them pop up in week 10 of project launching next month.
From the security point of view, a few comments. At first, using a third-party service to let directly generate your random numbers leaves a question about trust. Can you trust the third-party? Can you trust it tomorrow? Is the trust justifiable? Second, the service is accessed in an unsecure fashion (HTTP). Third, there seems to be a bug that lets one to generate always number 1 (this should probably be 1 or 2). According to the random.org FAQ, the numbers generated are uniformly at random distributed, which is great. Too bad there is no native function in PHP (yet) that can generate cryptographically secure random numbers with uniform distribution.
I'm for strict type hinting. The point is to validate input when you get it, not just send whatever wherever. Then you don't need checks for is this variable this type in every function! If you don't like strict type hinting you don't have to use it. I feel like the weak type hinting is a poor compromise which will be like register_globals in a few years... 
I am on a mac. when i do **ifconfig** i don't so any IP's that start with 10.anything. Here is a [gist](https://gist.github.com/dadamssg/6463063) of my Vagrantfile. Does the "private_network" have something to do with why i'm not seeing anything? I've also changed my **Box Sync Folder Source** to an actual directory on my machine. I put a index.php in my source folder, but i still can't connect to the VMs supposed IP. I also expect to see the "var/www" directory when i SSH into the VM and do a **ls**, but i do not. I only see a postinstall.sh file
Yep, this. Add ucfirst() to that list. ugh. 
I think it is because the barrier to begin contribution is really high, and if not that part is really hidden. As one who ones to start contributing, would like great documentation and support from the community. I have been using php for quite some time and am *not really bad* at C. It's just the barrier from nothing to breaking the ice IMHO.
Eh? There's nothing about AOP that precludes static analysis.
 /var/www
If you would be advertising something that complements Idiorm and Paris then it wouldn't be much of a problem. But this is kinda like hijacking the thread. I appreciate your contribution to open source though! **EDIT** I didn't downvote you though.
That would be nice. Using `func_get_args` is such a shitty workaround.
Bonjour/Hello, Symfony CMF would be an interesting area to consider as it seems to me that one thing Symfony could use is a stable CMS solution. They are nearing the 1.0 release but I don't know how far off that is and documentation could certainly be improved.
This would actually be very easy to do in a class. Use __set and __get to automatically build the document behind the scenes and toJSON to render that document out to json. This actually sounds like a fun tiny library project, I might do it.
When your mentor is your peer, it's time to move to a new team. Don't waste career time where you can't learn from someone better. 
They do, I just prefer open source. Most people I know that use storm use a stolen key.
 public function getNeededVars() { $this-&gt;var1 = $this-&gt;model-&gt;getVar1(); $this-&gt;var2 = $this-&gt;serviceApi-&gt;requestForVar2(); } Get?! This method sets the values of the object. It doesn't even return anything. The fact that this method "gets" anything is a big lie!
When I read your headline, I thought I was going to read something along the lines of, "I just did a sudo shutdown -h instead of sudo shutdown -r on our remote server, help me reddit". Give it a bit of time, besides you aren't going to be blamed for any major fuckups at this stage. If you don't get the mentoring you want, stay in your job, get the experience, then start looking for a way out. You're golden. 
hahahahahaha, oh wait, you're serious, you really think management listen to devs....
Reading through the thread, I can see that most people are jumping to the same conclusion that you are based on your description of a few conversations. I say hold off all judgement until you've dug into the code with him. In a corporate environment it can sometimes behoove you to underplay your abilities. I've worked in a corporate job where it didn't matter how much you did or how well you did it, if you finished early, they just assigned you work from somewhere else and left you with 125% of your original work. If you finished that early, they upped it to 150%. And so on until you're completely buried at which point management starst taking stuff away from you and giving it to other people that are finishing early and stop giving you good performance reviews and thus eliminates raises and awards. People that figured out the system would just turn stuff in on time and not early or late and cornering the raises and awards department from people that are more ambitious than them. All that said, if the dude's code sucks, then it sucks.
I love that people write tutorials - it makes it easier for people to learn and the one thing I've become positive of over the last few years is we need more software developers. However, more complete tutorials are ideal. In this case, a failed (non-200 response) request doesn't operate as expected, and the code doesn't involve any error checking. The author also ignores random.org's usage guidelines. 
Very good idea. We will definitely keep this suggestion in mind!
Can you be more specific? What kind of features would you like to have in this View layer?
are you planning to add support for arbitrary precision numbers (bcmath) and arbitrary length integers (gmp)? :)
I've done that before.
But what about backwards compatibility!? There's a PHP 3 script written by a lobotomized cave-dweller in 1999 that relies on undefined bare words to be interpreted as strings! Why do you want to break his script!?
If you're a junior dev, I'd suggest listening to what the senior dev has to say first. Take every word in, try to understand it. Ask for references from the senior dev. Ask him/her to explain the whys behind what is going on. Then do your research by yourself and see if it supports his/her claims. Sometimes if you're getting into something new, and you think you know better, it will hurt your learning potential. Then again, sometimes the senior dev doesn't know what they are doing. But by the time you REALLY know this, you've already done the research yourself and you know WHY it's wrong. Be open, you can always learn something from someone, even if it's how not to do something. 
At least we have [openssl_random_pseudo_bytes](http://nl3.php.net/openssl_random_pseudo_bytes) now. That's a start.
I've just accepted a pull request that implements a default locale fallback in the new method "localeFormat".
Unless it's an intro to C++ and they make you recreate every wheel without the STL *shudder*
Yes, but joins are a very basic and intrinsic part of SQL.