How about we just make php not throw notices on undefined values? I feel like the arguments for that are just as good as implicit issets. Or, make everything have an implicit isset.
What I always do, is in the case that I know a variable might be blank but not care if it is, I just use @ to suppress the notice. Then I get: echo @$_GET['page'] ?: 'home'; Which I think is an already great solution. I already have a fallback if it's blank, why not have the same one if it's null? If I need a more complex one and I care about it not being null and only blank, I wouldn't use the shorthand ternary in the first place. But I think this is a good solution if for example, you wanna populate a label or textfield or whatever with a value that has a default.
No, that's not smart. You wanna make sure the code is properly organized, and non-existing variables are an easy way to make a mess and not be able to debug easily if you don't code right. 
Ah, nope, not at all haha :) sorry. You should add a /s at the end
Your first example isn't what's being proposed in the RFC.
On PC I found Atom to either be non-exsitant or slow (it's preeety new). NP++ just works, handles every file ever, has SUPERB editing modes (keyboard driven column selection, drool) and is as snappy as you could want. Annnnnd it's free. Since it's not the primary IDE, there wasn't much reason to invest in anything else.
&gt; slow as molasses startup time for PHPStorm vs. sublime/notepad++ ...which is why I keep it open indefinitely. So using it for scratch won't really incur startup fees cause it's basically always up and running.
Go with Exceptions.
Thanks, that cleared it up. I still think it's crazy to arbitrarily pick a few words to be treated specially. Why not include "d" for "don't know" as NULL? Perhaps the fact that it's missing from the 1.2 specs is an indication but then it's been out so long that probably a lot of code depend on this behavior and we're likely stuck with it. EDIT: Looks like it's actually going away. From the 1.2 version: &gt;The primary objective of this revision is to bring YAML into compliance with JSON [...] In this version of YAML, boolean values may be serialized as “true” or “false”;
&gt;Trying to compare Doctrine and Eloquent to Magento's ORM is a waste of time, because Magento uses an EAV database structure. I mean, I'd actually say EAV is the problem. Its got its uses, but a e-commerce store is definitely better suited to a different data model. One of the biggest reasons is the whole concept of Eav is directly in opposition to the Set Theory which relation databases are based on (relational algebra needs a schema). It tries to force a schemaless data storage format onto a data-store that requires a schema and so does away with all the benefits you get with having a schema. You'd be better off just going with a schemaless data store and then defining the actual schema the entities/models map to in the configuration. Now you have a human readable database, you don't need to make a bunch of joins to get your data, and you haven't lost any additional flexibility. You could even create some sort of inheritence hierarchy to allow schemas for certain products to extend others. Base Product has attributes: name, price, stock. Chair Product extends base product: Has all attributes of base product as well as is_wheeled, can_recline, fabric_type. The only case this doesn't cover is needing to create custom attributes at runtime, and that could be doable with custom code but its also an extremely rare requirement (and I'd even argue that when it is needed, its actually the an incorrect solution) &gt; If you think Magento's templating system lacks functionality you've clearly never tried to use it to its full potential. I get quite a bit of enjoyment sometimes working out new ways to bend Magento's internals to my will. I've used it quite a bit, and I'm not saying you can't achieve anything with it that you can do with twig. I'm saying it lacks some of the functionality to make templating easier. A quick example off the top of my head are twigs built in filter functions (and the ability to design your own custom ones). If I want to show a date in twig I can simple do {{ "now"|date('m/d/Y') }} or if I want to display the size of a set I can do this &lt;h4&gt;You have {{ products|length }} products in your cart&lt;/h4&gt; &lt;ul&gt; {% for product in products %} // 2 decimal places, capitalize first letter of each word &lt;li&gt; {{ product.name|capitalize }}: {{ product.price|number_format(2) }}&lt;/li&gt; {% endfor %} If I wanted to do this in Magento's templating system I'd either have to compose and define a block and then register them in the layout/config xml or I'd have to create methods on my product class that only exist to format data for the view (seperate concerns). Its also a lot more work, which translates to more time, which translates to more expenses for your clients. I'm sure Magento can achieve any and all of the functionality of Symfony, but what I'm getting at is that in my time using Magento(16ish months) the amount of effort I'd have to expend to achieve those same things was, more often than not, much higher and the resulting code was much less understandable/maintable than in Symfony (I keep referencing Symfony as it is the framework I know best). My honest opinion, Magento tries to be both a framework and an out of the box shopping cart solution, and those are two different things. Magento's end product was the out of the box solution, and so they split their focus between making a framework and a shopping cart and the framework part of their product suffered drastically for it. You get a shopping cart solution that works, and is actually usable out of the box, but as soon as they start selling it as a super customizable modularized solution is when they go wrong. Make these two different products, one built on the other. I get the feeling you haven't had a lot of experience with some of the alternative frameworks to Magento (not talking ecommerce solutions). I'd recommend you take a look into Symfony, and even Sylius(Ecommerce on Symfony). I'm willing to bet that you will enjoy your experience.
This is my primary use for sublime text.. opening quick files not in my project.
Perhaps, but google is just as good for basic MySQL issues. If you're having a basic MySQL issue, there's going to be 4 articles about it already. Trying to get comprehensive advice about your specific, complicated, high traffic MySQL installation out of Percona? Good luck...
~~This is the only correct answer to this question.~~ I may have misunderstood the question. If OP is making a kind of *validator*, whose only purpose is to report whether a given value is valid or not, a boolean is the right answer and an exception most definitely is not. If instead the validation happens inside the URL builder or whatever it is, which is how I understood the question, exceptions are the way to go.
Do not use exceptions. use booleans instead. The function is supposed to answer a question. Does this piece of data fits this criteria. It either fits or it does't. So return a boolean. It is upto the calling code to decide if it can proceed with a piece of invalid or missing data.
The answer to your question lies in the details of what you are wanting to make. The package is defined as an input validation library that is used to validate information given to it and notify the system calling the library as to the result of this validation. Because I see exceptions are recommended multiple times in this thread, I will start with them. Exceptions are used for handling an unexpected occurrence. In the case of validation, it is expected that validation will either say the item is valid or invalid. These two states are expected and normal in the execution, so they are not exceptional to the system. InvalidArgumentException is designed for a different purpose as well, that being if the argument is not of the correct type. It is also a Logic Exception, which is defined as an exception that leads to a direct fix in the code. An acceptable use of exceptions would be to throw InvalidArgumentException if you are validating a number is between 0 and 2000, but the comparison is only safe for integers and the given number is not an integer, but a string with a number. Whether or not the number is between 0 and 2000 is not an exception. Assert should not be used because it does not match the definition of how to use it. &gt; Assertions should be used as a debugging feature only. You may use them for sanity-checks that test for conditions that should always be TRUE and that indicate some programming errors if not or to check for the presence of certain features like extension functions or certain system limits and features. This leaves your last option: returning a Boolean. This option is most likely what you will be using for input validation. Most validations are checking if it is something or is not something. tl;dr: The correct answer for this question is returning Booleans and acting appropriately to them.
Well, they are not really the same thing. One is a ternary operator, and the other is a *shorthand* ternary operator. The latter can have its own mechanics. While I agree that in theory they should work in the same way, in practice it kills most of the practical uses of `?:`, so I'm up for the change. +1 if I was a voting contributor
Can say only for myself. But most of my projects are really ugly twitter bootstrap things and I'm okay with it because they function just as I want. 
What's the diff between laravel and Symfony2? Could you provide any info for doing TDD? The only reason I heard of TDD is because I was thinking about doing a coding bootcamp.
This is not just when using `$_POST` and `$_GET`.
For me, the shorthand changes the logic. As I see it, in the classic way, it checks for a `bool` value and returns `mixed`, whereas the shorthand checks and returns a `truthy` value. When we are using the shorthand, what we really are looking to do is offer an alternative to an empty value, and that is what this RFC offers. As I said, this is a gut vote as everyday coding has shown me how useless the shorthand can be without a built-in `empty()` check. In Javascript this is used constantly, and has been working fine so far. We sort-of implemented it and didn't work, maybe it's time to fix it. *Just as a note, I just got up and checked /r/php before breakfast. My opinions may vary as the day advances :)*
And what about 6?
MariaDb is now on 10.0, which is faster than the 5.7 current in alpha, let alone 5.6.
For the record, I don't dispute that `?:` is practically much less useful than would be nice. I just think making them behave differently is a bad idea.
Could you list a few? I could really use a side project but am never able to come up with anything interesting to do :|
I am not sure using something like this outside the scope of dealing with user input is good idea. In the case of variables set by the user, the question "if this variable is set" should not exist rendering this function pointless. 
What's the point of ?: if it's not useful? 
Not everyone's using the latest and greatest fancy framework, and even those who are will still be affected by this.
How?
Unfortunately that sounds like an argument a lot of developers would make, so it wasn't obvious to me as well.
JavaScript doesn't throw any error and it's a nice feature, as you can do `x.y || foo` but not `y || foo`. However, it has its problems.
Query strings and request bodies aren't the only source of user input.
Would be great if you could elaborate..
JSON data, XML data, reading from disk, processing API output, handling data in memory, etc.
It is inconsistent, yes, but it makes `?:` far more useful and simplifies an incredibly common operation.
&gt; Not everyone's using the latest and greatest fancy framework It would took 10 seconds to write a wrapper function in *any codebase*, so you don't have to use a "fancy" framework.
Please read [this](http://www.reddit.com/r/PHP/comments/2fjmp6/percona_or_mariadb_which_one_should_i_pick_for_a/ckaofdh).
With a quick skim on https://github.com/panique/php-login-advanced it is not secure (i.e. randomness issues, timing leaks, "deny login DoS" and so on) and its architecture leaves quite a bit or two to be desired. No login process etc. is secure under non-SSL situation. Personally I wouldn't recommend using it.
Any other recommendations?
None. There's also PHP Desktop, which is maintained, but I have yet to try it. https://code.google.com/p/phpdesktop/
I hope that was possible. The Laptop is dead beyond repair. I have decided to buy another one, just *which one* is the problem. I have a budget of $1000 so, I guess I am looking a bit more than the bottleneck. 
Not much experienced regarding laptops, but if you ask me I would say buy something with a lot of memory, (8 gb+) that runs cool and have a big, matte screen...Bonus points if you can add an ssd in addition to the built in hdd.
I love using my MacBook Pro for programming, the screen is a bit small at just 13 inches but it's a good size for carrying around with you. It's a bit on the expensive side of things tough if you want to pimp it out. I would recommend you to get a computer with a minimum of 8GB memory preferably 16GB to future proof it a bit, and at least an i5 processor and a 256GB SSD drive. Get a thin laptop that weighs less, don't buy one of those cheap ass plastic laptops for a couple of hundred bucks, get something in the $1000-1200 price range with a good build quality and a low profile. They are so much nicer to use over an extended period of time.
The problem is with the specification you have given, 8GB-16GB, 256GB SSD, core i5 that would be double my budget right now. The most promising one I have found so far within my budge is [this HP](http://www.interdiscount.ch/idshop/product/Notebooks/910114_ER-8815159672833/HP-ProBook-470-G1-Core-i7-4702MQ-2.2-GHz-Win/detail.jsf) 
Or, like the OP, you could realize when the language is doing nonsensical things, bring them to the attention of the community and propose changes, thus bettering the language. Of course you can always just ctrl+v ancient lolphp sentences and be useless.
using the option parameter Arras you can add a default key.
&gt; they should really stop with these half-measures when it comes to PHP and be a bit less lenient about fixing up old flaws like this one. Obviously bad idea? Let's VOTE on it. AGAIN.
C# solved this with the null coalescence operator A = x ?? 3; Easy enough and not adding undue weirdness into the language. Example here: http://msdn.microsoft.com/en-us/library/ms173224.aspx
Maybe im not reading this right, but for the isset shorthand, mapping to "empty" internally seems problematic. There is a significant difference between isset and empty that will bite you in the ass at some point if unaware and this proposal would make that difference even less transparent.
Whoops. Fixed it.
Would be great if Sequel Pro handled it. :(
Doesn't really matter what the processor specs are. You really just care about pixel space (and RAM, but 6-8GB is easy to find and is plenty). Since you use an IDE, you need to be able to have plenty of room in it for all the toolbars and menus. I highly recommend buying a large external display or two and hook up to them when you are at your primary place of work. If you go that route just make sure your laptop has the correct display adapters/ports. 
I will of course suggest [Aura.Auth](https://github.com/auraphp/Aura.Auth), at least as a starting point. (I am the lead on the Aura project).
Few things. Anything, Mac or PC with these will be totally fine: 15" screen. You'll hate a 13" for programming. Any SSD. The shittiest SSD is light years better than a mechanical. Quad core anything. Aim for i5 or higher. Graphics cards are totally unnecessary. That's about it. Also buy refurbished from the manufacturer. Believe it or not, they're higher quality because all the components are checked, whereas on new laptops only a percentage of the units on the assembly line are tested properly. I used to work for a well known manufacturer and the malfunction rates for refurbs is much lower. 
Minor and maybe obvious consideration... 64bit. And make sure your hardware supports virtualization so that VirtualBox can make use of it. 
Yeah, that's why I added the edit there. I knew a new one was released since I last checked.
Main things you want to worry about is the keyboard, not the specs. A laptop with a quality keyboard can be difficult to find, although I quite like the keyboards on the Asus Zenbooks. Screen real-estate is another important factor. For me working with a 1080P minimum is a must. 1440P is the minimum for me on a desktop these days. PHP workload typically isn't intensive, or at least it shouldn't be, so speed of the processor typically isn't a big deal, and neither are the tools you would be using. A decent i3 or lowend i5 should still be fine, but since you are utilising virtualisation, I'd jump to a minimum og 8GB RAM (Partially for virtualisation, and partially to add longevity to the laptop, RAM is typically the weakest point in systems these days). Lastly, as others have suggested swapping in an SSD is an added bonus if the laptop doesn't come with one. It's a noticable boost to your performance.
I don't doubt that percona is faster either. Wikipedia has already shown it got a small but noticeable increase in speed when migrating to maria, which has reflected most of the benchmarks I've seen.
I've never seen this before, I like this solution a lot better. It's cleaner, shorter, and easier to read.
I had an HP for a while and it put me off ever buying one again. Build quality was fine but the BIOS was completely locked down so it was a pain getting Linux installed on it, and was impossible to do things like switch out the hard drive for an SSD, control the fans properly, turn on/off switchable graphics etc. Basically if you'll be happy using the shipped OS and can't see yourself making any changes, an HP laptop might suit you fine, but if you like a bit more control over things go for something else.
Yeah, I recently did an intern where I tried a 22" display for the first time, and I never wanted to code in anything smaller since then. So, external display is 100% a must. 
I am pretty sure he means in regards to everything but man-in-the-middle attacks which (unless I am mistaken) is the only thing SSL actually does security-wise. 
Yes, and it's *because of* that difference that I used it. See, I wanted to do `(isset($a) &amp;&amp; $a) ? $a : $b`, and began implementing a new type of `isset`/`empty` operation to do that efficiently (they're actually the same opcode internally, just with a different flag). However I then realised that `empty` is just `!(isset($a) || $a)`, i.e. the opposite of what we need, so we can rewrite it as `empty($a) ? $b : $a`. :) Obviously it'd be nicer to have it actually be `isset($a) ? $a : $b` but we need to maintain backwards compatibility and also do a falsiness check, for which `empty` works very nicely.
That's not a very helpful list :/ And yeah I wish Sequel Pro did it too
You could write a wrapper function, yes, but for such an incredibly common operation it seems silly to require everyone to write one themselves. Furthermore, such a wrapper function has some disadvantages: * If you want it to do an `isset()` you, well, can't unless you use references to hack around this, as they happen to not throw a notice. * You can write an array-specific one, but it won't support chaining. * Your wrapper function will evaluate your second argument. * It's longer than just `?:`, and programmers reading your code will need to learn of your wrapper function
Three things matter when choosing a laptop that you'll spend many many hours on: 1) screen resolution and brightness, 2) battery life, 3) level of ergonomic(isity). Everything else can be fixed with the proper tools and software.
Unfortunately it's one area where Postgres can't quite compete with several other databases.
I'm not sure if there is a modern, maintained, secure, fully-featured login solution right now. If you do end up building a custom one, use the password_* functions from php 5.5. If you don't have php 5.5, use this lib to gain the same functionality: https://github.com/ircmaxell/password_compat
The moment you install Drupal. Then you are a certified PHP Engineer focused on the Drupal framework development, hell i think they even have a cerificate for that nowadays.
That doesn't sound too promising :P
Can you please show an example. I cannot make any sense of the documentation..I saw this part which says "When default is set to option, default's value is used if value is not validated." What does that mean?
If Percona or MariaDB work better for you, great. But do not base your decision on those benchmarks (do always your own tests!). They are *all* PR-driven and very very very partial. Source: I have worked in the past for MySQL-Sun, Percona and Oracle. Wikipedia migrated from 5.1-FB to MariaDB 5.5. That says absolutely nothing about how MariaDB is better than anything else. I quote "The main goal of migrating to MariaDB is not performance driven". But obviously any 5.5-based version is going to be better than 5.1 (except maybe the Facebook branch in some cases, like compression, or with single thread performance).
Something about semantic versions and putting breaking changes into the major version
Perl did too, 6¾ years ago. $A = $x // 3;
Exactly same here. Goodbye Sublime. You were good but not the best.
Shouldn't it be LaravElePHPant?
And even with all that, modifying existing behaviour and special-casing one notation of a ternary operator (while keeping the other) results in yet another inconsistency in the stdlib. Is it *really* worth doing just to save a few keystrokes?
Almost any non-Chromebook laptop produced today is acceptable **as long as it has an SSD**. I can not emphasize that enough. I would prefer a four year-old laptop with an SSD to a new one without an SSD. I would rather have a laptop without a battery than a laptop without an SSD. An 11" screen would be preferable to a laptop without an SSD. A laptop with dead pixels and a few stuck keys is preferable to a laptop without an SSD. If I had a choice between a laptop without an SSD and an SSD without a laptop, I would probably take the latter.
Token space is really the only sane argument one could make. The other two points are just sheer idiocy. Ugly? Aside from the fact that this sounds subjective, this is PHP we're talking about. Programmers have to learn new stuff? *SAY IT AIN'T SO*.
lol I get the point. 
Also what does it do with objects? Does the latter call ArrayAccess::offsetExists()?
&gt; as long as it has an SSD I write software on a laptop without an SSD just fine. While an SSD is definitely a plus it is hardly necessary.
How important would you say screen resolution is?
This is why cancer can't be beaten.
+1 for Sentry. Been using it in couple past projects and it's always a pleasure to work with.
Is your 13inch MacBook a retina? I'm replacing an Air, and was planning to go 13 inch retina, but would be interested to hear from someone who finds a 13 inch retina limiting. 
Not all 13 inch laptops are equal. Retina MacBook Pros are a high resolution, and some windows machines slightly higher still. A shitty 15 inch could be lower resolution than a top-end 13inch. 
I'm sorry you feel this way but the main purpose of this kickstarter is: &gt;The purpose of this kickstarter is to help with the funding of the project and keep it going strong. I believe the Elephant is just a thing to keep the people intrested since barely none is willing to spend money on a 'framework'
What, needing to actually do work to keep things secure?
People still having to build custom solutions regarding to security doesn't sound too promising.
This is a basically impossible question. Everyone has different things they value, different things they require. We could say "you need x" and you'll say "but I don't have any use for x". You haven't even listed a budget. Laptops are a minefield of compromises. Want it more portable? It will probably be lower power. Want a higher resolution? You'll probably need a larger screen and bulkier unit. Want high performance? No battery life for you! In general, performance, weight, and price are the three sliders that work against each other. Pick any two and the other one is drastically impacted. You can get a cheap, light laptop - performance will be shit. You can get a high performance and lightweight laptop - if you can pay for it. And sure, you can get a powerful and cheap laptop - it will be heavy as fuck. My personal preference is for light weight. I carry it everywhere. I also value power. As a result, I accept paying more. I've been down the road of 15 inch laptops with two hours of battery life and 3-4 kilogram slabs of dead weight, and I'm not interested anymore. My laptop for some time has been a 13 inch Macbook Air. Less than 1.4 kilograms, and plenty of performance with a single exception: screen resolution. For most use it's great, but for web development with chrome dev tools, or for working in photoshop, or whatever... it's a bit limited. A 13 inch MacBook Pro will replace it. I should point out that I spent more than a decade using Windows exclusively for development. When I got this MacBook for travelling I found that a huge number of things were simply easier than they had been. The development world, both PHP and front-end has become increasingly command-line: git, composer, artisan, gulp/grunt... The windows environment is, IMO, inadequate for modern dev practises. I personally found I had less "friction" getting things working on a Mac, and that has been a consistent fact. You posted a link to a HP laptop that was "within your budge". IMO, that laptop is a heap of shit. Reasons: 1 - it's a 17 inch laptop. That's fucking huge. The thing weighs 3 kilograms! Not including its power pack. 2 - Despite being 17 inch, it's only 1600 resolution. That's pathetic. My Air's resolution is 1440 x 900 and it's absolutely not enough. General advice: Resolution &gt; size. Get as much RAM as you can get Don't worry about CPU Don't worry about video card/chip SSDs are good, they reduce weight, noise, power drain, etc, while increasing performance If you have a budget or specific requirements TELL US.
There [won't be a PHP 6](https://wiki.php.net/rfc/php6).
No reason other than because I've simply had it forever. 
&gt; 2/ when the plugin is installed , a system of permissions ask the user to validate the fact that a plugin will be able to use this and that functionality of that framework. Hahaha, as if wordpress users will have any clue how to assess such a thing properly, or even care about it before clicking whatever the 'yes' prompt is. What do you expect Wordpress to do? Parse the entire plugin file contents, construct ASTs, and tell a user that it contains an `fopen` call? And they're supposed to know all the implications of that? Or even any of the Wordpress public api, which who knows what is safe when?
very. I use a 13" MBP but it's 1600p so it's beautiful to code on.
It's amazingggg. The only area where it is limiting is playing games (I play CSGO on it). For coding, the 13" screen is completely adequate if you use gestures, shortcuts and other utilise to optimise your use of it (Quicksilver being a good example). And I never feel cramped. It's also a 1600p display so if you do want lots more space, you can set it to native resolution instead of the default of using 4:1 pixels to make it extra crisp.
Well the point is, we do have super globals like $_GET and $_POST. So PHP does have dedicated constructs for dealing with data from the HTTP request. So by following that logic, I think there should be constructs that can access the same data in a safe (I mean, does not throw warnings or errors) manner. So while there are other forms of user input, the design of PHP seems to assume that an overwhelming share of this input comes in the form of get/post requests.
According to the link the last default gets executed. I also can not imagine a scenario where multiple defaults in a switch would be useful in anyway... 
Hey - if Your old laptop is dying - want to send it in goodwill to me? ;) mine "decent" laptop is twice age of Yours...
Here's a code sample ... I'm not on a recent computer so I can not use 3v4l.org so that you can know when this started to work on PHP... http://sandbox.onlinephpfunctions.com/code/37a56a6174c1b84ead94725d1abab5d0e25cff3f
I agree. I have a Samsung series 5 that's 15" but the resolution is shit. It's an i7 with 8 gigs of ram, it's light and has a full keyboard, but the screen sucks balls. 
Nope. ?: still does the same thing it did before.
`public function setPasswordResetDatabaseTokenAndSendMail($user_name)` Best method naming ever.
I would choose something from: [php-login](http://www.php-login.net/), [jyggen/persona](https://github.com/jyggen/persona) (Did you heard about [Mozilla Persona](https://www.mozilla.org/en-US/persona/)? ) or already mentioned Aura.Auth ;) .
After using a ton of different laptops, go with anything Apple Retina resolution or higher. It's much easier on the eyes.
&gt;With TDD we focus on verifying that our code works the way we expect it to work, whereas with BDD, we focus on verifying that our code actually behave the way that we want it to. A main reason for the emergence of BDD, as an alternative to TDD, is to avoid using the word "test". OK
I don't, so I might sounds dumb here, but whats the problem?
You can easily create your own non-verbose method, so it really doesn't have to be part of the core.
/u/Hatte_keine_Ahnung some here seem worried about "highjacking" the shorthand ternary operator. Might you consider using OR instead? ``` echo $foo || 'something else'; ```
Wordpress doesn't do code separation so well. So you may have html and php in the same file. Which breaks the PSR-0 I believe. 
I misunderstood it, sorry.
It is bad, because it tells you this function does too much.
That would be a bigger backwards-compatibility break, and I'm not sure people would like it to stop throwing notices.
That's absolutely true, but I was talking about being explicit in method names. 
&gt; Yes, but the problem is that it changes that implementation GLOBALLY for all places where the Auth::user() facade is used. &gt; This is the problem with ALL facade/static usage. Yes, you can swap out the binding that the IoC references, but you have to do that globally. Yup, I agree with all this. There was a time I wanted my logger service to have some extra behavior, but only when used within a certain set of classes. Fortunately I was using DI. I made a logger decorator class that implemented the extra behavior and delegated everything else to the underlying logger. For the set of classes that needed this extra behavior, all I had to do was inject the decorator instead of the plain logger, and everything just worked. But if I had been using facades, then I couldn't have swapped in the decorator for only certain classes. I would have had to swap in the decorator globally, for everything, or not at all. Facades are simple and easy... but they're also less flexible.
`doAWholeBunchOfStuffAndReturnBoolean` would have been better
The generated specs don't have visibility declared on the methods, and use underscored method names? [Gross](http://i.imgur.com/4xlvm.gif).
Well, there are solutions, like Sentry (and its bigger paid-upgrade descendant Sentinel) which have already been mentioned. Just because one person doesn't know something exists doesn't mean it doesn't.
Then it would make much more sense to call it DD rather than BDD...
It's a shame the files aren't soft-saved.. still this is a great step forward.
+2 for Sentry. Very secure, and easy to configure/use.
/r/phphelp
I've started using a mix for test names: function testGetDisabledUsers_withInvalidId()
You can store the TIMEDIFF() return value in a column with a TIME type. To answer your second question might make your first question irrelevant. You can't use an aggregate function like SUM() on a temporal value, so you'd have to convert your TIME to seconds before summing those seconds off. It may be stylistic to just put the time in and time out as Unix timestamps, then you'll be able to easily get an aggregate sum from the differences. But you'll still need to format that sum to something humans can easily read (hh:mm:ss). This may be preferable than doing the conversion inversely. Also, possibly another stylistic thing, but it feels odd to have three fields where the third field is derived from a simple mathematical operation of the first two fields. It may be better to have a mySQL VIEW where your third field is calculated on the fly inside your SQL query. 
 $output = array(); foreach( $rows as $row ){ //Maybe you can skip creating unnecessary arrays, but I'm not sure, depends on the code //of course, always remove passwords and secret stuff $processed = array('one'=&gt;$value1,'two'=&gt;$value2,'three'=&gt;$value3); $output[] = $processed; } echo json_encode($output);
You're creating multiple JSON objects by json_encoding in the loop. Add the items to an array and json_encode the array out of the loop.
http://webscalesql.org/faq.html Q: Is this a fork of Oracle's MySQL Community release? A: No. As long as the MySQL community releases continue, we are committed to remaining a branch – and not a fork – of MySQL that’s focused specifically on the challenges of deploying MySQL at our scale.
There isn't something to check HHVM compatibility specifically but since everyone writes unit tests now just run your unit tests and integration tests on HHVM to check your compatibility.
This 10x 
Thanks.
I am not telling we shouldn't..by having dedicated functions, we can save one argument (for indicating the input type)..get('username') instead of get_key($_GET, 'username')...
Yes it was! I think this project just shows the power to transform JavaScript into anything else. Like what HaXe already does incredibly well. There is no actual use case of this. It's just for fun and experimentation.
There's being explicit, and then there's being overly verbose.
There's nothing wrong with writing your own login system these days, provided you use the built-in functions and don't try to MacGyver it too much.
just a thought. But as you mention HP Notebooks http://www.macbreaker.com/2014/04/the-best-hackintosh-laptops-of-2013-2014.html At least it's the cheapest way to have 3 different OS on your system and watch your work on 3 different Systems and their browsers native.
&gt; If their are have 5 different ways of accomplishing this "frequent use case" how is that a good thing? As I see it, there is no nice, short way to do this. That is the whole argument.
It might actually make sense to go the other way around, but... I can't conceive of a use case for this.
Shitty tutorial is shitty, that thing is going to throw an error undefined variable when launching the page
\" shell_exec( 'rm C:/'); ' Or some shit.
Reinventing the wheel isn't *always* bad - Look at [React](http://facebook.github.io/react/) for example. People really questioned it when it came out, but now it gets a lot of love. The developers could have just stuck with existing solutions, but they were adventurous and went with what fit their needs best :) As for the IDE, I guess one of the drivers for the project was for it to be web-based and tight integration into Facebook's internal tools. Not sure how good PHPStorm's integration points are. I'm not entirely sure though. It was already built and working when I joined Facebook so I don't know about its history :P
Not to mention the unsanitized output of user input. 
Thanks for all the comments I will add photos and more details.
Extremely, especially if you're doing any sort of splits (vim, phpstorm, sublime text etc).
More photos?
There are photos?
The picture shows the results of each stage. With descriptions
trust me you don't need it
Thousand developers happily developing and there's bound to be one or two MacGyvers in the bunch. I think I'll take a look at Sentry and Aura.Auth next time I need to do something like this.
There are no photos
Whoah there. Progress shouldn't be at the expense of code written incredibly shitty 12 years ago!
why is it bad? these are test names, the only time you ever use them is when you first type them out and when you read them again because some test broke. &lt;?php class JobServerTest extends PHPUnit_Framework_TestCase { public function testRunJob_success() { $jobServer = new JobServer(); $job = new SuccessfulTestJob(); $jobResult = $jobServer-&gt;runJob($job); $this-&gt;assertEquals(JobResult::SUCCESS, $jobResult); $this-&gt;assertTrue($job-&gt;jobRan); } public function testRunJob_failsDuringRun() { $jobServer = new JobServer(); $jobResult = $jobServer-&gt;runJob(new FailingTestJob()); $this-&gt;assertTrue($job-&gt;jobRan); $this-&gt;assertEquals(JobResult::FAILED_DURING_RUN, $jobResult); } public function testRunJob_failsToSchedule() { $jobServer = new JobServer(); $job = new SuccessfulTestJob(); $jobResult = $jobServer-&gt;runJob($job); $this-&gt;assertEquals(JobResult::SUCCESS, $jobResult); $jobResult = $jobServer-&gt;runJob($job); $this-&gt;assertEquals(JobResult::FAILED_TO_SCHEDULE, $jobResult); } }
it would be for shared hosts etc, but even then you could just use Symfony's [reverse proxy](http://symfony.com/doc/current/book/http_cache.html#symfony2-reverse-proxy)
Man, I am now going to write a Swift transpiler that can simultaneously convert code to both PHP an Javascript.
There is no php server http://sittisak.typepad.com/blog/2014/09/how-to-install-a-php-server.html
I wonder what you get after looping a file back and forth between these a few million times, might try it out! 
As about PHP processing might take 1 day to improve.
**edit: tl;dr, below, is ramble free** &amp;nbsp; Ah, good point. Another suggestion then would be something in between, as others have suggested: $foo ?| 'something else'; $foo ?? 'something else'; //c# style, see: http://msdn.microsoft.com/en-us/library/ms173224.aspx //etc There might be another route to go here, and that would be to allow a `isset()`/`empty()` check in a simpler way - independent of ternaries. Perhaps introduce a type hint of, say, `(any)`. This would ensure that SOMETHING gets returned by a variable - either it's set data or null if its not set (but never throws an error). If your worried about characters that need to be typed, the above can be aliased by an operator such as: ?$foo || 'bar'; // or !$foo || 'bar'; This could then be used ANYWHERE an unset variable is acceptable without throwing an error. Like: if (?$foo == 'bar'){ /* do something */} // or // myFunct(?$foo); Ultimately, for those that DO want errors thrown for `$foo ?: 'bar'` this is a backwards-compatibility break. Also, there is no other area that I can think of that php magically checks to ensure a variable is set (magic methods aside), and hence the proposed might be counter-intuitive. Finally, I think your idea is great - don't restrict it to ternaries! &amp;nbsp; **tl;dr instead of limiting the auto-application of `isset()` to short hand ternaries, introduce a [Null Coalescing Operator](http://en.wikipedia.org/wiki/Null_coalescing_operator) which can be used everywhere.**
In what context is it a frequent operation? Directly accessing super globals is the only thing that comes to mind and you really shouldn't be doing that. Even if you were completely opposed to making your own class there's still filter_input().
It doesn't do the same thing it did before. With this proposal developers would need to learn that the two forms I used in my previous example are not semantically the same any more. I don't think having to learn new stuff is an especially valid argument either way since we should constantly be learning anyway, but if you're going to make it against introducing a new operator, it applies just as much here.
A new operator is unlikely to pass.
They do the same thing, the only different is ?: won't output an E_NOTICE if the variable doesn't exist.
Unfortunately, camelCase is one of the things PSR got unequivocally wrong (probably because PHP core got it wrong first).
Difference == not the same :) You can't argue on the one hand that a new operator requires people to learn something new, but new behaviour for an existing operator does not. A bad argument either way, but if you're going to make it it applies both ways.
If you are getting a download check to make sure the PHP module is loaded, if might be commented out in the apache config causing it to not parse at all obviously
Do you have a link to instructions on how to do this? I'm quite new to hosting a webserver
What is the url you typed in the browser?
Just http://&lt;myserversip&gt;/info.php
Not really, I'm accessing the file in the same way I'm accessing the index.html file: http://&lt;myserversip&gt;/info.php
Coming up, the new Javascript &gt; Assembly Transpiler! 
I am running LAMP On Ubuntu server. I should write that in the post though, thanks :P
Oh, I see. Some testing would need to be done to see how phpcs handles that. That being said, if your goals are in line with OP, I would strongly suggest you keep your *custom* code separate (i.e. keep the templates out of the code) for *your own sanity*.
I don't care HOW you got your code formatted, only that you did. If you don't CI will **fail** and I wont review - let alone merge - your code. But I will be on your tail for not meeting the deadline. *tl;dr: it dosent sound like you would enjoy working for me*
it's a convention thing. with large codebase (not a single developer.) people tend to "bend the rules" and push the limits of what they think apply to company convention. when adding the rule "on test code, you can use underscore on method names" you'll start to see: testRunJob_failsToSchedule successfullyTest_RunScheduledJob testShouldFail_whenJobIsScheduledLater test_ok_only_on_jobScheduled now here's the kicker! people also tend to copy-paste code especially tests that are somewhat related and modify them. so let's have a look on our modified test "testRunJob_failsToSchedule" after a normal copy-paste testRunJob_failsToSchedule_AndNullStrings then another developer comes and say OK! good! I should also check that IP is valid testRunJob_failsToScheduleOnNullStrings_IPValid now this test makes no sense to me. I'm not blaming underscore and camelCase combined as a cause of copy-paste code, but it's easier when one firm rule is applied. firstly on the eye, and secondly when some other developer will search testMethodNameInCamelCase he will find the test quickly without thinking "ok, where should I put this underscore now". 
Then your web server doesn't know what to do with a .php because of some misconfiguration. Try manually assigning it as a test and then find out how to change it permanently: http://stackoverflow.com/questions/12561203/how-to-change-php-version-in-htaccess-in-server
Thank you for the link and suggestions, but I don't see what the link has to do with the rest of you post... :P How would I manually assign what Apache should do with a php file?
Ah, sorry, the MS Webmatrix reference threw me. Firstly, I'd stay on your Ubuntu machine and get it working there, but as you mention in one of your other comments that it is serving html correctly over the network then it's pretty clear that PHP isn't running on your server properly. I'd reinstall it, specifically the module for your webserver software, probably libapache2-mod-php5
By setting a directive for files ending in .php via the .htaccess file.
Happy to help! Chuffed that I guessed the exact missing module from so little initial info... feel free to use the upvote button on anything that helped you.
Then your question isn't "what's your take" but is instead "how do I get the most out of it". Mysql has limited spatial abilities but they do exist. You can research them in a weekend in the mysql docs.
/endthread
http://asmjs.org/
Please do this and post the results.
Good for you.
Why not throw it up on github? I'd give ya a star.
If anything the first thing you should do is get rid of CI
Im not familiar with it , I suppose it's a collaborative platform? Edit: just checked github its definitely the way to go
Here it's a video, it's in Spanish but you can get the idea, it's about creating a hardware inventory application in 20 mins http://youtu.be/pMSHPFqccLs
fun stuff. have you ran into any rough spots with HaXe?
 $dto0-&gt;add(DateInterval::createFromDateString('1 hour')); This line returns a new immutable datetime instance (you can't modify the existing one as it is immutable!).
Immutable means not changeable. That's the point. Try taking the return value from add and re-assigning to it: $dto0 = $dto0-&gt;add(DateInterval::createFromDateString('1 hour'));
Great, didn't know that. Thnx for the recommendation, I'll check those out! 
thank you all
Thank you very much, and nice to meet you kind Sir/Ma'am ! Will definitely check your project!
When you realize that "?&gt;" is completely unnecesary.
(/me bows) I appreciate the "Sir." :-)
:-) you're welcome
Yeah, kinda secure. By default, Basic Auth sends password in plaintext but SSL adds an encryption layer on top of it so it's secure.
With the include() thing, do you mean creating a php file that contains this, and then adding it to the top of every php file? &lt;html&gt; &lt;head&gt; //html head stuff here &lt;/head&gt; &lt;body&gt; EDIT: Thanks, that worked perfectly!
Quite possibly the most useless project on the internet.
Quite possibly the most useless comment on the internet.
When I pitched in the concept to ExtJs at the time, they said because it's a platform for creating applications then I would beed to pay an OEM which is a 75k renewable each 3 years and that I could pay 25k per year, but no monthly or per user/application fee. It really made me mad since we where a year in development. The cheery over the cake was when they released version 4 and it was, according to my devs, waaaay to different and that my friend was the first step on our cease and desist decision. 
When I pitched in the concept to ExtJs at the time, they said because it's a platform for creating applications then I would beed to pay an OEM which is a 75k renewable each 3 years and that I could pay 25k per year, but no monthly or per user/application fee. It really made me mad since we where a year in development. The cheery over the cake was when they released version 4 and it was, according to my devs, waaaay to different and that my friend was the first step on our cease and desist decision. 
Why?
There's that, and just for curiosity's sake.
I know, but...why? I can't think of a situation where I've ever used eval
For curiosity's sake I can understand
I have put an image in a blog and create an online program to see results.
That question seems backwards. What is the use-case where you would want to do templating on the client instead of the server?
Thank you. Actually I was going to split repository, but just can't find any profit from this.
How can you not know about GitHub? I don't even host any projects on it but it's *still* a hugely important part of my daily developer life.
&gt; I even thought about creating it again from scratch with html5, responsive and such, I already have the know how (believe me, it took us some time to figure it out) and the coding should not be that complicated Rewriting is rarely the right choice. Know-how is not the issue. It's a huge time investment, and if another version is already in production then you have to maintain two versions. Moreover, there's not much sense open sourcing an empty repository. If you do want to open source this thing, whatever it is, you need to be prepared to sell it. No one wants to buy into a project they don't believe in.
Oh...... I thought I walked into /r/programminghumor.
So, it's a more elaborate version of include("data:,&lt;?$code") ? The VFS layer looks nicely done, btw. 
.Net dev here. It's great, and the issues I do have worth it are all being addressed with the vNext reboot.
Generating complete HTML without involving JS. Albeit these days this is somewhat considered a bad practice since the likes of Angular, Backbone, CanJS and Ember have been released. Still, it's still a valid workflow and reveals much less of your internals. Also makes it a lot harder for other people to scrape your site (still really easy though).
That sounds interesting. What about search engine spiders, is such page indexable?
&gt; The new version of ~~Wordpress~~ JetPack. 
I don't know what you get for laptops these days, especially when spending $600-1000, but the HP pavilion g7-1070us that I bought over 3 years ago (under $500) is still a kick-ass coding device, and I attribute that to the following facts: - 8GB RAM (upgraded from 4GB) - quad core (nothing crazy: the i3-370M @ 2.4g) - upgraded to SSD - running Linux - 17" widescreen offers decent amount of space to fit code-editor &amp; a browser window side-by-side So if I had to hit the market today, those are the specs I'd be aiming for.
Sorry but you are not proficient enough to be publishing any kind of tutorial. Read about XSS, it's absolutely vital if you plan to put anything online and your script is vulnerable. http://www.sitepoint.com/php-security-cross-site-scripting-attacks-xss/ Again, you have a lot to learn before doing tutorials or putting any code online, because you're opening up yourself and others to hacks. Edit: I'd also like to say in OP's previous post not one person communicated to him what the issues were (they were mentioned, but not actually directed towards the author with any advice). It was just "lol what the fuck is this" and he's left to go on making these horrible mistakes. Tons of people make these mistakes at the beginner stage, we should actively try to stop people making them.
As a new developer tasked with developing for magento you people fill me with dread. 
The moment I saw this I was scared shitless for the code base..
How is $foo = $bar ?? 3; more ugly than $foo = $bar ?: 3; They are practically identical.
Symfony and Laravel are both great. I use both daily. I'd personally recommend Laravel out of the two, it feels a bit "cleaner" sometimes, and is a less steep learning curve coming from CI.
"Cease" and "desist" are just words. He is free to use them in that context.
&gt; !$foo || 'bar'; That's the negation operator, can't use that. &gt; This could then be used ANYWHERE an unset variable is acceptable without throwing an error. We have that, it's @ (error suppression operator). There are various reasons why using it is a bad idea. The more I think about this, the more I think it's a bad idea to have an operator that magically hides errors/warnings. We have the language constructs isset/empty as exceptions, so the only solution would be a new language construct like ifsetor($foo, 'default')
No, no one should do that.
That wasn't sarcasm. You need to learn to write it better.
What exactly is shit about it? It might help to know? Why won't it work for you? Quite honestly you're incorrect, and it suggests to me that you're not concerned with the abstraction and interfaces envolved; I am. There is a lot of information in that code. It's not for everyone, and I don't even use it "as is", but it succinctly models a MVC application in way that is ALOT easier to read and understand than other frameworks. I've been around for a while and I'm tired of pulling your preferred frameworks apart; especially years later when it is time for an upgrade. I'm presenting everything in the configuration and that is invaluable. PHP 5.4 and traits have been around for a while now and I'm suprised how little of an impact they've had on the existing preferred frameworks - and it doesn't help when prominent members of the PHP community still moan about them or still prefer to use abstract classes! Thanks.
&gt; Mobile clients can consume JSON much faster than the complete HTML as well. Consume in what sense? No browser can take some JSON, convert it to HTML/DOM and render it via JavaScript faster than it can render HTML direct.
And that's exactly what this is doing, what exactly is the issue here?
I'm not sure what the relevance of that link is, it is a joke. Its sentiments also apply to myself - I've been here since the days of PHP 3.
You need eval when code is considered message. For instance, if you need to save and run code programmatically. PHP is generally considered to be a scripting language and therefore code doesn't need to be compiled into a binary before execution. It is compiled *during* execution. That means that php can run any new code at any time without constraint. This is as flexible as it is dangerous. While eval makes code itself a message, it also introduces the vulnerability of messages being tainted with exploits. You don't see this approach much in PHP because, aside from the vulnerability, the HTTP platform and RESTful frameworks aren't very conducive with the need for real-time scripting. There are several (non-PHP) SaaS frameworks that implement similar functionality to offload processing onto the client. The problem is that PHP is generally consumed via a browser and PHP obviously is not available on the client machines to be run. There are others, but I have an implementation of [this concept](http://github.com/jgswift/delegatr) (using eval) in PHP based on [jeremeamia/FunctionParser](http://github.com/jeremeamia/FunctionParser) that allows you to serialize and unserialize closures at run-time. 
That's what I was hoping to make clear to ultio.
Adrien Gibrat has done some benchmarking; Aura appears to do well in comparison. http://adriengibrat.github.io/benchmarking-dependency-injection-containers/
Absolutely love it. Great work! I'm already considering adding this as failover for eval disabled environments. 
That is completely untrue. If you are receiving HTML there is no good alternative but to set the HTML to the DOM via innerHTML for example. This is a method which is slow and very unperformant. On the other hand, if you get your data in JSON you can selectively update the parts of the DOM that have changed, which is significantly more performant (like way more!).
Sometimes, the best method depends on the browser, but fragments and DOM manipulation are usually faster. http://jsperf.com/innerhtml-vs-removechild/96 http://jsperf.com/bulk-inserts-innerhtml-vs-appendchild/6
Most of the time we are updating an app in response to new server-side information, the resulting DOM will have a lot of similar structure, and in such cases modifying the DOM is enormously more performant. (See React for example)
Tell people never to `eval()` user input, and now they freak out about `eval()` itself… Many frameworks and (actually useful) libraries that you might be using rely on it. Try for example: - Ocramius/ProxyManager (used by Symfony, Zend Framework, …) - Symfony itself for the [templating](https://github.com/symfony/symfony/blob/397687f345f4ea83f344a54275f4bc328ac2d4b4/src/Symfony/Component/Templating/PhpEngine.php#L173) - Twig - Doctrine That's enough?
http://www.phptherightway.com/ If you don't have at least some understanding of the basics, learning a framework to start off it a bit of overkill and may or may not actually help you much. I think it's hard to appreciate what a good framework does for you if you don't have a fair understanding of how things are often done without one.
Learn PHP. You might be able to make a site if all you do is focus on a particular framework, but by focusing on learning to use the language itself you'll be able to switch from one framework to another. You'll also be able to better understand how the frameworks work and to bend them to your will.
Hah yeah, when I first read the comments it was everyone :p
Oh.. *no..* this isn't what we want. &gt; *Script code php calendar helps you to add calendar in your site. You server must support PHP.* &gt; *Script code php calendar helps you to add calendar and you can add events into calendar also. Hope you know about PHP calendar .* We can't stop here, this is bat country.
&gt;We can't stop here, this is bat country. 
Blog spaaaaaam. Downvotes!
I hope it will be good for me. While re-inventing the wheel is fun, I'd rather use wheels built by smarter and more experienced men than I am (and save some time while doing so) :P
Can you post your wrapper function? Since unless you found some magic to not pass the array by reference - it's a kludgy solution. 
There was a 6. It just never saw the light of day.
That's a contradiction. Either there was a PHP 6, or it never saw the light of day. If I've never had a house, and decide to start building a house, but decide I'm going to stop building and build something else before I'm done, then will I at any point have had a house? No I won't. Maybe I should leave that discussion to the PHP internals people, they're much better at this sort of thing than I am.
I would recommend against jumping into CI. Some of the practices it employs aren't very modern.
I can't upvote this enough. If you really want to learn PHP, learn PHP and not a framework. As soon as you have a basic understanding of the language, you'll find out that it doesn't really matter what framework you are coding in. At the moment, I'm working on two pretty big projects, both on different frameworks. Every single framework has advantages and disadvantages over another framework. Some frameworks suit you better, you start liking them more. Picking a framework is 50% based on the project and 50% based on your personal preference. I still code on WordPress projects these days. Now WordPress is not a framework according to most people (let's not go there right now :)) but it offers a set of classes and functions in a similar way an actual framework would. Having a broad knowledge of core PHP makes it a lot easier to jump on different projects, with different frameworks or tools. As I said before, upvote ∞ on this. Go learn PHP and then dive into a framework if you need to.
&gt; According to the link the last default gets executed. My point was that nobody has ever defined that to be the case. It's probably not what you meant, but it looks like you think that this has always been true and will always be true, because it's true right now, when in actual fact, you have nothing whatsoever to base that on. Some people will try something that's not in the manual, and assume that it will always work that way. Then when it gets changed because it doesn't make sense, their code breaks and they won't understand why, even though nobody has ever guaranteed them their code will continue to work.
No it isn't, and you're missing the argument. He's saying that it's faster to load a page directly for the initial request than it is to load an empty one, wait for resources to load in, make a JSON request and populate the page with compiled templates.
So much this. I think you'll actually learn more, better, and faster working with a good framework than you will without. 
&gt; people tend to "bend the rules" and push the limits of what they think apply to company convention It doesn't matter! Code convention is not just about aesthetics, it's about not having to think when you type a variable/method/class name. In this case, you never have to type it again. Also, even if it did matter, you should have code reviews to pick these things up. &gt;people also tend to copy-paste code They should be fired ;) &gt;testRunJob_failsToSchedule_AndNullStrings This is just wrong, regardless of naming. Unit tests test single things, not multiple.
I agree with your earlier paragraph, but the latter part implies that framework choice is kind of irrelevant, that they're all roughly equal. I couldn't disagree more on that. Picking up something like Code Igniter, for example, would be an objectively poor choice compared to Laravel or Symfony. And a noob developer would probably be better served by Laravel's extensive training resources (such as Laracasts) than by Symfony. "Personal preference" shouldn't be overstated as a factor. If your "personal preference" dictates lesser option over objectively better ones as determined by rational examination of the options, then you're probably an idiot.
I agree, maybe my response was a bit poorly worded. Of course the framework choice is extremely important, but not when you are still learning. Considering the developer in this scenario has very little experience with PHP at all, the framework choice is less relevant (although I would also recommend Laravel, simply because sites like Laracasts exist). The developer will realise this as soon as they grok the core of PHP. It wasn't my intention to overstate the "personal preference" factor, but I do think that it's an important factor. Of course it shouldn't be able to overrule any technical factors.
Some of this probably comes from Rails and Django being treated like separate languages almost.
Alternatively, read the [5.6 migration guide](http://php.net/migration56) from the manual, which has much better English and includes examples.
Laravel is a framework based on Symfony2. I haven't used it, but it has been described to me as what Ubuntu is to Debian. As far as TDD, just learn to use PHPUnit ( https://phpunit.de/ ) and when you are confident at writing tests, start writing them before you code.
Please, add here the list of sites failovered.
That is a really great point. I interpreted the OP incorrectly. Thanks for pointing it out.
Loving the flashing minion :)
But that's what ultio was saying too. Sounds like you all agree.
You're correct, but phptherightway doesn't teach the basics.
You like reinventing the wheel over and over again, or use a wheel that has been tested, hardened and maintained by thousands of open source contributors and experts in the respective fields?
Why?
Well, I think you're overstating your use of the word "read" in terms of my statement. I **did not say** that a person new to PHP should start with frameworks. In fact what I said, if you read with your eyes and not your mouth, is this: &gt; Regardless, frameworks are generally pretty advanced PHP, and may be hard to get into without a good grounding in PHP generally, and OOP specifically. Do you think a newbie developer just starting out has a "good grounding in OOP"? &gt; They should first learn php and then realize that frameworks are usually and more often than not a waste of time. Ahhhh. Enough said.
Take it easy! If you don't like it, don't use it. Have some manors. 
That library is exactly what I was looking for! Thanks!
Apparently, yes. 
I'd recommend learning the basis of PHP first (non OOP) by writing yourself a test website / app. Once you are happy with PHP Syntax and quirks go back and start rewriting your project using Object Orientated methods. Once you are happy and proficient with classes (learn difference between public, protected and private visibility differences!) start looking at popular frameworks such as Symfony 2. [Code katas](http://codekata.com) are a useful tool whereby you write some code to do a specific task such as producing Fibonnaci numbers. get it working. Delete the code, rewrite the code. Like a musician practicing scales you will learn what you are writing and improve your methods. If you can learn two things at once throw in PHPUnit tests with your Code Katas. 
I would agree with the others that it's best to learn the basics of PHP first. Understand PHP and its various constructs, particularly if you're a new programmer. There's no doubt that you should learn to work with frameworks however, and being able to distinguish the traits and features of PHP from those of a framework will be beneficial and give you a head start when you want to dive into a new framework.
No, it makes complete sense. Using innerHTML with with code trigger's the C compiled code in the browser to parse it and build up the DOM. Using something like AngularJS, a lot of non-native JavaScript script code needs to be run to insert each element. I'm not saying using JSON has a bad idea - it has its benefits - but it's certainly a bit slower.
Please stop linking to phptherightway as if it's all someone needs to learn PHP. It's a completely un-structured set of best practices in advanced topics without any sort of meaningful organization or putting them into any context. What the PHP community really, VERY desperately needs is a very thorough, structured syllabus that ties core software and web development concepts together in an organized way, and points each topic and sub topic to many different resources, *of which* phptherightway.com can be one. But phptherightway.com is closer to a pocket reference guide for best practices, not a way to learn PHP from the ground up.
But if you don't know core PHP, then you cannot differentiate between the magic of a framework, and actual PHP.
Nope this is the reason projects like react exist, because the dom is slow. Do some research.
I've release v1.1 which now uses GMP first, if available. But it's not much faster than BCMath: https://github.com/stephen-hill/base58php#benchmarking If anyone can make it faster, I'm happy to receive pull requests.
Released v1.1.0. Now uses GMP math functions if available. https://github.com/stephen-hill/base58php/tree/v1.1.0 https://packagist.org/packages/stephenhill/base58
While not PHP, when I first learned Python I jumped straight into a framework and just kept hacking away until I did things that worked, then I refactored. If you have an understanding of programming (i.e.: done Python, Ruby, C/C++, etc...) then I'd not be opposed to suggesting just diving into a framework. A lot of the different syntax translates between one OOP from another. Now, if you're new to programming in general and not just PHP, I would say write some basic stuff first. A simple calculator could be beneficial, then expand from there. However, if you learn best by just diving right into something, I would use a simple, but current, framework. I personally like working with [MinPHP](https://github.com/phillipsdata/minphp). The syntax is pretty simple and easy to work with, and it follows a pretty smooth MVC pattern.
I didn't mention AngularJS because of the framework itself; I only did because of its style. Were the JavaScript native, it would still be slower. So a different framework will not help. Think about it: which do you think is faster? Letting the browser render a complete HTML page by itself, or passing it a huge JSON tree of intended HTML and recursively iterating on it, calling createElement() for each element? I'm sure plain HTML wins here. I did not provide benchmarks, sorry; you don't have to take my claims seriously.
You're interested in crowd development? Check out [Assembly](http://assembly.com). Assembly is the platform you're probably looking for! Example project built by people through Assembly: https://assembly.com/helpful
I wouldn't say it's evil because of performance. There are a butt tonne of lesser performant tools in PHP that *aren't* typically classed as "evil": * Reflection * uniqid * xdebug/xhprof There are also plenty of entirely performant things that *could* be considered "evil": * Closure:bind * declare/tick * goto I think the point is; evil or not, these tools are useful, otherwise they would have never made it into PHP in the first place (despite what we all think about PHP's ungodly number of inconsistencies). Be sensible, use them where they're needed, and don't eat cheese before bed.
I disagree. Everything is a framework for something else until you get down to the zeros and ones. "php" is one of the levels - frameworks built off of it are another. ...kinda.
&gt; uniqid Well, this is the first time I've seen someone point at this function as slow. Any resources on why/suggested solutions? 
Entropy pool starvation makes sense, I was worried it was some underlying old code that was just slow.
This is my first major open-source project, so I'd greatly appreciate any feedback!
It's based on the reference work done with the NodeJS/JavaScript implement - so it seems fair to be it's own project. Pretty good going IMHO - got this together rather quickly. Would be curious to see some benchmarks vs. other parsers. 
Fair enough but we got so many parsers already, including very good ones like Parsedown, I'd rather see it become compliant than add another one to the already-confusing list.
Great question! There are a few reasons why I chose to create a separate project: * As magnetik79 mentioned, it's based directly on the JS implementation. This allows me to easily and quickly port any changes. * This is also a learning experience for me (for both syntax parsing and package creation/maintenance). * Other libraries support non-"standard" Markdown of various flavors. I wanted something that only supports this new flavor, and does so perfectly.
My gut says this might be somewhat slower right now, but on the other hand it probably supports CommonMark better. I'd love to create some benchmarks sometime and add whatever optimizations I can. **EDIT:** I did a quick benchmark - looks like it's about 35-45% slower than PHP Markdown Extras. I know of a few areas that could be optimized, and I'm sure profiling will reveal some others. The slower speed should be unnoticeable if you're only processing a few documents at a time.
Don't know if that was a serious post, but w3schools is awful, even at the basics.
An object based chainable pseudo type system that implements all the mb_* functions would be awesome.
Seriously? * http://lmgtfy.com/?q=php%20closure%3A%3Abind * http://lmgtfy.com/?q=php%20declare I also said that both Closure::bind and declare/tick are performant but can be considered evil
Dependency Injection isn't used because it's the only way to handle giving a class to a piece of code, it's used because it's the correct way to do it. What you're doing requires the dev to manually maintain all of the dependencies. You couldn't even write a blog in this "framework" without creating lots of unnecessary complexity, and that has to do primarily with the fact that it doesn't use DIC.
Why announce a guest blog series before the first one is posted? There's no content there.
The confusion is understandable. If you're new to this area then I can see how you view programming in raw php and utilizing a framework as different paths. The answer is that you should do both raw php programming as well as get familiar with frameworks. This might sound like a copout, but it's really not. The strength of a language is in what it can do whereas the value is in what you can do with it. What you absolutely need to know is how php works and operates which is why you need to do raw/native php programming. Over time, you'll find that you're doing many of the same things over and over again so you want to carry around these items as you go from task to task; this is the beginnings of a framework. When the repetitive items are formally collected together in a coherent manner, that's the framework. Many times, it's much easier and advised to leverage the work of others so you don't try to reinvent the wheel and screw it up. When you want to leverage another's work, you do your research and you choose a popular and commonly-used framework and you work with that framework from then on. The issue with separating out the frameworks is you're still programming in php since the frameworks are written in php (exceptions include yaf and phalcon which are written in c/c++ as php extensions). You'll be working within the frameworks and learning how they work and eventually relying on the magic they do behind the scenes for you, but you're still doing all of this using php. If you don't know how php works, then you're shooting blind and the framework you chose won't help that much in the end. They are tools to leverage and not to rely on. If you're just now learning php, then the commonly recommended "php the right way" site wouldn't help you much. The focus of that site is to help guide those who know how to do stuff, but aren't sure what the recommended way is. In time that will prove to be a great resource, but in the early days of learning it's generally too in depth. I'd also like to point out a similar area of contention I've noticed that parallels your situation and that's with javascript and jquery. Years ago when everything javascript and jscript were a pain to deal with, we wrote little wrappers to help. Over time we wrote more and more and developed our own little frameworks to help deal with doing stuff over and over again. Some groups released theirs, like prototype and scriptaculous, then jquery was released and many people jumped on board effectively making it the de facto standard framework. Over time, the browser vendors came to more parity by using ecmascript standards as their foundations instead of their internal ideas. During this time, everybody kept using jquery as their framework instead of learning javascript/jscript/ecmascript (they're usually collectively referred to as javascript nowadays) so what they learned wasn't the language, but the framework. Asking for somebody to iterate over a collection or array without using jquery's `each()` is surprisingly revealing. This specific trend is slowly fading away with more and more people using other frameworks like angular and backbone. You absolutely need to understand the core language and native functionality regardless of which framework you eventually use. Also understand that the framework fits a need that you can leverage and doesn't replace the language. If you don't know where the framework ends and the language begins, then you'll have problems down the road. Frameworks change and can be abandoned. You might also switch projects that uses a different framework entirely that you'll have to learn. Just don't shoot yourself in the foot by choosing a single path.
In which case, you also need to include: src/GMPService.php src/ServiceInterface.php
They decided it was a whole-week event. 
You could also write your own PSR-4 autoloader: https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader-examples.md
Yeah, but this a dinosaur, very big, and the links are generated with JavaScript, and there are may be more than 500 files, and the UI has very deep places and some places do not exist in every set-up, etc etc.
Lol $100 for a minimum of 40 hours of work using god knows what for legacy code....
So it was only one week or it'll happen once a month for a week or what?
Then, I'd refactor from scratch.. without caring about unused files.. and to be honest, I know why I still design so my frontends are perfectly usable without any JS. Much less debug nightmare..
If you have little experience in PHP , task is for 6-8 Hrs
$100 won't buy more than 1-2 hours at most of a qualified PHP developer's time. And it certainly looks like you have more than that needing to be done. And I'd say way more than your 6-8 hour guess.
Down forget cebe/markdown, which is my current favorite. Hopefully he can get the parser to conform to commonmark soon :)
And what if it is completed within 10 Hrs?
I loved it ;-) LOL (I did not know those - now that I took time to read, still I find no use for it) Thanks ;-)
It's every day, every week (that's the joke)
Ohhhhhhhhhhhhhhhhhhhh
It's just [CommonMark](http://commonmark.org/) [now](http://blog.codinghorror.com/standard-markdown-is-now-common-markdown/)? &gt; Edit: after a long and thoughtful email from John Gruber – which is greatly appreciated – he indicated that no form of the word "Markdown" is acceptable to him in this case. We are now using the name CommonMark. And he took down CommonMarkdown.com too. Unbelievable. Lost all respect for John Gruber. Great work on getting this up so quickly OP!
Sorry! I've been very busy with work and haven't been able to find the time to post it. I mentioned in the post that if someone posts it I will sticky it for the day. 
I am talking about updating the DOM not the initial render. So updating in response to serverside data.
I bill freelance, custom, off-the-street type work at $75 per hour. And I'm not at all the highest-priced developer out there. You simply will not find what you want without going to some overseas developers....India, Pakistan, Bangladesh, etc. That's about the only place you'll find people willing to work for what you're willing to pay. But be advised, as the old adage goes, "you get what you pay for."
[Done and done](http://www.reddit.com/r/PHP/comments/2fu84k/php_moronic_monday_20140908/)
We use ExtJS 4.1 in the front end. It is pure JavaScrit. We (all the 4 programmers) are refactoring the front-end. However the back-end is risky place, it deals with money, rates, taxes etc, so it is critical application. I want to refactor but no one wants bugs, it works. The app is for technical services who work as franchising/dealership. Probably, first, I'll learn ExtJS 5 and its finest new features, Laravel and best practices, Git. Then I'll start refactoring it in from scratch. Until then I'll start with this approach https://www.reddit.com/r/PHP/comments/2fgi1w/how_can_i_find_unused_php_files/ck9aw10 within few weeks.
I went ahead and implemented Veval in my [delegate package](http://github.com/jgswift/delegatr) to offer said failover. Obviously it is beholden to developers to use this tool responsibly.
while i (like everyone else in the world) have done this and it is a great way to get to grips with the language, I think it taught me bad practices. i should have been learning Symfony-esque development from the start. 
a million times this. there are two types of learners it helps - experienced developers coming from another language, or experienced PHP developers who use outdated tools and methods.
Should this be part of the same repo, or a separate one? I'd have to `require-dev` the other parsers used in the benchmark, and I'm unsure whether that makes sense for the main project. What are your thoughts?
No love for Microsoft FrontPage or Dreamweaver... But seriously, +1 for Eclipse. Everyone else at my work uses Netbeans...
I know I did. A lot of times. 
TL;DR: What do you recommend to shape up old messy projects? Sorry for the grammar ;) Long version: We have a big bulky project written in CI, I started it as a sane little thing 5y ago, then I had to pass it over to other dev, it was ok and he managed, but in a not great way mostly due urgencies and being a solo dev for this big project. Now, I'm getting the project back, I have a couplex of extra devs for it, and I'd really like to get it in shape ASAP while still building/maintaining it (its ever growing). The users are a 50-person close group, but required to be (almost) 100% uptime as its used to run a 100% online business. So... what would you suggest? Problems: - Messy code, but not spaguetti, just disorganized, tons of functions on a few models and a few controllers, no actual folder organization. This includes PHP and JS. - CSS is in very bad shape for now, we're working on a redesign, but as a different branch, not hoping to merge that soon. - No docs, almost no comments. Some parts are scary due complex conditionals (5 levels of conditionals and alike) - Lots of repetition - Not automation of any kind What I'm doing/thinking to do: - Enforced PSR code styleguide for all devs, using editorconf too. - Enforced git branchs for each new task, then PR, then I (or someone else) reviews and then merge to stage. Master (production ready) is only touched by one person, and only on deployments. - Enforced a new folder structure: allowing more files (models, views, controllers) separting concerns with folders. - Moved a lot of repeated functions/methods to helpers and base controller or base model (extending CI). - One hard rule: when you create new code for a feature/task you should follow all the new rules, when you fix/touch old code, you MUST renew it as much as possible, at least that function on that file, to be PSR compliant, fixing the logics and adding TODOs/notes when weird stuff appears. - For the future: - Automated docs creation (enforcing docblocks wherever needed/possible) - Automated deploying - Automated testing on some parts, I'm not good on TDD, so I won't fully enforce TDD, also on a big project like this seems to be really difficult. What other recommendations/ideas would you have in a situation like this? Just be sure that I'm not mad or angry or anything personal with the other dev, I understand how the company we work for moves, quickly and a bit chaotic, and sometimes you need to acquire tech debt on these projects, but its time to do the right thing, for the sake of the project and the team.
Agreed... What's Gruber up to? Why is he so defensive about the name?
The question of importance, is it faster than [Parsedown](http://parsedown.org/demo)?
More the latter than the former. Its all about encapsulation. Private is enforcing the callee to be the exact class its in, and protected is enforcing proper method use with inheritance
Ah. In my ten years of experience, I have never worked at a place without a problem like this in one shape or another... I tried to modularize the controller logics as much as i can. Take it out of CI framework, build components out of them, and register them as name spaces using something like symphony universal class loader. You can probably register them in the hooks. I do it right in index.php. This way you decouple core logics from the framework and each other. Similar to what Laravel does. You can slowly adapt your controllers and models to use those objects one by one. There's no quick way to do this. Only an organized way. 
I believe you can get AutoModerator to make weekly posts.
Another moronic question! Woooo, at least I'm good at something ;) I have some methods I'd like to keep private in a function, but I want to test them using PHPUnit, which requires them being public. How do you guys handle this?
This is actually a very insightful question. Python, for example, makes everything public because "we're all consenting adults". But yeah, I think the take away is clear encapsulation. It makes using and extending the class more explicit and clear.
This is how I think about it: Public methods establish how to interact with your class. They should be unit tested, and should changed only after much consideration. The private/protected methods are internal, helper methods. Use them to keep your code "DRYed" up, and keep your public methods a manageable size. With this mindset, it is a combination of both reasons you mentioned. If your class needs to do something that isn't part of it's API, then that method doesn't need to be public.
Seems like you have a really good handle on moving forward pragmatically while trying to enforce best practices. If anything I'd plug automated testing a little more (does not have to be TDD even). It's a great way to test the internal workings of an object, as well as contracts between objects. Unit testing also requires a very simple and logical flow of code, often forcing you to rewrite functions to be smaller and more simple, which is a win-win. Maybe start by generating coverage reports, tracking coverage over time, and rewarding people who add coverage. That way you can keep it positive and goal-oriented vs punitive.
 $refClass = new ReflectionClass($class); $method = $refClass-&gt;getMethod('methodName'); $method-&gt;setAccessible(true); $method-&gt;invokeArgs($args);
Yeah, I know this happens on all levels, its part of the complexity of these solutions, but I guess its healthy to stop from time to time to paid some of the debt. I will take a look on how to move out of CI, it would be interesting if at some point we can move to something more "modern" (if needed, and when the time comes) without the pain of rewriting controllers and stuff. Thanks!
Wow, thanks! I definitely need to read up more on the ReflectionClass, I skimmed the chapter on it. Appreciate it, this is exactly what I was looking for.
Why does laravel use func_get_args and call_user_func so frequently? If I'm passing a callpack as a parameter so why not call it directly? Is Wordpress safe to use by itself? If not, what blogging platform would be good? I'd need templating, tagging, static pages and code highlighting. When I use Laravel's schema creator, PHPStorm doesn't see the 'references' method when I try to create a foreign key: $table-&gt;foreign('some_field')-&gt;references('another')-&gt;on('table');
You said 'kid'... I had no idea he is 19 years old. Incredible.
Indeed. He is a reasonable, well-educated and passionate young man. I dare say even the main force behind PHP's improvements over the last few years. We owe him a lot of thanks. 
&gt; How do you guys handle this? Don't test private methods. Test the public API -- that's what the clients of the class will be using, that's what your tests should be using. 
It's an impressive effort Colin - well done. I think those looking for pure "speed" - attention is probably better spent on a PECL module implement, there is a C reference as well out there which could probably be ported. Still, speed isn't everything - and if it is, cache the rendering result.
But there's a lot of complicated logic in there that is going to be refined over time. Having tests for this data is necessary.
Yes, PHP does indeed tell you about any syntax errors already. And it also provides runtime errors, warnings and notices - which are mostly about e.g. incorrect function usage. Static code analysis does not actually run the code. So it couldn't provide the exact same checks as PHP itself - though there is some overlap. It's primarily just a more fancy way to search through code in a tree-structure. * It allows for example to watch for a variable getting assigned some value, follow it through the code flow and see if it's actually used anywhere. (Which PHP does not care about for instance.) * Slightly more complex logic might even be able to follow that variable through expressions / function calls, and check if it was escaped or vaguely filtered before ending up in one of the common SQL query functions. * It's also useful for some stylistic checks, or generating a data or program flow graph. Generally a parser just splits up code like `$var = func(2 * $var)` into an array/tree like `EXPR_ASSIGN( "$var", EXPR_FUNC("func", ARGS( EXPR_MULTIPLY( 2, VAR("$var") ) ) )`.
Think of your public methods and variables as your public facing user interface. These are the ones that are hardest to change and easiest to get wrong. Your mistakes with your public interface can haunt you for a long time, so be very conservative about what you expose. Always test your user interface by trying to use it. Test cases are great for this. Nothing can stop a determined developer from calling or changing your private/protected variables or methods, so don't think of them as inviolable, just think of them as a strong recommendation coupled with a few hurdles: &lt;?php class Foo { private function hello() { echo "hello\n"; } } $f = new Foo; $rc = new ReflectionClass($f); $m = $rc-&gt;getMethod('hello'); $m-&gt;setAccessible(true); $m-&gt;invoke($f); 
There's always the functional approach, but if you don't like that one either, then please [keep this in mind](https://lh3.googleusercontent.com/-TtK9SfXmGJQ/U0UmS3hp2mI/AAAAAAAAAWg/1Rl-9lB14f4/w506-h291/violent-psychopath.jpg).
Probably not, but I guarantee it supports the full CommonMark spec better than Parsedown does :)
That sounds awesome, any good read/libs to achieve that? Mostly we do lots of reporting, we could add some test to check numbers and write/read processes, but some inspiration could be useful. Thanks!
Funny thing is, I almost cannot write PHP anymore unless it's in an object context. Without OOP, it's like "Oh, you want access to that variable in another function? FUCK YOU". Or, you have to pass a variable through 8 functions before a function that actually uses it, can get access to it. Maybe I haven't done procedural programming for so long that I've forgotten how to do it, but I find OOP significantly easier these days.
Should my getters/setter be public, protected, or private? Logic tells me that getters should be public, but setters should be protected, for extensibility. Furthermore, do I even need setters if my class is going to be the only thing setting its variables?! Should I ever be setting object variables outside the class?! I thought this was bad practice...but I just don't know. These are the questions I can't ask during sprints =(
As /u/ocramius hinted, scripts *generally* need to do two things: * Whatever you wrote them to do * Allow others to quickly understand what they're doing so they can be modified/extended/integrated into other projects As the scope of an application's featureset grows, coding becomes less a matter of writing code and more a matter of managing complexity within the codebase - the object-oriented approach can help to mitigate that complexity, allowing you to focus on whichever problem you're trying to solve at the moment. Even if you're the only person who needs to maintain what you've written, I think you'll find that the *truly* lazy way to approach the problem of managing complexity is going to involve OOP.
Wordpress is fine to use for blogging, and is built around it's templating system, and you can get a plugin to handle code highlighting in blog posts. 
Exactly. People are confused by what a lazy programmer is.
Is `ast\parse_code` faster than `token_get_all`? I know the structure is different, but they can be used for similar things, and performance can be a concern when processing a lot of files.
Whoa whoa whoa, what's that `new` and `\` thing? w3schools never taught me about those!
Wordpress should never be used in any serious system...
How can I get started on Test Driven Development in PHP? Do you recommend any books for this?
About the wordpress bit, yes you can use it by itself? It's wordpress. Tons of people use it without any other software stack. By code highlighting, do you mean highlighting in the post editor? Fairly certain there are plugins for that or you could roll your own. 
Being in CI I know exactly how this looks on the backend.. and yes we should all be scared.
I mean if I put something like: [java]public class SomeClass { public SomeClass() { } }[/java] It'll make 'public' and 'class' blue and give method names a different colour like in IDEs. I found [this](https://github.com/kukulich/fshl/) library to do syntax highlighting which looks pretty straight forward to use.
That doesn't sound lazy at all. It's admirable that you're willing to work double or triple the time necessary to complete even the simplest of tasks.
You would probably want to use some sort of JavaScript library for the rendering so that way you could include it in the post editor while you're typing up the blog post/page. Something like this https://wordpress.org/plugins/wp-syntax/ though that plugin hasn't been updated in a year or so. 
&gt;1. WordPress &gt;2. Joomla &gt;3. Drupal Really??? ... &gt; .8. PHP-Nuke That was the real kicker, how is that even alive?
Just report this guy as spam and move on.
Had asked him something sometime back [here](http://www.reddit.com/r/PHP/comments/2ejm7c/rfc_abstract_syntax_tree_ast_accepted_for_php_7/ck05cvt). Made me wonder if he knows what he is talking about. I am sure I am missing something. But it appears that he is avoiding answering the issue. May be he got busy or something..I don't know.
Most of the time, things that are private can be extracted to a new class/method which can be public. It is generally a good way to clean up complicated code, reduce complexity within a class and respect the single responsibility principle. It'll also open up the possibility to reuse that bit of code somewhere else as well.
just a way to differentiate the external interface of your objects. That's all. I don't know how much the restrictions based on this (while extending and all) actually helps.
Markdown is WAY bigger that just daring fireball now. I don't think he has any more claim to it than anyone else, other than he wrote the first "spec".
While bloated, [Crayon Syntax Highlighter](https://wordpress.org/plugins/crayon-syntax-highlighter/) is a commonly used choice. 
Honestly, don't try to write unit tests for existing code unless it's feasible to Refactor it to the point where you can write unit tests. If the code is working without refactoring, then leave it be. If the code needs to be changed write an integration test that covers it and then start refactoring after your integration test is written. Don't try to write unit tests for legacy code that isn't unit testable. Write unit tests for all new code you add. Behat/end-to-end tests are great for testing existing code in a legacy system because they offer immediate feedback without refactoring first. Once you can go into your refactoring session with confidence it takes off so much stress. 
This is a major piss off for a lot of libraries. PhpStorm has a huge user base, why can't they spend a couple minutes to doc-comment everything?
Or also just as likely, that private method contains logic that should be abstracted into its own class. The best way to make classes testable and granular is to try to have a fractal dependency tree (where it makes sense obviously). Constantly ask yourself, what does this class I'm writing represent conceptually. Software development is the act of modeling whatever problem it is you are trying to automate the solution to. So if you need some super complex private method, odds are you are trying to model something in the context of a private method as opposed to its own class. Example of this I came across, we had a class that needed to call an external api. The previous developer had implemented the logic interacts with that api and get data from it with the same class that consumes it. All this logic was in the form of private methods. I refactored the class into two, one class which queries the external api and packages the results in a format consistent with how the rest of the applications code was modeling the problem space. Then a second class that consumed this packaged data. Both classes were easily unit testable now (the external api also required a few integration tests to verify that what my mocks were expecting was what I was actually getting from the api since I didn't control that code). 
Generally, a PHP *parser* is responsible for reading the source code you write and converting it into a different format. For example, the PHP runtime uses a parser to convert your source code into a sequence of operations that can be executed by the runtime/VM. Nikic's parser turns your source code into a PHP-readable version of that same operation sequence so you can analyze it yourself using another PHP script. This allows you to, for example, find all the places where a variable's value is taken and check if it had been set before (that means you can verify that you are not reading an uninitialized variable). *Static analysis* is the process of reading the code and analyzing it without running it. In a strongly-typed language like C++/C#, this lets you identify a large amount of problems, including issues that are not errors from the language's point of view, but are logical errors made by the programmer. In a loose language like PHP, you cannot find all the same problems, but you can still find plenty. For C and C++, notable static analysis tools include `lint` and [PVS-Studio](http://www.viva64.com/en/general-analysis/) - look at a few examples to see the kind of stuff they can detect. `lint` became a generic term for this type of analysis tools and now there are tools like JSLint, CSSLint and many more, based on the same principles. Advanced IDEs, like PHPStorm, also do this kind of analysis as you write, without running the code.
"a couple minutes"? That's quite optimistic :) I fully agree that this would be a welcome change, but some cases are more complicated. For example, [this is how you need to document factory methods in PHPStorm](http://youtrack.jetbrains.com/issue/WI-6027). Libraries don't touch custom solutions like that unless it becomes standard...
It's not black or white. The way to go about it is think about how your class will be used. Your public methods are you api. What does it make sense to expose. Should certain properties of a class be edited after its created? A users ID should never be edited after its created, therefor the id shouldn't have a public setter. Should a users password be changeable later? Absolutely, so it should have a public setter. Also, quick tip. Try not to think of extensibility when creating a class as inheritance is almost always the wrong way to go about reusibility. Instead try to use dependency injection whenever possible. It's much easier to test and has much fewer side effects. There are some good articles on composition over inheritance. The concept sounds a lot more complex than it is, but it basically comes down to you can more confidently code when you have absolute knowledge of what people using your class have access to and what they don't. 
Good one! :)) to be honest I do not have the cleanest code... but it's not the worst neither... my app is about 60K lines of code... I showed it to someone who is an OOP expert he said it's almost like an OOP code without using objects... well he thinks I'm crazy too! for example in my app I do something like: rquire_once DATABASE; $user_email = database_get_user_email_by_id(2); Yes, I have very long function names.... and even variable names as long as this: $current_design_conf_in_templates_folder // an actual variable name copied from my code It sounds silly I know... but I have never had problems reading my 1 y.o code... It's just as clear as it is stupid! That's why I almost have no comments.... Please criticize! I feel more than ever that it's time to change my coding style! 
You can probably get away without actually writing any private methods... just use protected. Won't be ideal but of you want better coverage you can't use private.
Yeah, factory methods are a bitch, but at least pick off the low hanging fruit. It should take no more than a minute per function. Write them at the same time you write the method and it's not that much of a pain. They're great documentation too, not just for code-completion.
What specifically interests you about their integration? There shouldn't that much that's different from integrating any other JS framework. &gt; *how you have to change AngularJS headers to make them show up in $_POST* By default, Angular posts data as JSON with `Content-Type: application/json`, and PHP does not know how to process that. I decided to add some code to the PHP side that parses this data and puts it in `$_POST`, similar to [this snippet](http://stackoverflow.com/a/19870028/1233508), but you can [tell Angular to post normal form data](http://stackoverflow.com/a/19633847/1233508) instead.
kinda make sense, but the right visibility should be package private sadly no such visibility exists in PHP
&gt; I think those looking for pure "speed" - attention is probably better spent on a PECL module implement, there is a C reference as well out there which could probably be ported. The reference implementation in C is not in good shape, at all. It's currently being rewritten by a staff member at github, I expect it will emerge from this rewrite in better shape. When the reference implementation is as it is described (provides a shared library), one of us will indeed write a PECL extension.
I've gotten some pretty useful advice out of them, since we have hundreds of generally small databases, a design that doesn't seem to be very common (and thus hard to find anyone talk about optimizing for). Once or twice it was helpful to have someone who just knew about a particular bug without me having to spend 30 minutes searching for it. But YMMV, of course.
I am working with these two. There really isn't a whole lot you need to do in order to make them work together. Auth is the trickiest, but that's true of any app. If we wanted to swap out PHP for Python and keep the frontend, we could easily. Makes me feel like we are doing something right.
Take a look at the [symfony](http://symfony.com) and [laravel](http://laravel.com) frameworks. 
You are a stranger on the internet, Nikita doesn't owe you an explanation of anything. As it happens, he did provide reasoning, which you ignored: &gt; Basically, it comes down to this: Either we disallow direct calling of all magic methods, or we allow it for all of them. We chose the latter behavior, only __clone was left behind, because it was introduced early. &gt; Sorry, I don't get how __clone() is different from any other magic method, like __construct() or __destruct(). All magic methods are automatically invoked and should usually not be manually invoked. What makes __clone different? The manual does not define how the language *should* behave, it defines how it *does* behave. In a perfect world, sound reasoning should be the thing that defines behaviour; the changes to the magic clone method make it consistent with the rest of PHP, all other magic methods. There was no *good* reason to make an exception of __clone in the first place, that the manual takes the time to describe it's behaviour shouldn't allow you to dismiss obviously correct reasoning and question the abilities of one of our most active contributors. Some people talk a lot, you are left with no choice but to base your opinion of that person on the words of their mouth. Others don't talk so much, (usually because they are busy doing stuff), you are left to base your opinion on the fruits of their labour or lack thereof. Your highly tuned powers of perception should finish the rest of this paragraph for you.
Is there any search library written in PHP that does the job of sphinx but without needing to install a separate server software?
Both Parsedown and php-markdown have open issues for CommonMark that indicate they're not super keen on adopting the standard. Seems like a good opportunity for a new project to take the limelight.
Think of it as: * Public: The Interface * Private: The Implementation I'm not a fan of protected as the reasoning behind using it varies too much.
Good to know thanks
Honestly that guy is a hero, he's a very good asset for PHP's future. And he has done *a lot* of good work already. For example he was the one that rewrote the PHP parser into an AST. That's just huge, people have been talking about this for years, and he just did it. So I do believe he knows what he's talking about :)
Regarding performances, I'm copy-pasting a comment I made elsewhere: &gt; How is that a problem? &gt; - is there a performance problem in every PHP application in the world? &gt; - does the call to `eval()` represent a large portion of the request/process time in every PHP application in the world? &gt; - do you *need* to cache that tiny bit of processing time in dev environment? &gt; Do you think that Symfony, Doctrine, Twig and ZF developers (and users) are just stupid and making a big mistake? Or that `eval()` actually answers a valid use case and you are just seeing the world in black and white? I'll give you a simple example: Doctrine needs to generate proxy objects. In dev environment, I don't want to have them written to disk because I need to set up a folder, correct permissions, handle clearing the cache, etc… So in that use case, eval is just perfect. So no, eval is not "evil" per se.
Number of stars on GitHub is my normal measure. Also look for at how thorough the tests are and activity, so frequency of commits, releases and attention to issues/pull requests.
Check the source repo. See how often it receives commits. One note about things like markdown. Markdown is a pretty old solid spec at this stage, so even the most current and stable changed to a lib may be old, unless they add features not in the basic spec. I wouldn't expect much in the way of changes for such a lib. Edit: for markdown, since there are numerous libs out there, I'd go with whichever is the fastest and has the cleanest API that conforms with my programming style.
Until PHP adds private inheritance, I maintain that there are legitimate reasons for needing to test protected methods, as they are part of the API for other classes. Private methods are a different story...
By "deny login DoS" do you mean DoS-ing by repeatedly invoking the CPU heavy slow hashing functionality? If so, I haven't found any resources so far on how to aid that issue. Do you know of any?
Stars on Github, how often it's updated and test coverage.
In the beginning you don't really have to. With time and experience you will understand.
I started with symfony. Best thing I could do. I didn't need to understand how it all works under the hood. It just works! Then with time and months passing using it (and its components in other projects) you start understanding how it works eventually.
How can I get started with unit testing? :/
&gt; Public methods establish how to interact with your class. They should be unit tested, and should changed only after much consideration. Ohh, I'm much more inclined to do this for private (protected) methods. These are really small and a public method is more likely to use several methods, while a private function always has one responsibility. 
I have answered you three times in that thread. It didn't seem like the discussion was going in any useful direction, so I didn't continue it.
Author of [Parsedown](http://parsedown.org/) here. We are very keen on adopting the standard. We created a branch dedicated to that a few days ago.
Repost. It was idiotic then and still idiotic now.
`ast\parse_code` is slower than `token_get_all`, because it's a more high-level abstraction. The syntax tree is built by using the tokens that `token_get_all` exposes. However the function is not actually slower proportionally to the additional work it does, because the bottleneck is not the actual lexing or parsing, but rather the creation of PHP arrays and objects. In my tests it was between *5-50% slower* than `token_get_all`, depending on the structure and size of the file. Compared to `PhpParser\Parser::parse()` the function is *30-50 times* faster.
Start with phpunit: https://phpunit.de/ Read the guide -- that's how you get started!
Without needing to install separate software, not *really*. Your primary datastore (like MySQL or postgres) may have a way to do fulltext search, but if you want really powerful and fast search you'll need to use something like sphinx or (my recommendation) ElasticSearch. 
Sometimes I think about writing procedural code. And sometimes I have a feeling I could do crystal meth, and then I think to myself...better not. 
You could build an index and search through it via a Lucene implementation in PHP (Zend Framework has one, I believe). However, you will most likely suffer in performance if you're dealing with large amounts of data and have no caching of the search index between requests.
Thanks for the opportunity. I consider myself an experienced php developer but recently I found myself thinking if I was retarded after reading a thread about what features should php borrow from other languages. So my questions are: Can someone eli5 lambda expressions and list comprehension for me? Maybe I'm too wrapped up in php to understand these. 
I mean this line: https://github.com/panique/php-login-advanced/blob/master/classes/Login.php#L274 which doesn't let a legitimate user log in if someone just tried to log in for his account using bogus passwords. DoS caused by exploiting heavy password stretching process can be mitigated by using correct (bcrypt) work factor. If you use something like 1 ms of stretching time, it is a lot more harder to exploit than, say, if you used (overkill) 500 ms stretching time. Some more info about this here: http://timoh6.github.io/2013/11/26/Aggressive-password-stretching.html
We're actually going to be using it as the means of authentication and verification for our payment platform when people submit the hidden form to us. The secret will be the pre-shared key between us and our vendor and the body will be certain bits of the submitted form that tells us the form hasn't been messed with by the user. 
If you need private inheritance you are *probably* modelling has-a, not is-a, and that's better done with composition.
If they contain enough logic that they require independent testing, they should probably be dependencies, not private methods. Make a new class where your private methods are public. If it's too much to refactor to a proper dependency-injected solution in one hit, you can even make it static methods for easy calling *ugh* This sort of rewrite could be just copy-paste the original code into a new public static function and call it. Don't use statics unless you must OR really know why they're good in this exact case though. This is something I've done a lot in the past. A lot of small, but logic-intense helper classes helps to keep a single objects conceptual weight low and a surprising amount of these have some re-use value.
This is a good question. GitHub stars etc. can give some insight, but it could as well mean nothing about the quality of the underlying code. A few things that could help to get a better view of the project: * Knowing the authors, i.e. a well known XYZ specialist releases XYZ library. This probably gives some trust for the project. * Mentions about the project from trusted persons, i.e. a well known XYZ specialists recommends library A. * Do they offer security/bug bounties for the project? * General commentary about the project (if it has been posted on, say, /r/PHP). And besides those, code review of any third-party components used (like GitHub projects). On some companies/situations, this is an absolute must. I wish I there was a plug-and-play solution for this.
&gt; Or is it just a way to enforce the proper use of methods (by yourself or by others)? I'm often using it for this reason. Or to make sure to decouple *what* a class does (public methods) from *how* it does it (private methods). Public methods are part of the contract of how your class is going to be used, so whenever you change what a public method does (its return value, its side effects, etc), you have to be careful not to break existing code with your change. But whenever you change a private method, you only have to check callers within that class, none outside (of course, these callers might be public, so still be careful). Another reason is having ugly boolean parameters for internal (private) methods and then expose properly named public methods without the boolean parameter for much better readability. so private function do_some_thing($param, $with_foo){} but public function do_some_thing_with_foo($param){ return $this-&gt;do_some_ting($param, true); } and public function do_some_thing($param){ return $this-&gt;do_some_ting($param, false); } 
Typically I fork the repo, add comments, then put in a pull request. Why not take a few minutes to help others after you? Hell all you need to do in phpstorm is type /**&lt;enter&gt; and it's all done for you!
My main estimation metric is "Is it codeigniter?"
Nope, use something quite similar that we implemented ourselves (serialized data, encrypted then HMAC'd), works well for us.
Not really familiar to it, but I want to learn about it as soon as possible. I've read about it, but never tried it by myself.
Isn't OAuth 2.0 bad and insecure?
I think it's trying to communicate.
I'd say there's a few levels here. First you'd want to look at the more superficial things: * How many commits are on the project * When the last commit was made * How many contributors there have been * If on GitHub, how many stars/forks. Otherwise, maybe download count * Was the library recommended? (and when was that recommendation?) * Number of open issues in bug tracker * Has it released versions or is it just dev-master? Then you start getting into the quality aspects: * Does it have unit tests? If so, are they passing? What's the coverage? * What are the results of the various PHP QA tools (PHPMD, copy &amp; paste detector, etc) * Does it embrace Composer? * How well does it follow a coding standard? Obviously you have to weigh each of these against your need - if the package is only one of 2 or 3 that do what it does, you can't dismiss it just because it has failing tests. On the flip side, you can also take the answers to these questions as a guide of where to contribute back to the project. :)
No. Because it's kind of a loose spec, people can implement it poorly. 
If I come across any good getting started guides I can send them your way. It might make sense to just do a some really basic tests to get the idea, like write up a class that adds two values together and returns the result, then you can write tests that confirm that adding a + b actually does yield c. The TDD version of this is to write a test that confirms that a + b = c, then write the class the adds a and b and returns the result.
There are a number of comments saying that people watch the number of stars a repository has. Which has merit all on it's now, I simply don't think it's such as good idea. IMHO you should be much more interested in active commits, and by whom.
This is great advice, however, I've also worked places that are really backwards and don't let devs touch the codebase without having a reason from the product team. I'm just saying these always/never answers tend to be too strict for the real world.
If you follow and big open source projects, take a look at how they organize their unit tests. Typically, you have a phpunit.xml file that defines their options (this is incredibly power, and a little overwhelming at first), and a tests/ directory, which should match the directory structure that their code lives under.
There's nothing wrong with OAuth 2.0. Read Phil Sturgeon's book "Build Apis you won't hate" https://leanpub.com/build-apis-you-wont-hate
I would add (in addition to all the other great comments) that PSR/composer support, test coverage, and good documentation are all great indicators of a well maintained library.
I need a routing library/component * multiple routing files (route definitions in many files*) * caching * wildcards /{id}, etc * callbacks but also be able just to specificy a controller/handler * &gt; 5.3 psr-4/composer * tested * preferably well-documented (covering my needs above) Any suggestions? 
How should acceptance tests be designed using codeception, can I simulate and group tests, like a group of tests for login, one for failure, on for success, etc. How do I go about like database suddenly not working etc? How do I test that?
I think I traveled back in time back when it was common to echo HTML with PHP.
Here's where you use protected: When you are creating a base class with the intention that it will be extended by other classes, and you would otherwise make the method private. You can't access private methods of a parent class in the child class, which is why you have to "open them up" to being protected.
RE: Laravel question - because you are registering an event handler. If you are familiar with JavaScript and JQuery, this should be a clear parallel. You're telling the framework what function to call if an event is fired, but you don't want to call that function until/unless that event happens. For example, when you define a route in Laravel, you are telling Laravel what function (anonymous or named, in a controller or not) you want to be executed if that route evaluates to true. FYI, WordPress works this way also when adding filter and action hooks.
Add number of issues to that. Projects with a lot of issues tend to be used a lot
I agree, we have what we call a "factory" which is in charge of creating the front end, I was thinking in rewriting the factory using html5 and responsive to give it a better look and feel; this way we get to maintain the same version with a new factory. I'm a beliver hehe I just need to transmit that to my speech. thanks!
Code like it's 2005!
Do what with private/protected methods? Unit test?
That feels way too recent for me :|
PHP4.4 was released in 2005, PHP4.0 in 2000: http://php.net/releases/
Thanks, I appreciate the input, I will certainly keep this in mind when working on this project. The more I think about it the more I realize that having these methods as public / part of the API is legitimate.
Or are buggy and have been abandoned... Balance of open/closed and time since last closure are more telling.
Php is still a a templating language in many ways, and there is no inherent problem with using string concatenation to build up HTML output, as long as you personally maintain a separation between business logic and the view. 
Your open issue specifically says the project's intention is to wait months to adopt the standard. I'm not arguing with your reasoning, but waiting months isn't going to help /u/colinodell who implemented something today.
True but that isn't really present in the post.
Those where the times, spend days -&gt; weeks -&gt; months figuring out how everything works with other young developers on MSN.
A lambda expression is a type of [anonymous function](http://en.wikipedia.org/wiki/Anonymous_function). Implementations vary from language to language, so if anything specific was meant by that it's impossible to tell without context. PHP actually has anonymous functions. [List comprehension](http://en.wikipedia.org/wiki/List_comprehension#Python) is a language construct that generates a list from an existing list with a user supplied expression. (Ironically, I consider list comprehensions to be incomprehensible and I really don't want to see them in PHP.)
Lots of good things have already been said ,but the number of downloads on Packagist also factors in for me (if it's on packagist). Total, per month, week, day ... I interpret each download as a tacit endorsement.
The [Symfony Routing Component](http://symfony.com/doc/current/book/routing.html) meets all those requirements.
&gt; I have answered you three times in that thread. You didn't address the issue that clone behaves differently from other magic methods in the sense that clone($obj) invokes the clone method of the newly created $obj (as a result of clone), instead of acting on the original $obj. So when you call $obj-&gt;clone(), it is not the same as clone($obj). So if you allow clone() to be directly called, it might cause inconsistencies. because $obj-&gt;clone() != clone($obj).. So clone magic method is different from other magic methods like __set and __get.Is that so hard to grasp? 
Have you looked at ohloh's measurements?
Any general or specific advice on how to avoid writing spaghetti code? I'm able to keep my code relatively simple when performing basic CRUD actions, however I've just implemented an xml parser and it is a horrible mess of if/else and try/catches. Say you were building an RSS parser, what would your class/classes and methods look like?
If you can't test your private methods through your public methods then it is dead code that can't never be reached. Code coverage will allow you to see what and when each instruction is used
Good ressource on both most used TDD approaches http://codemanship.co.uk/parlezuml/blog/?postid=987
Now this is an appropriate time to link to this website.
So I'm pretty sure the reason this is being downvoted is that it's fairly well-known already and, in fact, noodlehaus is (used to be?) an active contributor to this sub. That said, I really do like PICO. Lately I've been getting excited about small web apps that do just what they need to do and no more. Just some routing, wire up a DI container real quick like, and boom you're on your way. This sort of thing makes me feel more like a PHP developer and less like a "laravel" developer or "wordpress" developer. No one would ever claim to be a "PICO" developer or a "Klein" developer. They just *use the tools*. PICO and things like it can be really great tools when the job calls for it. It's really only appropriate though when you're absolutely certain the project doesn't need to scale. Or if you suspect it might need to scale someday, I suppose just build in such a way that it will be easy to transfer. 
If you do extensive use of setter/getters you might be suffering from an [Anemic domain model](http://www.martinfowler.com/bliki/AnemicDomainModel.html). Protected getters/setters can be useful when you want to decouple your domain (as you want to do in Domain Driven Design) from your data handling layer. For example you have in your domain the following classe in which you define a behavior abstract class PersonAbstract{ public function calculateAge() { return (date('U') - $this-&gt;getDateOfBirth()-&gt;format('U')) / 3600 / 24 / 365; // doesn't support leap years } protected abstract function getDateOfBirth(); } With a class like that, all your domain logic is defined, and you don't have to care about the source of the data. Imagine you want to implement this from an ORM data soure (like Doctrine): class PersonDoctrine extends PersonAbstract() { /** * @ORM\Column(type='dateTime') */ private $dateOfBirth; public function __construct(\DateTime $dateOfBirth) { $this-&gt;dateOfBirth = $dateOfBirth; } protected function getDateOfBirth() { return $this-&gt;dateOfBirth; } } All you have to do is implement the getter method and extend your domain object to be able to calculate the age of the person. You could create an entirely new entity from an ActiveDirectory source that extends the same class and all that you have to provide is the same getter and it will work. You can eventually change de visibility of your get/setDateOfBirth to public if you have to display the data, but otherwise, it can stay protected. If a class has only getters/setters and no behaviour it can be considered a [Value Object](http://martinfowler.com/bliki/ValueObject.html) and for data safety/integrity should be be immutable.
While this will serve as an excellent Turing test for bug reports by more experienced developers, I fear that many bugs or issues spotted by more novice users will go unreported.
Oh. This made it sound like the Laravel team were arbitrarily removing issue tickets, but it turns out that they disabled the issue section altogether. 
Try as hard as you can to match the principles of [SOLID design](http://en.wikipedia.org/wiki/SOLID_(object-oriented_design%29). Each principle has relatively straightforward rules to follow, and you should have to justify to yourself why you need to break any of them before doing so. Coming to terms with SOLID design alone will help minimize a lot of problems and help you think differently about writing more maintainable code, but here are some other tips: - Minimize branching: if you're using long strings of if/elseif/else blocks, it's a fairly good sign that your function/method is doing too much. Again, there should always be a solid justification for doing that instead of breaking it up into more manageable chunks. - Let exceptions bubble up as far as possible: if you're catching exceptions immediately just to log it or display an error message, let them be thrown and catch them all at a higher layer. Similarly, if you have no meaningful way to handle an exception in context, don't catch it. - Minimize nesting: a good rule of thumb is to avoid indenting more than once or twice in a method or function unless you have a really good reason to. Practically, this means things like returning immediately if a condition fails instead of wrapping the rest of the code in an `if` block or breaking out nested logic into their own functions/methods. - When a function or method goes past 10-15 lines, start thinking about how to break it up. Is it violating the [single responsibility principle](http://en.wikipedia.org/wiki/Single_responsibility_principle)? Is there code that [can be reused elsewhere](http://en.wikipedia.org/wiki/Don't_repeat_yourself)? - Start looking into design patterns. An algorithm or structure that you came up with on your own and takes 300 lines may be better solved by a pre-existing design pattern that only takes 20. A good place to start is the Gang of Four's [*Design Patterns*](http://en.wikipedia.org/wiki/Design_Patterns). It's pretty dated in its code examples (uses Smalltalk), but it gives a point of reference to know what to look for when finding more up-to-date examples. Finally, check out the book [*Clean Code*](http://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882) by "Uncle Bob" Martin, which goes into a lot of the above and more in more detail.
I'd have to say you are [mistaken](https://github.com/erusev/parsedown/tree/commonmark). Their efforts into implementing the spec are anything but low quality and half assed. So to claim you support it better is a bit subjective as they aren't even finished.
More people should do this. But please don't leave the phpdoc saying just `@return array` - if it's at all possible, be more specific, e.g. `@return Thing[]`.
Indeed. This is what the documentation currently reads like: &gt;Laravel is an open-source project and anyone may contribute to Laravel for its improvement. We welcome contributors, regardless of skill level, gender, race, religion, or nationality. Having a diverse, vibrant community is one of the core values of the framework! &gt;To encourage active collaboration, Laravel currently only accepts pull requests, not bug reports. **"Bug reports" may be sent in the form of a pull request containing a failing unit test.** A failing unit test provides the development team "proof" that the bug exists, and, after the development team addresses the bug, serves as a reliable indicator that the bug remains fixed. At one hand they say that anyone is welcome to contribute regardless of skill level, and at the other they require the contribution to take place in a way that clearly require a specific skill-set. I don't see how they're supposed to reconcile the two statements. 
absolutely. Though I think that a lot of people don't realize that you can do that ... that being, specify an array of object with the square brackets
Yes indeed! There are some high level information there, but I always feel unsatisfied because 1) they don't have metrics on project management (like are issues and PR actually acknowledged and fixed) and 2) metrics are not up to date. And also it seems not all projects are on this but I'm not sure. Anyway there are some good things, but still not perfect to me :)
Just modify its visibility for the duration of the test. If it's properly isolated and has a single responsibility it shouldn't be that big a deal. &lt;?php class MySweetAssClass { private function my_private_method() { echo "show me on the doll where the bad language touched you"; } } $method = new ReflectionMethod('MySweetAssClass', 'my_private_method'); $method-&gt;setAccessible(true); echo $method-&gt;invoke(new MySweetAssClass); ?&gt;
This sounds like the kind of situation where you need to assert your expertise as the developer/consultant and tell them PHP is not currently the right choice. If they continue to disagree, air your concerns about stability.
There is no need to do this and it's extremely clunky. It's not easy on the eyes, even if you completely ignore the lack of consistent formatting used. Any templating system will allow you to just iterate over an array and be done with it in a concise way that is incredibly straightforward. Back to formatting...it's kinda gross. Inconsistent spacing across the board. If you want people to take anything seriously, it should look nice. It doesn't have type-hinting for the "value" parameter. "string" is a bad name (consider "title" or some alternative). Nothing is escaped. What if one of the parameters you passed in has a double quote in it? I'm sure it's not unit tested, but that's another matter entirely. Not trying to shit all over it, but it needed to be said. Logically, it shows a basic grasp of some of the extremely fundamental concepts. But it's a very dated approach and has a number of flaws at every level (concept, implementation, etc.).
You don't need to instantiate a ReflectionClass for this. Use ReflectionMethod.
That doesn't answer my question though. Why use call_user_fund instead of $callback($event_data) since functions are first class citizens in PHP?
Sockets in php are solid. Php as a long lived process, also not bad. Same pitfalls as any language. Make sure you don't store anything you shouldn't be. Also, since the hardware is underpowered, consider using unset on any complex objects you don't need anymore. That said, php is a terrible choice for underpowered hardware. 
We use [RabbitMQ](http://www.rabbitmq.com/tutorials/tutorial-one-php.html) for this sort of thing although [ZeroMQ](http://zeromq.org/bindings:php) works as well. Both have PHP bindings. When it came down to it, react and ratchet were a couple layers of abstraction more than we needed. If they want to stick with a PHP solution for maintenance purposes this could be a good way to go
&gt; You are a stranger on the internet, Nikita doesn't owe you an explanation of anything.. Oh. I see. I need to be a friend of yours to have a discussion with you. Right?
This is currently a WIP for me as well and I've decided that since I want to use PHP that I will wait for some months before working on this part. I played with Ratchet for some days and it appeared to be very good except that it doesn't currently support WAMPv2 and the JS libraries seem to have all moved to v2. I could use older libraries for now but they don't seem to work well at all with a commonjs build system. I'm using webpack and it is similar in nature to browserify. So now there is a new project call [Thruway](https://github.com/voryx/Thruway) that builds upon some parts of Ratchet but has a more generalized approach to transport agents and I guess seeks to use unix sockets as well. The documentation for Thruway is not so hot but there is a flurry of development right now and the project looks like it has a bright future. The upside to socket.io is that it has some crazy amount of test cases and it is being somehow automated tested in numerous browsers for each commit. My take is that currently Ratchet is very good if you don't need WAMPv2 protocol.
I think that Ratchet is plenty good if he doesn't need WAMPv2. That is for me the only hitch. Also I'm not sure if socket.io has any built-in WAMP support at all.
It kind of took me forever to figure out which pieces of the Ratchet library to put together while I was evaluating different ways of doing it. The documentation was just barely good enough.
I'm not speaking to whether it is or isn't good - but if OP thinks it shouldn't be done in PHP, he should be forward in that towards his client. Otherwise he's in the wrong business.
Yeah, that's what I was thinking of and really do not care for it.
Callbacks can accept a variable number of parameters, and using functions like call_user_func allow for specification of the function name as well as a variable number of parameters to pass to that function. In WordPress, for instance, not every callback is going to use every parameter, so you might define a callback with only one incoming parameter when it is possible to include several. Additionally, callbacks can be specified in different ways - calling a standalone function vs. calling a static method in a class vs. calling a method in an instantiated object. Depending on how the callback is specified, the code can use either call_user_func or call_user_func_array depending on the callback target.
Just my thoughts as expressed earlier today in this short [twitter thread](https://twitter.com/Ocramius/status/509367221085544449): * requiring issues as PRs with failing tests is perfectly acceptable, but far from reality, and especially a reality where time is limited, not just for maintainers. * removing issues (without tests) prevents documenting of: 1. architecture limitations (there's no way to test those, typically) 2. bugs that cannot be tested easily (race conditions, complex setups, heisenbugs) * reduces discussion, limiting it to the laravel forums, which are visited only by a small part of the github community * issues are harder to search * contribution requirements are greatly raised: laravel is a framework for beginners, and a beginner should also be able to contribute, even by just reporting a problem without any clue of where it comes from My feeling is that this change was introduced because of too much pressure put on top of the Laravel team, and I don't think that this is a solution to this sort of problem. Having a long list of overdue bugs to be solved is not something to be ashamed of: an issue tracker is exactly designed to do that job for you, and here the proposal is to get back to forums. Additionally, it is perfectly fine to say "I will not install your application to verify your problem": there's a specific name for this sort of issue, and it's usually "incomplete" or "invalid". If the time wasted on this sort of issue is too great, then write about it or take a volunteer to dig out and close these tickets. In general, don't expect me to search a forum for known bugs in a particular software revision of laravel, it's just not how it should work, and no, not every issue is representable by unit tests the day it is discovered. **EDIT**: so it seems that https://github.com/laravel/liferaft was released today, and it should be the way of producing bug reports via pull requests. It's an interesting concept, and very similar to what [/u/cordoval](http://www.reddit.com/user/cordoval) did with [gush](https://github.com/gushphp/gush). Mixed feelings, but this is still far from writing issues, and yet another tool to learn in order to open an bug in a tracker...
May be they are getting too many bug reports for test cases that are hard to set up or something like that. But they could just have made it clear that bug reports with test cases will be prioritized over the ones with out.. Is there any other project that have done this before. I know some projects require a bundled test if you are sending an issue fix? But for a bug report? That's new..
Imho it's fine and of benefit to be in the very same repo. You wouldn't ask the question for tests either; that's what I'm trying to say ;)
To be honest, this is not that far from the previous situation where people opened bugs and /u/utotwel closed them without even a comment. Many people complained in the past, nothing changed and now it became slightly worse. The third-party forum is also no substitute as, AFAIK, Taylor doesn't even participate there. Add to that the current forum lacking even basic functionality of the previous, well-developed one, people really have no place to report issues anymore.
&gt; I don't see how they're supposed to reconcile the two statements. Minor nitpick: [There is no "they"](https://github.com/laravel/laravel/graphs/contributors). The second-highest contributor has 0.038% of Taylor's commits. For better or worse, Laravel is a one man show.
[they](http://images6.alphacoders.com/342/342567.jpg). Edit: Thanks for the gold. 
I haven't launched any large applications yet with PHP sockets, but I am currently developing one using Ratchet. So far, I have had about 20 simultaneous connections with lots of data streaming both ways and it was just fine. I am planning on this application handling around 1-2k users simultaneously, but again, I have no idea how stable it will be yet. More over, if you are uncomfortable about using Ratchet, then voice your concerns. However, before you voice your concerns, I would find out their concerns with Node or whatever technology you think is appropriate for this task. If you can understand their concerns, you may be able to resolve their issues and use the technology you want. 
Don't think that was what I was saying at all...
That's a great point. I've opened a new issue as a reminder to myself. Thanks for the idea!
Thanks!
My bad then
I've considered this. I've had bad experiences with PRs in the past though. People are very anal about their projects and if I'm going to donate my free time to help a project out I don't want to have to go back and fix it 5 times because the spacing isn't quite to your liking.
I could test the private methods through the public one, but the logic for the private methods was so complex that I thought it merited testing. Upon reflecting on many of the responses to my question, I've realized that having these methods as public is actually appropriate and likely to be necessary for future features. Basically it's a scoring system, and originally the "total score" value was the only one public. I wanted to test the logic of the constituent scoring functions, and thinking about it I realize having the constituent scores public will likely be useful down the road.
That makes sense. Thank you for explaining! Are there any plans to make a generator version of `token_get_all` that works off a file stream? That would be more memory efficient to process for large files, no?
Personally it doesn't bother me too much since I have no problem creating a failing test case if I find a bug. I might be different than most having a long history managing software quality. 
&gt; In my mind, all 3 engines (MySQL, Percona and MariaDB) are pretty much the same and I have no particular reason to choose one over another, so I was looking for feedback before picking the de-facto MySQL. Increases in performance will come from 1. higher versions of the software 5.5 or 5.6 far better than 5.1, etc 2. proper DB design - choosing the right engine, normalisation, indexes, no select * queries, proper joins, proper data types, memory variable settings, using Explain a lot, partitioning, etc. In short, DB tuning. 3. Hosting provider - Shared / VPS / Dedicated - MySQL on separate disk, SSD or not, available RAM Once you have those kind of things covered, then, I guess you should worry about optimising between MySQL, Maria DB and Percona. Percona has some built-in tools for metrics which you might want and so that might be tempting. Also, if your application isn't very different from the mainstream business app bunch, I suspect you can design a schema and queries that can be moved from one of the three to another without issues of any kind. /my opinion
It might be worth to extract the scoring mecanism to it's onw class and pass it as a strategy to the user class. This way you could reuse it somewhere else, swap it for an other strategy or even use it as a part of a composite of scoring strategies to calcule the optimal result.
Hey, thank you for this article. I enjoyed reading it. I noticed in the "How they're created" section, you wrote that there are three periods that separate the three components of an encoded JWT. I think that number should be two. Cheers!
Digging graves 101
I agree; that's what interfaces are for.
It's doesn't sound like a bad idea; especially if you can customize the forum software and if there is github API support, e.g. assign pull requests to posts and vice versa. Otherwise there is the github issues "this is not a support mechanism" complaint. I think beginners should have code completion support, but thats a different topic. However it should be possible to submit request via github without needing a local version. 
If you are using OAuth, I wrote the JWT grant type for this OAuth 2 Server: https://github.com/bshaffer/oauth2-server-php/
Thank you. Late comment but I think it's the best so far. :) 
But now you can simply search the irc logs for reported bugs /s It's really infuriating. I've been googling for solutions to a couple things and already have found numerous links from google or the forums that refer to git issues that appear to have the solutions I need, but they're not accessible. Fortunately google cache still works on many of those links, and I have found what I've needed. There's so much discussion lost from the issues being removed. I hope they revert the change...
Same boat as you. Mind if I hit you up with some questions and to trade notes?
Oh, and there'll be a full transcript available when the podcast is posted, too! PS If you have Q's for RethinkDB's founder, let me know, too! http://www.reddit.com/r/programming/comments/2fyf31/this_is_your_chance_to_ask_rethinkdbs_founder_a/
y u no fix api andi pls
Remove everything. Leave just &lt;?php ?&gt;
Yeah...but I'd have to maintain my own repo then, periodically merging in their changes.
I'm not sure about the original creator, but if you look at the dev branch on github, it appears to be fairly active. https://github.com/UnionOfRAD/lithium/tree/dev That said, I prefer Symfony. You may like Laravel, also.
Yes.
I've been reading about writing extensions for years, it's really what you'd want to look at if you want to really understand how it all works. But the problem is that it's quite a mismatched mess of resources. In the past couple years there have been a few more articles and such written about the subject. Anyway, I'll get to my point. Typically the beginning part of all of these resources is an explanation of how variables are passed from php to c and how they work. You'll learn that the underlying structure uses ZVALs for pretty much all variables that are scalar values, and hash tables for arrays and so on. Now, there are extensions, such as SPL that implement their own structs for variables and arrays and the sort. Anyway, look for resources regarding extension writing and you'll learn a lot about the Lower level C stuff. Also just poking around the source helps. 
There are still &lt;? ?&gt; and &lt;?= ?&gt;.
Do a small chunk first (say one or two classes) then send a PR and see if they like it. Say that you would be happy to do more.
Probably not a good idea, as removing &lt;? ?&gt; and &lt;?= ?&gt; would break WAY too much BC with existing codebases.
Can you provide a source that isn't word of mouth?
&gt; proxy objects could be achieved with magic methods. lol I'm sorry maybe you can help out the Doctrine team because you seem to have so much knowledge…
We're talking about PHP7 here. It's a rare chance to move forward. Any decent IDE could replace these tags.
Also &lt;?= is great. Screw the short tag but grant me my short echo
Never used any of these tags, I'd be for removing them.
I never understood why those were labeled `&lt;script&gt;` instead of `&lt;server&gt;` like in Netscapes original server-side JavaScript.
Not totally sure why, but this has bitten me in the past: Make sure the encoding on the channel you're receiving these tweets on is utf8 encoded. (Database/HTTP connection)
It's no more lazy than using $i++ instead of $i += 1.
Unless someone produces benchmarks to prove otherwise, I'm betting microoptimization at best. This argument sounds reminiscent of early day dogma to use single quotes instead of double quotes to avoid variable replacement lookups. Real benefits will be cost savings in maintainability with one standard. I don't know who would do the &lt;script lang=php&gt; echo "%&gt;" combo but that really shouldn't be allowed. 
Take that shit out but leave your damn paws off my short php tags you damn dirty apes.
When there are more bugs and issues generated than can feasibly be tackled by the team this is inevitable.
Try this simple Method.. Soon some others will show to easy tricks to fix this.. http://pastebin.com/NwJ2kBgA &lt;?php $string = utf8_decode('this is just a #h̶a̶s̶h̶t̶a̶g̶ #h̶a̶s̶x̶v̶a̶g̶ to test'); if (preg_match_all('/#([^ ]+)/im', $string, $regs)) { foreach ($regs[1] as $k =&gt; $found) { $found = str_replace('?', '', $found); $string = str_replace($regs[0][$k], '#'.$found, $string); } } // Build an array for json $string = array($string); // Encode json $encode_json = json_encode($string); $decode_json = json_decode($encode_json); echo '&lt;pre&gt;'; print_r($string); echo '&lt;/pre&gt;'; echo '&lt;pre&gt;'; print_r($encode_json); echo '&lt;/pre&gt;'; echo '&lt;pre&gt;'; print_r($decode_json); echo '&lt;/pre&gt;'; ?&gt; Array ( [0] =&gt; this is just a #hashtag #hasxvag to test ) ["this is just a #hashtag #hasxvag to test"] Array ( [0] =&gt; this is just a #hashtag #hasxvag to test ) echo '&lt;pre&gt;'; print_r($decode_json); echo '&lt;/pre&gt;';
I use the script tags all the time. I like them better. Seems more concise and also its faster then the normal &lt;?php tag. That said im developing a framework that uses the script tags, it fits better because i embed so much html and javascript inside my php. I plan to have full support for php 4,5,6 and 7. Its like a mix of drupal and codeigniter with a flavor of mambo and dnn. 
it looks like the branch parent (or what the PR is against) is incorrect and is including a mass amount of previous commits.
As a student, how can I get Zend Guard for free or cheap?
Not sure if troll or serious...
&gt; than can feasibly be tackled by the team [There is no team](https://www.reddit.com/r/PHP/comments/2fx0sz/laravel_removing_github_issues_opting_for_failing/ckdn04g) :(
When you realized you can replace the &lt;?php echo with &lt;?=.
&gt; The most painful part is thinking about it being used ~other than in templates~... Fixed
I've decided troll. I refuse to accept the possibility that someone seriously said this.
&gt; they are all in less than version 1 states makes me extremely hesitant to use them Node, Current Version: v0.10.31
&gt; switched to short-tags default enabled Not short tags, **short echo** only. Short tags should be removed too. It's PHP7, not 5.7 - there must be as many BC breaks as possible.
It really is a big fucking mess when you get into SPL and the native language implementation. The APIs exposed to people writing plugins are a lot nicer, and if you want to learn the former, I'd start by studying the latter. https://github.com/jheth/hello-php-extension This will give you the "quick shot" write a PHP extension tutorial. It will teach you basically nothing, but will guide you to exactly the right place if you want to _start_ teaching yourself how the insides of PHP work.
Judging by the comments so far, this RFC could greatly benefit from explicitly stating what will *not* be removed (and in the case of `&lt;?`, why). [Edit] RFC updated.
&gt;&gt; The most painful part is thinking about it being used ~~other than in templates~~... &gt; Fixed Fixed
This should get you started: http://www.phpinternalsbook.com/
http://lxr.php.net LXR FTW ... No but seriously, the best way to learn is by reading, and this is the best bit of kit we have to help you get started ... http://phpinternalsbook.com is also good ... also, you could come hang around in #phpinternals (Freenode) #php.pecl (EFnet) or SO PHP chatroom.
&gt; The hard part of course is to come up with meaningful indicators ;) Yep indeed. Although human brain will be always needed, but such tool could ease the job and I think it is definitely worth researching.
Having people around so you can ask questions when you need help is better than any documentation I've found; that goes for any programming task. 
? 
I use Laravel for most things, loving Silex atm. Haven't really dove into Symfony, idk what it is about Symfony, but it's quite intimidating.
&gt; Having people around so you can ask questions when you need help is better than any documentation I've found; that goes for any programming task. This. Also, it's good to have something to set your mind on ... extensions are okay, but, they aren't really anything to do with internals, since most of the time they are light wrappers around third party libraries. If you're looking for something todo: https://bugs.php.net/stats.php Pick a subject you have knowledge of, or are interested in enough to research, and get stuck in ;)
It is obvious satire. Not everything is trolling.
Good old php 6.
The best way to learn PHP is - using "Zend PHP X.X Certificate Study Guide" as a start point - and learn how to use php.net website as a reference - and learn one of the bests frameworks as an requirement for development. (symfony or zend or even laravel) - then learn design patterns which are not limited to language and there is many good resources for that to improve OOP knowledge - after that they need experiences, tips and tricks, security issues, performance tips, optimizations, server things, programming principles that should be learned in around the world wide web
Commit [b72de3cca1a75cb945e0d196a71b70fa74f287a1](https://github.com/nikic/php-src/commit/b72de3cca1a75cb945e0d196a71b70fa74f287a1) has the tag removal stuff. The other commits are probably caused by a branch that's out of date.
*ahem* http://symfony.com/doc/current/contributing/code/bugs.html https://github.com/symfony/symfony/issues **Why is Laravel so different?**
Oh hai there shideon.. haha Symfony isnt requiring you to send in a PR with a failing unit test. If you can clearly describe the issue, they are happy with it. I've done it :) Besides that, im not sure what you are pointing out here 
Maybe that's the problem. They need to set up a system like the Linux kernel developers have. One all-seeing overlord with several trusted minions to filter out the noise. This is really not the solution to Taylor's problems. It fixes his problems to the detriment of the end product.
Yup, that's my point. I don't agree with Laravel's change and I'm saying that Symfony hasn't needed this type of a change so why does Laravel?
That's great thanks :)
&gt; One all-seeing overlord with several trusted minions to filter out the noise. That would be great but Taylor seems to have an unhealty obsession with keeping all the decisions to himself :(
It just copied ASP syntax. Trace it back, and someone, somewhere implemented that in ASP and no-one shouted loud enough "NO!" Legacy is a bitch. 
He did read it. Hence "take that shit out".
working in a company, where an amateur programmed an entire CMS, I have seen extremely filthy code but &gt; *&lt;script language=php&gt; echo "foo" %&gt;* just made top spot EDIT: format
How about go with an approach that it is insecure and let him know where, and then refactor it instead, if folks are happy about it, the best thing you can do is to improve it. 
If your boss thinks he knows Laravel can be scanned for, ask him to write up a script to do it. Laravel doesn't have any signatures on the frontend. People will never know it is in use unless you tell them. Homegrown solutions are fine, but only if you have a dedicated security team going over things before they go into production. Also, XSS is the biggest vulnerability against websites. Just because what you put out may not be big sites, don't think people aren't looking.
Thing is, because of supposed bots or hackers targeting popular frameworks, it means they've stood the test of time and have considered every possible use case. Symfony2 is solid as a rock if used correctly, as is Laravel. Security by obscurity is only going to work if best practices are also followed throughout, you can never predict the methods or ways in which a hacker will work. It might seem obscure to you, but to a seasoned hacker... it might be a different story. 
One route you could go down is to use Symfony components for forms, http requests etc. So you're still using your own framework, but it'll have more solid foundations in those areas you suspect are vulnerable. 
I prefer the combo Silex/Sf2. They use mostly the same components so it's really easy to switch from one to another. Silex is really nice for small projects and fast coding. Symfony2 is maybe intimidating at the beginning but is focused on a really clean structure and good practices. It's really important for big projects or when you are several working on the same project. There is also a lot of bundles availables which are working out of the box. I also tried Laravel. Even if there is of course good things in it, I think it's too much closer to a micro framework, there is some missing features. It just doesn't fit my needs.
&gt; I imagine that you also struggle to attract new developers or have a slow ramp-up while they learn? That's exactly what's happening here right now. Though my opinion was that it's just hard to find web developers currently. More recent coworkers never did web development. This is the first company I am doing web development at and if I would find myself in searching a new position I would certainly also consider the framework they use. So you might have a point. &gt; You could run a generic automated vulnerability scanner against your (local, dev) sites to prove that not only big frameworks are vulnerable from automated attacks. Acunetix made one I think. I would look into that, but hearing what our sysadmin says people are already trying without success. edit: I mean I will look into that.
I also found other problems in our framework I forgot to mention like the lack of best practice for some things since some new core features are implemented differently in different projects. Also there is actually never time for that.
Not sure what happened there ... I've rebased it onto master again, now it's just the one commit.
I'm upvoting the shit out of that comment haha
 &lt;script language="php"&gt; echo "Noooooooooooooooooooooooo!"; &lt;/script&gt; &lt;?php echo "YES! Hasta la vista, scripty!"; ?&gt; &lt;% echo "WHYYYY%!%! :("; %&gt; &lt;? echo "FUCK YEAH. QUESTION MARK SUPREMACY!"; ?&gt; ^^Don't ^^ask ^^^because ^^^I ^^^^don't ^^^^know.
Yeah that could work! Once they see the power of those components, they might get a taste for Symfony. If not, there's still a lot of power and flexibility in just using the components to taste without the full stack 
I am still on the fence about which framework to learn, Laravel or Symfony, and this is kind of pushing me in Symfony's direction. Any advice?
Oops, by the time I got down here I'd forgotten it didn't mention removing `&lt;? ?&gt;`. Which by the same logic they present in the RC, they should do. Obviously `&lt;?= ?&gt;` needs to stay though.
Are you sure you want to learn a specific "framework"? You should also consider building with components. Like using Symfony components, Zend components, Aura components etc. to get the job done. Pick a component/library that does thing A and another that does thing B... I mean just use precisely what you need and get the job done.
Honestly? You should give both of them a shot and decide which one suits you better. Personally, I like Symfony better since Laravel has too much "magic" going on. By magic, I mean Facades-but-not-facades, extensive use of magic methods, etc. It also has some ugly global state issues, but that's too long to discuss here :)
Laravel has just one person because Taylor wants it that way, not because no one ever stepped up...
Nah, &lt;?= is now seen as a long tag instead of a short tag. 
I've never seen these tags in real world except php.ini, documentations, urban legends, myths...
It shouldn't be too hard to implement a security layer that sanitizes the input. You can write forms in any framework that doesn't sanitize (filter) the input. For example in ZF2 you can write form fields that don't have validation/filtration rules attached to them and I'm pretty sure you can do that in any framework. I think you need better arguments than "potential XSS problems"
Yep, that's what's turning me off from Laravel (well that and some of the author's policies). OTOH, it seems like it's an easier framework to learn and it's very popular, which means I can get a lot of support if I need it.
That is true, I just feel that if I learn a complete framework, I'll have one more tool under the belt to make my work easier.
Just spend some time on this whenever you have finished some task, or do it in scope of this task
Because with this method you still have to write all of the glue and if anyone else wants to help you work then they don't have previous knowledge of how it works. Also documentation is spread out and there isn't a community surrounding it. I'm not saying that there are no benefits to doing it yourself. Just that for most CRUD websites a framework will get you up-and-running a lot faster. That's what they are designed for, speed of development.
I don't want to. Doctrine is bloatware. You should learn SQL instead. Or if you want ORM, Laravel's or FatFree are simple &amp; good, 
Besides, that is exactly what laravel is doing with their so-called facades. They are proxies ;-)
&gt;Their usage has been discouraged since forever Lol
:) Kinda figured. But...well, ya never know.
I think the best option is to spend time to secure your current app. adding filters should be enough (filter_var**) Then start the new devs, or new version of the products with a open framework, look at Slim &amp; Fatfree before going to mainstream (bloated) frameworks. At least just to compare. Just remember that when choosing a framework, you attach yourself to it, and I mean a **version of it**. look at the huge difference between Laravel 3 &amp; 4, or Symfony 1 and 2. If they were so close to the perfection, why there is a version 2? ;-) 
Just a note: If the information flows in one direction, you might be better served with [Server-sent events](https://en.wikipedia.org/wiki/Server-sent_events) than with Websockets. SSE are simpler, more reliable (since they go over HTTP) and faster. See eg. https://stackoverflow.com/questions/5195452/websockets-vs-server-sent-events-eventsource or http://matthiasnehlsen.com/blog/2013/05/01/server-sent-events-vs-websockets/
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Server-sent events**](https://en.wikipedia.org/wiki/Server-sent%20events): [](#sfw) --- &gt; &gt;__Server-sent events__ (__SSE__) is a technology where a browser receives automatic updates from a server via HTTP connection. The Server-Sent Events EventSource API is standardized as part of [HTML5](https://en.wikipedia.org/wiki/HTML5) by the [W3C](https://en.wikipedia.org/wiki/World_Wide_Web_Consortium). &gt; --- ^Interesting: [^HTML5](https://en.wikipedia.org/wiki/HTML5) ^| [^Comet ^\(programming)](https://en.wikipedia.org/wiki/Comet_\(programming\)) ^| [^Push ^technology](https://en.wikipedia.org/wiki/Push_technology) ^| [^JavaScript](https://en.wikipedia.org/wiki/JavaScript) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ckecg4a) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ckecg4a)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; . Any thoughts on how this works? http://builtwith.com/laracasts.com It seems to recognise Laravel
Still doesn't mean it should hold the same bug report standards as a project with numerous people helping take care of them. So all projects should be run exactly the same regardless of maintainers? That sounds like a great way to end up with crap everywhere.
I know it is not part of your two options, but maybe give CakePHP 3 a try? If you are looking for something new to learn it is definitely worth the time. The ORM is pretty advanced and you will find it similar to laravel in many aspects, while still flexible and well structured. It also has some pretty unique features that make it a joy to work with when doing rapid application development
The short echo tag no longer requires short open tags to be enabled as of 5.4!
I wasn't even aware that ++$i was a thing. I guess you learn something new every day. 
&lt;? is too widely used I'd assume.
Granted. But my response was to the options "troll" or "serious".
Wordpress. Then put a route into /wp-admin that returns "Invalid Password. Please try again."
You won't win this argument. The pros will get dismissed. The cons will get blown out of proportion. I've seen it before and I'll see it again. Oh... also... if at all possible, quit and work somewhere else. You need to be always learning new skills, and someone's shitbox "framework" is a career dead end.
Not really. I think it's 100% clear. The first time I saw += I took just a second to puzzle it out. The first time I saw ++, I had to look it up.
Don't tell the Node crowd about that. 
Oh, that's good. But, I'd also really rather not give WP anymore stats of any kind...
Not in all cases is a popular framework the best choice. Sometimes systems are so complex that you do not want to get stuck in a framework (old version) that broke backwards compatibility in newer versions. Or optimization is key. Or the system grows so large that a generic framework makes no more sense (Twitter, Facebook etc.). All that said and done, its good to use a framework, but sometimes better not to. This is purely my opinion, if you think differently don't flame me for it.
Calling bloatware is pretty lame. There's a time and a place for it, just as there's a time and a place for straight up SQL.
We use redis for alot of things, including the ones you mentioned, but Redis doesn't give us the same safety as MySQL does for keeping data forever. One `redis-cli flushdb` and we're done. Things like comments still has to be kept in a database, and Redis can simply cache the `Comments::popular(10)`'s response. I'm pretty sure there are better alternatives (such as Hadoop) which is reliable and does big data analysis much better than a KV storage application.
Ah yes, I just realized that I read past the part where you mention Redis in your original post :) Yeah, that's definitely an issue with Redis. They say it can be used as a permanent data store with its backups, but it definitely shouldn't be trusted as a primary data store. I wasn't sure how volatile your statistics data was. The way we use Redis, it's kind of a "don't care if it's lost forever" type of thing.
Tried this to no avail
;-) 
We have several, admittedly each are pretty simple, and we don't have any particular issues. The only ones I've encountered were 100% my fault, by not cleaning up data. Any language will have that particular issue. Out of curiosity what kind of issues did you encounter... also how long ago was it that you were doing these?
Nothing particular, they are just the basic socket API.
&gt; &lt;script language=php&gt; echo "foo" %&gt; ... * *twitch* *
It's the kind of godawful syntax only a C++ programmer could love.
To be fair, it's unlikely those memory leaks were PHP's fault. Not that you are bad or anything, memory leaks are a nightmare in anything that complex. I used to work on a ROM\ROT mud in C back in the day and man did I make a mess of it. PHP itself did have massive internal memory issues in the past, but as far as I know they have been cleaned up in all but a few edge cases you are unlikely to encounter.
I'm going for satire on this one.
While I think there's a good chance you're right, I did end up migrating to python and have not had any similar issues. I think it's just a matter of language design when considering how easy/hard it is to leak memory.
Hmm so there seems to be something regarding silex not understanding that we're in a subdirectory **on windows**, this htaccess works fine on my linux web server &lt;IfModule mod_rewrite.c&gt; Options -MultiViews RewriteEngine On RewriteBase /rphp/ RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^ index.php [L] &lt;/IfModule&gt; I just created a VH on my local and will continue to do that from now on to avoid this on windows.
Cross post from r/programming.
I wish I could give you more upvotes
No. It's an open source project that doesn't allow enough collaboration so it will never reach it's full potential (it's stupid to assume that one person knows better than the group, like any team). I brought up Symfony to bring up this point. Not all projects should be run the same but laravel now **has no issue tracker** unless you're capable of writing a test. I'm pretty sure *that's* how you end up with crap.
You're going to have a difficult time convincing your boss and other developers to switch frameworks because of potential security vulnerabilities, when you haven't thoroughly investigated and audited the framework for those security problems. Telling your boss you have a hunch that the framework might be vulnerable is not a good argument, and that argument will get shot down every time. Do your homework and give your boss a list of the security issues you found and proved were vulnerable. While you're at it give him a list of reasons the custom framework is wasting developer time and resources. Resources that could otherwise be used to build new features. Really, you can't get mad or frustrated because you've failed to sell your co-workers on your ideas. Improve your ideas and your presentation or risk not being taken seriously.
What's up btw! Didn't see the first part.
You didn't mention actual volume of statistics being stored. How many rows do you have in MySql now? 1) I would break your stats table out into two separate tables and add a new table for each object type you want to track. I.e. article_stats and widget_stats. When you want to track a new object type, add a table. 2) Store summary data in Redis and increment counters as you add in the row of tracking data. I.e. each API request now performs two (or more) operations: * Inserts a row into MySql * Increments a Redis key holding summary data. Redis key example: article_impressions:{article_id} * Increments additional summary counters as needed 3) Define redundant methods to search for Redis keys on request and if it can't find one, calculate it from the MySql data and create it.
The alternative syntax is, in my opinion, the way you should write PHP if you mix it with HTML in PHP template files.
&gt; CakePHP Hm, it seems to be trending along both of these frameworks I mentioned: http://www.google.com/trends/explore#q=symfony%2C%20laravel%2C%20cakephp I'll give it a look, thanks.
Can you show me template code that doesn't lend itself to this style instead?: &lt;ul&gt; &lt;? foreach ($values as $value) { ?&gt; &lt;li&gt;&lt;?= $value ?&gt;&lt;/li&gt; &lt;? } ?&gt; &lt;/ul&gt; With syntax highlighting this is all very readable for me...
Check out [Saltstack](http://www.saltstack.com/community) for provisioning. It's a lot nicer to work with than Puppet or Chef put together.
How is "someone's shitbox framework" any more of a career dead-end than any other framework? Unless your career is "Laravel Developer" or similar *rolls eyes*. The only career killer is not learning. And using someone's homebrew framework does not prevent you from learning implicitly.
We use Symfony2 exclusively at my company, so we've built and released our own Vagrant .box file specifically for this. Welcome to use it here: https://github.com/brightmarch/vagrant-box Unfortunately we don't use Chef/Puppet/Ansible/etc, but the .box file is already built. You'll be up and running in seconds. Looking forward to learning Chef/Puppet/Ansible from docs like these to work off of. Also, if you're using PHP 5.4+ (you should be), use the built in PHP web server, it's so much easier than mucking around with Apache/nginx. Symfony2 even has a command in the default console for it.
Why should it be removed?
Particularly focus on the have builtin protection against these security issues that good frameworks have. TWIG's automatic html escaping, using binds with SQL etc etc... In the end I still think your boss will only want to reimplement these things into his framework... IMO What the OP is not understanding is that a private framework creates some power for the framework's core developers and usually that's why they keep existing over time.
Very nice box, and I like the idea of using the built in PHP server. I will be looking into that shortly.
Good. I hated those. ASP tags were for "user-friendly-ness" for people moving from ASP to PHP, and an attempt to add uniformity between the two popular languages (of that time). However, people were so anti-asp, they were just anti-asp anything -- &lt;%. Thus, &lt;% never caught on. &lt;script tag was just a fad. For a short period in time, other languages could be used, VBASIC being a key one, in &lt;script tags. The idea has merit, but eventually just became reserved for JS (although, I think there may be other languages that support it still).
Have you looked into [JSON Schema](http://json-schema.org/)? It seems to be close to the problem you're trying to solve.
Yeah, It's something similar. Thank you so much, I didn't know about JSON Schema. 
Thanks! Yeah the built in PHP server is nice. What we do: 1) Development on local machine using Vagrant and built in server. 2) Promote to dev/QA for testing (mirrors prod). 3) Promote to staging (mirrors prod). 4) Promote to production (full Nginx).
Try throwing in a couple of `if` statements, then scale it all by a factor 10.
I've used it in the past to do front-end validation using backend model definitions for forms, it works really well.
No problem! Make sure you visit the documentation page for version 3.0 http://book.cakephp.org/3.0/en/index.html
Thanks mate!
&gt; Because with this method you still have to write all of the glue and if anyone else wants to help you work then they don't have previous knowledge of how it works. Also documentation is spread out and there isn't a community surrounding it. Exactly! 
Yes please!
Won't argue that python is going to be a better environment. At the very least, a MUCH more mature ecosystem for that sort of thing.
Do you know any good examples of Vagrant box builds using Salt? I use Ansible mainly but I've heard good things about Salt.
Maybe make a table with "entity type" or something like that? So instead of "article_id" and "widget_id" you'll have "entity_id" and "entity_type"? Then store entity types. You can make another table with types this way, adding possibility to track more things.
The first one is beautiful, the second one.......pfff
They have some good examples in their formula repositories on github: https://github.com/saltstack-formulas Also, in their main Github: https://github.com/saltstack/salty-vagrant I have been working on getting a full LAMP stack working with it. It's not *fully* working but it does work. Mainly, I have been trouble getting VMware provisioning, actually. My repo: https://github.com/haydenk/saltstack-lamp-vagrant
Yes. The presentation was done by Infostrada Sports (http://www.infostradasports.com/) at Laracon EU and we are doing a case study for the website, so you can read that when it is up.
Laravel makes writing clean, de-coupled code much, much easier than Symfony does.
NBC, Fox Sports, Irish National Airlines, US Government, City of Chicago, APIs for the Olypmics, MTV... do you want me to keep going? There are several I can't name.
Laravel uses 27 community packages from the PHP world, more than any other framework (by far).
&gt; Just that for most CRUD websites a framework will get you up-and-running a lot faster. Wouldn't CMS like Drupal get you even more rapidly going in such scenario, and not to mention WP at all ;) I mean if you are starting to develop a web app, then I see more benefits from using precisely only the components you need than using a whole framework.
List is much larger for zend and symfony... i'd think. I'd also assume that the list you have provided isn't 100% legit/fair, as the entire US govt isnt using Laravel, along with the others you posted.
That's cool! ) Taylor, that's a nice list. But don't you think, that there would be much more trust into your product if you have live bugtracker? Let's say there is a company for 50-100 developers, and they consider choosing framework. Will they prefer Laravel, maintained by one man and with no sign of current and potential issues? What will they do if one day Taylor will drop everything and, let's say, move to Tibet for meditaition practices? Instead of enlarging core team, you make it even smaller. Security bugs are even sent to your *personal* email! I don't know any open-source project driven in that way. I can't understand why don't you give more trust to community and make Laravel more community driven framework, like Rails did one day. 
not what he meant i think....
wat. That is definitely a personal opinion. I have ZERO problem writing decoupled code with symfony. 
You can simply use pre-made Puppet modules to eliminate most of the work you've done here, and make it more readable.
And Rails is quickly becoming an object of derision for poor code quality and general craptitude. Again, the failing unit tests **are** the issues. Other than that, I literally posted office hours in the contribution guide, where you can personally talk to the creator of the framework. We also have several other permanent, searchable discussion forums where issues can be discussed. Anyone can link me to one of them at any time for my comment. People can discuss an issue there, come up with a PR, or, heck, even just link me to it and ask me to fix it. It's not that big of a deal. Beyond that, someone starting a Laravel Premium Support business sounds like a very profitable venture (serious - someone should do it).
Are there any websites like puphpet for ansible? (/u/jtreminio not that i'm looking to switch, im just curious.)
What do you want me to say? Person challenged anyone to name a single world known company that uses Laravel. I name a handful. Done.
Didn't need to say anything. Just adding some insight/counterpoints to your response.
We use elasticsearch for analytics. Each day is a different index, like `analytics-20140101`. You can do multi-indices aggregates and histograms, and the ES syntax is very powerful. Every x days we close unused indices to free up memory. Since ES is JSON and REST based, it works pretty nice. Let me know if you need more details. 
Can you show me code where alternative syntax solves the indent problem? I indent PHP and HTML independently and it makes it extremely to ignore lines with 2+ indent difference, if the &lt; vs. &lt;? isn't enough. I also use a framework that allows me to throw out all the nested *if* blocks used as guard code and collapse an object query to a single line, if removing presentation logic from the view isn't enough. I didn't realize simply asking about this would get me downvotes... I guess y'all are scared they're coming for you next.
That's a good idea, we'll add that. All of our projects has a `build-dev` script that does that for us every time a dev starts a project. Here's an open source Symfony project that we did - https://github.com/brightmarch/picto/blob/master/build-dev that includes that. But we'll get it added to the box. 
Thanks for the feedback!
Seems like that would be good for unit testing APIs
&gt; Can you show me code where alternative syntax solves the indent problem? It doesn't solve the problem. But it does help because you can match the control structures using something else other than indenting. With braces indenting is your only clue. &gt; I didn't realize simply asking about this would get me downvotes If that was an honest question that you should not get downvotes, but it sounded more like an opinion couched as a question.
&gt; It's a lot nicer to work with than Puppet or Chef put together. I know quite a few people that'd say otherwise. This is a preference thing and your environment could also sway your opinion. Let's not make configuration managers another "my language is better than yours" type of argument. EDIT: Wait, and you're new at this? How do you feel qualified to even say such a statement if the most you've done with Salt is barely get a LAMP stack up and running?
Sounds like you have the same hosting I do. No matter the permissions I could always access my subdomains through mydomain.com/his_folder. If you contact support, they can set up a fake domain to serve as your primary for free. I just gave them a random string of characters. That way your main (fake) domain will point to public_html. Then they will add your 'main' domain and your friends as 'add on' domains. Since no valid domain will point to public_html as the webroot, there's no way to access one domain from the other. Hope that makes sense. Let me know if I need to clarify anything. EDIT: sorry, I think I solve a different issue. What I was referring to is anyone can access his domain my going to you.com/his.domain.com. I'm not sure if you can limit a PHP script from reading the directory with different user access. And I'm sure the same apache is running your php and his. 
I thought it had already been deprecated, but I guess not. This kinda stuff always seemed so stupid, since it can be turned off you shouldn't ever use it.
Nope - don't agree with that. For writing PHP style template code, for me this is the most readable form.
- Having shorttags (&lt;?) enabled can cause conflicts with the xml declatation, which starts with &lt;?xml - Up to PHP 5.3 using &lt;? could cause a security issue if short_open_tag is disabled later on.
That's hardly a reason not to enable it. Who writes xml declarations manually anyway? (XHTML is dead, so that's no excuse.) And if you have to, there are simple workarounds. Disabling short tags for such a tiny issue is quite an overreaction.
I'd disagree with using the PHP web server. You'll soon discover that the internal server only handles one request at a time, making for some really weird problems, or masking issues that occur with asynchronous stuff like multiple AJAX calls.
&gt; But you do need to work on contemporary and well designed applications, or your skills become... legacy. Those two things are mostly unrelated. Falling into a rut, writing bad code, not keeping up with the industry, not learning new things, not keeping yourself challenged and engaged... these are all things that will erode your skills (and career) over time. Working on a legacy application is not one of those things. Plenty of great developers make awesome livings working on legacy applications, and stay on top of their game (look no further than core Wordpress devs, for example - all *excellent* devs who work tirelessly on a horrible codebase). Working on a legacy application does not implicitly mean that you aren't writing contemporary, well-designed code day-to-day either.
Specifically: https://github.com/justinrainbow/json-schema
True. However most places with mentality like op's employer are not places that promote new technology and growth.
Might want to proofread your readme
Rsync does have a 2 to 3 second delay and it sucks. Also try getting that to work in a place where you have developers running every os. It is not fun.
Yup! http://phansible.com/ http://getprotobox.com/
Yeah, something along those lines
Updated: http://pastebin.com/VCJjcrEP
Good old momba.
That's not necessarily true. Professional development is about *process* more so than specific technology, but the technology you work with can be an anti-process. Modern PHP process involves using composer, autoloading, IoC containers, testing, continuous integration, and even automated code review/correction. If you have a shitbox framework or legacy code, you might not be able to do any of those things, and thus you won't be learning modern development practices, or even good software design. Even if you want to learn more or apply what you do know, the framework might not accept it. So even if you are a "Laravel Developer", that's not stopping you from using framework-agnostic software design to make your application SOLID. Using some questionably designed framework however, might get in your way. One time I tried using composer's autoloader in a cake 2.1 project, and quickly found that it caused a conflict with one of Cake's proprietary class loading solutions. I had to abandon using an autoloader for fear that it would cause unknown conflicts in random obscure features of the site. It's almost impossible to write unit tests for everything on the site because of the extensively abused static classes and crazy inheritance trees. Can't really write integration/acceptance tests because many features are extremely database intensive and require either appropriate test data in place, or take several minutes to run, and state changes would need to be reverted. That project is a bit of a nightmare, so I'm thankful that it's not the only project I get to work on, else I would be trapped in legacy code hell with zero time allocations (and zero budget from the client) to modernize it. So yeah, shitty frameworks can trap you and prevent you from keeping up with modern development standards/processes/practices. Even new language constructs can pass you by if your stuck in the sewers.
Have you considered graphite with statsD?
Yes, you can do that too. You can also write your web app entirely in assembler. The point of the extended syntax is to made it easier to read and write. It does not perform any function that can not be done in another way. It's simply a *better* way. I mean, are you proposing to get rid of all string manipulation functions in PHP too? After all you can write those yourself without any problem.
Not to mention that cookies, ssl, virtual host rules, opcache, etc, etc, etc are all critical components of how a system will behave -- not having these elements in your dev machines *will* bite you later on. And "mucking around with apache"? Really?
I will have an answer for all of you clowns tomorrow.
I work on a rather large PHP site -- and when we added websocketing functonality we picked Node+socket.io. In my opinion, the php landscape is woefully immature in this area. If you MUST use php + sockets, zeromq is a really good idea. It takes sockets and makes them a bit simpler to execute in practice than raw sockets php offers (which are just a facade for C sockets, really).
Both NetBeans and PHPStorm can flag it as an error (but do nothing about it). If you use Vim or Emacs you can probably write an on-save script for PHP files that removes everything superfluous at the end. I don't think PHP itself needs this. It would introduce a lot of complexity, if it could even work at all (multiple legitimate closing tags in templates), for something that isn't *technically* a bug, only a huge inconvenience.
&gt;Oh... also... if at all possible, quit and work somewhere else. You need to be always learning new skills, and someone's shitbox "framework" is a career dead end. This shitty kind of advice needs to stop. If you have problems with your company's stack, work on helping them change it. They're not listening to you? That probably just means they don't trust you. YET. Prove yourself, make incremental changes, show them how things can be improved. Help them, don't spit on their work. Their code has been running long enough to bring money to the business, and also hire your whiney self-important ass. Dead end? Then pick up the shovel and start digging a way out with the team. What, you're too much of a rockstar to touch "legacy" code? Pffft.
Alan Storm is a fucking boss. I can't tell how many times I've had to reference something this man has written with regard to Magento. He does good work. He always explains things very well, and in a very practical manner.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
We are trying to list out available eBooks for php beginners and expert for free download. We will also committing to update time to time in future.
Hello? Context anybody? Mom? 
Not sure introducing a new term (like "Laravel Objects") is the most helpful thing to do. These are normal PHP classes, resolved by normal PHP reflection. "Class objects/instances created by the [IoC] Container" perhaps...
Unless you can provide sources and license information, these appear to be illegal copies. Some of them are also hilariously old, while others should never have been published in the first place (ie. anything with "PHP6" in the title) and will likely cause more harm than good.
I have purchased a few of these books, and to my knowledge they are not free to download. Looks like illegal copies.
Would be funny if someone put PHP6 as experience on his resume.
Regardless of the new terminology he introduces, what he explains, he does really well. There are many tutorials on *how* to do stuff, but this author is very good at explaining *why*, so you really get to understand the whole approach that has been taken. It's a great foundation to build on. 
illegal
Here's a book you have for download, which actually needs to be brought: http://www.apress.com/9781430233183 Your site is hosting copyrighted content without permission and this post should be removed.
Fantastic reply! I took a screenshot, so in the future I can remind everyone how exactly you view the users of your framework. I mean, "clowns"? Seriously? This is completely unprofessional and makes you sound like an angry 15 year old...
Interested to hear more. I've been using it since just about when it came out, with large complex web apps (with multiple AJAX calls at the same time) and never run into an issue. What issues are you running into? Are they Symfony related?
This is just the intro to a series he is going to write later, which will include all the magic that laravel does internally. Including the dependency resolution. He has already written a great deal in magento internals which is one of the most heavily engineered platforms (over engineered is perhaps correct here) in PHP, he will definitely write a thorough set of articles on laravel internals
Same here. To aggregate statistical data Elasticsearch is very nice, if a bit complex to use sometimes (I'm still not sure when I have to use a "filtered" key instead of a "filter" key, so it's trial and error). Put [Kibana](http://www.elasticsearch.org/overview/kibana/) on top of it and you can visualize even big data very nicely.
no matter what you do, you need PSR compliance, use Laravel or Symfony, and be sure you use the term "facade" correctly.
I recently setup a template project of pretty much exactly this! https://github.com/ptlis/symfony-vagrant-template It might not be 100% what you need (i've added some default packages that I find end up going into most of my projects) but it's a great starting point. One thing that's really worth noting is that Vagrant uses nfs to share your environment and it's *very slow* - particularly when in dev mode with many calls to fwrite for logging/caching. To solve this in my template project I configured Symfony to write log &amp; cache files to /dev/shm shared memory &amp; this results in a *huge* gain in performance. I also use ansible rather than puppet - it's simply a cleaner &amp; simpler way of configuring this stuff.
I've used it before to unit test the generated JSON document. But people were too lazy to update the schema. :')
That's a great library. It even has support for resolving references to external schemas by URI.
Looks very nice!
A nice looking project...I'm glad that most things involving changing the data itself (like the "nullify" changing an empty string to null) is something that has to be called and not just assumed. I wonder about adding other scrubbers for types might be useful. For example, if you're given a string of "1" and you need 1 (integer). Obviously it'd be as easy as just casting it with (integer)$inputString but if you have a whole set of them in an array, it might be handy. Also, in your boolean scrubber, you should probably also have the actual boolean value false in that $falses array. Otherwise what happens if they give it an actual boolean value. 
It lets XSS through (or did I miss something)? What character encodings are supported?
I generate the schema from the model definition defined from the backend, so devs don't need to modify it
You give me a smart ass response you will get one in return. Get over it.
PHPUnit? If so, care to explain how?
Thank you for the feedback. I don't think I'd expect the regular Laravel community to adopt the idea of a "Laravel Object" -- but as the series goes on I plan on building on the concept. There's a Laravel object, then there's a bound laravel object, etc. To an experienced developer like you hearing the phrase "Class objects created by an inversion of control pattern" is enough to understand what's going on, but to a more novice PHP developer that's a confusing concept, and over the article series I want to tease out the details how how everything is implemented so that a novice developer can 1. Understand what's going on in Laravel 2. Become less of a novice and recognize the patterns in other frameworks Sometimes that sort of thing requires inventing concepts like a Laravel Object. 
I don't know much about you, though I hear good things about your ability to teach. Don't don't think I'm criticising that. Laravel has a bit of a rep for "misappropriating" terms. "Object" is not a term that belongs to Laravel and I am concerned that teaching people, who you refer to as "novice PHP developer", the term "Laravel Object" will make them think that Laravel is treating these objects differently to how these developers would with say..."regular PHP". You don't have to says it like "Class objects/instances created by the [IoC] Container" but you don't have to make it sound like using Laravel in any way affects what they classes do or how they are used. The Container (for the purposes of your article) is no more special than any other service locator. "Service locator" isn't a difficult term to teach either; "store/get objects, by name, from a common store". Build on that and new PHP developers are more likely to know what's going on when another framework's documentation refers to service location... Because no other framework/tutorials are going to refer to "Laravel Objects".
whats the use case for: " Null If Repeated If a string is just a repeated character ('1111111' or 'aaaaaaaaa') and has a length greater than two, null it out:" ?
Right. To give some context to why I even made this in the first place, we were doing a large-ish migration of some pretty terrible data from one database to another, and we were cleaning it up along the way. This particular cleaner came from lazy users who would just fill fields with long strings of repeated characters, which we wanted to null out. Not sure if it's applicable to anyone else, just figured I'd include it.
Good point, I think "sanitizer" might be too strong a word, as XSS prevention isn't so much the goal here. It's more about cleaning and translating data flexibly. My comment below describes why I developed this in the first place (http://www.reddit.com/r/PHP/comments/2g3k5k/mr_clean_an_extendible_php_sanitizer_for_cleaning/ckfdgnh)
You should definitely go for timestamps. Why would you spend time learning a new language, your current stack (PHP/JavaScript) is perfectly fine. Go with something you're comfortable with and focus on making an application instead of the framework. Make some notes on functionality you want, break it down to pieces and you're on the right foot. 
Question: how does it let XSS through? Just curious
I like Silex too, the advantage of using the Symfony framework though is access to a lot of useful bundles.
1 Go to http://www.phparch.com/ 2 Add any magazine issue to your cart. 3 Use 3VJR-BZJY-9MGK when you checkout 
The first one isn't that obvious what the closing braces are for.
PHP newbie here. I created something like this: (app/libraries/mr-clean/Sanitize.php) &lt;?php namespace MrClean\Scrubber; class Sanitize extends BaseScrubber { public function scrub() { return filter_var(trim($this-&gt;value), FILTER_SANITIZE_STRING, FILTER_FLAG_NO_ENCODE_QUOTES); } } and my composer.json: "autoload": { "classmap": [ "app/libraries", ... It works but is this the correct way? Let's say you'll use this class, how'd you extend it?
+1 it's very important to understand Laravel's facade pattern
I assume you mean that testing an API would be a functional test, not a unit test.
Yes
My response was based on your previous behaviour on Github, which many people can attest to. What was yours based on?
&gt; using our internal framework &gt; Able to learn complex frameworks and procedures with ease &gt; Actively collaborate with foreign colleagues and partners I already have a clear picture of what kind of environment you're walking into. Good luck.
Well, this might help you. Imagine you were sitting on top of a frying pan, now you'll jump onto the fire. 
Why exclude Sublime Text? Its only missing intelli sence
Just imagine being forced, to waste your time in learning something crapy. 
Thanks man, something I do NOT know is "socket programming", I started reading up on this in PHP last night...do you think this is something I will need for the game? I was reading some about rts browser games and how actions and such are sent to a handler through sockets..it kind of sounded like BS to me but at the same time I don't know much about sockets so figured I would ask here to double check.
I just started setting up with linode. I see the walkthroughs to get me through most of it. Anything special for setting up Laravel and my app?
I was mostly joking but on the chance I was close to the mark. The trick is when they start been unreasonable (and they might) just ignore it, do your work (and your hours) and go home. Don't try to keep up with insane demands it's simply not worth it, as a developer you have a skillset that is in demand so the amount of shit you have to eat with a smile on your face is very small ;).
Yes, I went ahead and went through all those questions, as well as a lot more and decided on Linode. We like the idea of the management on our side so we can understand the ins and outs. We have the ability to work on our enviro until january as we build the app locally and deploy and mess with the linode piece. Thanks for your input.
I.e. &lt;div onmouseover="XSS"&gt;
It seems I'll use app/libraries/mr-clean/Scrubber/Sanitize.php
The code is pretty clean! Injecting the available scrubbers instead of lazy loading might give a slightly different perspective, e.g removing $scrubbers from the Sanitizer class. 
Currently, there is no way to add options to scrubbers, we need to create new classes entirely or extend existing. Examples: * Allow a different of tags for Html. * Change falsey values for Boolean. * Change normalized format for Phone. * Change the removed attributes for StripCssAttributes. * Create factory scrubbers like a chain scrubber that aliases a set of scrubbers. This implies that `MrClean::register` would be able to take an initialized object. It also means that `MrClean::register` would need to take an optional alias as parameter since the same scrubber could be instantiated more than once.
I personally don't get the purpose of the article. First of all, "Laravel Objects". Why would someone call a PHP class that is registered in Laravel's DIC a "Laravel Object"? Secondly, the article says in the beginning it's going to open curtains on Laravel insides. But instead I've seen some var_dump's all over the article, which tries to explain how to register a class to DIC and how to obtain it from there. Plus a listener at the end, which makes this var_dump story a bit Laravel style. I didn't see anything from insides. I understood that author misused naming of common terms. And now I know, how I SHOULD NOT use Laravel. No offence, but article quality has tons of space for improvements. Good luck with future articles, author!
Some advice on making a game. Worked for EA as a designer for a little while, and also built a couple of games in Unity. What I learned is that 75% of the project is the art &amp; visual effects. The programming is the easy part, it's the art that's not. Be prepared to get through the programming fairly quickly, even with a small team, and then get hamstrung by art assets.
1) then leave reddit. Its a fair assumption to make, as they have both been around longer, and are known for being enterprise solutions. 2) I care....? As im sure others do too. Just because you don't doesn't mean you can try and discount my opinion. &gt; It is very high quality and well respected. Talk about absolute conjecture.
And much more. Sublime with plugins is a solid editor, but by all means no real subsitude for a proper IDE. 
Noted. Thanks man.
I have been trying to get into PHPStorm But its like super slow, nothing beats Sublime Text in speed
&gt;Your going to get blamed for the shit the indians wrote even if you pointed out there was no spec and they where crap on the last job, they cost a third of what you do and do about a 30th of the work but the bottom line is the bottom line. Hey I write decent stuff...but OP is gonna get fried.
Try a different country code http://ca1.php.net/ http://ca2.php.net/ http://ca3.php.net/ http://us1.php.net/ http://us2.php.net/ http://us3.php.net/
Wouldn't this fix it? $cleaner-&gt;post(['htmlentities']);
Not all PRs are accepted. That's how it works. Some are, some aren't unfortunately.
I was wondering.. Is it.. Legal, for you to call your product "Mr. Clean"? Maybe you should rename it to *SirClean*. *DoctorClean*?
IANAL, but it's my understanding that generally such trademarks only exist within the same industry. If you made another detergent product and called it Mr. Clean, then you'd run into problems, but you could make a car and call that model Mr. Clean and nobody would care.
Looks like it's back now (and, as adragons said, we have [mirrors](http://php.net/mirrors)), but the best way to report these sorts of issues is by [opening a bug](https://bugs.php.net/report.php) in the "PHP.net Systems Operation problem" package — that'll get to the right people if it's something that isn't just a transient problem.
A good ide will show you what is what.....so...
this multi demential array is insane! :D
If typing speed is your problem when coding, then you are solving the wrong problem ;-)
After more than 10 years, i hardly remember any scenario where this was an issue. I avoid endif / endwhile like hell, and i try to change it everywhere i see it. Seriously, my IDE can parse the code perfectly well, highlighting a brace will show me what opened it, so i'm never lost. 
In the words of the great TLC, "I don't want no scrubs" https://www.youtube.com/watch?v=FrLequ6dUdM
He never said typing speed was where PHPStorm was being slow...
How about, you guys run Zend how you please and Taylor can run Laravel how he pleases? each are clearly two different scenarios to support, regardless of the reasons of it being that way. Considering you are on the Zend team, I doubt you really use Laravel much in production. So it seems like to me you are only putting down the management of Laravel to make your own thing seem better.
Agreed, I thought about this as well. Currently there isn't a way to do it, but I'd like to add this in the near future.
It looks good, my primary suggestion would be to place the class in a different namespace to avoid any possible clashing.
worksforme
Interesting... I might play with that, thanks!
For my money, I'd say /u/ocramius is engaging in a pretty healthy discussion of the pros and cons of this approach. The objections seem legit so far and so do Taylor's answers. If the back and forth continues, hopefully it will remain this productive!
I'm sorry, I'm not following. I'm fairly new to security breaches prevention in PHP, so excuse me, but I'm really interested in learning. Wouldn't $userSubmittedData = htmlspecialchars($userSubmittedData, ENT_QUOTES, 'UTF-8'); prevent XSS on that particular field? What modification does it need to become "context aware"?
controversy is good for SEO
Having worked a proprietary framework written for PHP 5.2, I've seen some pretty demented arrays.
meh. whatever. Personally, I prefer it to be descriptive.
All the same, the end result ll be a reduction in bug reports...which is bad for the users as a whole and easy on the maintainers.... Why not just give more priority to issues that include a test. people who care about getting it fixed asap can include the test...and if they dont they can still report the issue...
... or to give more weight to the issues that *do* have failing tests... but wiping out the ability to file issues altogether seems harsh.
I hop into discussions about any framework, I don't care which one. If you want to tag me green or orange because of zf/doctrine, then feel free to do so, but I'm in no way here to make advertisement for myself or the products of my volunteering. I'm only truly concerned about PHP's code/ecosystem and its very scary growth and health, especially when this compromises the quality of our work, directly or indirectly. There are enough Laravel coders leaking into my areas of competence, and many developers from my communities leaking into Laravel's, so I think I have my right to state my opinion here, mainly because I don't want to deal with coders sending me `"here's my app for reproducing the problem"` the next time I have a bug report. Also an errata: Zend is a company, I am only part of the ZendFramework community, which has nothing to do with Zend, so please stop calling it "Zend" and "Zend Team".
Super slow to what? Launch? You might loose 5 seconds per day with PhpStorm starting, but you'll save much much more with all the tools and features.
That's fair, but in my experience when reading some issues you just go "Oh yeah I see what that is". No need for test cases, or demos. Of course not all issues are that way, that's why sometimes project maintainers ask for test cases or reproducible steps. But sometimes a paragraph is all you need. And it's too bad to set the bar so high by default.
Looks great! Look forward to you developing this, I'm always in need of decent sanitizers.
&gt; All the same, the end result ll be a reduction in bug reports.. and a corresponding increase in their quality
I'm assuming you're American? I've only just 'learnt' this tonight, but Americans say 'learned' and the British (i.e. me in this case) say 'learnt'. I'm sorry it put you off, but it's not incorrect, just Ye Olde British English haha http://www.oxforddictionaries.com/words/learnt-vs-learned
And it's not a bad idea. The Symfony team is looking to do [something similar](https://github.com/symfony/symfony/issues/11494#issuecomment-55328841), and after them seeing this, I'm sure something relative is will arrive soon. I thought it was a bad idea when I first head of them removing GitHub issues, but Taylor made up for it 10x over with a fresh new approach to something people have been looking to solve for years.
I switched to PHPStorm from Sublime Text because they finally got multiple cursors functionality, and it's greatly increased productivity for me. When NetBeans supports it, too, I'll gladly give it a try.
A person can be learned(two syllables). Material was learnt. There also used to be the word "cookt" for the same situations. You seem like the type of person who (if they were English) would complain about the use of the word soccer, forgetting that England coined that term....
How do you do it?
Even if 'learnt' weren't a completely valid word in English, which it is (making your pedantry/hubris hilarious)... To extrapolate from a single misspelled word to poor documentation and communication skills!? I'm glad Hemingway's ghost is writing in between /** and **/ for you, but the rest of us just make do.
Its really slow on windows, i have not tried it on osx
From my own personal experience, I feel like I've found around 20 bugs in different projects until I go to write a tests for it.
You aren't terribly bright, are you?
&gt; The instantiator is able to create new instances of any class without using the constructor of the class itself When I think Doctrine, I think database ORM. While I know the Doctrine team shouldn't be relegated strictly to only ORM-related work, this library really seems odd to have landed within the Doctrine namespace.
You need specific escaping for the specific context the data is placed. See http://phpsecurity.readthedocs.org/en/latest/Cross-Site-Scripting-%28XSS%29.html
How do you account for different manifestation of the same bug. Even if I spend a half day creating a demonstration of a bug, it may end up being useless because it was caused by an already reported bug, or even a bug that has been fixed in a later issue. A simple bug report makes this a non issue from the point of the reporter. A maintainer can quickly identify this and can give feedback saying that, "hey this behavior is caused by an already reported bug, and that has been fixed in release xyz, please try that and let us know..".
I've submitted a laravel bug, proven its a bug, written a test case proving its a bug, wrote a fix and submitted a PR (upon request) but had it declined due to spacing. i'm not going willing to jump through *that* many hoops personally.
&gt; Mr. Clean is an extendible PHP cleaner that allows you to easily clean up strings, arrays, objects, and anything in between. The heck does "clean" mean? You might want to elaborate on that a bit. I eventually figured it out, but I'm still not sure how it's much different from `array_map('my_cleaning_func',$arr)`.
Fix the spacing and resubmit. Code standards and consistency with the project you are committing to matter. 
&gt; The instantiator is able to create new instances of any class without using the constructor of the class itself Isn't this about 2 or 3 lines of code with PHP's reflection classes? What does this do differently?
You need to be running the EAP. 8.0 official will be out in a few weeks I hear. You just alt+click, I believe, or press Alt+J if you have a selection already. No way to add cursors on every selected line though, yet (equivalent of Ctrl+Shift+L in Sublime).
I don't doubt it, but as someone who's not particularly familiar with Git or Github I don't want to fuck around for 3 hours for a 5 line change when the maintainer could have done it the way he liked in 2 minutes from the get go.
Soon to be mockery too
That's why liferaft was made. You don't need to know git or even how to fix the problem, Just how to replicate it. Liferaft does the rest. Also the beginner argument is a little contrived - how many actual problems are stumbled on and then fixed by neophytes with no understanding of git?
The creator of Lithium is not a single person. They are Nate, Gwoo, ... . They didnot sold the domain name, but was forced to loose it due to certain legal issues. Open-source projects are nice and make you Happy. But when there are commitments or some people relies on you for food and shelter you could not spend most of your time on the project for free is a sad truth. I heard from Nate that they will be releasing soon stable version. You can read the response from Nate http://www.reddit.com/r/PHP/comments/25nh9m/state_of_lithium/ .
It's still worth it though. Git and Github are pretty popular, and not going anywhere soon. After spending the 3 hours you will have learned a useful skill, and the next time it will take you only 2 minutes as well. 
With PHP &gt;= 5.4.0, is that library needed? (i.e. is reflection able to do it in every case?) From reading the code, it seems that the unserialize trick is used for internal classes (on which apparently the reflection method doesn't work?), is that right? (by the way: awesome!)
I'd be afraid to start a project using Laravel without facades though, because the documentation is AFAIK written using it. Example: [database](http://laravel.com/docs/database)
Who, me?! Why?
Yep, did exactly that for the duration of the World Cup, every time I saw the word 'soccer'. Guilty. As. Charged. 
Yeah I was pretty confused by that jump haha! 
only if there i only whitespace character behind them.
It's mainly a polyfill, aimed at fixing various regressions that appeared in PHP 5.4.29 and 5.5.13
Thanks for the heads up, you're probably right that it's due to inexperience. I just struggled to find any decent documentation on the best architectural practices. I'll do more research as I'm currently on a Laravel project. But if you have any links, it'd be much appreciated! 
To be fair, this is a failing of GitHub more than anything else. They put their shiny "Accept PR" button so front-and-center that they obscure the fact that you can actually pull the PR locally, fix any issues, and push it without problems. Because GH wants to make their UX all done in the browser so you never need to actually touch git commands, it has lead to a bad mentality among maintainers that the people submitting the PR should fix things so they just need to click a button and be done. Also, the code style has always been clearly described in the contributing.md file (now moved to the laravel site itself), which when you are creating an issue it does say "make sure you have read the &lt;link&gt;contributing&lt;/link&gt; docs" or whatever it says. So you were warned about the style ahead of time and you simply ignored. I wouldn't really be hurt over having a PR rejected because I ignored the quality standards setup by the maintainers if it is clearly stated.
provided you have oodles of RAM - i stopped using phpstorm on my 4gb mac after it kept gobbling up all my RAM (even after turning off nearly all the inspectors). now i just use textmate with the file browser view
I found around 40+ exploitable methods in less than 5 minutes
Yeah this is some scary code.
&gt; /js &gt; /js2 &gt; /css &gt; /css2 Enterprise level coding ;)
http://php.net/manual/en/function.finfo-file.php possibly? or http://php.net/manual/en/ref.fileinfo.php
^ this is true
Not you, the person to which he replied...
Please send it to admin@dcoin.me
+/u/dcointipbot 100 dcoin
Thanks for posting this. It sounds like you're heading in the right direction! Best of luck on your career.
 exec("/usr/bin/file /path/to/file", $output); Probably not what you're looking for, but hey, it would work, assuming file is in the same location on your system as it is on my CentOS box.
The day those tags are removed, is the day PHP becomes just that much better.
**A PHP Error was encountered** Severity: Notice Message: Trying to get property of non-object
There's too many to try to fix this.
From the docs: $finfo = finfo_open(FILEINFO_MIME_TYPE); // return mime type ala mimetype extension foreach (glob("*") as $filename) { echo finfo_file($finfo, $filename) . "\n"; } finfo_close($finfo);
The first thing that comes to mind with Doctrine is their ORM and DBAL components. However, I've seen their annotation and cache libraries used outside of their ORM/DBAL stuff, so I don't feel it's out of place.
Yes, the code is ugly, but in the Dcoin of no real vulnerability. If it is not, show please.
Honestly, there is a bunch of ways, but none of them are super reliable from my experience. First of all, [mime_content_type](http://us2.php.net/manual/en/function.mime-content-type.php) is deprecated, so don't use it. When a file is uploaded, the browser will pass the file type in the `$_FILES` array. However, you cannot trust this value, so don't validate with it. As already mentioned, [finfo_file](http://php.net/manual/en/function.finfo-file.php) is the recommended way, however, it doesn't always work right. This function relies on the [magic file](http://manpages.ubuntu.com/manpages/hardy/man5/magic.5.html) to be up-to-date on your web server. Further, I've come to understand that there are some known issues with it and MP3 files, even if you've properly set the magic database file correctly. As an alternative, you can run a system command on Linux based systems. $path = 'path/to/your/file'; $mime = exec('file -b --mime-type ' . $path); But now you've created a dependency on the operating system, so this isn't great either. I know some libraries, [like Guzzle](https://github.com/guzzle/http/blob/master/Mimetypes.php), don't even bother with these functions and simply determine the mime type based on the file extension. This works fine in certain situations, but certainly not for validation. So yeah, stick with finfo_file, and handle edge cases (like MP3's) manually when you run into them.
This is what I ended up using when I had the same problem, works rather well for me
Not taking into account the ugliness of the code (which is a big problem you should address), but: * [You're using globals](https://github.com/c-darwin/dcoin/blob/master/includes/class-mysql.php#L61) * Your webroot is at the top level of your project, allowing access to *all* files in your project * [You use raw `$_GET` values in your sql queries](https://github.com/c-darwin/dcoin/blob/master/ok.php#L24) I'm going to stop at these 3. For someone's personal project, I could not care less how bad your code is. For something that is supposed to be financial in nature, this code is a disgrace and it should come with a disclaimer: &gt; If you use this, you will probably lose any or all monetary investments you make My suggestion is to slap that disclaimer on your `README` and make it absolutely clear that this code should not be used by anyone for anything even remotely related to anything financial. Better yet, make the repo private and don't let anyone fall into the trap of using it.
Ahh yeah haha, my bad! 
Only remote-friendly, interesting positions are allowed on this sub. Your post fails the first requirement.
Node work, no real vulnerabilities. Do you agree? If not, please show holes on the node 62.109.16.183.
And how do you use it?
You don't seem to understand. There's no point in /u/jtremenio actively looking for and testing exploits for vulnerabilities in your code, because we already know it's insecure just by glancing at the code. You're not using secure, standard development standards so the code is inherently flawed.
Anyone who uses this deserves what they get.
Security isn't that simple. It's not always about finding working attacks, it's about fixing the flaws you can find so that they can't be chained into a possible attack later or used to enumerate info about your app. Regardless of whether you know how a flaw could be used, you have to fix it so it can't be used in some way you might not consider. (Even knowing config parameters can be useful to attackers.) Beyond that cryptocurrencies demand trust and no one will trust your security unless it seems like you're trying.
Mime type isn't reliable if you want to verify the file type. If you know the markers for each file type you want to test, for example PNG: http://www.fileformat.info/format/png/corion.htm Then you can use PHP unpack() to extract that info from the file itself and match it against the hex values. This way you'll know for sure the file has the right type even if for example a PNG file has a different extension. Here's a really simple example to do it: https://gist.github.com/feketegy/0cb1488f0320d1fa81d0 $png = [ 'format' =&gt; 'H32', 'marker' =&gt; '89504e470d0a1a0a0000000d49484452' ]; $bytes_to_read = strlen( $png['marker'] ) / 2; $fp = fopen('your-filename.png', 'r'); $data = fread($fp, $bytes_to_read); fclose($fp); $x = unpack( $png['format'], $data); $is_png = ( $x[1] == strtolower( $png['marker'] ) ) ? true : false; var_dump( $is_png ); 
4 months of usage with a few users does not prove that it's secure. It's not an interesting target yet, for one thing. Looking at the code does help prove security, however, and you've got multiple professionals here telling you that this code is not secure. It's not about the code being pretty (yet), it's about the use of deprecated/insecure language practices.
An alternative one-liner without using `call_user_func_array`: $result = array_reduce($arrays, 'array_merge', []);
Please try here - http://pool.democratic-coin.com/. http://pool.democratic-coin.com/tools/available_keys.php - keys. 62.109.16.183 works in single mode. pool.democratic-coin.com - pool mode. 62.109.16.183 - a node with 1 key. Which is just the owner. The master key is stored only by the owner. If you have a master key, it will be elevated privileges.
Nice. I'll add it to the article :)
I really like the PHP way of "it's running right now, there's nothing at all wrong" 100% safe until proven otherwise. 
- Document everything you do (Cover Your Ass) - Use version control (even if it just a git repo in your local working directory)
Don't be afraid to tell them you would have to look something up in the documentation.
Thank you for your feedback, it's appreciated. The article is a foundational building block for future articles that will go deeper into Laravel's internals. Step 1 is teaching developers how the `make` method works, what its responsibilities are, etc. Once this foundation is set we'll explain application containers, dependency injection, etc. As mentioned in the article, the techniques here aren't for day to day Laravel production, but more building blocks towards a deeper understanding of the system. It's meant for PHP developers who want to know how Laravel is built, not how to build applications with Laravel. 
This is quite possibly the worst code I've ever seen. 
Think about if you need to use mime type at all. Most likely not. Mime type is useful in case you want to interpret it with additional application on the client side, meanwhile most of projects are providing the files explicitly for visitor to download. In this case 'application/octet-stream' mime type is ok.
amazing.
Do I have to know PHP? 
Thank you for your feedback, it's appreciated. I decided to hold off on covering dependency injection until a later date. The main gist of this first series of articles is (in a roundabout way), explain Facades. In order to explain Facades, you need to explain service containers. In order to explain service containers, you need to explain binding. In order to explain binding, you need to explain `make`. Dependency injection, while interesting, is a distraction from all that.
Parser error: syntax error, unexpected T_PAAMAYIM_NEKUDOTAYIM in /usr/local/www/nginx-dist/tipb/eval.inc.php on line 37
&gt; You don't have to says it like "Class objects/instances created by the [IoC] Container" but you don't have to make it sound like using Laravel in any way affects what they classes do or how they are used. I get your point, and it's a fair one, but that's exactly the sort of thinking I want to soften a bit. In as much as Laravel, or **any** PHP framework can't do much to change anything the underlying PHP object implementation, these frameworks **do** have object systems, and an object created via these systems behaves differently than an object instantiated directly with the `new` keyword. This sort of concept has a long history in programming, and it's one of those concepts that can really change how you approach your programming and your work. 
Thank you for saying so, it's always nice to know my rambling has helped someone.
Thank you for saying so, it's good to hear you're still a developer after having the Magento gauntlet be one of your first gigs!
Thank you for your saying so. Sometimes I worry I'm typing mad rants in a cave by myself. It's good to know people find them useful. 
&gt; Code is not beautiful, but it works. You are utterly clueless. Go and find a different way to occupy your time.
looks almost like real world code
I know, but you literally tell people to go to it. If you said something like http://example.app or http://localhost:8080 it might be more clear. 
It doesn't matter if the objects are created with `Illuminate\Container` or `Aura\Di` or `Pimple\Container`. What you get out is exactly the same thing. Perhaps the dependencies were automatically created. Perhaps the object is shared. Makes no difference to the functionality or composition of the class. If I replace App with another class which extends `Container` and implements `HttpKernelInterface`, `TerminableInterface` and `ResponsePreparerInterface`; will the application behave any differently? If I create objects with this new container, are they still "Laravel Objects"? IoC doesn't change classes. It doesn't make them special, or specially make them. Calling them "Laravel Objects" implies that it does. &gt; object created via these systems behaves differently than an object instantiated directly with the new keyword No.
[It happens.](http://www.reddit.com/r/PHP/search?q=logo&amp;restrict_sr=on)
Php has autoloading for exactly this purpose. One autoloader class can scan specified areas for the necessary files and load them without any extra code. Take a look at http://php.net/manual/en/language.oop5.autoload.php for more info. 
The API is identical whether you're using Facades or not. Facades in laravel are just static proxies that forward static calls to the non-static methods of the actual classes they are proxying. DB::select() and $this-&gt;db-&gt;select() are identical. The static usage is just for brevity in keeping the examples short. This is the full facade class mapping for reference: http://laravel.com/docs/facades#facade-class-reference You can use those to do dependency injection or resolve instances out of the IoC.
hah yeah, the php.net page has a lot of easter eggs like, go to the page and just type: bork or press... up up down down left right b a enter or type rotate then press enter or type mirror then press enter or type I love php then press enter or type I hate php then press enter you can cycle different logos by typing logo and pressing enter 
You are not entitled to having your vulnerabilities showcased to you. You've already been told. Acting smug will get you nowhere.
If you're on a laravel project with a company, get the company to pay for a subscription to http://laracasts.com (or just pay for it yourself if you want to learn Laravel). You will become 85% proficient at Laravel in the space of a day by going through as many of the series as possible. 8 hours spent learning laravel will then save you 30 hours of doing things manually/the hard way later on.
 $user_id = intval(@$_GET['user_id']); Jesus.
&gt;or press... up up down down left right b a enter There's two left rights, so it's up up down down left right left right b a enter
I for one think we should all thank Taylor for always thinking outside of the box instead of subscribing to "this is the way everyone does it" mentality. That's how progress is made. 
Thank you. But I do not understand what this file /usr/local/www/nginx-dist/tipb/eval.inc.php on line 37.
No I'm pretty sure that's a real thing :/
+1 to /u/_ben_lowery's comment This is one way to bring DRY practices to pull requests and bug fixing. As a group of developers, **if we can prevent more than one of us from writing the same code someone else wrote, we should**. That is the core of the time savings open source projects afford us. To the real issue here: **we as developers shouldn't be so lazy**. If I use Laravel, for free, for my commercial purposes to put money in my bank account or those around me, then the least I can do is make it easier for the Laravel community as a whole to get a better product. I should not take for granted /u/utotwel's and other contributor's hours and hours of hard work on the framework over the past 3 years and into the future. If anyone put in hours of work to build something that I get to use for free to advance my business goals, I should be able to carve out some time - even 10 minutes a month - to contribute to the open source project as a whole. **I don't think we are talking hours and hours of my time - just literally a small contribution like 10 minutes a month** to forward the group's advancement as a whole.
Did.. Did this really just happen?
#[**Mammalian diving reflex**](https://en.wikipedia.org/wiki/Mammalian%20diving%20reflex): [](#sfw) --- &gt;The __mammalian diving reflex__ is a [reflex](https://en.wikipedia.org/wiki/Reflex) in [mammals](https://en.wikipedia.org/wiki/Mammal) which optimizes [respiration](https://en.wikipedia.org/wiki/Respiration_(physiology\)) to allow staying underwater for extended periods of time. It is exhibited strongly in [aquatic mammals](https://en.wikipedia.org/wiki/Aquatic_mammal) ([seals](https://en.wikipedia.org/wiki/Pinniped), [otters](https://en.wikipedia.org/wiki/Otter), [dolphins](https://en.wikipedia.org/wiki/Dolphin), etc.), but exists in weaker versions in other mammals, including [humans](https://en.wikipedia.org/wiki/Human), including babies up to 6 months old (see [Infant swimming](https://en.wikipedia.org/wiki/Infant_swimming)). [Diving birds](https://en.wikipedia.org/wiki/Diving_bird), such as [penguins](https://en.wikipedia.org/wiki/Penguin), have a similar diving reflex. Every animal's diving reflex is triggered specifically by cold water contacting the face – water that is warmer than 21 °C (70 °F) does not cause the reflex [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*], and neither does submersion of body parts other than the face [*[citation needed](https://en.wikipedia.org/wiki/Wikipedia:Citation_needed)*]. Children exhibit the reflex more dramatically than adults, and can thus potentially survive longer. This is for a variety of reasons, including higher surface area to volume (so they cool faster), and better recovery from oxygen deprivation. In a 2012 case, a 21 month old child inhaled cold water and was immersed for approximately 25 minutes, being pulled from the water with no breathing or heartbeat, and was revived in hospital after approximately 50 minutes without a heartbeat. He was warmed up slowly and brought out of a therapeutic [coma](https://en.wikipedia.org/wiki/Coma) after two days, making a full recovery. &gt;==== &gt;[**Image**](https://i.imgur.com/9KsL53X.jpg) [^(i)](https://commons.wikimedia.org/wiki/File:SpongeDiver.jpg) --- ^Interesting: [^Reflex](https://en.wikipedia.org/wiki/Reflex) ^| [^Cold ^shock ^response](https://en.wikipedia.org/wiki/Cold_shock_response) ^| [^Infant ^swimming](https://en.wikipedia.org/wiki/Infant_swimming) ^| [^Darren ^O'Donnell](https://en.wikipedia.org/wiki/Darren_O%27Donnell) 
I agree totally. It monthly fee is less than an hourly fee for general laravel developers. It will make your life much easier and pleasurable. I can't thank enough Jeffery for making that site. I have learned so much and i feel so much better writing much cleaner and extendible code just because of him. And this is not Laravel specific either, he made me a better software engineer overall. The best spent money ever.
http://i.imgur.com/zjObWRh.png
The issue isn't how do you use it, it's that it's visible. Put that shit behind the root. 
In this case, the config.ini does not make sense to hide.
because not everything /u/utotwel brings to the world is a godsend.
I've been looking into this, trying to figure out what's going on and I'm slowly realizing it's not a joke. It isn't, is it? That's scary.
I'm going to say this once and only once. **A security problem does not have to be proven, to exist.** If people point out issues with your code style, then **fix them**. Poor code style almost inevitably leads to vulnerabities, *even if they are not immediately obvious*. You are going to have to do some serious self-education on good code practices. Or you could ignore all of this, [and end up like these guys](http://arstechnica.com/security/2013/05/app-developer-calls-critic-fcken-little-know-it-all-site-goes-down/).
Heads up; if you enjoy clusterfucks like this, here's another PHP "altcoin" to look at: http://timekoin.org/ (Yes, it's similarly terrible.)
+/u/dcointipbot "; DROP TABLE transactions --
Query executed OK, 1387326 rows affected (53.902 s).
If I had a store of old logos for such a huge, widely known and frequently visited project like that, I would keep the old ones in rotation at something like a .01% display rate. 99.85% of the time you see the current logo, but a few fortunate visitors get to go "DAMN THAT IS UGLY, WTF."
No way, did you just use SQL injection to wipe out his transactions table? Wow. 
https://i.imgur.com/ZjlBOEZ.jpg
Thanks for your reply. The session just contains one variable - a string of perhaps 100 characters? I wish it wasn't working for anyone, but because it works for about 25% of the people, I don't know what to do.
Boooo
You can get the day (monday, tuesday, etc...) from the timestamp. Just create an array with days as keys and team arrays as value. You then can have the teams working on a certain day. Then match the hours/minute to the shifts with array fills or whatnot.
Never knew PHP.net had easter eggs, for those who are wanting a list view the common.js file [here](http://php.net/cached.php?t=1410183606&amp;f=/js/common.js)
I've had similar issues like this and the reason was internet explorer users with chrome frame installed. Our front end guy always added the following to the slice - which activates chrome frame: &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" &gt; It took forever to debug and figure this out, taking over screens, etc 
What timezone have you set? If you haven't set one, what is your Server's timezone?
No...
Hmmm. Might do this if I am getting nowhere. Thanks.
Hahaha the I hate php one brings you to python.org Great stuff!
It's ambitious, and they overshot their skill-level. They could learn, though. Don't discourage people who have ambition when you could give constructive criticism instead.
does browsing in incognito do this?
Could be! Can it do this?
Found this. http://stackoverflow.com/questions/8247842/session-data-lost-in-chrome-only
Idk what OS you are on, but if you are on os x or *nix, what do you get when you enter the command `date` on the terminal?
I can't think of any good scenarios to actually use this besides testing. Can anyone give me any scenarios?
As someone in a similar position as yourself, I'd say you and your boss are approaching this from different perspectives and values, and that is leading you to come to different conclusions. If this is a purely **technical** question, then yes, you are most probably right. A custom, legacy framework is a poor choice for ease of development, security, and best practices. If this is a purely **business** question, then no, you are wrong. A stable of developers who know a framework inside out and are productive in it is much more advantageous than inheriting the technical debt of all of them learning a new framework, while still having to support legacy sites built in the old framework. I get the feeling that while your employer is engaging you in a technical debate around the security of your in-house framework, the driving force behind *why* he is arguing that is for more practical, business reasons. So, suppose you win this argument, and your employer chooses to switch to Laravel or Symfony. *What happens?* Does all of your production shut down for months? What does your project workflow look like, now. Do you now also have to change your deployment practices, or does Laravel/Symfony integrate into them? What tooling around the legacy framework now needs to be re-written, or written for the first time? Most commenters here will suggest that you find a new place to work. I'm not disagreeing with that. Your personal plans for your growth as a developer might be totally opposite to your employers plans for growing (or maintaining) his business. In that case, learn what you can while you're their, do good work, and move on when you've outgrown it.
Here's the php.ini stuff: Session Support - enabled Registered save handlers - files user Registered serializer handlers - php php_binary Directive Local Value Master Value session.auto_start Off Off session.cache_expire 180 180 session.cache_limiter nocache nocache session.cookie_domain no value no value session.cookie_httponly Off Off session.cookie_lifetime 0 0 session.cookie_path / / session.cookie_secure Off Off session.entropy_file no value no value session.entropy_length 0 0 session.gc_divisor 100 100 session.gc_maxlifetime 1440 1440 session.gc_probability 1 1 session.hash_bits_per_character 4 4 session.hash_function 0 0 session.name PHPSESSID PHPSESSID session.referer_check no value no value session.save_handler files files session.save_path /tmp /tmp session.serialize_handler php php session.upload_progress.cleanup On On session.upload_progress.enabled On On session.upload_progress.freq 1% 1% session.upload_progress.min_freq 1 1 session.upload_progress.name PHP_SESSION_UPLOAD_PROGRESS PHP_SESSION_UPLOAD_PROGRESS session.upload_progress.prefix upload_progress_ upload_progress_ session.use_cookies On On session.use_only_cookies On On session.use_trans_sid 0 0 
Alright, Check /u/maiorano84's answer 
May be it is related with local time? Your server sets end of session to 2 pm, however your users are at east time zone, at 3 pm, thus, problem. (?)
May be someone somewhere posts an image showing "yoursite.com/logout.php" as image? Thus they log out when browser loads that "image". I have used this method in some forums to log out other users.
Interesting. I will check this out. Thanks.
I don't think this is it, but thanks for your comment.
GMT+1
Watch out for strange characters in the cookie name. Do you switch between domains and subdomains?
You have space character before &lt;?php or sessionstart() starts. (?)
No, intval forces the value to be evaluated as an integer. But it's a sign of horrible practices. The @ symbol as well shows that he has no idea what he's doing (it's used for error suppression) - it means he was getting an error and didn't understand how to fix it, or even turn off errors, so he silenced it.
My intent was never to submit a PR. If I wanted to actively contribute I'd have spent more time going over the contribution notes. I submitted a bug report and clearly described it, and was simply told to "submit a PR". That's a good point about GitHub's UI though. If someone submitted a PR to one of my repos that'd probably be what I would do -- clean it up a bit and then push it through. Maybe leave him a comment saying "for next time, could you please..." rather than doing this back-and-forth dance.
&gt; how many actual problems are stumbled on and then fixed by neophytes with no understanding of git? I work in Mercurial. I have a thorough understanding of that, but I'm not set up for Git, and the workflow I follow is different than that of a typical Git user. I know we're a minority, but we exist.
So you have friends or know anyone that can do the art? You could have an agreement where they can do the work upfront and you pay them a percentage of profit.
There is very few people who would be willing to do that, and I don't have any friends in the art section unfortunately.
how are you saving sessions? perhaps it is a file system issue?
there's a modern package out there somewhere in packagist that uses over 35 symfony components, that can do what you need. re-use modern libraries!
I'm just using the default settings? start_session() and $_SESSION['var_name']. The values are not saved between sessions; they're used in the same session only.
No, I always use www.domain.com
Stop trying to get a free copy of Laravel. It's not going to work.
One possible reason is calling `session_regenerate_id (true)` too often (say, every page load) which causes a race condition. What happens is this: 1. When the client hits the page, the session is regenerated, so the cookie on the client is invalidated. 2. The server tries to send the new cookie to the client, but the client is in the process of redirecting. This causes the client to not receive the cookie and lose the session. This is easily reproducible if you have a `session_regenerate_id(true)` on every page load and refresh the page quickly in succession or make multiple AJAX requests.
This could be it. The page works like this: Load page -&gt; header redirect to same page -&gt; header redirect to different page Could this quick header redirect (step 2) cause this?
Doctrine use case: to fetch objects from the database, you have to convert database rows to PHP objects. Now you don't want to call the constructor of these objects, because you are just "unserializing" these objects from a DB representation (row). It's just like PHP serialization actually (the serialization doesn't call any constructor, because the object already exist), except the serialization method/format is different. I don't know if I'm being clear at all :/
This is a possibility. You can try it yourself by refreshing the page multiple times in succession to see if the session is lost. For me, it was very easy to reproduce when I encountered it. Then, comment out any calls to `session_regenerate_id()` and perform the same test to see if that resolves it.
Maybe it's just me but I don't understand what you are asking. Actually I don't understand a single sentence in your post :/ Are you talking about the [`class_alias()`](http://php.net/manual/en/function.class-alias.php) function? Or autoloading and namespacing?
This article does nothing to make me want to use "Laravel Objects". In the rare case that I need dynamic arguments, I can create my own factory at any time. function factory($className, $args) { $r = new ReflectionClass($className); $inst = $r-&gt;newInstanceArgs($args); return $inst; } What am I missing?
It's part of Composer's job to expose global namespaces that allow dependencies to interact. How do you determine what's an inappropriately exposed namespace? Are you suggesting that Composer should not willingly expose any global aliases?
yes to which question?
Where you see "sheer fucking negativity", most people see a constructive discussion with valid points (per the upvotes). If you are afraid of discussion, don't take it on others. I know there is a fair amount of Laravel hate sometimes, but this exact thread shows nothing of that sort.
&gt;I know we're a minority, but we exist. And we are not as vocal. Hi! from another long term Mercurial user. 
Breaking this should be the first challenge in next year's Defcon CTF. The one that's there to weed out teams who have no idea what they're doing.
 $block = $db-&gt;query( __FILE__, __LINE__, __FUNCTION__, __CLASS__, __METHOD__, " SELECT `data` FROM `".DB_PREFIX."block_chain` WHERE `id` = {$_REQUEST['id']} ", 'fetch_one' ); Is this some kind of joke?
You might want to check out the MimeTypeGuesser in Symfony HttpFoundation package at [Github](https://github.com/symfony/HttpFoundation/tree/master/File/MimeType)
Dupe -http://en.reddit.com/r/PHP/comments/2exyxa/introducing_reckict_a_compiler_toolkit_for_php/
Not only that, but you get an autoloader for free with Composer (which all modern PHP apps should be using to manage dependencies) 
You could use it to namespace legacy code without namespaces.
The [wiki](https://github.com/autarky/framework/wiki) has some basic documentation, and the [skeleton project](https://github.com/autarky/skeleton) shows a well-commented but bare-bones example of what an app looks like.
Nobody has yet put into practice these vulnerabilities. Please, show them in action.
commit
The code is in the common.js script (View Source, Ctrl+F). Search for "bork" in there.
PHP manual has some interesting infornation: http://php.net/manual/en/security.database.sql-injection.php
Please show me sql injection. Node: http://pool.democratic-coin.com/
That's some really nice work! Which makes its hard to gripe about; I personally think we should have the ability to apply the DIP to the IoC by being able to inject it's configuration. Which makes me uncomfortable with the ConfigInterface ConfigInterface extends NamespacedResourceResolverInterface Otherwise I really liked it and found it interesting. 
No sorry it is illegal to crack into computers. Do you really think you are safe even though you openly ignore the information in the manual? Are your PHP skills that much better than the PHP developers?
Dcoin - this is not the site. To get access to dangerous functions need to have the private key of the admin node.
if (check_input_data($_REQUEST['id'], 'int') )
Yes to class_alias; its related to autoloading. Classes could use aliases instead of FQCN.
Composer would only intervene if it has a registered alias, e.g. similar to its autoload config.