I recently used a similar convention in a wordpress plugin, but I checked $_GET['sub'] vs an array of valid values first, and this plugin was a one-off for a single site. I mean it's one line. If in array, include path.GET.php edit - well, two lines with the array declaration.
I would. I don't see breaking with compatibility as a negative in Angular 2 - I see it as a big positive. I don't want my framework to get bogged down by its history. I can choose to use 1.x any time, now or after 2.x might become popular. Before Angular I used Knockout for most projects. I was always happy with it, but I wouldn't go back for anything non-trivial.
I'd be curious to hear your thoughts on "reactive backbone". We use backbone heavily at work and I like it, but the views get pretty unwieldy when you try to nest them (we don't use Marionette, unfortunately).
Can have a point though. Just has to replace mysql_query with mysqli_query in one place, once mysql_query is deprecated.
To be honest, you sound like you have more than enough *knowledge* to be a junior developer, but that's not actually the key factor that I look for when hiring one. Basic knowledge, yes - but the willingness to learn and ability to solve problems on your own is what I'd want. For instance - If you're given a task you don't understand how to do, you need to be able to do the research in a timely manner to find out what you need to know to do it, and ask the right questions. Note that I wouldn't expect you to quickly understand everything you need to do, but I would expect you to find out *what you need to learn*. The most important things for a Junior dev in my opinion are: * Willingness to learn * Ability to research * Ability to be autonomous (i.e. I give you a task and you can work on it without help once you understand the spec, even if you don't understand how to yet.) * Willingness to listen to and understand criticism * Checking your ego at the door The last one is incredibly important. We all know developers are egomaniacs, but as a junior you need to understand at all times that you probably don't know what's best, even if you think you could do it better. 
The elseif is redundant, it's already established that $_GET["p"] is not empty, should be just an else.
We have just started a fairly large project with Backbone.Marionette and Symfony2 backend. Working out really well so far
could be less if you count a popular project with forks.
did you read the search term he used? &gt; mysql_query( in:file I think that means an actual mysql_query( call in the file, not the words mysql and query in the title/description.
To be honest, I've learned a lot while arguing here. Thanks for the highlights on the topic.
Yep. We need to know what you are trying to do here to provide the best solution.
hunter2
&gt; If we have to learn a whole new language What? What are you talking about? &gt; take 10 times longer to develop an app Huh? Given a moderately complex SPA, a developer using a framework will destroy a vanilla JS developer in terms of development speed, it wouldn't even be close. &gt; then perhaps we should rethink this "hmm.. that code works perfectly and is clean. but its more than 6 months old.. We better completely rewrite that app just so we can say its new.." mentality. Strawman. Nobody believes that you should rewrite your entire app every six months, that's insane. In fact, the point of this thread is so that the OP can get some suggestions on stable platforms for the future.
Ahhhh true... Then again... being able to read 0.php is probably the LEAST of your worries if you're running this code.
&gt; keep on learning till I get it right It can be difficult to tell when you have gotten something right when no one is reviewing your work. My thought is you really need to get into a developer position and start getting feedback from your mentors and peers in the profession. tldr - find a position asap and choose based on the company's ability to mentor you.
Holy fucking shit. /me facedesk's 
EmberJS, just the best for enterprise. Various major open-source projects already use it, like Travis and Discourse. Beside open source may companies use it, because they do not have major breaks, and have nice consistent architecture.
Good luck, this service would be so wonderful.
Yeah I've shaken my head plenty of times when a client has chosen to go with someone else because they're "cheaper" than I am only to come back to me when the first guy is a total flake and has written things similar to this. My favorite, though not PHP related, was when a well-known design firm tried to charge him $4,500 for a redesign when all they did was buy a WordPress template from some guy for $45. I found out because they left his copyright notice in. D'oh! No bonus for me though.
This would be better in /u/PHPhelp. 
Excellent, thank you! Fortunately I know the codebase is pretty solid because the people maintaining it are dedicated to best practices, so I'm really looking forward to seeing what they've done.
&gt; PDO/MYSQLi as neither are installed on the live box What version of PHP does live run? 
I don't think that's being grumpy at all. I would personally want people who are willing to try to find answers on their own. It shows you have an interest in learning and developing yourself. This post is somewhat ironic because this question gets asked a lot and there are tons of good answers for the person willing to look.
Please don't mess with my browser back/forward gestures! Why do you need to mess with the scroll on this site anyways?
Yes. Angular 2.0 isn't going to be out for another ~12+ months. When 2 hits, 1.x will still be available. Support may dwindle over time, sure, but it would with any framework/lib/lang you use. I'm not a huge Angular fan but the doomsday shit you see all over the place is pretty dumb. 
http://you.com?p=..&amp;l=../../../../../../../../../etc/passwd%00
Dynamically loading pages whose names are a series of concatenated unsanitized string inputs from the user? [Nothing could go wrong ...](http://imgur.com/Ht8m5rt) [Edit 1] fixed img url.
ohh myyy goddd
i dont even know php that well(worked with it for a total of ~30h, which includes the learning time for the basics), and even i can see the big mistake in this. Just write what ever you want in the url and bam, you got acces to everything(include any files on his server, even files which are not suppose to be accessible). Also, wtf is wrong with this guys indenting. Why would he indent the last include so it lookes like it under elseif, whens its actually under else... 
Did you actually try looking at the repository search? You're wrong, that's not how it searches. (And think about it, if it was only 126 repositories that would mean over 5800 files per repo on average.)
&gt; I personally wouldn't hire a remote junior. Juniors need a whole lot of hand-holding This makes me feel special, as a remote jr developer
I get a resume that reflects that this is someone who might pass those tests, then I interview them. It's not hard to get a feel for somebody. I've been right more than I've been wrong. (Some of my "wrongs" have been REAAALLY wrong, but that's another story.)
Well, on reflection that may be more an expression of my confidence level in myself supporting a remote person than in the capacities of a remote person. I actually don't trust myself not to be "out of sight out of mind take the spec and deliver the commits" with a remote junior the way I could be with a more senior remote person, and in my experience that doesn't work.
It's really not a big deal if you're conscious of the fact that zero counts as empty. if (empty($_POST['name'])) reject(); Uh, oh. We just rejected someone with the name "0". Is it really easier to do if (! isset($_POST['name']) or $_POST['name'] === '') reject(); every time? Just pay attention to cases where zero might be a valid input and for me at least that's actually pretty rare. You have to pay attention one way or another. Do you also insist on doing this obnoxiousness if (null == $var) just in case you miss an equals sign?
Excepted Toran helps Packagist stay afloat so I prefer it personally
&gt; maktouch Jesus christ, that is very sexy. 
Not really, but I think the OP downloaded Toran and is now selling it for money as a service =)))
What about his gonna get hacked? 
&gt; http://en.wikipedia.org/wiki/Directory_traversal_attack 
Helps that I'm a java developer by trade I guess. Any advice on a server I can install java that is cheap?
rip in peace phil
I use rack space , guess I can load java on that, wasn't sure have never done it .
 You can use meteor with a rest service in php. 
We've just started using toran proxy at work, it's awesome :D
Would anyone actually pay money for such a rudimentary set of tools? It''s basically firebug + firephp + xdebug. For 19$/mo
I knew what 'e' does but i thought that given another letter it would still convert to numbers because of the leading 0. Shame on me.
The only purpose I can see is that is speeds up automated testing as the deps don't need to be resolved. I don't think there is much of a good reason, but the myth that it affects dep resolution when a lock file is in a required component is fairly widespread yet wrong.
Any maintainable, modern code should never have the problem noted in your example, as it's abstracted away behind a good HTTP request API which hides that for you (and often offers niceities like defaults - e.g. `$request-&gt;getParam('foo', 'bar')`). There are also several other elegant ways to do it, like using `array_replace()` or the `+=` operator, if you don't have the luxury of using a good HTTP request/response library. But, perhaps a better example than your noted "name" would be something like "number_of_children" or "reserve_price", or, quite literally, *any* numeric input that you can think of where `0` is a valid value. Anyway, I was just being funny. Not sure what you're on about with the `null ==` bit.
UGGGHHHH PLEASE JUST LET ME SCROLL NORMALLY.
Looks like ******* to me.
A few years ago I may have agreed with you, but PHP has come a long way as a language. I'd say it's a very dangerous language for a new developer, and while it's often billed as one with a very low barrier to entry, I don't think that's the case anymore. If you want an easy, well-designed language that's quick to get started in and develop good habits in, Python would be a better place to start. Once you're more experienced as a dev, you'll be able to identify the 85% of syntax and libs that you should just completely ignore (never `$foo and bar` instead of `$foo &amp;&amp; $bar`, don't use variable variables e.g. `$$foo`, and many more). I like the approach taken at http://www.phptherightway.com/ , which I find is a much better way to learn PHP than to just peruse php.net. Modern PHP, properly written, is excellent for writing very well-organized web applications which run synchronously. So long as it closely adheres to the traditional concept of a website (user requests page, site replies with page data, and the bulk of the data you process is meant to be displayed to or read from a human), I think it's the best language to choose. Pick a good design pattern, namespace properly, write your Interfaces, and make sure to use dependency injection, and you'll do well.
Interesting... Good luck. Not sure how it compares to satis or toran: https://getcomposer.org/doc/articles/handling-private-packages-with-satis.md
It is similar, but as it stands Toran is hosted by yourself, repobox was intended to be a hosted service. I actually stalled out on this project when someone tipped me off that Jordi was building Toran Proxy. I've picked up interest in it again recently after some encouragement from others.
Apologies, I had no idea it was doing that, it's a template from themeforest, I'll see if I can make it behave.
You could pretty much think of this as hosted satis with a thin layer of authentication and access control over the top.
That's pretty much what I'm shooting for.
Have you never had this conversation? "Hey client, some of these functions are deprecated and we'd really like to do some updates to your application". Client: "Sure, as long as you're happy to do it for free then no problems".
Further the point that this is a silly statistic with no basis... many of the apps I quickly looked over were using Mysql_query as a fallback.
Just trolling =)
&gt; Isn't that a better alternative to wait a few weeks after the release to go in details on the security issue? I think without the whole publicity, *most* people wouldn't bother upgrading to every single bug fix release immediately. So I don't think waiting would have helped.
I don't think that tests should influence what you include in your repo
If Drupal wasn't upfront about the vulnerability right away, it would be reported by someone else within hours. It's open source, so they can't hide what they're fixing. Patch notes or not, checking the source people would work out what they fixed.
Plus it means your tests will run only on locked deps so if someone uses your package with newer deps it can break and your tests will not be able to show it.
&gt; Have an interest in becoming a programmer (which is literally all a college degree tells me) I hate this sentiment, it's just not true. If you're getting juniors with degrees who turn out to be that useless, stop hiring them, because there are plenty of decent CS degrees out there that turn students into better programmers than most 'veterans' I've seen in my day. 
&gt; I consider the Drupal security team one of the best I've encountered in OSS. They are on the ball, quick to respond, and know their stuff. Made me laugh. https://twitter.com/i0n1c/status/527552935623143424
Well send them to me. I've never once seen a new graduate who had much of a sense of how to build more than a toy or "assignment" project. Doesn't mean they're bad programmers, they just literally have zero real-world experience (by definition). I've seen a few who had side projects they'd built on their own, and they tend to be stronger, but for the most part even that stuff is pretty toylike. By the way, having done a degree program is a WHOLE DIFFERENT THING from sitting at a desk for 8 hours and delivering code. Not everyone with a degree in programming is actually cut out for a job programming, and for the most part they don't know that.
Actually, upgrading a fleet of servers isn't that difficult assuming you've approached it with automation in mind. You may say thats looking at the problem from a developers standpoint, but the truth is in this day and age if your ops team doesn't use a configuration management system, you need a new ops team. Upgrading and testing code is where the problem usually lies and since the ops team doesn't know anything about your bespoke code and the quality of such code, and thus will be reluctant to upgrade any of the underlying services until someone has signed off that the code works as suspected with relevant versions. There's a lot of big business running on terrible code where nobody knows what's going on and then you have hosting companies with thousands of customers per server, it's understably a lot of work. Unfortunately it's a lot of work you should be doing and if it's not happening and the service is internet facing and in any way important then it just speaks to incompetance.
Author beat around the real lessons : 1. Do not execute code that is writable by anyone other than root user logged in with ssh. ssh must not accept password logins. If code can be modified/created and then executed by a web user, you are doing something horribly horribly wrong. Even if your web user is 'admin'. 2. Use PHP's prepared query tools, don't reinvent security related code. If old versions of PHP and MysQL don't work, don't support it.
We have been using Jasper for the last two years where I work, and we're not planning on using it for future projects. It gets the job done, and the end result is nice, but the server is a maintenance headache. We consider it to be a very high-maintenance solution. Expect to spend a lot of time fighting with Jasper. Edit: FWIW, I haven't personally used it. I am simply relating the experience that my coworkers have had with it. We are currently scaffolding up a new project, and the team members that have experience with Jasper have taken it off the table as an option for the project due to the maintenance. 
In fact, the bug was reported back in November 2013: https://www.drupal.org/node/2146839 and marked as Major in March 2014 because of its security implications. Anyone monitoring the reported issues list would have seen it. (Here's a thought, what are the odds that there are other similar reports in the issues list?)
Most security teams and researchers suggest not releasing POC exploits. It's perfectly fine to release a disclosure of the exploit, but releasing code that can actually perform the exploit is *slightly* more dangerous. Not because it'll take days or weeks for attackers to create those scripts, but because it will take a certain class of attacker days or weeks. 
lol. I was super drunk last night. I don't even remember this. I think I was just trying to stir up trouble. My apologies.
In an ideal world, yes. These are good rules to live by. The fact of the matter is that we live in a world dominated by dynamic and pluggable systems. And in that world, tradeoffs exist. It's nice to get high and holy, but that ignores the large fraction of users who need that functionality. 
&gt; Not because it'll take days or weeks for attackers to create those scripts, but because it will take a certain class of attacker days or weeks. This vuln is so simple it should've been obvious that it would lead to mass scanning in no time. Still they obviously thought it would take days to weeks if there is no POC. If it was just usual routine to speak out against POC, why did they explicitly say it would take days/weeks? &gt; Automated attacks began compromising Drupal 7 websites that were not patched or updated to Drupal 7.32 within hours of the announcement In relation to this they write: &gt; You should proceed under the assumption that every Drupal 7 website was compromised unless updated or patched before Oct 15th, 11pm UTC, that is 7 hours after the announcement. I'm so happy (and safe!!), I patched 6 hours after the announcement... Also why did fix take 29 days I wonder, maybe researchers set public disclosure to 30 days...??
That is mostly an irrelevant point because currently people don't test systematically against different ways dependencies can be resolved, so generally they end up getting the same dependency resolution each install even without the lock file. But yes I agree, unless you make sure you update the lock file at times, the. You will be testing against the same deps all the time.
For phpBB a BC break is when mods and templates would not work with the newer version without a rewrite. This happened between phpBB 2 and phpBB 3, hence the versioning 
High and holy? Really? Tradeoffs ignore the security of all users.
We spend so much time screaming at new coders to prevent SQL injection, and then Drupal went all the way to workaround prepared statements for a small coder convenience. It's a bit mindboggling.
Damn, what a great post! So if I get this correctly, I shouldn't be worried when comparing two hashed strings (for example passwords), right? since even the slightest change to the plain text password will alter the hash completely, even more so if it's hashed with a salt. Or am I still missing something?
&gt; But PDO's emulated prepared statements split that query into two.... Oh my god! OH MY GOD! Why? Why? All the while we were yelling and yelling at people to use PDO and prepared statements, pdo has been doing this in its FUCKING default mode. Why isn't every one freaking out? Why are we fucking knowing this now in fucking 2015?, (THANKS TO /ircmaxell by the way). So people, the real question is not about drupal. The real question is about PHP and its most widely used library. 1. Why was pdo doing this (splitting queries) in the first place? 2. Was this a known behavior or a bug? 
&gt; Anyone monitoring the reported issues list would have seen it. This is not as straightforward as you might think. There are currently 14000+ open issues. This was reported in the wrong queue and for the stable 7.x version (which has comparatively less eyeballs since most people are working on the next 8.x version). The original reporter did not realize it was in the wrong queue, and tried raising attention by tagging it "#security" and raising priority to major. However, unknown to him, nobody else was using that tag so it didn't pop up on anybody's radar. edit: An issue was started to make it clearer where to report security issues: https://www.drupal.org/node/2358373
Not really. The reason is obvious, but it isn't quite exactly as you stated. Having hung around the bot scene for a while some years ago, a majority of people in the scene are absolutely incapable of producing anything of quality. I mean, I did an RFI write-up long time ago, and for those who don't know, RFI would inject scripts into unpatched or unprotected PHP application deployments remotely (as in, over the net). Any administrator could see attempts and probably still can every once in a while in their logs even today. The PHP bots and c99 shells they were injecting often displayed plain text passwords, and a majority of attackers had no idea how the exploits worked or how to modify scripts to obfuscate or hash their passwords. It took an edit of like, 3 lines max to add MD5, maybe 4 or 5 to add salt. Nobody knew how. I mean look at the malware scene, people are still utilizing cryptors to obfuscate their malware to hide existing known malware from scanners, when it is fairly trivial to just make your own and port some features to evade detection for a period of time. The fact of the matter is, most people in the black hat scene are morons. Not all, definitely not all, as I've met talented people in the past, but I would say a majority of them have no idea how to do anything and are just skiddies. A script kiddie can't be a script kiddie without a script. The purpose of advising against releasing POCs is to stop people who don't know how to code at all, or who don't know enough to exploit it themselves. Which is a lot, lot, lot of bot owners. You and me are essentially saying something very similar, but I'd argue it isn't a matter of speed at all, and is instead a matter of just not being knowledgeable enough to utilize the information in the first place.
Per the documentation, PDO_MYSQL will take advantage of native prepared statement support present in MySQL 4.1 and higher. If you're using an older version of the mysql client libraries, PDO will emulate them for you. However, without insight into the PDO code itself, I can't say with certainty that this is indeed what occurs. As a side note, you can explicitly bind parameters, or set the PDO::ATTR_EMULATE_PREPARES attribute to false to disable emulation.
Doesn't solve your problem, but for the spreadsheet generation there's [PHP Excel](https://github.com/PHPOffice/PHPExcel), or just fputcsv and run libreoffice in the command line to convert it to other formats.
&gt; As a side note, you can explicitly bind parameters, or set the PDO::ATTR_EMULATE_PREPARES attribute to false to disable emulation. It sounds unlikely anyone will run PHP 7 with MySQL &lt;4.1, so maybe this should be disabled by default in 7 or plain removed from PDO.
Fixed. Thanks for notice.
I wholly agree with it being disabled by defauly, but it'll take an RFC and a vote that is unlikely to pass due to it breaking BC. IMHO, the PHP community shouldn't be afraid of small BC breaks, though it should shy away from BC breaks the like of Python 2/3.
There was a thread on it started: http://grokbase.com/t/php/php-internals/114yxh67nx/change-request-make-pdo-default-to-not-emulate-prepared-statements-for-mysql I don't believe it was ever changed to be prepared by default.
I don't care if the pdo does its thing using emulation or natively, as long as it does correctly and consistently. I can even understand if it misses some edge cases where the results of emulation and native calls differ...because bugs happen. But splitting the query in one mode and not in the other is well...I am out of words to describe that. I cannot think of any reason whatsoever to do something like that. It would be great if someone could shed some light on this Damn! are some of these php libraries written by kids learning C programming for class assignments?
Wow, this makes me feel like a dinosaur. It surely had a rough drama-full ride over those years. Makes me feel nostalgic reading the original [announcement](https://groups.google.com/forum/#!msg/comp.infosystems.www.authoring.cgi/PyJ25gZ6z7A/M9FkTUVDfcwJ)
This was interesting at the start but the sections for PHP 5.x just feel like a rehash of the changelogs. It would be better if those sections were written in the same format as the earlier sections, detailing just the major changes in a paragraph rather than bullet points. Important milestones like major frameworks (CakePHP, CodeIgniter, Laravel, FuelPHP), PSR standards, Composer, the release of PHP-FPM are all missing. 
haha, no worries.
Great post!
I read the title and I just assumed it was a job requirement somewhere. 20 Years PHP 30 Years JAVA 40 Years C/C++ We're looking for young and energetic talent. 
You basically just described [Lada cars](http://en.wikipedia.org/wiki/Lada).
In what situation would you even have to write something like this? ( I'm not super knowledgeable about PHP / Server Side programming ). 
This is incorrect. PDO will use emulated prepares by default unless you explicitly disable it.
work around prepared statements? HUH? It's using the prepared statement API under the hood. They are not escaping anything. In fact, their system, while a bit complicated and hard to figure out internally, actually makes developers *more* secure by giving them an easier-to-use system. Looking at one corner (the `IN` expansion) and declaring the whole system for naught, is itself mindboggling.
&gt; adding them manually to every single composer.json is a pain I have never, ever, been able to use composer with private repositories (although I didn't use satis, I simply tried to link them to github repositories). The closer I got, Composer said it had found the package, but there were no versions for it, even though I did have releases in the github repo. Go figure 
If you *never* made any security tradeoffs, you'd never write any software. Literally. Because as soon as it's written, it's possible to exploit. Even if by putting a gun to the heads of the people with the keys. **EVERYTHING** in security is about a tradeoff of one form or another. Often its usability on the losing end of security. For example: Requiring a long password sounds great, except that it makes the site less usable. So rather than the user using a password they can remember (but is reasonably weak) they write it down and leave it next to their monitor. **All** security is about tradeoffs. That's the game we play. To say "tradeoffs ignore the security of all users" is completely missing the point. Software is here to do something for us. That's the fundamental reason it exists.
&gt; However, without insight into the PDO code itself, I can't say with certainty that this is indeed what occurs. 
No, it's like saying that every Englishman doesn't need a castle, just the rights to build their own home. And not because poor people need cars too, but because *everyone* should be able to participate in this thing we call the internet. If you don't like it, bugger off. But if you want to help, build a system that will give them the functionality that they need, at a complexity that you can afford, and a performance that's reasonable. Tons of people have tried. And Drupal is one of the best that's come out of it. That doesn't mean it's perfect, not by a long shot. What it means is that it balances the tradeoffs effectively. You want to try to make something better?
I agree with this one - ember is amazingly good. Takes a bit to come to grips with it's conventions and opinions but after that it is remarkably terse and very productive to work in. Ember Data simplifies communicating with an API like nothing I've used before and Ember CLI (while still not entirely stable) is a great bit of kit for generators, testing, API stubbing etc etc.
Why? I see how it works, but I don't see why someone would need this. It's not like you're abstracting presentation and design, it's all mixed together. I can't see any performance advantage of doing it this way, and I don't see any caching, templating, token replacement, etc. Tiger: div('.row marketing')-&gt;div('.col-lg-6')-&gt;repeat(3, function() { h4('Subheading'); p('Donec id elit non mi porta gravida at eget metus.'); }); Traditional: &lt;div class="row marketing"&gt; &lt;div class="col-lg-6"&gt; &lt;?php for ($x=0; $x&lt;=3; $x++): ?&gt; &lt;h4&gt;Subheading&lt;/h4&gt; &lt;p&gt;Donec id elit non mi porta gravida at eget metus.&lt;/p&gt; &lt;?php endfor; ?&gt; &lt;/div&gt; &lt;/div&gt; The Tiger way is more concise in this particular example, but introduces a lot more overhead in my opinion. Is there another nuance that I'm missing?
Well said and thank you for your feedback. Here is the thing. I didn't want to use HTML so I built this. Halfway I realized I didn't want to write PHP either so I built [gum](https://github.com/bucaran/gum) and this was left over for a while. Last night, I made it into a library, polished the comments and decided to push it upstream. At its current incarnation, Tiger brings sugar and little convenience, nothing else. You have some ideas I would like to understand better so if you could be more specific I am all ears. Cheers.
The whole thing about having php code in your database has always been a disaster waiting to happen. Not to mention it's a pain in the ass to maintain between instances of the site.
&gt; I wholly agree with it being disabled by defauly, but it'll take an RFC and a vote that is unlikely to pass due to it breaking BC. No RFC necessary, I already [received approval](http://grokbase.com/t/php/php-internals/114yxh67nx/change-request-make-pdo-default-to-not-emulate-prepared-statements-for-mysql) to do it. The only thing was I didn't because I broke a boat load of tests (over 200 if memory serves me correct). And I ran out of time trying to fix them all... 
Indeed. From 5 onward focus more on the community aspect that has evolved around PHP such as WordPress, Symfony, Composer, etc. rather than language features.
You forgot to mention EXTREMELY PASSIONATE about working with 15+ year old legacy code.
Auto resolution was very much nice, provided you are not expecting a lazy shared object. Things are hard to debug when you have enabled auto resolution. Learning from experience.
If you don't go into details, a lot of people will look at the patch to see what changed. The fix this time was just one line. The fact that they sanitized the array keys kinda screams that they were not filtered before and that's a pretty good place to start digging. It wouldn't take that long for someone to identify the actual bug, and then you'd have the same race as now, except the good guys would know *less*.
I can't believe I've been developing with php for 16 years
hi
Honestly, I know this is not constructive but TL/DR. Maybe try to make the README shorter? Or at least a really small introduction, or code examples?
 I didn't invent a new language. You are referring to [Jade](http://jade-lang.com/). What I did build was [gum](http://github.com/bucaran/gum), a library of Jade mixins to render PHP.
Thank you. I had something like this in mind as well. Eventually I realized a tool to help me writing PHP in [Jade](http://jade-lang.com/) would be more useful in the project I was working on, so I built another little tool called [gum](http://github.com/bucaran/gum). Tiger was a reminder I didn't want to throw away so I gave it nicer clothes and put it out there. I published the project in [bower](http://bower.io/) too.
&gt; If you never made any security tradeoffs... Of course, no one is arguing about that. Why are you even assuming that people are suggesting to lock down all software for sake of security. But allowing a short password and executing arbitrary code from a user "ain't the same fuckin' ballpark, it ain't the same league, it ain't even the same fuckin' sport". I know you mean well, but your argument is misdirected. 
Agreed.
Please post these kinds of question to /r/phphelp as per the sidebar. Furthermore: Don't try to validate email with regex, just check for the existence of an `@` and send a validation email instead. If you want to know why, here is a regex that is fully RFC822 compliant (e.g. allows all possible variations): ``` (?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t] )+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?: \r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:( ?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\0 31]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\ ](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+ (?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?: (?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z |(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n) ?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\ r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n) ?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t] )*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])* )(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t] )+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*) *:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+ |\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r \n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?: \r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t ]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031 ]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\]( ?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(? :(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(? :\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)|(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(? :(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)? [ \t]))*"(?:(?:\r\n)?[ \t])*)*:(?:(?:\r\n)?[ \t])*(?:(?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]| \\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt; @,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|" (?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t] )*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\ ".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(? :[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[ \]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?:[^()&lt;&gt;@,;:\\".\[\] \000- \031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|( ?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n)?[ \t])*(?:@(?:[^()&lt;&gt;@,; :\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([ ^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\" .\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\ ]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\ [\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\ r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\] |\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)?(?:[^()&lt;&gt;@,;:\\".\[\] \0 00-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\ .|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@, ;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|"(? :[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*))*@(?:(?:\r\n)?[ \t])* (?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\". \[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t])*(?:[ ^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\] ]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:(?:\r\n)?[ \t])*)(?:,\s*( ?:(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\ ".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:( ?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[ \["()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t ])*))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t ])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(? :\.(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+| \Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*|(?: [^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\ ]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)*\&lt;(?:(?:\r\n) ?[ \t])*(?:@(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[" ()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n) ?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt; @,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*(?:,@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@, ;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\.(?:(?:\r\n)?[ \t] )*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\ ".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*)*:(?:(?:\r\n)?[ \t])*)? (?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\["()&lt;&gt;@,;:\\". \[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t])*)(?:\.(?:(?: \r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z|(?=[\[ "()&lt;&gt;@,;:\\".\[\]]))|"(?:[^\"\r\\]|\\.|(?:(?:\r\n)?[ \t]))*"(?:(?:\r\n)?[ \t]) *))*@(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t]) +|\Z|(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*)(?:\ .(?:(?:\r\n)?[ \t])*(?:[^()&lt;&gt;@,;:\\".\[\] \000-\031]+(?:(?:(?:\r\n)?[ \t])+|\Z |(?=[\["()&lt;&gt;@,;:\\".\[\]]))|\[([^\[\]\r\\]|\\.)*\](?:(?:\r\n)?[ \t])*))*\&gt;(?:( ?:\r\n)?[ \t])*))*)?;\s*) ```
You should use the [bracketed syntax](http://php.net/manual/en/language.namespaces.definitionmultiple.php) only on files that have multiple namespaces being declared. It is also probably worth noting, [PSR2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md).
Meh. Install Facebook's [XHP extension](https://github.com/facebook/xhp) (or switch to HHVM/Hack which has it built-in). Mostly however I'm commenting to say: weird choice to use Bower for package management.
Whoa. So many unnecessary function calls.
Thanks for commenting. I used bower because it's very simple to use. Just push project and tags to repo and run: bower init or create the bower.json file yourself with the project info. Then: bower register myProject git://github.com/me/myProject.git What would be a better option?
I couldn't find a better way to expose all the functions globally, but I did come up with a way to avoid duplicating code thanks to some of PHP magic functions. Check [tiger.php](https://github.com/bucaran/tiger/blob/master/tiger.php). BTW Facebook's XHP is awesome. Tiger is simple and could work for small projects though.
&gt; Do you know what exactly was said? No I don't, but I believe a Stefan Esser. https://twitter.com/i0n1c/status/522424001659174914 &gt; It did not take 29 days to fix. Ok thanks, I've read FAQ now. &gt; Experience has shown that availability of weaponized pocs can lead to widespread abuse, whereas similarly critical vulns without such a poc are hardly ever touched. Yes makes sense, but certainly not for this vuln. So to me it make them look delusional/incompetent when they say it takes days/weeks.
??? https://www.sektioneins.de/en/advisories/advisory-012014-drupal-pre-auth-sql-injection-vulnerability.html https://twitter.com/i0n1c/status/522575281480302593 Bad enough that thing sat there for 1 year without anyone noticing.
*Writing PHP can be toxic if one is exposed to large amounts of it, but it doesn't matter.* So what is Tiger good for? And how does it help to make php less toxic? Looking at your code I believe PHP also made Tiger toxic. Did you notice PHP 5.3 (2009) has intoduced [namespaces](http://php.net/manual/en/language.namespaces.php)? Did you know there is some [coding styleguide](http://www.php-fig.org/psr/psr-2/)? Are you aware of IDEs that can use the phpdoc-typehints to offer static code analysis? Especially when the format is correct... Your code is the perfect example of why php has this negative image.
&gt; Some Yes some are delusional. Please look my initial sarcastic comment here, it stands right doesn't it.. &gt; I think it is telling that the current mass-exploits all use a particular entrypoint from a SektionEins POC that I believe to be widely leaked hours, if not days, before the announcement. In any case this vuln is no rocket science. I don't understand why you try to defend and imply without (possible) leak of private POC, drupal statement may stand right and it would've taken days/weeks. It's just not true.
I did a project last year, the client's agency runs everything on 5.2 even though their own internal documentation calls for 5.4. It was... frustrating to say the least.
*Bad idea to say PHP can be toxic*. I did know about namespaces. What is your point? Many thanks for commenting, but please try to provide more details as to why you think the code is inadequate. I am trying to understand, but there is no way to determine what is not right just from reading your feedback. 
I have nothing against composer or packagist, but if I recall correctly it's more complicated to publish to than bower. Please correct me if I am wrong. Bower is not perfect either, but I was able to get things working easily.
Bower's a package manager for front-end JavaScript. Composer's a package manager for PHP. They're almost identical in usage. Create a composer.json file, then register your repo on Packagist. To use, people just add your package to their composer.json file, then run `composer update`.
First, you didn't answer the main question: What is Tiger good for? To me it appears that you just wanted to build some field experiment without any existing practical usecase. Second, I extensivly use angularjs and emberjs to build html5-apps. Tiger is out of scope here. If I had an app built uppon Tiger, I had to rewrite all the stuff back to plain html if I want to start to use one of those fancy js-frameworks out there. Great reason to never use a tool like this. Third, you use functions. Today, PHP still knows the concept of functions, but no one should use them as well as static methods. Today we build apps uppon interfaces and inversion of control through dependency injection, which can be archived by tools like [php-di](http://php-di.org/). Today PHP can be used with concepts like autowiring and (as mentioned before) static code analysis. Fourth, your tool is not compatible with php &lt; 5.4 because you used [function-array-dereferencing](https://wiki.php.net/rfc/functionarraydereferencing) without any need. Fifth, you use [?&gt;](https://github.com/bucaran/tiger/blob/master/node.php#L148). Sixth, you use [underscores](https://github.com/bucaran/tiger/blob/master/node.php#L136). Subjective thing, but I dont like this mixup. Seventh, you did [this](https://github.com/bucaran/tiger/blob/master/node.php#L19-L23). Ok, I could end up with thenth of reasons, but I stop here. 
I agree. Where I work we used to have all manor of code in the database. I phased it all out. The only code left in the database is an extremely handicapped version of HTML for rich text.
Drupal still supports it, so as soon as someone finds an SQL injection somewhere they can do whatever www-data can on the server. Core is pretty good about these things these days (this issue excepted), but contrib is probably full of similar crap.
Everyone did something like this 8 years ago. We didn't have fancy routers and dispatchers. Or MVC frameworks. So you had an index.php that contained such code plus the layout, database connection, etc. and then injected the different pages into index.php. 
And the opportunity to work with our team of world class developers to build innovative products.
There is a much better emphasis on security. Be conscious of SQL injection (use paramaterisation), XSS, best practice password hashing and session fixation. 
I don't agree with everything from PSR2, so I take as much as I can from it, but deviate where it makes sense.
Yeah, good ideas. I'll make sure to set aside some time in the next bit. Anything on the functionality?
I know that this day is gonna come and i will feel like JAVA developers. 20 years, really.
I don't see this library as useful either but I have to object to your third paragraph. PHP is a language with first class functions, just like many other languages. That will *never* change and that's a *good* thing. As a side note, throwing everything into a class and making it composer-autoloadable does **not** make your code object oriented. There are *huge* [areas of programming](http://en.wikipedia.org/wiki/Functional_programming) where you don't even *think* in object terms. This particular library did the *right thing* by sticking with functions. And static methods are a bad thing? They are only bad *in PHP* because the language allows you to do weird things with them. For example in Java, you don't have the `self` vs `static` confusion, you don't have abstract static methods and, most importantly, you are not allowed to override static methods at all! There, just by having a sane language implementation you avoided most of the static method pitfalls. The only other issue is testability, but that only becomes a problem if you make the static method mutate existing state, which you shouldn't do. I do agree with the rest of your points :)
Thank you for the in-depth feedback. At first, I was writing a WP theme and didn't want to embed HTML in **PHP only** files, so I wrote Tiger. That was the use case and that's what it was for. Eventually, I figured it would suit me better to write a Jade Mixin library so I wrote gum. Ah underscores, I didn't know they were frowned upon in the community, thanks for letting me know. Honestly, I didn't mind the &lt; 5.4, and I was aware of this. Thank you for catching the ?&gt;. So, what's wrong with this again? function __destruct() { while (count($this-&gt;elements)) { echo '&lt;/'. array_pop($this-&gt;elements) . '&gt;'; } }
&gt; Important milestones like major frameworks (CakePHP, CodeIgniter, Laravel, FuelPHP), PSR standards, Composer, the release of PHP-FPM are all missing. Composer is in there after 5.3, but yea could have done with more beef in that section
Interesting 
Thanks for the link. Now, if I ever build a time machine, I'll know which year to go to and stop Rasmus Lerdorf from ever spawning this evil.
Mixing domainlogic and templatelogic in the same file is never a good thing. Even not if someone is extending some bs like wordpress. @__destruct: Its up to the garbagecollector to collect and destroy objects from time to time. The developer might not know nor influence that. This may work now, but may be 7.0 changes the strategy how the GC works.
You referenced *functional programming*. PHP offers procedural programming. That is a big difference! As of 5.6 you can use autoloaders for functions. But, really, don't do that. Use classes all the way, think in units and use modern coding techniques like clean code. Except in really rare cases, there is no solution that is besser archived with functions than with classes. Static methods are much the same like functions. The only difference is, that static methods have some extra namespace wrapped around as well as private static properties. Really, there are tons of arguments against static methods all over the internet. Go ahead and look for terms like *inversion of control*, *testdriven development*, *design by contract*, *aspect oriented programming* and so on. This is not different in Java.
I didn't get that last comment. You do realize that *without this*, I would have to add a *close* or *out*-like method to element objects (nodes in Tiger) in order to render the closing tags. It's of course a feature that elements close themselves. One more thing, you talked about DI, the pattern of delegating the creation of dependencies to the client of a class rather than having the class itself instantiate its objects. But where am I failing to not use this pattern where I should in Tiger? Finally, &gt; bs like wordpress I can't agree with that, but I did struggle a bit (without much enjoyment) with some of Wordpress core stuff and [wrote about it](http://bucaran.me/joyd#themeus).
&gt; You referenced functional programming. PHP offers procedural programming. That is a big difference! I did, and I know functional != procedural, I was just trying to show that there is a world outside OO. Moreover, PHP has first class functions and you [*can* do functional programming with it](http://www.phptherightway.com/pages/Functional-Programming.html). &gt; As of 5.6 you can use autoloaders for functions. But, really, don't do that. Use classes all the way, think in units and use modern coding techniques like clean code. I mean this in the nicest way possible: That is an extremely short-sighted view of programming. You can think in units without using classes and what does *"modern coding techniques like clean code"* even mean? "Clean code" is not a technique and you can most certainly write it without ever touching a class (like you can do in, say, Go). &gt; Except in really rare cases, there is no solution that is besser archived with functions than with classes. There are entire *systems* that the world runs on which does not have a class anywhere in their code. Even popular PHP stuff like Laravel, Symfony, Assetic, Monolog etc. has helper *functions* where it makes sense. &gt; Go ahead and look for terms like inversion of control, testdriven development, design by contract, aspect oriented programming and so on. This is not different in Java. Did you read my comment on this? If you are not mutating state in a static method, you are not causing *any* problems for tests, IOC containers or anything else. Most well-written static methods either return a constant or an instance of the class (`public static MyClass instance()` is extremely common in Java and it doesn't hurt testability *one bit*). &gt; design by contract, aspect oriented programming and so on Are you sure you are not just throwing buzzwords around? What does AOP have *anything* to do with what we are discussing here?
Depending on where you're looking for work you might be able to get a job with nothing more than a willingness to figure it out. I got a job with a marketing agency knowing little more than HTML/CSS and basic PHP syntax. I spent a lot of hours at work (and at home, lots and lots at home) surfing the web for solutions to common problems using PHP/MySQL, Javascript, and the like. I watched lots and lots of tutorials online and now, a year later, I am just finally starting to feel slightly comfortable at what I would consider a junior developers skill level and role. If you have a good attitude and work hard, with just a little bit of luck, you can get a job.
Friends don't let friends use global state. [Static == global](https://gist.github.com/J7mbo/f9a6d54de6c48a6f0e7d).
You're missing my point. Stop complaining and start coding.
Dependency-Injection means, you have a *contract* on one side (in PHP = Interface) and an *implementation* on the other (in PHP = implementing class). So you can have multiple version of the implementation of Tiger - one currently available and a mock-version to write automated tests with. You can't use tiger as an dependency right now. The only possible way to use it is to hardwire it were you need it. Regarding your __destruct issue: https://eval.in/216279
That all said, it wouldn't be too difficult to move the code into instance methods and make both forms of use available. I'm going to make a reminder for this.
I don't "agree" personally with a good chunk of PSR-2, but I want contributors to have a defined spec for contributing code and I want my library users to have a common API style.... so PSR2. Standards aren't there to make people happy, they exist to make people productive.
Ok, I think this would lead to nowhere. Functional programming does not touch the functions vs. classes field. It's possible in both ways. You can think in units when using procedural approach - but you hardly map realworld-things to procedures as you could using oop. Talking about stateless helperfunctions does not hit the point, right? Yes, I rather advocate for not using them, but up to a certain extend there is objectively no serious argument against them. I don't see the need of functions in libraries like this. AOP: http://exarphp.com/
Ugh that awful scrolling. Why would you purposefully degrade the user experience like that?
If someone uses your code, he is tightly coupling his code to yours unless he writes a wrapper to wrap all your methods. Are you familiar with [SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29)? Your code should not have a single static keyword in it. I know some well known libraries use it, but I have had many headaches from those instances (looking at you symfony components). It is just bad practice and has no place in clean code. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**SOLID (object-oriented design)**](https://en.wikipedia.org/wiki/SOLID%20%28object-oriented%20design%29): [](#sfw) --- &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming), __SOLID__ (__Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion__) is a [mnemonic](https://en.wikipedia.org/wiki/Mnemonic) [acronym](https://en.wikipedia.org/wiki/Acronym) introduced by Michael Feathers for the "first five principles" named by [Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin) in the early 2000s that stands for five basic principles of [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming) and [design](https://en.wikipedia.org/wiki/Object-oriented_design). The principles, when applied together, intend to make it more likely that a [programmer](https://en.wikipedia.org/wiki/Computer_programmer) will create a system that is easy to [maintain](https://en.wikipedia.org/wiki/Software_maintenance) and extend over time. The principles of SOLID are guidelines that can be applied while working on software to remove [code smells](https://en.wikipedia.org/wiki/Code_smell) by causing the programmer to [refactor](https://en.wikipedia.org/wiki/Code_refactoring) the software's [source code](https://en.wikipedia.org/wiki/Source_code) until it is both legible and extensible. It is part of an overall strategy of [agile](https://en.wikipedia.org/wiki/Agile_software_development) and [adaptive programming](https://en.wikipedia.org/wiki/Adaptive_Software_Development). &gt; --- ^Interesting: [^Object-oriented ^design](https://en.wikipedia.org/wiki/Object-oriented_design) ^| [^Object-oriented ^programming](https://en.wikipedia.org/wiki/Object-oriented_programming) ^| [^Interface ^segregation ^principle](https://en.wikipedia.org/wiki/Interface_segregation_principle) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clr3e1i) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clr3e1i)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I created a library that is similar in nature albeit, a bit more generic: [libdomain](https://github.com/cjsaylor/libdomain)
What? I'm referring to the constant context-switching that comes from having that many function calls.
Exactly. Unfortunately, implementing a DI pattern in Tiger wouldn't let me use functions globally and result in: $doc = new Document(); $doc-&gt;add($doc-&gt;createElement('body'), function (Element $el) use ($doc) { $el-&gt;add($doc-&gt;createElement('div', array('id' =&gt; 'abc123'), 'Hello World')); }); Which I was trying to avoid. &gt; *Sidebar*: DI is just an obfuscated term for a common pattern I'll wager developers naturally come up with. I, myself was like, *so...?* the first time I encountered the word.
This reminds me a lot of Groovy's XML libraries. It's an interesting interface. I'd probably see more use out of it, if it were some XML generation library rather than an HTML one because there are plenty of templating systems already out there. But it's another take on how to output HTML from PHP in a cleaner way. Very cool!
I created https://github.com/donatj/PhpUserAgent several years ago. It's pretty popular and I keep it up to date to the extreme, eg it already detects the "New 3DS" despite not being available in mot regions. That and the code is extremely simple and straight forward, literally two reveres. Much simpler and more accurate than others if you ask me.
True, but you can already do FP by sticking with closures. I do support that RFC though, there is no reason to keep named functions outside.
I am not involved in the development of this library so I'm not the best to answer, but it detects consoles, even for example [the Dreamcast](https://github.com/piwik/device-detector/blob/master/regexes/device/consoles.yml) (I find that rather funny :p), but also cameras, cars… See https://github.com/piwik/device-detector/tree/master/regexes/device Have a look also at [all the OSes that are detected](https://github.com/piwik/device-detector/blob/master/regexes/oss.yml), that's pretty crazy. I know there is a lot of activity to keep it up to date, and it's used by Piwik (web analytics software) so there's the assurance that it's going to be maintained for a long time. IIRC, this library was extracted from Piwik itself, so it's years and years of data.
It's strange seeing you being downvoted, as when PSR is being criticized (spaces over tabs, etc.), people get defensive quickly saying "no one is forced to follow PSR! they are just a proposal!", but that's not what I'm taking from this conversation. I'm personally with /u/Rican7 in that a common style over personal preference is beneficial to developers. On the other hand, you're not claiming to follow PSR, and the few people who will interact with the source code won't have any problem follow its style, as it's clear and easy to follow.
Windows. *Edit: A windows guy can't see a neat Mac application and wish for it to be released on a platform he uses?*
From what I remember you have to use the right session handler and session storage classes to construct the session provider. When I get to a computer I will give a more detailed example. I did a similiar thing in a legacy project I work on but I used PdoSessionStorage and I was able to just replace all session_start() calls with calls on the symfony session so I didn't need to use the bridge. IIRC the idea of the PhpSessionBridge is that when you call $session-&gt;start() it doesn't try to start a session but only copies data from $_SESSION so you have to call session_start() before that.
Anyone care to explain how Pimple handles IoC behind the scenes? I went through the code, but couldn't understand much of it. I don't know why some people add overkill abstractions and fancy names to make their code harder to understand than it actually is. So, I am stack with pimple for now. :)
Which of the configuration-centric ORMs in PHP provides for **versioned tables**? I'm still seeing manual SQL ordering/grouping as easier, as I'm unsure which provides for record/model retrieval without replicating that in a query builder or having to use a [history table or e.g. current flag](http://en.wikipedia.org/wiki/Slowly_changing_dimension#Type_2) workaround. For instance I'm using a semi double-revisioned scheme: title TEXT -- primary key content TEXT -- whatever content version TEXT -- visual version t_published INT -- updated for new version t_changed INT -- ordered revisions But let's just assume only the `t_changed` timestamp increases whenever a new version for a `title`d entry gets stored. (And the t_published is just handled by application logic or a trigger.) How'd you set up a table model for implicit ordering and retrieving only the lastly timestamped entry / updating with a new timestamp in your favourite ORM/CRUD? 
That is indeed an issue that some of the highest ranked search results are more than a year old (in this case two and a half years). That's the "problem" with technology - it moves so fast.
Compared to the Piwik/DeviceDetector, you get bonus points for very straight-forward and well-formated readme page, installation &amp; usage instructions, as well as Packagist support.
Pimple doesn't really handle IoC. It's an IoC *container*, meaning that the only thing it handles is dependency resolution. In short, an IoC container is part registry, part factory. It is a factory as it creates new instances of registered resources, and it's a registry as it looks up shared instances and returns them rather than creating new instances if they already exist. Additionally, a factory can request its dependencies from pimple, invoking other factories (which can in turn request their dependencies) thus resolving the full object graph without you having to instantiate those yourself. As for actually injecting the newly created object, that's up to you. 
I am using laravel together with the eloquent orm. The orm creates timestamps and updates them for me when I save the object. Retrieving the last edited would be something like Model::orderBy('updated_at', 'desc')-&gt;firstOrFail() Hope this answers your question :-)
Just wanted to point out to avoid confusion: DeviceDetector is on Packagist too. Maybe the readme should state it, but it's kind of the standard nowadays.
And malus point for not specifying what is returned in case detection fails. That's the trend I hate in libraries replacing their documentations with a short readme these past few years.
Thanks for all the suggestions. PHP-FPM, Composer, Community overview and PHP-FIG are now included as well. Frameworks and applications will maybe come as well. There are a lot of those and I appologize for leaving them out here for now. They are of course important part of PHP but I was trying to focus here more on PHP.net project and PHP language evolution specifically.
Looking around in the results, the amount of SQL injections possible in those project is also remarkable. 
We're looking for a PHP guru rockstar! Must have 10+ years of experience with Symfony 2 and AngularJs!
I wrote exactly this for my interview test at my current gig. It works great, but I never use it. I have always been a fan of concrete HTML templates. You never know when the implementation is going to change and having your ui imprisoned in code is never a good thing. 
I haven't but it's definitely a popular one. Might go this year, actually.
Sunshine PHP is an amazing conference. I went for the first time last year (as a speaker) and it was one of the better conference experiences I've had!
Why would you need a package for Disqus? It's just a javascript snippet you put into your template(s). I use it primarily because I can switch out the backend without ever having to think about migrating comments/accounts.
I've been to every one so far (and will be speaking again this year), and it's one of my favorite conferences. Great people, great organization, great venue. I'll see you there!
How does the transition from PHP to C work? I know that PHP's basic functions are written in C, for example, the sort function is defined here: https://github.com/php/php-src/blob/master/Zend/zend_qsort.c If I did that myself, I'd call a C file using a PHP line of code, or something of the sort, but what is the process like when we call a default PHP function? Also, I'm assuming that since this is in C, writing your own sort function in PHP will ALWAYS be slower than using sort(), since PHP is inherently slower than C, is that correct?
Yep, I found this confusing for the longest time. Me: "I want to update my composer dependencies, so I'll use `composer update`!" The Internet: "What are you, a fucking idiot?!" Me: "Um. Yes!" 
I had quite a bit of experience with FOSCommentBundle. My recommendation is don't use it. Extending it was very difficult, so much that I ended up rewriting the bundle. The particular difficult challenge I faced when trying to work with FOSCommentBundle was to implement my own ACL. There is a limitation with their api that does not associate a comment with a thread so I could not grant/deny permission based on a thread. If you need a simple/basic then you might be able to use FOSCommentBundle however, if you need any customization, I would stay away from it.
Does version watch and security alerts (which VersionEye doesn't do)
One way to see exactly what happens is to strace the program (trace system calls and signals) and watch the output. I wrote a C program that got straced to 39 lines, and its PHP equivalent was 1117. The programs were simple file counters (circa 1990s webcounters), without any file locking. See full listing at http://pp19dd.com/2013/01/c-is-now-a-dominant-language/ The C version had this number of calls: [mmap] =&gt; 10 [close] =&gt; 4 [fstat] =&gt; 4 [open] =&gt; 4 [brk] =&gt; 3 [read] =&gt; 3 [mprotect] =&gt; 3 [munmap] =&gt; 3 [arch_prctl] =&gt; 1 [execve] =&gt; 1 [write] =&gt; 1 [access] =&gt; 1 [exit_group] =&gt; 1 Whereas the PHP version had this number of calls: [mmap] =&gt; 249 [fstat] =&gt; 148 [close] =&gt; 124 [open] =&gt; 123 [munmap] =&gt; 114 [mprotect] =&gt; 94 [read] =&gt; 94 [ioctl] =&gt; 30 [lseek] =&gt; 29 [stat] =&gt; 24 [brk] =&gt; 21 [lstat] =&gt; 17 [rt_sigprocmask] =&gt; 6 [rt_sigaction] =&gt; 6 [gettimeofday] =&gt; 5 [getcwd] =&gt; 4 [access] =&gt; 4 [futex] =&gt; 4 [fcntl] =&gt; 2 [socket] =&gt; 2 [connect] =&gt; 2 [getdents] =&gt; 2 [set_robust_list] =&gt; 1 [execve] =&gt; 1 [sched_get_priority_min] =&gt; 1 [sched_get_priority_max] =&gt; 1 [arch_prctl] =&gt; 1 [statfs] =&gt; 1 [exit_group] =&gt; 1 [sched_getparam] =&gt; 1 [getrlimit] =&gt; 1 [sched_setscheduler] =&gt; 1 [write] =&gt; 1 [set_tid_address] =&gt; 1 [sched_getscheduler] =&gt; 1
I am planning on going for the first time this year -- it was recommended to me at the Symfony Live Conference in New York this year.
Awesome, looks much nicer now :) 
In short, this is https://security.sensiolabs.org/, but with notifications? 
I was there the past two years. It's one of my favorite PHP conferences. You'll have fun and learn a lot. If anyone is on the fence about going, just go. It's worth every penny.
but whyyy.....
Unfortunately, I believe the only way is the POST-REDIRECT-GET pattern you described. HOWEVER, the 205 status code should do this - if I'm reading it correctly - although I've never used it and wouldn't be surprised if it wasn't fully implemented in current browsers.
Never been, I really liked the jQuery con in SD last year. Learned a lot and got to see what technologies on the web are going to be coming into play.
What will you be speaking about? And I promise I won't use this information to come to your session and heckle...
Looks good, what does this offer that [CLImate](http://climate.thephpleague.com) doesn't?
Amazon Opsworks has possibilities for all your requirements but it's surely not as high level as Elastic Beanstalk or AppEngine. It does need some operational work but it's not very hard to manage.
So it's literally just for clearing fields, but the originating POST Header data will still be intact?
If you reload the page, the POST request should be resent, yeah. Also, 205 isn't really well-supported amongst browsers. 
I was noticing that as well. Most seem to treat it as 204 or 200.
Linux.
You could go Heroku with postgres but that can get very expensive if you start adding plugins
[Here's the abstract](http://2015.sunshinephp.com/talks#beyond-design-patterns): &gt; Many people teach design patterns as a fundamental step to Object Oriented Programming. They are so universally seen as important that almost every single programming conference that I have been to has had at least one talk about them. They are quite often used as interview questions to test a candidate's OOP knowledge. However, just like inheritance, they are not needed for OOP. And just like inheritance, they are a distraction rather than a foundation. Instead of focusing on patterns, I suggest focusing on learning about abstraction and communication. Why? Come and find out!
awesome. I'll keep an eye out for it.
I understand that this isn't exactly a decisive answer, but you should adhere to a known standard. I personally use PSR, but any from this list should be fine: [http://www.phptherightway.com/#code_style_guide](http://www.phptherightway.com/#code_style_guide) EDIT: Also be consistent.
The problem is that the app is written for MySQL. IIRC ClearDB was available in Heroku too. Not too keen about it though. 
**Full Disclosure** I work for Engine Yard [Engine Yard](https://www.engineyard.com/techstack/php) offers: - PHP 5.4-5.6 (with most of the popular extensions, and it's easy to add others) - We run an nginx/php-fpm setup - With automatic composer support on deploy (if you're using it) - HA/replicated MySQL (Percona Server) with a dedicated team of DBAs as part of our support infrastructure. - Cronjobs - Multiple domains with SSL certs - We support the Dublin AWS region and the newly added Frankfurt region is on our roadmap (with no current date). The only thing we **don't** offer is autoscaling, however we used to with our Orchestra PHP Platform and found that most people like the *idea* of autoscaling instances, but not autoscaling **bills**. We *do* offer super easy scaling with a few clicks — and you can scale your web, DB, and other nodes separately as your needs require. If you'd like to learn more, I would be more than happy to put you in touch with one of our support engineers who can get more information about your needs and come up with a solution that will meet them. &lt;/shill&gt; :)
Went through a similar process, but instead of re-writing it I extended the bundle and re-implemented parts as I also needed other functionality (voting, etc). FOSCommentsBundle is good until you need complex requirements.
Configuration mostly. Different configs for different environments. It also gives you a simple twig function IIRC
I ran into issues with scopes. It seemed most classes used private scoped properties so when I tried to extend and reimplement some functions, I couldn't. 
Obviously I love it because it uses [Aura.SqlQuery](https://github.com/auraphp/Aura.SqlQuery) under the hood. :-)
A heads up, you'll probably get downvoted because this belongs in /r/phphelp
It's for system admins. If you ever used Ansible, this is kinda similar to Gathering Facts, but does it in a language familiar to pretty much every dev. &gt; And for simple things like getting process ids etc one could just as easy call a shell command. Hmm, this is made to work on a cluster of servers. You can query process IDs in hundreds of servers in one command. It's extensible, so you can write your own extensions to query whatever you need about the system. In a few months time, a few extensions should be popping up. Obviously, this will look utterly useless if you manage less than 5 servers. 
You may want to reconsider your section on Sublimall, as the creator is shutting it down on the 1st of December due to it being too much work. You can still host it yourself using [https://github.com/socketubs/sublimall-server](https://github.com/socketubs/sublimall-server) though.
PM me. I'm open to having my mind changed. :)
I'd suggest looking at the table/row gateway pattern such as the one in zendframework as it basically does what you're describing AFAIK.
Reddit hug of death. 
My wife will be 39 weeks pregnant. I probably won't be going this year. But it looks like a good one.
A bit late to the party, but does anyone know how i can convert a csv file to text and read it in php? 
+1 :) I would recommend OpsWorks over Elastic Beanstalk.
Congrats 
DO IT.
Thank you!
I was there last year and am planning on going again. I learned more in the three days I was down there than months of googlefuing. And Miami in February is a nice bonus. If you go make a point to go to the early learning day, well worth it.
As /u/Nicoon said, that's not quite what `205 Reset` is for. It's actually a bit of a pity, one of our workflows in our software is posting checks one after another and we had tried using `205` to allow the user to do so rapidly, but it really wasn't supported. Now we use XMLHttpRequest to achieve the same thing, and as a bonus we can update running totals and let the user know their input was accepted and didn't just vanish into thin air after pressing Save :)
Hi Xeoncross, Interesting idea indeed. I have been also playing different variations, but have not thought this way. I was looking at the query executed Array ( [0] =&gt; SELECT * FROM user WHERE id = 3 LIMIT 1 [1] =&gt; SELECT * FROM information_schema.columns WHERE table_schema = DATABASE() ORDER BY table_name, ordinal_position [2] =&gt; SELECT * FROM information_schema.KEY_COLUMN_USAGE WHERE table_schema = DATABASE() AND REFERENCED_TABLE_NAME IS NOT NULL ORDER BY table_name, ordinal_position [3] =&gt; SELECT * FROM topic WHERE user_id = ? [4] =&gt; SELECT * FROM reply WHERE topic_id = ? [5] =&gt; SELECT * FROM reply WHERE topic_id = ? [6] =&gt; SELECT * FROM reply WHERE topic_id = ? ) `SELECT * FROM reply WHERE topic_id = ?` Isn't it the N+1 problem? When it looks nice not to write much configurations, at a later point I wonder how easy is for others to maintain. I am currently playing with [Sql Mapper](https://github.com/auraphp/Aura.SqlMapper_Bundle) and [Marshal](https://github.com/auraphp/Marshal) . My thoughts are there will be a write service and read service. The write service make use of insert / update and read service make use of getting data from the mapper and marshalling to make the objects. The source code is over : https://github.com/harikt/aura-sqlmapper-experiments . As I mentioned it is experimental, but looks good so far to me. Thanks to /u/pmjones and all mentors. Suggestion : I know you would have thought of `caching the schema`.
Thanks - wasn't aware of the other forum.
Why the `:` though? Doesn't seem to do anything useful. Why not something like return type definition in Go: func someFunc() string { } instead? Edit: seems I'm in the minority on this minor issue, and as I've stated, its my personal opinion based on my syntactic preferences. Nevertheless, this is an important RFC and I'm glad it has mostly all yes'
Just what we need, more tutorials on how to use Composer. 
Sorry. Can you elaborate on the problem it solves? You seem to have a problem I don't have and I'd like to understand what that problem is. 
While I can understand that from a language family perspective, I don't see why they shouldn't go with a cleaner looking (in my opinion) way.
we've been using elastic beanstalk at teamcoco.com for almost a year now and it has been great so far. getting the configuration nailed down can be a bit of trial and error, but for a simple app setup it should be pretty straightforward. having deployment and auto-scalling support integrated into the same tool is a huge time saver. security patches and version updates haven't been a big challenge so far. for the most part they can be done with YUM/RPM/APTGET updates in custom ebconfig scripts (http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/customize-containers-ec2.html). if you need to, swapping out AMIs can be done through the console and will trigger the environment to rebuild all instances with the new AMI. just make sure you have rollout and min-instance parameters set. elastic beanstalk has support for managing mysql/postgres, but we don't use it. we use RDS with multi-AZ support and scaling read replicas if needed. been very solid for us.
I think visually it sets it off (I feel like I'm talking about the drapes in my boudoir). I might scan right past the return type in your example.
I guess this is a matter of taste, personally I'd rather have the `:` it makes the intent clearer. And it has the advantage of being compatible with Hack (which is a minor reason, but still a plus).
By the way I had a look at the code of https://github.com/Xeoncross/DByte/blob/master/DByte/DB.php and I just wondered isn't that simple one. Looks nice :-) . It will be more awesome if you could add tests. ( And of-course something like PSR-2 personal taste ) .
I've been meaning to port getID3 to modern standards, more like a complete rewrite
I fully agree that its a matter of taste, and as I've mentioned in my other comments on this thread, ita purely my opinion that the : is not necessary. But I do agree that it provides a separator
Most of my projects are in php, python and go - hence my bias :) func (ptr Type) function() returnType{ } Just seems cleaner to me personally
Looks great! Good job on this RFC.
Oh Em Gee! Your kitchen must be horrendous! It's a style thing and I know you're just nitpicking but I think we can agree that just having the RFC itself and the (like mnapoli said, minor) compat with Hack makes it worth embracing. But hey, that's why we're here, to bitch and moan (at least that's why I'm here)!
Using coupon RDOPC1 you can get the course for $27!
this could allow method overloading at some point in the future!
i don't see a problem...
I think this more readable: function Iterator getIterator() {} Yes. From Java.
I don't think you read my original comment. Also, my kitchen is beautiful! 
I refuse to drink water until its fully finished and comes naturally sweetened! I refuse to drive a car because its unfinished because it doesn't come with a couch and a stove and a jet from the factory. Give it up and go back to whatever language you decree as complete, without realizing that no language is ever fully complete - they are all constantly evolving.
What part did I miss in your original comment? &gt; Also, my kitchen is beautiful! Oh, I think the PHP community will be the judge of that...
While I would love method overloading, most programming languages I know don't allow method overloading based on return types. 
This part: &gt; its my personal opinion based on my syntactic preferences Granite countertops, full cabinet set, modern appliances - its a darn nice kitchen. Now, excuse me - I have to go take my souffle out of my dishwasher and put my dishes back in the fridge. 
&gt; Your comment: its my personal opinion &gt; My comment: It's a style thing and I know you're just nitpicking I didn't miss anything. Now tend to that soufflé!
While i understand the usage of frameworks in the frontend sector more than in the backend sector, i would rather tend to: no frameworks. At least for "large scale enterprise" stuff. Why? Because applications in that sector mostly last for years, and if you once chose a framework, there is basically no way back without a full rewrite or a large scale refactoring which blocks development for months or even years. In 2007 we made a web editing backend with prototype.js (jQuery wasn't as popular back then), and it was a horrible pain in the ass to upgrade it every time there was a new version which would improve performance. Same i saw with other projects which used ZF 1. And Software always ages, some ideas always turn out worse than others, it has to be developed further. And this "developing further" is easier with your own code than with the code of others or even a "black box". I know i am alone in /r/php with that opinion, but a lot of PHP devs do not quite grasp the weight of the decision to use a framework. But it also depends totally on the people you have, if you have a bunch of good engineer, you can easily write your own foundation of code. If your team consists of young devs, the decision to use a framework could turn out to produce the better foundation.
argument parsing?
&gt; how i can convert a csv file to text and read it in php? First, CSV is itself plain text: you can read it like you would any other text file. Second, to parse it, you don't need a CSV library: use [`fgetcsv()`](http://php.net/manual/en/function.fgetcsv.php) if you're using `fopen()` for file input, or [`str_getcsv()`](http://php.net/manual/en/function.str-getcsv.php) if you're using `file_get_contents()` or another method to read the CSV file into a string first.
No, no it couldn't. And overloading is stupid.
Did you test this on Windows? You'll have fun with symlinks there - even if you're developing in Linux virtual machines.
This is a really nice RFC. Next to the phpng performance improvements, I'd say that this is the most important change in PHP 7 (unless scalar type declarations will land).
I totally agree, tbh. Just like /u/aikah said, if you're gonna do it with ":" for functions, you might as well do it for variables as well, or else it doesn't make any sense. Zero coherence.
This.
Does Stas vote against literally everything ?
Duplicate post: http://www.reddit.com/r/PHP/comments/2js2fn/im_british_so_i_know_how_to_queue_a_new_book/
What is "practical" depends on what you want to practice. See also [The Devil's Dictionary for Developers](http://paul-m-jones.com/archives/4724) under "pragmatic".
At the time of the previous post, the book wasn't published. It is now though.
So many people use the Laravel framework as a basis for their own project repos that it might be seen as tricky, as those who don't know to delete it would end up being very much restricted to what Composer components they can use in their application afterwards. laravel/framework could definitely have it. laravel/laravel could probably have it, if it could be removed from composer create-project somehow. 
Cool, will take a look :) Might want to update this: &gt; Learn how to use RabbitMQ to ~~seperate~~ **separate** back end processing from user facing ~~UI's~~ **UIs** [...] And this: &gt; You'll learn all about the different types of ~~exhanges~~ **exchanges,** the problems they are good at solving [...] 
Rasmus doesn't vote against everything.
People have (semi-legitimately) complained in previous return type RFCs that having `function type foo()` means that you can no longer search for `function foo` in a codebase to find the function definition. While I don't fully agree with that as being a reason to vote against a Return Type RFC, you can't dismiss it totally out of hand. And while I agree that having the return type before the function is more readable, that is at least in part because that is what I'm used to from C/Java etc. I think the opposite order, once you become used to it, will actually be more readable. i.e. when you read this outloud function foo(bar $bar) : array { ... } I read it as, "this is a function named foo, that takes an argument of type bar, and returns an array" which is better than: function array foo(bar $bar){ ... } which I read as "this is a function, that returns an array, and the functions name is foo, and it takes an argument of type bar". The things are just in the wrong order. 
Good point
The only problem with symlinks on Windows is that they require admin rights to be created.
So upgrading protoype was more of a pain in the ass than building your own framework from scratch and maintaining it? Sorry no.
You could always ask package maintainers (if they're using git) to provide a .gitattributes to eliminate these files: http://www.reddit.com/r/PHP/comments/2jzp6k/i_dont_need_your_tests_in_my_production/
If understood you correctly you're looking for [ReactPHP](http://reactphp.org/). It runs as a daemon and manages all the requests, so you are able to keep objects between requests. This is indeed orders of magnitude faster than the traditional PHP way, and people even managed to run Symfony on it, so there is a reasonable framework for you. But this all is still far from the state when it would be easy to switch to this from existing codebase. You are likely looking at a necessity of a complete rewrite and using not very stable software.
Can I just say that I appreciate it when people post links to voting / accepted RFCs in here? It makes it easy (for me at least) to stay semi-current. So, thanks /u/Hatte_keine_Ahnung
&gt; But is it really the most prevalent syntactic variant in C-style languages? Depends which C-like languages you mean. It's such a broad descriptor it's practically meaningless.
Thanks, there have been 4 sets of eyes (5 if you include mine) on the book &amp; even still people find typos :-)
Back in 2007 / 2008, Firefox implemented getElementsByTagName. This was a function which prototype provided too, but with a different return type. This caused a lot of trouble for us, and the only solution was upgrading prototype to 1.8 or 1.9, and because of BC breaks, this was causing a huge frontend refactoring. Prototype.js might be a bad example because contrary to jQuery, it does do bad practices like extending the DOM, but yes, actually had we invested the time and developed the functions we needed from prototype ourselves, this would have caused less trouble than using prototype. And i repeat: I understand the reasoning why people (myself included) use frameworks like jQuery for frontend stuff, but i am still critical about it. And look at it from another point of view: How do you sell your customer that his web app broke because the framework which you're using went incompatible with a browser and for an upgrade, he would have to pay you for weeks? Of course, your own framework can utilize stuff which becomes incompatible too, but that's a smaller refactoring in most cases, than upgrading a complete framework version.
I know this is not the point, and I know this is translated, but I can't get past the grammar here. Pragmatic is an adjective. I would accept a noun (pragmatism) to suggest that it is pragmatism that drives development. I would also accept an adverb (pragmatically) to suggest that the manner in which the driving occurs. But as written it makes absolutely no sense. Regardless... sure. Part of this argument is valid. Pragmatism is important, it means that all decisions should be rooted in reality and rationality, rather than opinion and ego. But sometimes pragmatism is a mask for everything from laziness to inexperience. Bad practise in terms of architecture can be dismissed as "pragmatism". This is especially the case when short-sighted decisions are made that affect the extensibility and maintainability of the system in the medium and long term. Just like real debt, there is often a case to be made for taking on a well understood technical debt. But there isn't a case to be made for creating a shit sandwich because you're too lazy to do something right.
Yes, like I said, this test did not attempt to solve the N + 1 problem, caching, DI, or any other "nice" thing that a finished library would need to solve. It was mostly about individual records being able to identify their own table object and figure out relations themselves.
This would actually be a more optimal solution. Does it mean the $_SESSION calls in the legacy app would call the database stored information, or does it need to be refactored to use $session-&gt;get?
I understand what you are saying but I think you are looking at it from the wrong perspective. This RFC has value regardless of what happens with nullables; just enjoy them where you can!
This syntax looks identical to how hacklang handles its return types. It definitely has the shortcomings of a language that had to be updated to include return types, and shows its roots in half-copying things from other languages. C syntax, which PHP can trace many of its syntactical roots back to, declares the argument type first then the name, but it also declares the return type before the function (eg `int foo(char *bar) { `), so PHP's type-hints tried to follow that syntax in order to be familiar. Other languages, including Go, realized that it often makes more sense to declare the type after, so both arguments and function returns come after (eg `func foo(bar string) int { `). PHP (and hack) have to split the difference, which is a tiny bit confusing and less than ideal, but it's the worst solution except for all the others that could be tried. Obviously PHP has a glut of odd syntax most of us would be happy to lose, and nobody's in a hurry to add more to that pile, but compared to the rest of the language this one's a drop in the ocean. Besides, the amount you can clean up your code when you can rely on a return type being either the specified type or null way, way outweighs the minor sloppiness of the return type coming after. I've been working with hack a lot for the past 6 months, and this style of return type hinting works extremely well. Like all type hinting, it's optional, so unless one of the 'no' voters can offer a compelling alternative RFC for how to type-hint returns, this is both a big improvement and one with 0 risk to existing codebases.
Or, don't, and store stripe tokens or authorize.net customer IDs. There is no good reason to store credit card numbers especially when they are so easily decryptable.
Or...hear me out...just don't do it.
The thing is, people who want return types are currently declaring them in docblocks (mostly for IDE support), and without the nullables, you can't simply switch to return types as `@return Foo` in docblocks also allows returning `null` without the IDE complaining. Is this RFC useful without nullables? Sure. Does it constitute a *complete feature*? I don't think so. 
Doesn't make it any less illegal to store credit cards information on your own server just because it's encrypted ;)
no it doesn't have anything. It's crap. This is spam.
Especially if you need to read a tutorial on how to do it. Also I think the PCI compliance guidelines are pretty stringent on this. 
Certainly we can agree on a bit of C semantic and stylishness. For instance Lisp, Basic and Ada/Pascal languages are easy to discern from `{` curly `}` bracketed languages. As to why listing [Erlang and Haskell in the comparsion list](https://wiki.php.net/rfc/returntypehinting?&amp;#fnt__3) seems inept for a comparison. HHVMs Hack on the other hand would be more relevant than C++ for substantiation. But again Java, C#, D, Vala, Dart are just a few of the more popular C-esque languages going with the C-style return type prefix. So I can't help but wonder if this syntactic preference is again just a \workaround\for\some\parser\deficiency.
That was a remark *at* IDE users. We emacs/vim/non-IDE users are slightly more proficient, and can certainly cope. No worries. Just don't reason syntax decisions with presumptions or misattributions.
It's not illegal, you just need to follow certain guidelines. It's generally (almost without exception) a terrible idea, but it's hardly illegal.
We don't have type checks for string or int in core, so it wouldn't be complete anyway. You'll still have docblocks for those.
that's true, it's not technically illegal. But you'll still get sued for it!
Due to not having any response from the TC, well, I guess the original source code found a new owner.
Let me try to rephrase the post. Most Developers want the same thing: RAD and maintenability. And the people invoking the X, Y or Z pattern/practice, sometimes are more dogmatic than pragmatic, as they do not improve the above said objectives. So why would they promote things that don't improve development? Sometimes because it makes them look smarter (it's cool to impress someone by invoking fency technical words, and as any human, developers are also sometimes guilty of letting their ego take over pragmatism. Don't developers use buzz words all the time?), because of systematic generalization (a practice might be useful in one case but not in another one), because of appeal to authority.. well, there are plenty of reasons to fall into dogmatism. It's quite common, especially in /r/PHP, and pretty annoying when someone falls on you and says you are an idiot for not using something like it's written in the bible.
As long as this gets implemented for interfaces, then we're good to go. Right now you can only do half contract enforcement whereby you can restrict what comes in, but not restrict what gets dumped out by that interface. It's very easy to violate LSP in PHP right now.
Backbone and marionette are a great combo that comes with tons of features and doesn't lock you in to a bossy framework. We are starting a new product with it right now. 
Also, they can't move parameter type hinting to after the variable due to backwards compatibility. The chosen syntax is really just the lesser of all the evils, rather than a perfect solution.
Yes, it works on interfaces.
Well being O(1) for Queues and Stacks is nothing new, so idk why you bothered putting those stats. Well perhaps you wanted to show that its not slower than the regular approach. Reusing a parent queue in the child queue is a god idea, but it has nothing to do with *persistence*. You use that word so much while in fact it has nothing to do with your implementation. Also: https://github.com/keyvanakbary/medusa/blob/master/src/Queue/PersistentQueue.php#L28 What if I called *new PersistentQueue(null, null, 0);* ? You would still consider it non empty 
Where can I find reasons why certain people vote no on RFCs? Is there a place to find this stuff? 
I just exclude "vendor" in PHPStorm, it's still smart enough to find classes and autocomplete it but doesn't clutter my searchs with the files in it.
Yeah, that's one of the reasons return types are needed. Only being able to half-enforce an interface is awful!
Sure. It means completely different functions get called by changing the types of arguments, and makes code hard to read. Default parameters, which PHP already has, are a better solution.
$14 to compare your solution to mine.... I'll bite! 
I don't see how default parameters solve the same problem as method overloading. Method overloading is a wonderful feature of statically types languages. Being able to pass a `$userId` integer or `$user` object to the same method and having the delegation handled by the language is much nicer than type checking at the beginning of the method.
Sued for what? You can store credit card info but you fall under the most stringent PCI security standards for network, software, and physical server access (SAQ-D). The standards are also loose enough that if there was a breach the business would assuredly be found liable and end up with huge fines. So depending on your merchant status you can do it. But you really, *really* shouldn't. If you're looking up simple encryption you'll never pass the rest of the SAQ.
&gt; `@return Foo` in docblocks also allows returning null without the IDE complaining. I'd say the problem is the IDEs not complaining. Why should PHP change to accomodate IDEs that don't follow their own rules?
^^ This. Very much this. Allowing null is a fundamental problem to any type system. The fact that IDEs allow null should have literally no bearing on what the actual type system implements.
&gt; you'd expect all type defs to be after a variable One way of looking at it is that input types are before, and output after. So `Foo $foo` makes sense as an input variable, because you're defining a precondition. But `function biz() : Baz` also makes sense because you're defining a postcondition. So it is consistent. It just may not be consistent in the way you were initially expecting.
I don't *have* to use gasoline to fuel my car. I can put all kinds of more "pragmatic" alternative fuels into the tank, and it will run. For a while. And I'll save some money in the interim. And if I go into a garage and ask the mechanics what fuel I should be using, you can bet that they'll all parrot the "dogmatic" answer of gasoline. When I tell them my car can run on other things, they'll all tell me I'm an idiot. I'll get mad at them for being impractical. I can't afford gasoline on my wages. Eventually, my car engine dies, and I'm back at the garage asking how to fix it. Now, they're all laughing at me and carrying on. I feel like an idiot. I should have just used gasoline.
Everything is discussed on [the internals mailing list](http://markmail.org/search/?q=list%3anet.php.lists.internals).
yes, I love having it in Go. In fact, next I would love to see multiple return types like Lua (or Go).
Next can we have multiple return types? It's nice in Lua / Go.
I suppose we could have tuple typing like Hack has, for use with list().
Most of the overloaded C++ and C# APIs I've used are horrible, as the overloads have different argument orders.
&gt; True, but I was giving an example on how *actual developers are using it right now.* Actual developers, as opposed to me and /u/ircmaxell? As someone who works on legacy code a lot, there's a lot of shit I see *actual developers doing* that I wish they wouldn't. edit: this comment sounds like I'm taking it personally, but rather I'm saying that people who may disagree with what those *actual developers* are doing, are themselves *actual developers*, and just because lots of people do something doesn't magically make it sensible.
Yes, but now you have two different methods. And doing that kind of polymorphism makes for code that is hard to understand without an IDE in many cases, or unpredictable in a weakly, dynamically-typed language like PHP.
I find it slightly amusing that the terminology for this is "type hinting". After all you are actually forcing the type.
Definitely agreed that it would be difficult to manage in a language like PHP and without an IDE. But all type-hinting in PHP is a little silly anyways :)
How is that an argument against overloading? Let me reiterate: if you have a bunch of different overloads of the same function, and they do completely different things, then the person who wrote them is a bad programmer. Basically, all you're saying is you used a bad programmer's code. So what?
And what? The word "pragmatism" is sometimes wrongly used? Yes. It's sometimes rightly used? Yes. Just like everything else. It's not easy for sure to know if something really deserves being called "pragmatic", and naming anything this way just for the sack of it doesn't mean anything. However, as I explained above, some developers have a tendency to bring up "ideas" repetitively, without any serious thought, for reasons I listed in the comment you are replying to. I wouldn't say some practice is more pragmatic than another. Again, that means nothing. However, repeating and taking for granted things you read before, is definitely not pragmatic, and just pain in the ass for everyone.
C++ says hi typename std::function&lt;TRet(Arg1)&gt; curry(std::function&lt;TRet(Arg1)&gt; f) Also I have no idea what you mean by this : = function name(): className {..}
Just voted :) (With the majority)
Indeed. Internet kudos to you \^_^
I'm personally a fan of the $ for variables and ending a line of code with a semicolon. The dollar sign in front of the variable helps me to find them easily when scanning through code (especially when I'm looking at code in something like wordpress's built in file editor, over ssh with no ability to use an editor with color coding, looking at code on reddit where there's no color coding, etc.). As for the semicolon at the end of a line of code, I like that I can split my code across multiple lines to make it easier to "read", without having to worry about new lines, tabs, or spaces causing issues.
&gt; That is a highly subjective topic, with tons of arguments on both sides. Let's not go there :) I didn't mean it as "you're wrong for allowing null". I meant that, as a topic, it's fundamental to the type system. It's a core-level decision that pretty much everything else is built upon.
It's an argument against overloading because it allows, nay, encourages you to do bad things.
&gt; It's a core-level decision that pretty much everything else is built upon. True, but PHP being a language where "anything goes anywhere" is the norm, out of all the "strict" things (like scalar types) *this* is the bit we want to be *really strict* about? Even stricter than Java? 
Heh, I'm just praying for the day that we are allowed to optionally do scalar type extensions.
&gt; We don't have type checks for string or int in core, so it wouldn't be complete anyway. Yes, but given the *massive* demand for proper, strict, optional scalar types I'm hopeful we'll eventually get them. Maybe not in 7, but *someday*.
I will probably get some flak for this, but I think Rasmus is an idiot. I wish that no one in the PHP community cared what he thought. He wanted to create a templating language like Twig or something, but it filled a hole in the web. Simply, PHP is much more useful because people have done things Rasmus didn't want to do.
That will likely never happen. As explained in the RFC, you can already have multiple return types in PHP5 *right now*.
A good IDE will let you take care of this already
&gt; this is the bit we want to be really strict about? There is no example in PHP today where we have post-condition enforcement (verify the right thing happens, after it's happened). So it's a new realm to explore, and to say "this is the bit we want to be really strict about" is a misnomer: function foo(Bar $bar) {} Calling `foo(null)` **will** fail. So there is precedent to not having explicit nullability. But again, as I was trying to say in my past two posts, I'm not trying to say "nullable vs non-nullable". I'm trying to say that the decision is fundamental to the type system, and should be based on *code*, not what an IDE does or doesn't hint.
Not strictly answering your question, but you can check out some of the frameworks available in PHP. Zend Framework 2 is my framework of choice.
I'm really searching this post for its point, but I can't find it. What am I supposed to learn from this?
&gt; I'm trying to say that the decision is fundamental to the type system, and should be based on code, not what an IDE does or doesn't hint. And no one is arguing that? The only reason I mentioned an IDE at all is to show that this is expected behaviour for a lot of developers *right now*. Any discussion on allowing nullables should keep that in mind.
See the new RFC http://www.reddit.com/r/PHP/comments/2l7xlk/rfc_return_type_hinting_vote/
Rasmus isn't an idiot. I think his opinions shouldn't just be disregarded like that. He's supported plenty of things we all benefit from.
&gt; to show that this is expected behaviour for a lot of developers right now. Disagree. The expected behavior right now is to not trust the return types at all. *Anyone* who trusts the return type of documentation deserves the code that will break when it lies. At least with a return type, there's enforcement.
That'd definitely be cool as an optional feature!
&gt; Note that while Codex is pretty much feature complete and good to use in production, I am still working on the documentation here. The irony! It burns me!
You should use Twitter Snowflake's formula: - time - 41 bits (millisecond precision w/ a custom epoch gives us 69 years) - configured machine id - 10 bits - gives us up to 1024 machines - sequence number - 12 bits - rolls over every 4096 per machine (with protection to avoid rollover in the same ms) or use GUID. It's a fun exercise, but I wouldn't do this in production. 
There's no point re-inventing the wheel. If you just have one server, just set the server ID in the Snowflake formula to 0.
Haha! I know. I got antsy once I was done coding and wanted to share it, so I jumped the gun on that one. All my focus is on wrapping up the documentation at this point (and squashing bugs that creep out).
Eventbrite clone in Php. Evenbrite runs on Django/Python
I want to add that while GUIDs are fine in the **right** context.. Incrementing keys index better. Use both and index on the incremental. EDIT: I recognize this is specific to SQL Server: [http://www.sqlskills.com/blogs/kimberly/guids-as-primary-keys-andor-the-clustering-key/](http://www.sqlskills.com/blogs/kimberly/guids-as-primary-keys-andor-the-clustering-key/) EDIT2: Which is, in my opinion, a FAR superior SQL server.
Totally fair, just felt like being a dick about it. :)
&gt; I don't want to make another WordPress-like cms Seriously, though, I think there's actually a space in the market for a **good** Wordpress equivalent. 
This one https://www.eventbrite.it? Thanks for the reply
I'm thinking about changing the configuration number to the last part of the IP. Usually all the PHP servers are configured in a cluster behind a proxy so they should have the same block.
Yes, and a CMS can be almost anything actually. It can teach database design, internationalization, MVC, input sanitation, and a host of other things that most sites need. Personally, I'd build an API for an Angular app. People really want to hire Javascript guys right now.
As a personal project - I think this area needs a real re-work, and there is a HUGE market for this. PHP, in my opinion, has matured past these projects.
Does this have version control, like Git integration? How are my FTP details secured? Also, changing code on a live server is a bad idea (Even though it's common to do).
I am not a big fan of this. Sure its nice when your coming from java but that's about the only plus I see. I find this rfc proposal much more readable but its all preference I'm just happy to have return types.
There's so many already. Bolt? Craft?
Horrible, horrible idea. Just because you can, doesn't mean you should.
Full calendar is really good. I've used it for nearly 4 years now. It is however just a front end. You'll need to write your own backend
I absolutely love it. When I started using Laravel (almost a year ago) it was a real game changer in my development career and skill level. I've learned so much from it, and continue doing so. It's given me an appreciation for design patterns, architecture, and documentation. I highly recommend [Code Bright](http://daylerees.com/codebright/getting-started) and [Laracasts](https://laracasts.com/) (Laracasts is *insane*) to jump with into the waters of Laravel.
&gt; Well being O(1) for Queues and Stacks is nothing new, so idk why you bothered putting those stats. Well perhaps you wanted to show that its not slower than the regular approach. Persistent queues are slower than regular queues. That's just shows that the complexity of the persistent queue is still the same as a regular queue. &gt; Reusing a parent queue in the child queue is a god idea, but it has nothing to do with persistence. You use that word so much while in fact it has nothing to do with your implementation. I'm not sure you understand what a persistent queue is... &gt;What if I called new PersistentQueue(null, null, 0); ? You would still consider it non empty You're supposed to create a queue by calling the "createEmpty" method. As long as you construct the queue properly that won't be a problem.
Excellent! Now we can type hint the return type to ensure consistency and defensive programming! Unless it's a number. In which case, fuck you.
You seem to be missing everything that is being explained in this article and especially the one he linked to.
I declare dependencies `guzzle 4.*` and hope that everyone starts SemVer'ing.
Very nicely done, was hoping someone would do this in PHP using Laravel. I recently found [Raneto](http://raneto.com/) which is similar but in NodeJS. Only recommendation would be that you simplify down that base theme so it's super barebones and easy to customize.
well, that's up to how php handle `symlink` in Windows :)
I would say forget about you're going to do it in php .. just think on something you can build, or something you can solve.. chances are you will make it on php
also, server-side is not the only choice .. there's plenty of room for innovation in other areas, specially those where no one tried before.
If you set the session handler properly then session data will be accessible through $_SESSION. The problem appears when modifying it because the symfony session iirc doesn't have any knowledge of $_SESSION. I think that what i did was overriding the session object to make the sets to both and the gets fallback to $_SESSION. Btw the session storage isn't very important for this. It doesn't make any difference. I used it only to not introduce too much change at once in the legacy app i was working on. 
`uniqid('', true)`
This is why a reason should be required for a no vote. That's actually a really fair criticism, and I totally agree with him. But without that context it just seems like naysaying 
I understand that you're not talking about us. That is my entire point. My point is that because some us are doing something that doesn't make sense, that does not mean the rest of us should be doing the same thing. You are saying that it's lots of us and they are *actual developers* and I am reminding you that the rest of us are also *actual developers*. Look, if a docblock I write says my function returns a Foo and my IDE just imagines that I also want it to sometimes return a null value, then I'm using a crappy IDE. There really is nothing theoretical about that. It is plain common sense. If I want to return Foo or null, then there are docblocks for that and I need to use those. You were saying that return types should always be nullable because lots of developers use IDEs that automatically assume that any function can return null. Look I understand the use case. It's for models. Well give your damn model functions a mixed return type and declare them as such. Or use collections that can be empty. Or make a null object. Pr throw an exception. Also get a decent IDE.
That's like saying keyboards should be banned because people might write shitty code with them. We shouldn't encourage bad programming, should we!
If you want to lock down the version of your component's dependencies, you can do so in the composer.json, no? Just specify a minor version (4.1.*) or even a bugfix version (4.1.3). Personally, I start by assuming my dependencies will follow semver, so I declare them as ~4.1 for example. If later on I find out 4.3 breaks things and the author of the dependency won't fix it, I can change it to &gt;=4.1, &lt;4.3 I still think committing composer.lock for a component (packagist package, reusable library, whatever) is always wrong.
Build an interface that allows end users to "connect" different components (could be as simple as string parsing or as complicated as remote API lookups) and chain together processes which can then be automated. Seed the component database with a few examples - demonstrate automation ("set the timer on this job and it'll run every day until it finds X result on a web search"), batch processing ("use the file reader component to perform X operation on every file in the specified directory"), etc. Selling point: provides a functional teaching tool for users who don't consider themselves programmers (demonstrating your knowledge of programming and the need for accessible information technology systems). Bonus points for a user-friendly UI. Er... you've got three years full-time to put it together, right? /s Hopefully you appreciate the brainstorming, in any case :)
**Idea #1** A "website manager". Vague, but I can't think of a better term... By this I mean a web based system where I keep records of all my: * servers * websites * domain names * SSL certs * clients * keywords This is something that would be useful to many of us web developers, and should be pretty easy to develop. A nifty feature would be generating a network calendar file (that you can access from outlook/thunderbird/google calendar etc) that contains all your domain and SSL expiry dates, with some reminder settings. The expiry dates can be automatically scraped from whois records for most TLDs. The keywords could be used to scrape Google etc to check your SERP rankings. **Idea #2** There doesn't seem to be much in the way of (self-hosted, web based) easy to use accounting systems for the basic task of importing bank transactions, categorizing them, then generating some reports. Everything I tried had one of the following problems: * Too simple: many just generate invoices and that's it, not made to handle your expenses etc * Too complex: Big ERP type systems * Tedious interfaces for basic tasks such as just looking at your full ledger. Many small annoying details like having to constantly enter common dates, rather that just listing everything by default, or showing current/previous financial year. Here's some good examples of closed source web based systems: * https://www.waveapps.com/ * http://www.saasu.com/ * https://www.xero.com/ They're all easy enough to use for non-accountants, and cover the functionality most small businesses need. In the end for my contracting work and personal finances I just programmed my own ugly, but extremely straightforward/fast system in PHP, which categorized transactions based on the regex rules automatically. From there, the reports are easy to generate with a bit of SQL.
Is there any particular reason that this is built with Laravel? Wouldn't it be better to keep it as a framework agnostic tool? I'm really just asking, not trying to be a dick.
Really? Your mechanic just says gasoline? And you claim that isn't dogmatic? Any car that comes into the shop, "put some gasoline in it". Without checking if it has a diesel engine? Or is electric? Runs on hydrogen or compressed air? Go ahead, put gasoline in your diesel car. 
It matters not the language, you should not use global variables. It's a poor coding practice which violates scope isolation and introduces global state, which in turn makes the program unpredictable. Imagine a school class where each student is tasked with writing an essay about their experiences from the summer break. Only that they have to share the same paper which they all write on simultaneously. 
&gt;De beste stuurlui staan aan wal &gt;Literal Translation: "The best helmsmen stand on shore" &gt;Meaning: "The watchers always know better than the doers" &gt;English equivalent: "Bachelors' wives and maidens' children are well taught." There are quite a few theories about how software should be developed. They are important to know because they give you a basis, a foundation to get started from. The skilled developer will also know when theory should go out the window. In real life there always multiple factors to consider and many of them overrule theory for the simple reason of survival. If theory is to expensive or takes to long, it has to go. Yes, you will pay the price but the point often is, that you will still be around to pay the price. Many a web development project has a very limited budget, there aren't enough developer, not enough skill, not enough time and not enough testing. Often you have to just accept to implement it in bad way, in order for the project to survive being into stay relevant. Simply put: If you got 1 month to develop a project and do it badly in 1 month so it starts generating money this is better then doing it right in 2 months but having to stop after 1 month because you are now bankrupt. As a lead developer my job isn't so much to code better then more junior developers but to stop junior developers from spending to much time on developing "perfect" solutions that are never finished. Yes, very impressive that you can develop the PERFECT mail campaign in 6 months... it should however have been finished in a day because marketing only thought of telling us about the need a day in advance. No, we can't just tell them to reschedule Christmas. To wrap it up: Code what you need to code with the resources given. Not what you want to code if you had an infinite budget. Research Microsoft and its first development of Office. Even they couldn't do it without setting constraints and they had as near infinite a budget as you can get.
The theorists will tell you not to. In reality... it depends. Where would you put the variable $debug = true/false. It could be used anywhere in your code to do some debugging if set to to true, do you pass it everywhere, to every class, to every function? Or do you make it part of the global namespace somehow? There are lots of reasons not to do it but somehow most of them seem to come down: "someone could do something nasty". Well, that someone is you, so just don't do it. I have for instance in recent years taken to using a singleton instance for "loggedInUser" so anywhere in the code I can get the details of the logged in user without having to pass it. Same with DB and Log. Lots of people will tell you you need to pass these in as dependencies because... and then they come up with list of situations I never ever have run into in practice. But hey, they are smarter then me... so they must be right... and then you get Laravel that has a singleton DB and a singleton Log... so clearly not EVERYONE agrees. Globals can get bad if you don't name them properly and/or use them inconsistently. But ultimately it is like using a seatbelt in your car. Should you always use one? yes... unless you have a very good reason not to and know the risks involved. When people give you reasons not to do something, ask yourself, does it matter to me? You are not coding the OS for a nuclear reactor. You are coding a silly little website that probably will be replaced in a few years.
&gt; When people give you reasons not to do something, ask yourself, does it matter to me? While i agree with most of what you said, i'll add "**will** it matter to me?". Singletons, statics and globals might work for a while ; but scalability of your software will be an issue at some point. Might be a problem if you're interested in long term evolution and maintenance of your software ; might not if you're just protoyping, or building something shorter-lived.
&gt; But hey, they are smarter then me... so they must be right... and then you get Laravel that has a singleton DB and a singleton Log... so clearly not EVERYONE agrees. Most likely you would also make mistakes if you start to write code in .NET and you don't have a background in that area. The difference between "mistake" and "poor code" is when you accept your mistake and you try to fix it, compared to being stubborn and telling everyone that: *If it looks like a duck and walks like a duck ... its a Facade*. You will change your mind regarding globals when you will start to write tests for your code. 
ehhh it depends. Geo-distributed apps are not necessarily linked and in the same network. It's probably overkill though, so last part of IP should be fine. 
awesome
If your application survives and makes money, you can hire people who can do it better. If you application never sees the light off day, it doesn't matter how scalable it is. I seen lots of unmaintanable code but I seen also plenty of projects that never got out of the door. Software that generates money can spend money on being improved. Software that doesn't, can't. Edit: thanks for the gold stranger. 
Much thanks for the idea but I'm at the end of the 3 years, I just have some months, 1 year max. 
This require solid knowledge of security, I can try to develop a security login library but I'm pretty sure it will be full of security issues. But nice one, it's still a pretty good idea! 
No, but do I use a handful of define() which are like global constants. Is there any problem with those? They're really helpful in some cases.
Fuck no.
GLOBALS in php is kind unusual but generally speaking globals just aren't required if an application is well structured. If a component needs a db connection the DIC container can just give it one. It doesn't have to be more complicated than that. If you find that one of your classes has so many dependencies that it's unmanageable the real problem is your class, not your dependency management strategy.
ITT: People who don't know the difference between a Singleton pattern and global variables.
Think an hookable design pattern. Community will do the rest :P. 
global $db ahh ... back then when MC Hammer was still a thing! the only globals i use nowadays are the superglobals $_GET / $_POST etc ... and usually just once per call, transfering them into an object that handles them, code never acesses them directly except this first time when they are "saved" to the object and secured/sanitized
Static variables (on classes) are global variables. End of story.
&gt; It matters not the language, you should not use global variables. It's a poor coding practice which violates scope isolation and introduces global state, which in turn makes the program unpredictable. Simply false. Like goto, nothing in a language is ever evil, it's how you use it that makes it evil or not. The parroting of "globals are evil" needs to stop. In the early days of OOP even the best programmers in the world were saying how evil it was and how only idiots would use it, now it's common practice and we all expect everyone to understand and love it. It's better to say that globals tend to be poorly implemented, leading to bad/unpredictable programs than to just flat out say globals are bad. The thing is, global variables are perfectly fine to use, you can even develop something of a system around it if it scares you too much. That's what patterns like the Singleton or Blackboard were invented for. However as with most software design patterns, you don't actually have to implement it to use it. So, a global is just fine if you understand what it does and why it's there. After all, your program starts in global scope, at least something has to be there. Simply putting your entire program behind a single interface just to pat yourself on the back for not having anything (else) in global space is a silly practice. There are plenty of situations where a global is incredibly useful, for example, in your example. In your case the problem is not the location of the paper, it's how each student interacts with the paper. When a student writes to a paper, the paper should subdivide itself into chunks, one for each student. When a students writes on the paper, it should automatically go to the right chunk. OOP in a nutshell, which is fine. But where would you store the pointer/reference to the actual paper? Are you going to waste time and energy to pass that down to every student or do you simply place it on the teacher's desk and tell everyone to write on it? In case you'd pass the paper down to every student, you'd also potentially create spaghetti code, since the student doesn't own the paper and needs to be aware that others can write on the paper as well. It makes much more sense to declare the paper as a global, so that everyone knows it's not theirs and others potentially interact with it as well. **tl;dr**: Limit variables to the scope for which they are needed, don't assume they need to be deeper just for the sake of it. 
Why is this even coming from a database? Just make it an array or something and cache it, and it will be much easier to work with, without hitting your db needlessly every time.
There are quite a few of these, it would seem: * https://github.com/PhileCMS/Phile * https://github.com/picocms/Pico * https://github.com/circa75/dropplets * https://github.com/kevinbluett/LotusCMS-Content-Management-System There was one, I can't seem to find the link, that was the entire CMS in a **_single file_**. The index.html would load a boat load of JS and then ajax in your index.md. Any links to local content (other .md files) would then change the URL hash (#) and ajax load that MD. It worked pretty dang well, and in a few browsers you could even make it work locally. ... Ahh, found it: [MDWiki](http://dynalon.github.io/mdwiki/#!index.md)
Singleton pattern is slightly different in that it's not only a global class but enforces internally that only a single instance may ever exist. In other words, it has all the downsides of globals plus an additional artificial restriction which is usually assumed falsely. In other words, Singletons are a stupid design pattern, and you probably shouldn't use them except in very specific circumstances (and no, logging and db connections are not those circumstances).
When you say it like that, you make it sound less involved than it actually is. It's pretty involved and you should use a payment processor unless you're a payment processor.
&gt; A shared single $db handle is what most small to midsized applications need. It's not always sharp to overplan for multiple storage backends. YAGNI. As someone who's about to rebuild a medium sized app basically ground up because someone like you made that YAGNI assumption (when it's really not any harder to do it the right way), I say: Your code is bad, and you should feel bad.
When it's "really not any harder to do it the right way", then why would it induce a complete rewrite to apply the "not any harder" part? Are we possibly misattributing something?
No, it's almost invariably a disastrous idea. I said that. I'm just arguing against the use of the word "illegal". It just isn't. The statement is outright wrong. 
It's not really any harder if it's done correctly when the system is initially developed. Unfortunately, once an entire system has been built around a fundamental YAGNI assumption (in this specific case, singletons for db and frontend / output among other things), it becomes very difficult to refactor (since these assumptions are used when developing the rest of the system) when those assumptions are proven wrong. That said, I agree with the fundamental point of YAGNI, but only so far as to not artificially limit future changes which affect those assumptions (in other words, it's smart to not develop features you don't need, it's dumb to develop your system in such a way to make it very difficult to add those features later if you end up needing them). 
Your MyCoolStaticObject can also be modified by anyone at anytime.
This is very true. Facebook wasn't scalable at the start - they figured it out later.
Also, I don't want part of the IP leaking out into the world so I will probably bitshift a it a little. *updated:* https://gist.github.com/Xeoncross/f075f7745c9534e2a894#file-timeid-php-L5
This is just a global variable in an OO facade.
You are right, but I can control access, make it read only etc... How do you track the logged in user?
Do you know why Composer can't store packages into Phars despite all the interfacy abstractions and DI embellishments? Yes, it's precisely because of such initial conceptual design limitations. YAGNI does not mandate entirely-zilch planning ahead. It's about sound and practicability decisions. And more commonly the premature complexity bandaid is what's hindering future extensibility. Of course one could write application-level structural workarounds to e.g. multiple database backend support, despite it being an already better solved problem higher up in the stack (e.g. SQLRelay). And it's still entirely reasonable for compatibility (shared hosting) reasons IMO. Yet attempting to *predesign* layers upon layers of abstractions is not going to help implicitly with unforeseen scope changes. In particular PHP devs are a little buoyant with add-in modularity, when the actual design kings class is compartmentalization.
I think the idea is that you can add validation and access rules to the MyCoolStaticObject class, where you can't with a global variable.
[Some ideas from a previous asker](http://www.reddit.com/r/PHP/comments/28rm3q/what_i_can_make_with_php/cidtyoj) 
Funny! I've checked out both, and I have a Laracasts account. Jeffrey Way is like my person PHP mentor! 
[Dependency Injection](http://stackoverflow.com/a/130862)
I feel like a lot of the reasons why wordpress is bad are things that most blog-esque frameworks are subject to. It's hard to escape code rot, etc. on a project so large and old.
No reason really, other than it's simply something I'm comfortable with. When I started on this it wasn't a planned project - but more of a "hey cool, I can do this..." and it just snowballed from there. Laravel gives me a consistent platform on which I can build on top of - and something countless others are familiar with too. I do see where you're coming from though - with it being built on Laravel does make it *slightly* "heavier" in code and maybe makes it a little harder for others who are not familiar with Laravel to contribute or use it.
I've used MDWiki extensively in the past - it is definitely cool, but I found it extremely difficult to customize if you wanted to create a custom look for your documentation. The [Credits](http://codex.caffeinated.ninja/codex/1.0/preface/credits) page on Codex lists out the sites that I found inspiration in while I was developing this - MDWiki is one of them. The others you mentioned, I really wouldn't throw them in the same category as what I've built. Their aim is more of a CMS for personal sites/blogs through the use of flat files (which is the only linking element). You'd be doing a lot more setup work using those if you wanted to just have documentation - not to mention the initial design work. I'm not against any of those applications though. Codex will work for some people and not others - and that's perfectly fine. In the end, all that really matters is what you (and your team, if you're working with one) feel comfortable with.
&gt;That's what patterns like the Singleton or Blackboard were invented for. I don't know what the blackboard pattern is, and you're welcome to explain that, but I'd argue that singletons are anti-patterns as they too introduce global state and impose unnecessary restrictions. If you need a shared instance, there are other ways of solving it (such as by utilising an IoC container). &gt;There are plenty of situations where a global is incredibly useful, for example, in your example. In your case the problem is not the location of the paper, it's how each student interacts with the paper. When a student writes to a paper, the paper should subdivide itself into chunks, one for each student Oh come on. It's an analogy to demonstrate a problem. Stop over-analysing analogies. They're not meant to be an exact representation of the problem, but rather to communicate the gist of what the problem is. The problem is that you have multiple actors manipulating the same space. Additionally, I'd go as far as to say that globals stand in opposition with the SOLID principles (and also GRASP). And let's not talk about the technical debt. I maintain my position that it's a bad practice which should be avoided and that there are better ways of solving the problem. 
If you want to be innovative, look at [ReactPHP](http://reactphp.org/) and build anything using it. A CMS, DB engine, ORM, pretty much anything that requires I/O. ReactPHP allows PHP applications to be much faster because it's removing "run and die" nature. It's basically Node.JS clone for PHP. But this comes at expense of requiring all I/O to be done asynchronously. Many existing applications don't fit in with this model and it has a lot of space for innovations.
Constants are for putting text labels on numbers or values which have absolutely no possibility of changing (PI is a constant because it never changes) that would otherwise be unreadable. A lot of people use them to define configuration values like your database name, user, and password. They should not be used in this way.
&gt; In the early days of OOP even the best programmers in the world were saying how evil it was and how only idiots would use it You're greatly oversimplifying *that* argument. In the early days of OOP it was pretty terrible and hardware was orders of magnitude slower than it is today. Simply put, OOP was really horrible at the time the best programmers in the world were telling you it was horrible. As implementations and hardware improved, OOP became more viable.
The important thing to remember is they aren't globals, they're just request-scoped local variables that happen to have a misleading name. This idiom isn't considered taboo in any other language I've seen. If it feels wrong, you can achieve the same thing using a class with static variables.
&gt; “Object-oriented programming is an exceptionally bad idea which could only have originated in California.” – Edsger Dijkstra Dijkstra, enough said. He called it inherently harmful, completely separate from hardware capabilities. 
Commit the lock file when you want to be strict. Dont commit the lock file if you dont want to be strict. You seem to miss that its not going to be a workflow that everyone is interested in. For me, letting my package work with a wider range of versions is far more important than pushing the consumers of that package closer to dependency hell. If you are the primary consumer of that package and you want your dev team to all work on the same version, then yay. **Maybe** that's not the case.
Which is a fabricated quote, mind you. Dijkstra never said it. 
&gt; What we rebranded as "superglobals" are true global variables (and you couldn't write a web app without them, now could you?) The last large PHP website I wrote used the `filter_*` functions exclusively, and never touched the unsanitized user input from those variables.
An actual quote by Dijkstra on OOP: &gt;"For those who have wondered: I don't think object-oriented programming is a structuring paradigm that meets my standards of elegance" Which isn't really a statement that OOP is necessarily bad. &gt;Even then, plenty of quotes from other great programmers, such as John Carmack, who clearly see the benefits from NOT using OOP. I happen to know a fair bit about John Carmack and his position on OOP, and he's certainly not opposed to it. The reason why he sees a benefit in not using OOP is because he's mainly a game programmer and he deals a great deal with data-driven state machines. Since games rely a great deal on mutating states an inheritance model doesn't work too well. 
I never said opposed, they're just not bound to it, open minded, just like people should be with goto and globals.
I strongly disagree with you that the two cases are equivalent. 
At first I thought this could be reasonable if you treated it as like a registry that were injected as a dependency, but actually even then you'd end up creating untold numbers of hidden dependencies, because who knows what items in the registry you'd be relying on? If your class needs access to configuration, figure out a way to pass it in explicitly. 
&gt; Dont commit the lock file if you dont want to be strict. Seems like that opens up the potential for some obscure edge-case bug that happens on say, production, but not on 3 of the 5 developers' machines.
Using $GLOBALS is like always leaving the doors of your home open: sure, it's convenient when you know your neighborhood and a good friend wants to pick something up while you're out, but sooner or later things will tend to be displaced, broken, out of battery, or will simply disappear, without anyone being particularly mischievous.
You completely misunderstood the metaphor. The car is a gasoline car. The whole point of the post was to demonstrate that best practices (like putting gasoline in your engine designed to use gasoline) are considered such for good reasons, and deviating from them (like using kerosene in your gasoline-powered engine) is almost always a bad idea, even if it seems to solve some immediate or "practical" use-cases (kerosene is much cheaper, and I'm broke).
Though that'll not name them, it's really just a mapped TSRMG hash store retrieval. The filter functions nonetheless did a great job at popularizing baseline filtering. Personally I still find that API a little obtrusive; and prefer e.g. `$_POST-&gt;text-&gt;html["content"]`, `$_GET-&gt;int["pageno"]` or `$_SERVER-&gt;id["HTTP_HOST"]` for explicitness.
For the record, you should be carefully examining and determining the values in your config file if you're not installing an OS package anyways, so this really shouldn't be an issue for anyone but package maintainers to care about.
&gt; hey, that means I have to inject $db into hundreds of places Could you provide more examples on how to avoid that?
Ah, you must be a manager, you never specified the type of car but I was supposed to know it. And like a manager you will die if you are ever caught in a situation where you live depends on the car moving but you have no gasoline available. You won't be able to improvise and find alternatives to work with the situation as it is but keep insisting things should as you desire. If you have a gasoline car and have gasoline available you use gasoline. That is obvious. But what do you do if that is not an option. Can you find an alternative AND understand the consequences and make an informed decision? That is the mark of a good developer. Making a bad decision or not making a decision is something any idiot can do. Making an informed decision in non-ideal conditions is what sets you apart from a drone.
I think PHP needs a fork. One for the people who downvote comments like this and one for people who upvote them.
Depends what you mean by product, right? Your application, CMS, etc would of course have incredibly specific versions required for its composer.lock, and the entire application will have its mission critical functionality tested too, right? But a components dependencies (an applications dependencies dependencies) should IMO be a little more vague, when/if you can rely on semver, to reduce the occurrences of dependency hell as described in the article. I'm definitely not just saying "shove out shit code and who cares about versions lolololz." :)
First article: _It's always about the lock file!_ Followup: _It's ALMOST always about the lock file!_ Secondary: _It's SOMETIMES about the lock file!_ Tertiary: _It's NEVER about the lock file!_ Tertiary Followup: _What's a lock file, and why it's important!_
Maybe beanstalkd can help you. Laravel supports it as a queue subsystem.
Wow, thanks for reminding me those still exist )))) So I guess my answer is NO
As I said, I used an OS package.
so with this argument, all C programmers are bad programmers, and every C module/app written (which runs your OS along with its thousands of drivers) run on terrible code. awesome.
Oh, that's nonsense. You don't have to introduce global variables in C either. Nevertheless, you can't deny that if you do, you violate scope isolation and introduce a global state, which makes the program unpredictable when said globals are being acted upon by multiple actors. 
rabbitmq + php-amqplib has worked for us. another alternative is to use a database (mysql if it's all that you have) as your job store (so you can pick-up queued jobs after a restart), and redis as your pub/sub channel between workers/job producers.
RabbitMQ has always served me well
PHP is loosely typed for a reason: It's a feature, not a limitation. Not learning when to use == and === is a *bad thing*.
Was not aware of Snowflake (must have past me by at the time) - interesting stuff.
came to suggest this myself. 
Damn, you seem to have stumbled upon my blog plans for the next quarter. :(
Well I'm late, I hope somebody answers this. Why sometimes we don't close the '&lt;?php' tag with the '?&gt;' ?. Is there a difference?. &lt;? php class example { ........... } //No closing tag. 
Then your issue isn't with PHP, it's with your package maintainer.
&gt; This is why I encourage you to try techniques discussed in this post and why not take the more radical decision to try one of those obscure pure functional languages that some bearded guy are talking about in conferences. And yet those obscure language have better design or have design (which PHP hasn't) and they are not actualy crap.
The grammar and spelling of your comment do not inspire confidence.
So, if I'm understanding this correctly...you have a fluent API on a single class, but want to add constraints based on the sequence of functions called. So, to facilitate this, you create a separate interface for each path or step, and typehint the next step's interface. So all methods in Step1Interface return an instance of Step2Interface, and methods in Step2Interface return an instance of Step3Interface, etc. And you then implement all interfaces on the concrete class that uses the fluent interface.
The general concept of people agreeing with OOP is not equivalent to the general concept of people agreeing with goto and globals? Alright then...
I use Redis, which isn't precisely a message queue, but you can use lists very effectively for a lightweight queue.
His point is somewhat valid though. Deciding to functional program is one argument. Trying to shoehorn that philosophy into PHP, which was not designed to be a functional language, does not make sense.
URL shorter , if you know how to write services you can make even api for it :) 
Kind of. The one class part isn't a requirement, how it gets implemented further down the line isn't necessarily set in stone right now and that's actually been quite liberating. It's also daunting, as I'm constantly wondering if I'm digging myself in to a hole, with an API that's difficult to implement.
I'm a tad shocked this has got so much attention, and so many in-detail responses (not a bad thing). In short: no. $GLOBALS usage is usually a pretty good indicator that the code is either very old, or very poorly written (or both, of course :)). Lots of OOP talk knocking about here, but I haven't seen $GLOBALS used since the early days, when OOP was but a whisper.
Constants are fantastic and are used throughout the language itself, especially in third-party extensions as human-readable parameters for methods.
Makes lambdas look confusing. function Iterator() {} // Function with no type hint $fn = function Iterator() {} // Lambda with type hint
I will look deeper the service way, it's interesting
Sorry, english is not my native language, and I embrace my grammar instead using google translate.
Some example? 
Are you serious? Have you even read this thread? The same (problematic) config value is set for **everybody**, regardless of wether you install from source of from an OS package…
If you're already in AWS, their most recent SDK for PHP does not suck. Sqs + Gearman = Win
Welcome to the real world, where PHP is used by so many people who don't care about that. It's not perfect, but that's a fact. Shipping with a default config that throws warning is confusing and weird, and that's what I'm trying to point out. In forums we got people coming up: &gt; hey I got this notice when migrating to PHP 5.6 there's a bug in your software! Then you are welcome to come with your horse and scream "you fucked up you peasant!" but in the meantime the world keeps turning and we've got to deal with that.
The PHP source does not have a default configuration. I literally just explained that to you. The problem was with the package maintainer that compiled the binaries and chose the configuration without reading it. Apparently in the "real world" people don't read, either.
How do I push the new object into the array and store the revised version properly?
It's more like leaving your own gun out of the safe then get drunk. After you wonder around for a while you pick it up and go "Oh neat, I can just pull this trigger" 
Alright, question time. It's been a while since I've used PHP, but I get anon. functions and closures and passing scope: $factorial = function($n) use(&amp;$factorial) So, we're creating an anon. function and passing itself so it can call itself. But if memory serves `&amp;$var_name` means by reference. Why pass itself by reference? Edit: Also, since it's something that's caught my attention lately, Python supports decorators. If you've ever used Python and noticed this funny looking syntax: @awesome def my_func(): pass That's a decorator, which is really just short hand for `my_func = awesome(my_func)`. Since PHP supports both first class functions and closures (the two things I consider crucial for decorators to be possible), do you think there is any chance for a similar syntax to arise in PHP? Obviously, `@` won't work since it's used to silence errors.
rather just write some functional code that gets the job done.
your [development history of PHP](https://www.youtube.com/watch?v=ULjUgdxNaHg) video is wicked.
Yeah! 
Wurfl is not free/libre software which is a big advantage of device-detector
"more accurate than others" - that is excluding this new Device-Detector library :-)
I use beanstalkd for the queue and [Stiphle](https://github.com/davedevelopment/stiphle) for the rate limiting.
I mark it as a library from pointing the project at my composer.json and then get two levels of search, one for 'project files' and one for 'external libraries'. Thought everyone did this...
&gt; do you think there is any chance for a similar syntax to arise in PHP That *might* happen if/when we get proper annotations support, but yeah, it would be great for avoiding boilerplate.
The guy speaks two languages. Downvotes because he doesn't speak both perfectly ?! shame on you reddit. His point is a good one: why the fuck would you use a procedural language to do functional programming when you could just use a functional one. That said, this is impressive in a "don't try this at home" kinda way.
Dependency injecting the same once-instantiated class where you need it is very different from defining something on a global scope. It's also completely testable. Speaking of db connections, do you really think you're creating a new db connection every time you use it in your application? No, you're using a singleton pattern, and re-using the once-created db connection (otherwise you're insane).
$RAW_SOM is not defined in the function scope. See: http://php.net/manual/en/language.variables.scope.php
[SOLID](http://nikic.github.io/2011/12/27/Dont-be-STUPID-GRASP-SOLID.html) is a good starting point. Ideally, work throught the materials listed [here](http://stackoverflow.com/a/16356866/2834339), but that will take some time.
Mixed with Vagrant linux boxes, file shares, and ultra long file paths (not supported on Win), all sorts of things regularly go wrong.
Yeah that's how I do it, works will all linds of libraries too: JS, ruby, etc
You need to pass $factorial by reference because the variable has not been assigned yet. If you don't pass by reference, PHP will attempt to copy the variable, causing an undefined variable error (notice).
Is *use()* supposed to be next to the function brackets? Because I seem to get a syntax error. 
use only works with closures.
You should turn on error reporting, which would tell you immediately that $RAW_SOM is undefined rather than making you think it's null. error_reporting(E_ALL);
I prefer to use a database. Add entries to the queue table and include a status field with (New, Processed, Active). To get the latest item select from the tracker table looking for `MIN(creation_date) WHERE status = 'New' FOR UPDATE` (this locks it). Update the row to change the status to `Active` and commit the transaction to unlock it and let another reader find a row. Now work on that item, and when done change the status to Processed and look for another item. This lets you have multiple queue-writers and multiple queue-readers for free. Be sure to create an index on `status, creation_date` so you don't lock too many rows by mistake.
i made a simple mqueue class that uses memcache and head/tail/item keys its ok, might have problems with high concurrency of course if you can, use rabbitMQ, if i would do something like push messaging or anything like that, i wouldnt use anything else.
Sounds like either laziness or poorly written code still, sorry. I have never seen $GLOBALS used in the wild on anything that isn't very old.
[**@drgomesp**](https://twitter.com/drgomesp): &gt;[2014-11-06 05:44:24 UTC](https://twitter.com/drgomesp/status/530234223123116033) &gt;PHP internal trolls :\) [#php](https://twitter.com/search?q=%23php) [*pic.twitter.com*](http://pbs.twimg.com/media/B1vFNKnCcAAxKxD.jpg) [^[Imgur]](http://i.imgur.com/KTIKwMP.jpg) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2lgtjv%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
Added in PHP 5.4: http://3v4l.org/WY1Vs
Just because you shouldn't, doesn't mean there aren't any useful applications. (Not that I'm advocating using this by any means, but simply telling the guy it's a horrible idea isn't particularly constructive)
So .. I know I'm an idiot, so let's just skip that and get to the crux of the issue. Wtf is "use strict" and why isn't it allowed?
"use strict" is Javascript, not sure on any other languages.
Not really.. see.. http://3v4l.org/pTRCY 
Yeah, I know that it is used in JavaScript.. I was just trying to figure out how this was funny. I assumed it was something that I never learned in PHP.
This is no place for such question. Try [this one](http://google.com).
This most likely stems from preventing people from accidentally executing Perl/CGI scripts using PHP/CGI. use strict is a commonly used clause at the beginning of Perl scripts to activate ['strict mode'](http://perldoc.perl.org/strict.html), which, like PHP's E_NOTICE and E_STRICT, helps to prevent common programming errors. While it could have a relationship to javascript, I'm not sure how or why you'd end up attempting to execute JS code in PHP.
CI had its glory days. Sorry guys, it's time to move on. 
To make this work you are missing the 'global' keyword =)
PHP is not a object-oriented language, is OOP capable, since the OOP part was plug-in.
&gt; Dependency injecting the same once-instantiated class where you need it is very different from defining something on a global scope. That's true. It's also not a singleton. &gt; Speaking of db connections, do you really think you're creating a new db connection every time you use it in your application? No, you're using a singleton pattern, and re-using the once-created db connection (otherwise you're insane). Really? So you start in on this thread decrying how no one knows what a singleton is, then conclusively display that *you* don't know what a singleton is. Brilliant! 
I went through the docs on CI 3.0 a bit. I mean is there any plans to get CI installable by composer? Can you even use composer with CI? Been a while since I touched that framework and thought its was a turdball and moved onto better things &lt;cough/&gt; *Symfony*.
Yep. If there's anything CodeIgniter needed, it was a committee. Nothing gets things done better or faster than disparate goals and bureaucracy.
Yeah, it ought to be defined as a reserved keyword if PHP is going to play silly buggers with it.
~~that `MIN(creation_date)` *shudder*~~ ~~`order by creation_date asc` seems like a better choice.~~
Have you tried [SplQueue](http://php.net/manual/en/class.splqueue.php)?
I sort of agree, many developers in the PHP scene have never done any functional programming, and as i see it its a very good thing to study how its actually done in some other language, i would recommend F#, Haskell or Scala, Haskell beeing the de-facto functional language. You could also concider one of the compile to JS langauges with functional as a priority, LiveScript beeing my favorite.
If this is within a closure it needs to be passed into the functions scope function BSI_compare($Age, $Gender, $column, $value) use($RAW_SOM){ var_dump($RAW_SOM); }
In that case, I apologize. My comment was unwarranted and kind of lame.
&gt; The 10up Engineering Best Practices are not geared to teach anyone to become an engineer. **Rather, they aim to illustrate how to engineer the 10up way.** So... ~~Best Practices~~ Company standards. That's not to say there's not a lot of good info... just overzealous click bait naming
whoever downvoted this has no sense of humour. 
Why do you use CodeIgniter all day long?
`$ci &amp;= get_instance();` for life!
Np :).
If you have 5+ generations, you are doing it wrong. Objects should only inherit one or two levels. After that things become unmanageable, as you can see by the situation you describe.
Clicked on PHP, got Wordpress. Not cool. 
all the java-turned-PHP developers that's pushing for 99 levels of abstractions and indirection in packages and "standards" would beg to differ.
While I'm creating new apps in laravel, I'm not so unhappy with CI that I would rewrite all my already existing apps. I hope their first order of business is adding in some much needed functionality though and having it be non-breaking.
Haha. Like I said, I've been using Python primarily the last few years and there's no true anonymous functions, just single expression lambda functions (which are fantastic for sorting things or simple callbacks, but not much else). Closures are simply created by creating a function inside another functions: def outer(x=4): def inner(y=0): return x+y return inner f = outer() print(f()) &gt;&gt;&gt; 4 Python stuffs the scope it's closing over onto an attribute on the closures (being original, it's called `__closure__`). But the interesting part is if you examine it, `__closure__` is just a tuple of proxy objects that just ends up doing the right thing. I've not found much about the innards of it, but I believe that it uses the generated bytecode to know which value to use where.
&gt; So I know PHP7 is introducing type hints for return values of functions. Probably. It's not a done deal yet. &gt; is there going to be a way to type hint the return values of callable's sent as inputs to a function? Almost certainly not. If it were to be implemented, a mechanism for specifying the function's entire signature (including arguments) would need to be implemented. No-one has proposed a mechanism to do this, and it wouldn't be an easy thing to do. What is most certainly *not* going to be added is half an implementation which doesn't cover the entire function signature. It would also be generally quite difficult to do this in such a way that it worked with internal functions (at the moment).
Seems to have been added here: https://github.com/php/php-src/commit/133596b6f7c48a4e6de32e854c34859e6dfd1278
I was wondering what the best practice to implement interfaces is, when using the doctrine Entitymanager. It feels like this is a special case? As far as I am aware you can't use Dependency Injection as you can't change the interface and repeatedly instantiating the entitymanager costs a lot of processing time. Therefore having the EntityManager in $GLOBAL seems (to me) to be the only viable solution. The case I have in mind is the league/oauth2-server in which you have to implement the storage interfaces. (http://oauth2.thephpleague.com/implementing-storage-interfaces/).
That line of code alone is sufficient to show why CI is brain dead...
&gt; PHP also dont allow you to call methods without that goddamn arrow. Unless I misunderstood something here, this is what you can do: $object = new Class(); $params = []; call_user_func_array([$object, 'method'], $params);
I'm sure there is a demand for it, but you'll likely be inundated with the type of questions you see in PHPHelp and/or worse. Also it would be a good idea to have some sort of resumé. Like if I wanted to discuss certain OOP patterns and their appropriate usage with you - how do I know that you are a capable or reliable source? EDIT: I missed the links at the bottom of the post.
I think about the "reliable source" point you could just check the last three links he posted and make up your mind yourself. LinkedIn is a reliable enough source...
&gt; I'm sure there is a demand for it, but you'll likely be inundated with the type of questions you see in PHPHelp and/or worse. Eh, it's their dime. I love the newbie questions. Making their light bulb go off feels super good.
I was hoping there would be some good content from these chats.
I typically don't mind either, but it is a little frustrating when they haven't put in the proper amount of time researching issues and breaking down examples on their own.
I missed those for whatever reason. It's raining here - so that's my excuse.
Just because it didn't have it before, doesn't mean it wouldn't be great to have it. C# and Java did it.
I don't really see the benefit. If `$loader` throws an exception, you still aren't getting a `User` instance back. So, if your loader not giving you back what you want needs to be a recoverable scenario, just check the return value from the callable, and run whatever recovery code you will (should be) already running in your `catch`.
I agree. Use HaProxy to do fail over (even load balancing) instead. If you want more HA, also use something like Keepalived to maintain a Virtual IP that will move between servers as needed.
I think it would be beneficial to check out http://phpmentoring.org/. It seems like a better use of your time.
I've been there and that actually is what got this started :).
We've been using RabbitMQ in production for about 2 years now. It's been great :) 
I'm not sure I understand your point. Exceptions are kind of irrelevant because they would delegate execution away to your exception handler anyway. The benefit I can see is the same for type hinting in general. I get that you can use is_a, but you could also do that instead of the current implementation of type hints. The purpose of type hints in PHP seems to be for convenience – a succinct way to say, "I'm expecting an object of type X. If you pass me an object of type Y, I know this process will not be executed." – and clarity in errors – "Fatal Error: Argument 1 must be an object of class X". Presumably, any function that takes a callable argument will be using that function, so this would be a way to say "I'm expecting a function that returns an object of type X. If you pass me a function that returns type Y, I know this process will not be executed." If you pass in something else, you should get "Fatal Error: Argument 1 must be callable and return an object of class X".
It's entirely up to you wether you do or not. I write primarily procedural code but done my first entire app in OOP not so long ago. It's much cleaner and well structured. If you are comfortable with the way you code then there isn't really a need to change. It's actually quite therapeutic learning it. 
&gt;It's much cleaner and well structured. I would say that's the primary reason.
Once it's compiled to byte code, it doesn't really matter what you use, and you can accomplish any task with either procedural or OO code. Learning OOP (particularly the SOLID principles) will introduce you to a new style of organization and interoperability so that your code can be reused across multiple projects. This can make complex projects much more maintainable.
Luckily all the CI apps I inherited are 2.x so they are all running on 5.3.3
&gt; Non-OO code is simply harder to maintain, re-use, and understand than OO code is. So not true. You can write mainainable code using any paradigm if your hands don't grow from your ass. Linus Torvalds called object models "idiotic crap" and I'd say he's pretty good at writing maintainable code ( linux kernel, git ) OOP is not inherintely better than functional programming or even proper procedural programming. The main reason it's popular now is because it's harder for junior devs to screw up OOP code since it does strict typing and stuff and is easier to understand.
&gt; The main reason it's popular now is because it's harder for junior devs to screw up OOP code since it does strict typing and stuff and is easier to understand. I don't think this is the case at all; good ([SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29)) OO allows compositional &amp; code-reuse strategies that are very difficult to replicate procedurally.
Is pretty much the same as LiveScript but it close to haskell semantics, type system, ADT, is "pure" as reduntant as it sounds, and compile to a very readable and flexible js.
I can't call anyone a developer that can't write oo code. If you can't code in an oo manner you are just some guy that can throw a script together.
I was also on the IRC channel...
&gt; Linus Torvalds called object models "idiotic crap" and I'd say he's pretty good at writing maintainable code ( linux kernel, git ) A Linux Kernel and Git are *vastly* different in nature compared to a web application. I don't doubt the man's intelligence, but to the best of my knowledge he doesn't do the type of development where OOP is most beneficial.
~~I may be talking absolute shit, but functions on fields make me think that the whole table will be read, whereas `order by` may be able to utilise indices. Would love this to be confirmed/refuted by someone who knows...~~ ~~Still, database/engine specific!~~ ~~Edit~~ ~~this: http://dev.mysql.com/doc/refman/5.0/en/order-by-optimization.html~~
The problem is, only Linus Torvalds is Linus Torvalds. By definition, everyone else is not Linus Torvalds. Just because one brilliant person can do it well the hard way (and to be crystal clear - it IS the hard way), doesn't mean procedural code is an equally practical / maintainable approach for everyone else. Also, to support what /u/ThePsion5 said about the difference between git and web apps, here's the full context of Linus' quote: http://thread.gmane.org/gmane.comp.version-control.git/57643/focus=57918 Git's primary goal was speed and efficiency - which of course means reducing overhead as much as possible. Objects and C++ abstractions are indeed performance overhead, but if raw "rubber meets the road" performance is not a primary concern of yours (which it isn't in most web applications), then you're not gaining anything meaningful by staying procedural. And if performance is indeed a big concern, you wouldn't be using an interpreted language like PHP in the first place...
PHP also wasn't designed to be object oriented, but here we are.
I hope you mean just in PHP, specifically.
Set a base rate for a question and its all good. Telling someone to close a bracket for a quid isn't the worst thing in the world.
http://php-and-symfony.matthiasnoback.nl/2014/05/inject-a-repository-instead-of-an-entity-manager/ http://symfony.com/doc/current/components/dependency_injection/introduction.html I guess this is reading material for me then (?)
Sorry meant #phpmentoring
Thanks for the explanation.
There's a PHP port of Github's resque: https://github.com/chrisboulton/php-resque 
Think of it as a matter of discipline. I've had the pleasure of mentoring developers over the years and I've seen their ability to think abstractly and reason through problems improve through writing object oriented code. You get most of the benefit just from making classes with sensible methods. Where people go wrong is trying to Java-ize their PHP. You don't need to have an interface for everything and some abstract factory class and such. If you are building a framework maybe you can justify some of that but most projects are lifted a notch or two simply by making classes representing the business objects of the subject domain.
I mean, I hope you're not saying that people that can't write OO code are irrelevant. Many languages do not support class constructs and are purely functional - some absolutely brilliant people write exclusively in those languages.
Again: &gt; The default production configuration included in PHP (or call it whatever you like, it's still there) comes with that value. PHP 5.6 comes with a recommended config which is broken.
How is that different from IRC, StackOverflow or forums?
Honestly this article is a bit too enthusiastic. I've used BowerPHP a few times now and it only supports a small subset of what Bower does. And I'm not talking about very exotic features. I wish it would grow and become more stable of course, but right now don't expect it to cover everything and work in every project.
Lazy questions would be downvoted by the community I'm sure... It would be decided by the community. Could hook something up with StackOverflow to see if a matching question exists and decide whether or not that question should be allowed or not...
I would argue that both git and linux are much more complex than a regular web app. So I see no obstacle in writing a maintinable web application using procedural style. For example let's look at the project posted on this subreddit recently. Here is a model: https://github.com/caffeinated/codex/blob/master/app/models/Codex.php This model can easily be split into a data structure and procedures operating on it. Look at Go which is used succesfully for web projects. It's not far from procedural programming since the OOP aspect is incredibly thin and can be easily avoided. And yet it's as easy to write as regular class-based OOP
Again, it's a sample config, not a recommended config. The package compiler's laziness in their job does not make it a default, no matter how much your ignorance of subject wants it to be.
It's not me. It's the software I'm trying to integrate. :/
Are you offering tutorials, or help, or just general discussions? I would really like to learn PHP but have no idea where to start. Any suggestions? 
Hack solves this by defining "function" type hints. It looks like this `function foo((function(int, string): mixed) $var)`. I highly doubt this will ever end up in PHP unless it supports proper types and generics.
Yeah, no: https://github.com/php/php-src/blob/master/php.ini-production#L72-L74 &gt; PHP comes packaged with two INI files. One that is recommended to be used in production environments and one that is recommended to be used in development environments.
Which by that quality wouldn't be included in what I was talking about. 
Looks alright if you are using Symfony. If dependency injection is new for you, have a look at this [excellent video](http://blog.ircmaxell.com/2013/01/dependency-injection-programming-with.html).
People are still maintaining Smarty. Projects need maintainers, regardless of wether its the "new hotness" or not. I'm happy to see it being looked after by people who have been involved in the community for a long time.
Did this guy really take a picture of his screen with a camera? 
It seems like it isn't possible to allow the sharing of encrypted files without storing the key on the server (or a separate server, as I've seen some companies do). You make a great point about trusting the server though, but I guess you have to make a compromise at some level for convenience. 
I'm just guessing based on the description of the technology, but Spideroak encrypt and do allow sharing. https://spideroak.com/engineering_matters It appears that they basically build a URL where the decryption key is included in the URL. This ensures the full URL is required by the recipient, and gets back to the scenario where a server compromise doesn't leak anything. That's still only a configuration for data that's meant to be shared, and thus, presumably has a lower security requirement.
I'm sorry this comment isn't adding to the discussion, but this is something I've been mentally working through over the last few months. How to encrypt (potentially shared) data that can't be decrypted without the intervention of the originating user. I also, as the developer, don't want any way to decrypt the information. ~~EDIT: The only thing I can think of at this moment is to have have physical token for each user.. like the RSA dongles from my past, and even then I don't know enough about cryptology to say that's good enough.~~ Clearly this still wouldn't work. EDIT2: The more I think about it the more I think this a real problem that smarter people then me have been trying to solve.
But then the URL is stored somewhere along the line meaning that the decryption key is exposed.
I hear you. You should see the stuff I am dealing with. Much more than 5 levels of inheritance, globals everywhere, databases with no keys or indexes in the tables, just the tip of the iceberg.
What exactly is it missing? 
What did you expect? He's a PHP programmer! ^(I joke! I am too)
&gt; We installed in seconds what would have taken us minutes with NPM, if it would have worked at all in a VM hosted on Windows. Right...because composer global require "beelab/bowerphp 0.1.*@alpha" Is simpler than npm install -g bower Right? C'mon now. I also use VMs on Windows and haven't experienced this issue you're talking about.
This article annoys me, and for several reasons. Mostly because it's so hysterical and overwritten. Referring to the reaction to BowerPHP as "apocalyptic" is absolutely absurd. The response went into several directions, of course, including a lot of "hey, that's useful", but also quite a few people just saying "Meh, I don't see the point". If "meh" is apocalyptic... &gt; We installed in seconds what would have taken us minutes with NPM, if it would have worked at all in a VM hosted on Windows. Bullshit. Sorry, but just... complete bullshit. I literally just did this to test it. A brand new install that I never actually got round to finishing, vagrant with Homestead. Fresh install I've never run NPM on, and certainly never installed Bower on. I ran a stopwatch and it installed in 28 seconds. That's not "minutes". *Edit: out of curiosity, I tried installing this to see how long it actually takes to install BowerPHP. It took ~1:40. That is more than three times as long as Bower. "installed in seconds what would have taken minutes with NPM"? It's possible that this is a highly optimised composer, running on HHVM, but mine and most peoples' are not.* As for whether it would have worked at all in a VM hosted on Windows... who knows? That Windows is a shitty environment for dev is hardly Bower's fault, but I find it difficult to believe that the environment of the host would even make a difference, that's the point of using a VM. And `bower install foundation` worked perfectly. As it always does. In conclusion, I have no problem with BowerPHP. I'm sure there's a place for it. I think people have a tendency to a needless language specific NIH syndrome and miss out on the best possible tools. But regardless, a variety of options is good. But there is **no** place for this sort of exaggerated and misleading writing. If you have a need for a PHP version of bower then by all means use it. But acting like bower is somehow *broken* is absurd and does no one any favours.
*Released*.
If you have to ask you'll never know.
Didn't mean to comment on my own thread.
For your specific problem you might consider adding the CRC of the file to key so that it's only valid for that file.
I don't remember the details sorry, but have a look [at the issue list](https://github.com/Bee-Lab/bowerphp/issues?q=is%3Aopen+is%3Aissue+label%3Aenhancement). Nothing too major I believe, but from experience it didn't work with some projects. I also want to point out a very cool thing of BowerPHP over Bower: it can be embedded in a PHP application (i.e. used as a library). I've been using it successfully in one of my projects.
Sure. Try it out. The CRC should be unique per file and would keep "User B" from accessing beyond that file. For the record I'm just spit-balling. EDIT: If I were to do it I might encrypt User A's password hash, and User B's password hash using the file's CRC as the salt - then verify both HASHES before delivering the file and CRC. Again - spit-balling.
While it's pretty much the same thing, it's sometimes nice to put those values in a data- attributes on an appropriate HTML element, and the JavaScript can get that value when needed.
I love the usage of the single = so this will always eval to true. Well played.
What about Google Helpouts? I'm Canadian so they are of no use to me (last I checked) but the concept is great!
I honestly think your efforts would be better spent writing a blog or (as others have mentioned) making a podcast. Might not be a bad idea to get some source material, but Stack Overflow can be a good source for that too.
Is this the same guy who told everyone that their code is bad and this is why.. ?
Not is this video.. He explains what exactly are annotations and how they are implemented in PHP and how to use them (example being filters in this video). I found it to be quite insightful! Worth watching.
I'm wathcing. Just curious if this was the same guy - seems like it - I'll google it later. EDIT: The answer is yes - [http://www.youtube.com/watch?v=H2AvoAzbGOE](http://www.youtube.com/watch?v=H2AvoAzbGOE)
I am 100% in favor of annotations but if something affects the code why the fuck would it be in a comment? I'm not willing to use a hack for mere aesthetics or consolidation of data. Also, docblocks used for phpDocumentor or whatever aren't necessary for the code to function so they're not at all the same or even remotely comparable.
No, and the OP is.
thats rad
Thanks, will do.
Never heard of it, but ##php could often use more help. 
I'm Canadian and haven't had any issues with Google hangout :)
Well, everything you listed is all text base and personally I just find it easier sometimes to chat verbally.
ok
I see what you're saying and it makes sense I guess, but my argument is that PHP already supports type hinting callable things, so why wouldn't you want support for a more descriptive hint. It would only improve error messages and reduce ambiguity as far as I can tell. Also, if the function throws an exception, that would probably because it doesn't know how to return a User, so that would be the desired behavior if you ask me The difference is if the function returned a Zombie instead of a User, you'd know right away, whereas without the type hint you might execute the rest of the code thinking your User is alive!
just stop typing please
Functional programming is based on lambda calculus and designed to eliminate side effects. PHP is loosely copied from C and has $GLOBAL. There are no reasons.
I totally get your point about podcasts, haha. I guess I don't find sessions like this to be very useful without the option of peer review. Maybe take this inspiration as a chance to improve your writing abilities?
If you're brand new to programming I honestly push people towards this book to start learning, mostly due to the realistic per day learning: http://www.amazon.ca/Java-Teach-Yourself-Covering-Edition/dp/067233710X/ Followed by this book: [Design Patterns: Elements of Reusable Object-Oriented Software](http://www.amazon.ca/gp/product/0201633612) For specifically PHP: http://www.phptherightway.com/ Pretty much anything else related to PHP will be found here: https://github.com/ziadoz/awesome-php
Oh, thanks. Didn't even know about this...
I like that idea a lot more. Thanks for the tip!
And I would argue that the maintainability of linux and git depends on a few IQ points above average as a result of their procedural design. And while they may be maintainable in their present form, that doesn't preclude a scenario where they would be maintained *more easily* if they were object structured with well encapsulated, well named, and well designed classes / messages.
I agree with your motivations, but I just see too many gotchas/quirks. Another example would be when you want a callable that returns another callable (e.g. `public function __construct(callable:callable $loader)`).
Ah I interpreted "chat" as "text" ;) Makes sense
&gt; why the fuck would it be in a comment? because we have no alternative for now &gt; I'm not willing to use a hack for mere aesthetics or consolidation of data. I don't see the link with "consolidation of data" and it's not just about aesthetics, but the fact that is a hack doesn't prevent usage IMO. Before PHP 5.4 many frameworks used the infamous "Serialize hack", which was ugly, but worked. And in the end, annotations work. I'm hoping for something more "proper" of course, but the fact that it just works today can't be denied. The value they bring is greater than the drawbacks (e.g. having it in a docblock, needing to cache them, etc.).
What about using something like [Pusher](https://pusher.com/) for the card scanning action?
I don't think it makes sense and doubt it's possible since you can't pass functions by reference like in Python. Annotations like in Java/C# makes more sense, and in a broader perspective I think I prefer those over Python decorators anyway.
Your last few edits seem to describe what I was thinking initially. I think I'll turn the process I outlined in my initial post into a weekend project. 
For my uninformed ass, what's the problem with the con, apart from using mysql_connect?
Regrettable, but necessary. Given that this was sitting at votes of 49:3 for its addition, it seems that it's assured to get over the line when the issue is resolved, assuming it's achievable.
One approach is to store users' public keys and encrypted private keys (which are AES encrypted using user's, say, PBKDF2 derived password) and when one user shares a file, create a random AES key used to encrypt the file itself. Encrypt this AES key for each recipient using their public key. When someone with access to the file wants to read it, decrypt the AES key using their private key (which you can decrypt as the user must supply his password). If user B's access to the file must be revoked, do the above again but do not give the new AES key to the user B. Also, you may consider adding an extra server side AES encryption layer to the encrypted data (so that the data is not only behind "user's passwords", but is being protected by a strong server side key). This method requires a trust to the server (if an adversary has an active control over the server the data will be lost), but is as strong as the weakest user password against "full backup leak". Some information about symmetric key encryption you may find useful: http://timoh6.github.io/2014/06/16/PHP-data-encryption-cheatsheet.html
All of the above comments, + you don't even hash the passwords. Sorry dude, I admire the fact that you contribute to the community, but when you do, make sure you don't "teach" bad habbits.
There's Behat out there, but I'm not exactly fond of the cucumber approach to authoring tests. There's also PHPUnit - which lacks the multi-level before / after hooks that I find are important for integration tests where - in spite of test purity - you want to do things like initialize fixtures in a single before block. I also dislike the cli and it's stubbornness about not allowing you to specify flags like --debug after the test path. I'm pretty critical of the ergonomics of my tools. So I hope someone finds this as usable as a I do. Other thoughts: The grep mechanism is solid about making sure the requisite before / after hooks run prior to executing a test case. For more integration-heavy tests it's great because it allows you to drill down to specific tests while doing things like importing database fixtures only as often as necessary. There's assertions around precise ordering in the self-hosted test suite. It ~should~ match rspec's behaviour. Still pretty raw, but I'm hoping someone enjoys it!
My first question would be: what does this framework bring/do that existing frameworks don't? Is there anything interesting or novel about its design? These are the things I'm interested in when someone creates a new tool.
what was the issue?
I do this, if my mocks are the same on a lot of tests. Just put those on my TestCase class.
Given a brief reading of the internals discussion, plus talking to someone way smarter than me, it appears that the issue is... PHP. Basically, PHP only does a single pass when compiling. Certain usage of this RFC would break down because PHP doesn't *yet* know about classes that are being made *later*, but it needs to in order to compile. Pretty much every other language compiler does more than one pass, for reasons like this. As it's the compiler itself that's at fault, this feature may well need to wait some time, until, for example, a JIT is implemented. **edit: I should clarify that I have no idea what I'm talking about and this is just my limited understanding**
Looks like whatever the issue is it can't be fixed without manifestly changing *something* in the RFC so the original author thought it would be poor form to continue with it in it's current state.... Hopefully the change doesn't result in an excuse for bike shedding...the up vote for this was a near whitewash, compared to previous attempts to get return type hinting through.
The thread in question: http://grokbase.com/t/php/php-internals/14b4mw61cg/rfc-vote-return-types **Edit: as /u/MorrisonLevi pointed out, this code is not correct. Please read other replies!** As I understand, the following code wouldn't compile as `DigestedFood` doesn't exist yet. class Animal { public function eat(Food $food): DigestedFood { // ... } } class Food {} class DigestedFood {} Note that `Food` is loaded aftewards without problem. Which brings me to the question: people with more knowledge, why was it designed this way? Was there a specific requirement, or it's just that people hadn't thought about this? 
Most people probably won't change their mind, but Levi Morrison considered the appropriate way of action was to solve the issue and then present the new approach for everyone to vote. Given that PHP7 is not going to be released very soon, I don't think there's a big issue with this. The post in question: http://grokbase.com/t/php/php-internals/14b7ypze1c/rfc-vote-cancellation-return-types
I know that $class instanceof WhateverClass will work (return false) even if WhateverClass is not defined yet, so it can't be outside of the realm of possibility.
In the thread you can see the terms "covariance" and "contravariance" ([wikipedia link](http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29)) being used to explain how each method works. I'd love to dig more into it, but I should be working now (hope the boss is not looking!). **Edit:** it's indeed solvable, but they considered it changed the RFC enough to merit another voting process.
we still use far more complex routing via regular expression in .htaccess files, so not a php-based routing, performance wise it was never a problem. 
How slow is a router with regular expressions and how fast would your solution be? If its a matter of 1-2 ms, I'd like the flexibility of full regexes more.
@gripejones, Yep, I am the same guy :P
&gt;If the implementation detail necessitates altering the detail of the RFC then it's not an implementation *detail*. In this case the change in implementation should not affect the behavior.
Afaik parameter types aren't variant either, so I don't see why return types would have to be (at this point).
Around 2.5 faster by using a simple benchmark. the running time really depends on the size of your regexps and amount of routes.
Maybe there should be some more tests, with variable amounts of variable complex routes. 2.5 times faster doesnt tell me much. Did it go from 5ms to 17.5ms or from 0.1ms to 0.25ms? Thats a big difference.
*shrug*...perhaps you are right...but clearly the author thought it warranted a revote... perhaps there is more to it than we can see here. There was a promise of further details being published "soon'...
So have you actually developed this or not?
/r/PHPhelp is more your thing. And my guess is that your `$location` variable doesn't point to anything. You need to provide a proper system path to save to e.g. /tmp/
$name = basename( $_FILES["file"]["name"]); $location = "img/" . $name; move_uploaded_file($tmp_name, $location);
Interesting, just saw [Peridot](http://peridot-php.github.io/) released a couple weeks ago. Does this have the similar plugin support? I think that's a killer feature.
I released [Peridot](http://peridot-php.github.io/) a tiny bit ago and one of our big focuses was events and scopes for making it a super extensible BDD framework. As for mocking, you can check out the Peridot [Prophecy plugin](https://github.com/peridot-php/peridot-prophecy-plugin) Or if Prophecy is not to your liking, it should be trivial to add Mockery support :) 
Google "SQL injection"
i've been trying out peridot for the past few days and have been pretty happy with using it. seeing that this is somewhat similar on the surface, will also give this a try. you guys might want to think about collaborating. i really hate the amount code you have to write when working with PHP unit. this somewhat makes writing tests in PHP more "ergonomic". you'll get people saying "but PHPUnit does a lot more blah blah magic blah blah perfect abstraction java blah blah blah oo design patterns blah blah" please ignore them and keep moving forward with these (peridot/matura).
Here is some more information on the bug: The following code does a covariance check on `B::foo()`, because it needs to ensure that `C` is compatible with the return type of its parent method `A::foo()`, which returns a `B`. However, `C` does not exist at the moment that the check is performed and an error is emited saying that it could not find class `C`. If these were split into separate files and autoloaded the current solution would work. &lt;?php class A { function foo(): B {} } class B extends A { function foo(): C {} } class C extends B { function foo(): C {} } ?&gt; Note that parameters do not have this issue because they are invariant, meaning that inheritors have to exactly match the parent type.
&gt; because we have no alternative for now My concern is that "for now" really means "forever". As far as I'm aware, there's no proposal to add annotations as a language feature to PHP, which means - in an absolute best case scenario - they're years away. I'm not going to spend the next 3 years putting application logic in my comments. I have a very hard time believing the benefits outweigh the drawbacks.
There are several ways to arrange your code. How you keep all the functionality together and have it work together. Think of it as a workshop where you work on car(s) and how the car and the tools are arranged. You can have a home garage setup, all the tools on the wall, car in the center of the room. Each work area has its own complete set of tools. You can have a production line with several spots, each spot has a subset of the tools needed, the car is moved alone the line to the spot with the right tools for that task. You can go army/hospital style, all tools needed for a job are on a cart and the carts are moved to the car that is in need of them. Which is the best setup? ALL of them, for certain scenarios. So which of the above is which coding methodology? There is no match, I just wanted to show how different ways of doing something can all be equally valid. In coding, you have several methods for arranging code and they are a tradeoff between simplicity and complexity. OOP is for more complex projects where the organization of code becomes such a large part of keeping a project manageable that not to have any would make things unmanagable. BUT if your projects are not (yet) complex enough... well... don't bother. In PHP you can use OOP and procedural intermixed. Things like DateTime can be used both ways, you can even use both methods interchangeably if you want. For people who start PHP from simple pages, I find you typically go from: 1 file, constains both HTML and PHP, code is executed in place where you need it, re-used code is copy pasted to where it is needed again 2 templates, PHP is in PHP files, which load HTML files and parse them to insert pre-calculated valies into the right spot. Code is grouped into functions, so you can call the same function from multiple places and not just copy paste re-used code 3 MVC, code is further separated, you might start including all user related functions in a user.php and include that file wherever you need user functionality. 4 OOP, function and variables are combines so you can have $user object from which you can get $user-&gt;name and do $user-&gt;setPassword($password) knowing that this object contains all of your user needs in one central place but in its own package so $user-&gt;createdAt is seperate from $post-&gt;createdAt and not in a global namespace. Does this mean OOP stands at the top? You are doing it wrong if you are not doing OOP? No... it depends on the needs of your project. If any of the other methods meet your needs... that is okay. Think of it as travelling, cycling is faster then walking, driving is faster then cycling, flying is faster then driving. Ergo: Unless you travel everywhere by blackbird, you are a loser. No. I would read up on OOP, its principles, its usages, then decide for yourself if your current work would benefit from using it. Once you project reaches a certain complexity however, the answer will almost certainly be yes. 
Why not make return types invariant and introduce variance (for parameters and return types) as a separate RFC?
Is there anything wrong with using mysqli_connect if you're esacping the data first before a query?
Gotcha. Thanks!
Thanks! Would I be able to pass variables to that view?
1. Significant use of [global](https://github.com/ajaxtown/eaglehorn/blob/master/core/functions.php#L40) [variables](https://github.com/ajaxtown/eaglehorn/blob/master/config.php#L125), a registry, and singletons 2. No namespaces, no dependency injection, no [separation of concerns](https://github.com/ajaxtown/eaglehorn/blob/master/core/controller/EH_Model.php#L71) 3. No tests 4. Your logger is a copy of Redbean's, which you just included as a [single ten-thousand line PHP file](https://github.com/ajaxtown/eaglehorn/blob/master/core/controller/R.php) named R.php. It seems like this was developed without any of the practices that have become common in the past 5 years.
Introducing variance in a later RFC is one possibility, yes.
I prefer php array for config storage. Laravel uses it, which is where I think I was first exposed to it. I'm always disappointed when I look at the php implementation on Symfony's or Doctrine's documentation and it's a bunch of method calls. I don't understand why they can't just use PHP arrays and have a similar syntax to the xml/yaml. I've never really understood the love for YAML, I guess we could blame rails for it. It just doesn't make since as a config storage. The PECL yaml parser isn't included by default so some devs are forced to use php implementations. They're probably caching the parsed yaml into serialized array, in which case you might as well just write it as an array. I'd rather write my configuration in JSON or PHP arrays. Though I do agree with /u/PatrickBauer89 prior to 5.4 the deep nesting of arrays was verbose. 
If you're trying to get a job, I'd go with be truthful while telling employers what they want to hear.
&gt; It just doesn't make since as a config storage. It's not use for config storage, arrays are. It is used for config declaration. In beetween you have cache, validation, etc. YAML is a little bit weird, but: * It's not PHP, so it's portable * It's not too verbose * It has more features than INI If you have thousands of lines of configs, infrastructure stuff, provisioning stuff etc, it is a pretty efficient language.
You already are. $this-&gt;view-&gt;var = "value";
I am currently building a CMS and I am using functions, but I really can't see what effect it would have if I where to use OOP. It is a pretty complex system though and it may become more clear in the future why I would want to use OOP. Anyway, thanks for the explanation.
Additionally, see the 30 other posts already made about the subject.
Intermediate should be fine. If anything, list the areas you're most confident in as your "Areas of expertise" after that, to quantify it. That way you sound like you know what you're doing in those areas, but aren't billing yourself as a guru.
Ha ha, it was hidden in one of the few places people never go, the bottom of the google page. Thank you.
If you want to get hired and get paid well then I would recommend throwing some buzzwords in there like "agile development", "test-driven development", and any frameworks you're familiar with. It might be good to describe in some minor detail some of the past projects you've worked on. Keep in mind that the people who will probably look at your profile won't actually be developers, but headhunters and HR people who are just looking at a checklist.
Dude, you rly should read some arts about DRY i programming - understanding that will help you understand why you should use OOP. 
This thread confuses me since this already exists... Or am I misunderstanding what is meant by "type-hinting return values"? [Type Hinting with Annotations](http://www.phpdoc.org/docs/latest/references/phpdoc/tags/return.html) and [here](http://manual.phpdoc.org/HTMLSmartyConverter/HandS/phpDocumentor/tutorial_tags.return.pkg.html). You can just put @return \User in the function returning the object and say @return callable on the function which returns the function itself.
What is that?
Do you have a high resolution image or PDF? 
Last year I separated from the Air Force after 9 years. I didn't do anything related to development but I coded and played with different technologies as hobby. I wanted to get back into coding professionally so basically I just started working freelance. I did some crappy gigs on Fiverr and even some work for an old boss of mine. At the same time I read up on what had changed in the 9 years since I had messed with PHP seriously. When I learned something new, I blogged about it. I wasn't doing very well freelancing and was lucky to be hired on by my current employer last April. I think just having a blog and a Github account helped me get the job. I had very little prior professional experience besides the several months of freelance work. I worked a year at a poorly run agency before the Air Force. I think another reason I was hired was because I had played with a few other technologies like Angular and Vagrant. Giving the appearance that you are knowledgable and well-rounded is key.
If you say it confidently, you will sound as is. Been there... and always, honesty above all. Intermediate is a good status-quo because there is space for growing and learning.
&gt; databases with no keys or indexes in the tables I'm sorry. :( I literally just added an index on one column and decreased fetch time of entire rowset from 150ms to 2ms.
I think you're missing the point. The example config would be userland code, which would be dependent upon their installed version of PHP. But since this is mostly a joke, have an upvote!
How exactly does using Ansible come into play here? Are you loading your PHP application config files in Ansible to do something, or simply moving them around as part of a provisioning/deployment process? I guess I'm not understanding the workflow. But by any means, if portability or sharing of config files is part of the project, then of course use something portable. +1 If it's just your Doctrine, Symfony or PHPUnit config... that's all confined to PHP. So it still doesn't make sense to me. 
5.1, no PSR-0/PSR-4 class and file naming e: Oh, wait, I knew this was familiar. [My previous commentary](http://www.reddit.com/r/PHP/comments/2k4heb/a_new_php_mvc_framework_eaglehorn/clhvsk1)...
I'll test it Thanks a lot!
https://bitbucket.org/heinep/thaps/src/tip/scanner/Lib/VulnerabilityScanner.php?at=default Looks vastly underdocumented and low-level instructive (lots of duplicated code). And reciprocal licenses somewhat diminish a professional appearance in comparison to academic/attribution code.
I'll keep my front end resources separate from PHP, thanks.
**D**on't **R**epeat **Y**ourself http://en.wikipedia.org/wiki/Don't_repeat_yourself Basically, if you find yourself copy, pasting and slightly altering code a lot, you should instead look into ways of abstracting that code in to classes methods or at least functions that are reusable. Than if you need to make a change to how things work, that change can be made in one place.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Don't repeat yourself**](https://en.wikipedia.org/wiki/Don't%20repeat%20yourself): [](#sfw) --- &gt;In [software engineering](https://en.wikipedia.org/wiki/Software_engineering), __don’t repeat yourself__ (__DRY__) is a [principle](https://en.wikipedia.org/wiki/Principle#Principle_as_axiom_or_logical_fundament) of [software development](https://en.wikipedia.org/wiki/Software_development_process), aimed at reducing repetition of information of all kinds, especially useful in [multi-tier architectures](https://en.wikipedia.org/wiki/Multi-tier_architecture). The DRY principle is stated as “Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.” The principle has been formulated by [Andy Hunt](https://en.wikipedia.org/wiki/Andy_Hunt_(author\)) and [Dave Thomas](https://en.wikipedia.org/wiki/Dave_Thomas_(author\)) in their book *[The Pragmatic Programmer](https://en.wikipedia.org/wiki/The_Pragmatic_Programmer)*. They apply it quite broadly to include “[database schemas](https://en.wikipedia.org/wiki/Database_schema), [test plans](https://en.wikipedia.org/wiki/Test_plan), the [build](https://en.wikipedia.org/wiki/Software_build) system, even [documentation](https://en.wikipedia.org/wiki/Software_documentation).” When the DRY principle is applied successfully, a modification of any single element of a system does not require a change in other logically unrelated elements. Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in [sync](https://en.wikipedia.org/wiki/Synchronization). Besides using [methods](https://en.wikipedia.org/wiki/Method_(computer_science\)) and [subroutines](https://en.wikipedia.org/wiki/Subroutine) in their code, Thomas and Hunt rely on [code generators](https://en.wikipedia.org/wiki/Automatic_programming), automatic build systems, and scripting languages to observe the DRY principle across layers. &gt; --- ^Interesting: [^Ruby ^on ^Rails](https://en.wikipedia.org/wiki/Ruby_on_Rails) ^| [^Django ^\(web ^framework)](https://en.wikipedia.org/wiki/Django_\(web_framework\)) ^| [^Code ^reuse](https://en.wikipedia.org/wiki/Code_reuse) ^| [^Single ^Source ^of ^Truth](https://en.wikipedia.org/wiki/Single_Source_of_Truth) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+clvyev2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+clvyev2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Yes - contexts seem very similar :) We found the concept super useful, especially when combined with the event driven architecture. We were able to use scopes/context and events to quickly make some pretty useful plugins - coverage included :) * [peridot-code-coverage-reporters](https://github.com/peridot-php/peridot-code-coverage-reporters) * [peridot-httpkernel-plugin](https://github.com/peridot-php/peridot-httpkernel-plugin) * [peridot-watcher-plugin](https://github.com/peridot-php/peridot-watcher-plugin) * etc... I like the notion of your contexts being passed to the test definitions. Probably key to supporting 5.3, but if anything gives another option for accessing that scope. The downside of using "$this" everywhere so far is many IDE's inability to detect those types... wonder if function arguments could be a potential way around this.
pdf file(5.92 mb): https://www.dropbox.com/s/gua2t3fowim1m5j/yii%202%20classes.pdf?dl=0
Very cool, thank you! I'm largely still supporting Yii 1 applications and haven't been able to play with Yii 2 much. How do you like it? 
If you're only telling employers what they want to hear then you're a Junior developer, at best. They won't appreciate you overstating your abilities. If you can't sell yourself honestly then aim lower or for something else that you're better at.
Another reason I like PHP vs. YAML, is that if I want to write a shell script that uses some configuration value, parsing it is relatively simple: DB_HOST=$(php -r ' $env = include("some/config/file"); print $env["database"]["host"]; ')
isn't that an already supported behaviour for php?
One thing that most of those yaml/json/buzzword config parsers provide is parameter substitution. In order to do that with native arrays you'd have to implement your own solution for that. ... Not saying it is difficult, just saying you don't get it out of the box.
Thanks! I was really happy to finally get this release out there. I'll be doing some under the hood work soon, to split up the Klein class into more dependency injectable abstractions, but my focus is keeping everything backwards compatible.
For those that are not familiar with the standards, could you describe some of that here and possibly use it to fuel additional summary documentation to introduce each of the packages? With that said, I'm a sucker for small, focused libraries and packages and everything looks pretty straight-forward if you're familiar with the standards. I would also point you towards various recent developments of value objects for both Country and Currency that may or may not benefit from this as a backing technology: https://github.com/mathiasverraes/money https://github.com/nicolopignatelli/valueobjects/blob/master/src/ValueObjects/Geography/Country.php (surrounding collaborators) I have some technical critiques to give, but will leave those on respective repositories as issues rather than lay them out here. Good job!
I kind of understand his point. Your provided README example is only valid for ~5.4, so I think it would be nice to either: a) also provide an example for those living in the poor ages; b) adjust the version constraint. ... Also your installation code block mentions `perwinkle` (should be `periwinkle`).
Well I intentionally did not describe what the standards represent, since I figured anyone looking for this data already knows what they are. Looking forward to reading your critiques, and I might reach out to those projects you mentioned.
&gt; Note that parameters do not have this issue because they are invariant, meaning that inheritors have to exactly match the parent type. Could you expand on what you mean by this? I can certainly declare a child class and override a parent method using type hinting and hinting a different type in the chld method's parameter than the one hinted in the parent method's parameter. Does that make sense?
Just wanted to follow up on this a bit more. I've got a very similar event driven design underlying the the result printing - I did build that portion with different reporters in mind but I haven't committed to the design yet. Once I'm more comfortable with that I might start actively encouraging it!
How about you don't reinvent the wheel and just use FastRoute instead?
I'd say look at Symfony 2, Laravel and Yii
Why the downvotes? He's pretty much correct. CodeIgniter is outdated, don't use it. CakePHP is still maintained but uses bad practices and conventions, stay away from it. Your best bet is Laravel (beginner) or Symfony (advanced).
Thank you for your advice :)
Do you recommend any one of those 3? And Why?
For speed of development or simple apps: Laravel. For robust, complex apps: Symfony. I've never used Yii, so I can't weigh in there. 
Have you taken a look at: https://github.com/danielstjules/pho That is my current testing solution, how do you think your solution compares?
I recommend Laravel, its a great framework and for a newb there is no better way to learn then Laracasts: https://laracasts.com/ Just watch the Laravel 4 from Scratch Series: https://laracasts.com/series/laravel-from-scratch 
Well I've never been a big fan of static methods either, but.. Using functions the user would have to constantly input the source array as one of the arguments (alternatively I could load it every time the function is called, or load it once and introduce a static variable inside the function but then we're back to square one...). I can change the visibility of the source array in the class with static methods from protected to private and remove the overloading functionality from load() so users would never be able to provide an alternative source, thus making it immutable. But that seems kind of extreme. I don't want to make this into a class either. TL;DR -- I see no compelling argument to drastically change my implementation. Nor do I see any abuse of static here.
Urm there's a discussion right now on internals.
Surprised nobody has asked yet: what's the nature of the project? The type of thing you want to build could have an impact on what framework you choose to implement it.
Have the user instantiate an instance of your class. When they call a function, load the data and store it in a regular (non-static) private property. If the programmer needs to access your class a second time somewhere in the code, they can make a new instance and reload the data again. If they don't want to do this then it's their responsibility to keep track of their original instance and use it later. It's not your responsibility to force all of your data to remain loaded throughout the life of the application. I'm guessing your data size is a couple of KB. That's not a lot, but imagine if heaps of libraries did the same thing. You have all this junk sitting in memory that the programmer isn't using, and he's probably not aware it's happening. If the user should be able to provide a different source, provide functions for doing so. Don't allow them to change the variable directly. If you want your code to be unit testable, you'll need a way to set the source data manually. Your test cases can't be sure if what's in your data file, and you need to test situations where the data is and isn't found.
I'm going to throw in a vote for CodeIgniter (or Cake, but I was a CI guy). I know, I know, it's not getting much attention these days, but it has simpler, more transparent implementations of the basic concepts of MVC. For example, setting up a model and carrying to from database to screen in CodeIgniter requires knowledge of model, controller, and view. In Laravel, you use a migration and a (much more opaque) model to set up your data. In both cases, you don't actually see anything very databasey (for lack of a better term) so a noob won't understand what's going on there. From there you take the data through either a simple controller (anonymous function in routes.php) or real controller (in controllers but still referred to in the routes file). A weird complication in my opinion; why don't we just a controller file for each route? Then the view system, you can use plain php, but all the tutorials use blades, which aren't terribly complicated, but still, add it to the list of extra complications. In my opinion (and I teach programming from html through php for a living), if you really want a proper understanding, you need to do one small job in plain php, one or two in a simple framework like CI, and then move up to Laravel. Sidenote: The same goes for JS– build some stuff in JS, then some in jQuery, then use bootstrap components and Angular and all that new hotness that hides everything from you. EDIT: Oh yeah, another comment reminded me– What about all the terminal artisan composer junk you have to figure out. PHP with mcrypt. For Codeigniter and Cake you unzip it and point MAMP to the folder.
Don't assume people know what iso standard numbers are for. All you are doing is hurting the discoverability of your projects. And possibly making people overlook them because it is vague unless you go look at the code.
Thank you so much for the detailed reply! It's a small CRUD app so I don't foresee the codebase growing into a complex beast. It seems like lots of others are recommending laravel
Thanks so much for your reply. I'm making a small CRUD app with a Coue of pages so it seems like Laravel is the way to go.
Awesome, thanks so much for the links!
Fair enough! Consider the following GitHub searches: * ["country code"](https://github.com/search?l=PHP&amp;q=country+code&amp;type=Repositories&amp;utf8=%E2%9C%93) * ["standard currencies"](https://github.com/search?utf8=%E2%9C%93&amp;q=standard+currencies&amp;type=Repositories&amp;ref=searchresults) Feedback was geared towards promoting the packages if that was something you're interested in. These packages explain more about the standards and what the specific implementation does. This, in effect, makes them more searchable and identifiable. Someone looking for "a valid set of countries" may not know to search for ISO *anything*. Someone approaching a Currency value object may not even be aware of ISO standards. Including this documentation increases the probability they will stumble across your package! :) Looks like PHP doesn't have an ISO-backed Currency offering based on my 5 minutes of packagist/GitHub searching. However, there does seem to already be some level of ISO-backed country code representation. Food for thought.
I appreciate you providing that different point of view. I'm not an expert in the things you mentioned but I do know a bit about that stuff from prior web development experience. Thanks for your advice!
Its just a small CRUD app with 2 or 3 pages. Nothing huge here.
Don't trust user data. Never trust user data. Either transform Numeric values to real PHP numbers, or use the proper escaping functions for each database, when handling string values. Also, while you are learning about SQL injection, check out "XSS attacks", "password hashing vs password encrypting vs plain passwords", "php validation", "CRSF", "php timing attacks", etcetera :)
This response provided excellent points. I'm a college student right now and I've taken a few web dev classes. I haven't worked on any substantial projects, so perhaps you're right about using codeigniter or just plain old PHP. Its a simple CRUD app with 2 or 3 pages with some JS/jquery in the front
Borsnor, this is the essence of technical feedback I had. I would recommend maintaining an instance of the class and optionally providing framework-specific facades to simplify the construction and usage of the package according to the terms each would likely speak. Even your current static interface could be regarded as a "Native" facade that proxies calls to the instance. It's arguable how much this buys you, but it's food for thought. At least at that point, you can have a simpler time testing. There's really not a lot of behaviour here, so it may not be worth it? That's up to you! :) The comments RyanDwyer has made regarding data-access are valuable to consider. This would allows an abstraction in data source that decouples your implementation from backing source data. This is arguably valuable according to the goals you have for your package. I maintain a package for validating educational email addresses backed by the Public Suffix registry. This data is continuously updated and is fairly large. If you expect your backing data to change or grow, I would stress importance here. This problem has bitten me a few times. I would also suggest giving the package the ability to update data separate from your source control. In other words, you shouldn't have to roll a new version of your package *just* because the data was updated upstream. However, that *is* an option depending on rate of change. The current implementation is "fine" according to the documented goals of the package, but I do think Ryan's comments are worth consideration in addition to above.
That edit also makes a good point. I'm more of a LAMP guy but I understand what you're getting at.
&gt; In Laravel, you use a migration and a (much more opaque) model to set up your data. In both cases, you don't actually see anything very databasey (for lack of a better term) so a noob won't understand what's going on there. One might argue that being able to version control your database schema changes is very beneficial. One might also argue that before a 'n00b' starts using a rapid application development framework they should have a solid grounding in "databasey things". &gt; EDIT: Oh yeah, another comment reminded me– What about all the terminal artisan composer junk you have to figure out. PHP with mcrypt. For Codeigniter and Cake you unzip it and point MAMP to the folder. Cake 3 is composer all the way. Cake has had the command line "bake" utility for a long time. I no longer use the framework but it's got as much "junk" as you put it as Laravel does. And that "junk" is amazingly good for productivity.
Looks great. I'm trying to find something I do better ;) - I love that you've implemented a file watcher out of the box (and are leveraging inotify). - Deep nesting is there! - I like configurable namespace flag - which is a nice solution to the lack of use function prior to 5.6. - Your root namespace is also convenient: `pho`. - You're sticking with PSR-4 throughout. I was torn on this for the test files but it's likely going to create issues for people that automate checking for it. For the CLI - I jumped straight to symfony/console. I generally find myself repeating the last command with arguments tacked on symfony/console is pretty robust about argument / option ordering. But it also doesn't support a default command + arguments which necessitates the redundant `test` subcommand. For the expectations I forked esperance. I like what you've done here. You've certainly got a more complete set of assertions. I'm looking to chaijs for inspiration here. I do report failures that occur during the hooks and associate them with the active test. Really interesting to see the convergence WRT to context handling and organizing the DSL between matura, pho, and peridot. 
&gt; And that "junk" is amazingly good for productivity. Agree 100%. I'm using Laravel now and loving it. But 4 years of CI and 1 year of bare PHP helped me wrap my head around it. 
Forgive me, but wouldn't this junk just sit in memory too if he were to create an instance and pass that around (dependency injection)? Re-instantiating the class every time you want to use it seems to me like it would lead to a bigger performance impact in some (or most?) situations, since it would have to load the data array again every time. In my current implementation it's the same, the junk isn't in memory until you call it for the first time. I suppose I could not store it at all, but I imagine reloading the source array would have a bigger performance impact than keep it loaded once it has been read. I could add an unload() method but I have a feeling it would see very little usage..
Fair enough, I can add some information to the readme, even if just to aid discoverability. Thanks :-)
This is a very questionable design 
??
It's a totally different approach
What I mean is, PHPUnit has a special assertion exception that must be used to indicate test *failure*, as opposed to a test *error*. Does Matura have a similar exception? Or is it just a case of, throw whatever exception you like?
You can change parameter types when extending a class, but you can't when implementing an interface. I'm guessing this is what Levi meant. I don't know if this behavior is considered a bug, a feature or just undefined (neither would surprise me).
Why can't I star things on bitbucket? :-(
Well the fact that this data rarely changes was one of the reasons why I actually went with a simple data array access implementation. I did not want to enforce any specific kind of value object also because I'd rather leave that up to the user. Trying to stick as close to the single responsibility principle as possible. I have made some changes to https://github.com/alcohol/iso3166 (BC breaking ones) that I am considering for a 2.x release. Feel free to head over to Github to provide more feedback (or leave a reply here). :-)
If I understand correctly the issue is variance of typehints, which is broken right now (for parameters *and* return types). **parameters:** Currently, parameter typehints need not be compatible when extending a parent class; or need to be exactly the same (invariant) when implementing an interface. The commonly considered correct behavior would be contravariance: wether you are overriding or implementing, parameter typehints must be the same or less specific (a superclass). This way any `SomeImplementor` can still be used as a `SomeInterface`, aka the Liskov Substitution Principle. **return types:** The return type RFC says return typehints must be covariant. In plain english, when overriding or implementing a method the return type has to be the same or more specific (a subclass). So I guess there are two issues: 1. The RFC's implementation is faulty, and fixing is not trivial (because of php's single-pass architecture). 2. The behavior is not consistent with parameter typehints. I don't know if (2) is even being considered as part of the problem. Imho it should be, but that would imply a (major) breaking change. If it isn't, the result is backwards compatible but inconsistent.
You already asked this, no need to repost.
&gt; It's not PHP, so it's portable Portable to what? You're *never* going to use a Laravel config in a non-Laravel project. And Laravel is strictly PHP. So.....where exactly are you planning on porting your *configuration* files? &gt; It's not too verbose Not are arrays. &gt; It has more features than INI So do PHP arrays. In fact, PHP-array configs are Turing complete. They've got an entire language built in! Build your array anyway you like.
Why don't you just put that data into the class instead of loading it from a file?
You'll never guess what the first link on google is: http://i.imgur.com/5od5UvP.png
There's an exception hierarchy. I'm using them internally for things such as skipped tests (as well as failures) but the code isn't specifically aware that Mockery's exceptions constitute a test failure. They definitely should be!
You can, it's done by becoming a watcher. 
I still feel the overhead of preg_match() over every route item in a collection is still a minor processing overhead vs. the rest of your page request life cycle. But I do agree with your point that most captures are just [A-Z] or [A-Z0-9-] in practise. Still having the ability to (option1|option2|option3) where feasible does allow to short circuit invalid routes before even hitting the controller/business logic - so can work in your favour. For my current project have just mixed regular expressions and str_cmp() matches for simple routes - running the str-cmp() tests first. 
There are plenty of systems out there that consists of multiple languages. Even PHP has its limitations. It's always a good practice to have configurations language-independent. If you're not into YAML's structure, there are always JSON, XML, or even plain text.
Eat the brains of a better programmer. Dibs on philsturgeon
There can be only one...
Here's a list I compiled, the list books kind of hit a wide range. I don't really have any given list of talks I like. I'll just randomly google for videos by a speaker i like or subject I'm interested in. Books: - [Patterns Of Enterprise Application Architecture](http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420) - [Design Patterns: Elements of Reusable Object-Oriented Software](http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612/) - [Domain-Driven Design: Tackling Complexity in the Heart of Software](http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215/) - [The Grumpy Testing Bundle](https://leanpub.com/b/grumpy) - [Build APIs You Won't Hate](https://leanpub.com/build-apis-you-wont-hate) - [The Art of Readable Code](http://shop.oreilly.com/product/9780596802301.do) Watch: - [Rafael Dohms at Kings of Code Festival 2012](https://www.youtube.com/watch?v=H2AvoAzbGOE) - [ PHPNW13 Track 2 Talk 5: Ross Tuck - Models and Service Layers; Hemoglobin and Hobgoblins ](https://www.youtube.com/watch?v=3uV3ngl1Z8g) - [Aloha Ruby Conf 2012 Refactoring from Good to Great by Ben Orenstein](https://www.youtube.com/watch?v=DC-pQPq0acs) Podcasts: - [dev hell](http://devhell.info/) - [PHP Town Hall](http://phptownhall.com/) - [Larave.io Podcast](http://www.buzzsprout.com/11908) Blogs: - [Mathias Verraes](http://verraes.net/#blog) - [Eric Barnes](http://ericlbarnes.com/) - [Phil Sturgeon](http://philsturgeon.uk/) - [Fideloper](http://fideloper.com/) - [nikic](http://nikic.github.io/) - [Ross Tuck](http://rosstuck.com/) - [Use The Index Luke](http://use-the-index-luke.com/) News Letter: - [Laravel News Letter](http://laravel-news.com/newsletter/) - [websec.io](http://websec.io/) Misc: - [Twitter List of php devs](https://twitter.com/CalEvans/lists/phpeople) - [php architect magazine](http://www.phparch.com/magazine/2014-2/october/)
Also dibs on jtreminio
No, you are not allowed: http://3v4l.org/VhYmM Technically it doesn't fail, but it does emit a strict standards, which means you absolutely SHOULD NOT use it.
Take the PHP out of the question and you are on the right track. Programming is an idea that is abstract from the language you write in. Some languages are better suited to certain types of programming but the concepts themselves are still separate from the language. You look like you are interested in Object Oriented Programming as your next choice, which is great! Laravel is a fantastic framework as well, and will show you some really cool things you can do with OOP. But it might be better to try to make your own small system, and thoroughly think out the architechture of it. To really learn what it takes. Look up as many programming paradigms as you can and learn the differences, look up principles you hear mentioned in those articles and never think "I don't know what that word means". Give it a quick google if you are not sure what a certain term means. It is really just about learning in the end though. Learning by doing seems to be one of the more fun ways to learn!
Thanks for taking out time to review this. Please correct my views on your points. 1. I wanted to access one/two configuration variables inside my classes, so i kept them global. There isnt too many singletons. I am using redbean which is singleton. But other than that the entire framework is non-singleton. 2. No namespaces (working on this). DI - I do understand the concept, I am little confused on how to implement this. 3. No tests - (pending) 4. Redbean is a lib which i added as an optional db wrapper. I am very much open in working on this and it would be great if i can get some guidance.
Learn a new language. No, really, before you close the browser in disgust, hear me out. This is not an "us vs. them" argument. Other languages will introduce you to new concepts and other ways of doing things you probably haven't considered before. This will have a direct impact on how you view the things you're doing in PHP. You'll almost certainly write better PHP as a result because you'll carry those concepts with you.
learn java circa 2003-2009 and apply everything you learn there in PHP. people here tend to make writing small web sites like rocket science. because software engineering, they say.
this won't fly! not enough interfaces and classes! i'll be watching this on packagist!
using an array won't require you anything extra. using yaml, well you include everything including your mortgage agreements with your banks. but yeah, software engineering, right?
Write small bits of code! Here's a start: Do the Bowling Game Kata to learn the basics of TDD. Look through the Wikipedia pages on SOLID code, keep Googling from there until you can write an example of something following for each of the SOLID principals and an example of something that violates it. Learn to recognise the differences. Look at the Wikipedia page on programming design patterns, if any don't make sense then keep Googling until they do and then write a minimal implementation of them.
It's easy to earn money with it nowadays :)
OMG. People should Google an ISO standard (knowing they exist) for country codes then search for that ISO code implementation in PHP instead of just searching for a country code PHP library. What an amazing thought! Really, it isn't "bothering" the project owner. It is some constructive advice on how to improve the discoverability of the project so more people can find and use it.
Because they're idiots and didn't want to become as popular as Github (same reason why they have no nice way to browse / search public repos)
It's crap compared to others, but it's easy to get into as a teenager, and a lot of new startups use it because you can start developing for it fast and cheap. Which in turn got me my first high tech job as a person out of the army with no degree, because I was able to learn it without guidance. I'm trying to move towards other fields now. 
I am considering it now that I removed the overloading method. It would make the file rather enormous though.
You should note your data sources and how frequently you're updating the data (country and currency lists are not static!) Also, while it's in the LICENSE file, also specify the license in the readme (typically at the end and in "human readable" form - eg "MIT" / "GPLv3")
I'll cite some sources (I had to merge stuff). The license is mentioned in the top of the readme as a badge. It's not clear enough I guess?
Please post this to the Yii Wiki. This mind map would really help when implementing core interfaces or extending core classes to support additional functionality. And thank you. I'm thinking of printing it out and putting it up on a wall. 
You know, some people here actually do this for a living and work on large projects.
Hi, I have a similar library: http://github.com/commerceguys/intl Generally, I think iso3166 and iso4217 are pretty confusing names, very few people will be able to remember which is which. Also, CLDR is generally a much better source of data for both currencies and countries, which is why both Symfony and Drupal rely on it instead. CLDR includes translated currency names and symbols, and translated country names. It also includes more precise currency data, for example ISO might claim a currency has 2 subunits (100 cents), but inflation might have made the subunits unused. In this case, CLDR follows the actual usage and tells you that the number of subunits is 0. This is the case for my home currency, the serbian dinar, and such precision is important in ecommerce. The country list in CLDR is also worlds better, it uses more natural country names and includes additional countries for addressing purposes.
https://github.com/mathiasverraes/money has a randomly collected list of currencies. The currency list needs to be autogenerated from a trusted source (ISO or better yet CLDR) and frequently updated. 
I've looked at cldr but it's a pain to extract the desired values from their dataset. On top of that I did not want to include localization in this package. Thanks for the tip though.
if your app configuration is so complex that you require an entire framework (yes, the YAML parser is a framework on its own) to load it into your app (set it up and tear it down on every PHP request) on every request, that config rocket science you're dealing with is probably the least of your problems. but yeah, go software engineering!
i actually get paid very well for knowing how to write PHP in large projects without using frameworks, other than for prototypes. yes, our company does not approve of symfony2/laravel, etc from a security perspective (it's a big name internet company, not some ninja-run-hipster-dominated startup), and at a certain scale, your fancy overly abstracted framework starts costing you more money than just hiring good engineers. so yeah, let's keep engineering the crap out of our web apps that serve product catalogs and for ticketing systems. because we're engineers, right? woo.
from deployment to your first hello-world, or to your first crm, it's the easiest to pick up, and the easiest to hire for. your clients don't care about your drill, they just want the holes.
your "fast" claim no longer holds up though. but it's still my goto-router when I need one for PoCs.
I tend to agree with you. However, most people's perspectives on this don't get formed until they've done multiple projects, and determination of what's important, and what's "big" vary greatly until you've done it a bit. I still see people worrying about micro optimization stuff they read about in a 2005 blog article because "well, my site's gonna get pretty big - we've already got 180 users! We had 20,000 hits last week!" "I'm not sure MySQL can handle the data load we're going to have - we've already got 150k rows!", etc. Until you're able to work on something truly 'big' in some sense of the word (concurrency, database size, lines of code, whatever), it's hard to understand the importance of basic fundamentals vs getting obsessed over generally non-important stuff (or stuff that, while important, is fungible down the road with a minimum of fuss). I think much of that perspective can only come with experience, but needs to be experience on progressively complex or larger projects, and not everyone gets access to those projects (or thinks to challenge themselves with their own projects in those directions). 
just... *do*. you've watched and read enough already. *do* more, and go back to the resources when you hit issues. Start experimenting with external systems - get to know message queues, search servers, etc. Get better with SQL. Part of the way to be a better "PHP" programmer is to understand when something is better done *outside* PHP in a better tool (SQL, solr, whatever). Talking with someone right now who's got an MVP partially done, used offshore dev team. The 'offshore' part almost doesn't matter, except, I see this problem more with offshore teams than shops/teams/devs that can meet face to face - a willingness to say "this won't work". The system is very search heavy - in fact, the only thing it does is search. Rather than saying "this is search heavy, and requires solr", they accepted the fact that the whole thing needed to fit in to a low-end bluehost shared account, and work on some older mysql version. Some screens take &gt; 8 minutes to generate - wholly unacceptable, but no one pushed back or even questioned the basic premise. It will be rewritten (perhaps not by me - not sure if we'll work together or not), but it has to be rebuilt. And I made that recommendation as someone who already tried the "let's do text searching in mysql", but i did that on my own project in 2001 and realized "this isn't good", and later found superior alternatives. PHP is often described as a 'glue' language - the more you understand other systems, the more tools you have to glue together, vs trying to write a bunch of your own stuff from scratch.
Seconded. I'd got stuck in PHP for 12 years before jumping to something else for a while. It gave me new ideas, helped solidify other ideas and gave me new appreciation for PHP's strengths.
Write more code.
[Static == Global](https://gist.github.com/J7mbo/f9a6d54de6c48a6f0e7d) [Dependency Injection](http://blog.ircmaxell.com/2013/01/dependency-injection-programming-with.html)
Where did you see me advocating frameworks? Just write clean code and use composer packages. Writing testable, SOLID OOP code should be a given. That is not overengineered, that is avoiding technical debt which will cost a compay a lot of money a few years later.
How often does this actually happen for you? How often do you need your symfony routing config or your doctrine entity mappings in another language? But if that's ever the case, sure, use something portable. Hopefully you think enough about your design on the onset to know whether this would be needed. Otherwise, it's really weird to write a config in Yaml and then immediately translate it into a PHP array.
I do that quite often. I code in several languages. I almost always break a system into two pieces. Backend service layer that's almost always written in Python and a front end view/control layer that's always in PHP/javascript. Sure routing, or any front end framework related config can be in php, but the particular example you gave, the DB config, should most definitely be language agnostic.
&gt; Forgive me, but wouldn't this junk just sit in memory too if he were to create an instance and pass that around (dependency injection)? Yes, but the programmer has the option to destruct it by removing all references to the class instance. What I mean by this is allowing the variable that the class is assigned to expire at the end of the current function, without copying it to somewhere else. PHP's garbage collection will clean up the class instance and deallocate the memory it was using. &gt; Re-instantiating the class every time you want to use it seems to me like it would lead to a bigger performance impact in some (or most?) situations, since it would have to load the data array again every time. It could. But at least the programmer has control over it. They can make a decision about load time vs memory usage and can pass the class instance around if needed. &gt; In my current implementation it's the same, the junk isn't in memory until you call it for the first time. I suppose I could not store it at all, but I imagine reloading the source array would have a bigger performance impact than keep it loaded once it has been read. Reloading the data each time a function is called is unnecessary. You should store it in the class instance so that it is deallocated when the class instance is destructed. As a programmer, if I were to measure how much memory I was using, instantiate your class, call a function (disregarding the return value) and unset the class instance, I would expect the memory available for my script to use to be the same as before. If you store your data in a static property then this is not the case.
This. No faster way to learn that by challenging yourself. 
I don't think anyone should "choose PHP for their career." I currently work primarily in Ruby and Go. The last few years I've done a lot of Python. In between all of that has been a lot of PHP. PHP is a great starter language but you should try and learn a few other options as soon as you can, otherwise you're a one-trick pony, tackling every single problem with a language that might not be as effective as another for certain tasks.
-1
Fair enough, I'm convinced :-)
I actually disagree that PHP is a great starter language. It hides too much. I think it would be more confusing to go from dynamically typed =&gt; strongly typed than vice-versa, but that is my experience.
Especially this. A huge majority of good php devs moved to ruby and python back in the old days of php ... ruby is like php without the anoying bits. Python is just lovely. Learning them, then reading the php language proposals shows you how ideas are introduced into a language and experimental features that have been tried and tested elsewhere.
Not bad. I would suggest updating the namespace you are using though since the base namespace `Twitter` makes it seem like the package is developed by them. Nice work!
Somewhere in the ISO3166 data is a flag that says if the entity is party of another entity or if it's a nation/state in its own. For example Guam is listed as being part of the US. Any chance that data could be incorporated into your dataset?
You mean ISO3166-2, e.g. http://en.wikipedia.org/wiki/ISO_3166-2:US. Guam is both a subdivision and has its own entry in ISO3166-1. I am considering writing an extension for ISO3166-2, yes. It will take some effort and time though as there is no easily parseable source available (to my knowledge).
I only use Php for personal web projects. I prefer it because it's quick to get going. I really started liking it as soon as I started using symfony.
Came here to say exactly this.
You're a good person. Thanks for this. 
I can't post an article in Yii Wiki because I am a new user there. Thanks for your answer.
Well, at least one file has to be that large.
I am still learning Yii 2. This is my first framework and I like it very much.
But wouldn't your Python backend service be the only thing that needs database configuration variables? If your friend end view layer also needs to access the database, it sounds like you're doing something particularly messy.
Many legacy sites that customers don't want to play to refactor.
Thanks very much for sharing
Join (or start) your local user group.
You know, I hadn't really thought about this, but you're right. I'm primarily a PHP shop, but work with .NET apps occasionally. (My focus is on building integration between disparate systems.) My time spent in working on other platforms has definitely improved the way I work in my native stack. And of course, there have definitely been times I wished for .NET features / constructs in PHP. 
Sure, I'll update it. Thanks!
Yeah I merged it already :-)
constantly look into design patterns, understand data structures and algorithms the best you can and constantly better your understanding,revisit code to refactor where you can, constantly be involved with one project after another. in other words, be better at php just as you'd be better at any other programming language. expose yourself to it as much as you can and NEVER forget about computer science principles. In fact, build on it. Good luck, the journey is fun and also... never complete.
Looks good. I suggest making it so you can inject a Guzzle client into your client so that users can attach subscribers and change the underlying RingPHP handler as needed.
Learning client side Javascript taught me to keep things DRY and RESTful. Learning server side Javascript taught me about async and stateless systems. Learning Ruby on Rails taught me the importance of "Convention over configuration" and unit testing. Learning Go taught me the importance of type hinting and interfaces. All in all, I'm going to be continuing to write PHP mostly because its what my job (web developer at a design agency) demands. And if I'm going to have to write PHP its going to be damn good PHP. I may object to a lot of things in the language, library landscape, and community, but at the end of the day it gets the job done.
this: http://paul-m-jones.com/archives/2420 , would be a good resource to find more info onto the inner workings of that. In a nutshell: a survey was taken on each and what we have now is what won. to get more in depth you'd have to poll each person who took the survey i guess, I know /u/philsturgeon is around
I just read the manual frequently and code new things I have no experience in.
Thanks! This answered my question: &gt; _Q: The standard is inconsistent: braces in one place sometimes, and in another place at other times. Dumb!_ &gt; I’ll refer you back to the survey; the brace rules are what the majority of member projects have already picked for themselves. (A minority of projects consistently put braces on the same line, and a different minority consistently put braces on the next line, but there was no majority that consistently put them in the same place.)
There are getters and setters for the Guzzle client in the underlying Connection class, can't those be used?
I agree. its easy to start with but the language itself is ugly. If you don't have experience it will be hard to create good code.
I'm particularly baffled about why these shitty, pointless posts keep getting made about coding style guidelines. Do you honestly have nothing better to talk about? Are you so worthless and stupid that this is it? Should we start talking about tabs vs spaces next?
A great point. In fact, I think Laravel is so good because Taylor came from a background in other languages so was able to bring "the good parts" from many coding styles and paradigms. There is never a good reason to NOT step out of the box from time to time.
Any exception will do for failing a test. The test.failed event will send the specific exception along to any listeners if you need it for anything.
And High School never ends! Talk about forming irrational standards from what the masses already do! Then again, I was a non-conformist in high school and I'm a non-conformist now. 
PHP has enjoyed as much success as it has because it fits a very specific set of criteria that caters to the needs of an extremely large developer base. It is FOSS, dynamic, interpreted, ubiquitous, mature (in the "it's been around forever" sense of the term), supports the most common OO features, and has a great community behind it. No other language satisfies *all* of these criteria except PHP. Some of them are very close, like Python or Ruby, but lack some of the pieces of the puzzle. That's not to say that they aren't as good (both are arguably better *designed* languages), but they don't cater to the masses like PHP does, as a result. That being said, I'll parrot /u/philsturgeon here, in that no one should be choosing a specific language for their career. You will be drastically limiting your growth, and doing a disservice to your employers. You should use whatever tools best fit the specific scenario that you find yourself in. Now, that doesn't mean that you can't *specialize* in a particular language, or even that you can't *prefer* positions where your favorite language is the primary tool. I think most developers end up doing this knowingly or not anyway. Just make sure that you aren't slipping into the practice of mashing square blocks into round holes, and you should be okay.
I refer you to the very next q&amp;a in that link: &gt; **Q:** *Wait, you mean the rules are defined by a survey, and there’s no design involved at all? Brain-dead!* &gt; &gt; The “design” portion happened in the individual member projects. The survey identified common elements of design across those projects. The follow-up discussions refined the broad commonalities, and the proposal codified them.
But I don't want to be notified of changes, I just want to be able to find it again.
That's fair, but again, because it's actually a PHP script you can easily do return [ 'database' =&gt; json_decode(file_get_contents('db.json')), ]; Which should satisfy the 1%ers that are using multiple languages.
This is interesting, but it's not modular so I can't include it into other existing applications.
Do you care to explain what exactly a BaaS is? I'm having trouble understanding how a service could possibly handle all my server-side code, unless what you really mean that it's a set of helper methods, which really doesn't sound so different from a framework.
I prefer tabs.
That's conflicting with the following q&amp;a: &gt; **Q:** *Coding style is all personal preferences. How can you make a “standard” out of them?* &gt; On one hand, you’re right: a style guide is a collection of preferences. On the other hand, it’s not exactly personal when a lot of different projects run by a lot of different people indpendently arrive at a similar set of rules. Design or personal preferences?
This part: &gt; it’s not exactly personal when a lot of different projects run by a lot of different people indpendently arrive at a similar set of rules 
Three words: "Design By Committee"
Just don't use PSR-2, simple.
tabs + spaces for alignment, man it's the new generation, man
Why Cygnite instead or laravel/symfony ? People should contribute to opensource frameworks rather than creating yet another one.
That's K&amp;R style: https://en.wikipedia.org/wiki/Indent_style
Most PHP programmers make the same damn mistakes and go along the same growth trajectories and stumbling blocks. How many of you actually started with proper DI OOP, for instance? or even learned how to utilize breakpoints in a semi-modern IDE within their first 6 months? Hell. I work with people to this day with 12+ years experience that STILL do not use breakpoints and step-ins to debug complex apps. It's *so* frustrating! [and, no, TextMate is NOT a substitute. PHPStorm runs circles around that.] The way I've been able to help people is by mentoring them to avoid all of the false starts and nonoptimal strategies that, while mostly work, aren't optimal. By not forming bad habits and by continually having the mindset that you need to learn more. You know you're in a good state when the code from 3 months ago looks like crap and you always have a desire to refactor all of your code, but have enough new projects that there's hardly enough time :-) After mentoring about a dozen people, the average person ends up going from zero knowledge to $20/hour jobs within about 6-9 months (depending on their dedication), $35/hour after about 18 months and $50+/hour after about 2 years. E.g., I think with mentoring you cut down about 8 years of false paths and bad habits. That is seemingly much more time effective than "college", which didn't prepare me for much of anything. EDIT: These hourly rates are all outside of NYC and California. All of my apprentices have come from mostly low-wage areas like Detroit and Houston, for instance. In CA and NYC, I would expect roughly double.
Read other people's code.
&gt; Tabs vs spaces. All of this crap is just personal opinion. Tabs vs spaces has always been about technical requirements for me. Same as line endings. Yes you can use a mix of \n \r\n but don't claim it's personal preference. There is an optimal use case by sheer volume. The rest is complaints from users who have not had enough experience. The inexperienced usually outweigh the experienced in both technical projects and communities (eg this sub).
I was here to say the same thing.
Thanks so much!
It isn't meaningless at all. If multiple developers on the same project have their editors set to use spaces sometimes and tabs sometimes, commits wind up with tons of line changes that are all just tabs to spaces. This makes code review a pain in the ass. This might seem trivial, but when you are trying to merge multiple feature branches into on rollup that covers potentially thousands or tens of thousands of lines of code, having the indention a change all the time makes diff viewing damn near impossible and waste a huge amount of time. Source: I've personally seen those diffs. Inhuman.
Yes.
Correct, I've not done any real C, didn't realize it had the same convention. Thanks!
I figured it out. It's fast and returns same results, but not as elegant. &lt;?php $list = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; $array = str_split($list,1); $count = count($array); for($i = 0; $i &lt; $count; ++$i) { for($j = 0; $j &lt; $count; ++$j) { for($k = 0; $k &lt; $count; ++$k) { echo $array[$i].$array[$j].$array[$k]."\n"; } } } 
Hi mahacctissoawsum, Hook is a "no-backend" solution. (http://nobackend.org/) When you're creating a back-end there is a lot of decisions to make. Also some kind of integration with front-end (mobile, websites, etc). Hook already made some decisions for you, such as: - which database should I use? (mysql?, sqlite?, postgres?, mongodb?) - where should I store my uploaded files? (local filesystem?, aws?, azure?, dropbox?) - how should I define my models and database schema? you may just store data structure, hook will create the schema if you want to - which authentication system should I use? (email/password?, facebook?, twitter?) - built-in forgot password integrated directly on frontend clients If you want a custom feature, it is still possible to extend the core with custom routes and custom observers for your collections of data.
Or React + Flux, the frameworks that Facebook actually use.
Good to know, I never noticed that from [the manual](http://php.net/manual/en/function.str-split.php), but yea I suppose the accident is good for those learning.
Just saw the docs, seems it is an open source framework http://www.cygniteframework.com/2013/07/quickstart.html
Start with the Laravel From Scratch series on Laracast
Strangely, no -- the rules ended up being very similar to the older Horde/PEAR standard, with some minor differences.
&gt; The fact that PSR-4 Autoloading is awesome is not simply a matter of opinion. It's the only part of the PSRs that offers any real meaningful PHP Framework Interoperability worth caring about -- and it's massively important for PHP and the community. As did PSR-0, descended from the Horde/PEAR standards, before it. &gt; PSR-4's autoloading (a-thank-you, Composer) is the only thing I really care about. You can thank *me* for that, if you please, along with Beau Simensen who provided a final assist. Composer's just an implementation of it.
&gt; your clients don't care about your drill, they just want the holes. Love that. I'm going to use that saying in the future :) 
 &lt;?php $list = array_merge(range(0, 9), range('a', 'z'), range('A', 'Z')); foreach($list as $c1) { foreach($list as $c2) { foreach($list as $c3) { echo $c1.$c2.$c3."\n"; } } }
&gt; It isn't meaningless at all. If multiple developers on the same project have their editors set to use spaces sometimes and tabs sometimes, commits wind up with tons of line changes that are all just tabs to spaces. This makes code review a pain in the ass. *Project conventions.*
&gt; Tabs vs spaces has always been about technical requirements for me. Well that's just your opinion :P Especially with the "for me" part.
I thank everyone involved in PSR-4 and Composer :) I thank PSR-4 for setting the standard, and I thank Composer for making it easily accessible to me
&gt; Especially with the "for me" part. I explicitly stated it's not. The priority choice is mine.
...Personal projects.
You are cherry picking sentence fragments to make a point, that doesn't apply. ie You have implied tabs-vs-spaces is somehow still an opinion based decision, on my part, because the post included the words "for me", instead of comprehending the full statement. Some people pick Tabs over spaces for convenience with an associated technical justification. Some pick spaces over tabs for convenience with a technical justification. I pick solely on technical merits, I don't care about convenience.
&gt; Or was it just to get everyone to stop arguing :) I'd consider that one of the best of reasons. 
So does your comment mean you are convinced project conventions are a good idea now? It seems like you were adamant that they were a bad idea two comments ago.
while I prefer /u/cosha1's code, for yours, you don't even need assign it to a variable, you could have done this: $count = strlen($list); then echo $list{$i}.$list{$j}.$list{$k}."\n"; (you can actually use [ ]'s instead of { }'s, but I like using the braces so when I see the code later I know I'm accessing the position in a string instead of normal array use.)
&gt; *I mean seriously, does anybody here have an issue with conforming to another project's conventions? C'mon, we're professionals here!* Now you can tell me whether I think project conventions are a good thing, or a bad thing. Consider it a reading comprehension pop quiz! 
At home, I mostly use PHP to feed my dog. No, man, I make websites and stuff with it. Personal projects, man.
You do realize that psr-2 is other people standardizing how they want their projects formatted, right? My problem isn't that I don't see words in your comments. My problem is that you aren't making any sense. If you have no problem with other people's project standards, how on earth could you possibly be upset by other people's project standards?
&gt; *If you have no problem with other people's project standards, how on earth could you possibly be upset by other people's project standards?* Tabs vs spaces, braces, etc -- all these ancient and endless debates have *not* simply been waiting in turmoil for all this time just hoping for the PHP-FIG to finalize the conclusion and save the day. The debate on these aesthetic coding style preferences is bigger than the PHP-FIG, and is bigger than PHP itself. For the PHP-FIG to waltz in, and declare that they hold the absolute conclusion and that everybody else is wrong, is what I have a problem with. I will have as many newlines between my `namespace` and `use` statements as I damned well please! And what a thing to take a stance on, anyways. It's just aesthetics. I think they should focus on the important stuff like Autoloading. Telling people how to tab or brace or newline is just a waste of time. I think it's perfectly natural and OK that different projects have different stylistic approaches with regards to these aesthetic preferences. Variation there promotes evolution.
Lots and lots of personal projects since it's the only place I get to use PHP. A couple of those projects have actually gained traction, so I'm having to approach them with a more production level mindset these days.
Yes Cygnite is open source framework. Thanks!
I think it chose me. And it isn’t really “my career” - I just choose it for most REST service implementation these days. I’ve got stuff out there running in rails, django, java, even Smalltalk. They were all a PITA to deploy requiring way too much fiddling and futzing to get running and more importantly KEEP running. All of the above have, at various times, netted me calls from clients complaining about “bad gateway 502” errors - which means the damn app process has died. PHP deploys easily. Just copy the files into place and you’re good. PHP is reliable - It runs in the web server - if the web server is up - so is PHP PHP scales like crazy - it shares no memory between calls and its fork exec “die a thousand deaths” serving strategy is more reliable than the others “live, leak, and die” cycle. PHP is a fairly powerful language. Its object features are dynamic and rich - more capable than pseudo object languages like Java. PHP integrates well with other libraries - all the stuff I tend to need is available with PHP interfaces. Databases, cloud services, payment gateways... PHP shares a lot of C’s api and that makes it easy and familiar for me. More recently - PHP has gotten a nice module system in composer and a good MVC/Rails style framework in Laravel. Bottom line - PHP is low on hassles for simple servers vs all the “popular” solutions like Rails or Java servers.
Made several crawlers-downloaders for websites where normally you would be expected to manually go to each page and download everything yourself manually. Great regex practice!
Here's 14 chapters on using mysql_ functions!
i made a kitten site.
I use it to backup images from my ip camera (It grabs the current image from the camera, saves it as a file, zips the files for each hour etc). Can also play back said images from a given time period. Using cPanel API and GoogleAuthenticator (for 2 factor authentication security), I made a script that updates a subdomain with my current home IP address every few minutes so I can SSH to my house from anywhere. This doubles as the target for my OpenVPN, Teamspeak domain (Hosted at home too) and other services I have. Created a smart power board with with a RPi and a relay board, so that I can turn devices on and off from over the internet (PHP ran some scripts that I created on the RPi to access the GPIO ports). I created a ADSL2 modem in Linux (ADSL2 card running inside a mini-ITX box) and I used PHP to write the UI for it so that I can easily configure DHCP, DNS, username and password etc for the modem (Instead of messing around on the CLI). It had pretty graphs drawn too that showed my line signal strength, sync rate and that (I used PHPlot to draw the graphs).
Use input fields to create webpages and then append text to them to make lists of things.
Framework or any open source people it is just to help people. Here are my opinion. Symfony is much better for enterprise development, I am also fan of Symfony but very large libraries. Cygnite CLI is also build top of Symfony console component. Laravel may be good in its own way, has good feature though but most of the library borrowed from Symfony and other third parties. Recent versions are completely dependent on other packages, I would say I will rather can use Symfony instead Laravel though I am not against Laravel. Regarding Cygnite it has very less dependencies but good features in it. On active development i can see. Currently it fit for small, mid level projects. [You tube channel] (https://www.youtube.com/channel/UCCTfZwaRCaPJ_270Z5Hh0VA/feed) Everyone has different opinion, using new framework is real fun with learning things and the post was not about "Framework Battle", post just shared a simple script with demo, hope it may help some people. Thank you 
how is it done? just wondering..
My dear Friend @tf2ftw. Thank you for your comment. It is not framework battle here rather shared a sample script which may help some people. Yes, CodeIgniter was one of favorite framework but it is almost dead now. Not sync with PHP latest features. :) Thank you!
React is good one for building UI. thank you!
I use a mysql book for my monitor stand ;)
Various php related code analysis stuff, in php with php, using the excellent nikic/php-parser library.
Big thanks!
Just use your vendor name, that solves it and is the best practice. 
Nice! What ADSL card are you using?
I'm using the Traverse Viking PCI ADSL2+ PCI card.
Definitely in for tabs + spaces for alignment! I wonder why people keep going with tabs or spaces only.
Downvoted: * Uses the name of a [well known site and book](http://www.phptherightway.com/), (which are written to a much better standard of quality) which could make people think it's related when it's not * Recommends editing composer.json to install packages when using the commandline commands is the recommended method. * Makes no attempt to explain version specifiers or stable / unstable or how to manage versions that will be installed / upgraded. * Does not describe how to find packages (via packagist) * Claims you can use composer and not pay any attention to package versions, when this is incorrect (especially for packages which don't (explicitly) follow [SemVer](http://semver.org/))
1 . Never knew there is a well known site and book for this , it is a title and need to be related to the content posted , it is a beginner series on how to use composer , namespacing and autoloading (will add in next posts) 2. Editing composer.json is not a disaster . I was explaining what are different parts of composer.json file so said to put directly name in json file . 3. what do u mean by how to manage installed/upgraded versions . Maybe you should go through post one more time . 4. it is described that you can find packages on packagist.org 5. I wont be spoon feeding you by showing you everything when a developer just need a simple step to get started with using right tool and he can find necessary references .
I used it just like other scripting languages (e.g. Python or Perl) using php-cli, which lets you run PHP code on the command line.
I use cron that runs my php files which use curl to fetch pages then parse them mostly using xpath and store in sql. Sometimes they send notifications using email, pushbullet or pushover.
We have once created remote controlled Lego robot. PHP wasn't able to command him directly so we had to code small Python bridge. Then we bough 5 webcams and put live streams online. Then we coded nice website in Flash where visitors could see robot and command him via PHP and that Python.
A CLI script to help get an invite to Google Inbox by checking a Reddit comment thread for new posts every second. It's crude but it worked :-) https://gist.github.com/colinodell/a70c6f0cdcd8f3036da4
When I actively DJ'ed a number of years ago I kept all of my music in a local web app made with PHP &amp; MySQL. Stored the basics along with BPM and subjective fields such as mood and genre. Also had lookup tables to indicate requested or appreciated tracks. It wasn't much to look at but functional. :)
For example for those typical websites that show you a folder and file listing where you can click to open folders or download files: `file_get_contents()` on the starting URL, pick the relevant HTML bit with `preg_match()`, do a `preg_match_all()` to fetch all the link items, determine which ones are downloadable files and download them, recursively open the folders in a loop and repeat. I've written one to download manga strips from online manga reading sites by feeding a URL, having the script download the strip image and then navigate to the next page after finding the link on the next button. Then typically to jump to the next chapter you would have to increment the chapter number on the original URL by 1 and repeat.
Ok, here is how you can improve your code base: 1. Delete all your code 2. Read and watch everything in [this list](http://stackoverflow.com/questions/16356420/mvc-for-advanced-php-developers/#16356866) 3. Curse yourself for writing such horrible code and publishing it 4. Start writing clean code
This is cool!
i have a local git server, and I use it to generate a list of available repositories which are read only.
I believe there is an error in your second example on the readme. The if statement at the end compiles to preg_match('[a-z]'..... But I think you need preg_match('/[a-z]/'....
Thanks for pointing this out, but it's not actually my project. I just thought it was kind of interesting, so posted it here.
Yes ish.. Pathfinder was the game is was running
It works good for my Personal Home Page. 
I think using associative arrays would help, so you could have ['topic'] =&gt; array(your results from topic query here), ['other_content'] =&gt; array(other query result here) I'm on mobile so forgive if that formatting looks like shit. Anyway, please make sure you are using pdo for database access and you are using parameterized queries to prevent sql injection. I know you didn't ask for this advice, but I am guessing from your question that you are teaching yourself to use php right now, so I thought I would throw that in just in case it helps.
not every developer who uses github are native english speakers. if the project picks up a lot of interest, other people will help out in documentation. you might want to look at other languages that has a compilation/transpilation step, that make use of directory "watch" tools (coffeescript, less/sass, js build tasks, etc.) not every developer who uses PHP is happy with PHP's syntax. considering it's a transpiler for PHP, it makes sense to post it here for feedback, and not necessarily for code contributions.
two choices: 1) do all one shots using the same framework and if a security risk is found update them all 2) set up automated backups and forget about them. If they do get hacked, then restore backup and fix the seurity hole
Sticking feathers up your butt does not make you a chicken! Likewise, sticking different syntax on a shitty language does not make it a better one.
Thanks, look my problem is i'm thinking too complicated And no i'm not really learning i was thinking to complicated again haha. And thanks for the reminder to use pdo Hehe Feedback in any shape or form is welcome
Just out of curiosity, but do you read /r/PHP just to bash the language?
This would be useful for people who's programming ability is primarily limited by their typing speed.
It's a shame your comment won't be seen by default (for most people), because it's an excellent response to many of the other comments so far.
With regards to standards in general - I pointed out that the reason having a standard is important comes when many people are working on the same code base and format differences create extra work for code review. There will always be disagreement between any two people about code format, even when both have valid reasons. This is precisely why a standard is required - if there were no differences, there would be no need for a standard. With regards to your argument specifically - If you are being forced to use psr-2, the project isn't yours. If the project is yours, you aren't being forced to use psr-2. If you don't have a problem with others setting standards for their projects, there is literally no instance where you can be both upset and consistent with your argument.
Not to mean any offence, but you are clearly still learning PHP, otherwise you would not be here asking this question right now. Also, his advice is sound. You should try not to reinvent the wheel when you don't have to - just use PDO, it will make your life much simpler, and will produce higher quality results.
I think the best approach would be to just include it as part of some installation instructions wherever they are. If they don't do it, then they'll quickly realise and go looking for a solution anyway - which they would find in your installation instructions (which they should have read in the first place! ;))
Do I have to like the language to be here? Just because I think it's bad doesn't mean I don't end up using it.
Try using bower install or npm install commands in the post install/update actions. 
You don't have to like it, nor do you have to stay away from /r/php just because you don't like it. But, it would be much appreciated if you at least pretended to act respectful while you're here.
Thanks for introducing me to range!
He enjoys accumulating negative karma. I believe they're known as trolls elsewhere.
PHP cookbook for me. http://imgur.com/p9FUjau
For the time being, no. Its simply a stand alone application that's meant to be installed on a sub domain (like codex.yourdomain.com). I've thought about extracting it out into a package though - but there are no plans for that at the moment. The focus at the moment is to beef it out a little more with options for additional storage options (host docs on GitHub for example) and user authentication. You're more than welcome to extract the code from it for your application if you want an integrated approach!
If it is a once off as you say, then I wouldn't worry about it. Frequently I have to tell clients (for freelance work) that there is no such thing as a fire and forget app. There will always be security fixes and just keeping it up to date. I've seen hardened app become unusable as PHP updates and functions are deprecated and then are removed. They pay for the upfront development and then they have to pay for maintenance as well. 
And if the user doesn't have npm or bower installed?
Urrggh, it's like coffeescript bred with PHP. Can anyone pass me a sick bag?
Thank you for answering me, but I'm still not getting it. If all you write is "front-end" code, how do you handle security? - Can you really [send emails](https://gist.github.com/gr2m/5463552) from the client? - Can anyone [create a million accounts](https://gist.github.com/gr2m/5463426) by writing a simple loop? - [Hammer your server](https://gist.github.com/gr2m/5463605) by running arbitrary conversions? This doesn't sound like "no backend", it sounds like they've moved the back-end to the front-end and removed the security layer.
Urgh. Essentially this post (with minor word changes) has been cross-posted three other places, without declaration. Please read this: https://en.wikipedia.org/wiki/Crossposting
Just because OP is a beginner doesn't mean they're *learning*. ;)
The purpose of following a standard like PSR2 is to maintain consistency and to help make with readability. When you look at different parts of an application, it should not be apparent that they were coded by different developers based on the coding style.
&gt; notify the user that the files need to be copied? Tangential: isn't it easier (and more maintainable) to symlink? Probably doing things a bit differently, but I find it's handy to create a versioned symlink as part of application config to enforce desired cache-control settings.
Undergraduate project.
I just never understood the phrase "terrible language." A ton of developers hate PHP. But in the end, just don't use it! There is a plethora of different CLI/Web centric languages out there. Why develop another language which creates code for another language which you deem terrible? Seems kind of weird to me, but the project itself, in essence, is really cool.
If you are going to do this, just use an ORM already. There is no value in you writing your own db abstraction classes.
Although I don't agree with the way that /u/SeerUD is saying it, I almost agree with him fully. You __should__ be using PDO for something like this, however, when you're learning PHP never take the advice that you shouldn't reinvent the wheel. Reinventing it is the best way to learn how it works! I just wouldn't use any reinvented implementation outside of a dev environment. lol
Watch, then right under it uncheck all the notification options...
There are at least 20 webdev agencies in my city. A few of them might use node.js; all of them focus mainly on PHP. Unless you are your own boss, get to set up your own hosting and your clients aren't too picky, PHP is the only game in town. (aside: I recently had the pleasure of moving a bunch of my own node.js projects to some shared hosting accounts. Finding suitable hosting was nearly impossible. Then to get it running... I have never done so many ugly hacks and workarounds, ever. I actually had to patch formidable (node post data parser module) because the server software (screw you, passenger!) overwrites some core stuff in node and does a bad job at it. It's pretty much the same story for RoR and django (admittedly, the RoR hosting situation is marginally better)) Anyway, even if you consider PHP a horrible language, there are a lot of good frameworks and tools for it. Those don't exactly fix the language, but they do make the platform (on the whole) workable. Though I still wouldn't use it if I could help it. That said, I don't believe in this project. Imho PHP's biggest concrete issues are typing and the standard library; neither of which you can fix by transpiling - at least not without breaking performance and/or compatibility.
It's not consistent because it's not supposed to be "consistent". It's not the only way to do it but usually contravariant parameters and covariant return types is the most sensible choice. More info on the related page on [wikipedia]( http://en.m.wikipedia.org/wiki/Covariance_and_contravariance_\(computer_science\)). quote: &gt; In other words, the → type constructor is contravariant in the input type and covariant in the output type. This rule was first stated formally by John Reynolds,[1] and further popularized in a paper by Luca Cardelli.[2]
No personal disrespect intended to anyone here. Just trying to say that in my opinion, PHP has issues and a transpiler doesn't fix that. I elaborate in my other comment. If language was the issue, I am really fucking sorry! :)
The issue being I'm not sure where they should be installed to. People have different preferences for where JS/CSS files live.
&gt; https://github.com/francoispluchino/composer-asset-plugin The question was "what is the recommended practice for vanilla PHP + Composer". 
&gt; If they don't do it, then they'll quickly realise and go looking for a solution anyway You have ...... high estimations of users. But yes, listing install instructions sounds like the best plan. 
Yeah, going to do that! :)
It isn't really any shorter than the generated code in any meaningful way. In most of these examples you're just removing the curly brackets from a function definition...
I usually use a more general purpose scripting language like Perl or Python at home. I know PHP has made a lot of strides in that respect but I find the ease of use of things like the Python Package Manager and CPAN to be a huge advantage. I do a lot of media manipulation, like glitch artwork etc. I tend to use libraries like aviglitch and PIL to compress, corrupt, manipulate video, audio and image files in various ways. It's super fun! Recently I did start using PHP for the gd image library port, it's extremely easy to do things like recompressing a jpeg hundreds of times and it does it relatively fast as well!
Are there any advanced examples? I'm wondering what this looks like with a complicated function that does more than only set/get.
No, session data exists on the server side. Not possible in general. 
Ok, thank you !
&gt; You have ...... high estimations of users One of the great things about releasing your composer packages is that your target users are developers who know about things like that
I never chose PHP. I just ended up in it. I was working as a front-end developer for a company (actually a porn company - seriously) that happened to be using PHP for handling basic things like form submissions, credit card processing, etc. I got sick of waiting for programmers to do basic shit I needed to get a site working, so I started learning it myself. The more I learned, the more I enjoyed it, and over the next few years I found it to be a more valuable skill than design/development, and have been doing PHP programming since. I don't want to be a PHP programmer, though. I'd like to just be a programmer. I'd like to learn RoR, Node, etc. But finding the time is hard.
I never really understood this thinking. Coffeescript is a good example. It's cleaner and more readable - as long as your definition of "cleaner and more readable" is "looks like Ruby". There's this whole movement to make things "better" by removing semicolons, removing braces, making whitespace more meaningful, etc. And somehow this as seen as desireable when actually it's just... rubesque. People demonstrating this sort of thing tend to create artificial examples of the edge cases that genuinely make more concise code, but for the vast majority of the time they achieve little. What they **do** achieve is to mean that now instead of needing a skilled PHP programmer, or a Javascript programmer, you need a Gutscript/Coffeescript programmer. Congratulations, you've achieved nothing, added a needless step to your workflow, while also limiting your talent pool! If the goal is to obscure a well-understood and readable language in order to replace logical words with meaningless characters, then well done.
Hmm but if i do so it feels like stealing 😫