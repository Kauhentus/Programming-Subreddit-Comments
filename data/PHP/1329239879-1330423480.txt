At my job, we use Oracle - PDO isn't real good for Oracle. :(
I will totally check this out.
net tuts have an excellent set of videos on code igniter
I don't think it is a bad recommendation, if it is not about performance. Single quotes and concat is the way to go, then you are not even tempted to use "things $like this".
I just go through and build things, and then rebuild. If I try reading too much I get frustrated and prefer learning by example. By building something, I get to do some research and reading anyway by looking up the bits I'm stuck on and that leads to blogs and sites which provide other interesting articles about the same framework so I get to learn more than just what I wanted to. You'll always miss things the first time round, but you'll still gain a lot. And the next time you'll have more confidence with the basics and will find yourself able to learn the more difficult concepts which you originally considered as wizardary
I've been told that employers would sometimes ask you to write a data object for basic CRUD, is that true ?
It all depends on where the database is hosted. If it is on your computer, you can use the command-line, or a number of GUIs out there for MySQL. If it is hosted on a server, you may be stuck with viewing it with a web page.
Interesting idea. I saw someone intercept stream communications the other day to use Amazon's S3 service. Keep up the good work. While this might not be useful (yet) compared to other tools, exploration like this is where we come up with new and creative solutions. Most of our tests are failures, but it's the ones that succeed that count.
I've had that happen as well, but even as a development tool for client sites I've found most CMS's to be incredibly lacking.
I have never seen any client use their CMS properly, in spite of heaps of training. We think we're going to make the clients life so much easier by giving them the control, when all they want is for us to do it for them. Honestly I am starting to think the CMS is for me, it makes it easier for me to make the changes to their site when they ask for them. 
Sorry, I can't see offering bitcoin as a payment type getting *anybody* more work; unless your job is to develop some new system involving bitcoin. Half of my clients still pay my cheque sent out by USPS once a month.
What my experience has been is that CMS's are NOT focused on developers, for the most part. They are focused on the customer. If I use anything now, it's always a framework that has the structural work done well, or sometimes an ORM. But I don't use CMS's anymore, because they are only really useful for me, but they are not designed for me, from either a code standpoint or a usability stand point. EDIT: In other words, my personal conclusion has been that there is an inherent problem in using CMS's for websites... they do not serve anyone well.
I was getting some JavaScript errors when I tried to use the minified version, but it seems to be working with the uncompressed version. It's pretty cool, and I'll continue to give it a try.
&gt; Sometimes this is related to the database structure, other times it's related to various kinds of sandboxing that "protects" me from accessing areas of the CMS. Excuse me, but if I'm in the code creating applications, I either know what I am doing, or I shouldn't be in the code. With your average run-of-the-mill CMS, that "shouldn't" generally does not translate into "won't". Hell, things like Wordpress *require* being in the code just to create themes.
Well... I clearly have an opinion. So do you. Also, without getting into less productive discussion, I will say that I don't believe your last paragraph is correct. I've worked with enough developers, at enough firms, on enough projects, of enough types, that at this point I certainly don't *feel* like I lack expertise. I don't have trouble getting around programs like Drupal/Joomla/etc. It's been... about 5 years since I've looked at a PHP program and not understood what was going on... It sounds to me that the issue I experience has been more the people negotiating the contracts/doing sales. I've done freelancing, and in those cases I haven't really had this problem, (with one notable exception that was entirely the character of the client himself). However at all firms I've worked at it might have been inadequate requirements that lead to what I'm talking about. The worst, IMO, is when a client comes to you and has already chosen a CMS... I had a client like that once. Didn't have anything but an idea and a CMS that Must Be Used^TM . He was the only client I've ever fired.
I posted this to my wife's Facebook wall today. I thought php might appreciate it.
I pick a large project and just dive in, learning what I need as I go. I'll probably write crappy code on the first go round and at some point learn, "oh I could have just used this to eliminate all that code", or "this is great but it doesn't work exactly the way I need, can I extend it to add functionality? no? okay this kinda sucks and isn't my style of code". But most good frameworks will allow modifications pretty easily. I skim over the documentation a bit to get a general overview, but I don't try to read everything line by line and commit it to memory. I also slowly increase my confidence with the framework so I'm not overwhelmed. For example when I first start out I'll write maybe 5 lines of code, and then test the code. After I get a good feel I'll write 20 or 30 lines of code, and then test the code. After I feel confident I'll just write entire functions or pages of code without testing at all and then debug everything at once. If I tried to do that right out of the gate I would get overwhelmed and likely give up. Also, those little moments of victory of "yay! I got the form validators working!" keep me hooked on learning the framework.
The only CMS's I've ever had work (where the client was happy to use it and I was happy to work on it) are role-your-own versions where you create specific functionality for editing specific pages on their site. They are 100% un-reusable and entirely custom to their specific app but they do 100% of what the client needs... nothing more and nothing less.
I've tried a few CMS's and rolled my own too. I use SilverStripe for now which has a framework included and I don't really ever come across client features I can't implement. SilverStripe includes a kind of mixin class which allows you to use lots of different hooks in the core classes so you can achieve a lot without having to resort to hacking the core files. Quite a nice system and worth a look if you are frustrated with the other options.
Yes. Stop using framework/CMS interchangably, they're very different things. CMS: Manages all your shit, tells you exactly what you can and can't do. Custom code usually has to follow some plugin API. Framework: Handles boilerplate horseshit and gives you a place to hook in your code. Some, like codeigniter, are extremely liberal in what they permit.
Oh, I think it's a major design flaw in general. It still baffles me that despite that, Wordpress has become so popular. In fact, every time I use it, I can't help but want to write a simple alternative that strictly follows the MVC model, uses a templating language like Liquid or Mustache, observes strict separation of user roles (with admin functions being separate entirely), and includes core functionality (aggressive caching, flexible content types and custom taxonomies without code, related content, etc.) as part of the core.
That's pretty awesome. Maybe that's how this [UK council FAQ](https://lccsecure.lancashire.gov.uk/corporate/web/?siteid=5965&amp;pageid=34649) is so fucked you can't click on any links in FF or Chrome.
Why not? It's the flagship feature of php. It's one of the features to love about it. Even performance-wise it's better to include variables in double quotes than concating. Not really related but equaly awesome: if you're going to oftenly use a function in a feature you're implementing you can do $html = 'htmlentities'; echo "the string is {$html($unescapedString) } "; Disclaimer: not English, not sober. 
I'm aware of the bug, will fix this asap when I've access to a pc, closure compiler has never given me trouble, figures that it coughs when I finally make reddit notice kint. 
Xdebug requires much more complicated installation, is inferior feature-wise and can not be used in a production environment, whereas kint can be toggled in real time (eg. it can display output if you're logged in as an administrator only). It can also optionaly return its output instead of displaying it - for logging and whatnot. 
This topic is too painful to even read comments about.
I just did a band's website in Wordpress. Custom post types add a lot of flexibility to the CMS, with them I was able to give them the ability to add albums, songs belonging to those albums, ability to upload music, tour dates etc. The code would have looked prettier and executed faster with an MVC framework but I was able to do everything they asked for in Wordpress.
Yes. I label my advertisements clearly with "PHP Developer".
I don't like the fact that CKEditor has a "Paste from Word" function. I have never seen it work properly. Half the time when a client calls and asks how they can do something using the editor, we explain how to do it from the source view because CKEditor breaks the code 90% of the time.
It's noteworthy to say that I don't want to make the client a designer, either. a) They'll screw it up b) That's why you pay me. Because I can do it better.
I never had any problems installing/configuring/customizing Drupal installations. It always depends on the project, but for now, i try to do everything i can in Drupal, it saves me time.
Most don't care as long as the end result works for them. Most don't know what goes on behind the scenes.
Or learn Joomla, and get the best of both worlds. The framework has been separated into its own project, allowing you to build your own CMS or CLI app on top of it. https://github.com/joomla/joomla-platform 
Wordpress is *cool*?
Sounds like you are headed in a good direction. Implementing the things you learn into your own projects is a good way to grasp whats going on - definitely. Sounds like you are ahead of me quite a bit - I just started last October learning PHP, but I have no prior html/css experience. The good thing is that it seems that there is an abundance of free accessible knowledge to be taken in on the internet - the key is just finding the right place to look. I would totally be up for collaborating together with you. I'll send you a pm.
they all just paste shit from word in there and wonder why its all fucked up....
2009, 2010. It's been a couple years but not that long. I like MVC, and agree that WP plugins/themes have some [very] crappy code for the most part, but I doubt every developer for Joomla is a good developer that codes "strictly" MVC (if you can call anything on the web strict) either.
Sounds like you are well on your way to writing the screenplay to Misery 2: Coder's Worst Nightmare.
What is the advantage of this over something like FirePHP ( http://www.firephp.org/ ). Having the dumped variables appear inside the webpage is a major drawback. For those who don't know, FirePHP dumps debugging info into http headers that a browser plugin (part of FireFox's Firebug console) intercepts and displays in a seperate window.
I'm laughing right now because I also only just learned about this syntax last month, and I've been working in PHP for 9 years. I had a legitimate use for it the other day, but I'll be damned if I can remember what code I did it in... I think it was in conjunction with a __get magic method.
Yeah, weird. I've had them for over a year, and pay $13 and some change (with sales tax). Never had a price increase. I'm not using any of their add-ons though, so I don't know if those prices have changed.
I really don't know your situation, so I hope you'll take the following criticism with a grain of salt. Perhaps learning your tools better would serve you well? I deal with all sorts of clients and it's exceedingly rare that I can't find a Wordpress or Drupal plugin to serve whatever needs they've invented at the last minute. And in the rare case there is something outlandish, I can almost always hack up one myself in a relatively short period of time - far under the 12-15 hours you've quoted. If you're going to use a CMS for your clients, you simply *must* master it. (There is generally no good reason, for instance, for you to be messing with the database structure.) Moreover, your second paragraph indicates that you're not doing a very good job of setting expectations with your clients. You probably will save yourself a lot of trouble and hassle if you can educate them in advance as to how the technology works and how to use it on some fundamental level. I've worked in web development firms for nearly 15 years now, about as long as there's been a web. And the best thing I've learned is to communicate effectively with my clients - it solves most every problem before it can arrise. 
Sigh. php.net, php.ent, same thing, right? Right? Link fixed.
Neat and all, my only question: why google code? it's god damn horrendous
Do you recommend MySQLi over MySQL functions (I hear MySQLi is buggy), or PDO? Right now I'm using a DBAL built upon MySQL functions and haven't had any issues.
MySQLi isn't buggy, it's just awkward. I generally recommend PDO and things built on top of it that add additional utility. 
but it is similar to SNMP so not entirely unheard of! :)
&gt; I hear MySQLi is buggy Where did you hear that exactly
What I'd *love* to know is how this thing pulled the name of the variable when passed as a parameter to the "d()" function! That'd be extremely useful to me for a variety of reasons. Will research it later when not on iPad. 
Ok, found it... wow. It's actually parsing the file that called it and manually retrieving the names of the passed argument directly from that file, line 655 of kint.class.php (via fopen). I figured as much, since I've looked and looked and could never find a way to get the names of dynamically passed arguments (via the likes of func_get_args). 
FYI, this reminds me of "phar," a way to package PHP apps into a single compressed and executable archive. See here: http://www.php.net/manual/en/intro.phar.php Depending on your needs, you may also find this useful as well!
its not actually parsing the file, but only the one line from which the call came to the kint function....Right OP?
Have you tried Drupal? It has a steep learning curve but is fantastic to program on. I used to have my own custom built CMS because I could not do what I wanted in existing systems, but Drupal really gives you a lot of freedom to program in. The biggest challenge is configuring the clients account to make it easy enough to use (eg restrict permissions to the minimal needed).
No, it's actually reading multiple lines up to (and no further than) the function call's closing parenthesis. By parsing, I don't mean interpreting PHP literally, but actually parsing the text with regular expressions for the specialized purpose of reading the variable names. **edit:** See line 665 here. It starts from beginning of file, stops at the caller line and just parses, later on down, with a regex, to get the contents of the original function call. http://code.google.com/p/kint/source/browse/trunk/Kint.class.php
OOP is great, but it's also a quick way to obfuscate code. Everything being an object is cool, and quite useful, but when you are building classes &amp; libraries, abstractions get so convoluted that eventually you can't figure out wtf is going on anywhere.
I've done the same thing you have, but with a different approach. What I have is a set of two simple files (and a separate framework that handles the nitty gritty image resizing). These files in particular, however, take an original image (say an already reduced 800x800 jpeg generated by CMS from an original upload) and dynamically resize on the fly, but with a few differences: .htaccess parses all requests under this special directory to all jpeg files to my "thumb.php" file. thumb.php file, which contains config array at the top of the file and the rest of the operative/logic at the bottom. The array contains several size options, such as "lg" or "sm" (whatever you set) and you specify a width, height and cropping method (detail, handled by my framework). The cached files are stored under these alias (eg "sm") directories. If the file exists, it is served including cache friendly headers (I use a reverse proxy cache, squid server, to accelerate content). If it doesn't exist, it's generated and served. So while the request may be to "images/products/sm/file.jpg" (a real file that exists), it's being intercepted via mod_rewrite to thumb.php and being checked if it needs to be generated. By the way, if I change the dimensions of my "sm" file, I can just update my config and remove the directory or delete it's contents and then, if necessary, update image tags. This is very simple to manage. This is setup as boilerplate and is copied right now, but can be further optimized as an object/library. I have also made a version of this that takes the dimensions from the URL, but I rarely need this and I use this code VERY frequently on new projects all of the time. I only use the URL based dimensions when optimizing images dynamically via a CMS HTML editor such as TinyMCE by parsing the img tags as they are output on the front end to redirect to the image resize script. Again, the need for that is rare. 
I've been using http://github.com/valums/file-uploader for a couple of projects now. Its a javascript upload component that 'replaces' the default upload component with a fancy javascript/html replacement. Supports drag, drop, multiple fileupload and so on. 
It all depends on your requirements. Kint is much much faster to set up and use and, again, it displays more info (see my other posts). FirePHP is useful when debugging ajax requests, but then again, kint provides a formatted text-only option which fits my needs entirely.
thank you for that. That looks really quite nice. I'm going to give that a shot tomorrow. definitely written much better than the one that i wrote. Total hackjob.
Yeah, that is **the** feature that made me decide to outsource this little project of mine, as it's totally unique. I actually got up from bed in the middle of the night to go and implement it when I thought of that. This code analysis also allows kint to use modifiers: &gt; kint::dump($variable); &gt; @kint::dump($variable); &gt; +kint::dump($variable); &gt; -kint::dump($variable); all net different output, see documentation for that. Basically how it works step by step: * determines where the dump was called from (achieved by traversing debug_backtrace) * opens the caller file and reads the source for further processing up to the denoted line. Note, debug_backtrace reports the location of the *closing bracket* of the function as the callee line, not where the actual function name resides. * it then uses regex to find the last occurrence of the call in the aforementioned source. This has a known issue: `someFunction();d($variable);` will return poor results unfortunately, the dump should reside on its own empty line * we now have the concrete piece of source code of the whole dump, we remove any comments with php tokenizer * as per comments: // we now have a string like this: // &lt;parameters passed&gt;); &lt;the rest of the last read line&gt; // remove everything in brackets and quotes, we don't need nested statements nor literal strings which would // only complicate separating individual arguments * we now count opening and closing parenthesis/quotes in the passed arguments list to discard them, I may later add some way to see what they contained but showing `someFunction(...)` is almost always sufficient as opposed to `someFunction($firstArgument,'secondArgument')`. *Note, properly detecting parenthesis pairs cannot be done with regular expressions.* * now we have the argument list as a string which has NO commas unless they are a separator between arguments (before removing quotes and parenthesis, commas could have been used in strings and passed function arguments) so it's safe to explode the contents by comma. * lo and behold, we have the list of arguments in a neat array, finally check which of them were passed literally (i.e. array(1,2,3), new stdClass etc) and which - via expression or variable questions? :) 
It is up to developer. But i'd recommend 1 Page = 1 Controller. I'll push a "real" example soonish on Github.
Mostly i find it difficult to work on existing software (being it CMS, ERP and so on) unless they are extremly opened and provide apis or extension points, and even then they are hard to use until you understand the entire system you are working on (data flow and so on). It is important to know the cms inside and out and to know the customer's request from the start in order to decide towards a existing cms or a custom built one. Clients have differend needs. For a regular blog for example wp works perfectly fine. For more complex cms's, not so great. Once the content for example needs to be versioned, wp will not do (or maybe i don't know wp really good, i am not in this field of business). But mostly you don't choose a CMS and hope it will work, you need to understand the client's needs and requirements.
There's also Plupload: http://plupload.com/ It works pretty good, but it seems like it's a bit 'heavier' than the uploader that MKnudson mentioned.
Never mind checking with a mod, are you sure it's *wise* to post here with an offer like that? You're basically announcing to an entire worldwide software development community that your company doesn't really value what they do. Double the salary then report back.
That's actually really handy - I didn't know that! I really appreciate you following up!
It's really great. I've used it quite a bit and I am very happy with it.
Well at least they are offering biscuits, that should count for something too. Minimum wage appears to be 6.08(GBP), so 40 hours a week, 48 weeks a years would translate to 11673.60(GBP). I don't know much about UK wages but 3 times minimum for someone with a few years of experience might not be that bad. Plenty of european countries have worse rates.
After working at a couple agencies, I've found a disconnect between how the CMS is addressed pre-sales and post-sales. When the site is still being sold, then the CMS (usually Drupal) is touted as having thousands of standard modules we assemble to build a site. It saves time, they say, because we don't need to reinvent the wheel. They just want to make the sale. But after the sale is made, the project managers sit down with the customer and blank sheet of paper, and they say "how would you like this to work?" They come up with features that work completely different than how the canned solutions work. They just want to make the client happy. When they come to the developers, we don't have any room to say "you can't do that". At that point, all the crazy designs have been through weeks of revisions and we just need to make it work that way. That means custom modules to override default behavior &amp; appearance, or sometimes completely reinventing the wheel. At my current job, we've been pushing management to consider Drupal's capabilities earlier in the process, and with some success. But it's hard in a larger organization, where different teams are responsible for different parts of every project and everybody has their own criteria for "success". I sometimes miss my days doing custom development, that's for sure.
&gt; I don't know much about UK wages London is very expensive and salaries are usually higher to reflect that. That salary would be low anywhere in the UK for what they're asking for. It might be about right for a basic php monkey with a few years' experience, which means they don't seem to attach any monetary value to the rest of the skills they want. As in, if you can develop ORMs in your spare time for fun then we don't need to pay you for that ability, because, you know, you do it for fun, right? Hey, if they fill the role, great. I'm sure somebody wants it. I'm just saying that I'm not sure I'd announce the (not particularly attractive) offer to an entire international community which will contain many members who might take offense at being undervalued.
absolutely correct, great code analysis skills!
May you explain how you have come to that conclusion? The rate is well above average for london based digital agencies. Salary isn't all either, if you note on the jobs page you get: * 25 days holiday + public holidays * Extra time off between Christmas and New Year (roughly 3-4 days) * Your birthday off * Choice of equipment (everyone gets new kit) * Company pension contributions (up to 5%) * Private health insurance * Regular office lunches * Great company outings * Profit share scheme (a nice Christmas bonus) Which when calculated to an equivalent freelance rate brings you roughly up to £50K. I value these perks as much as my salary. When I don't have to think about my health care, pension, holidays and my income is more than sufficient to cover my costs of living I work better :)
Yes, but setting all that up is a one-time thing (that takes only minutes). As far as support goes, any decent editor will support xdebug as it uses the defacto GDB protocol. Version 2 uses DBGp which is supported by: http://www.xdebug.org/docs/remote#clients, so most bases covered there. As for sending XDEBUG_SESSION_START etc., once again, any decent IDE will do this for you. If you don't want to to the tiny bit of work to get debugging working, then fair play, but you really are missing out on a very powerful feature by doing so.
can't tell if sarcasm.... this is, I suspect, the exact reason people use them.
something ive never needed to do before, and i didnt know about abs(). so shoot me.
You can use perks all you like to attract the best talent, but not in place of salary. Perks are differentiators when two companies offer the same take-home pay. You cannot add some monetary value of perks onto a salary and pretend you pay well; it doesn't work like that. Dual 30" monitors do not add anything to my capital worth. An extra £1000 per year with compound interest certainly does. This nonsense that skilled technical staff can be bought for shiny equipment is yet another insult. Of course your staff should have the best equipment you can give them; they'll be more efficient, benefitting the company, not them. I tried to pay my mortgage in office outings, but sadly they only accept money. Your salary offer is low for a PHP coder in London based purely on what people I know earn, both in London and all over the UK. £35k is far more like up north pay than down south pay, for a coder. On top of that, what your asking for is not a php coder; it's an experienced and highly competent software engineer who happens to know php. Either you want a coder, in which case £35k is low but fair enough, or you want the person you described, in which case your offer is half what it should be. I'm not having a go... if you can hire at that rate, fine. I question whether this is the place to do it though, as you can only upset people who fit your requirements with such a low valuation of their worth, and this is a very public place to do that.
your birthday off, hahahaha, nice bonus.
nope, the link is still not fixed ;) EDIT: ok, now it is, thanks
Use PDO. I try to abstract dba code as much as I can. Recently I have been using Doctrine.
I think it's a pretty good salary to be honest - seen loads of similar roles that were much lower.
Erm actually you can but only when comparing freelancing as I'll explain. To compare a freelance job with a fulltime job you have to convert all factors to a monetary value so you end up with apples vs apples. In this case ~30days holiday in freelancing terms is not earning anything for a month and then paying yourself for the time you are not earning... Basically if you take time off as a freelancer it costs you double. Where as in this case its paid time off. Pension also is another expensive one as the company matches your contribution up to 5%, so I would as a freelancer have to pay 10% into my pension out of my own pocket. Your own equipment? Again comes out of your pocket. Private Health if you want it is again out of your pocket. Christmas bonus, another factor that a freelancer can't depend on. Perks are there as optional extras that the company are happy to give to employees, yes they are very useful for comparing matching offers but they aren't there for that purpose. May I contradict your statement on what you think we are looking for (and apologies as obviously the wrong impression was given)... We are looking for a php developer with experience, I never said how much and we are open to interviewing anyone who is interested in the job, scores well on our quiz and is keen :). I'm no engineer but I can build websites. In fact I have no formal qualifications. I'll openly say I work for that rate and get those perks and I live and work comfortably in London. I saw a job ad like this last year for this company and I wasn't offended. Maybe I am a chump, and don't know what I am worth but I love working where I am. I'm also not insulted by fancy equipment, I have worked too many jobs where I am lumped with the standard equipment they provide! I apologies to anyone that has been upset by our job offer, its obviously not the right place for you. For everyone else, feel free to fill out the quiz :).
See my reply to ConstableLoadletter :). You have to convert all those factors to a monetary value to compare to a freelancing rate, hence the £15K ontop. EDIT: Unix admin skills don't mean being able to setup web servers, its more like being able to dump mysql tables via cli and ssh. Stuff like that :)
Not sure about the JavaScript, but as for PHP I use CodeIgniter's file upload library to upload the file. Somebody made a plugin called Image_moo, which is what I use to easily manipulate (e.g. Cropping, resizing, distorting dimensions) an image that has already been uploaded. 
I assumed you were the one hiring, but it sounds like you're an employee too, and this wasn't meant to get personal, so best of luck finding a colleague and I'll leave it at that.
Indeed it does. I missed that. My apologies. 
I'd have liked to check out the quiz, but didn't want to fill out the form first. (But I'm not on the market at the moment anyway.)
Cool idea, hope it takes off. Upvote for you.
&gt; MySQLi isn't buggy, it's just awkward. Indeed, I absolutely hate working with standard MySQLi prepared statement syntax. It's like 6 lines to run a query. I typically either use a lightweight wrapper where I can write simple queries and prepare them under-the-hood, or use an ORM.
1. Never, ever, ever, ever use apostrophes for pluralization. Start with this rule, then we can talk about the exceptions (learn the rules before you can break them). 2. Use a question mark when you're asking a question. 3. Capitalize 'I' when used as a first-person singular subject pronoun. On to your question.... Why are you using an iframe to submit a form? What is wrong with using a normal form? More information is necessary to solve this bit of the problem, then we can decide whether you even need a plugin or library. EDIT: Some editorial review suggests that I sounded a little condescending in my introduction. Sorry about that, folks.
What the crap. 
good stuff, subscribed! TYVM!
Finally some place for me to post my php gems no one but me knows about :D
I'd argue that my example is also declarative, it's just done within a function rather than within a comment. What if I need to change the type of the Shipping model depending on e.g. the value of an attribute in this particular model. Can you accomplish this kind of thing using annotations?
Learn to be proactive instead of being a dick. People everywhere are ALWAYS learning. If you are helpful in a "online developer community" people will come back and actually be open to learning how to code properly. I'm willing to bet there was a moment in your life where you actually DIDN'T know everything and had to actually learn from others examples and asking questions. 
Just had a stab at it; I used acreature@example.org, because I prefer using an email address that's not actually routable.
It's a reasonable entry level starting wage. He isn't looking for a rock star, and lets be reasonable. Many php programmers aren't worth a rock star wage. Those that are most likely know other languages they're more interested in using.
Oh, sorry, I misread something, there. Even so, you're forgetting to capitalize the first word of every sentence and just forgot to use an apostrophe in "I'm", so while my bit about answering the question doesn't really apply, the last bit about following the advice stands :)
First, criticism/pointing out the obvious is why I made this thread. My opinion seems to not be the norm, and I wanted to know why. :) Second... I think you're misunderstanding me. You almost never work on a project over 12-15 hours? At this point I don't take projects of less than 15 hours. I'm talking $10,000 to $15,000 projects, sometimes more. Sites where your only standard page types are your privacy policy and terms of service.
This might be a good drunk-idea, but it just looks horrible to me ;) And the code is not very descriptive. Imagine someone else looks at the code and aks himself "What does $html() do?" (if it's not defined right above) then he has to scroll all the way up to get it ("Hey, why not name it $htmlentities?"). The next one changes it mid-code to $html = 'trim'; because he needs it and doesn't have to change 40+ string. And so on... I know most of the time performance and good readable/maintainable code don't go well together, but in my opinion the performance gain in quote/double-quote cases is just not worth it.
Looks like this will be pretty helpful, so thanks a lot! Just curious though — are you normally a lurker and just created a username to post in this thread? Because your UN was created just 21 minutes before this reply o.0
It really depends how you design the application. Are you going OOP? OOP has its own standards and conventions on how to split up code and responsibility. Try to code with DRY (Don't Repeat Yourself) in mind. Are you writing 50 lines of code that does X in one file, and in another file you write 40 lines of code that does nearly the same thing? Could you merge the two into a single function and call it multiple places? If you focus on code reuse you will soon find that you are making lots of libraries and helper functions, which is a good thing. It makes your platform more flexible and efficient.
&gt; So if I store the password in the PHP file, the only way they can get to it is by hacking/gaining access the file system itself and downloaded the PHP as a text file? Assuming file permissions are okay and no other vulnerabilities exist, yeah pretty much. &gt; Since I'm looking at using the master password method, any coding suggestions? Just code it like you would any other login system, only retrieve the password from the file instead of a database. Check that the password they entered matches and set some sessions. 
PHP salaries are depressed as hell over there, for some reason! Senior architect positions barely top £50,000 there ($78,000 USD), and one can get basically double or triple that here in the U.S. in any number of cities.
Note to rockstar UK devs: Come to the U.S. 
Is the UK demographically bustling with web developer talent or is it hard to find?
I've thought about trying Symphony a couple of times... I've worked with Cake, and DABL quite a bit. I'm actually taking the time to write my own framework, carefully and precisely, because that is what my employer wants.
I understand where you're at - but as I *always* say around these parts, please *please* **please** do not reinvent the wheel if you can in any way avoid it. A custom-rolled framework will never have the level of development and testing that an opensource package will, and you'll be stuck supporting that code for years. Even with *great* unit test coverage, you'll still be finding regression bugs years down the line that make you crazy. (Painful firsthand experience talking here.) Symfony or Cake or Zend will do you *really* well. Again, just explain to your employer that anything you create will only contain a small fraction of the power of any of these, and will be more stable in the long run. If they still want something custom, find a new client! ;)
Hi No - not going OOP. I definitely want to code with DRY (and I believe I do when I code in C.) I guess what I'm really asking is... it OK to create program.php which then includes files for all the discrete functionality? All the best Keith
Very hard to find *good* php web developers - other languages I can't speak about.
I asked this question after about a 15 hour day. My wrists were killing me, and I tend to forget to hit the shift key when I'm typing I. Lazy typer I am. You Sir are a prick. Lay off the grammar nazi behavior. I know I potentially came off as ignorant etc. But if you don't have something positive or useful to say about the question, you could have ignored it. Now move on, nothing to see here.
Actually, if you *read* my comment, I did have something useful to say. In fact, I'd say that suggesting better grammar in your communication *was* something useful. And again, sorry if I sounded like I was being mean. I wasn't, I was simply commenting on your post (which, I presume is the purpose of the "comment" button)
Or use MySQLi without prepared statements and use a custom sanitization method. Which I think developers should be doing any way. Prepared statements help prevent ONE of MANY types of attacks and hacks. Anyone relying solely on prepared statements is living on the edge of a nasty 3AM wake-up call.
Prepared statements prevent SQL injection. As far as query safety there isn't really anything else to sanitize.
After running a small web firm for years and running into all sorts of clients and projects, Ive really drawn it down to this (and this is a simple version of the speech I give clients): A pre-built CMS is a fast and cheap way of getting a website out there, with minimal debugging. A CMS will help you modify your site's content, and it won't be too complicated to do it (unless you're using Joomla). A pre-built CMS won't scale very well, and will most likely be thrown out in the future once you start getting serious traffic (sorry, but using 5-10-15-20-25MB of memory per request in unacceptable..cough...wordpress...cough) A custom CMS will cost you more at the beginning, but it will be built for your needs, an scaling in mind. It wont add excess bulk, and you will have more control over it's expansion, security features, etc... (with a pre-built CMS, you are pretty much at the mercy of the developers to put out updates, fixes, etc...) A custom CMS will do everything a pre-built one will do, without unneeded bulk. It will be more lightweight (if you have good developers) and will be more secure (even current versions of WP can be easily hacked). You think Google, Facebook et all use a pre-built CMS? Of course not, because a pre-built CMS is for small websites, with small budgets. Inevitably, there are clients that fit both categories, and Ive dealt with both types extensively. Some tend to be stubborn, and later find out they should have gone the custom route the whole time, and then they end up paying more for a recode. Any developers advocating a pre-built CMS for all, either don't know how to build their own, are too lazy and want to make a quick buck, or don't know any better. Don't get me wrong, WP is great to put up a blog real quick. But not for a serious project.
I'm pretty sure most hosting solutions install this by default, and if i'm not mistaken, it could actually be a dependent file for php installation on debian servers.
And injection is just one form of attack...like my original post stated. Plus, mysql escape strings function does the same thing (more or less)
And what other form of attack do you plan on preventing by sanitizing the query yourself?
have you been to london lately? it made new york city feel cheap.
There's enough spaghetti in this code to solve the world's hunger problem.
If you're used to C, then working with PHP should be similar. Where you #include a header file in C, in PHP you would `require_once` the implementation file. The difference is in C, you have header files and implementation files (.h and .c respectively) and in PHP there's only one file and you include the whole thing. 
You win the pony! Actually there is no pony. Thanks for pointing that out, I'll get on it in the morning :)
I'm going to have to take it on faith that you know what you're doing. But I must again reiterate - if you're having to write the whole thing from scratch, you're usually doing something wrong. ;)
I prefer to sanitize XSS on output, with either htmlspecialchars or HTML purifier (depending if I need to actually allow HTML to be used or not). Using prepared statements or not really use nothing to do with XSS.
It just adds more work for the server to do it every time you display the page. Plus, the less hacker crap stored in your DB, the better. What happens if you view the data in an unsanitized local? Risky.
I suppose you could filter out *just* XSS from the input before saving it, and then decide what to do with the rest of the HTML later. But, I prefer to keep the user's data intact as much as possible. XSS doesn't do anything sitting in a database.
In my country, I can get a few PHP devs at a decent/fair rate, but there are no python/django devs -at all-. Now if I had a project that needed python expertise, I would have to pay a premium to get decent offshore devs. If there was a single python dev here, he would be able to charge a premium and I would gladly pay it, because he has a skill that is in short supply in my locality. Supply and demand. 
could a person use authorize.net? ie build a customer portal on your company website
Why is everyone downvoting this? Here is the spec: http://tools.ietf.org/html/rfc3986 Show me the line where a size limit is imposed on URIs
Yea! I noticed, since 2.0.2 version CakePHP is really fast!
I think the easy way is create a Blog because you already know all the logic implied: posts, users, comments, themes. I mean, learn the basic CRUD elements. After that, the next steps should be: * Athentication (login, logout) * Emailing * Uploading files and images * Ajax * Captcha * RSS I like CakePHP, is fast and API is easy. When you know the API you really get into the framework. 
Generally this is the case. You could, however, make use of [set_error_handler](http://php.net/manual/en/function.set-error-handler.php) to keep the file from die()ing, if you really wanted to be tricksy.
This, completely. Don't reinvent the wheel. I'm also a fan of Symfony, as far as frameworks go. Whatever you do, do **not** borrow your coding standards from Wordpress. It's a great CMS, but the code is a slum.
Thanks! I think I'm going to give CodeIgniter a try.
Love it. :)
&gt; The tradeoff is that if you write it yourself, you've only got a few pairs of eyes on the code You also have less bored teenagers trying to break it.
There is the [phpass](http://www.openwall.com/phpass/) library that you can use which implements bcrypt. I have heard its pretty secure but would love if anyone else could give some feedback on using this.
I agree with most of what you say, but OOP is not the end-all be-all solution. You can write beautiful, efficient procedural code. You can write a "steaming shit pile" with OOP. Also, it is just as easy to pollute the global namespace with OOP, in fact it's even a little inviting to do so.
I'll take that bet any day. ;)
&gt; And with execution times nearing half a second to a full second. I use a framework and the majority of my requests take under 500ms.
PDO is fantastic for most things, though. Have MySQLi fixed their completely retarded binding syntax yet?
I've already mentioned here reasons why my solution also is not vulnerable to DoS
Yea. I use eAccelerator for opcode caching, and memcache for user data (and other data) caching. This post was more to see what other devs think about it. And how many actually dont mind sacrificing a lot of performance for the sake of using a framework.
Exactly (though not sure on the 75k count, as many other factors would contribute to how much traffic would break the site). For a blog that gets 100-500 hits a day, its no big deal. Heavier blogs start to feel the pressure at 10-20k a day, and it just gets worse as it goes up. Unless you are on a super server that can give you all the resources you need, you will start hitting brick walls.
&gt; The problem is I only hear this "OO isn't all it's cracked up to be" as a cover story for those who are too clueless to know what they are talking about and too lazy to find out. I know OOP very well, and use it almost exclusively. I was simply saying you don't *have* to use OOP to write good code. You are not helping the OP's education either by saying otherwise. A good majority of PHP CMS out there are not strictly OOP. They may have some classes here and there, but the overall architecture is procedural. Drupal, Wordpress, phpBB3, SMF, pun/fluxBB, etc are all not OOP. I'm not really sure if there are any competitors for these applications that are OOP but I'd be willing to bet they are in the same ballpark performance wise. For the record, I highly encourage the use of OOP and MVC. But I think the wealth of successful non-OOP applications are proof enough that it is not the only solution.
My personal solution is to have one class that handles a database connection and will handle queries in general. This class doesn't have any queries associated with it, but a generic connect (which accepts the database user, password, etc.) and a generic query clause (usually named 'select' or 'exe'). I then use another class to handle the queries specific to the given class (User in above). The constructor accepts an instance of the above function, and it is saved as a protected variable. The methods of this class are oriented to updating and selecting the database information pertaining to the User. And instance of this class is passed into the base User class that has more general functionality. An example flow of this structure would be: $db = new DB($host, $user, $pass); $user_queries = new $User_Query($db); $user = new User($user_queries); Of course, they might be more parameters passed in depending on your functionality (pass in the base user ID to the User class as well to load a particular user, etc. I've only recently come to this paradigm (recently dropped the singleton anti-pattern), but I'm interested in hearing criticisms to this approach to find what might be more appropriate to handling queries.
Database connections should always be done outside of non-related classes, in either a singleton or factory (I use singleton when I know only one database connection is required, and factory if I know several connections may be required. Though the latter is rarer) Then with the singleton, you can check to see if a connection has already been made, if it has then you return the mysqli resource or wtv you end up doing, if it is not connected, connect, then return.
One thing I always do when scraping is to look for a mobile version of the website, it's a lot easier to extract the needed information from there.
Argh, if everyone starts using generic bootstrap layouts the web will become so boring.
I like fitness! Fitness somewhat average piece in some hoohoodillychacha!
The problem with PHP developers, as a culture, is the hubris in thinking that doing it yourself is a time-honored tradition that everyone should go through. That is a rather unfortunate cargo-cult tradition, that other big names (Python &amp; Ruby in particular) eschew in favor of getting into good habits from the start. That is, *not* reinventing the wheel and wasting your time, or learning to code things *your own way*. (As a senior dev, I have to spend a lot of my time breaking juniors of their bad, self-taught habits.) Learn how your tools *work*, not how to build them. If everyone had to learn to *build* a car before they could drive one, no one would get anywhere. A good understanding of basic combustion, maintenance, and some on-the-road experience are all you actually need to be a good driver.
italian flatpress?
Performance is relative. On most sites getting *at most* a hundred concurrent users, you're not going to knock over any decent box with Wordpress running. It's just not a valid tradeoff.
People actually do that? I only use the stylesheet and add my own HTML.
It's come to a point where people want to use Wordpress for things that Wordpress isn't very good at. I don't have a problem with it, but I'm getting tired of seeing the industry planting themselves into Wordpress for a be-all-end-all CMS.
True, but even if you use it for what it is good at, you can still build a custom solution with a lighter foot print. This is because you could better optimize to your specific needs and only write functionality that is used.
And spend the rest of your life supporting that codebase? No thanks. ;)
As a dev who's been in the game for well over a decade, I can assure you that your previous development mistakes will come back to haunt you over and over again. Clients will constantly find new issues, even years later, and ask you to fix them. And that eats into your profits in the long run. The "work" involved in updating Wordpress is to click one link that says "Update Wordpress", and then wait approximately 5 seconds. I can eat that cost. More importantly, I can train a client to click that button, and it costs me nothing.
The stats aren't presented very well, but I think that those tests are being counted in the hundreds, ie 1.63 responses per second is actually 163 responses per second. Still slow, but not get-you-fired slow. EDIT: Disregard this, I am wrong.
Wow, thank you! Very thorough. I think I might even send some of this information to my professor(s). (IT student here). 
It's kinda faster?
If you have a maintenance plan it's just more money in my pocket for a probably quick fix. Besides, nobody says that because you build a web app you have to support it for the rest of your life. You hang yourself by your contract not the code you write.
I think PDO handles it automatically by adding this code to the constructor : array(PDO::ATTR_PERSISTENT =&gt; TRUE);
It's sort of like going to your doctor and telling him what prescription you want. And your only knowledge of said prescription is a commercial you saw on TV recently.
Seriously, just [use Doctrine](http://www.doctrine-project.org/) and don't waste your time on the low level stuff like this.
I created an extension of the mysqli class and in it's constructor it makes the DB connection with the host, user and pass embedded there. This way you only have to update one place if the username or anything changes. Once called, it functions as the mysqli class with a few extras I've added. I can embed the database name or use a method to select it but most of my sites are one host, one DB. 
flat files make me cringe and bring me back to my days of the Ultimate Bulletin Board modding in perl.. yikes
And just like the doctor, you are on the hook if that prescription fucks up!
From the top of my head: performance, scalability/flexibility, indexing, rich queries. In most cases, those might be quite important advantages over a text file based data-storage. But as long as the data access layer isn't demanding and the traffic is low, I don't think that it makes too much of a difference.
That is for [persistent database connections](http://php.net/manual/en/features.persistent-connections.php), but you will still need access to the PDO object to use it.
haha I know...CSS files are already cached, I don't know why I didn't do HTML caching from the get-go.
Depends on the use-case. MongoDB on a shared-host, for example, is not ideal.
I don't have the code anymore but one of my clients decided to go the cheap route and hire an outsourcing company from the Philippines. The code was for ratings stars where they had 5 stars with half star increments. The code was literally almost 300 lines long and didn't work. I replaced it with a 10 line function (including white space) and 1 line for each rating in their templates. It would have been less but they wanted to use separate images for each star. On a side note... they paid the outsourcing company more than $3000 for the changes that didn't work and had to be completely rewritten... I rewrote it in it's entirety in under 10 hours @ $30/hour. They told me they learned their lesson...
Hold on, I'm sure if I dig through some of my old code I can find some real winners....
oscommerce
An article file in TextPress will have two sections. A JSON encoded meta part and a content part which can be in Markdown/HTML syntax. The application will parse this article file on the fly to create HTML from Markdown.
I dont mean to high-jack your thread but I'm in a similar situation as you. I'm going to be in the process in learning CI. BUT I was first told to learn basic OOP structures (class, methods, object, and inheritance) before I jump into MVC so i dont get overwhelmed with concepts and syntax. Not sure if this is true or not since i have yet to start CI. Anyone here like to add their 2 cents? &gt; Do you read the docs first, walk through the code to see how things get set up, or just learn by trying to build something and reviewing the docs as you get stuck? The way I learn and I found it to be promising is to follow with tutorials (specifically video tuts) and do the codes also on a local server. Once you finish, try to do it by yourself and then try applying that to something youre interested in. For me it sticks a lot better. EDIT: dlenny88 provides a link to a CI video tutorial that someone else have referred me to as well. 
I saw that in the source. Is there any reason you aren't preparing the HTML files before hand?
In the include for every page: if (!empty($HTTP_POST_VARS)) { reset($HTTP_POST_VARS); while (list($k,$v) = each($HTTP_POST_VARS)) { ${$k} = $v; } } if (!empty($_POST)) { reset($_POST); while (list($k,$v) = each($_POST)) { ${$k} = $v; } } if (!empty($HTTP_GET_VARS)) { reset($HTTP_GET_VARS); while (list($k,$v) = each($HTTP_GET_VARS)) { //${$k} = htmlspecialchars(htmlspecialchars_decode($v,ENT_QUOTES),ENT_QUOTES); ${$k} = $v; } } if (!empty($_GET)) { reset($_GET); while (list($k,$v) = each($_GET)) { //${$k} = htmlspecialchars(htmlspecialchars_decode($v,ENT_QUOTES),ENT_QUOTES); ${$k} = $v; } } if (!empty($HTTP_SERVER_VARS)) { reset($HTTP_SERVER_VARS); while (list($k,$v) = each($HTTP_SERVER_VARS)) { ${$k} = $v; } } if (!empty($HTTP_COOKIE_VARS)) { reset($HTTP_COOKIE_VARS); while (list($k,$v) = each($HTTP_COOKIE_VARS)) { ${$k} = $v; } } if (!empty($_COOKIE)) { reset($_COOKIE); while (list($k,$v) = each($_COOKIE)) { ${$k} = $v; } } if (!empty($HTTP_SESSION_VARS)) { reset($HTTP_SESSION_VARS); while (list($k,$v) = each($HTTP_SESSION_VARS)) { ${$k} = $v; } } if (!empty($HTTP_POST_FILES)) { reset($HTTP_POST_FILES); while (list($k,$v) = each($HTTP_POST_FILES)) { ${$k} = $v['tmp_name']; ${$k._name} = $v['name']; ${$k._type} = $v['type']; ${$k._size} = $v['size']; ${$k._error} = $v['error']; } } if (!empty($_FILES)) { reset($_FILES); while (list($k,$v) = each($_FILES)) { ${$k} = $v['tmp_name']; ${$k._name} = $v['name']; ${$k._type} = $v['type']; ${$k._size} = $v['size']; ${$k._error} = $v['error']; } }
Also: /////////////////////////////////////////////////// $dbqueryid = "select max(autoid)+1 as maxautoid from **REDACTED**"; $resultid = mysql_db_query($dbname,$dbqueryid); if(mysql_error()!=""){echo mysql_error();} $rowid = mysql_fetch_array($resultid); (trim($rowid[maxautoid])=="")?($rowid[maxautoid]=1):($rowid[maxautoid]=$rowid[maxautoid]); $uniqid_value = "t".$rowid[maxautoid]."_".uniqid(rand()); /////////////////////////////////////////////////// $dbquery_insert = "insert into **REDACTED**(autoid,uniqid) values(null,'$uniqid_value')"; $result_insert = mysql_db_query($dbname,$dbquery_insert); if(mysql_error()!=""){echo mysql_error();} $LastInsertedAutoID=mysql_insert_id(); $dbquery_update = "update **REDACTED** set autoid = " . trim(addslashes(stripslashes($LastInsertedAutoID))) . " where uniqid = '$uniqid_value'"; $result_update = mysql_db_query($dbname,$dbquery_update); if(mysql_error()!=""){echo mysql_error();} Edit: In response to the downvotes, this is actual code used on an actual site. Better yet, it's used *everywhere a row is inserted into a table*.
How do you create new articles? They are written in the Json/Markup syntax and uploaded via ftp? From the source, it looks like you are accounting for certain numbers of line breaks and specific formatting where you then explode the article file. You have to assume the user doesn't know what they are doing...even if it is targeted towards programmers/enthusiasts.
oh, god. I ... just... my faith in humanity...
I came across this yesterday: $q = 'select column1, column2 from table where id='.$_GET['id'];
While bad, that's not that surprising to find in PHP code, considering it's what most tutorials online say to do still.
I've seen something similar: code that was used to display a schedule of appointments (for tech support at an ISP, iirc a callback schedule). The guy who wrote that was obviously still learning to program in general and had not yet learned how to use **loops**. Result: the entire page was generated using **if** statements (1000+ lines of them).
I came across this nugget a couple years go. This class was instanced on every page of a site. class strings { function padString($string) { $newString = substr($string.' ',0,strlen($string)-4); return $newString; } } It tacks 4 spaces onto a string then removes them. And it was the only method in the class. AND we were using php5 at the time but there was no score added to the method. And it has unneeded function call (strlen()). AND it makes an unnecessary assignment. It was so dumbfounding I had to save it.
Yup. This was the same site that had a 4000+ line switch statement to output page titles and metadata.
That's not always true. It really depends on what you're doing. Think about it this way: there's a reason your filesystem isn't SQL driven - it would be deathly slow. If all you're doing is editing specific files, or outputting them in filesystem order, the filesystem will destroy the database speed-wise as it has a far smaller overhead. Modern filesystems are designed to be aggressively cached by the operating system, too. There are a lot of things filesystems just don't implement that modern RDBMS systems do in order to remain fast. Whether or not this is a problem for your project depends on the project. Really the biggest issue you need to worry about is locking the file. This is not a big deal when reading, but it's something of an issue when writing. In a blog, you're really going to be reading a lot more than you're writing though.
Have you not watched "The House Of Lies"? 10 hours = 1 hour of work + 8 hours of reddit + 1 hour lunch = $300! Simple math! If you charge someone $30 for something they paid $3000 for, they will be very dubious, you charge them $300 and they feel like they got a great deal. Win-win.
*shudder* so true
it's also possible that it has already been checked and/or sanitized. if(is_numeric($_GET['id'])) { $q = 'select column1, column2 from table where id='.$_GET['id']; ....
So bcrypt requires the server to be running PHP 5.3, but the server I'll be running off only has version 5.2.17. Any ideas on what I should use instead? Again, this isn't some high-profile web-app I'm building but I'm looking for the next best alternative.
I worked for a fairly prominent webhost, and their in-house developed Billing application was a joke. When determining pricing for a particular product, the code was literally a GIGANTIC if/elsif block with one if FOR EVERY SINGLE PRODUCT WE OFFERED. Anytime we offered something new at a new price, we had to edit the module and manually add another elsif to the block. By the time I stopped working there, this block of code was a few thousand lines long.
I used to reformat strangely-indented code by hand until I learned my IDE (Netbeans) can actually do it for you! You can completely customize it to fit your liking. It's saved me countless hours since I no longer need to choose between reformatting code or reading it as-is. You can choose to have a space between "if" and "(" if you'd like, wrap long arrays and/or function parameters with standard indenting, put opening curly braces on a new line - almost everything is customizable. I highly recommend checking it out.
From a user login page: //Create a query to check for valid user $sql_string = sprintf("SELECT COUNT(*) AS numfound FROM users WHERE email = '%s' AND password = '%s'", mysql_real_escape_string($username), mysql_real_escape_string($password)); //Run the query $result = mysql_query($sql_string); //Check if the user was in the database, //if not close session and redirect if user is not valid $num = mysql_result($result, 0, "numfound"); if ($num &lt; 1) { session_destroy(); $locationString = "Location: /login.php?error=1&amp;num=$num"; header($locationString); exit(); } //Create query to get employee variables $sql_string = sprintf("SELECT * FROM users WHERE email = '%s'", mysql_real_escape_string($username)); //Run the query $result = mysql_query($sql_string); //Get the query results $userid = mysql_result($result, 0, "id"); $firstname = mysql_result($result, 0, "firstname"); $lastname = mysql_result($result, 0, "lastname"); $superuser = mysql_result($result, 0, "superuser"); $active = mysql_result($result, 0, "active"); $change_pwd = mysql_result($result, 0, "change_pwd"); //Session variables $_SESSION['userid'] = $userid; $_SESSION['username'] = $username; $_SESSION['displayname'] = $firstname." ".$lastname; $_SESSION['superuser'] = $superuser; $_SESSION['change_pwd'] = $change_pwd; The biggest problem: there's no unique index on the `email` field, which means you could actually create a new account using the same address with a different password. Using those credentials would get you in as the original user.
I so wish I could sit here and pretend I did not know what that was. But having written a unreleased whole sale addition to it, I can only sit here and cringe in agreement.
That is absolutely mind boggling. You *must* track down the person who created that class and ask them wtf they were trying to accomplish.
Well, assuming he did some error checking, at least it would be insanely easy to debug if there were a mysql error.... still though 0.o
[RTFM](http://php.net/manual/en/simplexmlelement.xpath.php): &gt;**Return Values** &gt;Returns an array of SimpleXMLElement objects or FALSE in case of an error. 
365.... I just died a little inside.
Exactly this. I do not care if another person has bad code, as long as I'm in the position to update it; but my own code, how dare me!
This is why books are better than most online "resources".
I'm your boss. I'm on a horse.
I know exactly who did it but I fear trying to find them because, based on their other work, I'd be too afraid they were building aircraft control systems or something else my life might depend on. I'd never feel safe again.
That's actually pretty cool. Do they still do the Presidential Fitness thing? do 10 pullups, 7 minute mile, 60 crunches in a minute, etc? For the most part the fitness metrics would be the same from school to school, right?
This is how I learnt about arrays and hash tables. I built a calendaring class, which showed a month view. I'd then loop through every day, querying the database for that's day's bookings. I soon learnt about PHP's execution limit, which led me to arrays and multidimensional arrays. An valuable lesson which I still recall today. What puzzles me is how can someone build something like the above yet be satisfied in the craptacular way that it works?
No it is not :)
First off, there was no error checking, anywhere. the way I found this was because they were complaining that this one page was moving REALLY slow. So when I went to that page to see what was going on, I found a page like this, inside a loop. They were updating up to 150 items like this all in one shot. If there were 20 fields an 150 items being updated, it would make 3000 transactions per submission. And then, it was doing UPDATES which are the slowest transaction.
Any OOP code that is written by someone who doesn't understand OOP.
 if($_GET['file']) { include($_GET['file']); }
Probably not the most terrible piece of code I have ever seen but it did give me a good laugh. switch($val) { case true: //do something case false: //do something } Why you would use a boolean in a switch statement is beyond me.
1 hour to write, 9 hours to work with the customer. That has been my experience, at least.
Indeed, I didn't say "cover it with hot sauce", I said spice it up.
If your queries are next to echo statements you're doing it wrong.
As someone that's learning as I go along...everything I coded last week. This is true of every week.
That's not to bad, as long as you provide the EXTR_SKIP flag... but for some reason they decided the default should be EXTR_OVERWRITE, and I don't think I'll ever be able to fathom why, for the love of all that's holy, would they do such a thing.
Not familiar with oscommerce but VirtueMart (component for Joomla) was/probably still is really really shitty Thanks to it I had to learn that php has parametric continue statements (first user comment here: http://php.net/manual/en/control-structures.continue.php ) and a whole mess of other crap, seriously some of the worst code I've ever seen work
Sorry I didn't write out an entire MVC framework right here in the comments, but I'm sure you understood what I was getting at. Also, not always. If you use MVC for everything, even an otherwise tiny webapp, *you're* doing it wrong. I do "odd jobs" for small clients all the time. Sometimes they want nothing but a single contact form that does nothing but emails them. If you install Kohana or CakePHP for that, you're DEFINITELY doing it wrong. Separating out your queries in some situations is better, but not doing it isn't "wrong."
I feel your pain. I've taken over the development of a with a design style circa 1998 and this brilliant code for updating a product page: if ($cappa == "update" &amp;&amp; $up_name != "") { mysql_query("update pages_products set name='$up_name' where id='$axpg'"); mysql_query("update pages_products set parent_id='$up_parent_id' where id='$axpg'"); mysql_query("update pages_products set frequency='$up_frequency' where id='$axpg'"); mysql_query("update pages_products set usable_range='$up_usable_range' where id='$axpg'"); mysql_query("update pages_products set boom='$up_boom' where id='$axpg'"); mysql_query("update pages_products set front2back='$up_front2back' where id='$axpg'"); mysql_query("update pages_products set front2side='$up_front2side' where id='$axpg'"); mysql_query("update pages_products set elipticity='$up_elipticity' where id='$axpg'"); mysql_query("update pages_products set gain='$up_gain' where id='$axpg'"); mysql_query("update pages_products set beamwidth='$up_beamwidth' where id='$axpg'"); mysql_query("update pages_products set feed_type='$up_feed_type' where id='$axpg'"); mysql_query("update pages_products set feed_impedance='$up_feed_impedance' where id='$axpg'"); mysql_query("update pages_products set vswr='$up_vswr' where id='$axpg'"); mysql_query("update pages_products set input_connector='$up_input_connector' where id='$axpg'"); mysql_query("update pages_products set polarity='$up_polarity' where id='$axpg'"); mysql_query("update pages_products set power_handling='$up_power_handling' where id='$axpg'"); mysql_query("update pages_products set element_length='$up_element_length' where id='$axpg'"); mysql_query("update pages_products set turning_radius='$up_turning_radius' where id='$axpg'"); mysql_query("update pages_products set stacking='$up_stacking' where id='$axpg'"); mysql_query("update pages_products set mast='$up_mast' where id='$axpg'"); mysql_query("update pages_products set wind_area='$up_wind_area' where id='$axpg'"); mysql_query("update pages_products set weight='$up_weight' where id='$axpg'"); mysql_query("update pages_products set no_of_elements='$no_of_elements' where id='$axpg'"); mysql_query("update pages_products set html_data='$up_html_data' where id='$axpg'"); mysql_query("update pages_products set order_now_link='$order_now_link' where id='$axpg'"); $target_path_pdf = "../pdf_manuals/"; $fileextension_pdf = ".pdf"; $up_name = str_replace("/", "_", $up_name); .... Still don't know what the hell a 'cappa' is.
One of my first projects was for a pretty large company, so I was paranoid as hell. We had a boolean value being stored in the database and I wrote this code to handle it: if($val === '1'){ //Do stuff } else if ($val === '0') { //Don't do stuff. } else { //Error handling for invalid boolean } Even better was when my friend was laying out the schema for a database he was creating. He decided he wanted to save a Yes/No field as a varchar(1), for 'Y' or 'N'. Yes, varchar.
I think you can in the paid version.
Anything that is deeply nested with no comments. 
Either that code was _really_ old, or the dev never bothered to read any documentation after PHP4 came out.
PHPBB 2.0 Was literally this. They were working on some automated mod installer that actually read these instructions and apply the changes, before they started with the hook system,
what about leap years?
It's not fun, it's painful. Literally, my eyes hurt trying to read some of my stuff from 7 years ago.
D:
I would assume someone wrote "padString" without the -4 but then someone later thought "I can stop this without having to rename everything". God knows why he couldn't just comment it out...
Pretty sure 1 is the default, why change it?
An old client who had spent thousands on a specialized system someone else developed for their own site, asked me to speed up his site. I figured it was taking a second or two to load, so it'd be a decently complex little project (I like to optimize code)... Nope, it was taking hours... HOURS for pages to load, because not only did the creator of this system have each page update all of the stats every time you load it... He also had queries in while loops, in while loops, in while loops, etc.. Each time a new entry was added to the database - you'd get an extra 100 or so queries. I think when I checked, there were over a million queries per page (SELECTs mostly, but also some UPDATEs and INSERTs). Took about 4 hours to get it down to &lt;10 queries. Only reason it took so long is because I also sanitized what I saw (There was no way I was going through all of the code for my rate with him, plus nothing was santizied*), and the code was just... Awful, just terrible - completely uncommented, and it was the equivalent of an entire book written with no line breaks, or chapters. Did I mention the guy paid thousands ($5+... US) for it? **I told him it wasn't sanitized, and it was insecure. He didn't care.*
hah who the FUCK does this?!
Wow, I think you're right. I retract my previous statement. I think what we're seeing is a misuse of the requests/second metric. Normally I would expect it to describe how many requests you could actually serve in a second, not the inverse of seconds/request.
What on earth is the point of that??
Thanks for the comment:). I assume that user know what he's doing. He should format the article with JSON and Markdown as mentioned in the doc. Otherwise it will break. Right now its hosted in http://phpfog.com. So articles can be published using git. I don't want to make this something that can be used by one who can't care how to use it. 
nikic is right, once the parser finds some invalid syntax it will throw up it's hands and refuse to attempt to parse the rest of the file. Using an IDE is probably your best bet (Check out PHPStorm or Netbeans) as they usually have their own parsers written for finding problems and understanding PHP files. You may also want to checkout [PHP_Codesniffer](http://pear.php.net/package/PHP_CodeSniffer/redirected) - I've never used it but it may give you some joy with finding problems in your files. It's fairly easy to integrate with VIM, also.
Seems like a fine project to me. It could be useful for running a blog/cms on a small device like a router. I only have a couple comments. * Why create a flat file format that contains both json and text? Why not store the whole thing as a json string? * Your Textpress class should really be broken up into smaller classes with specific skills. * This is minor, but your docblocks are all messed up. For example it should be @param type $varname description, and you have @param $varname type description. There are a lot of other minor problems too. Check the [wiki article](http://en.wikipedia.org/wiki/PHPDoc), or the [phpDocumentor Tutorial](http://manual.phpdoc.org/HTMLSmartyConverter/HandS/phpDocumentor/tutorial_phpDocumentor.howto.pkg.html).
some dude at my collegue. their site got hacked.
Thanks for the feedback. Yeah, I need to put some effort to standardize it. Surely I will do it in coming days 
You don't want your CPU to spike too high though. Too many requests for pages this slow, will slow down the request times significantly. Requests already taking 500ms will take 1 second, 10 seconds, 30 seconds,... timeout timeout timeout and your site is effectively down. The message I was hoping to convey above, was that "the majority of my requests take under 500ms" indicates a problem in mentality. Not only is 500ms already very slow, it's a liability if the site in question ever gets any serious traffic. 
I can overwrite your previously scoped variables with my own variables. &lt;?php $user_id = $_SESSION['user_id']; $query = 'UPDATE `users` SET `password` = ? WHERE user_id = ?'; extract($_GET); if (isset($password)) { Mysql::write($query, $user_id, $password); } // Sets password for session user // site.com/update_password.php?password=thisisaterribleidea // Sets password for user with id 1, 2 ,3, 4, 5, ... // site.com/update_password.php?password=thisisaterribleidea&amp;user_id=1 // site.com/update_password.php?password=thisisaterribleidea&amp;user_id=2 // site.com/update_password.php?password=thisisaterribleidea&amp;user_id=3 // site.com/update_password.php?password=thisisaterribleidea&amp;user_id=4 // site.com/update_password.php?password=thisisaterribleidea&amp;user_id=5 And now I have access to everybody's account!
This gem is from phpdocumentor if (!defined('T_DOC_COMMENT')) { define('T_DOC_COMMENT', T_DOC_COMMENT); } If it's not defined then define it as it's defined. 
parametric continue statements are deprecated in php 5.4 
I remember when vBulletin was like this. And yes, like gigitrix said, PHPBB was like this too. I did some of the programming on phpbbhacks.com back in the day. Would not want to go back and look at my old code now.
Why you use an if statement, when you could use a boolean is beyond me. Not to mention in your code sample the false case is always executed. &lt;?php switch(true) { case $user-&gt;isUnverified(): // prompt for verification break; case $user-&gt;isTeacher(): case $user-&gt;isAssitant(): // Show cool stuff break; case $user-&gt;isGroundsKeeper(): case $user-&gt;isJanitor(): case $user-&gt;isCustodian(): // user does something else break; case $user-&gt;isStudent(): // Throw unauthorized break; default: // show cool stuff here } if ($user-&gt;isUnverified()) { // prompt for verification } else if ($user-&gt;isTeacher() || $user-&gt;isAssitant()) { // show cool stuff } else if ($user-&gt;isGroundsKeep() || $user-&gt;isJanitor() || $user-&gt;isCustodian()) { // user do something else } else if ($user-&gt;isStudent()) { // Throw unauthorized } else { // Show cool stuff here } Maybe slightly easier to read with switch statements.
Wow you just brought back so many memories of IPB/PHPBB circa 2005
Ahh that's pretty cool. I know a lot of ruby flat file blog systems that do that, so it's cool that someone is trying to replicate the same functions in PHP
Not having a unique index on email isn't all that obnoxious. Your registration and change email forms would obvious have to check for the email already existing. Which you should be doing to start out with.
~~"inverse of seconds/request" is seconds per request, as opposed to requests per second. The table has both.~~ Sorry, I see what you mean. I guess he performed 100 individual requests. Obviously you can't get very many req/s if you're only asked to serve one at a time.
Doing just this in phpbb2 is what got me started in PHP programming. Now I get paid good money to do what used to be a hobby (still is actually)
I agree, but it seems the original coder didn't factor that in.
With reading all this bad code nonsense, is there a site that shows examples of bad code, why its bad and the right way (or one of the right ways) to write it?
Also, this is basically what you find inside a [patch file](http://pastebin.com/0f7NRUh5) except a patch file is also machine-readable.
At least they created a random table name? I've seen people do this but with a single table. Race condition? whats a race condition? Did they at least use a MEMORY table?
On my 3rd or 4th project, I wrote an awful, awful wrapper for mysql_query() that did a whole bunch of other stuff and returned a massive array of data. I wanted a more convenient way to get all that data. I then proceeded to use that function for several more sites. I cannot apologize enough to whoever maintains those sites now. Sorry guys.
A unit test for a data contract. The data contract was just a class with properties. No methods, no constructors, and no special getters or setters. The unit test would instantiate the data contract and set a property. Then test that the property was of the same type as specified in the data contract class. Whaaaaa?
Wow. Ballsy.
&gt;What's the most WTF/terrible piece of code you've ever come across? Yours.
Queries can be very fast if your schema is solid, a select statement between two indexed Columns takes a matter of microseconds
Not quite so. Nginx not copying PHP into its own process is not the reason it saves memory. The PHP process still has to run, it just runs as en external process to which Nginx pass the request. Thus the exact same amount of memory is required for a PHP request. The reason Nginx appears to save memory over Apache is because Apache uses the same process to serve PHP request as it does to serve image requests. This effectively means that a request for a 8kb image use up a 25 MB process until the image is served - for slow connections this can be significant. Your not as fast claim is based in theory-crafted FUD. PHP is PHP regardless of whether it runs within an Apache process or as an external process. The reason some people claim that Apache is faster is because the time to pass the request from webserver to PHP is smaller when PHP is embedded. The difference here is that it's not PHP that's marginally slower, it's the overhead in communication that's marginally slower. Thus you get a constant minuscule slowdown, not one that scales with the complexity of your PHP code.
With all the pages spread across different files each containing the site layout. Oh well, I learned a lot from osCommerce though!
Yeah but they added [goto](http://php.net/manual/en/control-structures.goto.php) functionality in php 5.3 which is essentially the same thing, although it is more readable. 
Magento's not THAT bad as long as you use a good IDE along with xdebug. Otherwise you'll end up putting `echo 'Hello';` in 10 different files just to see where the piece of code you looking for is executed, &amp;#3232;\_&amp;#3232;.
Useless micro-optimization suggestions on a blog filled with advertisement popping in left and right. **No, thank you**. Which is faster, print or echo? The real answer is: *It doesn't matter!* The gain of switching to print is so negligible that it won't have any noticeable effect at all on your website's performance. In other words, you've just wasted hours on "optimizing" code to no real benefit. 
I disagree. Their convoluted EAV schema is absolutely terrible. Magento's codebase is a textbook example of OOP done completely utterly wrong. Oh, gonna call GetProducts() or GetItems()? Haha, good luck because there are at least a dozen of each strewn liberally up and down the object model. Don't get me started on it's performance...
You made the first one, not the second one specifically, though, that's what people are going to assume and I felt the need to clarify so misinformation wouldn't spread.
Aah, right - thought it was something else I didn't know about!
[The Daily WTF] (http://thedailywtf.com/default.aspx) is the go-to resource for such perversions... 
Yes it matters! No need to change existing code, but if you from now on know that certains patterns are faster - why not leverage them? 
&gt;Yes it matters! No need to change existing code, but if you from now on know that certains patterns are faster - why not leverage them? It doesn't matter because the difference is negligible. You won't be creating a better experience for your users by using a function which is a few microseconds faster.
&gt; I believe that if you understand your stack and your application well enough, there's no reason you need to "live with it". I agree, knowing the exact project requirements, we took only the specific components (from kohana) we needed. The result with some glue and handcraft is avg. ~20ms. 
Eh. Terrible presentation. Most of these require explanation for why they'd be worth the effort, or why they are better. And like Nicoon said, some are pretty irrelevant in practice. PHP is an ugly language, so I'd rather strive for clarity than micro-optimizations. Hardcore optimize only as needed, and only after proper profiling.
&gt;If however, your app can serve a request within 20ms, then cutting down just 2ms by using better techniques is a huge gain. That's nonsense. 2ms won't increase the performance of your application in any noticeable way at all. It is indistinguishable from the noise produced by the server when balancing and accessing its resources. It won't have any meaningful impact on your servers, and you most likely won't fit in more requests per second because of it either. Furthermore, 80% of your website's lifetime takes place on the client-side. If you want to optimize your website, do it there first.
&gt; And it was the only method in the class. AND we were using php5 at the time but there was no score added to the method. And it has unneeded function call (strlen()). AND it makes an unnecessary assignment. And it will randomly leave some of those spaces on the end if the input string contains multibyte (e.g., Unicode) characters.
Oops, sorry. English is not my native language. But thanks for the corrections. I'll keep them in mind.
You sanitize back into $_GET ?
Hi Veonik, Thank you for the up vote. I am also interested to see the comments why people didn't liked the article ? Is it because of PSR-0 standard or something different ? To my knowledge Doctrine2 uses PSR-0 standard , was you pointing to https://github.com/doctrine/doctrine2/pull/205 which is merged. Or anything other than that ?
Thank you and Happy to hear you liked it.
There are many sites out there, that web designers, developers and common geeks find highly entertaining or interesting. Which ones have you stumbled upon, that you haven't forgotten since?
Tips like this are in a great many cases worse than useless. Don't optimise in this way - it's a waste of time and can in some cases cause much worse problems than it solves. Optimisation is a balancing act between business requirements and software performance. If extremely subtle software performance benefits have a negative impact on business requirements (e.g. the ability to quickly change the function of large parts of the application) they're probably not worth doing. Saving 2ms per request isn't worth it if it takes 10x as long to make changes in the application. Each optimisation has to be justified on it's on basis within the wider context of the application - you CAN use the fastest tool for the job but only if it's the RIGHT tool for the job. Don't just always try and use what's fastest. Some of these are also contradictory or could harm an application depending on it's function. For example I happen to know though some benchmarking I was doing yesterday that mod_deflate processing overheard decreased RPS by 10%. This would be a good deal if your pages are large because it saves so much time in transfer but if you are developing an app to serve as a backend for some kind of JS application where you only server small results it wouldn't be worth doing because a deflate on { success : true } is a waste of time. It's a bit specific but it illustrates the point that you "optimise an application", you don't just "optimise".
I think "years" is a bit much, don't you? I've had teams of two developers build a social networking site in under 1. Profiles, music uploading, video streaming, etc... Plus, what will it cost to debug future bugs in a framework the company did not have full control over? Any strategy that says "just throw another server at it" is doomed to fail, if not by crashing, then by investors or CEOs coming down on you telling you to the get f*** out of their company. Facebook has billions at is disposal, yet it never has had the "throw more servers at it" approach. 
for me it's: &gt; "My god, you were a colossal idiot just **yesterday**".
The ratings weren't the only changes they needed. The basically got a new design for their site... so I had to integrate the design. Honestly, I am confused as to why you would even assume that... obviously, no one is going to pay $3000 to have ratings added their site...
I was, am, and always will be a colossal idiot. I just leave it at that, and move on.
[This](http://pastebin.com/az8C8hF9). Scroll fast to see the twirling effect or use a *very* wide monitor. Oh, and please, donate. :/
Also, POST variables, cookies and so on. And don't even let me start on vulnerability to XSS SQL injection. register_globals was disabled for a very good reason.
Also, most newer distros should have the option that prevents "rm -rf /" just because of stupid mistakes like this.
AFAIK, all C-style languages have fallthrough, so not only is that stupid for using switch for boolean, but since there is no break the "true" will execute both code branches.
Thanks, I will check that out. So far I have been using online tools to reformat code one file at a time, as needed. I have just had a bug reported in which records are mysteriously being deleted, and it involves the above code, so I'm going to need to tidy up that section of code today. It is only *after* the code is reformatted, that I find out just how bad much of it is! It is full of $_GET and $_REQUEST variables concatenated into SQL queries for a start, though this does seem to be a general weakness of SugarCRM anyway (SQL injection through the standard SOAP interfaces is terrible, and a massive security hole IMO - you do a search for a contact by email via SOAP and forget to escape any single quotes, as the Outlook and Thunderbird plugins often do, and you get SQL syntax errors - doh - why?! SugarCRM - learn about query variable binding NOW, FFS!).
[The Daily WTF](http://thedailywtf.com/) All programmers, professional or otherwise, should know about this site.
"What the fuck is the going on here?" - That's usually my reaction when revisiting anything I've written that is 6+ months ago.
The first website admin I wrote, along with its user login system. To be fair, most of the code was generated by Dreamweaver 8... still, it's a scary piece of work to look back on: so much untrusted input, so little validation...
Real men use die() instead of exit :D
It's never going to be faster than a local check. It doesn't matter how quick the query is; there is overhead. Especially if the database is on a remote machine.
Wow. On the one hand, at least you aren't exposed to hackers manipulating GET/POST input... On the other hand..... just .. wow. *root's* crontab?
PSR-0 specifies that only underscores in the final segment get replaced. So, e.g. `\Abc_Abc\Def_Def` becomes `/Abc_Abc/Def/Def.php`
I found a "better" one. This outputs a link. Of course the construction inside is repeated many times over the code: &lt;a href="&lt;?php if($cat['type'] == 'AL') { echo $this-&gt;xml_link('article_list', array('node' =&gt; $cat['prod_structure_id'], 'list_id' =&gt; $cat['target'], 'lfa' =&gt; $this-&gt;class_name . '-child-' . $counter, true)); } else if($cat['type'] == 'S') { echo utils_utils::call('url')-&gt;unserialize_url($teaser['target']); } else if($cat['type'] == 'E') { echo utils_utils::call('redirect')-&gt;get_extern_redirect_link_for_url( $cat['target'], array('lfa' =&gt; $this-&gt;class_name . '-child-' . $counter) ); //echo $cat['target']; } else { if (isset($cat['target']) &amp;&amp; !empty($cat['target'])) { echo utils_utils::call('redirect')-&gt;get_extern_redirect_link_for_url( $cat['target'], array('lfa' =&gt; $this-&gt;class_name . '-child-' . $counter) ); // echo $cat['target']; $target_blank = true; } else { $target_blank = false; echo ($cat['depth'] &lt; $this-&gt;parameters['global_properties_list_depth']) ? $this-&gt;xml_link( ($cat['depth'] == 2) ? 'sub_categories_teaser' : 'sub_categories_navigation', array('node' =&gt; $cat['prod_structure_id'],'lfa' =&gt; $this-&gt;class_name . '-child-' . $counter), array($cat['name']), true) : $this-&gt;xml_link('sub_categories_list', array('node' =&gt; $cat['prod_structure_id'],'lfa' =&gt; $this-&gt;class_name . '-child-' . $counter), array($cat['name']), true); } } ?&gt;" onfocus="this.blur();return true;" &lt;?php if ($target_blank) echo 'target="_blank"'; ?&gt;&gt;&lt;?php if ($this-&gt;object_data['actual_node'] == $cat['prod_structure_id']) echo '&lt;strong&gt;'; echo escape($cat['name']); if ($this-&gt;object_data['actual_node'] == $cat['prod_structure_id']) echo '&lt;/strong&gt;'; ?&gt;&lt;/a&gt;
Yeah OsCommerce get's an F for having terrible spaghetti code. Magento get's a D for its MCV/OOP gone Lieutenant Dan (think drunken ocean storm scene) and its general slowness and overly normalized database design. I have to agree that I'd either write my own shopping cart or purchase a non-free one. The open source PHP community has been failing for over a decade at building shopping carts.
Yes, someone working with an OSS Framework would be great. Most designers think they are the same thing.
I guess I fail at representing benchmarks. Will do better next time.
What if he used a loop to generate that code?
Probably, I designed it 4 years ago, give me a break :-) Could probably be moved into a singleton design pattern. Never noticed any performance issues or anything like that though.
Haha, no worries. One day I began working on a website that was getting &gt;50,000 unique visitors a day. And I say "one day", as in, I wrote the website thinking it would be used by a few people, and then a month later got an email about it being too slow. Long story short, the traffic had exploded and all the bad/shortcut code was bogging things down. I unlearned a lot of bad habits on that project.
And the word "rockstar" was not even mentioned once. Not bad.
Be sure to also read [articles](http://derickrethans.nl/collecting-garbage-phps-take-on-variables.html) [on](http://derickrethans.nl/collecting-garbage-cleaning-up.html) [memory](http://derickrethans.nl/collecting-garbage-performance-considerations.html) usage &amp; garbage collection (by Derick Rethans).
&gt; ...where you start work at 9 and finish at 5. That place sounds horrible.
&gt; why, for the love of all that's holy, would they do such a thing. This happens for quite a few things they did in php 4. The amount of "cleaning up old mistakes" php 5 had and still has to do is crazy.
Apparently, mysql functions are soon to be deprecated. You should be using mysqli functions.
OK yes, I'll concede that if you are scaling to that kind of level there are a BUNCH of optimizations that I can only dream of! The bitmask stuff pays off there but the average LAMP app wouldn't really benefit from premature optimization, amazingly clever though it is :)
Also, passing variables by reference is ugly, please JUST SAY NO
The session isn't the same as the session ID though. There is a function called session_regenerate_id which will create a new session ID if you need to. Did you check the session still contained the user data after you unset it? If so maybe try the session_write_close function (though you shouldn't really need it!) after the destroy.
Yeah, your answers make sense. Keeping it small and single-purpose is best. Saying no to feature requests should happen way more than saying yes, IMO :) On the simplicity, I tend to avoid alias methods myself, but I can see that being more a matter of preference in the end. I like the approach of PSR-0 + compiled single-file option. For small projects, I definitely appreciate the drop in a file and code approach.
Wow! Sounds like a great place. Why did you leave?
Just read the CI session docs. http://codeigniter.com/user_guide/libraries/sessions.html
&gt;I learned a shitload doing this That's good. Programming is a continuous learning experience. If you're not learning, you're probably doing it wrong. 
He felt like he wasn't getting anything worthwhile done.
&gt; Each "\_" character in the CLASS NAME is converted to a DIRECTORY\_SEPARATOR. The "\_" character has no special meaning in the namespace. I dislike this portion, I realize this is there for 5.2 naming scheme compatibility, but I like underscores in class names and avoid uppercase characters in my filenames.
me too personally.. but in the end i decided that supporting the standard was worth the aesthetically unpleasing (to me) look.
The most helpful thing to me as a self taught programmer was exposure to other people's code. I recommend browsing github, stack overflow and sites like that. Think about one problem/user story and look up as many different solutions as you can. Not all of them will be winners but many will teach you something. And don't limit yourself to PHP. Learn some other languages, even if it's just the basics. And never think you've learned it all. I started programming in PHP 10 years ago and have been a profession for over 6 years and I still learn (and seek to learn) new things on a regular basis.
I think Bishma is right. What else might help is a peer review. Show one of your colleges/other committers in the project your code and let them critique some of the more complex parts of your code. Ask them for feedback, and ask how they would have solved the problem at hand. This technique helped me to become more confident about my own code. 
Read framework code. 
English Major perhaps?
NOTE: You can strip the ".php" off by using a zero, or "null"-byte, and therefore access any file on the filesystem. http://www.example.com/index.php?page=..%2F..%2Fwhatever_file_you_want.txt%00 include("../../whatever_file_you_want.txt"); This works because strings are stored as "char,char,char,0". PHP (or more specifically the underlying C) only knows how long the string is when you hit the null. So if you have a string like "char,char,0,char,char,0" then it stops reading when it hits the first null, thinking its only two characters long. This has been patched in recent versions of PHP, but I'm guessing these kinds of people are still running 5.2.
FYI, for anyone looking to read these books. They're both on [Safari](http://www.safaribooksonline.com/). Edit: switch link from wiki formatting to reddit style.
I would investigate any design patterns that are relevant to PHP. You'll only ever be able to use a design pattern if you know about it, and 99% of problems that programmers encounter have been solved by someone else in a clean, efficient way.
The biggest one I see early programmers do is put a SQL query in a for loop. It is database / speed suicide to query the DB that way and it will destroy the performance of a website. 
This is exactly what come up at my job a few days ago. I had done this when I should have made a "SELECT ... WHEN ... IN". The problem is SQL queries is my weakest area and hadn't thought of using WHEN IN. Generally can a query in a for loop always be converted to a different structure?
I'm guessing you store session info client-side in cookies...? And server-side in files? What is the value of `$_POST['sess_id']` that you're testing? Are you getting that from examining the cookie in your browser? On [`session_destroy`](http://php.net/manual/en/function.session-destroy.php), note: &gt; session_destroy() destroys all of the data associated with the current session. It does not unset any of the global variables associated with the session, or *unset the session cookie* In other words, you have not "destroyed the session cookie" (Check that `session_destroy()` manual page to see an example of how to do that). So, when you do `session_start()`, if the client (you in this case) has a cookie with the same name as your session name as defined in your INI file or by using [`session_name()`](http://www.php.net/manual/en/function.session-name.php) regardless if they manually changed the value of that cookie to something completely random, it will create a brand new session file on disk using that ID value as given by the client if it doesn't yet exist, if I recall. I don't recall though if the old session file is ever deleted anyway until the session garbage collection runs and cleans the old session files from disk. In your case, it more or less brings your abandoned session file back from the dead. I'm going off memory here though and don't have a server in front of me to test it, so if I'm wrong anyone, please correct me.
Correct, session_start() will accept a user-provided session ID from a cookie when creating a new session. Which seems like a session-fixation vulnerability, but really isn't.
mostly this reddit :) there are many good links from comments in these threads that leads to one link that leads to another which ends up giving me something new :) as for twitter @phpizer is someone who just throws out tons and tons of links and sometimes its a good one, if u'd want an example outside of /r/php =)
It seems like this should be clarified in [`session_start()` manual page](http://us.php.net/manual/en/function.session-start.php). As is, the only hint is: &gt; session_start() creates a session or resumes the current one based on a session identifier passed via a GET or POST request, or passed via a cookie. Seems rather ambiguous or vague. Should the manual be changed to add: &gt; If a session does not yet exist server-side and the client provides a session identifier, a new session will be created using the session identifier given by the client. Or actually, how could this best be worded to better describe the entire session startup process?
I've been pretty pleased with the stuff [@funkatron](https://twitter.com/#!/funkatron) posts on Twitter. He also does a great podcast called [/dev/hell](http://devhell.info/) with @[grmpyprogrammer](https://twitter.com/#!/grmpyprogrammer) that is 80% about PHP.
I'll have to look at the highest voted section. That sounds pretty solid.
nice, you can also just make it do include("http://domain/foo.php") and make foo.php doo whatever you want, which is what I usually see.
So far I think paniconomics is right. Looks like input is tainted unless it has been escaped and raises errors for un-escaped data. It's too early to how it'll work out, but quite honestly I think this is falling into the same trap as magic quotes...
I wanted more about sniffing in php than swig and c++, i thought you'll gonna explain what to look 
Not necessarily. When it's ridiculously simple conditions and statements, using a full formated if {} else {} can take up a lot of space. If nothing else, it takes less scrolling to skim through your code. 
I was writing a test for some code someone else had written, and came across this marvel (not using the original code but you get the idea): function someFunction($arg1, $arg2, $arg3, $arg4, $arg5) { // some function processing... return $retVal; }//end someFunction() // and it was called somewhere else by this: $retVal = someFunction($arg1, $arg2, $arg3, $arg4=array(), $arg5); ... And I was wondering why the test was failing in a particular case!
only one comment in the thread and its the one I was gonna make. :-/
And now you've gone and ruined our perfect score. ;)
Penetration testing, writing applicaitons that give you the ability to monitor the kind of traffic you have on a network from a php console, whether it's for security sake, or being used just for reporting purposes, there's a few things I can think of.
I'd like to point out that, regardless of what you think about how stupid those three lines of code are or that you have a weekend due date (why didn't you just do it when it was assigned?), this exercise is demonstrating that it is sometimes useful to break operations into separate parts. Personally, I think this: $totalCost = $ticketCost * $numTravelers + ($hotelCost * $numNights) * $numTravelers; is less maintainable and possibly confusing than breaking it up into separate ticket and hotel costs. And berating your TA (who has to grade a ton of these), is not going to earn you any brownie points. just sayin'.
Could be worse. They could have called it Santorum. 
&gt; I suspect the idea is data is considered "tainted" until an escaping function has been called on it Which in itself, is ridiculous. I wager such a system would still 'require' intigers to be escaped, which is a pointless task. Much easier to just learn to escape variables yourself, where it's appropriate.
People making PHP frontends for applications like this has always baffled me. Just shows that skiddies are too inexperienced to use a SSH shell. 
I think this reading can help you. It written by the creator of Symfony2: http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1
Haha! Klein wereldje, toch? ;-) Anyhow, we are sort of in the same position. As you may know, we use PivotX for a lot of our clients, and while it does work well, it's starting to show it's age. We've just started working on a new version, completely from scratch. It'll use Symfony2, ORM, hooks and all that stuff. The main reason we didn't settle on anything that is already out there, is because in our opinion there simply isn't anything that works well with our workflow. In short, what we need to have is a tool that caters optimally to each of the following: - The developers: The people who write code. This code is either part of the 'core' CMS, or part of an extension. - The implementors: People who write frontend code and/or markup. These people set up the CMS, make sure the CMS does what it has to do, and implement the templates in HTML/CSS. - The editors: These are the people who actually work with the CMS on a daily basis. They write and publish articles, review posted comments and edit old content. - The visitors: This is the group of people that actually uses the website. Now, we feel that there simply isn't an Open Source CMS out there that does all of this well, so we're going to do it ourselves. To me it seems that what you're looking for for your company is pretty close to what we're doing, right? 
Thanks for the comments to all! but you kind of missed the whole point of the article. *sigh*. Having a shell to run tcpdump IS NOT EQUAL TO HAVING A LIBPCAP BINDING FOR A PROGRAMMING LANGUAGE... mmkay? The point of the article is to show how to use SWIG to create a PHP binding for a C/C++ code. It was done with a libpcap example. So what? dont use it if you dont like it :) this is not a replacement for tcpdump and neither a complete frontend to libpcap (which is NOT an application, but a library). that being said, having access to libpcap from a programming languange (instead of using a shell) is much more useful. if it wasnt like that, why would libpcap have bindings for other languages like python and java? Sometimes it's better to use tcpdump from a shell, and sometimes it's not. 
half hacked? why is this a hack? why cumbersome? have you actually read the article or looked at the source code?
Design the UI first; determine if you're using dropdowns, links, a search form etc. Your queries will be almost the same with whatever scenario you use, just adapt the LIMIT, SORT and OFFSET statements. 
Kohana
Symphony just uses Doctrine ORM AFAIK. You could easily use Doctrine in CI or whatever. CI is certainly simpler to use than Doctrine or Zend but also not as flexible or IMO as well designed. I wouldn't suggest building everything from scratch - you can just use Zend or Symphony components to build a more stripped-down framework and it'll work better than anything you build yourself. 
You can take a look at [my list that I follow on Twitter](https://twitter.com/#!/bsummers82/web-dev/members), they're not all PHP related though.
I've been working in the field for about 13 years, and gone through these painful steps myself. Here's my humble advice: 1) No framework lasts 10 years. At the current rate of change for web programming, and *especially* PHP, code you write today will be outdated and painful to maintain within 5 years, easily. Don't expect things to stay the same - this isn't Fortran we're dealing with. ;) 2) Symfony is awesome. But if you just need a CMS, choose Wordpress, Drupal, or Joomla instead. Don't write it yourself. Choose a solution that's easy to use for anyone who needs to touch it, that requires the minimum amount of upkeep. Preferably one with a wide developer- and install-base, so that bugs are found quickly and resolved quicker. 3.) You can write a quick script to deploy the site in any number of ways - I'd recommend [Capistrano](https://github.com/capistrano/capistrano/wiki/Documentation-v2.x), personally. It integrates nicely with your version control software and makes deployments painless. (Protip: if you're not using one of the above CMS, use DB migrations!) 4.) Get everyone on your team using version control ASAP. They don't have to know it from the commandline with all the GUI tools (Tortoise, etc) available - but they *need* to start using it. You'll save lots of time and money, even if there's a bit of ramping-up time. 
Well that's like, you're opinion man. True MVC frameworks haven't existed in a long, long time. There should be no relation between a controller and a view. Read this for some background: http://martinfowler.com/eaaDev/uiArchs.html So the term MVC has become vague and subjective. Backbone nicely separates the view state and the model state, so there's not that much wrong with calling it MVC. It's definitely closer to MVC than say, rails or ZF.
Hopefully someone finds this as entertaining and awesome as I did
 error: pcap.h: No such file or directory you need to include libpcap header files. they usually can be found in /usr/include or /usr/local/include. try changing the makefile by adding -I&lt;path to libpcap header files&gt; to the CPPFLAGS
I installed libpcap-dev, now there are only a few error lines. [http://pastebin.com/G8ApThS1](http://pastebin.com/G8ApThS1) Thanks for the help!
Definitely a function we need to have in the php core.
I am running Debian 6. including the sys/types.h file into packet.h removed those errors, but now it has: &gt;src/Packet.cpp: In member function âstd::string SimplePcapNs::Packet::__toString()â: &gt;src/Packet.cpp:57: error: âsnprintfâ was not declared in this scope 
... and that would be one more #include &lt;stdio.h&gt; in Packet.cpp. i'm sorry for the extra work, will now commit the changes. I really appreciate the feedback!
It always has
Ok so I tried loading it into PHP-CLI and get the following error: &gt;PHP Warning: PHP Startup: Unable to load dynamic library '/etc/php5/ext/SimplePcap.so' - /etc/php5/ext/SimplePcap.so: undefined symbol: _ZNKSt13runtime_error4whatEv in Unknown on line 0 &gt;PHP 5.3.3-7+squeeze8 with Suhosin-Patch (cli) (built: Feb 10 2012 13:05:56) &gt;Copyright (c) 1997-2009 The PHP Group &gt;Zend Engine v2.3.0, Copyright (c) 1998-2010 Zend Technologies &gt; with Suhosin v0.9.32.1, Copyright (c) 2007-2010, by SektionEins GmbH 
I see how expecting such a life cycle may seem a bit unrealistic, but the company proved to me that it will actually take ten years before someone decides it should be done over.
This about sums up my worries. But instead of building something yourself, have you considered something like Drupal 7?
Thank you for your advise. I considered adopting Drupal, everyone is very impressed of what you can actually click together with its base. I'm a bit afraid the Drupal development is going too fast. We might end up in the situation where Drupal 8 is released when our CMS application is ready. Everyone is on version control already, this is the first thing I did when I started working there. Also, its not a hard demand it should last ten years, but past has thought me it could take up to ten years before someone finally stands up and decides it has been enough and we should develop something new. We're a small team of developers, no one really has the time to invest in work that won't pay itself back within a few months.
I like CI, but having multiple database layers or classes just feels wrong. I want something to be stripped down to our needs.
I can't give you enough up votes. I just spent my entire afternoon fiddling around with this. But, adopting this method and creating a small framework to our needs would seem a lot like recreating Silex, wouldn't it?
I am not all that well versed in GCC and Makefiles. How would I go about linking it with the complete path /usr/lib/libstdc++.so.6 ? Sorry for being such a GCC noob.
It seems like you need to go back to basics if you an't quite figure this out. I recommend relearning [forms](http://w3schools.com/html/html_forms.asp), [tables](http://w3schools.com/html/html_tables.asp), [looping](http://w3schools.com/php/php_looping.asp), and possibly just reviewing the basics of [php](http://w3schools.com/php/default.asp) edit:Formatting.
Goldsound, a word of advice: if there is one thing frowned upon in programming related forums( here and elsewhere) is precisely this sort of post, where is evident that little or no effort has been made to accomplish the task. Give us something to work on. Tell me what would your approach be. Show us the rough sketch of the initial form...something. That way it's much more likely you'll get any sort of help. Also : [r/PHPhelp/](http://www.reddit.com/r/PHPhelp/)
&gt;We might end up in the situation where Drupal 8 is released when our CMS application is ready. ...then just upgrade as it does. There's really no magic here, if you stay up to date with new versions, it's relatively painless to upgrade. The same level of effort will be required regardless of what package you choose - and it's far less effort than keeping a homegrown solution up to date. &gt;Everyone is on version control already, this is the first thing I did when I started working there. Great. :) &gt;Also, its not a hard demand it should last ten years Yes, yes it is. For all the reasons I already covered. What you're asking for is *madness*. PHP will be several major versions ahead in 10 years; would you really want PHP3 code to still be running on your production sites? With global variables, virtually no OOP support? I don't think so. &gt;We're a small team of developers, no one really has the time to invest in work that won't pay itself back within a few months. All the more reason to use an off-the-shelf solution: * Low start-up costs (nothing to write) * Low overhead &amp; upkeep costs (little to maintain) * Low training &amp; investment costs (easy to teach) You receive none of those benefits doing it yourself. :)
great! you should be done now.. what you're missing now is a valid syntax for a libpcap filter. In this case, try "port 80". You can read more about the syntax for the filters here: http://wiki.wireshark.org/CaptureFilters Hint: php sniff.php eth0 "port 80" 4096
ah that was my half baked mistake, put quotes around the spaced argument. But one more: &gt;Sniffing on: eth0 &gt;terminate called after throwing an instance of 'std::logic_error' &gt; what(): basic_string::_S_construct NULL not valid &gt;Aborted 
pcap_next() might be returning null due to an error when trying to capture a packet. So i've commited a check for it. an exception is thrown when this happens. could you try making a pull and recompiling, to see if that's the case?
Yep, that is what it's for.
I did go ahead with your suggestion of moving towards PSR-0 and included a very basic PSR-0 autoloader available as part of a general bootstrap process. https://github.com/nategood/httpful In addition, I included a build script that takes all the src files and concatenates them into a single download file (that fires as a git hook). The single file is available as a standalone download on github. Thanks for the PSR-0 suggestions.
No one's here mentioned something pretty much tailor made for you: Silverstripe. It's a CMS that's built on top of the Sapphire Framework. Out of the box it comes with a good CMS system, but what it excels in is that it's made for developers to build upon, with clear code and an MVC architecture. Check it out.
The EOL for Drupal 7 should be at least 5 years from now. And by the time you want to switch there will be an upgrade path. Drupal 8 is also adopting parts of symfony for the beginning of page requests and bootstrapping so it is becoming a better of both worlds scenario. 
Look back 10 years, to 2002, and see which of the frameworks out then would have seen you through the next 10 years, and how you would have been able to pick that winner. Then scrap your silly requirement.
I already knew about it (as well as soundex), but it's still very interesting!
You propose someone do *more* work because this function has less value? Leaving it alone requires no effort at all. 
No, Backbone.js never claims to be an MVC framework. It doesn't have any controllers. To call it an MVC framework would be like calling Kohana a full-stack framework: it's missing some crucial parts to fit that definition. &gt;So the term MVC has become vague and subjective. I agree. However, all you're doing is making it more vague by claiming Backbone is an MVC framework.
The price of maintaining a sane language...
The global namespace is a lost cause -- you're not going to make the language sane by trimming functions one at a time. 
It took 3 years for it to move from 6 -&gt; 7... how is that fast?
I've found that the soundex is actually a better function to use in searches with misspellings. http://php.net/manual/en/function.soundex.php
What about [double metaphone](http://en.wikipedia.org/wiki/Metaphone#Double_Metaphone)? The original metaphone is a pretty simple algorithm - simple enough that I can easily implement it myself (and have done). It's also not nearly as effective as double metaphone or as well-tuned to English, and to as many other languages. Edit: There's also a metaphone 3 but I'm not overly familiar with it.
This is hardly the case. In fact I started off as a front end developer and Drupal (particularly views) gave me the ability to build sites I thought were beyond my skillsets. I've spent a lot of time over the last 3 years building my programming knowledge and now Drupal also gives me a wide range of hooks to allow me to extend the core features. As for Drupal being difficult for end users, I think this is a common misconception. Node add/edit forms can be simplified and are hardly difficult to work with unless of course poor development choices are made along the way. 
If you have no programming experience: [Learn Python the Hard Way](http://learnpythonthehardway.org/book/) For programmers: [python.org wiki](http://wiki.python.org/moin/BeginnersGuide/Programmers)
Really? We're down to parroting the manual without saying anything interesting?
Thank you
This looks nice. How does this apply to my needs though?
Depends on the framework - there is a lot of junk in the PHP world.
The Zend framework is one of the best maintained frameworks at the moment. And it seems Zend will continue to do so for the next couple of years. (Futureproof), Furthermore the ZF is very updatable, and this process is rather hassle free (as long as you respect the ZF design priciples) (Maintainability). Other frameworks like, CI, Cake, kohana, Yii, (the list is extensive) sometimes add more specific functionality to the mix whereas ZF is one big library with take away modules you only include and use at your own convenience. That can be easily extended into your own personalized library(Highly flexible, yet very very structured). To be honest, I never was a big fan of the ZF. I always thought the payload of the library was way to high. And I did not like the way the folder layout of the framework was layed out. Also the database abstraction layer was a weaker spot (Inefficient). It turns out that many of the issues with the previous version are not that bad an issue anymore in ZF2. Keep in mind this is just my opinion. Frameworks ive worked in include - Zend Framework 1 and 2 - CI - Cake - The obscure framework/cms, that shall remain nameless, we use at work :P
And now guess what: Now even more functions get thrown into the core!
Did php.net have a DNS issue? I'm finding it won't resolve at the moment. Anyone know a mirror site that's not a subdomain of "php.net"?
It seems like you feel quite strongly about that issue. A double metaphone implementation is already available here: http://pecl.php.net/package/doublemetaphone
heh 1 point
Ugh. More linkspam. 
This function "simply" swaps pre- and lastname of $full_name. Believe it or not. It uses 14(!) nested foreach-loops: public function get_simple_name($full_name, $title = NULL) { $parsed_name = preg_replace('/&lt;.*&gt;/', '', $full_name); $title_slash = '/' . $title . '/'; $title_slash_colon = '/' . $title . ':/'; if(preg_match($title_slash, $parsed_name) == 1 &amp;&amp; preg_match($title_slash_colon, $parsed_name) == 0 ) { $parsed_name = preg_replace($title_slash, '', $parsed_name); } $name_slash_array = explode ('/', $parsed_name); foreach ($name_slash_array as &amp;$name_slash) { $name_semicolon_array = explode(';', $name_slash); foreach ($name_semicolon_array as &amp;$name_semicolon) { $name_colon_array = explode(':', $name_semicolon); foreach ($name_colon_array as &amp;$name_colon) { $name_hrsg_array = explode('Hrsg. ', $name_colon); foreach ($name_hrsg_array as &amp;$name_hrsg) { $name_red_array = explode('Red. ', $name_hrsg); foreach ($name_red_array as &amp;$name_red) { $name_ed_array = explode('Ed. ', $name_red); foreach ($name_ed_array as &amp;$name_ed) { $name_inh_array = explode('Inh. ', $name_ed); foreach ($name_inh_array as &amp;$name_inh) { $name_vlg_array = explode('Vlg. ', $name_inh); foreach ($name_vlg_array as &amp;$name_vlg) { $name_by_array = explode(' by ', $name_vlg); foreach ($name_by_array as &amp;$name_by) { $name_and_array = explode('&amp;', $name_by); foreach ($name_and_array as &amp;$name_and) { $name_and_word_array = explode(' and ', $name_and); foreach ($name_and_word_array as &amp;$name_and_word) { if (preg_match('/[.*]/', $name_and_word)) { $name_square_bracket_array = explode ('[', $name_and_word); $name_square_bracket = $name_square_bracket_array[0]; } else { $name_square_bracket_array = array($name_and_word); $name_square_bracket = $name_and_word; } if (preg_match('/(.*)/', $name_square_bracket)) { $name_bracket_array = explode ('(', $name_square_bracket); $name_bracket = $name_bracket_array[0]; } else { $name_bracket_array = array($name_square_bracket); $name_bracket = $name_square_bracket; } $name_line_comma_array = explode('-,', $name_bracket); foreach ($name_line_comma_array as &amp;$name_line_comma) { $name_comma_array = explode(',', $name_line_comma); $implode_sign = ', '; foreach ($name_comma_array as &amp;$name_comma) { if(trim($name_comma)=='' || preg_replace('/[A-Za-z0-9]*/', '', $name_comma) != '') { unset($name_comma); } } if (count($name_comma_array) == 2) { $switch = 0; foreach ($name_comma_array as &amp;$name_comma) { $name_comma = trim($name_comma); if (preg_match('/0-9/', $name_comma) == 0 &amp;&amp; preg_match('/a-z/', substr($name_comma, 0, 1)) == 0) { $switch = 1; } } if ($switch == 1) { $switch_array = $name_comma_array[0]; $name_comma_array[0] = $name_comma_array[1]; $name_comma_array[1] = $switch_array; $implode_sign = ' '; } } $name_line_comma = implode($implode_sign, $name_comma_array); } $name_bracket_array[0] = implode('-, ', $name_line_comma_array); $name_square_bracket_array[0] = implode(' (', $name_bracket_array); $name_and_word = implode(' [', $name_square_bracket_array); } $name_and = implode(' and ', $name_and_word_array); } $name_by = implode(' &amp; ', $name_and_array); } $name_vlg = implode(' by ', $name_by_array); } $name_inh = implode(' Vlg. ', $name_vlg_array); } $name_ed = implode(' Inh. ', $name_inh_array); } $name_red = implode(' Ed. ', $name_ed_array); } $name_hrsg = implode(' Red. ', $name_red_array); } $name_colon = implode(' Hrsg. ', $name_hrsg_array); } $name_semicolon = implode(': ', $name_colon_array); } $name_slash = implode('; ', $name_semicolon_array); } $parsed_name = implode(' / ', $name_slash_array); $parsed_name = trim($parsed_name); return $parsed_name; } 
Personally I'd use sprintf().
No major, self taught probably.
In addition, 6 will be supported (security-wise) until Drupal 8's release.
Most every linux distro ships with PHP packages; PHP provides windows binaries, and OSX comes with it by default (and it's included in all the 3rd party package managers too). *I* compile because I get exactly the binary I need, with all the extensions I want (invariable some of the more esoteric ones I use are not included).
yeah or even apt-get install php5-cli php5-cgi and there's even an stupid-simple "instant LAMP server" mode in ubuntu server, but what confuses me the most is "I'm honestly only using PHP for PHPMyAdmin" -- why would you actively choose to use PHPMyAdmin? Especially in an environment where you don't work with PHP anyway.
Top Google result for "php-mysqli ubuntu" is a Stackoverflow page where the answer is: apt-get install php5-mysqli
you could also use the synaptics package manager which allow syou to search for available packages.
Anyone who has done any kind of server administration knows that it is not as simple as taking execution time * "made up number goes here" = amount of seconds to complete without running out of memory or whatever you are looking for. Your calculations would be in THE MOST ideal and IDLE conditions possible. Which never happen. MySQL runs a big query and starts writing to disk? You're screwed, 10 concurrent requests goes down to 2. Backup service starts up? Screwed again. Updating a service? Halve your concurrent requests. Any number of vital services are running and crunching memory and sipping CPU all the time, and the more CPU and memory you use, the more CPU and memory you use. It is a vicious circle that needs regulation. As I have stated many times, for a simple blog, or company informational website, it's fine. But when it comes to large scaling sites, you'll either be spending a lot of money on servers, or a lot of money on debugging a framework to work the way you want it to work...at which point, why not have started your own code from the beginning? If a complex gaming site can do all of its work in under 100ms and under 1MB of memory use, then there shouldn't be many reasons for a framework like Symfony to be using 8to 15MB of ram per request on a DEAD page, and anywhere from 300-500ms to execute on a DEAD page.
Using the new code with a timeout set works. I just had to change in the GNUMakefile, libstdc++ to the actual location of the library~~, and Debian's PHP includes folder is in a different location (/usr/lib/php5/).~~ (did not fully read over the readme, that says I have to change the php include location) Other than that, works great so far.
great news :) thanks for giving it a try. Let me know your thoughts about it, my email is at my github account, and in the article itself. enjoy :)
Hi, paying is not an issue, we're looking to get a balance between price/performance. I'm going to take a look at what you told me. For streaming we'll be using amazon cloudfront i thougth it was the easiest/less problematic solution Thanks!
Take three porn sites that stream videos. Examine the CDNs they use to host their content. 
CloudFront is a decent solution, depends on how much traffic you expect. It's good if you start really small, your costs are way down this way, but as you grow it will quickly become more expensive than a regular host. If you are expecting enough traffic to warrant it, you can always find a good host get a dedicated server with a 1Gb pipe and 100Tb/Bandwidth Per month (or depending your country you can find unlimited bandwidth with a 1Gb pipe at reasonable cost), install lighttpd+mod_h264 and you are set for a pretty solid solution that will scale (money wise). For the player you have plenty of options, but the most popular ones are [JWPlayer](http://www.longtailvideo.com/players) and the [FlowPlayer](http://flowplayer.org/). I've worked with both, and i have a preference for the FlowPlayer.
Good advise!!!
Hmm, I wasn't aware that iterating over and array was considered a write. You sure about that? If true, it's incredibly misleading from a user standpoint. 
And make sure to spread around some... privileged memberships to the... videoclub you're developing.
I found the hardest part was finding a video encoder that your host supports and works well. That is if you plan on allowing users to upload video files.
You can use http://php.net/xmlreader to pseudo-manually parse an XML file. The advantage over SimpleXML et al. is that it will not build up a full XML parse tree in memory but instead only extracts the needed data. On the other hand it is a good bit harder to use. So if it is a large file and you only need little info, go with XMLReader.
This is my first draft of the library, any feedback would be more then welcome, and I'd be happy to answer any questions about it. For those wondering the short version of what this library does is gives you a simplified, more accurate way of seeing how similar 2 strings are. This is useful for Spellchecking, Search Engines, Recommendations, AI, etc..
The reason they are all hacky is because PHP wasn't intended for this. Of those that you have listed, I have used bamcompile in the past and it works fine, although I haven't used any database extensions with it.
Very cool! I realize this comment brings no value to your submission, but I just wanted to let you know I think this is a great release :)
Do you have experience troubleshooting the xmlreader? I posed the xml file and code im trying to write in the main description, if you could take a look. thanks!
I'm just saying, he could have very easily have found the APIs he was looking for by typing in "PHP XML" in Google. The PHP manual is an excellent resource, and it is a shame that he isn't using it. He'll grow and learn more if he knows how to look that information up for himself rather than relying on other people for basic information like this. Edit: *sigh* Are you really going to downvote me for trying to encourage him to try and find answers for himself? Ever heard of the following Chinese proverb? &gt;"Give a man a fish and you feed him for a day. Teach a man to fish and you feed him for a lifetime."
No no no no no. Use this: https://github.com/koto/phar-util With it, I have the following Makefile that works for any PHP app with minor mods: PHAR = webpage_consolidator.phar SOURCE = \ simplehtmldom/simple_html_dom.php \ WebPageConsolidator.inc.php \ WebpageCache.inc.php \ index.php $(PHAR): $(SOURCE) @echo "1. Packaging source files..." @mkdir src @cp -a Web* index.php simplehtmldom src @echo "2. Generating certificates..." @mkdir cert @cd cert; phar-generate-cert echo "3. Creating $(PHAR) phar..." @phar-build --phar $(PHAR) clean: @echo "Cleaning up..." @rm -rf src cert webpage_consolidator.phar* dist: rm -rf src cert 
I didn't really use a book to learn. I came with a programming background in Java, and pretty much took to the world with just what I knew and php.net. I love using frameworks to an extent. When using a framework, I've been using CodeIgniter, which I really love. I think a framework is great for common frequent tasks, like I love all of the database functions and stuff, but you can get this type of functionality elsewhere (like PDO whatsit). In contrast I think it's almost easier to just type up all the HTML for a form than to use the functions in CodeIgniter. I love writing my own "mini" frameworks, and I always try to write code for maximum re-usability and always save good snippets of code in a special file. As you know, that's one of the main benefits of using a framework: high code re-usability, faster deployment. (And of course, there's MVC.) But if you write it yourself, sure you may be re-inventing the wheel, but there are definite advantages to understanding that wheel inside and out.
What is the advantage of this over just using PHP built-in getopt()?
It should be really easy to find a LESS library and port it into a bundle. Better than hooks, Laravel has events that are a pleasure to work with. The Eloquent ORM is.. eloquent. Just super simple and it works. Updating should be very simple if you use git: Just fork it on github and merge from upstream when you want to update. On top of all that, Laravel is by far the fastest framework in its class. The creator, Taylor Otwell, is a freaking genius.
I believe since it changes the internal pointer that it is. I'm not 100% certain on that though.
Thanks Voltric. I'll take a look at CodeIgniter. Like I said, I don't even know what frameworks are available. Do you know of any editors that would be really good to use for PHP on a Mac? For instance, I'm a Flash developer and so I use Flash Builder which is invaluable for its code-completion, refactoring tools, etc.. Is there some sort of equivalent for PHP? By default I would just be using Textmate, but it doesn't exactly help out in the ways I would like it to. 
Headers already sent usually is an issue with having ANY sort of output before you call the header() functions etc. Even a newline before your &lt;?php tag will throw that off. I'm not 100% sure what you're talking about with the rest of it, you're saying you want to output some GD image instead of text?
If you're using a framework like CodeIgniter (Which is great), then I'd highly recommend using Coda by Panic, they have a demo for you to try out. It is excellent and reasonably extensible. It'll make your CI experience a lot better.
Sublime Text 2 is a great editor but not very good autocompletion - I'd argue that as a newcomer to the language, with all its problems and "gotchas", to try to learn as many of the functions you will use on a regular basis without an autocomplete utility. That being said, I hear good things about Komodo, Netbeans, Eclipse PDT, and PHPStorm (I believe that is the name). I plan on using Netbeans in the future, and have used Eclipse. I am not very fond of Java-based IDEs ala Eclipse due to their sluggish nature and amount of disk i/o. Personal issue though, my machines are generally more than capable, so it is simply an annoyance rather than a usability issue.
TextMate is one of the best editors out there. It's maybe not as user-friendly on the surface as Coda, but in terms of actual code-editing, I think it's the best. The problem is that it IS a little dated. Sublime has some new cool features that TextMate doesn't have. TextMate 2 is in Alpha and introduces a bunch new features, but development is super slow. If you're a ZenCoder, TextMate has much better implementation than Coda. I've used Sublime 2, and I like it alright, and I believe it's Win/Mac/Linux, which is nice if you're a multi-OS user (for consistency).
Have the image script be standalone, and embed the image in your regular site with: &lt;img src="path/to/your/script.php"&gt; and it will embed correctly. 
Looks like you have your answer(s) over there? You can't do header(content-type) twice like that - nor can you just throw an image content type editor in with text output. You'll need to have two separate scripts, or as someone else points out you can base64 encode the output and do some fun stuff that way. Either way you have your solution. Also posting your code and at the very least your exact error message is super helpful. 
Now the question becomes... getting this to work in a Joomla installation! I have jumi installed, so I can link to a PHP file from within an article! Working on that...
This is a great question! My Thrive_CLI_Helper is the most advanced (and at the same time easy and elegant) CLI parser I've ever programmed against, and that includes Perl's Commandline_Parse (whose option syntax it's most compatible with), bash, Console_Getopt, and getopt (the C library, unix command, and PHP function). How so? Let's see: Two line initialization is all you need. You can have more complex options that really shine. Here's the demo: http://pastie.org/3423694 cli = new Thrive_CLI_Helper; // Long options are based on PERL's CommandLine_Parse syntax. $longOpts = array('!host=', 'user=', 'pass=', '!database=', 'filter=', 'verbose:', 'debug', 'exclude@'); try { $params = $cli-&gt;getParams($longOpts); } catch (Thrive_CLI_Exception $e) { if ($e-&gt;getCode() == Thrive_CLI_Exception::HELP_REQUESTED) { showHelp(); die(1); } } What this means is that --host is a required option and requires a value , user is optional but requires a value, verbose is optional and has an optional value, exclude is optional but it accepts multiple values: e.g. --exclude a --exclude b (think rsync,). The best part is, my library handles everything for you! Check it: ~/thrive $ demos/handle_cli_args.php Error: missing required option --host. Try 'demos/handle_cli_args.php --help' for more information. ~/thrive $ demos/handle_cli_args.php --host Error: missing required value for --host. Try 'demos/handle_cli_args.php --help' for more information. ~/thrive $ demos/handle_cli_args.php --host=localhost Error: missing required option --database. Try 'demos/handle_cli_args.php --help' for more information. ~/thrive $ demos/handle_cli_args.php --host=localhost --database mysql --exclude Error: missing required value for --exclude. Try 'demos/handle_cli_args.php --help' for more information. ~/thrive $ demos/handle_cli_args.php --host=localhost --database mysql --exclude a --exclude b --verbose Strictness: 101 Value of passed CLI params: Array ( [host] =&gt; localhost [database] =&gt; mysql [exclude] =&gt; Array ( [0] =&gt; a [1] =&gt; b ) ) Now try doing that with any other command line parser library / utility in any language in less than 3 lines of active code, that returns a simple, concise array. I've never found anything like it. Also, I've **never** found a CLI parser that accepts **both** equals or no equals for values (e.g. --host localhost or --host=localhost). Go ahead, show me a single CLI app that accepts both. I'd genuinely like to know. I tested every GNU app I could think of and many others in a mad quest to find one that supported both, but they just don't exist, and such support is devoid of every CLI parser I've seen. Additionally, I've used HipHop to compile it to a C library, so it could be an arguable getopt replacement.
This topic seems to come up a lot. I'm glad some developers are starting to look at password security a little more seriously. I hear a lot of complaints that proper hashing is too difficult, not worth the effort, or is "overkill", despite how simple it is to actually implement. If you're working with php 5.3+, I've been working on a library to make working with password hashes very easy while remaining flexible. It supports bcrypt out-of-the-box, and has configurable support for PBKDF2 and others. If anybody would care to take a look, I always value feedback: [PHPass](https://www.github.com/rchouinard/phpass).
Interesting post re: the BC break. I've been aware of it, but I didn't know all the details about the alternative hash ids. Thanks for sharing!
Came here to recommend phpass too
Do some unbiased research and I think you will find that Wordpress is a solid choice. Look into what companies use Wordpress. I have been doing highly customized solutions for a while and Wordpress has been a dream to develop for. Going with a pre-built CMS will save you a load of time once you understand how the platform works. There are lots of untrue facts floating around in this here thread. Yes, some things will slow Wordpress down: -your own unoptimized code -a slow host (shared hosting is NOT a problem with Wordpress scaling!) -poor server setup -too many plugins A chart from last year: http://www.techi.com/2011/07/open-source-wars-wordpress-vs-drupal-vs-joomla/ Optimize Wordpress for high traffic: http://www.619cloud.com/blog/5-essential-steps-for-hosting-wordpress/ 
I've never encountered it when using a correctly salted crypt()... *shrug*
I'm also glad to see others taking password security seriously. It's amazing how many websites just store plaintext passwords. What is the advantage of using PHPass over just a simple call to crypt() as mentioned in the original post? I browsed through the PHPass code and it seems to be quite a large and complicated object oriented framework, but I'm guessing it's intended to be extensible for more complex purposes in the future? I see that it does have a password strength calculator feature which could be useful.
As far as I can tell, crypt() does alter the last salt character in the returned hash, but whatever the purpose of that may be, the function still stores the salt as part of the returned hash string and it works as intended. Thanks for your input. I updated my original comment with some code that's even simpler than the code in the original article. It turns out all you have to do is use crypt() with a good random salt and there's not much else to it. It's too bad all those old outdated articles on the web make password hashing sound so complicated. At least with new versions of PHP it's really simple.
If you want me to get real nitpicky... :) You use some phpdoc but not for everything. Also, the phpdoc syntax you are using is not any I am familiar with (at least parts of it)... Also, since there is a not a lot of documentation, I am confused as to why you would ever want to se "cost" manually. Isn't this erturned by a call to levenshtein? If so, why is this the first constructor parameter? The others seem more likely candidates for overriding. To make the code slightly more accessible using a common code formatting standard would be nice (e.g. pear, zend, etc). So, for example, the naming of the functions (camel case), spaces vs tabs, white space in general, etc. However this is always subject to debate... ;) Also, I don't know enough about this algorithm, but why are you limited to only 255 character? Do you have any idea how much the speed of the algorithm is affected? I just found out about this algorithm recently and was thinking of using it in some applications, so thanks for your input.
[intval()](http://us2.php.net/manual/en/function.intval.php)
It's mainly about flexibility. With PHPass, you can use a variety of hashing methods with just two or three lines of code. It looks like a complicated beast, but actually using it is very easy. If all you ever need is bcrypt, and you don't care about a consistent API across hashing methods, the sample in the article is fine. PHPass will probably generate a better salt, though. :-) And yes, my plan is to make the library more than just a hashing library. The password strength calculators are just one step in that direction. 
Not the worst, but something simple to add in (as pseudo code from memory): input $target; $x = 0; while ($x &lt; $target) { $x = $x + 100; } $range = ($x-100) . '-' . ($x - 1);
Awesome, thanks. How do I implement this inside of my array?
I enjoy Netbeans on all OS's and its free. There is a file you can import which should allow for auto-completion to work correctly. [link](http://codeigniter.com/forums/viewthread/187949/) This is the most recent version I can find -- it has instructions on how to load it as well.
I'd do it inside of this theoretical function you mentioned that computes. There's no way my advise on something like that can really be good advise. You're the one writing the code, you should know better than me.
I would find this too specialized and limiting. For example what if I don't particularly want to use metaphone but do want to use levenshtein? Also for medium to large datasets, which is a very common scenario, you should be doing your phonetic string matching separately from edit distance which should be done only on the matches. And if you're working with a database, you'd be better off putting the phonetic index in an indexed persisted computed column rather than outsourcing to a scripting language. BUT that's just me. For people who just want to work with small datasets and aren't particularly keen on working directly with metaphone or levenshtein then this lib will be right up their alley. I'm sure there's a need for it. 
Thats exactly why I built the library, its far less daunting to use a simple library then to dive into the intricacies of metaphones and string similarity. If your working with large sets and high throughput, you would most definitely want to build something custom anyway. If for no other reason the PHP levenshtein &amp; metaphone functions arnt very efficient, Im hoping to improve this in the future versions though.
Since you're a Java dev, nothing wrong with Eclipse for PHP. Side-benefit is you can use the same editor for your Java (or other) projects as usual.
There is a popular php password hashing library called phpass from openwall, is this a wrapper for that? http://www.openwall.com/phpass/
I'm curious, what's an application for this?
Not a wrapper, more of a rewrite. My intention at first was to update it to PHP 5 standards, then I used it as a personal project in keeping up with 5.2 and eventually 5.3 changes. It's kind of evolved into something different now. Most, if not all, original code from openwall is in the portable adapter. The name is still a carry-over though, yes.
Interesting. I've only used LD for duplicate detection but I hadn't considered a semantic analysis pass or stemming beforehand.
I've had good luck with [Zencoder](http://zencoder.com/) in the past, they'll encode about anything to about anything, and after encoding will drop the files wherever you want via FTP/SFTP, S3 or Rackspace CloudFiles. 
could you make your comment a little more racist, just to round things off?
I personally love the [Fuel](http://www.fuelphp.com/) framework.
There is also a live website for this project, the CD version will just mirror the live site for those who have a slow or flaky internet connection. Most users are going to use it online, we just wanted a simple way to allow people to use it who do not have that option. It's a government project, so by law they have to make it available to as many people as possible. It's a bunch of training and testing scenarios, not something that would have to be constantly updated like a regular website. I agree in most cases this would be a stupid way to present a website. 
Well, I see what you're saying... the code uses sha1() means it's only generating hex characters which have a smaller range of bits than [A-Za-z0-9./]. But that's just the salt... it only needs enough bits to make rainbow tables impractical. That doesn't take many bits at all (even just using the user's id as the salt is considered to be acceptable in most cases). As the article says "the attacker would have to generate 10 million separate Rainbow Tables, which would be completely impractical." By that point, a brute force is relatively easier than generating that many rainbow tables, so the complexity of the salt isn't an issue. I'm definitely no expert on this stuff, but that's my understanding of it. Having said that, the added complexity of bcrypt's salt certainly couldn't hurt if you don't mind that a little more code is involved in generating it.
Could we see the source? You could have the error reporting suppressed which would lead to this problem.
You'll want to use the internal directory pathing, not the external version since that will go through apache and error since you should have directory browsing disabled.
What server are you running? Has it worked in the past? Any recent changes? Have you tried to piece everything out to find your error? 
If every thing else fails, here is a xml parsing/ generating/ manipulation library I wrote using DOM functions.crXml, Details are in this forums post http://forums.devnetwork.net/viewtopic.php?f=50&amp;t=127475 here is documentation(unfinished) . http://www.phpclasses.org/browse/file/34394.html It contains a search function that when called, returns the php statements that can be used to access the matching nodes. Its use also is mentioned in the above post. It also makes working with namespaces very straightforward. An example usage would be, for eg: $x=new crXml(); $xml=&lt;&lt;&lt;EOB &lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;records&gt; &lt;name&gt;sandeep&lt;/name&gt; &lt;/records&gt; EOB; $crxml-&gt;loadXML($xml); var_dump($crxml-&gt;search('name')); calling var_dump($crxml-&gt;search('name')) would print an array with all the 'name' nodes it can find in the xml. and for each entry there will be a key 'accessStatement'. here it would contain "..-&gt;records-&gt;name". so that you can use statement $crxml-&gt;records-&gt;name to access the nodes value. in this case the string 'sandeep'. Hope this helps. 
Ok, well I'd say you should look into small self contained web servers that can run without an installer or with a very minimal/seamless install (not sure if it exists, but I want to think I've heard of this somewhere years ago). Then I'd package PHP with it (possibly with a "phar" archive). On top of that, I'd say use a SQLite database, which is just a simple single file based database that can either be saved on the computer or run directly from CD-ROM (read only). Again, I'm not sure but maybe you could use XAMPP or something along those lines to run your HTTP service that would then pipe requests over to PHP that would then host the website for you locally on their computer. You could also try extending that SQLite database to download and sync with a remote copy whenever a connection is present in order to keep the local content up-to-date.
if its not actually a local dir you may want to look into curl. 
That's precisely what I was thinking of; nice find! It's sort of cool, if you ask me. Niche (which is what you're dealing with), but interesting no less. I was once tasked with the prospect of setting up a Kiosk and the first thing that came to mind was to setup a local web server and have it run a chrome browser off the local web server with the occasional sync (pull) from a remote server to keep everything up to date. I wouldn't have used *this* software per se (on linux, plus I would have time to set it up), but I can see this serving a similar and more general purpose.
Ok, thanks for the good explanation!
I believe you should not be using the full path (e.g. http://www.the-irf.com/files/), not only because it is bad practice, but also is_dir does not recognize it as a directory. Simply change $dir to "files" (or "./files" or "/files") and you should be fine.
Unfortunately, it does get one concept wrong, regarding collisions: he is mixing up collision resistance and preimage resistance. For some hash h() and messages m_1 and m_2: * *Collision resistance* means it is infeasible to find some m_1 and m_2 *simultaneously* such that h(m_1) = h(m_2). MD4 is particularly weak to this attack. * *First preimage resistance* means that given h(m_1), it is infeasible to find some m_2 such that h(m_1) = h(m_2). * *Second preimage resistance* means that given m_1, it is infeasible to find some m_2 such that h(m_1) = h(m_2). The relevant issue with regards to passwords is the first preimage resistance of the hash, the collision resistance is a different matter. The complexity of the collision attack against MD4 is just 3, but the best first preimage attack still has complexity 2^70.4; so while it's very easy to make two pieces of data that have the same MD4 hash, it's still difficult to find a message whose hash matches a given hash.
No, if you read the article, especially problem 4, you'll see why you should be using bcrypt, not sha1. Sha1 is designed for speed, password hashing should be slow.
Thanks for all the info, the movies will be available to subscribers only (pay users), so youtube is out of the question (we also plan on establishing a Youtube channel for trailers/promos), thanks for your recommendations, i'm actually looking at Flowplayer because it seems to support S3+CloudFront one time urls.
you should probably rename it to avoid confusing, because my initial thought as well was that you are the person who wrote (the original) phpass.
He doesn't talk about collision specifically enough (in terms of the different types, as you've laid out here) to call anything that he's said really wrong though, I don't think. Generally, they're all referred to as some sort of colliding attack.
Is the important part that it's not selectable? This effect can be achieved with text and CSS. -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; user-select: none;
I was asked to develop a site in a week. I did it with Joomla with a good 1 dozen extensions installed for enhancements. I don't know if I could have done it with Drupal or WordPress. Take that for what it's worth. Since the site has been done and live, I have gained 4 new clients to develop sites.
Yes, that is important. I will retain that CSS in my archives. Thank you! I also require that the text be not indexed by search engines. For example, if someone searches for the name John Doe, there should not be a hit to my domain. So instead, I will be creating an image on the fly that is the person's name.
Not the whole truth of it, though. The admin account is likely to be a very low number user id, and the author might want to crack that, as it could be a very useful account and/or password to have. Or indeed, many low id accounts might be useful. If so, the id only adding one or two characters of entropy is not going to phase the attacker or their rainbow table(s) one bit. Two ways to avert this is - A) by using random uuid's instead of auto-incrementing ids B) just use a random salt stored with a bcrypt hash, or similar scheme. Both of these options are using long(er) random data, incidentally the same as what a salt does. You can see why just using a normal, randomly generated salt is the best recommendation. It's to add enough entropy to the password that the user's password's entropy no longer matters.
It shouldn't affect how secure it is positively or negatively, however I don't see much to gain from doing this.
Yes, I probably should. When the openwall project was introduced to me, my colleagues referred to it by the class name, PasswordHash. I didn't realize it was actually called phpass until I was using the Phpass_ class prefix (now namespace). I suck at naming things, so I've been slow to do much with it.
Ahhh once you said the ! stand for not it became clear. Thank you for your help. I'm at work right now, but when I get some time I will make the changes to my php file and try again.
Naming aside (as mentioned elsewhere in the thread, I do agree), I'm open to suggestions on improvements. My goal is to remove many of the excuses I hear about proper password management, and making it as simple to implement as possible is a step towards that goal. 
`end(array_values($array))`?
This works also and might be safer (depending upon context): static function factory(array $array) { return new static($array); } 
its lightpd with debian squeeze. it has worked it the past multiple times. no recent changes to the server except this file and everything else on the server works fine.
oh okay. is there any way to access a non local dir in php?
Well. Since this is the *right* way. I'm sure I'd never, *ever* seen that before. How amateur of me. Why would I implement a whole new class and sneak it into the PHP base when there was a *PHP way* of doing it?
It's not a class you dumb shit.
No it isn't. Phpstorm is far better.
turns out there were no errors just that i was using a non-local dir.
From PHP.net &gt; Returns a numerical array that corresponds to the fetched row **and moves the internal data pointer ahead**. This alone suggests that the result needs to be iterated; meaning you must loop through it. while ($row = mysql_fetch_row($result)) { echo $row[0], '&lt;br /&gt;'; } This works because mysql_fetch_row returns FALSE on error. I hope this is what you were looking for. I don't know what you mean when you say "spaces."
To access a non-local directory tree the server that you are connecting to must list the directory contents, which isn't as common as it used to be - not a problem if you have control over both servers but there are better ways to access remote files behind the scenes. Your basic file index page is pretty simple and you may not even need cURL to parse it, you'd just need to load the URL with something simple like $html = file_get_contents('www.example.com/the-directory'); and then parse it down either by converting it to one of the many XML objects or if speed/sanity isn't a concern, regular expressions.
It is impossible to use the built in php file/dir functions on a URL, yes. But that doesn't make the task impossible, it just adds a few steps (like creating a way to parse the HTML from the server's directory list)
the data in comp_offer is "5KG Koala meat for £3.50" and its when it hits the first space it stops so it only echos "5KG" i hope this sheds more light on my problem. thanks for your response BTW
What is the column definition for `comp_offer` in the `users` table? Char, Varchar? What is the character limit? This is very odd behavior for PHP. Can you verify that the column value is "5KG Koala meat for £3.50" and not truncated?
its VARCHAR with 140 limit if i look at my actual database in PHP MyAdmin the entire text is there
Well I'm glad it doesn't make it less secure. My reasoning behind it is that the result from XORing the value with the salt still doesn't look like an actual value with a salt attached the end. :) Thanks for the feedback
oh okay. well file_get_contents will return the different files in a string. but i have no clue how to convert them into xml objects and then what to do from there
Well the title doesn't say it's a new "major version" ;)
Putting "major" and "version" in the same sentence does tend to muddy the waters :P
Hrm. Turns out you are correct. The documentation says: Note: This function will reset() the array pointer of the input array after use. I guess maybe I'm just reading that wrong, as reset() will set the array pointer to the beginning of the array.
I think you're reading it right, but the manual has it wrong. It's definitely a misprint in the docs.
Well it is Apache, a minor version number is usually a major update.
Use prepared statements; they're immune from SQL injection: $pdo = new PDO($dsn); $stmt = $pdo-&gt;prepare("SELECT comp_offer FROM users WHERE user = ?"); $result = $stmt-&gt;execute(array($user));
Ah, sweet. I guess I'll do my duty and file a bug.
Great stuff! mod_lua FTW!
Semantics.
It's pretty much the same situation as PHP itself, really. Minor version increments are actually fairly big deals (bigger for Apache, obviously!).
There will be a requirement to save user data to some sort of local storage. When I get around to it, I'm going to set up a prototype using server2go and see if it can store the database files in a local directory. I may end up building an installer that sets it all up for the user by copying the entire LAMP stack and site files to their local machine. 
Good old Reddit - an announcement about the biggest new release of Apache in 6 years and the majority of the comments are arguing about their choice of version number. Talk about a bike-shedding community.
Yes, you're doing it wrong. But then again, everyone else is doing it wrong too. Coding can be pretty personal and subjective. You will never find The One True Way™. If you try to, you'll never get any work done. And if you do happen to stumble upon it, it'll be outdated within a few months. So, just keep coding. The fact that you're thinking about it and asking these questions probably means you're already coding better than half the people out there.
I'm curious as well. We switched to nginx about a year ago on a high-traffic Apache server and have had success with it on other projects. Plus, once you understand it, it's much simpler to configure. 
Keep in mind that "best practices" is somewhat of a moving target. Languages are always evolving, and patterns are always emerging, and then being denounced. So, although it's good to search for best practices, don't get too caught up in the chase. That being said, try doing a project using a modern framework, e.g. Symfony 2. This will immerse you in patterns and practices. That'll probably be the quickest way to get up to speed.
AS long as you keep learning, its nothing to fear. The way I look at it, you're not learning if you cant reflect every year and think, wow I didn't know shit this time last year. And you should always be learning
For best practices in complex situations I mostly address my design pattern books. Wikipedia has a sufficient list of design patterns http://en.wikipedia.org/wiki/Software_design_pattern You can draw a lot of inspiration even for common tasks from design patterns. At least, I do.. Please not that the dp's described on that wiki page are language independent. 
Perhaps it would convince them if you email them some news stories from the lawsuits and chaos that have happened to other companies who chose that path.
Fair enough, I'm not advocating using the user ID, I was just saying why I think 22 hex characters is beyond sufficient (which is what the code snippet uses). I was actually thinking earlier about your last point, that a complex and random salt adds entropy so "the user's password's entropy no longer matters". That made sense at first, until I remembered that the potential hacker should be presumed to also have the salt, so a weak password can still be quickly found with a brute force attack regardless of how complex the salt is. So really the salt has no purpose other than to make rainbow tables sufficiently impractical so that a direct brute force attack is the only viable option. Unless I'm missing something, I don't believe it adds entropy since it is known, and it doesn't make a direct brute force attack any more difficult. The complexity of the user's password is still the weakest link.
Most popular frameworks route all requests to one file and then process the request there. Symfony 2s .htaccess file is a good example https://github.com/symfony/symfony-standard/blob/master/web/.htaccess 
Yes, a salt is not at all designed to protect against direct brute-forcing. Hash-strengthening is the major defence against that, as well as rate-limiting, if the hacker doesn't have direct access to the hashes and salts. Salting is there to stop lookup tables, either direct, or rainbow'ed.
A PHP program gets to see the URL the user used to access it. The trick is making Apache always run one PHP program whatever the URL, and from inside the program doing different things depending on what the URL was. [mod_rewrite is the apache module which does this by rewriting URLs](http://httpd.apache.org/docs/current/mod/mod_rewrite.html)
[Here's a good tutorial about it!](http://davedash.com/2006/07/26/how-to-remove-file-extensions-from-urls/)
If you get enough eyes to look at your code, it will always be wrong.
PHP is a crap language. It's the equivalent of a rectal prolapse design-wise. You *are* writing crap code and will keep doing so for some time. D'ya know what they teach new Eve Online players? Accept the fact that you are already dead and all your possessions are gone. Read other people's code. Read lots of it.
A readme.txt would be nice :)
It doesn't matter. I didn't learn to ride my bike without hands blindfolded, oh wait, yes I did.
That's nice and all, but I thought we all agreed to avoid using SOAP whenever possible, because it's awful? At least use REST, perhaps JSON.
A lot of older systems you might need to interface with will end up running SOAP. Most newer APIs are going to the RESTful way, but anything that's been out for 5 years is most likely using SOAP, and it won't be changed because the bean counters don't care how shitty it is.
Total agreement, but we can always hope and work towards better days. ;)
I use it when I have a script that is working with tight memory constraints and I know that a variable is hogging too much when I'm done working with it. I use it most with MySQL queries that return a lot of rows and when working directly with large binary files.
Only if I am concerned with memory usage, especially in intensive tasks and long running scripts. 
Why use NuSOAP instead of the [built-in PHP SOAP classes](http://www.php.net/manual/en/book.soap.php)? 
In 2012, memory management in PHP is still *terra incognita* for the **vast** majority of *senior* PHP engineers, mostly because the language developers take great strides to shield them from it. Because of this, there is a great and growing gulf of when one absolutely should unset things, which developers routinely do not see or just simply dismiss in their stubborn delusion that **every** (or even most) PHP objects will **always** be both immortal (never being unset) and short-lived (e.g. only survive for a few seconds, max, of a page load. Suffice it to say that various objects, particularly those derived from C extensions (most notably PDO), are not either short-lived nor freed correctly in all instances by the Zend VM. Therefore, it is best to always unset these (esp. PDOStatements) once they are finished, and to get into a better practice of unset()ing **every** temporary variable used inside loops. But these are just two suggestions in a complex field; your best bet is to seek advice from Java and C# developers, who tend to be much more attuned to memory footprint management. Also realize that in the world of FastCGI and a decoupling of PHP from short-lived Apache processes to long-lived FastCGI daemons, that memory management is increasingly a must. Zend Core can only meet us part of the way. It's up to us to unset() properly wherever both practical and feasible, but also especially where it is mandatory.
We have an private API and a public one. I remove properties from objects only on the public API.
Hey man. Thanks for your comment. Please read my "EDIT" that I wrote to this post and tell me what you think. It is my understanding that PHP automatically unsets variables once the script is done running, so it may not be necessary to use unset() for purposes of memory management, but I'm not sure.
I can definitely see how this would be a great usage for unset().
Anyone recommending NuSOAP is a total noob. It's a great way to bring performance WAYYY down, and last time I checked, SOAP by itself adds a LOT more latency than even REST and substantially more than querying a DB. AND NuSOAP **still** doesn't support SOAP v1.2, SSL, or any MS IIS SOAP servers that don't go *out of their way* to be NuSOAP compatible. I remember it being a complete pain in the ass to work with. And the API isn't nearly as clean and concise as PHP's.
When I first started I was so worried that something would just break for no reason. I soon found out that things don't really break for no reason. There's always a reason why it's broken.
unsetting was good programming practice a few years ago. If you're doing a heavy loop intensive app you may want to unset. It depends on what you're doing. If your website is live imagine 1000 people running the same php script at once on your page. Unsetting would free up memory. If it's just you running the script it probably is ok to not spend the effort unsetting.
I use this pretty frequently actually. Long running scripts can be a PITA.
Same here, with very few exceptions. Sometimes there is a huge amount of data that needs processing/sorting in some way and since it's so big, I better unset it after I'm done with it, since some process needs to carry on.
**Disclaimer:** This is a repost from a couple years ago. I'm only posting it because I happened to be migrating my old blog and felt it could help some PDO newbs get their head around it. Feel free to offer suggestions either here or in the comments of the post and I'll incorporate them into the post.
What school are you going to that teaches PHP?
&gt;That's nice and all, but I thought we all agreed to avoid using SOAP whenever possible, because it's awful? At least use REST, or perhaps JSON. I always understood REST to be the method by which the data traveled and not the format of the data itself so that REST data is usually returned as JSON(P), BSON or similar as such that the two concepts aren't incompatible: GET /api/users/krues8dr/posts/42.json Might return: {"time": "1970-01-01 00:00:00"; "content": "That's nice and all..."}
After digging through the new changes I'm quite impressed. This framework borrows ideas from many predecessors and improves on them. It's hard to find systems that implement design patterns correctly and in a way that is efficient.
The thing about PHP is it's faster to let the scope "unset" the variables than it is to manually unset them. IMO unset should only be used to hide a variable, or when it uses a large amount of memory and your going for memory efficiency. http://stackoverflow.com/questions/3425848/calling-unset-in-php-script/3425916#3425916
I wish I could instantly absorb all the knowledge needed to switch frameworks. I'm tired of CakePHP but I don't feel like spending ages learning something new. :c
Exactly. I was going to point out that REST is often used in conjunction with JSON or XML (the former being preferable to me). Generally REST incorporates utilizing native HTTP methods (GET/PUT/POST/DELETE) and then encoding the action you want to perform in the URI of the request (the part after the domain, starting with a slash) which then tells the server which resource you're talking about. The data (or parameters) that a client would use in a RESTful request is then incorporated either into the URI or into POST data (regardless of the method being used, if I recall correctly), which is just a section in the data section of an HTTP request, which is normally ignored when not a POST, like the last line below: POST /api/users/12345 HTTP/1.1 Host: www.mysite.com User-Agent: Mozilla/4.0 Content-Length: 27 Content-Type: application/x-www-form-urlencoded firstname=Joe&amp;lastname=Smith Whereas SOAP is entirely it's own beast. It has (if I recall correctly) it's own complete layer of complexity that doesn't utilize the more fundamental HTTP protocol itself as part if it's own core functionality like REST does. It uses it's own XML format to encapsulate ("envelopes" as they're called, I think) data and more directly represents/exposes services externally in a way more reminescent of a programming language, i.e. "editUser(firstname, lastname)". REST on it's own is a little simpler to digest at a fundamental level and is more of a standard on technique/convention, whereas SOAP is an entire protocol with a lot more internal complexity and more functionality built-in (because of what it is), so that's why I think REST tends to be preferred by people. REST is just easier to understand. Ultimately, I think the choice between SOAP/REST depends more upon the context what you're doing along with preference, since I definitely don't think REST alone entirely replaces SOAP (since again REST doesn't cover quite as much as SOAP). While REST + *(another library in your preferred language)* would instead need to be utilized to expose/consume services that would practically replace SOAP.
A [better approach](http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers) to showing people pdo is to show them how to do the same stuff they do in the old mysql extension in pdo side by side.
SOAP... stab me in the face please. 
Did you set out to design a framework of this magnitude from the ground up, or is this a side project that turned into a full blown deal? Just curious. =] I've considered designing a framework for the fun of it, but I couldn't see it ever progressing to the level you've taken Laravel.
Totally a side-project that turned into a full blown framework. It was just an experiment at first to give me something to tinker with after my wife went to bed. After a few months I had the core laid down and released it thinking that it's very possible nobody will ever use this, and I was totally cool with that. It gained some steam and just kept growing. However, the recent growth and ability to add more advanced features like migrations is due to the fact that I was hired by a company to build their next product on Laravel, and they were gracious enough to give me a few months to work on it full-time and build out some of these bigger features.
Presumably something like intval would count as de-tainting user input. Presumably.
You have any evidence to back up these claims? Is there any evidence that unsetting a variable is any different than simply letting it fall out of scope? If an object from a C extension is not freed correctly by the Zend VM, what evidence exists that `unset`, which is what the Zend VM does, would have any positive effect in that situation? Without such evidence, it seems foolish to believe that unset does anything different than simply letting variables fall out of scope. In the end the results should be exactly the same.
I completely agree. The more tuts the merrier though. I'll definitely add that to the post's "Further Reading" section.
This might possibly be it's own separate discussion, but - scaffolding? I tend to find it handy in cake, and I presume that it's possible to build a 'bundle' to do it, but how many people use it? Am I one of the few that does?
Only after foreach'ing by reference.
Someone already built a bundle for it actually. Check out "bob": http://bundles.laravel.com/bundle/bob
It appears that it is fully-backwards compatible and forward-compatible for the latest snapshots. There are 3 missing tokens from the official PHP page: T_DOUBLE_COLON (synonymous with T_PAAMAYIM_NEKUDOTAYIM) T_ML_COMMENT (PHP 4 Only) T_OLD_FUNCTION (PHP 4 Only) But contains: T_CALLABLE T_INSTEADOF T_OPEN_TAG T_TRAIT T_TRAIT_C So, obviously, it will need to be maintained indefinitely, but looks like it shows promise.
It happens from time to time.
Very nice... I dream of a day I might be able to script/code on a more regular basis but it would appear I'm stuck with storage administration for awhile. It's niche enough to pay the bills, but not really where my heart lies. Thanks for the answer!
I do it religiously. Lately I've been writing a lot of code that is prone to using Massive Amounts Of Memory, so I end up having to be really careful about unset()ing variables when I'm done with them. You're absolutely right, variables are garbage collected once they're out of scope. If you're done using the variable, though, it's definitely better on your memory usage to specifically unset the variable.
[[Here]](http://www.reddit.com/r/PHP/comments/p9dwm/include_and_require_am_i_doing_it_wrong/) is a recent discussion on just that topic. I believe the primary thing to take from it is that the \_once() functions take longer to run. You should use \_once() if for some reason at run time you don't know if a file has already been included, but otherwise use require()/include(). On a somewhat related note; you may also be interested in investigating the joy and wonder of autoloading, if you have not already. With autoloading, your class files are only ever included once and only included on demand. Very nifty. Disclaimer: I'm a hobbyist programmer, take my words as such. =]
Cool, so there was actually much more thought put into it than I put into reviewing the code :) Thanks for the info, sounds like a really cool project!
unset doesn't actually free up the memory, it removes the reference to it, it's up to the PHP runtime to do that, which it does when the script terminates and the process is killed, or the GC cleans up. letting the variable fall out of scope also removes the reference. 
Have you played at all with Lithium, which is from some former CakePHP developers? It's very fast and modern, and built with all the new PHP 5.3 stuff. I've been using it for a lot of projects lately and love it. (Not to detract from utotwel's fine work—looking forward to trying out laravel as well.)
This is really interesting. I briefly worked on Project Zero as an intern (IBM's PHP on the JVM) and though I never touched any of the parsing/lexing stuff but it's something that really interested me. What's your background in languages and can you suggest to me some resources to help with this kind of stuff?
unset is more cpu intensive than you gain from freeing the memory and most of the time that memory would not be freed at that moment, but after the end of the script. That is, if you're writing a web type aplication. If your app is a desktop or server app that runs continuously, you could gain something by freeing manually big arrays ... If you do not believe, try running a loop that generates random arrays, checks memory usage, frees, checks again the memory usage ... There should be no big difference. You can even time it to see how much time you loose by unsetting a complex array ...
so if webPage1.php uses include_once 'functionsPage.php' and the users navigates his way to webPage2.php then I can still call functions from functionsPage.php without including it again?? If webPage1.php uses include_once 'functionsPage.php' and webPage2.php also uses include_once 'functionsPage.php' then it will ignore the include statement because 'functionsPage.php' has already been included? Are these statements correct??
This is the point: long running processes. I was messing around with the freedb data once upon a time. There are literally millions of files. Getting file listing? yea, 100MB easy. You better believe that importing this into a db was a long process, and actually this was one of the best exercises for learning php I've found so far. Opening files, db reads, db writes, loops, text parsing. It's got it all. I recommend anyone learning php attempt it. It was frustrating fun:)
For the love of elephpant don't do nested ternaries!
How do I PM? Do you have Skype or anything?
PM is click on the name and under the karma summary there is a send message, if you want you can email me ( robotmanscioly at gmail.com). It may be a bit easier then trying to explain it via reddit comments
I also had created a very simple framework and added a lot of documentation. But I was not able to make it look so good. This was all I could manage http://moduler.pagodabox.com/ How did you make it look so good. Did any designers help you? And how did you select such a nice name? 
You are mistaken. PHP uses reference counting for garbage collection -- when all references to a variable are gone the engine *immediately* frees the memory (and if it's an object, immediately calls the destructor). [This post](http://www.reddit.com/r/PHP/comments/q11sp/do_you_guys_ever_unset_your_php_variables/c3u1lrt) has some more evidence of that fact. More recent versions of PHP have added a separate cycle detection GC feature (cycles will never be cleaned up with reference counting) but it's not relevant to this conversation. 
You are mistaken about how garbage collection works in PHP. When the reference count of a value reaches zero, the memory is immediately freed by the engine. 
Depending on your platform, file_get_contents() might use mmap to load the file and that would make a speed difference. 
Oh dear. I thank you in name of my employer for this for not letting me do my normal job today. Must fiddle around with this, now.
That's completely dependant on the structure of your code.
Wrong? What do you mean?
&gt; $sth = $dbh-&gt;prepare("SELECT :user, :pass FROM :mytable"); &gt; $sth-&gt;bindParam(':mytable', $table); [You can't bind identifiers,](http://stackoverflow.com/questions/182287/can-php-pdo-statements-accept-the-table-name-as-parameter) only values. Edit: Some drivers might allow this; specifically those database engines that allow the same quote style for identifiers and values, or maybe ansi quotes. But you should *not* ever rely on this always working. 
Coda is not really an IDE. It's a great app, and I bought it, and used it happily (and still do from time to time). But it's just a nice text-editor with some handy SFTP and SSH/Terminal stuff attached (in a really nice way). The other guy suggested PHPStorm, which I've heard is good. I use Netbeans for serious projects with large codebases. When you say "IDE", people expect things like autocompletion, debugger integration, source control integration, etc. One of my favorite Netbeans tricks is to be able to right-click some method-call and have netbeans show me where it's defined. When you write all your own code, that's not so handy, but if you're relying on piles of vendor-provided code, it's a lifesaver.
That's the route I've taken. I've been doing ZF stuff since pre-1.0, and have been generally happy, despite never feeling like I fully "get" Zend_Application entirely. I've also been using Doctrine2 since the betas, and I can't say enough good things about it -- at least for prototypes and basic line-of-business (non-public) apps. 2.2 has brought some great new improvements, and the overall architecture is really smart. I may start evaluating other frameworks to replace ZF. I ran across [laravel](http://laravel.com/) earlier tonight here on reddit, and will probably play with it this weekend. I'd kind of like to replace the front-end of ZF with something else, use Doctrine2 on the back-end, and then use various ZF libs (Filter/Validate/Cache etc) in the middle.
In itself that makes little sense. You could possibly read it out with preg_match if there were unsanitized inputs with the /e flag. You wouldn't bother though, as by then you'd have code execution..
&gt; Even before 5.3, when the new GC code came in, PHP still did gc during runtime. The site I'm speaking of is running on 5.2. When, in the midst of a loop, would PHP 5.2 perform GC? &gt; unset _doesn't_ even always destroy the variable being unset (for example, global variables, static variables, variables passed by reference). As I said, these were all local variables being used within a loop. I also wasn't using unset, I was setting the variables to null. So if what you are saying is true, why then did this simple change eliminate my memory problems? I had it outputting memory usage at the end of each loop, before making the change the value consistently climbed each iteration. After the change the value remained consistent. &gt; Most ORMs will keep references to all hydrated objects, so it can reuse them (hydration is expensive). The ORM in question is my own code, and no, it does not retain references. The only data retained across object instances is the table structure. 
The other players will all handle S3 expire links just fine as well. And FWIW JWPlayer is the other popular commercial player to look at and has far better styling options than Flow, but you can't rely on their support for questions that are too technical (even things about their own player like changing the available source).
yes - for security related tasks - session variables, for example, when logins are required
What is this good for? Just asking honestly.
Having no idea about Sinatra, could you expand on Sinatra-esque? Congrats, BTW!
This is great! I have been working on a very similar project, but with more of a focus on creating an OO grammar-less parser. The idea being you could replace logic when certain tokens are encountered to allow easy prototyping of new language features (with an eye to eventually create my own PHP pre-processor adding more advanced type-hinting, among other things). Hopefully I'll be able to make use of this project, it looks very well thought out.
As time goes on, with large projects, I've tried to reduce usage of static methods considerably. When used carelessly they can make testing a nightmare, or worse actually destroy your ability to properly decouple your classes. My general rule of thumb is that static methods should be deterministic, that is, having no state, any given input will always produce the same result. More often than not when they are present in our codebase they are helpers for constructing, something you'd achieve with a constructor overload in other languages. I don't agree with the fairly common advice that any method that does not touch $this should be made static, especially if you're producing a library for use by other developers - doing so destroys end user's ability to modify your class' behaviour by overriding that method. I hope that makes sense and possibly even helps ;)
Op, to add to his: look at the Wordpress installation if you want an idea of what an easy installer looks like
From the *README*: &gt;You can then work with this syntax tree, for example to statically analyze the code (e.g. to find programming errors or security issues). 
Yes, designers did help. My employer [UserScape](http://userscape.com) graciously paid for the designer to build the site. We are building the next generation of [HelpSpot](http://helpspot.com) using Laravel, so we need Laravel to have a nice, professional site since people will be consulting the Laravel site to learn how to build "bundles" for HelpSpot. About the name, it means absolutely nothing. I gave up trying to come up with meaningful names a long time ago and just decided to pick things that sounded cool. It's much easier.
You could handle any HTTP method. If you need something besides GET, POST, PUT, DELETE, it would look like this: Router::register('PATCH', $uri, $callback); Yes, you can mix and match HTTP methods however you want. About the HEAD requests, no it doesn't properly handle them currently, though I think we could fix it fairly easily.
Sinatra is a Ruby web framework that has a similar syntax for routing in that it uses simple URI registration with inline functions to handle the route.
&gt; Suffice it to say that various objects, particularly those derived from C extensions (most notably PDO), are not either short-lived nor freed correctly in all instances by the Zend VM. This is not true. No object in PHP can span more than one request (I'm of course not include serialization at the end of the request + unserializing on a subsequent request to be the same object). It's *classes* from extensions that span several requests, never objects. Now, it may be the case (I have no idea) that some PDO objects leak memory when destroyed in the shutdown phase (as opposed to when the script is still running). If this is what you mean, then please point to existing bug reports or [submit](https://bugs.php.net/) a new new one so that this can be fixed. Any non-persistent resource (memory, file descriptor, ...) that's not properly cleaned up on request shutdown is a bug.
Very interesting article, but the results are a little misleading until you get to the very last set of tests. When a file is included *only once* in the script, include()/require() are still faster than the *_once() variants. The massive difference in performance of the tests prior is due to the script intentionally including the file multiple times. It seems like a no brainer that the *_once() functions would be faster in this case because the PHP engine is not having to parse the included .php file multiple times. If you are careful in the way you code and you know that you are hitting an include()/require() *only once* for the duration of the script, it's still better to use those instead of *_once(). The difference, however, is likely negligible in all but the most inundated real world applications. At least, that is what I pulled from that article. Nevertheless, a wonderful read, thank you for the link.
I fixed the HEAD problem on develop branch, so it should work according to the HTTP spec now. I like your syntax for cherry-picking HTTP methods like that... I'll try to implement it in the develop branch if I get a chance today! Thanks! *Update* added support for your multi method syntax. 
Apache isn't particularly complex to configure either. But what about memory usage too?
this is still a testing script, thanks for the heads up, I'll need to strip slashes... and other things
It depends how you are doing your loops. If you are doing a for loop then just echo out your control variable (adjusted to start at 1 if necessary). If it is a foreach then declare a variable to equal 0 before each loop and echo out the value incremented inside the loop. $line = 0; foreach($items as $item) { echo ++$line; } Sorry for the lack of formatting. Typing this on my phone. If you post the code in question I can give a more thorough response.
bingo!.... I knew there was a super simple solution... many karmatic points to you
As far as editors go, I use [Notepad++](http://notepad-plus-plus.org/) for Windows, and [TextWrangler](http://www.barebones.com/products/textwrangler/) for OSX. Both are general purpose text editors for programmers. I've used them to write in: Python, C#, HTML, and CSS. Currently trying to learn PHP, too. 
I think class names such as `common`, `utility`, etc. are code smells -- it's as if you're admitting that you don't know where the code belongs. "Common" doesn't even begin to describe what type of class that is, you might as well name it `ldckjhalkfjsflkjhd`. For your given example, that looks like some kind of logging or debugging method; hence, it should probably live in a logging or debugging class.
actually, that is pretty interesting and I'm glad it is actually possible (even if it's a bit clunky ;) Aside: PhpReboot has a little SQL DSL (http://code.google.com/p/phpreboot/) which is a much nicer solution than all these fluent interfaces.
You might also wanna add some sort of system check in the installation script, to ensure that the targeted servers have the necessary extensions and functions to run your blogging engine. I'm thinking extension_loaded('pdo'), function_exists('fsockopen'), that sort of things. It's not a necessity but it's a nice feature to have in my opinion.
&gt; You have any evidence to back up these claims? I think he's confusing memory management with persistent db connections. Apparently memory management is *terra incognita* for him too. Maybe he's one of them senior developers. Is it only intermediate developers that know anything?
I'm definitely looking forward to playing with this - thanks! I'm using CodeIgniter right now to build a project and I'm less than impressed. I particularly like the way you've handled the database and routes. I've got a little personal project that has Laravel written all over it. I'll be sure to provide better feedback once I get started, but I best finish my current project before I get tempted to rewrite 2 months of work using Laravel, lol. 
Oh geez, lol. Touche!
This was a good question to post here -- it seems like many PHP developers are confused on how memory management works in the language. 
I love how clean and expressive the syntax is. My only concern is the use of static classes for everything which are essentially globals. I'm not sure if this would become much of an issue but I'm interested in what other people think. Could it become a source of frustration later down the line? Or is it okay for a framework to integrate itself at the global level?
That doesn't matter once you hash it though, they're both opaque once they're hashed. I won't say what you're doing is wrong, but you don't seem to gain anything from deviating from the normal practice, and risk some unforeseen complication due to PHP's handling of XOR on unicode strings or something.
If you include the file from your bootstrapper, it will available to any class you instantiate from there, so there's no reason to call it more than once. If they're truly separate applications, then there should be no conflict anyway.
Here's the metrics for my personal projects since 2009: http://pastie.org/3439287 You can see that overall, 11.6% of my methods are static. here are my stats for projects that were started since 2011: http://pastie.org/3439405 My use of statics has gone *way* down.
Just throw in [**Thrive**](http://www.phpu.cc/releases/thrive-latest.zip) and do this: require 'thrive/Thrive.php'; Thrive::init(); and you're good to go! The autoloader will find your file either based on the PSR0 naming terminology or will search the CWD of the file that calls it. But it only does this once for each new class. It saves the class-file map in the temp directory of your server. 
That's why in Doctrine you can choose your hydrators and free you query when it's done.
This is actually something I've wrestled with a lot. I come from a .NET background and am very used to having interfaces on every class and using an IoC container heavily. When writing Laravel, I struggled to find a way to have clean syntax while still maintaining good practices. The framework itself has about 600 unit tests (which I know isn't a ton), so we were able to get most classes pretty testable. PHP has so much inherent global state that it's honestly tough to write a framework that doesn't take in some of that global state with it. I'm not sure how to get around it without ending up without really verbose syntax like Symfony's. A lot of the static methods you see could also be short-cuts into the class's constructor, just to make chaining methods easier. I think, as usual, it would be good for developers to make sure to build good abstracts in their own code, such as abstracting database work behind a repository that you can easily stub or inject.
&gt; Before PHP had namespaces people used static methods to emulate namespaces This is still current. Lots of places run early 5.x versions. I.e. you can't use a lot of fancy stuff when writting CMS plugins. :(
Unfortunately this is out of your hands. One of the biggest reasons to not use a shared host unless they have perfectly configured their shell accounts.
maybe mediamosa is useful for You (it is free and based ond Drupal)
See my answer here: http://stackoverflow.com/a/3710674/430062
You can try to chmod to 750. Owner can rwx, group can rx, and other can't do anything. If httpd is the group it may work out.
If it's a university assignment, won't you be turning over the source for grading anyway? Or are you concerned with other students stealing/sabotaging your work?
Here's a better rule of thumb: if you don't know when is a good time to use them, don't use them. It's not simply good enough that you don't *need* an instance to define one, because most people will end up overpacking their classes when they should just be defining functions instead. There are only a handful of cases where it's a *great* idea to use them (especially in PHP) - and as the OP points out, mostly that's in utilities and factories (and singletons).
Yeah. I personally use them for singletons/factories, and that's pretty much it. I can't recall a single time I've ever written a static function myself, unless it was to implement a singleton/factory method on the class.
Static methods and variables are useful in a class context for holding single instances of "things" (objects, data of certain types, etc.), that are pertinent to an ENTIRE class of objects, and not just a single instance of one of those objects. For this reason, Static methods and variables are great for SINGLETONS. class Foo { private static $oSingleton = null; private function __construct(){} public static function GetSingleton() { if (is_null(self::$Singleton)) { self::Singleton = new Foo(); } return self::$Singleton } } I love using a class like this for a global configuration object. in the constructer, you can parse an INI file somewhere with parse_ini_file, setting local variables for all the ini key/value pairs, and then reference the config class singleton for reading the settings from within any class in your script!
I'm only aware of phpclasses.org, however wouldn't recommend it. TIL Javascript Weekly exists- thanks!
I don't know of any email service like those. I have [planet php](https://twitter.com/#!/planetphp) or [phpdeveloper](http://phpdeveloper.org/) in my google reader. They have pretty good community coverage.
I'm signed up with phpclasses.org
I can *highly* recommend [these videos by Uncle Bob](http://www.cleancoders.com/).
Can we has a nice print style for the docs too? I don't need the left nav when printing, and copy/paste into a text editor was tedious :P
Except you normally don't want to state the format in the URI. It really depends on how RESTful you want to be, but the format should be decided through HTTP headers.
I sometimes use unset() in the tearDown() methods of my unit tests.
They charge for it? Is it all original content or is it just links to articles like the ones I mentioned?
Freeing your query won't help if you're using an object hydrator. You need to -&gt;clear() the table, or -&gt;clear() the Doctrine_Connection (which just clears all the instantiated tables and evicts them).
Is the manual wrong, or is there a bug in array_slice()?
It's all original content.
Which really begs the question... why hasn't anyone made a better competitor?
If there isn't anything filling that need, why don't we make one? I'm down. PM me.
So, if you looked at [the non-existence of] naming conventions for functions... Or the fact that directly accessing a returned result only recently became possible... Or that it only just became garbage collected... It still doesn't have default unicode support... There are many reasons to see php as a badly designed language, and I don't think 'having a relaxed syntax' is a particularly major one in the scheme of things.
Very pleasing :)
You just listed the main reasons why I have been looking for a new language... Sadly I always keep coming back to PHP because none have even close to the reach that PHP does. Python comes close, but cPanel seems to have something against supporting it easily - which means a large percentage of possible clients won't want it. I want so badly to have a proper naming convention, hell even just a standard way that parameters are passed into functions would be nice - there are some examples out there that show how bad this is, maybe someone can link them... I want to say implode/explode, but I don't think those are the functions that are closely linked but don't keep the same parameter order. Unicode support would be swell too, I had a hell of a time trying to build a unicode file organizer and just broke down and passed the folder data to python, which passed the data back into PHP... Pain in the ass.
While most of my competitors are trying the latest, greatest language (and relearning how to do every damn thing for the umpteenth time), I'm shipping code and making profits. I actually prefer it this way.
&gt; Why does everyone say PHP is not well designed? Because it's not. Really. &gt; "PHP is not well designed because it has a relaxed syntax" and the like. This is a straw man -- there's nothing more relaxed about PHP's syntax than many other better designed languages. &gt; All the top CMS systems use PHP. Facebook uses PHP. Almost the whole internet uses PHP. That doesn't make PHP good, that merely makes PHP *good enough*. I code in PHP every day, but clearly the sun is setting. It was the king of a previous era and software has a long lifespan. Facebook only continues to use PHP because they've already invested too much into it and when they can do really new development they use other platforms. &gt; I'm not saying that because everyone uses it, that makes it a good server-side language but it has to count for something. Does it? If "used everywhere" is a good metric then Java and C++ are the best programming languages ever created. \**shudder*\* &gt; Hundreds of people update it and everyone can see it's source code. Most language implementations are open source -- but that isn't the point -- when people say that PHP is not well designed they're not (just) talking about the underlying implementation but rather the language syntax, semantics, and API. 
This is so good.
Every language at one point was missing the features which you have come to adore. But that's beside the point. My reason for posting this is to raise awareness that r/programming is unfairly biased against **the most popular web programming language**. I only wish that any post submitted to r/programming have a fair chance at seeing the light of day or even the frontpage before it's downvoted. I'm not here to compare languages and that's not what r/programming or any other programming subreddit is about.
Then what are they talking about. You have shot down my points but did not give any reasons under any of them.
I've been developing web applications for the past 15 years, with PHP as my primary language for the past seven. I've lived and breathed PHP every working day. Let's ignore the syntax for a moment. Go take a look at the [default strings extension](http://php.net/strings). Scroll through the list. Without looking at the descriptions of the functions, can you tell what more than half of those do? No? I don't blame you. Some of these functions have horrible names because of PHP's origin as little more than a templating language that could call functions defined by wrappers around *someone else's C libraries*. Ever wonder why `mysql_real_escape_string` is called that? It's not because PHP's core devs are idiots, it's because the MySQL C library exposed a function with that name. Okay, I take that back, PHP's core devs *have been* idiots. For a very long time, a small group of people on php-internals shot down feature after feature that would improve the quality of life for developers. You know the new short array syntax introduced in 5.4? With the brackets? The same way almost every other scripting language on the face of the planet does it? Yeah. Shot down for *years* because php-internals thought it would "confuse" people. Bullshit. 5.4 is the first version where features were decided by community consensus through an actual process instead of by half-democratic half-autocratic decree. Things might get better over time, but I'm not counting on it. Oh, and because backwards compatibility is the holy grail, those wacky function names can't realistically be improved. We can strike that off the list of things that the RFC process will fix. PHP's syntax is occasionally quirky, the standard library is *insane*, spastic and disorganized, and the people in charge of the language have been irresponsible. PHP is an *objectively awful* language. If you're using PHP every day and and you *don't* hate it, then I suggest you go learn a few other languages so you can understand what's wrong. When you combine the horribleness of PHP with the gentle learning curve for newbies, then throw in over a decade of *horrible* tutorials that are still plastered all over the internets, it's entirely realistic to understand why PHP is considered a toy language for people that don't understand what they're doing. Despite all this, PHP is still my go-to language for web applications. It's a horrible, no-good, awful language... but it does the job well enough, and I've become so used to the nasty warts that they only bother me when I think about them.
They should revamp with BuddyPress ;)
If you require it twice in the same thread, it fatals. Numbskull. 
I wouldn't discount value that could be derived from reading through the articles, though. Annoying, yes, but not useless.
My thoughts exactly
What's your point? Just because everyones uses doesn't mean it's good, with that reasoning to it's extreme we would all be doing assembler still.
Well, if you're up for it I could create one for you.
r/programming has one of the better communities of **programmers** I've seen on the internet. Languages to programmers are different than to **coders** in that they are an implementation detail and not a skill. As such, if you are exposed to many languages there are many well documented annoyances in PHP that you pick up on. Is this elitest? Maybe. I think it's elitest to only use one lanugage and call others elitest master programmers because they really do know more than you (not necessarily targeted at you but at others who make this argument from time to time) I respect someone who has programmed in some stronger typed languages and maybe a LISP derivitive who chooses and implements decent PHP for a project. I have nothing but contempt for PHP ~~programmers~~ coders that blindly use PHP because it's all they know. Especially the really silly people that try and write networking daemons and such in it. Learning languages isn't that big a deal. I can't stress this enough. You'll become a **programmer** that happens to use PHP by doing so. And seeing critisicm of PHP wont affect you as much because you know they are valid and how to mitigate them when PHP is the right tool for the job or when to use something else.
Former PHP programmer, moved to a C++/C# job by way of redundancy. I've never been happier, now I *get it*, I know WHY /r/programming is so anti-PHP, it's a dirty language, it does what it needs to do, but in a really bad way.
Agreed. There is absolutely nothing unfair about the bias against PHP. Someone else said "go learn another language and you'll see what's so wrong with PHP".
Thanks; I'm inclined to agree that it's a suitable trade-off for more readable code. Could you expand on what you mean by "A lot of the static methods you see could also be short-cuts into the class's constructor" please. If the applications code is calling static constructors, as opposed to using 'new' then the dependency still remains - or have I misunderstood?
Fopen can be used to read the file line by line with fgets, which is useful for iterating through line formatted data files or csvs. File_get_contents just dumps the whole file as a string. Another neat thing about it is you can give it a URL and it can act like a ghetto CURL call. 
PHP is a very popular language. /r/programming is a bit of a "hipster" subreddit, they tend to only love obscure, rarely used stuff (Haskell) and hate anything that is popular (PHP, Java) PHP just gets more shit than the others because it's a horrible language.
looks nifty! i'll have to experiment with using variables in mysql
I've also been looking for one. Paypal Payments Pro seems to be the best option, quite expensive though.
For digital subscriptions, I've heard good things about a script called "Digital Access Pass". 
I use rot13 to encrypt all the credit cards on my site. Are you implying there is a better way?
yby!
I agree with your entire synopsis. I've been using PHP for 12 years now, and that's a perfect summary of the situation regarding the growth of the language. (Everything's a $GLOBAL? What were they thinking?) However, this is only half of the reason PHP gets a bad wrap. The other half is **PHP developers themselves**. (I know, I know. Please don't get out the pitchforks yet.) The PHP developer crowd, far and above any other language I've ever used, is populated by mostly *self-taught tinkerers*, rather than *experienced developers*. Now, there is absolutely nothing wrong with this, per se - I too started as a self-taught tinkerer! The problem arises in the **hubris** of the community that **insists on writing everything from scratch**. Take a look at the majority of questions in this community - the average PHP developer doesn't even know what an ORM is. As a hiring manager, I'm absolutely *dismayed* at the total lack of knowledge of available tools. Only in PHP (in my humble experience) is it a thing of *pride* to write your own, shoddy, un-[test](http://en.wikipedia.org/wiki/Unit_testing)ed software package and then brag about it - to "hand craft" every line of code, rather than using old, established, durable packages. PHP, unlike it's brethren Ruby, Python, and Java, is *only* used for the web, so it's base is generally only populated by web developers, who, historically, have *not* been software engineers. Knowledge of design patterns and good development techniques is a rather new thing in our world. And *that*, my friends, **is why the rest of the development community laughs at us**. Because they've seen our code, and know it for what it is - *Beginner's Cruft*, not *Craft*. . Now, how do we fix this? Here are a few ideas I've been thinking about: 1) Whenever anyone asks a question about PHP (in this community or otherwise), answer what they ask (e.g. "This is how you escape characters to prevent SQL Injection..."), but always steer them back to the Good path ("... but you really should be using an ORM like [Doctrine](http://www.doctrine-project.org/) or [Propel](http://www.propelorm.org/) to do this for you."). Explain the benefits of the Good. Personally, I try to do this on **every reply** in this community. 2) Use, support, and promote Open Source packages. There's no reason anyone should even *think* about writing their own bulletin board or blog software at this point - we've got over *ten years* worth of them. If you're even considering it, open source it from the start and get other devs on board before you even code a *single line*. 3) In your own code, use *modern techniques* whenever possible. I expect to see everyone's unit tests by the end of the day. Comment and document your code. Learn about [code smell](http://en.wikipedia.org/wiki/Code_smell) and how to both detect and resolve it! 4) Here's the big one - **Programming needs to be taught as an apprenticeship**. *Especially* PHP. We got where we are because they don't really teach PHP in most formal settings - it's been a lot of trial and error by people who "just want to put up a website." We need to have more hands-on *guided* learning for developers to *teach them* to look for better tools, rather than a new hack. . Ok. End Rant. It's up to **us** to make this better. **We're only going to do that by cowboy-ing up and becoming real developers, not just tinkerers.**
Last note: I really think we, as an international development community, need to found a guild, to encourage strong skills and to guide learning. Does that sound crazy?
I can't say I hate PHP, since my personal website has been made using PHP from top to bottom. There are, though, some concepts in which PHP is a bit behind. For instance, I personally found it very difficult to code inheritance and polymorphism, even coming from a Java background (in which the syntax is very similar). I am happy to use PHP for web applications that don't really require the application of object-oriented programming principles (4 pillars, SOLID). For a well-designed (objectively) web application I would rather use Java Web than PHP.
I think the problem of PHP is not the language - it's a fine approach for if you don't care about type safety and such, but the mess of the API delivered with it. I could put up an example, that the MFC C++ library has an awful API too - but that doesn't harm C++ at all because you're not forced to use it when you want to use C++. PHP has all those weird function names and such in the global namespace, so you have to mess with it if you want to provide a better implementation.
Dunno why you are being downvoted. The post is clear, clean (not blogspam) and provides a good introduction to PHP.
I see r/programming, r/compsci, and similar subreddits as places for the theorists. The people who enjoy talking about theory of programming. r/php, r/java, etc... are for the workmen. People who are using a specific language for whatever reason and are actively trying to solve problems they're facing. So the reason php gets shunned by the first type of subreddits is because it doesn't fit into their abstracted view of what language should be. However, it's *widely* used. I'm sure much to their dismay. It's an easy-to-learn language b/c it doesn't paint you in the corner having to learn more complex programming topics (like OOP), and that's part of its appeal. It has an easy-to-use reference site (as opposed to Java's reference documentation which sucks, but still better than other languages that simply lack a consumable reference doc) and the errors you get are written in English (again, as opposed to a Java stack trace which is fucking ridiculous... my eyes bleed every time I see one). Reference documentation and error output aside, just because a language is easy to use doesn't mean it's a *good* language. It doesn't force people to use good practices. PHP has a very low entry point and shallow learning curve. That means people who aren't "learned" can use it to start solving real world problems, which is great, but then those same people go into r/programming and have opinions. This creates a stigma. As hard as that may be to hear, it's true. The learned simply aren't going to respect you for using PHP because they've seen time and time again the type of work and opinions that come out of people who use that language. Instead of worrying about how PHP is viewed by those subreddits, view PHP as what it is: a tool. In the real world, there's a use case for just about any tool. It may not be the sexiest tool (what's the sexiest language right now? Is it still Haskell? I haven't been keeping up), but it's still a good one to have in your toolbox. 
First I thought even though it gives a good head r/php is not an audience for it. But then I thought maybe it will help someone who just happened to be non-programming redditor see what this php is anyway. So an upvote from me for creative work.
.. and static variables are globals, wrapped in namespace ( that looks like a class ).
NO, it does not depend on anything. If you are using static function or variables, you are just writing procedural code and pretending that it is OOP. It is not OOP. You are creating globals state.
Like the rest of Reddit, /r/programming is subject to fads. PHP has been the most popular web development language quite some time, so the current fad is to hate on it. Just like /r/technology hates on Apple. There's plenty of valid criticisms to make on both accounts (PHP and Apple), but the attitude on display in those subreddits has very little to do with actual faults or flaws and is mostly driven by the fact that kids think they can demonstrate how smart and informed they are by ripping on PHP. PHP has flaws, but so do Ruby, JavaScript, Python, Perl and every other language ever created. Languages are just tools, they are not a substitute for a personality. People should use whatever language is going to help them accomplish the task at hand. No other criteria means anything.
Not at all; I've been thinking along these lines for a couple of years now. Such a guild would also help the technical community have a more cohesive political voice, which could be a useful counter to, say, the RIAA, MPAA, CRIA, whoever whoever.
It seems that in the corporate culture, or rather the corporate way of thinking, there are two kinds of developers that turn up to work. Those developers that develop solutions for other developers (disregard API development) and those developers that creates solutions for the users who have actual problems to be solved. Developers that develop for other developers seem to spend a massive amount of their time pondering toolsets; best practices; design patterns; chasing after the perfect development stack; or at the very worst, detrimentally thinking about what other developers (outside of their organizations) are doing. As such they dabble, in what appears to be, a more theoretical approach to problem solving. It appears as all theory because their existing code can be thrown out as soon as the next best thing (in their own opinions) starts to show an upward trend. That is why they are easily in awe over the newest technologies. To the point where they would use the wrong tool to solve a problem that does not align with an actual set of requirements set out by their users. It is not my point to say that thinking about your approaches, tool set or stack is a bad thing; but we [developers] should be mindful; and at the very least; respectful that time spent distracted by other things moves us further away from our ultimate goals of providing solutions. I would suggest that it is in own our best interests to know a variety of approaches and then through experience select the approach that best solves the problems at hand. This leads into developers that develop for the user and to solve the actual problems given to them by these users. They [the developers] provide code that answers a given set of requirements (even if these requirements are vague and tend to change dramatically over time) and also deliver to their clients a polished product that is on time and within budget. Ultimately the user does not care about the underlying approaches, they care that their concerns are being provided for, in an experience that is 1) performant 2) easy to use, and 3) open for extension based on their future needs. That being said, having a dogmatic impression of a single language (that may or may not) solve your problem does not change the fact that a problem needs to be solved. It is a wasteful enterprise to change the minds of people whose minds are already made up. All you can do is better yourself, extend your toolkit, and gain the foresight needed to be the best developer you can be, with all the tools at your disposal. Elitist or otherwise this is all anecdotal and based on my own observations, but at the end of the day, you will need to ask yourself: are you under the employ of your various organizations to impress upon a community of developers you may never work with or is it your intention to provide to your users, solutions that best solve the problems that are presented to you?
It's funny because people who stress framework and ORMs use in PHP are the less talented programmers I've seen in the field in 10 years, along with those who stick to custom old code (mysql_connect(), ...). Good PHP programmers use them when it's needed only because **PHP is a flexible language**. Trying to be rigid about it make you hate it. Anyway, when the next "bad" language will come to existence, PHP will be found very nice like PERL was when PHP arrived.
why would you do &gt;$is_admin = ($user['permissions'] == 'admin' ? true : false); instead of &gt;$is_admin = ($user['permissions'] == 'admin');
I just added print styles for the docs. 
Currently working as a C++ zealot, yes. I get to spend my working hours reminding people that their choice of tools does not determine the quality of their output. It's astounding how often people spend days working up some fancy algorithm that turns out to be no better than bubble sort*. Makes me wonder if they're really qualified to criticize the PHP script kiddie who used a one line call to sort() which uses a native implementation of quicksort behind the scenes. * true story - Since the author of the code had already been promoted to architect we could never get it fixed. I left that shop years ago so I can't be sure, but if you live in the US, that code may still be active in a hospital near you. 
&gt;So I have no idea why programmers from more restrictive languages do not like PHP. Maybe jealousy :/ Mostly because if you have to pick up a project in php by someone else that hasn't been written in a sane manner, it will make you rage. Instead of blaming individuals, people in this position tend to blame the entire community *as well as the language*.
Nope, it's a hypertext preprocessor (I actually forgot this was where it's name comes from until after picking this to describe it) AKA template language, evidenced by the fact all code is embedded within template tags, lest it be assumed to be hypertext. If it were a programming language you'd write applications in it, things which stay resident and may or may not respond to web requests. Such behavior is nonsense for a template language (and for PHP), you just collect your data, spit out markup then die to start over again from scratch on the next request. Concurrency? Just handle more requests. Any persistent state must be maintained elsewhere (often through heinous misuse of a relational database, though that's become so common as to be the typical use case).
bookmarked! thanks
why?
There's an edit button next to reply! This looks pretty awesome though. It's annoying having to install the whole of XAMPP just to run PHP through netbeans.
Fortunately it hasn't been updated in a year.
Really ? I don't see it in the doc http://www.doctrine-project.org/projects/orm/1.2/docs/manual/improving-performance/en#free-objects But usually I use array hydrators.
Don't see why this is downvoted, re:ORMs
I guess all I see, and all I've ever seen, is values and methods. Whether they're grouped together or not, and how they're grouped never really seemed to make anything harder, you just then get *the option* of taking advantage of things like inheritance and polymorphism. To me it's like saying that eating cereal with a spoon is too hard, just use your hands. They're not significantly different except that one has the benefit of possibly keeping your hands clean.
There's a mark of maturity where you realize, "I *could* write this myself, but I have better things to do and I trust this foreign code to work correctly" Read a LOT of code. Review code. Talk to people about their code, and your code. Start to write code that you would trust someone else to have written. (So that you can reuse it) Learn formal algorithms for search, and arrangment of data. Learn about arrays, linked lists, sets, trees, and heaps. Learn about databases and how they work. (so that you can use them better) Ask questions. Listen to the answers given to questions you didn't even think to ask. And when you're done, answer some too.
God no.
Weak typing is NEVER a good thing.
PDO?
1) You need to be escaping *all* passed values, I see a lot of naked GET variables being sent straight to the DB. Better yet, use PDO, as suggested elsewhere in this thread. Even better, use an ORM, like [Doctrine](doctrine-project.org) or [Propel](http://www.propelorm.org/). 2) Don't mix your business and presentation logic - consider using templates for the latter, rather than sticking everything between header and footer includes. 3.) You need to have unit tests. Seriously. Start using Test Driven Design *now* and your life will be far better in the long run. 4) You'd avoid 1, 2 and a lot of 3 (and gain a million other benefits) if you used a framework instead of writing everything by hand. Check out [Symfony](http://www.symfony-project.org/), [Zend](http://framework.zend.com/), [Cake](http://cakephp.org/), or [Code Igniter](http://codeigniter.com/). 
[PDO!](http://php.net/manual/en/book.pdo.php) Prepared statements will keep you out of a lot of trouble.
I'm a professional programmer and I never use require or include because I know I should never trust the code I wrote in the past or will write in the future and don't want to cause errors. So I go exclusively with include_once()
How would I learn more using a framework when everything would be abstracted away? I would have never known anything about PDO or anything else you guys pointed out if I had been using a framework, no? Now I know!
The point here is that you don't *need* to know about that - it's not relevant to the job at hand. Do you need to know how your car works to drive it? Do you write your IDE/text editor before you start coding? Of course not! That'd be silly. So it is to reinvent the wheel for low-level code like this. If you want to be a better programmer, use better tools. Don't fall into the mistake of thinking you need to write everything yourself, that's *beginner's hubris*. 
Friend, let me put it to you this way. I'm you, 15 years from now. And I'm suggesting as best I can that you're absolutely wasting your time noodling around writing REAMS of bad code. Go read some good code, and learn how things are done well. Learn a couple of nice frameworks, how to work within them for a few months, and you'll gain a HEAP of good knowledge. You'll learn faster, and you'll feel very accomplished. And then you'll be giving this very same talk to someone else. ;) 
Awesome! Thanks!
you are correct that I am updating new error message UPDATE 'request' ('qunty') SET ('31') WHERE origin='M001V' &amp;&amp; dest='M001A' &amp;&amp; part_num='000889115577' UPDATE 'request' SET qunty = 31 WHERE origin..... You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ''request' ('qunty') SET ('31') WHERE origin='M001V' &amp;&amp; dest='M001A' &amp;&amp; part_num=' at line 1 the one that worked.... UPDATE request SET qunty = 31 WHERE origin..... fucking ticks, have some gold, I'll be deleteing this thread
easy, create a file named test.php and insert the code &lt;?php function test() { echo 'test'; } ?&gt;. Now, from another file try this: &lt;?php include('test.php'); include('test.php'); test(); ?&gt; See the results, then edit the other file to this &lt;?php include_once('test.php'); include_once('test.php'); test(); ?&gt;
Like I said, back ticks on table and field names, single quotes for values. This would have also worked: UPDATE `request` SET `qunty`= '31' WHERE origin='M001V' AND dest='M001A' AND part_num='000889115577' 
Why dont the close the ) at end of the conditional?
You can use libcURL to fetch the page they would log in into and display it, as if it was your work's page when its really yours.
Just leave the back ticks off. They are not needed and cause a lot of confusion with the single quotes that are required.
No reason to change.
Thank you for introducing me to propel! I've spent a few hours getting to know it today and I LOVE IT! I've been going about things entirely the wrong way. You've just convinced me that I would profit from some formal training in php. 
You can write applications in it.
It's safe to assume that those downvoting you have a poor understanding of English.
**eat** puppies
I like the idea but sometimes I feel like developer folk are such prima donnas about things like theory and idealism that nothing would get done. You'd need a prime directive like "always be productive" or "don't be a dick" or you'll get into flamewars about what the flagship language and editor should be. Thanks for volunteering, though.
Change your readme file from .txt to markdown and format it. The readme file is the first thing I look at on your github page. If you plan on me finding your web app via github, make it enticing. As @krues8dr said, use PDO, you may also want to try mysqli, either is better than mysql_* which is going to be deprecated in the next release of PHP. I'd highly suggest moving towards mvc - though you do have nice clean code. I think it's great that you took the time not to use a framework. Often times you don't need an entire framework, just as you have pointed out with your simple blog application. I think you have a great starting point for teaching yourself. You could now look into creating or importing an existing router, a form handler, or even decide to build a caching layer in on top of your posts(memcached or redis are too good options). If you want to move to a framework, I'd stay away from a full stack framwork. I agree 100% with you, how do I learn about this stuff if it is abstracted away. I'd rather hire somebody who knows mysql and have them learn dql(the query language the doctrine uses), than hire somebody who's only worked with doctrine and teach them sql. I'd suggest reading [The MicroPHP Manifest](http://funkatron.com/posts/the-microphp-manifesto.html) It might change the way you look at web apps it also has a list of mediocre libs. 
Why do you think "trying the latest, greatest language" is tied to "relearning how to do every damn thing for the umpteenth time"? And what is bad about relearning? What if you learned a suboptimal way the first time?
This is for very large quantities of 2.
Pretty sure the original thinking was something along the lines of "why not?"
but then again... how the fuck does this bug happen? whitespaces matter? how? the fuck?
That wasn't really a rant, it's a most valid point. I was self-taught, was going through source code of every popular CMS/BB out there. My first great discovery was the power of frameworks. Second was Doctrine, third was Drupal (and its awesome community, which is the very reason I love my job, which is more of a hobby to me).
Maybe someone more familiar with what you're describing can answer you better, but I'd need to see a little actual code to help.
It'd be a lot more readable if you put the code on a site like pastebin or codepad. Also, try not to put all your code on one line, that also makes it more readable even for you so that you can keep track of any potential errors. That being said, check the server settings to make sure PHP can actually send mail. That's most likely your issue. EDIT: It looks like you either fixed the formatting or reddit wasn't displaying it correctly when I originally viewed it. Much better.
That's probably the issue then. Some free hosts don't allow SMTP. If you want to test code that sends mail for free I'd just set up a local webhost and configure something like PEAR mail to send the emails through gmail. Maybe there's an alternative someone else can mention here?
Something like [[this]](http://pastebin.com/Zy9QGeFp)? That should work if I understood your question properly, albeit with a much smaller data set. This should give you the array, I assume you can work out how to dump the array into the format you need. EDIT: I unnecessarily stored the integers in $postID as strings, but you get the idea.
Correct. It was never meant to replace actual web server software in production.
What would you suggest as a decent example of this? I'm at a development job now but am looking at changing to a PHP company (hopefully) and don't know too many good examples of public PHP code.
Good news, idiots!
Rewriting your own code on the side is fine, rewriting production code "just because," can often cause issues...
so we can create the next Node.js in PHP.
i think this is a good one and i follow it. http://framework.zend.com/manual/en/coding-standard.coding-style.html
I'd probably suggest 'micro' frameworks first - mostly because they're likely to be simpler examples of code. Note - I'm actually mostly disdainful of microframeworks, but that doesn't mean they can't be a good learning tool like any other framework. Google'd: * http://www.slimframework.com/ * http://www.limonade-php.net/ * http://micromvc.com/ * http://gluephp.com/ Note, these are all written by other human beings, in their own style, and every human being is different; so they'll probably all have different things to teach you. A good site for lots of different 'micro' stuff - http://microphp.org/code.html I'd probably look at [symfony](http://symfony.com/) first out of the big frameworks, since it seems to be modular to a fault. That means it might be easier to digest code in pieces. Other than that, there's CakePHP (my current favourite), FuelPHP, Yii, Zend. One way to know you'd be learning would be, after a while, to be able to look at some particular piece of code in x framework, and think "Hey, they probably could have done it better by using this pattern that I found before..."
it's probably written in php... :P
They use re2c, so they do use a generator.
I have never used a framework before, but I thought I'd use one for a project. I eventually decided upon [Laravel](http://laravel.com/) and haven't been more satisfied with it. Of course, there probably are 'better' frameworks out there, but Laravel made it easy to integrate it with your project/product. 
I've used CodeIgniter for the past two years. It's easy to learn, fast, and robust. 98% of the things that I use are built in CI and if you need to build something custom it's really easy to integrate into the CI framework. 
I just finished a pseudo e-commerce site (it was just unique enough that nothing off the shelf would work) in code igniter and while it works great and it is fast, it still feels a bit clunky. When I was trying to decide which tools to use for the project I stumbled on Laravel but decided against using it as I didn't have time to learn a new framework. Now that I am done though I have given Laravel a try on a few small projects and I love it. Version 3 was just released this last Wednesday and the already good documentation was revampedand made even better so it's a great time to give it a shot.
PHP was *originally* an acronym for Personal Home Page (tools), hypertext preprocessor is a backronym. It indeed started as a template language, but since then it has certainly progressed. You certainly can write persistent applications in PHP either using sockets or using it from the command line etc (there is actually an ncurses lib for php). PHP under linux can also deal with concurrency, IPC, and multithreaded processing / fork()ing, though I definitely can't vouch for that under windows. Be careful with your misinformation.
I'm not sure if programmer vs coder is the right distinction/vocabulary to use here, because personally I consider them very nearly interchangeable. I think you'd be wanting to compare programmer/coder vs software developer/engineer/architect. I agree with most of your other points, but just the vocabulary throws me here. 
PHP uses a Yacc based parser and an re2c based lexer. This is only one of those small lexing quirks common to so many languages. E.g. writing 5.toString() in JS will not work, due to lexing limitations.
TwitLonger.com
CI really excels at updating old crap to an MVC architecture. Doesn't force you into a strict layout like Cake, you can port it over at your own pace. Not sure about new projects though, haven't had the chance to do that.
I use Slim (micro) framework + a couple of own libraries like ORM (based on Kohana's ORM, you could use Propel/Doctrine), Views (Slim has basic views as well) and Oauth. IMHO like this, I get all the tidiness and structuring of using an MVC framework, but I still have extreme control over how pages are built and which modules/libraries are loaded.
Wow thanks for all of the info, I know what I'll be doing today :D
Really good example for how you shouldn't do it.
Architecture faults, static methods overusage, hardly testable business logic, strongly coupled components, not-invented-here syndrom. This list is very long. Of course there are some pretty interesting and bright ideas behind this projects. Most of them allow you to create a project in matter of hours and that's pretty cool. But as for me - overall architecture quality is poor. Just a single example of Symfony2 awesomeness: Imagine you need to make a CLI tool in PHP. No website included. You can just take a symfony console component. Due to well thought out architecture and components decoupling. For exampe [Composer](http://packagist.org) project makes use of it, just check it out. This helps to increase code reuse and forget NIH-syndrome. P.S. I'm just some guy from the interwebs. Don't trust me. Check all the things yourself.
I'm curious, what did you find clunky about Cake?
When, in time, you know what the pitfalls of using straight md5 are, and what all the advantages of PDO are (and the myriad of other things you need to know to make an 'industry-standard-"good"' application), then you'll have the clout to be able to judge whether you need to be reinventing wheels or not.
I'm not the OP but my main problem with Cake (1.3) is how opinionated it is. Deviating from their conventions is extremely difficult, and can even result in hard to find errors. For example, if you name your model file "Event.php" and not "event.php", you'll never find out that it's not being loaded. Why? Because Cake will automagically load your models even without a file, and then their automagic "findBy*" methods will work, as long as it maps to a db column. This shoots way too many newbies in the foot for my taste. In addition, because of all this magic it is extremely heavy for every request (just do a &lt;?debug($this)?&gt; in both your controller and your view and you can see just how much stuff is being carried around at each level. Again, this is awesome if you want everything to "just work", but at a certain point it starts to feel - like the OP said - clunky. Lastly, I love the fact they have a shell and support custom tasks but executing PHP from the command line is pretty grim. Granted, this is less of a CakePHP thing and more of a "I'm so happy I got my job to switch to Django" thing, but sometimes you get on a roll and you just can't stop. :)
[Lithium](http://lithify.me/) over here for being comfortable to hack around. I wouldn't recommend it to beginners though.
first of all escape the $_post content + check if it's set before u do anything 2nd why not with a db?
What do you mean by clunky?
&gt; Architecture faults, static methods overusage, hardly testable business logic, strongly coupled components, not-invented-here syndrom. This list is very long. That's a little too general when somebody asks you to explain. Your generalizations on one hand and the praise on the other really comes of as strange. And from the number of frameworks you listed there is no way you worked on all of them for as long as it takes to form such a strong opinion. &gt; Just a single example of Symfony2 awesomeness ... CLI tool in PHP ... The example you are using would be the same in Yii. To me it is really not that clear cut. Right now there are Symfony, Zend and Yii (my main FW right now) about even. There is no reason to switch between these 3 (I read about the others and try them out now and then). They have their flaws and advantages. And I think that's a healthy competition.
Well, it wouldn't be *that* hard to put something together--especially if there are a few editors and contributors behind it. The biggest challenges I see: * PHP is mature. Many tools exist and niches are filled. Radical or novel things don't happen as frequently or they're not deemed as noteworthy (as compared to, say, something like node.js). * At the same time, PHP is ubiquitous (if somewhat derided) and that popularity means that when new/interesting things do happen it's too mainstream and unsexy for techno-hipsters to care. That said, I think there's an opportunity here. What I am going to do is spend the next two weeks gathering links and see how much effort is required to actually produce something that's worth a shit. If anyone has advice or wants to help me out or join in, let me know.
If the guy's not using a MySQL database then he can't use mysql_real_escape_string, as that requires an active connection to a database. I think just doing htmlentities is enough to prevent raw code from getting added to a file
You *really* shouldn't use a counter here at all, you just should get *every* line while there's still data, like so: while ( false !== ($line = fgets($fileRID)) ) { $linesoftext[] = $line; Or better yet just use file_get_contents().
Anybody who ignores the performance implications of using a framework should also "never work in this town again."
I like your attitude and I'd like to know your opinion about Laravel framework found few days ago here on Reddit ( http://laravel.com/ ).
The counter number is fine. There is still an eleventh iteration of the loop regardless of starting the counter at 0. Here is the code I use for output: echo "&lt;b&gt;" . $counter . "&lt;/b&gt;: " $lineoftext; ... which yields: 1: one 2: two 3: three ... 10: ten 11: (nothing appears here) Where the lines of the text in the file I am reading are the words 'one' on the first line, 'two' on the second, 'three' on the third, etc. Also, no code on the new line. Just hit the enter key, space space space space and started typing the code in by hand.
on the flip side there are a lot of experienced and intermediate programmers who would flock to such a resource especially if a lot of topics were covered. I know I would. As it stands right now i look at r/php, r/webdev, net-tuts, smashing magazine, ALA and a ton of other generic sites for the occasional php article. if i could get a good php site that puts together all of these things and more i would go there all of time. it is a lot of effort but i would join. you would have to cover tons of frameworks (i could have a crack at zend), ORM, php itself etc. etc. etc. i have a mediatemple DV 4 server i use for work projects i have full control over so I would have no problem setting a side a site for a starting point.
choose the one that solves most of your problems.
I have not yet looked up the php.net page on file_get_contents(), but I will soon. Thank you for the example on how to store all the lines in an array without using the counter.
also, thank you for your input :)
&gt; That's a little too general when somebody asks you to explain. Right. I find it nearly impossible to write even a half-year programming experience in one comment - that's why it's so general. &gt; The example you are using would be the same in Yii. Are you sure you can write a console application with Yii *without vendoring all the framework*? As addition I'll just tell you a story. My team (8 middle-senior PHP programmers) used to develop projects with Yii for about 1 year before I came here. So they are like deep into Yii and so on. So I've analyzed things and we decided to switch to SF2 for a couple of new project, just to see how is it going. Guys were just interested in new framework experience. So now 3 guys say Yii sucked, 4 say it has some benefits, 1 stayed a Yii fan.
 function login (User $user) { $_SESSION['user_id'] = $user-&gt;getId(); } function logout () { unset($_SESSION['user_id']); }
I just don't think a quick overview will create an objective opinion in my head. The first thought was "wow. so many static methods. is this ok?"
Do you have session_start() at the beginning of each page you are calling User::checkSession() on? This is a pretty common mistake. Use pastebin and post the user class as well as one of the pages you call your class methods.
http://www.agavi.org Don't thank me. 
I use [Fuel](http://www.fuelphp.com/) and I love it. Decent docs, configuration over convention, it's easy to extend and overload default logic, etc. Just an all-around amazing framework.
It's just as stupid to use a framework just because it's all the rage these days, or even to always use CI because it has the longest bars according to some website. Understand the application and its users before diving in to code. It costs a lot more to refactor than it does to research, plan, and architect.
Smart Client - start with the end first. The GUI. Isomorphic's Smart Client guarantees multi-browser functionality. Sold. Corporate America doesn't hang out here on Reddit.com. This is the swamp. Nobody here can give you advice. 
You can probably just use the following to clear the session: $_SESSION = array(); session_destroy(); Also I think you're supposed to put an exit; or die(); after a header redirect. The header() is just nicely asking the browser to redirect at the end of the script. If the browser or attacker decides to not follow the redirect then the code that follows will still execute. So if you went checkUserLoggedIn() and they weren't logged in and tried to redirect, but the attacker stopped the redirect then all your admin pages would be vulnerable.
Don't create your own formats for things. Use an already established encoding for this. If you're writing many "records" to a text file use [CSV](http://php.net/manual/en/function.fputcsv.php), or a similar encoding format. Better still step up your game a little and use [sqlite](http://php.net/sqlite) or [PDO](http://php.net/pdo).
Never use javascript as your sole means of validation. It's ok to do in javascript just to save the user the time it takes to post the request, but you should always be validating server side.
This is all irrelevant, and it's obvious you didn't take the time to read what he was saying. Even if he was using a database, I couldn't in any good faith suggest your code as a good solution. It is horrible.
file_get_contents() reads everything in the file into a string. Not quite what I'm looking for (not yet, anyway). Reading about it did lead me to file(). file() reads every line of a file into an array. For now, I think I will use file() so that I can easily do some formatting for the output of each line. The file_get_contents() method would at very least require a delimiter at the end of each line in the file in order for me to parse the file output to a page (the file will organize one short message, sender name, and e-mail to a single line). I will eventually write a method for erasing the last line and appending a new line to the file as a way of limiting the number of records stored in the text file. Thanks again!
Noted. Looks like I've got my homework to do :) I don't suppose you can answer my original question about why I get an eleventh iteration of the loop on a 10-line file? I'm sorry I don't have a URI to share; I'm doing this on a Ubuntu VM.
OK. No where did I talk about **regular variables**, now did I? I talked about **C-extension objects, such as PDO; and other temporary variables inside loops**. Do tests around those.
With FastCGI, the PHP daemon handles multiple requests in the same instance. That's just a fact.
Semantics.
Granted he was being a bit snarky, but he has a pretty damn good point. Session hijacking should be accounted for, as well as session fixation and similar.
No where I did talk about **regular variables** either. The word *regular* doesn't even appear in my reply but *C extension* does. You didn't answer my questions.
Scumbag redditor: mocks someone for not having a clue, uses Bing.
I agree with you, but I think this would be a huge barrier of entry for anyone who were to take on the project. The PHP community isn't exactly known for its kind critiquing, every decision the developer(s) make would be scrutinized and flogged. No matter what techniques they use, someone will have a problem with it. 
Ill say it again here. If somebody does this, ill help however i can.
So brave
Why would it matter is the site's code was open or not? You are there to be part of a community not to know how the site works.
I think the members should be learning from the content provided on the site not from the site's code. my2cents
This cover pretty much everything... http://docs.moodle.org/22/en/Installing_MSSQL_for_PHP
I like the idea of Github and Bitbucket being tied right in. Teaches a bit of version control and lets others fork and contribute. 
(If you are on a shared hosting account.)
Sorry, it wasn't meant that way. The "you" is a general "a random person". If the site has good content, there's nothing to worry about with individuality. Reddit's source is open, but it's the content that makes people come here instead of some random knockoff. As for security holes, hiding the source code is just security through obscurity. Having many eyes looking through the code helps to get it secured before some script kiddy finds a hole.
BEST
So, I've gone and done some research. I wanna make sure I have the principals of what's wrong with my code sample. 1. Make sure that session.use_only_cookies and that session.cookie_httponly are set to true. This should prevent session fixation. 2. Check the IP of the requesting with the known ip of that session(same with user agent) 3. After login regenerate session id 
I concur. The idea of a packager is way, way beyond the scope of what you want to bite off at first. Package management of any kind is an incredibly complex topic, plus there are several efforts under way already to replace PEAR with something better (Pear2 or whatever they are calling it and another called Composer, I think?) I'd stay away from that bullet point.
As will I. UI/UX and front-end is my specialty. I would love to be a part of a project like this. ( http://www.hollowdepth.com is my portfolio site. )
The [official way of destroying sessions](http://se2.php.net/manual/en/function.session-destroy.php):
No worries, it's just a flag. :) I agree about openness. Security through obscurity is also a valid model. Don't get me wrong, I'm a huge proponent of open source projects. I was only trying to say that the site owners/developers might have valid concerns. Keeping a site up costs, one way or another and they might be expecting some small kind of financial return, and it is possible that they have a model for that revenue which they don't want open. 
You have a classic problem here with session hijacking. All I need to do is get hold of the session cookie used, and then this code will say I'm logged in. What you want to do is to check if the session matched the authenticated login. Usually, that's done by saving the ip address and user agent on login, and for every session check you see if the current ip and agent matches the saved ones. Then even if I manage to get someone's login cookie and session, my ip and user agent won't match. This is also a good time to check if the login has timed out, by storing a timeout value and comparing it to the current time. That's as basic as you can get with login security. Of course, there are more parts going into security overall. I suggest you also search for how to best store hashed passwords. Of course, all this is pretty easily defeated if your communication with the server is unencrypted.
These are all good, necessary steps. [Stack Overflow](http://stackoverflow.com/search?tab=votes&amp;q=php%20login) has some good Q&amp;As about this topic.
There are a couple of alternatives. But they languish in obscurity, simply because of size. Phpclasses is hard to kill off beause its too old and big, noob coders still upload shit over there, and its impossible to compete with the mlemos forum spamming commitment. If you want to create an alternative (thought about it too), then you obviously need to get rid of the subscribe-or-fuck-off mantra (not even OAuth or OpenID), but also invest lots of time in building up a sizable repository yourself. More importantly it's not a good idea to start with featuritis. A simple github + google code link list might be a better start.
CodeIgniter [has a page](http://codeigniter.com/user_guide/overview/at_a_glance.html) on this subject. What part exactly are you having trouble understanding?
Sorry, but I could not possibly disagree more. As I [keep^1](http://www.reddit.com/r/PHP/comments/q3dbw/rprogramming_bias/c3uizuz) [arguing^2](http://www.reddit.com/r/PHP/comments/q4jg2/bitty_blog_my_first_php_application_can_i_get/c3unwo4) around here, that's backwards - and a cargo cult mentality exclusive to the PHP community. It also doesn't answer OP's question at all. You should learn what good code looks like first, then use that as a foundation to learn more. Trying to learn **everything all at once** is really a good way to teach yourself lots of **bad habits**, there's just **too much to know** (as they say, more than enough rope to hang yourself). Starting with a framework lets you focus on the important parts and ignore the low-level stuff until you're ready for it. **OP**: CodeIgniter is a small footprint framework that gives you an MVC and a couple of other niceties. Personally, I find it very clunky after years of working with [Symfony](http://symfonyproject.org), but if you're on a shared hosting environment (no shell access) it might be the right choice for you.
&gt; Agavi's minimum requirement is PHP version 5.2.0 or newer. DOM, Reflection and SPL extensions are required, but these are always enabled by default unless you're using **one of these weird Linux distributions made by "smart" people who think they know better**. I'm sorry, but this for me is good indicator of a very unprofessional team. I don't want to rely on people like that when writing commercial applications. Just keep in mind, I could be totally wrong. This could be a really good framework. It's just my first impression and I'm going to leave it at that. Maybe this changes in the future.
I agree with not building in a new package manager, but maybe tying in to an existing system would be a good idea. For example, as a developer submitting my project, I might be presented with the ability to enter data such as my PEAR/Composer channel and package name as well as a download location for a tarball or SCM repository.
I'm with you here all the way. The basic, raw PHP, and most of the tutorials showing how to use it, bypass all the important security features and techniques you *have to* know about *right from the start*. It is like learning JS without jQuery - sure you can do it, but what is the point of leaning the hard way about making JS work cross-browser? If you cannot learn from the simple statement, "you will do it *horribly* wrong if you *start* at a really low level", then I guess you are just going to do your own thing and not really learn anyway.
http://trac.agavi.org/ticket/1008 Edit: this is what the Bitxtender people allude to, but not exactly the problem. Agavi does use a wide range of PHP facilities. DOM is used for configuration parsing (XML is compiled into a PHP code cache) and form population filter uses it too. Reflection is used to analyze exceptions in the "shiny" debug template, not sure if anywhere else. I've met Bitxtender people and have been to their offices (in fact, I wrote most of Agavi's documentation) - they are *extremely* clued and pragmatic. Agavi is a conservative framework. And yes, what the distributions do to default packaging rules is borderline stupid. [This is what an Agavi application can look like](http://www.mtv.de/home) 
&gt; Personally, I find it very clunky after years of working with Symfony, Is kohana any better?
phpclasses needs to go. php community deserves something better. a site like that wouldn't have existed in ruby/python, they would have acted fast to create a better alternative.
If I can find a good designer I would do it. PM me if you are interested. For the website itself, others mentionned a lot of interesting things, but I think we agree it should be fully integrated with Github/bitbucket/Google Code. I agree on the no packaging, too big of a project itself. The website should focus on providing good code, and make it easy to find it and download it. I like the idea of replicating SO reputation system, I like it and its a great way to promote participation. Gonna dig a bit in Github API to see what is exposed. 
I agree abut server side validating. This is for a class and server side validating was last weeks assignment. Thanks!
I think having a such site open source would be a great thing, especially when trying to grow and kill a beast (phpclasses), you'd also get a bit of a base for things to share when you're sharing yourself - So to speak.
Ah crap. Fixed.
&gt; I never heard the expression "vendoring all the framework." I also can't find anything on the web. "Vendoring" doesn't seem to be a word to be honest. Sorry for using non-existent term. By "vendoring" I mean putting some third-party code into your project like [this](http://www.yiiframework.com/doc/guide/1.1/en/extension.integration) So please let me explain my example once again. Imagine you need to create a PHP console application. As a Yii user you know about it's [CConsoleCommand](http://code.google.com/p/yii/source/browse/tags/1.1.10/framework/console/CConsoleCommand.php) class and its handy methods like "copyFiles" "ensureDirectory", "prompt" etc. But as CConsoleCommand extends CComponent it relies on "system.base" package and that's why you will need to include ("vendor") it in your application. But the worst part is that [YiiBase](http://code.google.com/p/yii/source/browse/tags/1.1.10/framework/YiiBase.php) class from "system" package relies on other Yii components and standard directory structure. So that's why you will need to put all the Yii framework in your console application with all stuff like HTTP requests, DB classes etc. You will need to bootstrap Yii with its autoloader and defining its constants. Just to use some handy methods for reading user input. On the other hand [Symfony2 Console Component](http://symfony.com/doc/2.0/components/console.html) can be used as a stand-alone solution. It doesn't rely on any base package. There is simply no "base package" in this framework - its a set of decoupled components. Symfony2 routing doesn't suite your needs at all? Go on and replace it with your own component - it's really easy. You can even [create your framework with your own conventions and components on the top of Symfony2 components](http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1) Maybe there's some another awesome decoupled PHP framework I'm not aware of, but it's not Yii. Hope you got my point of view. 
Agreed. If you're on Windows, use the Microsoft sqlsrv/PDO driver. The Microsoft driver does not work on Linux.
&gt;I do think it's a good idea to learn a Framework first, personally CodeIgniter is a better choice as Symfony is such a task to set up and having to mess around with commands early on isn't ideal. I agree with your sentiment, I just think that CI doesn't put things together in a logical way, and that could hurt someone if that's the first thing they learn. That's just my opinion, though. But 100% agreement on the fact that Symfony forces you to do too much low-level work up front.
if you're worried about session hijacking you should be using SSL. 
I have had these problems in the past and I was able to overcome them both in PHP 5.2 and PHP 5.3. Find below a series of steps that should help you on your way: * Editing the php.ini file to enable the correct extensions. If memory serves correctly PHP 5.2 ships with its own extension php_mssql.dll; which I believe worked with MSSQL 2005. For me to connect to MSSQL 2008 with PHP 5.3 I had to download the extension provided by Microsoft. Which can be found here [http://www.microsoft.com/download/en/details.aspx?displaylang=en&amp;id=20098](http://www.microsoft.com/download/en/details.aspx?displaylang=en&amp;id=20098). With these drivers you will have to install the extension that works with your version of PHP, e.g. PHP 5.2 thread safe versus PHP 5.3 non-thread safe, etc. Note that in some cases you will have to do some trial and error to get certain things to work. You will know if the extension works if you view your phpinfo(); and see a section called sqlsrv or mssql. * Setting up SQLServer itself to either accept authentication through Windows Authentication, SQL Server Authentication, or both. The option you select will determine how you connect through your code. On the one hand, you can just simply provide the connection strings with a server name and database name and alternatively with SQL Server authentication you will need a server, username, password, and database. [http://kbase.gfi.com/showarticle.asp?id=KBID002804](http://kbase.gfi.com/showarticle.asp?id=KBID002804) * This is Apache specific but it was one landmine that took me forever to figure out. If you are running Apache as a service, and are going to use Windows Authentication to connect to your SQL Server instance, an Administrator user must be able to connect on PHP's behalf (through Apache) to complete the authentication process. This site has instructions for Windows XP but it is pretty much the same for all Windows operating systems. [http://blog.lysender.com/2009/07/run-apache-as-local-user-windows-xp/](http://blog.lysender.com/2009/07/run-apache-as-local-user-windows-xp/) * Alternatively if you are using IIS then the current ApplicationPool of the PHP website should be ran as a user whose credentials have access to the SQL Server. Or you might be able to get away with editing the site's Basic Settings and "Connecting As" a user who can connect to the SQL Server. * One recommendation / tip when you actually run SQL commands from within your PHP code. Use SQL Management Studio to generate your queries and then copy and paste them into your PHP code. SQL Server likes to either fully qualify its tables or enclose them in square brackets. Also be mindful that escape characters in SQL Server are slightly different than those in MYSQL. And of course using the **php_mssql** versus the **sqlsrv** extensions will give you a different set of functions to run your code against. Here are the websites that might be used as a reference if you are unsure about how to do certain things. [Installation of extensions on Windows](http://php.net/manual/en/install.windows.extensions.php) [Microsoft Drivers for PHP for SQL Server](http://www.microsoft.com/download/en/details.aspx?displaylang=en&amp;id=20098) [How do I configure SQL Server 2005/2008 to accept SQL Authentication?](http://kbase.gfi.com/showarticle.asp?id=KBID002804) [How to: Create a SQL Server Login](http://msdn.microsoft.com/en-us/library/aa337562.aspx) [Run Apache as Local User – Windows XP](http://blog.lysender.com/2009/07/run-apache-as-local-user-windows-xp/) And here is a project that I threw together that will help with understanding the differences between using php_mssql and sqlsrv. [https://github.com/Romayne/MSSQL-Server-Connector](https://github.com/Romayne/MSSQL-Server-Connector) 
&gt; The PHP community isn't exactly known for its kind critiquing There're always going to be haters, but I think anybody looking to improve the state of code sharing among PHP users would only benefit from doing open source right from the get-go. Self-hosting, for a project like this, should create a positive feedback loop.
Unfortunately that violates a whole host of best practice guidelines rendering most alternative frameworks much more preferable. Therefore anyone thinking about adopting this should really look elsewhere.
Could you please elaborate on the best practice guidelines that you mentioned?
Exactly, that's why I added the last bit about encryption.
The classes must implement the [PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md) standard. [Composer](http://packagist.org/about-composer) is already taking advantage of the standard and is going to change PHP development. Build your website around its momentum. Packagist.org gives me an easy way to add code to my project but is missing reviews, code snippets, and a better search/filter system. 
They should write the site in python, for irony. The features you described sound very cool, man. I'd totally become a member.
PSR-0 (or any namespacing requirement at all) limits the site to only supporting PHP 5.3 and later. There's still a LOT of developers out there on 5.2, and I'd wager the majority of public code isn't namespaced, for this very reason.
This is my number 1 irk with my interns. I'm all for mentoring and teaching opportunities, but when an intern runs headfirst into a problem, stops for a second, and proclaims that it *just stopped working randomly*, that'll set me on edge instantly.
Not related to the article, but the website itself... I'm a little confused about your use of _ in your fancy titles: $phpPost-&gt;_title(" PHP Interview With Chris Hartjes The Grumpy Programmer Of The PHP Community – Learn By following PHP Developers On Twitter "); $phpBlog-&gt;_title(" 7PHP dot COM "); $phpPost-&gt;_comments(" 5 reactions catched - throw another? "); $phpPost-&gt;_date(" February 19th, 2012 "); || $phpPost-&gt;_author(" Khayrattee Wasseem "); $phpPost-&gt;_category(" Expert PHP Advice "); An underscore preceding a method or property name is usually an indicator of it being protected/private - as in you cannot access it directly outside of `$this`. Am I missing something or are you simply a coder without a cause?
You could pretty much copy his code exactly and change it to PHPisms instead of Python and it'd work. What are you trying to change, exactly?
I appreciate you taking the time to reply and I see your point. What are your thoughts on globals are they relate to $_POST, $_GET, $_SESSION, $_FILES, etc? Personally I believe that these global variables are one of the strengths associated with PHP in that regardless of scope, they are accessible from anywhere inside an application. Static methods allow for encapsulation of functions, and once again another strength of PHP is that even if a method, inside a class called Foo, is declared as "public static function bar() { }". A developer can choose to new up a Foo instance $foo = new Foo; $foo-&gt;bar();, or simply go with Foo::bar(); You also highlight "pages" as globalizing variables and logic, and global inclusion of view segments. The Internet is built on pages, however frameworks needlessly strive to replace pages with single entry-point applications, where a "page" is buried within a controller or rather a controller's view actions. Where for the most part a page is a compilation (for lack of a better word) of a view's main layout and rendering the view's body somewhere within that layout. From my example, this is achieved by using normal php pages; instead of using the front controller pattern. It was my intention to provide images, CSS, and simple markup that could be ported into other projects. It was not my intention to say that someone has to use it as is (I did however provide samples if they needed to use it as is). As such that is why there is only a single model, containing a single method. Linear code has its place and full object orientation has its place. If I had used an established framework, naturally I would have organized the files accordingly. Single quoted strings versus double quoted strings versus strings concatenation is a form of code religion. Each organization has its own code styles to follow. I would concede that it was unfortunate that I echoed HTML from within a method, but when used sparingly there's no real cause for alarm. Could you provide links to the best practice guidelines you use in your own projects?
After the large number of discussions about rolling your own ORM (or not using one at all!) around here lately, I'm very glad to see this article. Excellent work, and great job covering the key arguments.
This may be a line in the sand moment, where you focus on quality vs quantity. This isn't saying namespaced code is *better* quality, but that might be a defining quality of all code in this newly-proposed repository. If you know you want code that has been namespaced for easier integration, this would be the place for it. Yes, there's a lot of people not using 5.3. And there were a lot of people using php4 for a long time, even when 5.0 and 5.1 were out. How much do you want to cater to people who can't/won't upgrade? Anything earlier than 5.3 is not even officially supported by the php group anymore. There are reasons to not upgrade, but explicitly not upgrading doesn't need to be encouraged by new projects.
sqlmap is a free utility. doesn't test everything, but can be an eye-opening experience if you've never seen a sql injection attack in motion before.
I don't have much experience using an ORM, but this gives me a great starting point! Thanks for the link!
Right now i'm wondering is there are any really large sites which are currenlty using doctrine2 as the basis for all their ORM
Wow, you sure are an ass.
We don't have 'large' sites as in millions of hits, but we have produces very very complex sites using it. Doctrine 2.1 is SLOW but powerful
Could you expand a bit on "clunky" ?
Static functions promulgate global state and all of the problems associated with it (unpredictability, difficulty in reasoning, etc.). If you want to use classes, force them to be instanced and use private mutable state (private $x) rather than global mutable state (global $x). I would imagine that *you* are probably effective in keeping this kind of approach fairly clean and maintainable, very few php developers have that much discipline or foresight. If you want to take a vaguely procedural approach, I would recommend you make it fairly function-oriented. If you want discrete pages, rather than an FC, Have an entry point on each page, Include views within a display($view, array $vars) function Seperate out controller logic into helper functions *on a page* ...and so on If you know C take the standard best practice approach to main functions: int main(int argc, char **argv) { Project *p = ProjectNew("MyProject", "someData"); ProjectCalcStats(p, 1, precision); ProjectSave(p); ProjectInfo(p); ProjectClose(p); } That is, write as many functions as needed to fully represent the logic of the page in a discretized, encapsualted fashion. Consider a page to be a *composition* of sets of logical operations, rather than a single operation or rather than having a single intent. For a PHP page? I dont know: fn main() { $form = getFilteredInput(); usersHydrate($form); if(usersCreateRecord($form)) { display('Success.phtml');(); } else { display ... } I dont have formalized guidelines (to hand, I did once write an extensive program design document for a MNC client). I have spent many years learning the best practices within other languages and have developed an intuition. Things which probably express my opinions: CLR via C#, Code Complete, The GoF Book, Any lectures on Zend 2, Real World Haskell, Effective Java, Effective Ruby, etc. For structuring programs in the manner i described above the Stanford lecture series Programming Paradigms spends sometime on adv. C. Detailed analysis of the (dis)advantages of Scala, and of OOP from a functional point-of-view, would be a good place to start to understand the problems of mutable state (esp. global). 
Don't know any yet, but YouPorn is relaunching on Symfony2, and my guess is they are going to use Doctrine, since Symfony provides a pretty good integration with it.
&gt;but if you're an experienced developer Ah, and there you've hit the critical point. When you *become* an experienced developer, that's when you're ready to be messing with the difficult problems. If you're new to the language, that stuff will only slow you down, and again, you'll *teach yourself bad habits*. You shouldn't have to know all the underlying pieces, just as you shouldn't have to know how an internal combustion engine functions to be able to drive a car. Knowing that you put gas into it and it drives is *more* than enough to get you where you need to go. At least, as you correctly point out, until it breaks down on the side of the road and you're late for a presentation. ;)
According to the developers, Doctrine2 is three times faster than Doctrine1. Don't know about Propel though. http://groups.google.com/group/doctrine-user/browse_thread/thread/2d7fda769953f747/72c9ed64777292ae
Well, we're running a couple of Federal websites on a Symfony/Doctrine stack if that helps. ;)
The internal code is complex, because handling ORM in itself is a complex task. If an exception comes from the bowels of a library, it's always frightening to dive into it, the same goes for bugs, they happen in every library that has not matured a few years yet. Doctrine1 was much simpler, because it used active record, where Doctrine2 is much easier to extend, and much less intrusive on your code. I think these are valid points, but they are more related to using 3rd party code in general, than Doctrine itself. 
Hey, hey, crazy guy! Hehehe...
Here's what I would recommend, with regard to my own interests as a PHP developer with about a decade working in the language. Take from it what you will. You ask a lot of "my, but you're impressive!" type questions of your interviewees. You have clearly established that they're impressive in your introduction, so don't waste your time on these things. Questions like, &gt;It is said that you attend more conferences in a year than most people get to go to in a lifetime. Is really not the sort of thing a programmer cares about reading. Along with my previous point on books - we all know that by the time a book goes to print, it's completely outdated in the programming world. Old news. These are the sorts of questions you ask of a celebrity if you don't know anything about their work. Compare "Good Morning America" to "Inside the Actors Studio" on their interviews of movie stars. I want to know them as a *peer*, not as a person I should worship. "Fans" of PHP will not navel-gaze in hero-worship. We don't care who these people are, or how many followers they have on twitter - we *only* care about what they *do* and - most importantly - **how they do it**. . You have to stick to the meat of the conversation, the stuff that we would actually care about! That's why I mentioned tips, tricks, techniques, opinions on the current state of affairs! That's the stuff we want to know, those are the questions we ask of our peers every time we go out for a beer or have a lunch! "Hey, what do you think of the NoSQL solutions these days?" "What ORM are you using, why'd you pick it?" "Doesn't Code Igniter just make you craaaaazy?" [Aside: As a programmer, I devotedly believe in the tenet that **all information wants to be free**. I don't believe in "trade secrets", I share all of my techniques earnestly and gladly with my peers at every available opportunity. Here's [my rarely-updated blog](http://krues8dr.com/), where I give away all of my secrets.] Moreover, the format that you're using is shallow - if you're just emailing questions to a person, there's no discussion, no back-and-forth. That's where the *meat* is. Surely if you can get them to sit down and answer *so many* questions, you can convince them to do a Skype chat for an hour that you can record and transpose for us! And *that* would be great. Or get a *panel* of several interviewees and get *them* talking about this stuff! Even *better*! . I apologize, but I had to make the assumption that you're a dyed-in-the-wool PHP programmer who's been doing this for a long time. You *should* know the right questions to ask, because we're all asking them all the time. If you *don't* actually know the right questions (and no offense intended if this is the case), you should consider opening up a thread to get questions from the community here - you'll see this a *lot* around reddit in the AMAs. (Or have someone lead the panel (from your selection of candidates to interview, perhaps), and let *them* ask the informed questions!) . And this brings me to my last point, regarding the "spamming". Your comment history indicates you've only just started to show up on this site and only are using it to market your website posts. We frown on that here, this is a *community*, not a link-farm. You should get involved in the technical discussions around this subreddit before throwing up "random" (to us) links - to get a read on the temperature and standards of the community if nothing else. Perhaps you have done this under an alternate account, but that doesn't help your case to us any, I'm afraid.
I'm using Agavi for an embedded software product and recently tried Kohana for another project. I like them both.
Yo dawg, I herd u liek PHP, so I wrote a PHP parser that can parse PHP so you can run PHP inside PHP!
I think Doctrine sacrificed a lot of simplicity be deferring things. DI, cache, lazy loading are all examples of deferring what you want to do and when you intend to do it. $user-&gt;save(); was pretty simple to understand :) easy to dive into and easy to follow round Doctrine 1, easy to put a break point on. 
I recommend following *those that develop PHP itself*, [such as I list here](http://www.reddit.com/r/PHP/comments/j1cjc/php_resource_sites/c28oeuz). Otherwise you end up with [smarm like this](http://www.reddit.com/r/PHP/comments/q6zx7/chris_hartjes_php_interview_learn_by_following/c3veyzy).
Turn them off one-by-one and see what dies?
[Definitely](http://www.d-e-f-i-n-i-t-e-l-y.com/)
uhm.... just... no
I think they keep a more complete source at Github and precompile it to a single rb.php. I know it works, because I just have one and use it in my dissertation.
Dam, chrome spell checker got the best of me again. Have an upvote.
It's not just a question of performance -- it's more than probable that this code could be replaced by a single SQL query -- that's just much easier to develop than some complex multi-array solution. SQL is designed for exactly this purpose. 
I hate to break it to you, but that's probably going to be your only real option.
If I have to do a monotonous, boring task, I write a program to do it for me. Otherwise, what's the point of being a programmer?
Agreed, I should point out that on average that loop only goes through about 4 iterations and each iteration returns in the region of 20,000 results... (depending on the keyword it can return at most 250,000 results).
You could create two new tables 'Permissions' and 'Role_Permissions'. Permissions would contain the description of the permissions along with its id. Role_Permissions would be a many to many and would contain role_ids and permission_ids. Since you'll be dealing with numbers at this point you'll need some way to keep it all in order. One way you could do this is use a namespaced constant. namespace Permissions; const Posts_Edit = 12; // ... later on use Permissions; if (in_array(Post_Edit, $permsList) { ... or namespace Permissions\Posts const Edit = 12; // ... later on use Permissions; if (in_array(Posts\Edit, $permsList) { ... If you don't want to mess with namespaces or are not able to. You could use some small classes with constants defined inside of each class PostPermissions { const Edit = 12; } // ... later on if (in_array(PostPermissions::Edit, $permsList) { ... 
I did everything I could to try and empty/clear/destroy the session and nothing was working UNTIL I called **session_regenerate_id()** before **session_destroy();** Now my logout() method works as expected
Depending on what you're trying to do, database engines also have built-in features for this kind of thing. For example, the full text search indexes will order keyword searches by relevance.
The source is more structured, but the production version is a single file. Thank you for pointing that out!
The point of being a programmer is also to maximize your time; if you tool everything that can be tooled, you'll not have time to actually put the tools to use. The complexities of what you're asking for are non-trivial. I'm thinking you'll need to either have to write your _own_ extension (so that you can try to hook into the Zend engine), or maybe you could write/use a [userland PHP parser](http://www.reddit.com/r/PHP/comments/q11sn/a_php_parser_written_in_php/) to generate some AST and then do magic to determine which extensions were called and which weren't. Other than that, I'm not sure how else to go about it -- a massive regex to comb the code looking for tell-tale function calls, such as `/[\W]mysql_(\w+)\s?\(/`....but that makes me queasy just thinking about it, and good luck should someone use a namespace to overload that function... Of course, there might be _an easier way_.....and I admit that I don't know what that would be.
This scares me, but frameworks which try to overly simplify coding tend to do that..
I don't really understand the advantage to that, disk i/o is negligible especially if you're using something like APC.
I had my own problems with the full text searching in MySQL -- I ended up rolling my own index solution for one project. Next time, though, I'm just going to pump it out to [Sphinx](http://sphinxsearch.com/).
Disk i/o at big scale is a huge problem but as you said, not if you're using APC properly. So not sure of the advantage in the minifying here. 
Something like this? public function genPassword($length, $charset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz@#_*^") { $password = ""; do { $password .= substr($charset, mt_rand(0, strlen($charset)-1), 1) } while (strlen($password) &lt; $length); return $password; } Not quite sure what you attempted to do here, though: &gt; foreach ($cons as $con) if (similar_text($pwd,$con)==0) $weak = true; similar_text returns the number of *matching* characters.
Use a debugger/profiler and look for any function call that you don't recognise, and look it up in the PHP manual?
Yea, sorry. I should really have annotated this. This was a minified version for production and I just took out all the nice bits that make it readable. All that monstrous line does is to append a single character from a random constituent set until the $pwd is at the length required. Roughly the same code: while (strlen($pwd) &lt; $len) { $constituent_set = $cons[rand(0,sizeof($cons)-1); $pwd .= substr($constituent_set,rand(0,strlen($constituent_set)-1),1); }
That line checks to ensure that each constituent set has been met by at least one character in the proposed password. If the result of similar_text() is 0 then it means that absolutely no characters from that constituent set are included anywhere in the password and the strength is compromised. $weak is set to true, flagging for a regeneration of a new password. This all happens until the password contains at least one character from each constituent set ($cons), ensuring difficulty is adhered to. How does your example ensure that difficulty is met? I feel like I'm being thick and missing something really obvious. Thanks for the comment.
While you try to be ironic, it seems you really are not aware how the site works. Maybe you only accessed the site a long time ago and you are probably not aware that the site evolved a lot over time and many things are not as you suppose. Let me clarify that further so people stop making up excuses to demonize the site. - When you submit a package you have the option to tell whether you want to track the package users or not with 3 options. The package properties page says: Keep track of the users that download or view the package files 1. Yes, except for files marked to not require the user to be logged 2. Yes, always require the user to be logged to access any package files 3. No, except if the user is already logged Furthermore, on the contribute page, there are more extensive explanations on how to make a package require the user to be logged or not to download or view a package. See the point Recommendations, 3. Making (some) of your package files available without login (or not). - RSS feeds for package changes exist since 2006. http://www.phpclasses.org/blog/post/57-RSS-20-feeds-for-latest-package-changes.html Some users use them, most other users don't. RSS is fine for power users, but for the vast majority of the users e-mail is still a more efficient way to remind them when a package is updated. Furthermore, to subscribe an RSS feed, users have to do it manually for every package they have downloaded. The package change email notifications are sent to all users that have downloaded a package (unless they do not want the notifications at all). The users do not have to go and tell the site one by one which packages they want to be notified about. The site keeps track of what packages they downloaded and notifies them when those packages are updated. This certainly assures more engagement from the users with the work shared by the authors. - The site always tells the users how to choose which of the many types of alerts and newsletters messages even before the users register. Many users want to get those messages at least until they figure they are useful or not. If they figure the messages are not useful or too frequent, the site always provides instructions to unsubscribe from all content newsletters at once, even from e-mail, so you do not even have to login to unsubscribe all at once. The site certainly does not want to send alerts or newsletters to users that do not want them. It is a free service that costs money to provide. It would be silly if the site insisted on sending messages to users that do not want them. - The site certainly does not support temporary e-mail addresses because those systems behind them do not bounce messages once the addresses become unavailable. This means that the site would keep wasting CPU and bandwidth sending newsletters to those e-mail addresses forever if those addresses were accepted. - The authors that submit packages to the PHPClasses done it voluntarily. If you want those packages, you should ask them. If they think it is fine, they will give you their packages for you to distribute them wherever. It is their work, it is their decision. It is not like the PHPClasses submitters do not know GitHub, PEAR, SourceForge, Google Code, etc.. The fact is that they still use PHPClasses to provide them greater exposure. Just an example, since Git import support was added, a great part of the new submissions are from authors them import them from GitHub. Some authors even share links in the packages for those that want to get them directly from GitHub. So if they distribute their packages in the PHPClasses, it is because it is good for them. Maybe if you ever contributed to PHPClasses you would know that already.
Oh, I see. You want at least one character of each character set. 
Bingo-bango, yo. I was thinking maybe there was some sort of permutation functions like in Python but I can't seem to find anything like that for PHP. Hence the lack of comments and non-retarded nesting.
continous integration negates that
I was actually going to suggest PHPMD/PHP Depend/etc. family of CI support scripts, though I don't have the hands-on experience with them to know much else... Either way, I'd be curious to hear what you end up with.
How do you pronounce the name of the site?
You've become much better at writing your rebuttals. But how about just posting it over at your stellar site, or being more honest about it? Site defaults are site defaults, reasoning (user benefits) and actual intention (newsletters and ads) notwithstanding. Mind you, I've uploaded a bit of crap on phpclasses. And by appropriate (and also inappropriate) licencing, I already gave permission for redistribution (not that anyone would). You going around and claiming otherwise is kinda irrelevant.
What the hell is "a minified version for production"? This is php right?
Okay, so code - teek. I was trying to pronounce it something like code - etiquette.
Have you looked at how Github does this?
I am not quite following you. Are you saying what I have told you is not explicitly informed in the site? Maybe the information was not all made explicit in 1999 but the time passed and all was improved because to be clearer because it only benefits the site and its users to be clear and explicit. I can understand you were not aware that things changed and improved over time, but it not knowing about progress is a bad excuse for campaigning against the site as if it was a bad thing that got stuck in the last time you accessed it. Anyway, I think the greatest problem is communication. Usually written communication is not very good to pass credibility and trust. In the case of a global site, it is hard for users to communicate in person and see with their own eyes that whoever developed the sites is not evil as you want to believe. This site was created to address needs of authors like me and you. It is just silly to assume that I have an evil plan to abuse from users just because you do not fully understand the reasoning behind certain decisions. That is why I am here giving my face and clarify whatever are the misunderstandings.
That's interesting, how would someone go about spoofing the cookie? Wouldn't the server realize that two users are using the same cookie? And is the cookie string the only piece of info used by PHP, it doesn't check for the right IP?
It means that this entire thing is going through an obfuscator before the customer gets it and it's copypasta from a reduced script.
Why would you do that?
This is actually a pretty decent way to attack it. You could break permissions vs roles up like stackus mentioned, but unless you have a really complex permissions setup, this is just fine. Storing the role_text in the session is a good idea though, unless a user's role can change on-the-fly. Also, make sure you are validating the role on the processing page as well. It make sense to hide the button on the frontend if the user can't utilize it, but you also need to ensure that they can't bypass it and just submit directly to the URL you're trying to prevent them from getting to.
There are other things to worry about. I'd really like to advertise unit-testing, type-hinting/validation of input and proper initialization of variables. 
Why the fuck would you minify PHP?
So you can a) Brag about having only one file and b) Make tiny computation/disk IO savings by not having a truckload of includes I guess. The one file thing certainly helps in regard to FTPing anyway, since multiple files makes FTP very inefficient. I still think it's premature optimization to consider these issues for most applications however.
In OP defense this is not yet_another_framework.
That's correct. There are. But there's also a potential for the random utilisation of a much smaller lexicon resulting in a much easier password to brute-force. In short, the larger number of permutations is nullified by his algorithms potential ability to create shitty guessable passwords.
I'm being thick. Can you explain?
This is not a framework, it's an ORM. I use Doctrine &amp; co. with symfony all the time, but RedBeanPHP is a good example of a very high-level of abstraction. You don't have to care about the database at all, just set your objects and you are ready to go.
Note: i'm not the author; this is something I use for small websites I maintain in production and for some applications.
Youporn seems to use Redis, I am not sure Doctrine is the best way to access it.
I know, that is syntax highlighting of Ruby with added Rails functionality. 
This. Please use PDO and stop using mysql_query.
relevant http://xkcd.com/936/
This is very insecure and should never be used for production passwords. Your code places limits on the total number of potential passwords. There is no reason to limit the character set, and there is no reason to limit the maximum length. Instead you should be checking for weaknesses in a password such as minimum length, identifiable information in the password, dictionary words, etc. Not only would you get better passwords from an entropy point of view, users can make passwords that are easier for them to remember. In fact, just drop the word password from your lexicon and adopt passphrase instead. Life will be much more secure this way.
Your site seems to freeze Opera 12 alpha.
All valid points. Appreciated.
To further support MikeSeth's advice: I've been working with Agavi for ~3 years. now my new workplace requires me to learn symphony (starting in 3 weeks, they gave me a book) and it really makes me want to cry. Making a console application in Agavi is extremely trivial. look at an example [routing](http://trac.agavi.org/browser/tags/1.0.3/samples/app/config/routing.xml) any route defined in the &lt;ae:configuration context="console"&gt; match command line commands (and parameters) and can trigger any action just like any other context the application may run in. 
PHP in embedded software...?
Cool.
Don't use FTP then
fair enough 
"One file" to me says "giant mess of badly-structured code". And even if it's great, well-structured code, it's a dumb metric. May as well concatenate every statement and declare "it's only one line of code!"
The browser stores the cookie, so the attacker would just need to add the cookie for that domain. No, the server would not realize that two people are using the cookie because of the very nature of PHP! PHP is what I refer to as a stateless language -- it doesn't know if you are already executing another script with a given person's credentials. In fact, with JavaScript, some applications may be sending 10s if not 100s of requests back at the same time with the same cookie. You are correct, the cookie string is the only piece of information that PHP uses to match a given request up with the $_SESSION super global array.
On the scattering bit, that's a good point. It doesn't actually keep them in the middle but it'll definitely keep them near eachother and push them somewhere. A better solution for the last few lines: // Randomly select the remaining characters while($length-- &gt; $difficulty) { $indexes[] = mt_rand(0,$upper); } shuffle($indexes); // Build the string, randomly alternating prepend/append to ensure difficult characters get scattered foreach($indexes as $index) { $password .= $characters[$index]; } return $password; I'm not following your comment about "first part can only contain.. last part can only contain..." -- Regardless, the adjustment above solves it although I don't think it's valid for the original code either.
Ahh, I see what you were referring to now. Another good catch. Anyway, in the above code, the prepend/append stuff has been removed and it's just using a simple shuffle() of the indexes.
I referred to that: &gt; or maybe you could write/use a [1] userland PHP parser Follow my link and read the comments ;) 
First, do a php -m. It will list all of the modules that are currently loaded. Next, select a module that you need to check if it's in use. List all the module's function names. Once you have the list, just grep through the whole source tree. If grep brings up a hit, then that module is in use for your project.
Fair enough, but if X is more usable than Y, you'd want to go with X, right? I guess it's subjective though.
what if you did versioning? I assume that some if not most comments are bug fixes, maybe have a way to do a revision like jsfiddle has
I dunno about that. I will play around with it and see. The only thing I am worried about is making the line number less readable by giving it a bright background.
True, it's all a very fine balance, but what you have is pretty cool.
You can switch any part of Agavi by simply writing classes that implement the neccesery interfaces and then making agavi use those by changing [factories.xml](http://trac.agavi.org/browser/branches/1.0/samples/app/config/factories.xml). You can (as any config file in Agavi) implement diffrent configs per contex (notice the soap/xml-rpc/console parts) and per environment (testing for exmple). we actually used an xml:include in factories to include a 'super-framework' with workplace specific aspects to all our Agavi projects. 
I have used RedBeanPHP in a ton of smaller projects and prototypes recently and I'm just now trying it out for a larger project. It certainly has shortfalls, the one-file thing is a bit daft - it is available as separate, well structured files if you want. I don't know why it's compressed into one file. The query syntax is a bit bizarre.. you need spaces at the start of the query because it unintelligently dumps it straight after the WHERE clause.. which just seems lazy.. and there are a few other minor points. Overall though, I love it. It allows me to prototype stuff as quickly as I can think it, it provides a great way to quickly build a schema (which you can then freeze (so RB no longer changes the schema), and/or edit the DB directly to add any indexes or constraints etc that you require), and it seems to perform pretty well so far...