I use vscode and update my sites with git in a vps, why?
A server side scripting language used for web development.
Needless complexity. Much as I love C++ holding that lot in my head to select the optimum way to achieve something hurts.
That's a horribly incomplete TLDR summary. This is situation dependent - in the case of the article the performance issues were in the context of low traffic. If your performance issues are being caused by high concurrent visitors, then increasing the number of cores is likely to be a better solution. Also, before looking at hardware, you should be looking at configuration. In many cases simply tuning the web server, PHP or DB server configuration can resolve issues. There's no silver bullet when it comes to fixing performance issues - you need to investigate where the bottleneck is, then fix that (and then possibly repeat the process to get rid of further bottlenecks)
I figured if you didn't understand what a templating engine is or how it works, you'd probably be behind in other things.
The only thing I do in front-end is show logs, that may explain it. No I'm not from India.
Magic HTML rewriter.
Well, yeah that probably explains it. I can see how you'd see plain PHP perfectly appropriate for what is likely just a couple loops and an if statement.
Then I guess you're only writing "Hello world" applications, so do whatever you want.
A good code formatter/linter, phpcs ux is horrible. I know there is some work to adapt prettier to work with php [https://github.com/prettier/plugin-php](https://github.com/prettier/plugin-php) and that's great but IMO it's at least a year away from production use.
üòâ
php -S 127.0.0.0:5000 for basic web server
Why do you prefer that over local run or CI?
Hm, I'm not sure I made myself clear. I don't talk about gradual refactoring or manual refactoring (the link you refer). That would be crazy and deserve 1000 downvotes :) I'm talking about pattern refactoring. It's much faster, easier to set up and the size of the project (or a number of projects) doesn't matter to it.
It's something like javascript, but hidden from user.
[PHP is not the new street name for a drug.](https://psychonautwiki.org/wiki/A-PHP)
Threads. Why is nobody saying threads?
It's also a [recursive acronym](https://en.wikipedia.org/wiki/Recursive_acronym): `PHP: Hypertext Preprocessor`
**Recursive acronym** A recursive acronym is an acronym that refers to itself. The term was first used in print in 1979 in Douglas Hofstadter's book G√∂del, Escher, Bach: An Eternal Golden Braid, in which Hofstadter invents the acronym GOD, meaning "GOD Over Djinn", to help explain infinite series, and describes it as a recursive acronym. Other references followed, however the concept was used as early as 1968 in John Brunner's science fiction novel Stand on Zanzibar. In the story, the acronym EPT (Education for Particular Task) later morphed into "Eptification for Particular Task". *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Maybe I'm misunderstanding you, but PHP has yield...
Checkout Lando. It's a super easy wrapper around docker.
That'll teach me to get trapped in Drupal-land. But without cheap threads, doesn't that just change the order of execution? I guess you get short-circuiting...
There's `php -S 127.0.0.1:8080` which starts a local [dev server](https://www.php.net/manual/en/features.commandline.webserver.php) which should be enough to get started.
&gt; short DTO declarations like Kotlin has This is probably one of my favorite features, and every time I don't have it I wish I did. Writing out a constructor, getters/setters, and instance variables for an object that has a lot of properties is annoying and hard to maintain, and this makes it way easier
A damn GUI library, python has Tkinter, PHP used to have PHP-Gtk, no longer supported
Still offering a large case of beer to whichever internals dev adds this to PHP 8.0
There are threads already. Although they come disabled in most distro packages. https://medium.com/@rossbulat/true-php7-multi-threading-how-to-rebuild-php-and-use-pthreads-bed4243c0561
I would personally prefer a non-runtime implementation, something more akin to TypeScript. perhaps building on Psalm/Phan's @template annotations. Generics at runtime seems like a huge task to me.
Check out gsxdb
Interfaces checked at usage rather than definition - such that you can define interfaces for code you didn‚Äôt write without building a full wrapper. Also Interfaces for callables is a big one I miss. Both of these are in Go and TypeScript where I collectively spend most of my time outside of PHP.
Does PHP have some kind background job processing ?
Generics are usually done at compile time.
Honestly I don‚Äôt think it needs real threads, particularly not in the context of serving requests. CLI scripts, I could see an argument, but PHPs thread per request model scales multiple requests really amazingly well out of the box unlike some other single threaded languages, largely in part of the fact that one request never saturates a multicore CPU. This means if there‚Äôs a resource intensive request and a light request, the light request can be served concurrently, rather than having to wait for CPU time.
The most common use-case (I think) is making multiple queries to middleware layers within the same HTTP request.
I am frankly glad it doesn‚Äôt have method overloading honestly. Having worked extensively with it in C++ years ago I honestly believe method overloading serves very little purpose other than to sell debuggers and IDEs as the call path is so much harder to follow by hand. Easy to write, impossible to read. You‚Äôre almost always better off just defining methods with separate clear names.
Oh my god dude I see you writing this same "Non of them actually do core reviews" spiel in every single thread. Can you just move on already?
This is why you have integration and acceptance tests
A standard Set object that also works with primitive values, not just objects.
The "short array functions" in the title really confused me :D
A very arbitrary conclusion. PHP remains a server website language first and foremost. If you don‚Äôt address your own customers (web devs) then what is your purpose? There are dozens of languages that are better at being ‚Äúa programming language‚Äù. What is PHP better at? Maybe we should strip the HTTP APIs and SQL database drivers as well. Those are often not built in other ‚Äúprogramming languages‚Äù.
You can build a multitasking system with generators. The question is where you'd need threads. If you need them for a performance boost, PHP isn't probably the right language for the usecase
 **If something is free, you are the product.**
There's an RFC for async stuff: [https://wiki.php.net/rfc/fiber](https://wiki.php.net/rfc/fiber) If it's threading you're after there's the pthreads extension. Only works for CLI though. [https://www.php.net/manual/en/intro.pthreads.php](https://www.php.net/manual/en/intro.pthreads.php)
I'm incredibly hyped for lambda expressions in PHP 7.4 [https://wiki.php.net/rfc/arrow\_functions\_v2](https://wiki.php.net/rfc/arrow_functions_v2) Fiber is also gonna be amazing when they eventually they sort it out.
Is that true multitasking, or is it execution-on-demand? (There are a *lot* of things PHP isn't the right language for, but we still seem to be drifting towards strong typing, to name one).
Oh baby. Finally some sexy features for PHP.
But in those languages regular type checks also happen at compile time. Type checks in PHP happen at runtime, because PHP is dynamically typed. I assume that generics would affect those runtime type checks.
async
I have been doing a lot of javba lately and method over-loading is so nice.
parsing twitter with no ability to paginate is useless for the most-part, headless browser ftw
It's logical given the nature of http servers. This isn't really a php problem. Generally speaking, the more cores they have to spread their processes, the more they can do simultaneously and thus, the more traffic they can serve. The only time this really changes is if the workload is actually CPU intensive and cannot be parallelized. In that case, you want your process running on a fast core. Typically hardware that has more cores has slower cores. So, you just need to pick your hardware to suit the problem at hand.
Nope. The good news is, that's completely irrelevant.
Are you really wishing NPM and `node_modules` upon PHP?
standard types as an object with their own methods rather than the mess of the standard library.
sorry for annoying you but why in the url controller you do first or fail and in getUrlForEdit you do only first why not in getUrlForEdit firstOrFail(); so you don't do 2 queries ?
Nice point, I think method overloading is good during rapid development, but should be refactored out towards production, which is what would normally happen in TDD anyway.
pip &lt; npm &lt; packagist Laravel is doing a lot of the things I am wishing on PHP In general...
This is only true if the number of concurrent requests matches your core count. Php may not be designed for multithreading but apache spawns a new process for each request, php fpm can be configured to use all your cores too. When you have more concurrent requests than cores more cores will be much better, try to run 10k concurrent requests on one core with 5ghz vs 10 cores with 2ghz.
This is a really strange one, considering how many iterations of the *AMP stack are out there for any OS.
As a MERN stack lover who makes their money in WordPress, I'm very ready for this.
This is a really strange one, considering how many iterations of the *AMP stack are out there for any OS.
Absolutely no problems! I encourage to review the code, because I know at the moment it is pretty immature. But I didn't understand completely what do you mean... could you please link files and lines in the GitHub repo? Thanks!
Laravel/Lumen is pretty quick too, and can be ran at the command line.
Pretty noice
 [https://github.com/urlhum/UrlHum/blob/86c0a7bccfcdb29503442eaac9a8441382735862/app/Http/Controllers/UrlController.php#L122](https://github.com/urlhum/UrlHum/blob/86c0a7bccfcdb29503442eaac9a8441382735862/app/Http/Controllers/UrlController.php#L122) why firstOrfail then inside [https://github.com/urlhum/UrlHum/blob/011a747a4921400d02d9f191ba498bd1f532ba0a/app/Url.php#L79](https://github.com/urlhum/UrlHum/blob/011a747a4921400d02d9f191ba498bd1f532ba0a/app/Url.php#L79) why not do firstOrFail() inside getUrlForEdit you run 2 queries the 1st one Url::where('short\_url', $url)-&gt;firstOrFail(); can be removed if you used firstOrFail() inside the getUrlForEdit() function
It takes around 1 sec to run `$ sudo find ./ -type f -exec sed -i -e 's/&lt;?/&lt;?php/g' {} \;` The only thing that has bothered me over the years is that it is an issue at all. E.g. why was different tags an option in the first place. Why did different distros or web hosts had different defaults. Why the flavoured style changed over time. Why people had so strong opinions and seem to be obsessed over such insignificant detail. Have simply not cared at all, just doing whatever the project, the web host, the existing codebase, co-worker etc seem to be most comfortable with.
Nope. We are far and away from `is-even`, `is-odd`, `left-pad`, etc., etc., so we are doing well.
Not sure if you are aware, but yhu are talking specifically about Apache mpm_profork only. But other than php handling, mpm_prefork is TERRIBLE at scaling! One should almost always use mpm_event or mpm_worker which neither support what you describe. Event and worker require PHP-fastcgi or PHP-FPM.
Imagine the parser coming along something that looked like: ```php class Vector&lt;type T&gt; { public function __construct(T ...$inputs) { ... } public function get(int $pos): T { ... } } ``` And then it found a usage of it: ```php $v = new Vector&lt;MyObject&gt;(); ``` The compiler sees the template, and converts the templated name to be something unique for that combination, so to the compiler it might end up looking like: ```php $v = new Vector_TemplatedFor_MyObject(); ``` Knowing that, it can then check if it's already got an internal Vector_TemplatedFor_MyObject class in its symbol tables, and if not, it will create one, replacing every occurrence of T, with MyObject. ```php class Vector_TemplatedFor_MyObject { public function __construct(MyObject ...$inputs) { ... } public function get(int $pos): MyObject { ... } } ``` After that, it's pretty much identical to how type hinting works in any other situation.
I use php-fpm with nginx, but even here you can use all cores if you just increase the thread pool. Yes apache prefork scales very badly.
Great catch! You're right. Thank you for pointing this out. I will edit the getUrlForEdit and remove the firstOrFail in the Controller in the next commit. Thanks! If you'd find anything other please tell me, I'm completely dedicated to the project!
Yeas but the point is still that PHP-FPM does not support multi-thread. It's still single threaded. Which was topic of article.
I'm aware of the existence of all sort of tools. But comparing it to C#(install Visual Studio and that's it) it's much harder. Everyone who has ever tried to configure XDebug with PhpStorm and Laravel Homestead should know what I mean... It's almost a nightmare.
This changes **everything**. PHP 7.4 is looking better and better every day.
What do you mean? Php-fpm can run multiple worker processes, so I wouldn't call it single threaded. Each worker can handle multiple connections and thus these are executed in one thread.
Please help me understand. How does it change everything. I'm not being snarky, I honestly want to know.
" brexit(); " LOL
With Lando it's literally just `xdebug: true` in a config file and you're good to go. It just works!
Great! I didn't realise it was only for single statement closures. Hopefully multi statement support follows soon.
The implementation of this looks rough. Is there a consensus on the final syntax?
&gt; Since dev-packages has no security guaranties \[sic\] What does that mean? All dev packages are a free for all now?
Anonymous functions/lambdas/closures have already existed for a while, that's just an RFC for the short hand version
To be honest, this is pretty amazing idea! Do you have some idea about generics as parameter and return type before we start annoying core developers? :) ```php function findCategories(Collection&lt;Product&gt; $products): Collection&lt;Category&gt; { //... } ```
PHP-FPM is multi-process, not multi-threaded
Google Sheets is the only spreadsheet with JavaScript as a first class scripting language (Excel and LibreOffice still rely on wonky pseudo Basic with cludges to use alternate languages) Also it's not a database.
But thanks to the api it can be misused as one.
Sorry for the misunderstanding I meant multi process and not multi threading, doesn't change anything though.
no you haven't changed anything. Full circle conversation. We are back to the fact that Php (including PHP-FPM) is single threaded and thus benefit from CPU single thread performance.
I'm about to get syntactic diabetes at this point.
It is much more complex than that though. The approach you suggest, while quite elegant, unfortunately wouldn't satisfy a number of common real world problems. For example, there is a problem with LSP. Consider the following source code: ``` interface Entity { ... } interface Person { ... } class User implements Entity, Person { ... } class Iterator&lt;E&gt; { ... } function sortEntities(Iterator&lt;Entity&gt; $entities) { ... } function sortUsers(Iterator&lt;User&gt; $users) { sortById($users); } ``` As per your suggested approach, PHP would generate classes for `Iterator&lt;Entity&gt;` and `Iterator&lt;User&gt;`. ``` class Iterator__Entity { ... } class Iterator__User { ... } function sortEntities(Iterator__Entity $entities) { ... } function sortUsers(Iterator__User $users) { sortById($users); // this would error as Iterator__User is not a subtype of Iterator__Entity } ``` There would be a multitude of problems to solve if generic type checks were to be done at runtime.
Look at the [syntax](https://wiki.php.net/rfc/arrow_functions_v2#syntax) portion of the RFC for why `($x) =&gt; $x * $y` and other popular at first options can't be used
Ofcourse it does, I never said that it doesn't I'm just trying to say that php-fpm also profits from more cores because you can handle more traffic. If one worker handles 1024 requests in one process another worker can also handle 1024 request in another process executing the same script
10 whole doll hairs?
Now that it's passed hopefully an RFC for multi statement bodies will be introduced in the not too distant future.
I will share script shortly
The syntax, to me, is very unreadable.
1-3 sec is incredible long. Even 2 seconds. Ok it's, sparse on application details anyway but anything &gt; 50ms would alert me unless it's specific special requests which are known to have to process lots of data.
I wonder what the future of PHP looks like. Given RFC's like these, they are trying to catch up with FP-languages like TypeScript.
 `/**` `* mark_additionals_as_paid( )` `*` `* @access public` `* @return void` `*/` `public function mark_additionals_as_paid( )` `{` `define('SHOPIFY_APP_SECRET', 'MY_KEY');` &amp;#x200B; `$hmac_header = $_SERVER['HTTP_X_SHOPIFY_HMAC_SHA256'];` `$data = file_get_contents('php://input');` `$verified = $this-&gt;_verify_webhook($data, $hmac_header);` &amp;#x200B; `if( $verified ) {` &amp;#x200B; `$returnedOrder = json_decode($data);` &amp;#x200B; `if( $returnedOrder-&gt;status == "completed" ) {` &amp;#x200B; `// search the database to see if this order is from a pending quote approval` `$query = $this-&gt;order_details_model-&gt;get_order_via_shopify_id( $returnedOrder-&gt;id );` &amp;#x200B; `// if a result has been found, update it` `if( $query-&gt;num_rows &gt; 0 ) {` `foreach ( $query-&gt;result() as $foundOrder ) {` &amp;#x200B; `$customer_has_paid = 0;` `$customer_has_paid = $returnedOrder-&gt;total_price;` &amp;#x200B; `foreach ( $returnedOrder-&gt;line_items as $line_item ) {` `// get the line item id contained in shopify response` `$new_line_item_id = $line_item-&gt;id;` `}` &amp;#x200B; `// update this order with the shopify data` `$this-&gt;db-&gt;set( 'total_price_paid', 'total_price_paid+' . $customer_has_paid, FALSE );` `$this-&gt;db-&gt;set( 'additional_order_id', $returnedOrder-&gt;order_id );` `$this-&gt;db-&gt;where( 'order_id', $foundOrder-&gt;order_id );` &amp;#x200B; `$this-&gt;db-&gt;update('orders');` &amp;#x200B; `// add note to the order to show how much was paid` `$data = array(` `'order_id' =&gt; $foundOrder-&gt;order_id,` `'note' =&gt; 'Customer paid &amp;pound;' . $returnedOrder-&gt;total_price . ' through Shopify',` `'date_time' =&gt; date( 'Y-m-d H:i:s' ),` `'user_id' =&gt; '2'` `);` &amp;#x200B; `$this-&gt;timeline-&gt;insert( $data );` `}` &amp;#x200B; `/*` `once finished, query this order and see if the total_price_paid at least matches the total_price column,` `being higher isn't the end of the world as a refund can be processed. whereas if it's less, the repair cannot` `be sent out` `*/` &amp;#x200B; `$query = $this-&gt;order_details_model-&gt;get_order_via_shopify_id( $returnedOrder-&gt;id );` &amp;#x200B; `foreach ( $query-&gt;result() as $foundOrder ) {` &amp;#x200B; `$customer_paid = $foundOrder-&gt;total_price_paid;` `$job_price = $foundOrder-&gt;total_price;` &amp;#x200B; `if( $customer_paid &gt;= $job_price ){` &amp;#x200B; `// update this order with the shopify data` `$this-&gt;db-&gt;set( 'pending_payment', 'n' );` `$this-&gt;db-&gt;where( 'order_id', $foundOrder-&gt;order_id );` &amp;#x200B; `$this-&gt;db-&gt;update('orders');` &amp;#x200B; `// add note to the order to show final balance has been paid` `$data = array(` `'order_id' =&gt; $foundOrder-&gt;order_id,` `'note' =&gt; 'Final balance has been paid (&amp;pound;' . $customer_has_paid . ')',` `'date_time' =&gt; date( 'Y-m-d H:i:s' ),` `'user_id' =&gt; '2'` `);` &amp;#x200B; `$this-&gt;timeline-&gt;insert( $data );` &amp;#x200B; `}` &amp;#x200B; `}` &amp;#x200B; `}` &amp;#x200B; `}` &amp;#x200B; `// shopify keeps trying to send until an ok response is received` `header('HTTP/1.0 200 OK');` `} else {` `header('HTTP/1.0 200 OK');` `}` &amp;#x200B; `}` &amp;#x200B; `// --------------------------------------------------------------------` &amp;#x200B; And Shopify webhook is set up as Order/Paid in the notification section with URL pointing to this specific script.
I know it can be really frustrating when companies change their APIs, but there are plenty of small useful projects that this kind of thing is great for. I frequently use the sheets API to pull data from Google form submissions so I can do a little processing in a script which makes that data more useful to me. Another super simple common use case is pulling in data from a sheet where a team had been collaborating.
You bring up a good point, it would certainly need to deal with inheritance chains as well by checking for / creating anything in the inheritance chain: ```php class Iterator_User implements Iterator_Entity ```
Didn‚Äôt mean the RFC was rough. I was referring to the implementation. I also agree it‚Äôs a very carefully crafted RFC. I also read the syntax section. My question was if there was a consensus on the final syntax.
I don't know if it's bad design, but the way I've always *wanted* to use it is for methods that act on an object, being able to pass in either the object or the identifier. For example public function deleteUser(User $user) { $user-&gt;delete(); } public function deletUser(EmailAddress $emailAddress) { $this-&gt;deleteUser($this-&gt;getUserByEmailAddress($emailAddress)); } public function deleteUser(Id $id) { $this-&gt;deleteUser($this-&gt;getUserByid($id)); } Or, even closer to my dream public function deleteUser(User $user) { $user-&gt;delete(); } public function deletUser(EmailAddress $emailAddress) { $this-&gt;deleteUser($this-&gt;getUser($emailAddress)); } public function deleteUser(Id $id) { $this-&gt;deleteUser($this-&gt;getUser($id)); } public function getUser(Id $id); public function getUser(EmailAddress $emailAddress); But there's been a long time between when I last used overloading and now, with a lot of change in my own personal programming style. I might not end up using it if we did get it, but there's a part of me that still wants it. Personally when I did use it, I never really found it hard to follow. And I use a good IDE all the time anyway, so I don't feel like it would be a massive issue. As for clear naming, when I was learning Java and brought it up my teacher told me to consider the signature as part of the name. `getUserByEmailAddress` is basically the same name as `getUser(EmailAddress)`. It's just a different way of reading it.
Oh, I forgot this one! I want [LINQ](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/introduction-to-linq-queries) so much. Imagine having a really nice query language, like SQL or DQL, but integrated into the language. Instead of passing strings, they're actual keywords that IDE's can understand better. And instead of acting on *just* Databases, they'd act on any data source. Arrays, generators, file handlers. You just write the query and swap out the data source as needed. That would be so great
Found the pedant.
Try it a bit, I think you'll get used to it. Pretty much every other programming language has some kind of lambda syntax by now, and devs in those languages cope fine (or even swear by it).
Agree, less readable and less maintainable code just to be able to write a few less characters, in a world where most people seem to be addicted to IDE's that do most of the work for them anyway.
The problem is, `Iterator__Entity` would need to be a class, not an interface, as `Iterator` is a class. `Iterator__User` cannot then extend both `Iterator__Entity` and `Iterator__Person` to reflect the fact that `User implements Entity, Person`. It's already possible to do what you have suggested in userland, but this approach simply isn't compatible with LSP. We also have lots of other problems, like `instanceof` checks and `get_class` returning unexpected results.
The way I read it people voted on the fn syntax, so I'd say there's a pretty convincing consensus.
Yea, that's what I'm assuming as well. I guess I'm hoping for the simpler syntax, as you quoted in your previous reply, similar to javascript's. At least then closure syntax will look nice.
I'm not the other guy. :) I read the internals discussion as well and my impression is that the simpler syntax is just flat out infeasible.
Seems to be the case. Unfortunately we're only going to get a shorter function keyword and a replacement for braces, if that's the case. I mean, I'm all about having arrow functions, but not a fan of the \`fn\` prefix requirement :/
And automatic capturing. I think it's pretty clearly an upgrade and editors are going to have auto-complete in any case.
Completely agree, symbols are more difficult for your eye to see than words.I guess if you come from JS as your first language, which all college grads do, this is "readable".
Out of curiosity - why do you think its less maintainable?
I'm a bit short on time to go into it much more over my lunch, but my thinking is, because you're using interfaces, your resulting classes would themselves have interfaces to support LSP. If I had class User implements Entity, SomethingElse, and encountered new Iterator&lt;User&gt; I would know that I would need to create: ``` Iterator&lt;User&gt; Iterator&lt;Entity&gt; Iterator&lt;SomethingElse&gt; Iterator_User implements Iterator_Entity, Iterator_SomethingElse { ... } ``` What that would need, is class names separating from interfaces. If every template symbol was an interface internally, the problem should go away (...I think).
I did something similar with JavaScript to dump dates from a calendar. The problem I ran into is the maximum limit on API calls or something. It was a long time ago. Overall my experience with Google API is terrible. For small quick projects sure, but if you're going to plan on running this for a while it's better to build your own project from scratch.
&gt; because you're using interfaces, your resulting classes would themselves have interfaces to support LSP. In my example, `Iterator` is a class, not an interface. (I should have called it `Collection` to avoid confusion with PHP's `Iterator` interface.) The fact that `Iterator` is a concrete class means that it's subtypes must all be concrete classes, not interfaces. For example, if I write `new Iterator&lt;Entity&gt;` in my source code (because `Iterator` is a class) and this is turned into `new Iterator__Entity` by PHP, then clearly `Iterator__Entity` must be a class, not an interface. Likewise `Iterator__User` etc. must therefore also be classes.
In addition to the tools /u/SerdanKK mentioned, you can also use some form of queueing system or scheduling if the results of the background job aren't needed. Most frameworks have their own library for interacting with queues and scheduling jobs. Common examples where a queue or scheduled job are appropriate would be sending emails, posting to APIs (for example posting a tweet or sending a message on Slack), regularly fetching data from external APIs or processing images or videos.
Speaking of Kotlin features, I actually thought `typealias` was pretty neat to do things like `typealias Register ArrayList&lt;UByte&gt;` and then being able to create extensions specific my new `Register` type. I might've been using it wrong though, but it was fun. :D
Yes, because in other languages you gain more than just (quote) "\*reduces the amount of boilerplate from 31 characters down to 8\*"...In JS it was a real a step forward because you actually got more clear, readable code (if you are using it right) and got implicit returns besides getting rid of the `this` overhead when not needed. In the above mentioned RFC I see some really confusing / out of place code that introduce a new `fn()` as a full keyword that WILL conflict with existing code (going through top repositories on GitHub is not just good enough) - I doubt any introduction of primitive "lambdas" in any language have been so problematic (just a language extension, not something that would break existing code with almost certainty) And just to do have the same "nice thing" in PHP people have learned to use in other languages, without the benefit of using that "nice thing" in PHP ...Just for sparing a few chars. But now its here, OK. We'll learn and adopt. But I really cannot see any improvement for the language or problem solving, more something that will confuse a lot of PHP'ers in the future.
&gt; I wonder what the future of PHP looks like. I wonder as well. But I can't help but think it's brighter now than it has been in a long time.
While in an ideal world I'd prefer it not be needed, it is only two extra characters, but introduces automatic capturing (no need for `use ($external, $variables`) and obviates the need for `return`. It is a significant improvement in a lot of cases.
Yea, that as well - good point.
Do you mean PHP_CodeSniffer? Do you have any specific examples of what you don't like? I've been working with CodeSniffer a lot and I'm not a real big fan of the internals, but I haven't really had any issues UX wise.
If it was done in userland yes. But PHP internals doesn't have to play by userland rules, and "new" can return anything it wants, including a concrete class which implements the actual interface name generated from the template name. ``` $x = new Iterator&lt;User&gt;(...); assert(get_class($x) === 'Iterator_User_Concrete'); assert($x instanceof Iterator&lt;Entity&gt;); ``` But "new Iterator_User_Concrete()" would fail as it wouldn't be userland accessible. Obviously it introduces an issue with get_class but that's something for reflection to deal with. There's not a great deal of difference between an interface and a class, the main ones being instance variables.
Having recently tried Kotlin, I love this feature: https://kotlinlang.org/docs/reference/extensions.html. Not having to write decorators, inheriting, or static *Util classes just to extend types with some functionality you need across your project. It's great.
It literally means: don't deploy PhpUnit/a-dev-toolbar/other-dev-package to a production system.
Wow! $10! A person working in McDonalds is probably on close to that an hour.
At least I want to give a someone a tip for a beer, I don‚Äôt expect doing it for free. Lol for me it‚Äôs no go, for someone clued up it‚Äôs like 20 minutes job.
I was talking specifically about *readability*, since that's what the parent comment was about. Apart from the `fn` prefix, the syntax is the same as in other languages. But anyway. &gt; In JS it was a real a step forward because you actually got more clear, readable code (if you are using it right) and got implicit returns besides getting rid of the `this` overhead when not needed. Not sure how this is so different from PHP. The syntax is nearly the same. The PHP arrow has an implicit return as well. And although not the same as the `this` thing, I would say the PHP version has a similar differentiator from `function` in that it implicitly captures variable references. &gt; In the above mentioned RFC I see some really confusing / out of place code that introduce a new fn() as a full keyword that WILL conflict with existing code (going through top repositories on GitHub is not just good enough) - I doubt any introduction of primitive "lambdas" in any language have been so problematic (just a language extension, not something that would break existing code with almost certainty) Maybe. I'd rather have seen a different syntax of course, but considering all the tradeoffs I'm fine with the final solution. Backwards-incompatible introduction of a new keyword is always problematic, but it happens all the time in language evolution. We can deal with it. &gt; And just to do have the same "nice thing" in PHP people have learned to use in other languages, without the benefit of using that "nice thing" in PHP ...Just for sparing a few chars. I disagree. This is subjective, but: it's not so much about saving chars but that the arrow syntax is a more natural way to express a function expression. It's like if instead of `+` we had a syntax for addition like `add { 42, 1 }`. Sure you can write code like that (Lispers basically do), but it's more readable to write `42 + 1`. Similarly when I think about a mapping I think `inputs ‚Üí output`, not `function(inputs) { return output; }`. If you write a lot of functional-style code, you're writing a lot of function expressions, and this overhead/unnaturality compounds.
I was stucked few days ago how to perform WHERE and IN() when using MYSQLI Prepared Statements. Finally, I found this solution. And, I thought it would be helpful for someone, someday. In PDO, the same thing can be done.
Right, this kind of solution would require a lot of hacks in order to be workable, and this is after us thinking about it for a few minutes. To summarise what I think: solving generics in PHP itself seems extremely hard (but perhaps /u/nikic can correct me), while a static solution would be much simpler imo and can still deliver a lot of the benefits. Psalm (static analyser) has already made good progress supporting generics.
Being able to specify typed properties in interfaces. PhpStorm already supports this. Just wish the actual language did as well. Given the introduction of typed properties in classes, I would not expect that adding this functionality to interfaces would be a huge problem.
If your shop is important to you, you shouldn't be hiring people for code blocks on reddit for $10... Have a developer or tech consultant on retainer if you need custom code. Expect to pay $50-75/hour for a quality developer on a contract basis. If you have the need to hire a developer as a full time employee and provide benefits, breaks, and employer contributions then $30/hour would be more reasonable.
Python style private accessor syntax (_prop or _method)
Take it as outsourcing. Life is brutal
default parameters aren't any better, it's just overloading without overloading.
Does anyone know why they didn't use the `~&gt;` syntax from the earlier proposal? It had the advantage of being easier to distinguish from `=&gt;` in arrays and would be unambiguous without the additional `fn` keyword.
The arrow syntax comes from math, like: `x ‚Ü¶ x + 1`. Which was then adopted by functional programming languages. And then imperative languages started to adopt it from FP. It's interesting that you mention JS, because just a few years ago they went through the exact same discussion as here, going from `function() {}` syntax to arrow functions. A lot of people complained the same way but now it's pretty much noncontroversial.
I really like this RFC, I just hope PHP doesnt go the way of perl where half the code ends up being symbols and not actual words.
While the RFC examples are clear thought through and understandable, you will for sure IRL see far more complex structures with for example deep nested arrow functions. Some people will adapt the `fn()` "pattern" and use it for almost anything they do (as we see in other languages). One of the benefit of arrow functions (and the like) is that they take some of the trivial implicit overhead out of the code. But it have to be done wisely, because the language structures is for ourselves actually hinting of what is going on. By the semantics our code become more or less self-describing - when we have a `function` or a `return`, and so on, we can very quickly understand what is going on. We sacrifice that part for a smarter "shorthand" (in other languages even more benefits) and that is OK done right. We can take those things out then they are trivial and implicit. But by heart, are there anyone who have NOT experienced that they not could interpret even their own "lambdas" after 6 months? What is going on here, what was that implicit x, and where did it came from? Using arrow functions (and the like) require a skilled programmer who know when to use it, and how to use it correct. Otherwise I fear (for PHP) that you just end up people wildly adopting the `fn()` pattern, without any reason than it is "easier" or "less verbose" - and in the long term we will have more less-self-describing code, and by that - in the long term less maintainable code. Does it make sense? Perhaps I am just an old barking dog :)
&gt; To summarise what I think: solving generics in PHP itself seems extremely hard Definitely :) Generics are an extremely tough topic, both in terms of semantics and implementation. I still think it's something that I think we'll want to pursue for core support, as the ergonomics are much better than what psalm can offer, not to mention the ability to perform runtime type introspection. I'm pretty sure we'd go for some form of reified generics rather than the templating apporach that /u/Sentient_Blade is suggesting though.
Yeah, the developments with Symfony and Laravel seemed to have really driven a massive interested in PHP again, along with PHP 7.0. I‚Äôm still loving PHP - it really has come a long way.
And honestly I 100% support getting rid of default parameters. Go does not have them and I don't miss them at all.
How do you use slots, components and inheritance in plain PHP? Or is that part of your minimal framework?
Right now my shop is using PHP7.2 in Docker images on Raspberry Pis to monitor and report temperature sensor data from a bunch of fridge/freezers. We're excited about JIT to extend our use of PHP as a general purpose programming language even suitable for embedded system applications.
I defer to the experts :-) I for one can't wait to delete several hundred files of machine generated code when generics finally land.
Seriously, is this needed? Does this make PHP better in any way? IMHO it makes the code less readable. Sure, you need to type a few less characters but if it's about code readability (and with that understandability of your code from others, and your 6 months future self) I'll happily write a little extra code.
The Doctrine DBAL db connection give you a much cleaner solution. [https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/data-retrieval-and-manipulation.html#list-of-parameters-conversion](https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/data-retrieval-and-manipulation.html#list-of-parameters-conversion) &amp;#x200B; \`\`\` $stmt = $conn-&gt;executeQuery('SELECT \* FROM articles WHERE id IN (?)', array(array(1, 2, 3, 4, 5, 6)), array(\\Doctrine\\DBAL\\Connection::PARAM\_INT\_ARRAY) ); \`\`\`
Another strange syntax term one has to learn just because someone is to lazy to type the letters 'u', 'c', 't', 'i', 'o', and 'n'. :-)
More CPU does mean a ton more of moneyz. Memory is cheap. So please go with php fpm and don't follow any of the advises the website does make. Scaling CPU is the last thing you should ever do. Before that you can even consider to change the whole hosting infrastructure to scale it properly.
I haven't read the proposals, but is there a big reason for why `-&gt;` (like in Java) wouldn't work?
AWS gives you a small database for free (up to 20GB of data) https://aws.amazon.com/rds/free/
And '{', 'r', 'e', 't', 'u', 'r', 'n', ';', '}' These are nice for higher order functions when you need to pass a short function that returns a value. Many other languages have this syntax or similar.
I was just referring to the 'fn' part actually. I don't get what would be wrong with 'function' in this case too for consistency.
Maybe I missed it, but Enums. I know there is the SplEnum, but I use empty classes with constants all the time.
For me, it's the implicit parent scope. With eventual multi-statement support, I can see this completely replacing the current use, but implicit parent scope in closures is a source of massive headaches in languages which have them, like Javascript. It can get pretty tricky understanding what's going on, especially in nested closures. I see the explicit scope for PHP's current closures as a **massive** improvement over the implicit system. I see this in all the "Arrow functions considered harmful" or "You might not need arrow functions" blogs in a couple of years. :) I'll probably look to fully disallow this in my coding style. Having said that, I'm very glad this was passed since this was on everyone's top 5 wish list . Now maybe development can focus on things of substance like generics.
Completely anecdotal, but the instinct to use shorthand/abbreviations/slang instead of writing clear, readable code seems to be a lot stronger in PHP (and JS to an extent) than what I'm used to with C# or Java. fn() is just so silly.
Agreed. Even the apps that don't get deprecated - have some other system breaking change that gets rolled out and fucks your app.
How am I the product when my app uses MySQL, Ubuntu, or Apache?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Alright, I tried to do that and doesn't work. Because the function in Url.php is using the Query Builder. I could add the **FirstOrFail** with a macro. I will decide what to do about this. Thanks anyway!
&gt; BTW, I believe we've reached a point where SOLID does as much harm, or even more harm, than it helps people write good code. There's so much pseudo-science and blog-born mythology around it, that the truth in it has been completely and utterly lost. this is the real wisdom in all of this. These guidelines are useful in that they give you things to consider when designing, but the second you become dogmatic about it they become actively harmful. DRY is another one that can become harmful if not used with care.
I agree. Don't think we should use RFC to institute laziness.
Used to use Upwork (formerly odesk) a few years ago, worked pretty well. Lately, it seems like there's too much scammy or spammy behavior. Favorable projects get 50 proposals in a day, making it hard to actually compete for any work. I've been with a company who's tried to hire some outside help on Upwork and they have gotten scammed repeatedly, people who file proposals and interview, then outsource the work to people who produce low quality results with spelling errors.
I just want null safe chaining. Not sure what has it, c# maybe
PHP kinda becoming the hipster javascript
The downfall of OOP, or the mistake of OOP if you will, is that the line for reuse moved outside of the language when SOA hit the scene (and the relevant web API's that cropped up around it). At that point sharing happened via message passing and/or backed DB systems, so the need for code reuse at the level of the language massively went away.
\&gt; In PDO, it's much easier to do! Are you sure? According to the PHP Manual‚Äôs entry on \`PDO::prepare()\`, which says: ‚ÄúYou cannot bind multiple values to a single named parameter in, for example, the IN() clause of an SQL statement.‚Äù But maybe you know an easy trick with PDO?
While I can't speak to the use of it in math or true FP languages... I feel compelled to post a problem I just solved after 1 hour of debugging...oddly good timing, but (to me) it illustrates the problem with using symbols vs keywords. But from what you say, I'm probably real late to the argument, as I'm new to JS, but starting with ES6... const popupBruteForceIncludeAnonymous = ( &lt;Popover id="popover-basic" title="Include Anonymous"&gt; &lt;/Popover&gt; ); vs const HelpBruteForceIncludeAnonymous = () =&gt; ( &lt;Popover id="popover-basic" title="Include Anonymous"&gt; &lt;/Popover&gt; ); It was the fault of fat-fingering vscode, which I'm new to, and it overwrote a bunch of lines. I hadn't saved a copy yet to `git stash`, so I couldn't see really what changed. While it's obvious when you get it down to almost no lines of code, it was tough to see in an established React component.
Is there something community can help like bounty system? Or Patreon support?
 It's more easy in PDO, as execute [method](https://developer.hyvor.com/tutorials/php/oop-methods) accepts arrays as following. $arr = [1,2,3]; $in = str_repeat('?,', count($arr) - 1) . '?'; $sql = "SELECT * FROM table WHERE column IN ($in)"; $stmt = $db-&gt;prepare($sql); $stmt -&gt;execute($arr);
I hear ya. :) I've made mistakes like that. But to me this is similar to mistakes like forgetting a semicolon, or writing `someFunction` when you meant `someFunction()`. Tiny errors which are difficult to spot and can be annoying to debug for sure. But I don't think many people are going to argue that we write `apply someFunction` or `return 42 semicolon`. Basically it's a tradeoff, and considering how many short anonymous function we write in the kind of functional-style code that's popular these days I think it's a worthy tradeoff. Also, I would say that this class of errors is solved by a good type checker like TypeScript. They would be able to check that you're trying to use a React element as a component (function). In fact React also does this check for you at runtime so usually when I run into this problem I'll be able to figure it out quickly.
PHP is starting to feel more and more like JS!
It's all in the RFC. -&gt; is used for calling methods and accessing properties.
It has the same drawbacks as the ==&gt; operator would've which is explained at length in the RFC.
If any thing you makes becomes big they get to put your logo on their website
That wouldve been about time
Can you explain for someone that doesn‚Äôt know what generics are? And how they would be useful/implemented in php
Multithreadding with a fast way to share memory between threads or processes ( without having to encode/decode )
Amazing!
http://gearman.org/examples/reverse/
Why even boher to argue this is a very,, very, very bad idea.
The syntax sugar catches up quick
Thing of generics as collections of objects of a certain kind. You can do that with an array but there‚Äôs no way to apply restrictions on the array to ensure that it contains only objects of a certain kind. Example: `$listOfPeople = [new Person(), new Person(), ...];` Now let‚Äôs say I have a method that takes in a that list of people as an argument: `public function addPeopleToGroup(array $people)` Now I have to ensure within that method that each element is an instance of `Person` which means I have to iterate over every element and do a type assertion. Instead, with generics you‚Äôre able to create native typed collections which do all those implied assertions for you. `$listOfPeople = new List&lt;Person&gt;(new Person(), new Person(), ...);` Then in my method I can just call for that type of collection to be passed in: `public function addPeopleToGroup(List&lt;Person&gt; $people)` Now I don‚Äôt need to loop over the collection to ensure its integrity since generics do that for you.
i've been looking forward to this for a while - stoked for 7.4
In case you are using a relatively modern MySQL (5.7+) a rick is to use JSON support and \`JSON\_CONTAINS\`. Taking the example from the blog: $stmt = $mysqli -&gt; prepare("SELECT \* FROM table WHERE JSON\_CONTAINS(?, CAST(id AS JSON))"); $stmt -&gt; bind\_param('s', json\_encode($ids)); See also docs on JSON\_CONTAINS: [https://dev.mysql.com/doc/refman/8.0/en/json-search-functions.html#function\_json-contains](https://dev.mysql.com/doc/refman/8.0/en/json-search-functions.html#function_json-contains)
Generators are not threading. Neither is cooperative multitasking, and this is coming from somehow who has a healthy love of generators. Threads _would_ be useful, but more for background work. You probably wouldn't want to use them when servicing web requests all that often as context switching has some overhead.
Wow! That's interesting....
And there we go down..
I couldn't tell from reading the traffic level of the site. If the traffic is low, its probably because of some poor queries or an I/O issue. Id look at that before hardware personally, but of course a developer would say that!
Really depends on what you're doing. 50 MS is lightening fast. Our API takes 2-4 seconds to respond, but we are in some cases going out to talk to up to 3 external APIs in addition to in network API, formatting all the data, crunching against our own business logic and spitting it back out.
\&gt;FP-languages like TypeScript &amp;#x200B; Not to be a zealot, but TS is certainly no FP language. It's JavaScript with static typing. Perhaps you meant a language with heavy anonymous function usage?
I also don't see the benefits. With composer it can be installed pretty easy. And if you don't want to type/paste the command every time, create a composer script
That is easier but sparing one line out of six hardly can be qualified as "much". It's before the argument unpacking operator PDO indeed was superior to mysqli.
If you want to advertise on reddit, [buy ads](https://www.redditinc.com/advertising). Don't spam our communities.
 &gt; $arr = [1,2,3]; &gt; $in = str_repeat('?,', count($arr) - 1) . '?'; implode(',', array_fill(0, count($arr), '?'));
Sure. But only use it for stuff where it makes no difference if it works the newt year/month/week/day. Definitely not for anything that your business depends on. Maybe for a one time use, to get content out of google and into a proper DB, if you for some reason cant use already available options export or copy paste. Or if you just like to code for its own reason.
Nice one .. You a beginner and you want to embark on this mountainous project how much hourly pay ?
LINQ, Streams, Lambda's seem pretty shorthand and *declarative* to me.
$2 an hour
Perfect for single-line closures and for filling in higher-order functions like `array_map`, `array_reduce`, `array_filter`. It could make working with collections a bit less verbose.
How many hours can I work?
How many hours can I work?
Expert development from India, sadly this has not been my experience :(
It's no OCaml, Elm or Haskell, but otherwise clearly designed with an FP-mindset.
I get your arguments, however it's hard for me to accept them :) I remember when short closures came to JS. It was mind-blowing. The code got shorter, more readable thus (IMO) better. In PHP I've been working way to much with nested closures (which I do not recommend). It's painful to maintain it, not to mention that it's hard to read it. With short syntax it may get only better. BTW, callback pattern is quite common now in PHP. I'm not sure why \`fn()\` would impact it negatively.
I am not spamming, only marketing our services. Thanks
&gt; implicit parent scope in closures is a source of massive headaches in languages which have them, like Javascript. I did not experience something like this. The only problem I had in JS closures is when they referred to global variables and mutated them. Although it's not the fault of the closures :) &gt; It can get pretty tricky understanding what's going on, especially in nested closures. I've been working with nested closures in PHP and have to say that with current syntax it's really hard to grasp what's going on. It's even harder to work with it when you need to remember about the `use()` statement. Short syntax will lower the cognitive load which I find good. Will this be overused? Quite possible, yet those are the things which can be defined/verified in development process (code reviews, or automated checks).
This is spam. Your post is both a violation of reddit's sitewide rules and the /r/PHP subreddit rules. Buy an ad.
A secure application plateform should be a business requirement.
Marketing the services and spamming is totally different sir. We don't want to buy an ad and you can't judge on your assumptions our services.
I spoke to both George Banyard (author) and Nikita Popov (who came up with a good way out) on the PHP Internals News podcast: [https://phpinternals.news/8](https://phpinternals.news/8)
There's also the awesome [https://github.com/mediact/dependency-guard](https://github.com/mediact/dependency-guard).
**Problem:** PHP is terrible at templating and dangerous-by-default. **Solution 1:** Argue for years about which templating syntax to use in PHP. Ask maintainers to spend countless thousands of hours re-implementing all of the templating engine features from modern templating engines over the past 20 years. Ask the entirety of the PHP community to refactor all existing codebases to use new open/close tags, because we can't make all current open/close tags encode output by default to make PHP safe for templating without simultaneously breaking output in non-HTML contexts. **Solution 2:** Use a real templating engine. Yeah, I can see how you'd think #1 is the way to go.
you can throw abort(404) if $data is empty but why you don't use a relations between tables and for the IFNULL you can replace with -&gt;withDefault([ 'email' =&gt; 'Anonymous' ]);
also in analytics.php getCountriesViews() and getCountriesRealViews () isn't pluck() useless since you selected both columns already ?
If you wanted to know what I think, you can read my comments, instead of spending suspicious amounts of time constructing elaborate strawmen about *what you think I think*, but in *your words entirely*. If you actually cared about PHP, you'd not mind having a honest conversation about what options lay ahead. What you're doing is not that honest conversation. Instead it's kindergarden level "he said in the mirror" inane bullshit.
wow
PHP will never get on these levels. Not before `array_*` functions are applicable on all `Traversable`s. You hear me, never.
While working on Web Code Sniffer ([www.webcodesniffer.net](https://www.webcodesniffer.net)), we had an idea. Why not create a "Standard PSR2 Encoding Challenge"? With a slightly different version of WebCodeSniffer, we can create challenges : a PHP source code is proposed, a timer starts and the candidate can modify the code and check it as many times as he wishes until the code validator displays 0 errors. The winner is the one who has the smallest time. What do you think ? It could be a good way to learn how to write a clean code.
Toit
Immutability properties, would save a lot of code, specially getters
Everything I said was 100% factual - presented in a humorous way, but factual nonetheless. Your fake outrage is nothing but a distraction, and doesn't impress me. If you had any actual thoughts on how the situation I presented could be avoided, you'd be throwing them back in my face instead of pretending to be offended just to have something to respond with. So, please, go ahead and put me in my place by explaining how we can make PHP a safe-by-default templating language without breaking backwards compatibility on one of the most ubiquitous features of the language (open/close tags). I'd love to hear your "graceful way" to handle this.
I'd love to pass this 'round the office and see the results. :-)
Eh, I'm mostly indifferent, but people racing against the clock to make code look PSR-2 pretty kinda feels like it's encouraging style over substance. Any decent IDE will offer to reformat code to PSR-2 in a couple of clicks, it's really not an important skill vs writing understandable and sensible code.
It's not factual, because it's not a fact that happened, it's a *speculation* based on your limited understanding of what I was trying to express, and your limited understanding on how it can be implemented. Speculation is not "facts". Go look it up in the dictionary. &gt; If you had any actual thoughts on how the situation I presented could be avoided, you'd be throwing them back in my face instead of pretending to be offended just to have something to respond with. I'm throwing them in your face: the templates can be included via a dedicated API, not via "require/include(_once)", just like any other template, thus avoiding all possible concerns about conflicts and B.C. breaks. Here's the simplest possible API, just as an example (and I'm not saying I'd support this precise version): require "foo.php"; // PHP without templating require_tpl "foo.php"; // PHP with templating Another solution is what TypeScript did when they added JSX support, which is literal after-the-fact templating added to TypeScript: they differentiate by extension: foo.ts; &lt;-- TypeScript without JSX foo.tsx; &lt;-- TypeScript with JSX I'm barely scratching the surface. There are literally so many good ways to introduce this, your dismissive behavior only demonstrates you know absolutely nothing about any of them, and you prefer to be smug and ignorant, rather than engage with a fellow developer and learn something.
They were partially removed. For example, you cannot use ASP-like tags anymore `&lt;% %&gt;`
&gt; `sudo` Woah dude, don't use sudo for that. It's veeeery risky.
Easy to install C extensions per project. Pecl is okay, but you can't define which extensions a project needs, and then have them installed for use with just that project.
Yes, but that's not a reason for writing messy code. A good knowledge of the standards and good habits, help to write better code.
The contents of `foo.php` will still be dangerous-by-default, and there's nothing the VM can do about that, even knowing that the code has been included in the context of `require_tpl`. You fundamentally cannot change this about PHP's parsing nature without breaking BC, as I've already said. Could we embed a non-PHP templating language (even if it were 95% identical to PHP) into PHP in a similar fashion and address the problems? Sure we could. But that's not "making PHP better at templating". It's just bundling and distributing decent templating with PHP, and would come with no practical benefits for the developer over just using an external templating language with PHP-like syntax. Your TS/JSX analogy is completely apples-to-oranges. JSX is actually parsed (because it has to be in order to be transpiled), and any expressions within it _must_ be valid JS/TS. This is not at all the same scenario as PHP/HTML, but kudos for trying.
&gt; The contents of foo.php will still be dangerous-by-default, and there's nothing the VM can do about that, even knowing that the code has been included in the context of require_tpl. You fundamentally cannot change this about PHP's parsing nature without breaking BC, as I've already said. You "fundamentally cannot change this" when using Twig either - "foo.php will still be dangerous by default". This argument is honestly nonsense. &gt; Could we embed a non-PHP templating language (even if it were 95% identical to PHP) into PHP in a similar fashion and address the problems? Sure we could. You forgot to say "sorry for claiming the exact opposite last time and mocking you about it". &gt; Your TS/JSX analogy is completely apples-to-oranges. JSX is actually parsed (because it has to be in order to be transpiled), and any expressions within it must be valid JS/TS. This is not at all the same scenario as PHP/HTML, but kudos for trying. I never said anything about "parsing HTML". That's just you being you again: smug and ignorant. The example was introducing new incompatible syntax in an existing language, for the purpose of templating. Would differentiating by extension work? Yes. The nature of the template syntax had nothing to do with the example.
What's the point? I can just hit `Ctrl-Alt-L` in PhpStorm and my code is formatted for me. Remembering all the rules of PSR-2 doesn't help you write better or cleaner code. In fact, I'd say spending time memorizing PSR-2 and following it manually (instead of having your IDE do the work) just takes up time and resource you could otherwise invest in looking at and improving your actual code.
For the lazy: this is pretty much a bug fix release as also can be guessed the from the version number. Nothing worth discussing.
I must disagree, formatting PSR-2 won't help you write better code at all. All PSR-2 represents is a set of arbitrary choices for code naming / formatting so that people have a written style guide to work to so that the style doesn't change for every file. Just because I want to put my elseif on a line following the closing bracket of the if, doesn't make my code "better" or worse than it would be if I had put it on the proceeding line.
&gt; You "fundamentally cannot change this" when using Twig either - "foo.php will still be dangerous by default". This argument is honestly nonsense. What? Wrong. And this comment confirms that you have no idea what "dangerous by default" even means. &gt; You forgot to say "sorry for claiming the exact opposite last time and mocking you about it". You said any example that wouldn't break B.C. would "put you in your place". You gave an example that won't even solve the problem, but yeah, I guess you sure put me in my place...? &gt; The example was introducing new incompatible syntax in an existing language, for the purpose of templating. Would differentiating by extension work? Yes. The nature of the template syntax had nothing to do with the example. You aren't understanding the difference between embedding new syntax into a language and templating. They are not the same _at all_.
&gt; You gave an example that won't even solve the problem, but yeah, I guess you sure put me in my place...? Yes, keep talking about "the problem" without specifying whatever you're talking about. And this coming from the guy who told me "if you knew what you're talking about, you'd explain it". Where is **your** explanation of the "problem"... if you *know what you're talking about*. &gt; You aren't understanding the difference between embedding new syntax into a language and templating. They are not the same at all. I'm talking about embedding new syntax into a language. If you want to talk about something else, that's you coming into a conversation for something nobody invited you to.
That sounds wonderful üòç
The winner is the one who refuses to participate. Doing things manually that can be done automatically is a waste of time.
transducers solve this but are not in core
Thanks for saving me a click
&gt; Where is your explanation of the "problem"... "Dangerous by default" here simply refers to the fact that output is not encoded for an HTML context by default. Most (all?) modern templating languages are safe by default. Output into the markup is encoded for an HTML context by default, and you must explicitly make output unsafe by opting into that behavior. PHP is the exact opposite: output into the markup is inherently **not** encoded, and you must manually encode it. It's dangerous by default. &gt; I want PHP to do autoescaping etc. PHP can't do auto-escaping at a very fundamental level. Not even in the context of `require_tpl`, a different extension, or whatever similar flagging mechanism you bolt on top. What happens when you `include` or `require` another template from within a `require_tpl`ed template? Use any number of dozens of other outputting functions that aren't just the standard `echo`/`&lt;?= ?&gt;`? Output streams with wrappers? Nested buffering? The list goes on and on. Now, you can strip away some of what makes PHP PHP and gain the ability to disambiguate and auto-escape from those sorts of contexts, but then you aren't "making PHP better at templating" - you're creating your own templating language that just so happens to be a subset of PHP, potentially with some syntactical sugar thrown in for good measure. At that point, you've jumped through all kinds of silly hoops just to avoid using a separate userland solution, with gobs of upfront work and maintenance by internals developers required to even do that much. The end result can only be _at best_ comparable to other solutions, with an extremely high development cycle, lack of flexibility due to BC breakage policies, and on and on. The value proposition is virtually nil. &gt; I'm talking about embedding new syntax into a language that happens to make PHP more convenient as a template engine. Either `foo.php` in your examples **is** PHP, or it's not. If it's PHP, then no matter what syntax/niceities you add, you will very fundamentally have a dangerous-by-default, inferior templating solution on your hands. If it's **not** PHP, then you aren't really talking about improving templating in PHP - you're talking about creating a new templating language that just so happens to ship with and look similar to PHP. And that's not what you said originally, and would be ridiculous for all of the above mentioned reasons, to boot.
The RFC actually says this is a viable option. The only bit that wasn't clear in the RFC that I haven't seen addressed elsewhere is that it says a lexer lookahead approach could be viable for the `==&gt;` and `~&gt;` approaches, which is what HHVM uses, but there is a complication: &gt;A complication (and forward-compatibiltiy hazard) is that it is not sufficient to check for just `) ==&gt;`, as we also need to handle `): ?Type ==&gt;` and possible future extensions to the type system. &gt;Using lexer lookahead is in principle a viable option. I hadn't seen any discussion about how much of a complication the type handling would have presented, or if there was another reason for not going with this approach.
&gt; Dangerous by default" here simply refers to the fact that output is not encoded for an HTML context by default. Most (all?) modern templating languages are safe by default. Since I mentioned "autoescaping" several times, which is precisely that, I have to assume you're not even reading what I'm talking. Hence why I've deemed it pointless to talk to you. &gt; PHP can't do auto-escaping at a very fundamental level. Not even in the context of require_tpl, a different extension, or whatever similar flagging mechanism you bolt on top. Wrong. I've actually done it with ob_*() and a very basic transform of the code, which PHP could do in templates natively (to skip T_INLINE_HTML tokens from escaping). &gt; What happens when you include or require another template from within a require_tpled template? Easy... it's interpreted according to how you included it (as a template, or not). &gt; Use any number of dozens of other outputting functions that aren't just the standard echo/&lt;?= ?&gt;? Output streams with wrappers? Nested buffering? The list goes on and on. Easy. They all send to output, hence they're all covered as much as echo is. That said, there's an alternative solution which would be more robust: regular output is forbidden in templates, and only template output functions are allowed (everything else results in an error). This would allow templates to support multiple escaping contexts, rather than just a default one for HTML. This is what I'd do. But both solutions would result in security that's at least *equvalent* or even superior to what something like Twig does while autoescaping. See, you think you're blowing my mind, while you keep showing again and again and again that you've never researched anything of this and you have no clue what the fuck you're talking about. You're literally light years away from how PHP works internally, and you shouldn't be posting smug comments telling other people what can be done and can't be done. &gt; At that point, you've jumped through all kinds of silly hoops just to avoid using a separate userland solution And here you go again, going on an imaginary "here's what I think you think" adventure again. Stop trying, it's pathetic. &gt; Either foo.php in your examples is PHP, or it's not. If it's PHP, then no matter what syntax/niceities you add, you will very fundamentally have a dangerous-by-default, inferior templating solution on your hands. You're just reiterating your above points, which I addressed. You're full of shit.
Being rigorous is not useless.
for those who don't know how to tell when new version if a bugfix or feature release: https://semver.org/
But you need to know how to do things manually before doing them automatically. It's like learning to count.
Yes, that's what I call better code. A clear code for everyone because everyone follows the same rules.
It's just really lacking when compared to something like eslint. I have a configuration file a mile long that doesn't do half the stuff my eslint config does for my js code. It's really hard to discover what rule there is and how to configure them, again comparing to eslint where rule discovery is really easy [https://eslint.org/docs/rules/](https://eslint.org/docs/rules/). Finally the tooling around it is a bit clunky, the addon for vscode that I use uses a lot of ressource and at least once a week it stops working for no reason and I have to restart my editor.
I understand your motivation, because you've obviously invested in the tool you've made, and for those who don't have one of the auto-formatting IDEs available it may have some use. That said, I would strongly discourage you from conflating code quality, with PSR-2. These are two very different things. PSR-2 deals mainly with whitespace, and is therefore, by definition, almost 100% irrelevant to the quality of the code itself.
Being rigorous about using PSR-2 is great, but doing it by hand instead of automatically is just pointless. If you wanna read through PSR-2; fine, whatever. But memorizing and manually applying it all is a waste of time.
The idea is not to memorize everything. The idea is to read the errors displayed and to correct them accordingly. It's a way of learning and acquire good habits.
I know. That's two different things. Here "better code" means a code that follows the standard.
tl;dr: When the first number changes, all your code is broken. When the second number changes, your code should usually be fine, but you have new toys to play with. When the third number changes, if you had code that was broken but shouldn't have been (by a php bug) it might have been fixed now. My rule of thumb is you can upgrade patch versions without thinking of it, minor versions with some testing and looking at the migration guide (there's occasional BC breaks), but with the major version prepare for extended testing before upgrading.
Yeah, but I don't think you're supposed to learn how to write code that conforms to PSR-2 by hand. It's like learning to open a can with a rock when you could just use a can opener. Tools exist. They're useful. Please use them. Focus on being good at the things tools can't automate for you - those are the important things.
I *do* know how to encode/decode base64. I *do* know how to use telnet to issue an HTTP request and read the response from slashdot. I *do* know how to do bitwise math in my head. I *do* know enough ASCII codes to convert hex to text and back. I **don't** spend all day doing those things manually. It's well and good to know what you're doing and why, but once you learn it, you are not required to do it manually all the time. Code is not artisanal woodwork, it won't magically be *better* (what does that even mean?) just because you lovingly polished and positioned each `{` by hand.
PHP 4 to 5 wasn't really too painful. I've been doing some testing on a fairly extensive legacy codebase that is locked at 5.6 and haven't had as much trouble as I expected targeting 7.2.
That's what the website propose, a tool that automatically shows the errors. You see the list of errors and then you know what you did wrong. If it's completely automatic, you don't even know if you did anything wrong, and what you did wrong. I'm not saying that it is what you are supposed to do everyday when code. But it's a thing that you should do at the beginning when you learn. The main purpose is learning.
It really depends on your codebase and how well maintained it was to begin with - it took our team of five part-time workers around a month to jump from 5.3 to 7.0. It's definitely more time and testing than a minor release would bring.
I'm not saying that it is what you are supposed to do everyday when code. But it's a thing that you should do at the beginning when you learn. You *do* know how to encode/decode base64 but you had to learn first. The main purpose is learning. Putting each \`{\` at the proper place is still better than putting it anywhere.
One thing it looks like you've forgotten is that JSON isn't always an object. `json_encode("Hello world!")` provides the valid JSON string `"Hello world!"` which will fail in your library. Your code isn't namespaced or even included in a classmap in your composer.json so you can't actually use it in a project. `$parent++` does not do what you think it does. You're incrementing the value yes, but after it's returned: ``` $i = $y = 0; var_dump($i++); var_dump(++$y); ``` Also you're borking possible valid values. If you put in a phone number `0800422422` your code will automatically change that to a number and you lose the first zero. The types coming from JSON are definitely going to be correct, you don't need to check that like you would for POST values. Just checking the actual type would be better. Your HTTP client uses the Firefox user agent, and I can't quite see why. Why not just put the user agent as the name of your github repo? Also, you're not handling non-200 responses correctly. If you get a non-200 response, Guzzle won't throw an exception so the response array is just going to be an empty array. You're also asking to check two fields, `success` and `error` to see if something has failed. Why not just use a single field? Your client is setting the `Accept` header to `*/*` but only handling `application/json` responses. You should set the accept header to what you're actually accepting. Please don't turn off verifying SSL certificates, this is really dangerous in a production environment. If you've got a domain name (they only cost about $10 a year) you can get free certificates now using certbot so there's no reason to not verify valid certs.
I disagree. It's exactly the kind of thing you shouldn't worry about as a beginner, because you have so many (much more important) things to learn. Why should a beginner spend any time learning the details of PSR-2 when he could be learning how to use composer, how to use dependency injection, or how to use PDO instead?
from the README.MD &gt; I was working on wordpress project...
What is "the proper place"? If you ask PSR-2, you get one answer. If you ask K&amp;R, you get another. If you ask BSD/Allman, you'll get yet another. There is no fundamental "proper" place, only the place prescribed by your convention. Things you *do* need to learn about conventions like this: * Why? Because it always formats the code consistently. Why? Because it is easier to read. Because it makes merges and collaboration easier. Because it prevents some weird syntax traps. * What? The convention we use for this project is called 'PSR-2'. * How? The instructions to format your code automatically can be found at &lt;http://...&gt;. Things you *don't* need to learn about conventions like this: * how many spaces are needed before `{`? This is useless noise your tools can sort out for you. For some things, attention to detail is crucial. For others, understanding the concept is key and low-level details are irrelevant. Instead of learning every single trivial detail, learn to distinguish between the two cases, and to operate at the appropriate level of abstraction.
"Beginner" ? I've never talked about people starting to learn coding. I said, when you begin to learn something. Here, coding standards. When you begin to learn coding standards, you need to practice ... by hand. And it can be fun to propose challenges to learners to motive them. That's all.
The proper place is where you boss and your team say where it is supposed to be. If your boss and team say we've decided to follow PSR2, you have to do so, then you follow PSR2. And if you don't know PSR2, then you learn PSR2. You don't just put things anywhere and ask the machine to clean up you're mess if you want to do it intelligently. You're right, you don't need to know all details, and I've never said the opposite. Learning coding standards is boring. So, challenges can be fun and motivate learners. That's we proposed in the thread. Nothing more.
&gt; _You don't just put things anywhere and ask the machine to clean up you're mess if you want to do it intelligently._ lol k This discussion is not getting anywhere.
I replaced some bad code at a previous company which was causing a report to take hours to run, basically, the chap who wrote it had iterated over an array to add thousands of `WHERE field = ? AND field = ?`, etc. Replacing that code with almost a carbon copy of this (in PDO mind, not MysqlI) made it run in seconds instead.
Are you sending the raw JSON from the files to the browser via PHP, or are you pre-processing them first?
You don't have to wait for 7.4 Given your conditions, a regular opcode cache would do. I would write a simple converter, JSON2PHP to make PHP files out of JSON files. As a part of the deployment process, you can convert all your JSON files into PHP scripts that would contain corresponding arrays/objects. On the first load these files will be stored in the opcode cache which should be enough for the time being. Once 7.4 is out and you feel the performance is declining, you can eventually add these files into preload.
Neither. I get the users location from the account DB, iterate over the file to find the location in PHP, process the users request (are they travelling? are they in combat? are they buying something from a vendor?) An example location response to the user: {"message":{"location":"caerina_stitchhill_slope","description":["[!&amp;gt; Stitchhill: Slope}]","The [[return to the base||base]] of the hill some half a kilometre behind you. All around you, Wild Rabbits frolic in the grass (which you may [[attack the rabbits||attack]]). You can't see behind the hill, but the [[ascend to the summit||summit]] ahead towers over the horizon."],"effects":["day"]}} As you can see, this is very unwasteful. My performance question is _purely_ backend, and isn't an existing issue - at the moment the performance is BLAZINGLY fast, I just want to know if 7.4 will make it even faster.
That seems like a reasonable solution (if there was an existing problem), though I'll probably wait for preload in 7.4, I imagine that will be released before I hit any unacceptable latency thresh hold, rather than spend time writing code I don't need yet. Premature optimisation and all that.
Wait, you aren't going to preload JSON files *as is*, are you?
I'm not 100% certain on whether 7.4 would help however I would imagine there would be improvements that could be made to the JSON files to make them more accessible. i.e. /u/colshrapnel's suggestion seems interesting. I would be changing the JSON files to store the coordinates as keys, allowing you to quickly pull whatever information you need from that location and also easily pull surrounding locations. It's also possible to load the data into redis or similar, that is shared across all requests and optimised.
In 7.4, if possible, sure. The files need to be loading on almost every request anyway, so if that can be done once in PHP-FPM rather than on every page load it should be a huge performance boost.
That's already in there, the locations are stored in indexed arrays which are accessed by ID. Performance wise, like I said, it's already really fast (an end-user response time of 12ms is pretty good), but this would shave 1ms off the load time, theoretically. This is less "I have a problem" and more "this feature looks cool, is it applicable" :)
But in your case you're unlikely wasting CPU cycles: your system is I/O bound and mostly waiting on the network, except the last crunching step. Any timeout happening in your scenario can easily blow up your entry HTTP request anyway up to multitude of seconds unless you set them all very low but in which case you wouldn't wait enough for your data to process it I guess.
Beyond what you're doing, I imagine it's not going to help in this instance. I'm sure someone who's had a proper play around with it will be able to help though :) Sounds fun either way.
&gt; You don't just put things anywhere and ask the machine to clean up you're mess if you want to do it intelligently. I'll admit, that if there's a space before the opening bracket of my for loop, is certainly on my list of priorities while I'm writing code which could make or break the company. It's somewhere on page 17, right after decisions on if I should have my next cup of tea now, or wait until I'm half way through the night on an 18 hour coding binge.
JSON is not only have to be loaded on every request but also parsed into a PHP array/object at every request as well. And the bigger it grows the more resource-consuming it gets. So being as much concerned with performance I though you already addressed this rather obvious issue.
Just convert them to PHP arrays, and put them in a file. Opcache will take care of the rest. echo '&lt;?php return ' . var_export(\json_decode("YourDataHere"), true) . ';';
Is there really so much to explain that you need a 20 minute video? https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/association-mapping.html#one-to-many-self-referencing
Thank you for the info ppl.
but thats not better code. You can still write shitty code that follows a standard.
If you're using **EasyDB**, you can also use `EasyStatement` to shorthand this even further. https://github.com/paragonie/easydb#generate-dynamic-query-conditions Write less, do more, accidentally side-step entire classes of security vulnerabilities without realizing they even exist.
It would have been too hard to parse.
This is the right answer! You may need to wiggle with Opcache Interned Strings Buffer given the size of your files. [https://www.php.net/manual/de/opcache.configuration.php#ini.opcache.interned-strings-buffer](https://www.php.net/manual/de/opcache.configuration.php#ini.opcache.interned-strings-buffer) and probably also increase the overall memory of Opcache to store files (which does not include the interned strings, but does include the static array definition): [https://www.php.net/manual/de/opcache.configuration.php#ini.opcache.memory-consumption](https://www.php.net/manual/de/opcache.configuration.php#ini.opcache.memory-consumption)
Rather than relying on PHP itself to keep data available across different requests, perhaps you could look to a tool designed specifically to keep data structures in memory. The first such tool that comes to mind is Memcached. [https://memcached.org/](https://memcached.org/) [https://www.php.net/manual/en/book.memcached.php](https://www.php.net/manual/en/book.memcached.php) It's a key/value store that does a best effort to keep recently accessed data in memory. Its primary use case is exactly what you're looking for: Store data that rarely changes, that is accessed by multiple processes on the same server, and that can be expensive to read from disk (or from network, or from the DB, etc.). In order to see the same benefits from PHP itself (and it would already be as fast as it will possibly get, with existing PHP opcode caching, so you don't have to wait for 7.4), you'll need to hard-code your JSON as values in your PHP scripts... That is, you'd have a file like &lt;?php require_once('caerina.php'); require_once('netherworld.php'); require_once('nowhereland.php'); require_once('seaofgreen.php'); and your region PHP scripts: &lt;?php $caerinaStitchhilSlope = '{"location":"caerina_stitchhill_slope","description":["[!&amp;gt; Stitchhill: Slope}]","The [[return to the base||base]] of the hill lies half a kilometre behind you. All around you, Wild Rabbits frolic in the grass (which you may [[attack the rabbits||attack]]). You can't see behind the hill, but the [[ascend to the summit||summit]] ahead towers over the horizon."],"effects":["day"]}'; I would personally choose to use a secondary in-memory cache application like Memcached; each PHP process will take up far less memory, and I can invalidate the cache for the entire application without relying on the PHP processes to be recycled... but the tradeoff is setting up and maintaining a separate service on my server, and writing code to first check the cache and, if the cache misses, to pull from the authoritative source (disk, network, database, etc.), then populate the cache.
that ... makes the difference. Nice syntax will refactor tomorrow...
Junk response
As others have said Memcache or Redis might be the better place to keep things in memory for faster access. If you want to preload microservice style take a look at Swoole. I did a YouTube demo of it called "PHP Expressive Microservice Training". https://youtu.be/atHmkjdcf6o
I'd use an object database/caching solution. It would perfectly scale and would probably be more performant in the long run. If you'd use a cache you could have it dynamically restore the data if a TTL has passed.
As a user which uses more other programming languages I would favor an even shorter version, but the syntax is okayish. Instead of: function array_values_from_keys($arr, $keys) { return array_map(fn($x) =&gt; $arr[$x], $keys); } I would like the shorter Rust syntax: function array_values_from_keys($arr, $keys) { return array_map(|$x| $arr[$x], $keys); }
The problem is, there is nothing to invalidate. It's static files.
&gt;FP language I still it's just wrong to call it FP. It may have many FP functionality but it is clearly an OOP language by design.
Those kind of MYSQL wrappers have very easy-to-use solutions.
Is it AND or OR? (I think `field = ? OR field = ? ...`) However, IN queries are faster for checking for array-like values AFAIK
Everything is static until you change it. OP said they want to add more files. Based on the snippet of code they shared, it looks like they'll also have to edit their existing files to allow them to link to new areas as those areas are added. If they're using FCGI (default with Nginx; many hosting providers set Apache 2.4 up this way) to handle PHP requests, they would either have to restart their web server to kill the persistent PHP processes it spawned, or will have to wait for these persistent processes to recycle over time, which would give an inconsistent game state.
Assuming PHP followed semver, which it doesn't.
You gave a perfect example of a generic answer which is correct by itself but completely useless for the OP. And now you started to imagine conditions never stated in the question. This is what I call a useful discussion.
From OP: &gt; I'm wary about the future of the game as regions expand and more features / content are added. Am I imagining that the OP posted that? (Sincere question... If the answer is yes, I need to go find a psychiatric professional.)
Anyone using Pre. for development?
You rather need some experience with gaming/gamedev. Or even webdev that is a bit more advanced than editing files over FTP right on the production server. Locations and features are not added on the fly. In reality, new JSON files will be added during the deployment of a new version. Which will include the process restart and opcache reloading anyway. So you are solving here an imaginary problem.
Beginners appreciate the verbosity, according to comments.
The answer is no. Because I don't code in Notepad, so custom syntax doesn't fit in my workflow. Not to mention the complication of adding a compiler toolchain just for that.
We're using Guzzle Async promises to run HTTP requests in parallel, so we are only as the single slowest API request. Four seconds being the worst I've seen, with two secounds more common. But yes, we are still to bound to the slowest API. Not really a way around that until I have time to create a robus cache layer, which will take a lot of planning and time to execute.
I completely agree with this approach. To one-up it though, because I hate the output of `var_export` (it's so damn ugly, looks super legacy), is to use this lib which was recently released which does a better job of giving clean output. And it supports basic closures! https://github.com/brick/varexporter
Thanks for saving me of thanks
I agree with you - but just saying that if you're using a templating engine, you already have a 'compiler toolchain'.
If I add a PHP preprocessor, now I have two compiler toolchains. Also I'd never use a template engine without IDE support, so there's that. Maybe if 7.4 support rolls out for IDEs and so on... but by the time it rolls out, I'd just be able to install 7.4 on the server.
&gt; Since I mentioned "autoescaping" several times, which is precisely that, I have to assume you're not even reading what I'm writing. Hence why I've deemed it pointless to talk to you. You _just_ got done saying Twig was as dangerous-by-default as PHP is, and now you're confirming that you know dangerous-by-default languages don't auto-escape. But Twig clearly does auto-escape and is safe by default, so the disconnect is absolutely on your end. &gt; Wrong. I've actually done it with ob_*() and a very basic transform of the code, which PHP could do in templates natively (to skip T_INLINE_HTML tokens from escaping) and much more efficiently than what I could do in userland. If you're using `ob_*()` and tokenization to transpile PHP, you're already "in userland", so claiming that it's more efficient than what you could do in userland is as confusing as it is ridiculous. Anyway, no; you haven't done it. You _think_ you've done it, and that's because you took the happy path and ignored all the complexity that makes this _actually_ impossible in PHP. You've effectively taken a string replacement one-liner a step further. The language has many oddities and mechanisms for going around what you clearly think is a comprehensive solution. &gt; Easy... it's interpreted according to how you included it (as a template, or not). That was the whole point of having two different functions for it. Intent is clear. Intent being clear is a given. But, as I pointed out, intent is not enough in this scenario, as you're bound by the language itself, regardless of whether you know what's being interpreted is a template or not. &gt; Easy. They all send to output, hence they're all covered as much as echo is. This huge problem you think is there... isn't even there. Oh, it's there. You're just not thinking beyond skin-deep, so it isn't readily apparent to you. Maybe what you've made satisfies your own use-cases and that's good enough for you. Great, I'm glad. But it's not exhaustive, and anything implemented in the VM would have to be. &gt; That said, there's an alternative solution which would be more robust: regular output is forbidden in templates, and only template output functions are allowed (everything else results in an error). This would allow templates to support multiple escaping contexts (for example, automatic JSON output in JS context etc.), rather than just a default one for HTML. This is what I'd do. If "regular output is forbidden in templates" then you're no longer talking about a template at all, but rather code generation (possibly not too dissimilar from JSX compilation, depending on what you had in mind). It would also no longer be PHP. &gt; And here you go again, going on an imaginary "here's what I think you think" adventure again. Stop trying, it's pathetic. The "you" in that specific comment you quoted and replied to was clearly figurative. It's blatantly obvious that it would not literally be **you** implementing this in PHP, if it were to happen. &gt; If we worked together you'd be a junior under me, you simply don't know enough to be arguing with me on this topic. Ah, yes. Everyone knows that the more wise and experienced a developer you become, the more fragile your ego becomes, the more vulnerable to criticism you become, and how much stronger the urge becomes to impress upon those around you your absolute superiority and dominance.
&gt; You just got done saying Twig was as dangerous-by-default as PHP is You really need to work on your reading comprehension. I'm tired of this game of "but you just said we should all eat babies" you keep pulling off in every comment. Just fuck off.
Yup, like I said, I agree. Just wanted to say that in this case the 'compiler' isn't very much work to set up and doesn't require any additional dependencies. pre is also not for me, like you said, because it's non-standard and doesn't have great IDE support. Too much existing tooling that works specifically with .php files. CS Fixer would break as well, for example. Code analysis becomes trickier.
Whilst it's not written in PHP, I can tell you now that most of my day involves writing migrations in PHP. I'm going to eventually work on a client (A vim one, sorry guys) that will make this linter work on SQL inside of PHP. Anyway, I hope you like it, bugs/suggestions and anything else are welcome!
I think you pointed to a nice tool. In this case you have json to look at. phpstorm and other tools can reformat both formats nicely if you want it to. The php files are just for the interpreter so no need to waste cpu cycles on the looks just because you MIGHT look into it ONCE. ;-)
+1
Are there any benchmarks available? Looks interesting.
Had no idea this was a thing in PHP, cool!
Of course I could run CS Fixer on it or something, but that's an extra manual step. I'm thinking of a usecase involving automatic data generation as the output of some web UI used to edit the data. That sort of thing. Committing the data to git is a good way of keeping track of the changes to the data, works well to keep history for auditing, and you get the advantages of the opcache.
I agree. OP has that in json files it seems. So the php files are just for caching in this special case and so there is no need for versioning theese redundant files into a cvs.
Yup, for sure. I know OP isn't the only reader of this thread so I'm just pointing out some potential applications for anyone else who might find it useful :)
me: *What misguided basic info will this self-promoter share just to advertise his blog?* *\* reads the guide \** me: *Holy f\*ck I knew nothing about array destructuring!*
:-)
Ironic, that site shows all errors publicly.
Nice [impl leaks](https://prntscr.com/njo9cw) dear *u664830366*
I'm sorry, the server is down. I couldn't even connect via FTP now. Edit: Hopefully it's fixed now
`[$a, $b, $c] = [1,2,3];` Done, what else do you need to know?
For now, please see this. [https://web.archive.org/web/20190502191620/https://developer.hyvor.com/php-list](https://web.archive.org/web/20190502191620/https://developer.hyvor.com/php-list)
Don't use list()! Shorthand is bad, readablilty is everything. Programmers spend 60 of their time reading code and 40% writing it, so shorthand that make things hard to read is doubly bad.
Destructuring Associative arrays, mutli-dimensional arrays and using it in Loops!
I'm glad you learned something.
Thanks brakkum!
I agree with you that the shorthand makes confusions. I have told about it in my article. However, what do you think about this example? &lt;?php $people = [ [ 'name' =&gt; 'John', 'age' =&gt; 20 ], [ 'name' =&gt; 'Callum', 'age' =&gt; 17 ] ]; // the old way /* foreach ($people as $person) { echo $person['name']; echo $people['age']; } */ // new way foreach ($people as ['name' =&gt; $name, 'age' =&gt; $age]) { echo $name; echo $age; }
90-95 reading to 10-5 typing is a more realistic ratio and was cited by Robert Martin in Clean Code (iirc, could be another book). How is it hard to read though?
I wanted to read this but I was bombarded with ads on my phone. To the point I couldn't focus on the subject matter due to the several moving and vibrant ads. Shame.
This isn't bad, but it doesnt use list(). I think the old way and the new way are not much different. I think the old way is clearer, it makes it clear that variable come from the array especially if there is more code in the loop, not that there should be; the loop should call another function or method if there is more work to do.
e.g. fireEmployee($person['name'], echo $person['age']);// not fireEmployee($person) I suppose fireEmployee($name, echo $age); is very similar.
Could be time for a change, though. I remember when ternary operators were "unreadable" and then lambda functions were "unreadable," and then when the new array syntax was "unreadable." Honestly though, I still avoid \`list()\` because it just seems kinda "hacky."
Yes, Ternarys are awful. Lambda functions are bad. I don't think the new array syntax is unreadable, but I was just saying that list() is terrible and I agree very hacky. The quicker you can understand code the first time you look at it the better; KISS. The shorter your functions or methods are the better just to make them readable, but shorthand ruins this effect. Abbreviating variables while keeping semantic meaning is the worst it leads to libShtHere(), which is soon gibberish, just to save a few character strokes.
&gt; it doesnt use list() it uses list()'s shorthand, which is also list().
I also noticed that in-article ads are a huge distraction. I'll find a solution very soon. Thanks for the feedback.
&gt; Where did I say "Twig is as dangerous-by-default as PHP is" Okay, sure. I started off by saying: &gt; **The contents of foo.php will still be dangerous-by-default**, and there's nothing the VM can do about that, even knowing that the code has been included in the context of require_tpl. **You fundamentally cannot change this about PHP's parsing nature** without breaking BC, as I've already said. ...to which you replied: &gt; **You "fundamentally cannot change this" when using Twig either - "foo.php will still be dangerous by default".** It's as clear as day, friend. But you don't _need_ to change it about Twig, because Twig _isn't that way to begin with_. &gt; The rest of your comment is also full of complete bullshit statements arguing with something I didn't say Coupled with your immature personal attacks and irrational rage, it sounds more to me like your deck ran dry, and you can no longer keep your house of cards propped up, so you stopped trying. &gt; Yes I said [...] I said [...] I didn't say [...] Oh, please. You keep continuously editing your replies after-the-fact, often _drastically_ and long enough after you originally post them to get edit flagged. Literally every single reply since your first to me now has been edited in this fashion. If you don't know what you want to say, and can't cope with being criticized for what you originally post, maybe pause and take some time to think hard about your next reply before you hit that Save button. It's not a race. &gt; I'm done Yeah, I know. You've told me several times now!
Yeah, but it is clearer than using list() itself.
That was awesome! Thanks
Every time my edits have stopped long before your reply, troll. There‚Äôs a timestamp on those edits you idiot. And the timestamp is before your reply. So now your excuse about your lack of basic comprehension of English is that I edit. Retard.
I don't know if you think my replies magically and instantaneously appear, but I can assure you that they do not (would be nice, though). When you reply to me, I open your comment, read it, and click reply. From that point until I hit "Save" can be many, many hours, as you can see. I do not sit there periodically refreshing just to make sure you haven't pulled the rug out from under me. If you want to say something, think it through and then say it. But, hey - maybe "speak first, think later" is another one of those graybeard pearls of wisdom you can teach me someday when I get promoted to junior developer and can finally work for you.
Well... Depends. Symfony is undergoing some optimizations and changes to speed things up for new developers. Search for: symfony flex, webpack encore, maker bundle, doctrine. ( Stay in the quite new 4.x branch and avoid old articles ) It took me 2 weeks to get comfortable.
Are you saying you can't understand this: list($name, $age, $uni) = $profile; But are okay with this? [$name, $age, $uni] = $profile; That makes no sense. I'm guessing you has a bad experience with an IDE not understanding list() 10 years ago and you've been against it ever since.
Just yesterday I did a deep dive into how list (his shorthand) works because I wrote a statement that I was sure should work but it didn't. Half an hour later I noticed I declared variable with name $ine instead of $line and the list worked fine the whole time...
it's become a common idiom in javascript, so it will likely get more common in PHP soon, and with it, more recognizable.
Yeah I thought same thing.
Actually in many cases it can make code more readable.
I think you may have forgotten about *extract (*[https://www.php.net/manual/en/function.extract.php](https://www.php.net/manual/en/function.extract.php)) and it's sister *compact* ([https://www.php.net/manual/en/function.compact.php](https://www.php.net/manual/en/function.compact.php)). What makes me nervous though, is if an array comes back from an API doesn't have a key you're expecting could cause unintended side effects. To me, it's a better approach to check for the key directly using *empty()* or *isset(),* and then accessing it directly instead of letting the language handle it in this way. I feel like it's asking for trouble. Though I do see the appeal of breaking numerically indexed arrays out into variables, but say a key is missing in the middle of the array...then your age variable could instead contain the university. You would still have to handle that case, thus kind of defeating the purpose and convenience of breaking it out in the first place. Also, you're doubling your memory consumption by copying values out of the array unless you actively delete the array once you've performed your destructure -- but that adds **more** complexity to your code. I also see the appeal for using it in foreach loops, but I could also see that exploding hard core if the array structure was missing a key. Incoming data **do** contain errors from time to time. I could be wrong in my assumptions and it just boils down to programmer preference, but I just don't see the practicality or safety of using destructuring in this way. I do, however, appreciate the article taking the time to demonstrate these language features in depth. I hope healthy criticism is appreciated!
I didn't see all the extra replies in sub-conversations, but this response is correct. I'll be deploying using CircleCI / Chef / Ansible / Packer / Terraform to AWS, same as my work production websites. Config is checked in to the repo and loaded to the server once, replacing instances / infrastructure is done with blue/green deployments.
"We are a small team of Sri Lankan developers and graphic designers who are working to reach an aim: Introduce the world's best private messaging app on 25th of November 2019. Our target is to help people with private communicating. We are doing our best to shape our messaging app to connect people, not to separate them." I really don't think privacy advocates should be loading in ads from google.
At least they're using prepared statements though
They're all the same as my example, you just map out the array as you expect it... My example is array, want it associated? do it associated \`\[ 'key' =&gt; $val \] = $a\`, want it multi-dimensional? do it multi-dimensional... want it done in a condition? works in loops and if statements (you didn't have that in your examples), it feels obvious to me? its mapped variable assignment I guess it's cool but it's been around for a while now, using this daily for over a year it doesn't feel like it needs an ad heavy article.. It's as basic as using short arrays, or using stdclass.. in my opinion anyway.
Not the person you‚Äôre responding to, but I think the latter (newer) syntax is indeed more readable. It‚Äôs a syntax that other languages use, and not one of the handful of weird language-construct-that-looks-like-a-function oddballs. I understand both just fine since I write a lot of PHP. Only one of those will be intuitive to someone with a background in other languages.
Smort.
Do this, except put the actual array data in the file. With optcache enabled this will be very fast. Once your data is to big, split it in multiple files.
Is that because you were using include instead?
I think it really hurt the readability in some examples (associative, nested), helped in others (foreach loop) and the numbered case it looked like it'll depend a lot on a case by case basis. I guess it's fine overall to have an option since we don't have to use it in the cases where it hurts readability. I think those cases are the cases where it's too much text before you get to the ` = $array` that most clearly tells you that you were supposed to read all of the preceding syntax a different way.
Ah, in that way. Yes, I agree. It goes to show that writing proper documentation is really hard I guess. The xml format for the configuration is much more verbose than javascript/json. I ran into a similar issue when trying to write a test for a sniff I built; not until I talked to a contributor at a conference did I find out about tooling for that. But there‚Äôs of course nothing stopping you from trying to improve the documentation in a PR. I have no experience with the vscode plugin - I use PHPStorm, which is pretty solid with phpcs in my experience- but I do have similar experiences with the aws cloudformation linter for vscode. So maybe in that sense vscode might also be a factor in the crashing. I am by the way in no way affiliated to phpcs. But I‚Äôve been working with it recently to set up a ruleset for my employer.
I agree in principle, but in practice I've seen list() simplify implementations, rather than make them more difficult to read... &amp;#x200B; Also in the thread: sad peeps without a way to block ads 8)
That looks interesting! Have you thought about implementing rotating encoding? It is used in DNA encoding and prevents consecutive "digits", but decreases the base by 1. With a lot of words, this decrease does not matter at all and would prevent something like "LuckyLuckyAutomaton".
If the JSON data is static, use a webserver or a proxy cache to handle the caching. That way you will skip php overhead entirely and you have quite a few options to optimise.
This. The prs are going to be declined if you use list() in our company.
Is your question is regarding BrisPHP meetup held in Brisbane?? Talks Topics : 1. Find out what's been happening in the last 3 months in everything PHP! 2.Tips around how to guide mentors, paired programming and helping juniors grow in their careers. if you had submitted a GitHub issue you have an opportunity to win the voucher.
I've never used `list()` or this type of array destructuring ever. Why? The simple fact is that I would never return a data structure like: ``` $bio = ["John", "Doe", 32, "Developer"]; ``` Because how do you error handle when you have no guarantee that the order remains unchanged? How do you elegantly access something like "the last name" without defining another dependent like a const (`const LAST_NAME_IDX = 1`) or just the plainly unclear `echo $bio[1]`? A associative array has all the benefits and requires no constant extraction just to be clear. For these reasons I consider `list()` something to be wary of, and to only use in the rare cases where it actually shows real benefits.
I agree that some uses of list() and its shorthand seem less readable. But I have to say that the foreach usage demonstrated here makes total sense to me and seems very readable. foreach ($users as \['id'=&gt;$user\_id,'username'=&gt;$username\]) { echo $user\_id; echo $username; }
This is not JSON intended for the front and. It's sort of a database intended for the backend.
Nice! Will try it out.
Nice write-up. Btw, it is called language construct, not language construct**or**
Why would you ever pass an echo in to a function like that? that looks janky as fuck
Any chance this could be looked at? My PR is falling further and further behind.
I've been working with PHP for around 5 years now, particularly with the SilverStripe framework. I am having some trouble getting into unit testing, not to mention TDD. I work at a very small web agency where it often does not pay off to write unit tests for projects (no time is budgetted for it). Whats the best way to get around trying to learn TDD? I feel like writing a bunch of tests for existing projects doesnt really reflect true TDD. Any tips?
Hey - there are a few steps you can take working towards TDD. I would start by writing a unit test for a function every time you are required to update it. Your test should initially be failing (as you are writing the test for the new desired functionality). Now you update the functionality so the test passes. Now when you are adding new functionality make sure you write tests for everything. Eventually when you have done the above enough you should be comfortable enough to write tests before the actual code.
For the first experience, Laracasts have good videos with TDD [https://laracasts.com/series/build-a-laravel-app-with-tdd](https://laracasts.com/series/build-a-laravel-app-with-tdd) you can try. I'm not big fun of Laravel but to understand this approach this videos is good.
You're going to have issues with running this at scale. Firstly, the way you generate URLs is going to get exponentially slower as you add users. You're using 6 chars of randomness, but it's always 6 long: ``` do { $short_url = Str::random(6); } while (Url::where('short_url', $short_url)-&gt;first() || $this-&gt;isUrlReserved($short_url)); ``` So you'll be fine with a few thousand users but hit more than that and you'll start to get a lot more collisions. Look into the birthday problem, you'll see that with 10k urls, you have a collision chance of 15%. Each collision causes a query to the DB, so you'll start to DOS yourself by checking the DB. Most URL shortening services work on a number base system when creating new links, as you can convert to and from that without having to do an expensive text search in the DB . Think of it like base64 encoding, but more concise. You should be converting your short URLs into binary or integer data so you can get the full benefit of the DB indices, then just incrementing the rules. The other problem I can see is that you don't lock the table between generating the ID and storing it in the DB. There's a chance that another user could generate the same ID at the same time and the second one to save would fail.
The Laracasts series on testing PHP is also great for learning TDD.
Yeah I also learned some other concepts from Laracast, even though I have never used it in a professional setting. Will check it out
Thanks, sounds like a plan. The problem is however, that there is no time for that on the job.. So I have find out how to learn it some other way
Found this very good too. There's another one on building a forum I think but I haven't gotten to it yet. (It has over 100 episodes if I remember so it's a little intimidating!)
Fixed the typo. Thanks :)
Not an ad but jeffry way has a great TDD course. From scratch you may check that out
Yeah now if only they had a sensible order for the array and the closure...
The more tests I make the more efficient I become in writing the actual test. And using TDD actually makes me write the actual code a lot faster. &amp;#x200B; This is also what I've heard from other developers, yes in the beginning it will take you longer to develop but at some point it will take you an equal amount of time or very close to it. Also you shouldn't forget that in the end having tests will save you a lot of time. Unless you write perfect code without bugs and never gets any new features added to it ;)
This course by Adam Wathan is excellent: [https://course.testdrivenlaravel.com/](https://course.testdrivenlaravel.com/).
That sounds interesting. Do you have an example of how exactly it would be implemented?
Hmm you say you want to learn TDD but then there's no time with your current job. It sounds like you might not understand the concept of TDD. Even done poorly, a test first approach can significantly reduce the amount of work you and your team is doing by cutting out a lot of the unnecessary programming that goes above and beyond what your applications need. It's also worth noting that TDD is extremely difficult in situations where you don't necessarily know what needs to be done. Eg, almost everyone has experienced the "make me a Facebook" type of request, where you're left to invent things and showcase them as options for what people might want. That usually creates a lot of churn, technical debt, and unsupported underused applications that are a headache to manage at best, and huge security liabilities at worst. You need to know what should be developed up front. I personally bridge the gap by requiring some sort of acceptance criteria on any feature request no matter who it comes from. Then it's just a matter of inverting the acceptance criteria and turning them into assertions and the tests are practically defined from the requests alone and all you need to do is flesh them out a bit and then you're ready to write your implementations. TDD can help prevent a lot of bad habits, but it's more than just a technique. You can't force it either. It fits well with a culture of planning and understanding what needs to be built and imo it's not worth trying to do if you're doing a lot of inventing, because you'll end up rewriting tests so often, it'll drive you insane.
As you say, "You cant force it either". I'm finding it very hard to convince my boss to make time for any testing what so ever, not to mention TDD. And since I am inexperienced with it, even if we did use it, it would (to begin with) increase our development time by a whole lot. I am 1 of 2 developers at this small company, not a whole dev team :)
Agreed, it's pretty niche, maybe if you're returning some positions, or a math map... Or maybe CSV parsing but there are way better ways of it. List is very niche, I'm shocked so many people are unaware of in this thread, it's been around for over 2 years...
Check out Uncle Bob's Clean Code series. Also, buy the books.
Use lambda's makes it so code is more maintainable and reduces bugs and cognitive overhead. Not the other way around. This would probably be the traditional approach that I find everywhere in code reviews or many open source projects public function getLastGroupWithType(GroupType $type) { $last = null; foreach($this-&gt;groups as $group) { if ($group-&gt;getType()-&gt;equals($type)) { $last = $group; } } return $last; } The problem I have is that right here you are explaining your computer how to get the last element in a collection that matches some criteria. But this code is probably going to be repeated everywhere throughout the project. Why would we want to explain our computer how to get the last group with a type. I just want to tell my computer what the last group with a type is. In the sample below the logic that describes how to get the last element from a collection that matches a some predicate is taken care of by the last function. The only thing that we need to do is explain to the last function what the criteria is. public function getLastGroupWithType(GroupType $searchType) { return last($this-&gt;groups, fn(GroupType $groupType) =&gt; $groupType-&gt;equals($searchType)); } You'd want to go one step further though, because the lambda that we're passing here basically only explains how to call a method on an object, it would be even better if we could partially apply the method and pass that to the last function. This is possible with `partial_method` function from [this](https://github.com/lstrojny/functional-php/blob/master/docs/functional-php.md) library, but it comes at a cost of refactoring support, which depending on your project size, may or may not be worth it. public function getLastGroupWithType(GroupType $searchType) { return last($this-&gt;groups, partial_method('equals', [$searchType])); } It would be sick if a future version of PHP allowed us to treat functions and method as types and have utility functions to treat partially apply and curry them without having to sacrifice refactoring support. I know that for a lot of people who are used to the first example this approach may seem very alien and it may feel very wrong. But after a bit of practice it's going to feel just as natural as the imperative approach and you're going to save yourself so much headaches trying to debug verbose algorithms that are repeated everywhere throughout your codebase.
Testing is definitely something every project needs but keep in mind, unit testing is only of several types of tests that you can use to provide accountability to your code. Integration testing is, imo, a really great way to introduce high level testing that can be done after features are built, can be automated and run periodically or after changes are made, and doesn't take up a lot of time. Take a look at services like Runscope. Integration testing works really well when there's a lot of churn happening at the beginning of a project but then as features mature and are used more, there's a higher demand for integrity around certain features. It also has the benefit of generally being more accessible than unit testing, and can create artifacts of business value that can be used internally or even distributed to clients. For the time being, maybe a better approach to getting more experience with writing tests is with writing bug proofs. Anytime you encounter a bug, before fixing it, write a test that shows how the bug works. So you write a failing test, fix the code until that test is passing, and now you have protection against it happening again in the future. Eventually you'll gain a decent amount of coverage following this pattern.
More code is more clutter. Why wouldn't you want the least amount of code to describe what your program is supposed to be doing? // Today public function getLastGroupWithType(GroupType $searchType) { return last($this-&gt;groups, static function (GroupType $groupType) use ($searchType) { return $groupType-&gt;equals($searchType); }); } // 7.4 short lambda public function getLastGroupWithType(GroupType $searchType) { return last($this-&gt;groups, fn(GroupType $groupType) =&gt; $groupType-&gt;equals($searchType)); } // What it would look like with Kotlin Syntax public function getLastGroupWithType(GroupType $searchType) { return last($this-&gt;groups, { $it-&gt;equals($searchType) }); } Clearly in this example having less code means having less clutter and making it easier to focus on what is actually going on in this function. Right?
It's important to point out that **each string** in a JSON field takes up 4 bytes of extra space. So if you're creating larger JSON documents, it can take up an insane amount of room. So if you've got 10 fields in a JSON object, each with a value, that's 10 * 2 * 4 extra bytes (80B) for each row.
Agreed. This is an old trick, dating back to the PHP4 days. It's neat. It is also forbidden in our coding standards at work except in a few limited circumstances (along with its even more dangerous cousin `extract()`), and I have started factoring it out of our codebase when I find it. 1. It reduces readability. 2. It pairs a data structure to code, and if the data structure changes or is incomplete, code breakage may occur. In the first example, with a sequential array, if the order or contents of the array change, you have to update any code that uses this method to also account for that change. Even using associative arrays, unless you are null checking all of your created variables (and programming without notices on, which is a bad practice IMHO), you could have undefined or broken behavior if an incomplete or different array is passed in. Consider, for example, the following code: php &gt; $f = ['foo' =&gt; 1, 'bar' =&gt; 2]; php &gt; ['foo' =&gt; $foo, 'bar' =&gt; $bar, 'baz' =&gt; $baz] = $f; PHP Notice: Undefined index: baz in php shell code on line 1 In general, we have moved away from using arrays to pass data around *where possible*, and have started using objects instead. The benefits of using objects over arrays: 1. With an defined object, you have an implicit contract. I can guarantee you that object X will always have property Y. I don't have to check that property Y exists. I can count on it being there. 2. I don't have to null and type-check every single property and variable, I can type-check the object and be reasonably confident it is complete, because I let the object itself handle validation. Write that code one time. 3. Objects with properties are documenting, as all the properties are listed in the object code. This is not so with arrays, and we avoid having the gigantic docblock with "array must have this format" messages. 4. Code completion, if you have an IDE that supports it. 5. Related to the above, refactoring if necessary becomes quite easy because you just need to find anything that uses object X. So, for example, a method or function that may have taken a "standard" `Page` array would now take a `Namespace\Page` object. The code becomes much more straightforward and easy to read as a result.
While I understand the desire for defensive programming, you can take things too far. With a properly designed API system, any random errors should be caught by the request/response handler before you start processing the payload. And at that point, if the API says you will get a particular attribute then you can be certain the attribute will at least exist. &amp;#x200B; Would you apply your same standards to a database query? &amp;#x200B; $row = $db-&gt;query('SELECT name FROM users WHERE id = 1958'); if ($row) { // Would you really do this? $name = isset($row\['name'\]) ?: null; &amp;#x200B; Gotta draw the line at some point.
for me the use($a, $b, $c) is probably the biggest deal after return
If you use Laravel, then, Adam Watham has a great talk about TDD: [https://www.youtube.com/watch?v=MdApmmK71WM](https://www.youtube.com/watch?v=MdApmmK71WM) &amp;#x200B; It's a nice start point for anywone who wants to start with TDD in Laravel.
Are you aware there are officially supported versions of [the PHP images on Docker Hub](https://hub.docker.com/_/php) containing apache? Why are you installing apache, PHP, node, and composer all in the same image? I assume you're using this for development, but even then, putting all this in one image is not the best/right way. Use [the composer image](https://hub.docker.com/_/composer) to do your composer build, mounting your host machine's project directory as a volume in a similar fashion to your `app`. Use [the node image](https://hub.docker.com/_/node) to do your asset build, again mounting your host machine's project the same way. And if you're __not__ using that `app` image in development, you should look into [multi-stage builds](https://docs.docker.com/develop/develop-images/multistage-build/), passing the built `vendor/` directory and your assets from the composer and node steps respectively into a final php-apache image that itself does not contain composer or node.
Why not use docker or vagrant :)?
What I do often is to do first, working code. Then I open the HTML code coverage report and do unit tests until I reach 100% code coverage. I always find one detail or another that needed to be corrected, and one or another improvement that I eventually needs to be made.
Or collection objects...
Which isn't really that relevant for many cases, where you are just searching for a handful ids. But yes, there will be a overhead, but in some cases the simplicity might have more value. Evaluate your use case and make a choice.
I would start with the source material on the subject, Kent Beck‚Äôs - Test Driven Development.
There will be a tiny bit of overhead from JSON processing, but * at least in some cases the MySQL Optimizer can see through this and still use an index (check the `EXPLAIN` for your specific case) * You can prepare once with a single placeholder and then "bind" an arbitrary number of values, with MySQL 8's improvements to prepared statement that can bring benefits over having to prepare different number of value counts. Costs depend on your specific case. Test it, analyze it, make your choice, based on your needs.
Code coverage does not mean that you code or tests are good, though. All that shows is that your code is being run through, when your tests are running. For some devs, that's fine, since they write modular code in small units and basically test for the requirements. For everyone else (the majority in my experience), this often leads to large units of code with terrible tests but high coverage.
Hey, 20$ is 20$.
I indexed composer package manager in December 2015, and it had 80K packages. Now I reindexed it again a couple days ago, and it has ~224K packages. * Old visualization [is available here](https://anvaka.github.io/pm/#/galaxy/composer?cx=224&amp;cy=442&amp;cz=6870&amp;lx=-0.0137&amp;ly=0.0144&amp;lz=-0.0012&amp;lw=0.9998&amp;ml=150&amp;s=1.75&amp;l=1&amp;v=2015-12-11T00-38-00Z); * [New visualization](https://anvaka.github.io/pm/#/galaxy/composer?cx=2581&amp;cy=3200&amp;cz=6940&amp;lx=-0.2708&amp;ly=0.1588&amp;lz=-0.1251&amp;lw=0.9412&amp;ml=150&amp;s=1.75&amp;l=1&amp;v=2019-05-01T00-00-00Z) * Source code that does the indexing [is here](https://github.com/anvaka/allcomposer) * Source code that [does the visualization](https://github.com/anvaka/pm) I hope you find this interesting :)
Similar to what? Oracle? PeopleTools? That documentation site?
"modern"
Both are documented very well, don't worry about that. Symfony just has a higher learning curve compared to Laravel, due to Laravel using (more) "magic" for faster development. If you have the time, Symfony is worth it. Otherwise just stick with Laravel, both are fine.
learn by doing. start writing tests for all new code you're writing. if you can't figure out how to write the tests _first_ then write them after writing your code. as you gain more experience with testing and start to see some of the reoccurring patterns then it will be easier to write the tests first and you can transition your workflow.
the amount of time you save from testing plays out over the whole lifecycle of the project. if it's a large application codebase or redistributable library that's going to be used for many years then automated testing generally saves a lot of time. if it's a one-off website backend for an agency (which is what it seems OP is mostly working on) then testing is just adding time up front for no appreciable upside down the road since the codebase is going to be, effectively, "thrown away" once it's deployed.
Sure! A line in the sand is a must. Documentation would reveal that the database driver is trustworthy enough to send back \`name\` if \`row\` is set correctly. In that case, I wouldn't worry about checking it a second time. I might just be used to more complex environments where external APIs aren't as trustworthy and in some cases I have experienced dynamic query builders that would need the additional key check. I think what I'm saying is that this comes down to case-by-case basis and I was taught to program in a paranoid way üòÇ Appreciate the reply!
Exactly, most of our projects are like this, so it is very rare that I can get some experience with testing
Yeah, thanks. We know. No need for another article about it that doesn't bring anything new to the table. Also that code style is hella ugly IMO
You're too fast for me
btw - is there any tool for code metrics you guys can recommend? I'm searching for tools like phpmd. But maintained.
I want to create a documentation site which will have cascading menus on the left. The content should be on the right and be editable by multiple users. In other words, use user ids and passwords.
sorry to say it but your boss is probably right that it's not worth putting in a lot of extra upfront time for testing if that's the type of project you're working on. my suggestion would be to try and create as much of a reusable common core library as possible, and test the shit out of it, so you can use that for your one-off website projects. you probably don't really need to do much in that respect though because the existing frameworks (like Symfony and Laravel) are very good and already very well tested, so your best bet is to just use the framework as your common core.
Did you know you can just echo $name, $age; ?
Thanks going to check it out!
AH-MAZING work.
If you want people to edit it you‚Äôll need js, some backend language like php and some database to store the content like mysql
Thanks.
nah, I've just upgraded to `.php3` yesterday. are you saying I'm living on the edge?
You've got NPE on first branch: //... $adb_obj = null; if(in_array("-n", $argv)) { $mode = "network"; $adb_obj = new Adb($adb_path, $mode); //... } else { $devices = $adb_obj-&gt;scanForDevices(); //... } Huge refactoring potential (for readability and testability), but doing it in steps of size suitable for pull requests might pose a challenge (some OOP need to be teared down back to procedural first and composed differently). OOP tip: Right after you assign variable called `$mode` in your code consider object for each of it's values. It doesn't have to be different class on the outside - it might be composition using different classes (startegies). Having difference in configuration only will probably force you to ask "what mode is it?" at least once again.
Pretty awesome! Though the usage is kind of strange - I‚Äôm trying on an iPhone and selection of packages is difficult. When I search it pulls me to a package but in 3D space so I don‚Äôt know where to look lol Just my opinion!
TDD in a single SIMPLE sentence: **TDD IS WRITING THE TEST FIRST &amp; THEN THE CODE THE SOLVES IT.** I went to LoneStarPHP Conference &amp; there was a section on "Learn TDD with Katas". Basically, it helped me understand TDD. The kata that was given a numeric input, output the roman numeral. It was REALLY easy to see the process &amp; I was hoping it was filmed. With that in mind, write the test first, then write the code that solves it. That REALLY all TDD is. The benefit is that at the end of typical development, you write the tests that match the use cases, but here you write the tests first. Now that you understand the basics. Do it! Tests: public function testRomanNumerals() { $actual = romanNumeral(1); $this-&gt;assertEquals('I', $actual); $actual = romanNumeral(); $this-&gt;assertEquals('I', $actual); $actual = romanNumeral(3); $this-&gt;assertEquals('III', $actual); } Run the test, assert that it fails. Now right the function that solves it. Start ridiculously simple, you know you have to refactor, but just accomplish solving the first test: function romanNumeral($number = null) { $value = 'I'; if ($number === 3) { $value = 'III'; } return $value; } Run the test, it should pass. Right? If it doesn't, then fix it. Rerun/refactor until it does. Ok, well, obviously we need to support other numbers, so lets write those other tests (one by one) &amp; solve it. ... $actual = romanNumeral(5); $this-&gt;assertEquals('V', $actual); // etc etc etc ... Then solve for that use test case as well. I hope this was sufficient.
I'm sorry, I disagree. I go for readable and easily understandable code over short code any time. Depending on coding style, what you call "clutter", I call "more readable". I always take a little extra time to align code nicely, making it all extra readable. Making things shorter and shorter will not help readability, it will only help save keystrokes, which for me never has been an issue.
On the Microsoft edge
How are the non-linked groupings decided?
I'm going to do that as soon as my 9600 connects. Do you like the short tags? (chills)
Sorry but this is objectively not a convincing argument.
Yeah I know.. so I‚Äôm trying to find other ways to get some experience
how about a frontend component library? setting up a unit test environment for javascript can be a bit of a project, but it could be really valuable.
This article could be summarized as: - Use composer. - Use PHPStorm. - Use PHPUnit.
Thanks for the elaborate answer!
oh man short open tags are the shit! also, can't wait to develop my own guestbook! I've just bought PHP in 24 hours, so far it seems promising!
Was it David Hayes' presentation on this? He turned it into an article here: [https://www.phparch.com/article/how-to-learn-php-unit-testing-with-katas/](https://www.phparch.com/article/how-to-learn-php-unit-testing-with-katas/)
You guys should try this amazing revolutionary app called PHPMyAdmin. Basically it lets you do DB admin actions within a locally hosted admin panel. I swear it's gonna be the next big thing.
You're right. Thanks, it would be better with tables relationships. In fact I should put them a bit every where. In the next days I will try to relationship almost everything, because the calls are so much
As far as I remember it wasn't working without pluck(), in fact when adding pluck() it worked i left it this way. Should take a look again Thanks
Potentially, but I'm not sure. The LSP site is down that had the course/author schedule. I can't see what that actual article is either (paywall).
Thank you for this explanation. I didn't even think at this... On a large scale collisions will be really so much. Thanks. Do you have any suggestion about how-to-go for this? I mean an example or something like that? About converting... I don't get completely how to do that, I mean: should I convert the long url and then get the short one from that or something other? Thanks! You're right about locking the database... will do that. Thank you so much. Really.
This is a classic response "not enough time". Well, having bugs &amp; massive refactors is HUGE time consumer that unit testing addresses. It's putting the time in up front vs after. Also, writing a test before the code helps identify code smells beforehand. I have seen this play out. It just gets your brain thinking about the best TESTABLE approach to solve the problem. If you're having a hard time testing, that is a smell that something is wrong with the code.
Will we be able to use the fn keyword as a replacement for function or just in the context of arrow functions?
This is amazing on mobile
Macros ü§Æ
This. I also recommend the videos and books...and blog.
&gt;objectively Uh huh..
This should also be added to r/dataisbeautiful
LES-BI-ANS
Hi, some other things: &amp;#x200B; 1. Why do you need node? lumen is for API's 2. You could set the password, username and database name of mysql to the defaults of lumen so you don't need the change anything in your env file 3. Are you using the lumen .env file to set environment variables for you container? In development I think it's better to just use the env file or else if you need to change an environment variable you have to remember to export the variable and also set that variable in the env file if you want the change to persist between container creation.
Every node here is a PHP package. Every connection between two packages means that one package depends on another. If a subset of packages does not depend on anything popular (which is in the middle cluster) then it will be pushed away by natural forces. The entire thing is constructed with a force based layout. I gave a talk long long time ago explaining this in more details: https://www.youtube.com/watch?v=vZ6Yhlxv7Os
Good one! I agree, it needs to be optimized better for mobile. One of my todo items from a long list.
Thank you!
Definitely! This helps a lot with that. Too bad regular closures require that to begin with.
Code Andromeda galaxy. üòõ
What *are* you a fan of?
Great job, it‚Äôs really interesting to play with.
I was just about to ask a similar question, good job I read the recent posts. &amp;#x200B; I've created a plan to learn TDD, with particular focus r/PHP, with PHPUnit in r/Laravel. This is my learning plan: &amp;#x200B; \* \[Github Gist: Test Driven Development (TDD)\]([https://gist.github.com/Pen-y-Fan/5a56a255a4733a04e10c58176cbe5f57](https://gist.github.com/Pen-y-Fan/5a56a255a4733a04e10c58176cbe5f57)) &amp;#x200B; As you can see from the ticks, I am making good progress, I wanted to check with the community: &amp;#x200B; 1. Does anyone have tips and techniques to learn TDD? 2. Is there anything missing from my plan that would be useful? &amp;#x200B; I'm happy to update and share with the community for other learners to benefit from my research, so far. All of the above material is free. &amp;#x200B; Thank you
You mean like a framework?
Just use a framework like symfony/lumen
Nice idea - a tool like this could be very useful in teaching SQL as well, by pointing out common mistakes like `ORDER BY RANDOM()`. If you'd like some pointers on how to really bring it to the next level, I'd recommend looking at [ShellCheck](https://github.com/koalaman/shellcheck); it has some great UX features like providing wiki pages explaining the issues, i.e. In /Users/predakanga/24-bit-color.sh line 96: for i in `seq 255 128`; do ^-----------^ SC2006: Use $(...) notation instead of legacy backticked `...`. In /Users/predakanga/24-bit-color.sh line 97: setBackgroundColor `rainbowColor $i` ^---------------^ SC2046: Quote this to prevent word splitting. ^---------------^ SC2006: Use $(...) notation instead of legacy backticked `...`. ^-- SC2086: Double quote to prevent globbing and word splitting. For more information: https://www.shellcheck.net/wiki/SC2046 -- Quote this to prevent word splitt... https://www.shellcheck.net/wiki/SC2086 -- Double quote to prevent globbing ... https://www.shellcheck.net/wiki/SC2006 -- Use $(...) notation instead of le...
Iam maintaining a set of components which help to build APIs, maybe there is a component which is useful for you, you can check them out here: [https://phpsx.org/components](https://phpsx.org/components) They cover topics like OpenAPI spec generation, data serialization and schema validation.
Due to performance reasons. When projects files are on shared from host then it is slower. Some projects do not suffer that much, other like Magento2 have big performance drop. Also it can be really cool to have possibility to run different projects ay the same time without starting/stopping containers. And lasly - both vagrant and docker are not magic. Sometimes you might need vagrant box configured with multiple php versions.
yii2
Look at apigility (From zend), you can use most of the modules as standalone.
I'll take a look immediately after finished installing PHPNuke.
what is _API platform_ in the first place?
API Platform is a standalone package, found under [api-platform/core](https://packagist.org/packages/api-platform/core). You can treat it as a direct dependency of a package you build on top of it and integrate into it. You could even make your bundle reconfigure API Platform indirectly, or have "presets" for various modes your bundle might have.
crud on steroids. you create entities and then everything is just configuration ...
**Here is the list of Modern PHP Tools you can use:** * Symfony: Nice Framework * Guzzle: HTTP client * PHPUnit: a framework for unitary testing * Behat: a framework for Behavior-Driven Development * PHPCS/CBF: code sniffer and code beautifier * Faker: fake data generator * Psysh: a runtime developer console (CLI) full of amazing features * Composer: dependency management and other useful features * Packagist: package repository * Twig: template engine &amp;#x200B; Source: Medium
yeah but op referencing it like a concrete software
Just sell it away. In a year you would be ashamed of your current code, so there is no reason to put it in a chest and sit atop forever. In the world of software development everything changes too fast that nobody needs a code written a year ago. You are right, it's support that makes the money, but as you are not willing to provide it, then just send it as a package and let the owner support it by their own means.
Exactly what I was going to said. You don't have to use the distribution, just use the standalone package :).
If you are willing to keep it running, set up a server for them in your AWS account and charge a decent annual licensing fee. Give yourself some padding to pay for hosting and any additional time you‚Äôll have to put into it. Also, write up a contract that defines what a reasonable response time is for support or outages. Explain the situation ahead of time and they will be understanding if it take you a day or two to get back to them. If you don‚Äôt want to maintain it at all, it may be a tough sell since I doubt they will have the capability to maintain it themselves.
This is a really amazing article. Thank you so much!
Offer it was SaaS if those are your considerations. Just bear in mind you'll need to have a licensing agreement written up to cover things such as availability, maintenance, billing. Alternatively, and I'm just throwing it out there, 70 to 100 hours isn't a large amount of time in the programming sphere. Somewhere between 1 and 2 weeks work and so not particularly valuable vs providing the support and upgrades which you're not keen on (at which point you're specialist freelancing). Perhaps consider open sourcing it, if it's any good you might draw the attention of some other contributors who may offer their time to make improvements, which you could then apply back to your family business. But yeah, if you want to get paid, SaaS is the way to go, as soon as it's put into the wild at other companies, it's almost certainly going to have bugs and other problems discovered in it, and the people you've sold it to are going to want them fixing, and fixes are easier to roll out if you have the infrastructure. Just remember: Contracts + Documentation + Backups. Especially backups. If you lose your clients data, they're not going to be best pleased.
You can't sell high or charge high recurring fees if you can't provide service. Businesses wants liability because otherwise they will lose money when your software will break, or they need help or tweaks. 100 hours is not that much either for a product, so I assume there is a lot of tweaking and patching coming up as they might want to use the software differently. I wouldn't bother selling for all the trouble this might cause, and wouldn't sell as a SaaS without providing service and development. Third option, you could also open source and charge for consultancy. Bug fixes and features can be charged if the businesses want a "fast track" and the community can profit from those.
PHP is a framework. As you progress through your career, you will build libraries of patterns , functions and objects to solve all the problems that the other frameworks claim to solve.
It's distributed like one. With docker setup and everything. For those starting a new project hassle free. But it's not mandatory to use the full stack.
My guess is they are talking about: [API Platform](https://api-platform.com/docs/core/) and perhaps don't realize that there are many other libraries out there addressing the same issues. It's also a bit surprising that the link provided specifically states: &gt; It can be used as a standalone or with the Symfony framework (recommended). So it is not at all clear why they want a standalone replacement for a standalone library that already meets their needs.
swoole reactphp
created a pull request for the clicks relation just a simple no reference on the migration yet relation but made the queries from 12 to 8
Thank you so much! Will check it later!
Let me ask you differently: why NOT api platform? We integrated it for both REST and GraphQL into an existing app. There were few bumps on the road but all in all the experience is stellar.
No - I do not ask for a framework. If I was asking for a framework, I would have stated such. I mean a standalone PHP package, such as many of the other thousands framework agnostic PHP packages that prepares and provides features for you. Just like how Symfony framework itself, it built upon its own standalone PHP packages (components in Symfony's ecossystem).
Thank you. I'll take a look!
Oh. Thanks, did not know that!
Sorry, should have included some context. It's this project: [https://api-platform.com/](https://api-platform.com/)
Another user informed me that the API platform actually provides itself as a standlone package. I was not aware of that before writing this post. &amp;#x200B; If there are: "...many other libraries out there addressing the same issues.", you may as well include these for us to see? Doing so would arguably answer my question asked in this post.
Thanks. Not sure if its really what I need, but I can sure look at this for potentially creating my own. I do really like Zend's projects!
I do actually sell licenses and I have different "packages" to sell. I make my living with it and I don't have an office job. I'm talking about Chevereto. Truth is that you have to adapt to what your market is willing to do. You could have lots of ideas, but at the end is the market which will define if you have to go SaaS, licensed, monthly, yearly, perpetual, renewal, etc. If you want to keep development ongoing in a regular basis then don't offer any kind of perpetual licensing or make a clear statement that you only do that for the current major version. Offer a perpetual licensing quickly builds a customer base but in the long term it will be just an issue for you. I suggest you to go SaaS first. By doing that your code will be safe and you will focus in the product, not in client's servers or silly issues like "how do I enable https". By offering a SaaS you will get off your back all these newcomers, you don't want to handle server issues trust me. Licensing certainly is another game. Way harder, complex. I'm already into it so I won't jump to SaaS, as licensing has also its own goodies like that you get a huge install base (more clients more money).
I wonder if anyone bothered to read the whole post
phpstan maybe? I also use scrutinizer-ci.
Slower? Vagrant is slow but Docker on Linux is very fast. Maybe you need to tweak your shared setup, are you using Samba?
hey, thanks for the link, never heard of this and I like it.
This isn't great. You should use email for anything other than infrequent 2FA. You're adding a false sense of security by doing it this way. If an attacker gets their hands on the email account, then they have full access to the account. It's still a single point of failure. They can request to reset their password which sends an email with a reset link, and then you get the OTP code in the email when trying to login. What you want is TOTP (a.k.a. authenticator apps like Google Authenticator) https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm Since the secret for TOTP is stored in an app or password manager, it's separate from the email account. That way if the email account is compromised, the account on your app isn't also compromised.
Dephpend IIRC.
What about combining https://github.com/FriendsOfSymfony/FOSRestBundle and https://github.com/schmittjoh/JMSSerializerBundle?
I also mean under a security and stability point of view
First of all, good for you man! That‚Äôs awesome that you have others interested in purchasing your own product that you built. Second of all, I don‚Äôt think you should worry about giving your code away. No one wants to maintain an entire codebase they did not write unless it gets absorbed by a company with many developers. As long as your code is generally clean, people will prefer to keep the authors code and share improvements rather than forking the entire thing. I do think it might be worth open sourcing it like others have mentioned here and then selling the actual upkeep and maintenance to the buyers. This allows others to improve the code for you - this has IMMENSE benefits and it‚Äôs the reason why open source is becoming so much more common. Everyone benefits from open source, it‚Äôs a win win situation.
Did you have a look at this? [http://www.slimframework.com/docs/v3/deployment/deployment.html](http://www.slimframework.com/docs/v3/deployment/deployment.html)
It's features are by far not what I'm searching for. It's docs recommend pdepend. But pdepend i abandoned.
Yes, but I mean the process of "preparing the app for the deploy", for example making it secure and setting up analytics and stuff like that.
Well, there any many ways to deploy an application with quite a few factors. So you have a chunk of code. Is it version controlled? How are you currently executing it? What dependencies (mysql? Mongo? Php 5? Php 7?) does your code rely on? Do you already have a domain and server? Are you looking to establish redundancy (probably not)? Do you have access to a CI service? Do you want to use containers? A very basic example would be to check your code into Git. Buy a $5 droplet, $10 domain. Install nginx, php, mysql on said droplet. Pull your code with git. Symlink your config files (these should not be checked into Git and stored statically in each environment, not directly accessible through nginx).
Can you be a bit more specific (btw yes I will use git, php7, mysql and some dependencies)
do saas, charge monthly
Be more specific how? A full detailed step by step tutorial on running a PHP app in Digital Ocean? There are tons of guides that go into much greater detail all over. https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-ubuntu-18-04 Or Google "PHP app digital ocean". There plenty of both text and video guides. FYI, you don't have to use Digital Ocean. It's just a pretty common VPS.
Before you think about turning it into a SaaS make sure you know what you are getting into. You must deliver 99% uptime (or whatever you put in your terms of service). You are on the hook for ensuring that the servers and all data is protected at all times, patching updating your production environment. Keeping PHP updated. etc. You will need to have multiple servers, in case one goes down, handle backups, etc. I personally enjoy writing code I dont enjoy doing production support. You could outsource most of those problems to a managed provider but then that cuts into your profits, and you will have to have prices that pay you what you need and whatever your provider cost. If you charge a license, you can make the running it something your client has to worry about and you could offer some recommendations.
Grab a book about TDD and write a small TDD framework that tests itself.
If you decide you want to sell the code (or monthly/yearly access to it); I built a thing called [gitstore](https://gitstore.app). It'll take care of all the billing and private repo access admin.
Indeed, I mainly meant Vagrant, as I haven't used Docker for few years now. I see that you have more recent experience. After reading documentation I see that there should be no performane impact on Linux, while macOS and Windows will have issues. Good to know.
See the [HttpKernel Component documentation](https://symfony.com/doc/current/create_framework/http_kernel_controller_resolver.html). You're on the right track.
What the actual heck
Some would argue that the ability to call any PHP function directly from a template is actually a benefit.
Thanks, I hate it.
You created a new way to create templates, but actually it's the wrong way. Because templates only have to display informations not more! Every complex logic have to be excluded from templates. And you want your customers to code in templates... Bad idea
Just to add to this a little - you might have put a lot of time and effort into this, I don‚Äôt mean to offend you. But maybe you want to tone it down a little in terms of buzzwords like ‚Äòimpossible‚Äô and ‚Äòrevolutionary‚Äô. The fact that you wrote this shows that it is indeed ‚Äòpossible‚Äô - but maybe there‚Äôs a good reason for why people don‚Äôt do it this way.. This sub is a great place for having factual discussions, e.g. about how much logic should go into your twig templates - but you may find it not very helpful when you‚Äôre looking for people that wanna licence this for 999,-/year.. I think I saw a PR or a tweet from fabien potencier regarding twig where they discussed the idea of adding closure syntax, filter, map, reduce etc to twig, natively, but I‚Äôd have to look that up - might be of interest to you.
April 1st wants their joke back
Codeception: a framework for nearly all test types Enqueue: message queue, broadcasting, etc
Thanks!
100 hours won't get the software purchased by anyone that knows wtf they are doing. I would expect at least a man year (2k hours) and a healthy customer base(30 paying users) before I would consider a purchase of any saas product. Even then, I would try and bootstrap some open source code into a solution before I payed for closed source/single dev one.
yes. Plus the fact that single hobbyist-dev's closed code might be (high probability) awful.
I puked in my mouth
But was the puke revolutionary
This is great advice. One thing extra worth considering is per client customisation. You need to be very strict and up front on costs as this can easily consume 90 percent of your time and eat all your profits. Individual customisations are rabbit holes and clients will take the piss if you let them.
&gt; You must deliver 99% uptime CakePHP &gt; ensuring that the servers and all data is protected CakePHP &gt; You will need to have multiple servers, in case one goes down CakePHP
&gt; In a year you would be ashamed of your current code It's CakePHP, should probably be ashamed today.
How much business management software could you build in 100 hours? Consider SaaS after another 500 hours ;-)
this is a satire, right?
Honestly you seem to be on the right path between laravel and forge you can do something quick and decently scalable.
Agreed. Laravel deployed on heroku or something similar can have you up and running super quick
I am the opposite. I can use build something in laravel. Symfony. Etc. But never ever used Wordpress. If I were to build something I would go straight with laravel, and know what I was doing. But having never used Wordpress or needed to use it, I kind want to try it out and see. But that said. Anyone can Wordpress. Or so I have been told.
My company splits between the two. Both pay the bills, but I have to say Laravel is by far more fun to code in. WP is just pain...painful.
&gt; If you don't want to use it, don't use it. Why the WordPress hate? The way you opened this question feels almost rhetorical. It's true of pretty much any technology and tool outside of job requirements, don't use something if you don't want to use it. I don't like working with WordPress but there's no denying it is an excellent blog tool that, with the help of strong plugins (most notably ACF), it can even be a comfortable CMS. I think particularly as a headless CMS WordPress remains a pretty compelling choice. All that said I think that the biggest thing WordPress has going for it is it's name. Especially with the rise of headless CMS, static site generators and single page applications it's becoming easier and easier to find modern, simpler CMS and website solutions. I'd say that "simpler" is the most important part of this trend, and I feel that losing none of WordPress' CMS strengths for the benefit of knowing "my site can't break, it's just a bunch of html/css/js files" is actually huge. Technically speaking there's a lot to hate on WordPress for but I don't think it's worth much of a conversation here because I won't do the argument justice and it's been had before time and time again.
I am a php dev and not once in my 15 years I touched wordpress for anything apart the website or blog. Recently one of the I did were to use wordpress as a base framework for mobile app api and e-commerce. As soon as I installed wp, it got hacked and some botnet started mining crypto. The other dev told me this and I had to remove all files and did a reinstall of wp with a number of security plugins. This confirmed my hate. Why the hell security is not built in and we need to install a plugin to do the same? And why the hell 3 mb of includes requires are needed just for hello world? I think wp is a bloatware and I have seen many people migrate to newer blogging platforms for the reason. But if it puts food on the table, then no issues.
why do all of these tutorials start out with the same "How to install xamp" bit? And I've see the rest on your channel, its terrible.
I'll use it, but I won't want to code in it.
Wordpress is solid for what its supposed to do. But its when people try to do things that Wordpress isnt supposed to do that makes it terrible. I have seen so many companies with wordpress trying to run their Sass application its insane. Also the docs suck.
Some people - and a very vocal minority at that - need something that they can hate on. I saw a discussion about Git and the commit-hack elsewhere on Reddit, and in it there were people who expressed their hate for Git GUIs very vehemently. I guess they need something to hate in order to feel superior. A symptom of insecurity, maybe? &amp;#x200B; I have worked a small bit on Wordpress, creating plugins etc. to help make a custom Wordpress experience for a client. I don't like programming for it, but there is no denying that it's a great platform. Especially when you can develop something that anyone can make use of without too much effort. &amp;#x200B; However, I do prefer to work with a good PHP framework and create my own specialized applications.
I don't want to use it and I don't. But that's not realistic if you join an agency as a developer, I did six months in one and boy did I not like WordPress at all. I'm a Symfony boy, my favourite CMS is [Bolt](https://bolt.cm/), which is what I will compare WordPress to. While WordPress does work, that's not a justification for some of the terrible things about it and unfortunately it's flaws have come about due to it's success (it's old because it makes money). This topic has been [done to death](https://www.reddit.com/r/PHP/comments/6es70v/why_does_wordpress_get_a_bad_reputation_from/) but my personal gripes are as follows: * Post/content types are added via [functions or plugins](https://www.wpbeginner.com/wp-tutorials/how-to-create-custom-post-types-in-wordpress/) rather than a [config file](https://docs.bolt.cm/3.6/contenttypes/intro#jumpbutton). * The code is an absolute spaghetti nightmare and has no separations of concerns, certain bits can be anywhere and it can be horrible to dig through to find what solution another dev cobbled together. * It's poorly documented, the [Git repo hasn't even been setup properly](https://github.com/WordPress/WordPress) with it's readme file being in HTML rather than MarkDown. * Some of their coding standards are..... [interesting](https://make.wordpress.org/core/handbook/best-practices/coding-standards/php/#naming-conventions) to say the least (why no camels?). This document has some decent advice and some odd stuff, but at least they have one (which is more than I can say for some CMS solutions). * It gets bloated quickly, which can [make it very slow](https://www.savvii.com/blog/wordpress-php-performance-benchmark-2019/) (experienced this firsthand). I understand why people like WordPress, it's got a large plugin library, it's old and it's probably the easiest e-commerce CMS to get started with because of Woo. But to be honest, if Bolt had an e-commerce solution WordPress would be obsolete very quickly in my eyes. Hell it borderline is if you create a Shopify theme to accompany a Bolt site.
Via a framework; they take the trivial, mundane functions out of developing so you can worry about your app logic.
Ya know, i've been writing php for 10 years.. i even wrote a blogging engine that i prefer to use because it is more secure and has a better workflow IMHO.. Recently i started a professional grade blog and found out that the plugin and theme ecosystem for wordpress is absolutely off the chain. It's what makes wordpress awesome. it would take me years to get my blog engine to do what a set of plugins is capable of. I decided to just use wordpress and spend my time coding other things.
Because the WP ecosystem has shitty security and its underlying fundamental architecture is limiting and hard to break out of.
This is actually exactly what I was looking for. A detailed why. You've given me some reading to do and Kme food for thought.
Dismissing all criticism of something just because there are idiots who hate without reason doesn't have much merit. &amp;#x200B; I'm a PHP developer, and there are still things that suck about it, even though haters exist. We shouldn't dismiss criticism in this way.
No probs! Honestly didn't want to give a "because it's shit lol" answer as that's not helpful at all
I used to do WordPress. Now I avoid it. Here's why I don't like it. From a user perspective it's ridiculously slow. Plugins and themes make it so much slower still. Security wise all the 3rd party plugins are a risk and often a problem. Dev related, I don't like the structure with all the hooks. The database isn't very straight forward for storing your own data. It's difficult to debug. And more than anything, WordPress seems to be what unqualified (and beginning) developers gravitate towards. Which means if you inherit someone else's WordPress code, there's a good chance you're in for a treat. When I'm hiring people I also will definite ask a lot more in depth and difficult questions to people who say they are wp devs.
There is a difference between hating something and criticizing something. I don't like WordPress, but I don't hate it.
_can you make an eCommerce site with wordpress?_ Sure it's doable, but it's s hit like that which makes me question why anyone would want to maintain something like that (which seems to be a common use case with wp) after it's done being built.
You're being dismissive of anyone who disputes you by saying they need something to hate on.
This, in so many ways. Also, based on old code. Are they using PDO yet? Are they still rolling their own Crypto? The size of the bloody thing, even compressed, and with no addons it's huge for what it does, add 1 or 2 plugins and that easily bloats out past 100MB before adding any content. My own PHP based CMS, which does more out of the box, is way smaller uncompressed and even with example images to get client's started than WP is compressed. Just check mine is 18.5MB, plan was to keep it under 10MB, so may need to do some refactoring, lol. Uses a LOT of Ram before it even starts to send out pages to the client side, mostly due to their cron system. Mom and Pop *ahem* design businesses use it without knowing about security and a ton of plugins, and in my eyes takes work away from experienced and trained developers and designers. I'm not hating on those bussinesses that know what they are doing, but I've had to fix a lot sites installed by such businesses, needless to say, got them off WP. SEO's love it and spruke it at every chance, and tell anyone they can that it has to be used for effective SEO. My rant is mostly about standard installs done by people with pretty much zero-knowledge about development or design. My hat off to those Devs that do take the time and effort to fix the weak points.
I'm a software engineering consultant in my spare time (in addition to my day job writing code). I wouldn't say I *hate* Wordpress. I advocate for it's use in some cases! I think it is a fantastic piece of software *for what it natively does*. You want a blogging platform? Wordpress is one of the best, hands down. You want a basic CMS that is so dead simple that anyone that can use a word processor can update the website? Wordpress excels at this, because that is what it was designed to do. But I do think it is a poor solution in a lot of cases where it has been shoehorned into. People keep grafting so much extra, unnecessary shit onto what is still, at it's core, still *a blogging platform*. Often this is done by low-skill, low-paid "consultants" with very little experience in writing maintainable, secure code. Literally all they know how to do is write Wordpress code. I often end up having to clean up the mess from these folks, who often still write PHP like it's 2007 and [they haven't learned better](https://phptherightway.com/). Wordpress's architecture has, until very recently, encouraged this behavior. Their stubborn refusal to move beyond PHP 5 (and continuing to support absolutely ancient versions of PHP 5 at that!) has held their entire ecosystem back from writing better, more secure code. And, more broadly, held PHP as a whole back, as they are among its largest players. Hard to make the case for hosts to upgrade PHP when Wordpress still supports whatever ancient version of PHP the host is providing. Their internal architecture can be very messy in places and documentation often contradictory (there are currently two totally different documentation systems!) about what the "correct" or even preferred way to do something is because there are multiple ways implemented at different times! I will give them credit: Wordpress itself doesn't have too many gaping security holes anymore. Most of those has been patched. It's the plugins and themes that provide the attack surface now. The public plugins themselves (and to a lesser extent the themes) are of such widely variable quality that it is difficult to know what to use and trust. You're probably okay with the "official" plugins, but you get too far off the beaten path, you find a lot of garbage (and, to be fair, a few gems as well). And any custom plugin I find is immediately suspect for the reasons above. Building a theme? Which of these multiple ways of user customization do you support? All of them? None of them? Or do you just write your own customization further messing up the UX for writers and editors who have little idea how to manage Wordpress beyond the very basics of writing a post. Oftentimes when I come into a Wordpress case, there's 30 or so plugins installed, half of which are disabled and you have no idea what is causing the client's problem. It takes a few hours just to untangle the mess, and you can't ask the last "consultant" because they wrote garbage code, threw it over the wall and disappeared. It's the reason I usually don't take Wordpress cases anymore unless it's someone I know or an installation I did, myself, from scratch that hasn't been messed with by anyone else. Wordpress is a great *blogging platform* and *basic CMS*. It's when people start trying to make it do things beyond this that problems start to accrue. And I think this leads to a lot of the hate. When Wordpress is your hammer, everything looks like a custom post type.
I tell you what I DO hate, though, and that is trolls like you.
That hammer/post type thing... I'm using that at work tomorrow.
No, seriously, your videos are crap, you should stop
Jesus Christ. Plaintext. Plaintext stored in a cookie Please nobody follow this. Pleassssseeee
Jesus Christ. Plaintext. Plaintext stored in a cookie Please nobody follow this. Pleassssseeee
you should never build a site from scratch like this
I'd totally recommend Laravel, but depending on what you need you can relatively easily stitch something together with e.g. something like Drupal, custom fields and plugins.
Exactly, the coding standards are so fucking weird, it really makes me wonder about Automattic. Have you looked through any of the source? Even the newer code is dirty and not to mention the REST API. It's so unintuitive.
Those coding standards look pretty reasonable to me, though they don't always match my preferences. The only questionable thing I saw was when to put spaces in array indices. As for camel case, I can see where underscores would become more readable when abbreviations come into play. Consider WPHTMLLinter vs WP_HTML_Linter.
You can create small or big project using laravel, with many usfully tolls like eloquent core and respons-request helpers, and many other features .. etc
Beware of saas. Running a saas is 5% coding and 95% operations and administration. Unfortunately services don't run themselves.
What's wrong with xampp?
Short answer: because people keep shoving down it's throat all kinds of things it was never meant to be. E-commerce? Sure. Betting platform? Sure. eBay clone? Yep. YouTube clone? Tess. Mobile app? Well look no further... Quantum realm GPS controller? There's hundreds of plugins to do it. 90% incompatible with your version, 9% unmaintained, and 2 commercial ones that need 300 MB, 150 tables and uses something that's not usable with your theme unless you code a plug-in. Ironically, people who do blogging move away from WordPress, while everyone else keeps pushing more and more into it.
You should take a look at [Slim 4](https://github.com/slimphp/Slim/tree/4.x) we make it so much easier to handle all this and we only depend on FastRoute and whichever PSR-7 implementation you choose. That‚Äôs so much boilerplate for a simple task.
No developer worth his salt would use xampp for a real development environment, especially with puphpet being a thing these days. Even a handcrafted docker setup is better.
Nothing against OP, but this is what came to mind immediately. I've written some applications that turned out a pain in the ass to maintain. 100 hours is nothing, I'm working on a new project and have probably spent 40 hours so far just designing and thinking about the internal layout of the system.
It depends. If you're going to manage a lot of content start with a cms. If youre making something really custom i would preffer to stick some components together. If you see that laravel has all the features youre gonna need go with it.
Now record me that in Behat/Min syntax
Can you point me to the right direction in terms of what I should use on Windows, please?
Vagrant or Docker. Puphpet is a good vagrant setup, but if you want to be more "modern" then Docker is the way to go. Either way will require a bit of fiddling to get it set up to your liking, but they're both completely isolated from the rest of your environment and closer to a production-like environment than xampp.
Only noobs like to hate and have a blind thing to follow ... Once developers work for few years they quickly realize every task has it's own set of ideal tools and using that wisely is what development is all about. Noobs don't realize that quiet yet and that's the problem. They simply don't have enough industry experience to realize their naiveness.
If you want some additional pre-built logic for user authentication you could look at [Laravel 5.7 Boilerplate](http://laravel-boilerplate.com), or even [October CMS](https://octobercms.com/)
Have you checked out sylius yet as a symfony e-commerce based platform?
Is it something that you're going to develop quickly, get paid, and walk away from, never to provide any support (unless you get paid again) until the end of time? Then follow a framework or CMS's tutorials to set it up. Laravel? Wordpress? Drupal? Just pick one at random... Might as well throw in Magento, since you can make custom pages for it, as well as vanilla Symfony, or hack something together with TranPHPorm and Dice. For a quick-and-dirty project, it doesn't matter which framework or CMS you pick at all. That really is the fastest way. You'll get paid and be on your way. Your client will be happy for a few months -- long enough for you to change your email address, at least. If you want to support the application, then you'll want to understand the framework or CMS of your choice. In that case, you shouldn't be asking us, but you should be learning the frameworks and CMSes, until you're an expert. Expect that to take *at least* a couple of years, regardless of which framework or CMS you choose, because there's *always* more that can be learned... and the fact that you've even asked this question shows that you haven't put in the time to learn any system yet.
&gt; WordPress in my opinion is solid as hell for what it does 80% of the usage these days is trying to use WordPress as a silver bullet -- not for what it was intended. Time for an upgrade, man. https://getgrav.org/
We had somebody build us a WordPress site for the business. When he left I tried to repair some of the gaping errors using the tools on the packages and plug-ins he used. After a couple of weeks I realised I had failed. So I ripped it out and put in 1500 lines of PHP (including comments and the underlying HTML) which only took a couple of days. It runs exactly how we want and it's pretty idiot proof code. It does everything we wanted and it is easy to make changes because even a senile old buffer like me can read and understand it. (Well maybe not all the stuff I just cut-and-stuck from the PayPal site.) I'm sure Wordpress, in the right hands, is a powerful tool but I'm just an old man whose CV is full of physics, assembler, C and a bit of C++. That rather makes me a native php fanboy.
I was in a similar situation long ago and what I did was I used the first friendly customers to shape the software and to add more features. That doesnt neccesseraly means that you should give it for free, but use some trivial pricing per year (mine was $100 per year). The first customers are very important, listen to them and add features they request. Try to make it as modular as you can. Also id you start selling it well after a while you can consider bumping the price for the first customers. You will have the leverage because you did so many features for them.
You‚Äôre not wrong but none of this is fault of WordPress. WordPress core is generally as secure and if you‚Äôre not trying to break out of it and use it for what it‚Äôs for (blogging sites) then it‚Äôs hard to deny it‚Äôs best in class considering ease of use and setup.
Any ready-made integration with major frameworks like Symfony? (Or is it trivial enough?)
I guessed that some people would argue that way. But I see no reason why that should be a problem. It is not more or less secure than a php script. What I can say with certainty is that in this way you can develop applications incredibly fast, because you do not need to provide a list of variables. &amp;#x200B; When writing the templates, you can change the generated content within seconds. If you do not like the result, just change the template again and press the F5 key.
Yes, integration is described here: [https://roadrunner.dev/docs/integrations-symfony](https://roadrunner.dev/docs/integrations-symfony)
Sometimes new technologies are developed which makes the existing technologies obsolete. &amp;#x200B; Calling a getter of an object is not complex logic, but a simple alternative to pre defined variable lists. &amp;#x200B; And that's the huge advantage. You can work directly in the templates with the data models of your backend.
These are not buzz words, but reality, since such a template engine has never been programmed before. Things that were impossible before are now possible. And that is revolutionary. &amp;#x200B; You don't have to pay 999,- per year. You pay only once. You can also make a call and ask for a special deal, for example free updates until this technology becomes open source. &amp;#x200B; This is a fair price for a product that can save you many thousands of euros in development and translation costs. &amp;#x200B; Even if Fabien Potencier makes the above changes, it takes years before these are available, believe me, I speak from experience...
You don't devolped a new Technologie! You just simple break the sense of templates.
Global functions in 2019?
It is reality! Because it has never been so easy to create multilingual web applications. &amp;#x200B; Have you ever seen a page with 64 languages, except perhaps with the exception of very large companies like Google? &amp;#x200B; With UCMS this is super easy and only needs a few mouse clicks!
Thank you! FOSRestBundle looks really interesting. Kind of what I was looking for. Although I do not use Symfony, I think I can take great inspiration from this package!
This was 2 months ago https://blog.ripstech.com/2019/wordpress-csrf-to-rce/ &gt; This blog post reveals another critical exploit chain for WordPress 5.1 that enables an unauthenticated attacker to gain remote code execution on any WordPress installation prior to version 5.1.1. This involved default settings on stock installs.
Hi, &amp;#x200B; The way Symfony itself implements it is quite neat. Maybe I'm a bit late to answer but. I would have checked out the documentation for Symfony's HttpKernel component. It's **really** great: [https://symfony.com/doc/current/components/http\_kernel.html](https://symfony.com/doc/current/components/http_kernel.html). &amp;#x200B; I've been creating my own framework, built upon some of Symfony components my self, and it's such a great learning experience and I do absolute recommend you to study the way Symfony's HttpKernel work: [https://github.com/symfony/http-kernel](https://github.com/symfony/http-kernel). &amp;#x200B; If the documentation or the source code seems intimidating at first, just take a look at this (HttpKernel::handleRaw) method: [https://github.com/symfony/http-kernel/blob/master/HttpKernel.php#L121](https://github.com/symfony/http-kernel/blob/master/HttpKernel.php#L121). This method describes your typical request and the HttpKernel's handling of one. &amp;#x200B; By the way, here's a link to the HttpKernel::handleRaw method but a version 4.2.8 (the one on master right now is a bit different). They changed the event names to a bit more "non-descriptive" names. For example on master-branch the "GetResponseEvent" was renamed into "ResponseEvent". I do think "GetResponseEvent" tells a bit more what's going on: [https://github.com/symfony/http-kernel/blob/v4.2.8/HttpKernel.php#L120](https://github.com/symfony/http-kernel/blob/v4.2.8/HttpKernel.php#L120) &amp;#x200B; Basically it fires an event in an attempt to get a response, if it did not find an response from one of the event listeners, it makes an attempt to resolve a controller and get a response from it. Which is quite neat, since you could in the first event "ResponseEvent" / "GetResponseEvent" make a listener that for example checks if the request path if "[https://example.org/admin](https://example.org/admin)" and deny access to it if you're not logged in.
part of my day job is maintaining ancient drupal sites. around these parts drupal is probably considered incredibly dated, yet all strings are run through `t()` to create a single list of stuff for translation. that is not new at all. being able to automatically pipe it through google translate or similar is neat and might serve as a starting point but there is *no way* I would trust machine translation to be accurate for production. Have you ever read a foreign news article via google translate? If so, have you *ever* found it to be grammatically flawless? &gt; Therefore, internationalization with the UCMS is not only possible, but it is simple and does not cost a cent and almost no time even if the machine translation was magically perfect, there is far more to i18n than translation. text direction? currencies? date and number formats? hell, even names - does your system automatically add form elements for tussenvogels? as for the twig stuff, you seem to think people use twig despite it not being a full-blown programming language. if that was the case they would just be using php itself to template. they use twig *because* it is not a full-blown programming language.
Hi, &amp;#x200B; I would say the absolute shortest/fastest path to deployment depends a bit on the final version you're trying to achieve. &amp;#x200B; * Are you building a "information"-website with just pages, text and images? *Go with an existing CMS of your choice.* * Are you building a website with a light and commonly existing features, for example forms, upload functionality, comments, search? *Go with an existing CMS of your choice.* * Are you building a more advanced website (what I would more classify as a web app), for example a more of a custom app with not commonly existing features? *Go with an existing framework of your choice and see if there's any existing PHP packages that may help you with implementation of some of your custom features.* &amp;#x200B; However, everything I've noted above is irrelevant if you're not going with the shortest/fastest way. Me personally, would always make the choice for using a framework or building from scratch with existing components from Symfony, the PHP League or Zend.
I've seen it, yet to have a project where I can test it out
Anyone running this on Raspberry PI? I've got an Octo PI server cluster...
Has this been updated in the last month? Cookies/sessions never seemed to work for me.
In the linked post: [https://github.com/spiral/roadrunner/issues/18](https://github.com/spiral/roadrunner/issues/18)
The last reply was three months ago and that solution never worked for me. Maybe I'll have to try it again some time.
https://github.com/symfony/psr-http-message-bridge got couple updates, few specific to the cookies. Besides that the session issue is still remains open and require app specific tweaking. Symfony use default _SESSION cookie which works outside of Request/Response scope and can‚Äôt be captured by PSR-7. Check the ticket linked to the article, few people have sessions working.
Ah sorry didn't see that it was still out of date, I tried RR a while ago and ran into this issues. Cookies worked fine but sessions did not, I moved them to Redis instead and that worked fine.
Using custom session driver might be a very easy way to fix it.
Thank you, I'll try to modify the application to not use the session cookie.
Thanks, I'll try that. I used the default session handler because it was easier at the time but modifying it should not be a problem.
The trick is that you need to translate every phrase in google translate before you put it into the template. Example: My native language is german, the source code is always english. Before I put the translation into the template I test it with google translate. If I don't like the result, I just change it until google translate produces a almost perfect german phrase. Then I take the english phrase and insert it in the template. Now I can be pretty sure that the Google translator will also translate any other language almost perfect. The quality depends on the language relationship. For example most western european languages are close to each other, this translations will be almost perfect. &amp;#x200B; Did you click on the flags at the top of the website? Some of the languages are RTL, and you will see that everything will be displayed RTL if you choose such a language. &amp;#x200B; Most of the translations are in the templates. Even if other systems are able to extract translations from php code, this is only a small part, maybe 5%. UCMS can extract everything easily. And that even very purposefully which means that you can choose the project files in a treeview with checkboxes. &amp;#x200B; If any translation is added, removed or modified, this can also be detected. In that case you just re-translate all fuzzy messages and done. &amp;#x200B; UCMS respects the locale settings. The new template language even has a own locale tag which allows you to embed content with other locale settings: &amp;#x200B; [https://php-ucms.com/de/docs/Libraries/TemplateEngine/Tags/Locale/](https://php-ucms.com/de/docs/Libraries/TemplateEngine/Tags/Locale/) &amp;#x200B; However, this is only necessary if you want embed different locale settings. For example the user has selected German, but you want embed French locale settings then the locale tag can do this. By default the format of numbers etc. depends on the user selected language. &amp;#x200B; An example of a feature that is definitely new: UCMS translations can contain markdown code. All you have to do is to wrap the trans tag in a markdown tag. Even more, the automatic translation will keep the formatings after machine translation. And this is revolutionary! I would not claim all that if it's not true at all. However, to understand the benefits you must read carefully all the information on the website. There, not only the template engine is presented, but also many other things. For example, the PDF Generator, which makes the creation of PDFs very easy. Or the way Business Logic is managed. The way how permissions are managed. All this is super easy with UCMS through the new technologies. &amp;#x200B; You did not read the technical documentation :( I think nobody here did read it. There are examples which explain all this... &amp;#x200B; What I can say with certainty after working with this technology for 2 years is: You can develop internationalized web applications incredibly fast. Development time can be reduced by 75%, which is equivalent to the development costs. Translations costs are zero and it's done in few hours. Normally a translation would cost at least 3000 euro - per language. Multiply that by 100 languages. Now choose: \[ \] pay 300k euro to translators without guarantee of more correctness compared to machine translation \[ \] pay nothing and accept that some languages that are far away from english (like chinese for example) have a lower quality &amp;#x200B; what's your choice?
That is so incorrect! One of many many features is for example the ability to use function expressions. Did you have ever seen that in a template language? It allows you to programm incredible things and makes the template engine almighty like JavaScript... &amp;#x200B; The translation capabilities are also new and revolutionary, see the markdown example: [https://php-ucms.com/en/docs/Libraries/TemplateEngine/Tags/Trans/](https://php-ucms.com/en/docs/Libraries/TemplateEngine/Tags/Trans/) &amp;#x200B; Revolutionary (for a template language), see last 2 examples: [https://php-ucms.com/en/docs/Libraries/TemplateEngine/Tags/Script/](https://php-ucms.com/en/docs/Libraries/TemplateEngine/Tags/Script/) &amp;#x200B; Revolutionary: [https://php-ucms.com/en/docs/Libraries/PDFGenerator/Examples/HelloWorld/](https://php-ucms.com/en/docs/Libraries/PDFGenerator/Examples/HelloWorld/) &amp;#x200B; Revolutionary: [https://php-ucms.com/en/docs/Libraries/TemplateEngine/Tags/Addtag/](https://php-ucms.com/en/docs/Libraries/TemplateEngine/Tags/Addtag/) &amp;#x200B; Revolutionary: * foreign function interface * anonymous functions * callbacks * dynamic tags * function expressions * method chaining * currying * scriptability
Actually, I‚Äôd say Woo was the best plugin I used in WordPress. Really used WordPress how it was supposed to be used. Lots of hooks and actions everywhere and templates are really easily overwritten. I do a lot of ecomm but this was the only woo site I‚Äôve ever done. https://zippypaws.com
Something I don't see on the site - how does it compare with swoole?
I don't, I've never used it personally. But I've been instructed about it.
[https://php-ucms.com/en/features/](https://php-ucms.com/en/features/) optimized for fast and easy web application development
about as long as one request usually takes, so sub-second
On the one hand it's neat, on the other there's bigger issues that should be addressed before sugar syntax is ever considered. Less boilerplate is not something that maters. If it did all function and variable names could be two or three letters, that an anti-pattern. DUH. But but X language does?? SO fucking what. This is PHP god damn it.
But you don't want to script into templates. That's why frameworks like Symfony were build to not use php as a html template script language any more. If you want to create complex template functions create you will create a twig filter or function for that.
Like I'm so fucking paranoid with security I have a 3 step system just for logins. Step one using encrypt in browser send to server. Server decrypts and reincrypts with a server side key and additional data. Server returns data that browser then pads with ip/time stamp. Finally returned to the server login script that compares ip and geolocation data. If good, go ahead and process the login normally. If not good process login then require OTP over text or email
Why go
I am pretty sure, 20 years ago when JavaScript was released, some people argued the same. I don't say that someone should write complex code in a template. But why not query database records in a foreach loop in a template, and then access the getters of an object to generate content: &amp;#x200B; {% for blog\_post in blog.getPosts() %} &lt;h1&gt;{{ blog\_post.getHeadline() }}&lt;/h1&gt; {% endfor %} &amp;#x200B; This saves so much time, and it is more performant because you only evaluate the code you really need. In the old twig you have to pass your variables, even if you not need all of them. &amp;#x200B; There are many more examples that prove that you can program much faster...
I like your experiments, things like this are needed to push things forward. Now if this could be integrated more unobtrusive, acting more or less silently in the background as Babel, that'd be nice.
Thanks. What would you suggest I add/change, to make it more unobtrusive?
To be fair, I haven't taken Pre for a spin yet, I should obviously do that first. &amp;#x200B; But the concerns about verifying code standards in the other comments made me wonder how to pull that off properly, also IDE support/syntax checking is a thing... &amp;#x200B; And having a special file extension also bothers me a bit, although it's probably wise to clearly separate files that need pre-processing for now while this is so exotic. Maybe ordinary .php files could have some kind of annotation or mark that makes them go through Pre as well. &amp;#x200B; What if I wrote a library that utilizes Pre and want to spread it without causing any hassle for people including it in their projects via Composer? Could Pre auto-run during the package installation to provide a compiled version, maybe even based on the installed PHP version? But sorry, I am just rambling. I need to actually try it and eventually come back with a more informed opinion. But like I said, I like the direction! I could really see myself using some Pre magic on some actual application code in one of my next projects.
All comments and questions. &gt; Maybe ordinary .php files could have some kind of annotation or mark that makes them go through Pre as well. Not a bad idea. I'll have a think about it. &gt; What if I wrote a library that utilizes Pre and want to spread it without causing any hassle for people including it in their projects via Composer? `composer du -o` (or generating an optimised autoloader) pre-compiles all `.pre` class files; and then disables itself. &gt; But the concerns about verifying code standards in the other comments made me wonder how to pull that off properly, also IDE support/syntax checking is a thing... IDE support is severely lacking with almost all of the Pre macros/syntax. This, however, is one instance where official PHP 7.4 syntax is being polyfilled; so IDEs will support, validate, and highlight this syntax.
First of all, great work on tackling such a complex task! However a few bits of feedback below, 1. Once you submit your form you need to ensure the data being passed from your user is safe. You‚Äôre currently not performing any escaping or validation. This could lead to malicious users performing XSS attacks through your login form. 2. Your php and HTML are in the same document. Of course this does the job however I‚Äôd suggest looking into object orientated php and creating dedicated authentication classes to abstract your logic away from the view. I know this was only a demonstration however it is important that if you‚Äôre making a tutorial you should be advocating for best practices and ensuring safety in your code. Best of luck friend. üò∫
How old are you?thats not a big.
Thank you so very much for your valuable feedback. I sure will look into what you have said to improve the quality of my code.
What are the use cases for this? Why would I port my application to this?
&gt; These are not buzz words, but reality, since such a template engine has never been programmed before. Yes it has. It's called PHP ;)
Translating between English and German can work automatically to some degree as they have a common root. But even their it fails. The translation engine won't know whether to use "Du" or "Sie" for instance when translating. This becomes quite difficult with languages which work differently, like many Asian languages. And even then proper localisation is has, since it's not only about translating text and switching LTR vs RTL but also usage of ordinals vs digits and other languageisms. And then their is the impact of machine learning: https://www.theguardian.com/technology/2016/jan/07/google-translates-russia-mordor-foreign-minister-ukrainian Good luck doing that automatically. I wouldn't like to associate my name/brand with a crappy translation.
Charge them as much as you can. I find it comical people on here are trying to scare you away from this. Just go for it, if you can make some extra bucks on the side why not?
Maybe crappy some years ago. Google uses "Neural Machine Translation" since 2017, the results are really good, and in most cases "Sie" is used, that's ok for business. The trick mentioned above will produce more than acceptable results for languages spoken in the EU. &amp;#x200B; You safe money in any case, because even if you prefer a human translator, you can reduce the work the translator have to a minimum. &amp;#x200B; Ordinals are possible if you create a translation for each ordinal. Usually, only the numbers from 1-12 are used as ordinal. For example, display seconds minutes and hours in that way requires 36 additional translations. Alternatively, in language where a count of 1 is always singular, the translator can use "one" for the singular form, and "%d" for the plural form. This is eg. possible in German and English but not in Russian. UCMS has for example a when() function: &amp;#x200B; this\_reddit\_post.ctime.when() would output "One day ago" / "Vor einem Tag" / "1 –¥–µ–Ω—å –Ω–∞–∑–∞–¥" &amp;#x200B; Plurals are also possible, even for languages like arabic which has 6 different plural forms. The UCMS code is written so that all plural form are prepared before the machine translation is done, so that 2 english forms as input result in 6 arabic forms as output. Is possible to calculate the count of items required for each plural form. &amp;#x200B; l33t stuff that's why it took two years developing all this ;)
Twig is able to handle template inheritance, but PHP can not handle that. That's why a template engine for effective applications is required. Details about template inheritance are explained here: [https://php-ucms.com/de/docs/Libraries/TemplateEngine/Tags/Extends/](https://php-ucms.com/de/docs/Libraries/TemplateEngine/Tags/Extends/)
It is a good introductory tutorial.
Want to tack on to this and say look into "mvc" and "separation of concerns" if you don't know what those mean yet.
&gt; PHP is not known for multi-threaded processing because, until now, it has been very difficult to achieve, as well as buggy to say the least. With the advent of Node and Go, PHP started declining in popularity for this very reason. *What?* Node is notorious for being single-threaded. It has succeeded, like PHP, despite the lack of multithreaded processing. On top of that, it's a very hard sell to assert that ~~a~~ the decline in PHP popularity is because of that shortcoming given the fact that your average page load doesn't stand to benefit much from multiple threads.
Disagree. First of all, google APIs aren't bad about breaking backwards compatibility like you seem to imply, from my experience. Second, I've actually done this before for a client. They wanted to get to market quickly, so I built an application using google forms + google sheets backend. They used it for 6 months before it became clear that: 1. It doesn't scale 2. The data is easy to screw up in sheets. 3. Adding additional functionality gets complicated using only google forms + sheets backend. So when they realized this (I warned them about all of this of course), they paid me to build a real application. And they had the money to do it because they got to market quickly using this hacky solution. The key here is to make sure you manage expectations and be honest about what you are providing, and that it will not scale beyond a certain point.
To add to what you said, I believe Node runs as a single thread for all connections. PHP is actually technically multi-threaded out of the box. Because every user that connects is a separate 'thread'. Implementations like Swoole is a different kind of multi-threading that allows you to run a single process on multiple threads.
This is great, can't wait to try this
Yep, this is a common misconception people have about NodeJs... It's heavily asynchronous, sure, but that doesn't mean multi threaded. For heavily I/O bound applications (waiting for database or external network fetch) NodeJS is great because while _waiting_ for those I/O fetches to finish, the next web request can immediately be picked up and worked on. But the moment your application will be doing some number crunching, everyone is waiting. This is why with NodeJS you'll want multiple worker processes just like in PHP.
Weird. People drinking the kool aid without much regard to internals. Reminds me of the mass Rails exodus a decade ago.
WTF is "a complex task" you are talking about? That's basically an HTML form and a condition in PHP. WTF is going on here? This kind of shitty spam half-assed video tutorials are posted here every day, how this one is any different?
I think before you come charging in all hot headed you should take a step back and consider that OP‚Äôs is still learning. We should be encouraging OP to research further into best practices. For a beginner the idea of an authentication system is quite a complex task. Perhaps not to you but to a lot of people it may well be. We‚Äôre all here to help each other and you won‚Äôt be helping anyone by putting them down.
Well, multi process. The difference being that the PHP child process that the webserver starts up and hands off the http request to, gets its own walled off memory space and is therefore quite a bit heavier for the OS to initialise and handle. Processes comes with a simpler programming model and more security than threads though.
Just a question - the tutorial talks about threads the whole time. Just had a look at the Swoole page. The first two words I've seen were: asynchronous and event-loop. Is swoole even multithreaded or is it multitasked like amphp and other frameworks?
&gt; OP‚Äôs is still learning. Then he just shouldn't shoot a "How to create a login and register system using php part 1 - basic tutorial" until they actually finished with their learning.
Why are you getting down voted for posting this comment? Genuine curiosity
I cannot disagree. To me, it seems the popularity of Node just comes from the popularity of JavaScript which comes from the explosion of frontend applications probably introduced by the mobile era. If PHP execution was supported in browser instead of JavaScript, everything would have been different.
http://restler3.luracast.com/examples/_008_documentation/readme.html
3. They're using the bitwise and (&amp;) operator instead of the logical and (&amp;&amp;) operator. I mean, I guess it works, thanks to PHP being loosely cast, but unless they're intentionally trying to avoid boolean short circuiting, they would do well to not use it as they are.
You ok pal? Getting a tad worked up over nothing.
Whatever you say. This shit will be removed as soon as our lazy ass moderators will surface from their usual hibernation.
&gt;great work You kidding, right?
This is terrible. This is not a 'login system' at all.
Thanks. I knew my terminology was likely not fully on point.
actually i see no reason to use nodejs over swoole php. the problem with node js is it tends to halt the processing if one of the nodes is blocked, it has been seen so recently, while php swoole doesn't suffer from any such issue. php swoole blows out nodejs at speed department. swoole php kills all the advantages of nodejs as far as it is about number of requests per second.
Indeed. But I think the major reasons of using one or another will come from several things : what developer is available to code the app, what environment will host it, and of course what the app is trying to achieve.
For real: who actually cares about these things?
It's actually cool to write code concisely. But I don't need any other avantage... Moreover, if you prefer writing code with static type checking, the gain is not really noticeable...
Define ‚Äúconcisely‚Äù
Anyone that also works in JS/C#/other languages with short closures will be glad they can use a relatively similar syntax.
I agree with you. It's been 7 years since we've had a new mod, and none of the current ones are active in any way on this sub. It's infuriating. I've been thinking of making a thread to stir shit up about the situation but that's not my usual MO. I'm not the sort of person to want to create drama. We need more active people as mods of this sub.
How do you expect anyone to grow if all you do is shoot them down?
&gt; But it doesn't really solve the problem it proposes. au contraire, it only creates additional problems.
I really like Swoole. The only thing I think lets it down is the lack of shared memory between processes to be able to better handle stateful applications.
Having to write "fn($i) =&gt; $i * 2" is clearly more concise than writing "function ($i) { return $i * 2; }" to me. Anyway, it's just a matter of taste
I'm not sure how much this should be about "people to grow". In my opinion this sub should be a place for more "professional discussion", not for "amateurish low content". And indeed this low quality content is right here in this sub. in other words, it is in a wrong place. Maybe /r/phphelp could be more appropriate for this kind of content.
One is coroutine like library and another is standalone application server (like php-fpm). Server is slower since it‚Äôs separate from php process but it provides the ability to easier extend core functionality using Go (basically infrastructure framework), vs recompiling library written in C++. I know that Swoole will be faster on synthetics, not sure about it‚Äôs performance in real application.
I will have to waste my time learning this sugar syntax... and that's sad as fuck.
You are as blind as I can't believe a man could be. This guy is not "growing". One who wants to learn goes to /r/phphelp and asks for help in learning. But he is not learning, he is already trying to teach. Knowing absolutely nothing on the subject. Adding yet another shit video to the pool of already existing "tutorials" made by illiterate beginners. We have this shitshow here every day, the last such video has been shot down just yesterday. I am telling you obvious things and you are asking me whether I am OK. What about you: &gt; We don‚Äôt need more shit tech articles from incompetent ‚Äúdevelopers‚Äù, thanks though. &gt; /u/locksta7 It seems that your attitude is only towards articles but shit tech videos are OK.
Well, according to my observations they actually surface something around once a day, doing the necessary cleanup, as long as there are volunteers to report bad posts. So I am only irritated but the response time but not desperate about it.
&gt;Just a question - the tutorial talks about threads the whole time. Just had a look at the Swoole page. The first two words I've seen were: asynchronous and event-loop. Is swoole even multithreaded or is it multitasked like amphp and other frameworks? &amp;#x200B; It threads internally. Threads aren't exposed to userland as such.
 [https://www.swoole.co.uk/docs/modules/swoole-table](https://www.swoole.co.uk/docs/modules/swoole-table) &amp;#x200B; From docs: &gt;Can be used by multiple threads or processes. The documentation is a bit lacking, but swoole provides exactly what you mentioned.
Checkmate.
Yeah like you said, not desperate.
I can for sure see cases in which theese would make code easier to read, but it's not like its a huge leap forward. More a optional QoL.
Thanks, I've seen the swoole table, but unfortunately the enforced data structure doesn't meet my needs as I have a slightly complex data structure I need to share / update between requests.
A professional developer who's expected to... learn stuff. Disgraceful.
Reasons: \- ZERO performance gain. \- Worst readability. \- As it is will the short closure implementation is buggy.
&gt; Worst readability That's your opinion. Most people think otherwise (look at the RFC votes). &gt; As it is will the short closure implementation is buggy. I'm sure you have evidence for this statement?
My god /r/PHP please stop being a bunch of fuckwits.
Coming from JavaScript, I can't wait to use them in PHP!
Don't use it then?
Me: avoid complexity as much as you can. Also me: writing an article of 15 or so sections to explain the above sentiment. Jokes aside, I feel the article aims for the good, but it's fatally mistitled. Source: I suck with titles myself.
You killed a large amount of erlang developers with this comment :D
Yeah, sure! I needed to think a bit how I would implement it myself. Here's my go: $words = ["A", "C", "G", "T"]; $base = count($words); $encode = 13; $encoded = []; $length = ceil($encode/($base-1)); $before = 0; $n = $encode; for ($i=0; $i++; $i &lt; $length) { $digit = $n%($base-1); $n = floor($n / ($base - 1)); $index = $digit + $before + 1; if ($index &gt;= $base) { $index -= $base; } $before = $index; $encoded[] = $words[$index]; } print(implode("", array_reverse($encoded))); If I copied the code correctly from my Python sketch it should encode 13 to GAC instead of CCC (base 3) or TC (base 4).
It's definitely possible it's mistitled. I'm not good coming up with title either. I speak about simplicity in software, I thought the actual title was in phase with the subject. I tried to explain as precisely as I could, since a lot of articles out there doesn't really explain how to make a codebase simpler. They just state that yes, you should be simple. Therefore, can you be more precise about "wast sections"? If the article itself looks complex (a lot of stuff in there, that's true), it's because I think achieving simplicity is complex. What a paradox.
&gt; ZERO performance gain. We don't use PHP because of performance. If performance were the #1 priority - we'd all be resorting to C / C++ / Rust. &amp;#x200B; &gt; Worst readability. You probably meant to type "WORSE". No, it's not worse. It might be you were never in the situation to need short closures. &gt; As it is will the short closure implementation is buggy. So.. it's buggy and we should just take your word for it? You, the person who apparently hates the feature, you have some kind of information that you didn't share with us which proves it's "buggy" or are you just fishing for random, unfounded reasons to hate the feature? Do you even code?
Laracasts hands down
We want PHP4 back!!! \s
If it takes you more than 5 minutes, you might want to reconsider your career choice.
Did you follow any of the affects it had on the JavaScript community? Many disliked it, didn't see the need for it and thought it was less clear. But now it's pretty widely accepted and appreciated. You just get used to it.
Annotations.
Well, *achieving* indeed *is* but all the pain is to make *the result* simple. Or, as Blaise Pascal put it, &gt; I have made this longer than usual because I have not had time to make it shorter. So yes, I would say this article is more complex than it should be, with overstretched preface (I got bored without even making it to the place where I can tell what is this article about). I often have to fight myself over removing some parts from a post or an article I am writing, parts that look hot but don't actually fit for the goal. May be you can find such parts in your brochure as well. Do I get it right that the "Conditionals and Cyclomatic Complexity" part is just an *illustration*? It is way too long for the purpose. Let alone its uncertain conclusion, "the cyclomatic complexity is not always a good metric". Fine, why did I read all this then? Again, at whole, I agree with most statements in the article, I am just having a hard time finding a *system* in it.
All would be fine with this article if not that nasty contrary relationship between compositional complexity (of layers) and cyclomatic complexity (within single layer) - you simply cannot reduce both. "Lasagna architecture" was a joke that backfired ([Matthias Noback blog article](https://matthiasnoback.nl/2018/02/lasagna-code-too-many-layers/)).
Unless I‚Äôm missing something this is a bit misleading. Swoole is not multithreaded, it‚Äôs multi process, which is entirely a different thing.
should prolly leave this profession if you refuse to learn
Everyone actually interested in his profession.
Explain how and we'll try.
They went through all that trouble just to shoehorn "=&gt;" into function syntax. They could literally have just done \`fn() {}\` and been done. All they would have had to do was shorten the token. Why didn't they do this?
Thanks for your feedback! &amp;#x200B; What do you call "Preface"? The introduction itself or the "Simple‚Ä¶ or easy?" part? I describe what I speak about in the article on line 6, but maybe it's not clear enough... or is 6 lines too long? &amp;#x200B; "The Conditionals and Cyclomatic Complexity" part is not just an illustration, but a concrete problem I see all the time. It's not to say "here an example of something complex", more "careful with conditionals for these reasons". &amp;#x200B; "the cyclomatic complexity is not always a good metric": I say that in the middle of the part, it's not the conclusion of it. It's not the subject either, conditionals are the subject. The title of that part sounds totally wrong though. &amp;#x200B; I agree with you about this: it might be too long. However: it's too long for somebody who knows all of that, but for people who doesn't know what simplicity in codebase means? I'm not sure... it's difficult to judge since I know all of that.
Different syntax possibilities were considered and discussed: https://wiki.php.net/rfc/arrow_functions_v2 (at the bottom of the page)
I tried to speak about both, to have an overall picture about complexity. You can always introduce complexity which is not necessary. That's what my article is about. I read Matthias Noback article. Whatever you want to call it, it's a joke... which is the reality as well for some application. It's just a question of semantic, the problem stay the same.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Wadler's Law: most programming language design discussion is about syntax. https://en.wikipedia.org/wiki/Law_of_triviality#Related_principles_and_formulations
It'll certainly take more than 5 minutes. Now there's two kinds of closures with different behaviour. You don't learn that just once; you pay for it every time you encounter one.
Probably the first version of phpmyadmin was really good! But they did a great job of introducing a lot of people to a lot of shit UI and bugs.
Wait, holy shit, you‚Äôre charging ‚Ç¨999 per project for this crap, and you offer no benefit over existing template engines outside of marketing buzzwords?
For real: Like who cares about your comment, like OMG! - fucking idiot
https://invoice-ninja.readthedocs.io/en/latest/install.html
Is this really multi-threaded then? Can a child thread share memory and locks across threads? For example, when using php-fpm, you already obviously support multiple running processes simultaneously, but they are not multi-threaded in the true sense of the word.
Admittedly I haven't read anything more than the comments here, but I would agree with your statement that it's not multi-threaded like the traditional sense you'd see in Java.
You can check this list: &amp;#x200B; [https://www.producthunt.com/best/invoice-generator](https://www.producthunt.com/best/invoice-generator)
Yea, I have been looking at many many and reading suggestions, lists - but they are just websites that list invoice services, programs and apps. What I am really looking for is someone that is actually using one that s/he likes and can personally recommend. I can find hundreds but I don't have the time to keep testing them - I already wasted tons of time doing that. I was hoping for someone to recommend ONE based on experience on actual 1st hand knowledge and use. Thank you for your time
well, this is currently this fourth post on this sub: [https://blog.solidinvoice.co/general/2019/05/06/release-2.0.0](https://blog.solidinvoice.co/general/2019/05/06/release-2.0.0)
It looks too difficult for me to install. I can create the databases and stuff,but looks like a lot of command line work - as opposed to just an install script Thanks I will keep it as a possibility and appreciate your time
let me know what your requirements are and i'll write one up for you for $25.
Hey OP, are you sure you didn't mean to post this over in r/Python?
r/lostredditors
I think he meant to post it in r/sadspammers
This is r/PHP.
Google docs? Seems like extra effort to make this a web app, no?
This feature is as useful to me as using if () do...(); I haven't seen much talk on FFI and preloading yet. Can't wait to see that in action.
This subreddit is fucking useless.
That was my first idea, too, but then I realized that they're spamming a Python tutorial, and Python devs obviously like low quality content (else they'd be using a superior scripting language like PHP), so I figured it might actually be welcome over in a Python subreddit... ;-)
This community is crap/unfriendly, and not the product I offer. Only amateurs and script kiddies here! It is impossible to have a normal conversation. The mere fact that the product is not free is enough to get people posting inappropriate comments here. So sad... &amp;#x200B; Here are many comments made by me which explains the benefits, but you did not read it, and I do not want to repeat myself over and over again. Read the comments, read the product description at the features page: [https://php-ucms.com/en/features/](https://php-ucms.com/en/features/) &amp;#x200B; There you will find a lot of features that have never been programmed before. This features speed up development dramatically! No one is forced to buy the product. You are free to use open source solutions, and you are free to multiply your development time and your development costs. &amp;#x200B; Service for blind people: [https://www.reddit.com/r/PHP/comments/bkp58i/i\_have\_programmed\_a\_new\_revolutionary\_twig/emk5uzf/](https://www.reddit.com/r/PHP/comments/bkp58i/i_have_programmed_a_new_revolutionary_twig/emk5uzf/) (highlight the word Revolutionary) &amp;#x200B; I will not answer any other unprofessional comment from now.
This looks cool, but I‚Äôm confused by the decision to change how scoping works purely for the shorter syntax. This is going to lead to mistakes.
So then you're here for people to do the work for you, in which case you need to post in /r/phphelp
If he goes the SaaS route, he'll also want to incorporate so when he does end up losing his customers data, they don't come after his house.
Ever figure this out?
There's no need. That's what contracts are for.
I'll take you up that offer. I need you to create an entire ERP backend to support the invoice creation, as well as 24/7 support for my team! And I need it yesterday.
&gt; ERP backend woah.. the offer was for a script to generate invoices. send me your exact specs and i'll see what i can do.
Ever used strategy design pattern? Implemented open/closed principle in useful way? Allowed client code to provide handlers for hooks?
Less effort to write good work, higher chance devs will choose good over bad.
Nice. Bookmarked it; I might have something worth selling in a year or two.
The same people who care about ``$i ??= 'false';`` instead of ``$i = $i ? $i : 'false';`` or ``if (!$i) $i = 'false';``. In other words, people who would rather write short and concise code.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Sure, you should avoid unnecessary complexity, but that doesn't tell you anything, because it's obvious fact you can put in any context - "X is good, but if you overuse it it will become bad". The example for exscessive layers was bad not becasue the number of those, but because leaky boundries. Whole point of introducing layers is to make complexity manageable or in other words: make managing complexity *simple*, and this is kind of "simple" is really hard to achieve. You won't solve it with set of rules, because they're not applicable in all contexts (you may overuse them:) Joke aside, take DI container for example - you can get away with auto-wiring for single-instance infrasctructure services, and generic libraries (which are built with their own factories), but using it for use-case specific code would become a nightmare (mental recursion). Even explicit container (not auto-wired) composing endpoint handler has no added value over plain factory - too much being defined in one place and upfront config definition becomes an overhead itself. My CRUD may have 10+ "layers", but lots of them will be single-instance-front-conttroller-middleware-services-managed-by-framework that you can configure and forget about. For perfect separation of single CRUD endpoint I need to write 4 extremely simple classes: (1x controller/action) translate http into data structure, (2x model) validation + persistence adapter, and a factory that wires it together and ocasionally some html template. Well, not a class, but that's five! I need to write 5... and website navigation wrapper for it (6) ...with i18n (7) - now this is becoming complex isn't it? Try to fit last 2 into domain logic and tell me how testing goes. I'll wait untill you finish only to tear it all down (or force you into partial rewrite) requesting REST API equivalent endpoint. &amp;#x200B; ^(Off topic:. If I ever start writing a blog I'll copy exact font/line with/hight ratio from yours - reading it felt like having one of those speed reading skills.)
So is this a InvoiceNinja alternative then?
Even better: `fn($item) =&gt; $item + $externalVariable;` vs `function ($item) use ($externalVariable) { return $item + $externalVariable; }`
I feel like that‚Äôs a bad idea considering we‚Äôre all pushed to program our applications to MVC specifications.
swoole capabilities being native to php.
I feel this would be better suited to /r/SQL and-or /r/MySQL moreso than /r/php It seems to broadly applicable across all languages that interface with MySQL,and none of the article bridges any of this knowledge into anything particularly applicable to PHP.
Oooh that getter syntax looks awesome. Hopefully we get that sooner than later
Oh, no, I did read it. You want to talk unprofessional and unfriendly? Let me walk you through something. You post your closed source product on a community discussion forum, spewing buzzwords and marketing lingo, insisting that you have created something so revolutionary that the rest of us simpletons couldn't possible conceive of it and that we should all be thrilled to buy it and sing your praises. Then you go ad ad hominem when people politely explain to you the simple truth: You have written nothing that has not been written before and what you have written breaks many principles of good programming design and that no one wants to buy it let alone use it in a project. Please tell me again who is the unprofessional amateur?
If you prefer Python, Python is better. If you prefer PHP, PHP is better.
In a sense, yes, although this project started before InvoiceNinja.
Let's hope someone doesn't forget to renew the cert. :)
Thankfully there's no X.509 involved! They just need to append a different Ed25519 public key (preferably one backed by a YubiHSM or equivalent).
‚ÄûWhen compared to PHP, PHP has a lot of security concerns but they can be tackled with the help of additional tools but even after that it‚Äôs not as secure as python.‚Äú Examples would be nice. Python also has eval. You can still write bad sql querys with string concatenation. And so on. I think, it's easy to build unsecure applications in both. For php there are probably more resources about how to don't do it because more people wrote shitty code. ‚ÄúPython‚Äôs design theory insists on the code readability. This makes it very easier for the developers to create an organized and clean code, regardless of the size of the project.‚Äú While I like the idea of having indents as block indicators, I find it harder to read large functions in python. And I don't like the built-in decorator syntax. But that's just my opinion; I know there are a lot of people who love python's syntax/readability.
We always prefer python as it's more secure.
Choosing among the one is a really difficult task because PHP and Python both are working good on their way. Python is the gateway to machine learning codes. On the other side, PHP is used for server-side scripting and web development. As per my experience, Numerous factors like the simplicity of code, versatile use cases and lots of useful libraries are the reasons Python is better than PHP.
Well tbh, It boils down to your preference. Many will say that python is more secure as compared to PHP, but as of 2019 there isn't any security issue in the language (PHP) that will bother you, yeah I can agree that you can write less secure code in PHP since it is easier to 'get it done' in PHP, and generally newcomers to PHP don't pay attention to security vulnerabilities. Apart from that it majorly depends on what do you prefer and what type of work it is. That's it.
It's faster usually to move your data over to another table and rename them to the original then it is to deleting the data you do not want in your original table. Stops locks from happening as well.
\&gt; To build a simple website or web application solution most of the developers will go for PHP. \&gt; Thanks to the code and logic, [PHP](http://www.digitalninjasingh.com/content-marketing/php-vs-python/) is better when applying for web development exactly. \&gt; Python is much more flexible then PHP but is not considered as a good language for developing the simple web-applications. You can't make claims like this without supporting data, or at least some sort of objective reason to make the claim. For example, I'd argue that Python is generally better than PHP for web applications because pushing through the nightmare transition of python 2-&gt;3 has at least blessed python with unicode-by-default. In contrast, PHP6 was abandoned and modern PHP still only has limited unicode-as-an-afterthought support. Choosing PHP for a web app means you're risking random obscure unicode-encoding-related bugs once you start trying to support non-English languages.
Thanks for your detailed comment! That's definitely valuable. &gt; Sure, you should avoid unnecessary complexity, but that doesn't tell you anything, because it's obvious fact you can put in any context - "X is good, but if you overuse it it will become bad". There is a disease among developer: we think that what we understand ("obvious facts") is not worth explaining. The thing is: not everybody has our knowledge. In fact, my experience shows me that many developers know that they should avoid complexity, without understanding what complexity really is about. That's why I wrote this article. &gt; The example for exscessive layers was bad not becasue the number of those, but because leaky boundries. Whole point of introducing layers is to make complexity manageable or in other words: make managing complexity simple, and this is kind of "simple" is really hard to achieve. The number of those is a problem, I think. As I explain, if you create a lot of layer, you will have to create a whole bunch of interfaces and other construct to make them independent to each other. Is that good? Not really, if you don't have any need for it. My example is a real life one: it's a nice application since you can exchange any layer you want with another one, with minimal effort, in theory. The problem is: you don't need to, and because there are so many layers with so many interfaces, pools and whatnot, that it's very hard to understand, to maintain and to scale. Is there a real concrete need for these layers? Absolutely not. I agree with the leaking boundaries problem as well though. &gt; Joke aside, take DI container for example - you can get away with auto-wiring for single-instance infrasctructure services, and generic libraries (which are built with their own factories), but using it for use-case specific code would become a nightmare (mental recursion). Even explicit container (not auto-wired) composing endpoint handler has no added value over plain factory - too much being defined in one place and upfront config definition becomes an overhead itself. I think your DIC becomes an overhead if your application does too much, if your monolith is too big. I would try to separate the monolith into module (bounded contexts) or microservices, depending on the case. I don't really understand when you say "using it for use-case specific code would become a nightmare". Any resource / example about that? &gt; My CRUD may have 10+ "layers", but lots of them will be single-instance-front-conttroller-middleware-services-managed-by-framework that you can configure and forget about. Nop. Not in my example. It's an application using Go, and there is no framework behind. I mean, just a router. When you implement something, you need to touch half of it. Even if you have a framework, you will forget about it... till you have a bug. As always. &gt; For perfect separation of single CRUD endpoint I need to write 4 extremely simple classes: (1x controller/action) translate http into data structure, (2x model) validation + persistence adapter, and a factory that wires it together and ocasionally some html template. Well, not a class, but that's five! I need to write 5... and website navigation wrapper for it (6) ...with i18n (7) - now this is becoming complex isn't it? Yes, this is becoming complex. But you need all of that for answering your business need. So you don't have the choice, do you? Maybe you don't need to translate your application though... maybe something to see with the management? Again, my example is a microservice without any templating. Another service request it for CRUD purposes, save or select the database, the service send back a response. It has more than 10 layers. I still think it's too many. &gt; Try to fit last 2 into domain logic and tell me how testing goes. I'll wait untill you finish only to tear it all down (or force you into partial rewrite) requesting REST API equivalent endpoint. It would be a bad idea indeed. But here's the thing: Matthias Noback, in his article, says that he's afraid that nobody create layers anymore because of this "too many layer" problem. Think about the contrary: because saying that "too many layers" is not a problem, I end up working on applications which has... too many layers. &gt; Off topic:. If I ever start writing a blog I'll copy exact font/line with/hight ratio from yours - reading it felt like having one of those speed reading skills. That's very interesting to know! Thanks for that.
Great news for security :) Thanks for all your hard work Scott
This is amazing news. Congratulations Scott on all your effort.
Can't you use redis as a form of shared memory?
It is truly threaded, but you don't get to control the thread created using pthread\_create C function, you get to control coroutines in userland which are even lighter than threads. Swoole is fast because it reduces the amount of work required to prepare the playing field when a request is received (if you decide to use built-in http server) and because it can utilize CPU to full extent even if you start only one process that invokes it.
/r/phphelp
As many adviced: choose the one you are eager to get things done quickly with. At our company, we are 2 to work on scripts relative to image processing, we mix PHP and Python because I prefer PHP and my collegue Python, and everything is ok.
I like how they humblebrag anytime they get the chance. *New release: we broke the plugins of 33% of the Internet.*
Your example is not valid, the HTML is formatted incorrectly. It should be: echo '&lt;iframe src="url"&gt;&lt;/iframe&gt;'; On your page you can view source and check the correct HTML is being output. Not sure what you mean by "also tried {src= etc.}" Presuming that's all fine, is the URL definitely supposed to be embedded? If not then Spotify may be blocking the page from being in an iframe.
There is also Shoplo SaaS platform, recetnly bought by SumUp. Quite good especially for estern EU.
Ok, so the way I would expect is to generate AUTO_INCREMENT IDs in the DB (redis, MySQL or whatever) then take that number and put it through a compressor like this: ``` class ShortCompressor { /** * Alphanumeric case-sensitive, vowels have been removed so that words * cannot be accidentally created by the compressor */ const CODESET = "BCDFGHJKLMNPQRSTVWXYZ0123456789"; public static function compressNumber(int $number) { $codeset = str_split(self::CODESET, 1); $base = count($codeset); $converted = []; while ($number &gt; 0) { $converted[] = $codeset[bcmod($number, $base)]; $number = bcdiv($number, $base, 0); } return implode('', $converted); } } ``` This is based on the one that I use in production. Basically what it's doing is taking the number and working from right to left, converting it into a different number base. If you're familiar with Hexadecimal or Binary this will be fairly apparent. Essentially you can write numbers like this: ``` Base n^4 n^3 n^2 n^1 n^0 Quantity 0 0 1 2 0 ``` Multiply each column by the amount that n^x produces, so in base 10 it's: `1 * 0 + 10 * 2 + 100 * 10 = 120`. In hexadecimal it would be: `1 * 0 + 16 * 2 + 256 * 1 = 288`. Now that we're working with a base system of 31, you can see we can fit some very big numbers in just a few characters, with no chance of collisions. Also this means that you only need to store the initial number, you can do the reverse of this function to convert from the compressed string to the actual number, meaning you can do integer index lookups, which is much much faster.
Regarding the 33% figure - the original source says: "We do not consider subdomains to be separate websites. For instance, sub1.example.com and sub2.example.com are considered to belong to the same site as example.com. That means for example, that all the subdomains of blogger.com, wordpress.com and similar sites are counted only as one website."
It's a lot faster than e.g. nginx+fpm
&gt; I think your DIC becomes an overhead if your application does too much, if your monolith is too big. I would try to separate the monolith into module (bounded contexts) or microservices, depending on the case. &gt; &gt;I don't really understand when you say "using it for use-case specific code would become a nightmare". Any resource / example about that? Use-case specific is different name I use for bounded context domain service and its infrastructure interfaces (ports). My knowledge is not broad enough to discuss microservices. Btw. Your example might indeed be excessive in this context - it looked like normal http endpoint for php, and I assumed it was. Writing "occasional" framework code couldn't end well anyway. Unfortunately I can't provide any concrete resource on "autowiring nightmare" - it's based on personal experience (I started with old-school manual composition though) and thrown-in sentences from conference talks - nothing concrete. I don't think it can be easily proven, but I just can't imagine restructuring objects composition without seeing current structure in front of me, and imo it's another reason why proper layering is avoided/neglected. Even finding bugs (places to put debugger breakpoints) or places where change needs to be implemented becomes hard when couple months later instead full execution path (stages) you see only top layer. I'd need to assemble it back by jumping from one constructor signature to another or using CLI tools. I guess tools would suffice if layering was fine, but it isn't because I couldn't see big picture.
Hmmm
Yes it is supposed to be, and I included the "", sorry forgot them in the example
Oh this is handy to know. Maybe I can re-enable logging without Stackdriver freaking-the-fuck out at the thousands of warnings being generated.
https://laravel.com
That's a framework. OP is wanting a package for authentication. &amp;#x200B; However, OP, I do suggest using Laravel. It's great, and as long as you're familiar with OOP, you'll be good to go
Haven't learned laravel yet. I made a pretty basic authentication script but got bored. So, I was thinking about what others use.
... and if you only want a package: [https://github.com/bshaffer/oauth2-server-php](https://github.com/bshaffer/oauth2-server-php) and [https://github.com/thephpleague/oauth2-server](https://github.com/thephpleague/oauth2-server) (also used by laravel passport) I worked with both and they are equally good.
Yeah that's what I do.
What are your requirements?
You can have a look at [Symfony Security Component](https://symfony.com/doc/current/components/security.html). &gt; The Security component provides a complete security system for your web application. It ships with facilities for authenticating using HTTP basic authentication, interactive form login or X.509 certificate login, but also allows you to implement your own authentication strategies. Furthermore, the component provides ways to authorize authenticated users based on their roles.
It's not about the length of `function`. Ideally there wouldn't be a keyword prefix at all and it would just be `(x, y) =&gt; x + y`, the `fn` keyword was added to prevent ambiguities.
OAuth2 is massively overkill if all you need is simple user auth. You'll get stuck reading spec documents for weeks to make heads or tails of all of it.
[Aura.Auth](https://github.com/auraphp/Aura.Auth/tree/2.x) is an older one, but pretty good. (I am the lead on the Aura project.)
What madman would evaluate Ubertcart for Drupal instead of Drupal Commerce?
This is an excellent review, especially when coupled with the corresponding [MageTalk podcast](https://magetalk.com/magetalk-episode-192-lee-goldsworthy-unfiltered/). An excellent study in platform comparison.
Does this only happen with the `php:stdout` pseudo file or also with the `/proc/self/fd/0` descriptor?
IIRC, it happens in both cases. In fact, I've found the linked PR from [this Docker Hub issue](https://github.com/docker-library/php/issues/207) where they discuss this issue at lenght, and the only found workaround is to `tail -f` a log file to the stdout...
&gt;You have written nothing that has not been written before Wrong. The new Twig has many features that are missing in the old Twig. Yes, some of this features also exist in other programming languages, but some are really new, for example dynamic tags which allows you to add a new tag and use it immediately. In terms of template languages, most things are new. &amp;#x200B; &gt;and what you have written breaks many principles of good programming design Wrong. I break nothing, the old twig also allows custom tags, custom filters and functions, but in a totally complicated way. I've added more flexibility and simplified everything. I guarantee you, if Fabien Potencier had the technology to use closures in his own Twig, he would implement it. Just ask him... &amp;#x200B; Other things are also new, for example the UCMS router technology. Adding new routes is super complicated with the technology provided by the symfony framework. With my technology all you have to do is define a url pattern, and done. Look at the following example, it explains the steps needed to add a new template/controller/route/all\_meta\_data: &amp;#x200B; [https://php-ucms.com/en/docs/Libraries/PDFGenerator/Examples/HelloWorld/](https://php-ucms.com/en/docs/Libraries/PDFGenerator/Examples/HelloWorld/) &amp;#x200B; That's all you have to do to add a new feature to your application. And that's why development time is reduced dramatically. Show me any other system that is so simple. &amp;#x200B; The PDF Generator used in this example, is also new and revolutionary. Any other comparable technology will use HTML for that and translate this HTML Code somehow (mpdf?), and this is not pixel accurate. &amp;#x200B; Moreover, I am introducing a new structure, a site tree, which represents your business logic. Symfony use tags inside the controllers for this (which makes a central administration impossible). &amp;#x200B; The site tree in UCMS can be compared to files in a file system, including permissions and everything else. Thanks to the power of the new Twig, it is easy to use the methods of the Site model to create navigations and other things super simple: &amp;#x200B; [https://php-ucms.com/en/docs/Models/Site/](https://php-ucms.com/en/docs/Models/Site/) &amp;#x200B; **One thing that is undeniable revolutionary and new:** My new Twig is able to parse a programming language with one regular expression into a abstract syntax tree. Nobody has done that yet in the history of mankind. Most people will say it's impossible. I say it's revolutionary new technology. And it would be easy to exploit this in many other languages. &amp;#x200B; Regular expressions make the new template language super fast. The {% cache %} tag makes it even more fast. My Raspberry Pi 2 will generate content faster than any other system on a real webserver :) &amp;#x200B; In addition, this technology allows each application to be scriptable. This technology is adaptable to any other programming language. No one else in the whole universe is able to provide this technology. And if any company need such a technology they can develop it which takes 2 years and need 20 years of computer programming experience, or buy a lifetime license for 999 euro. For a company 999 euro is nothing! Maybe it is even tax deductible, so that a smart company pay nothing under the dash! &amp;#x200B; I'm even kind enough to provide this technology for free, and as open source, but only after development costs are paid through licenses. &amp;#x200B; The headline that I chose was not an exaggeration, but a correct description, period! &amp;#x200B; My big mistake was to post here because most people here are cheeky brats not older than 20 years I think. And that's not the target group I am looking for. &amp;#x200B; My target group are companies who want to save a lot of money with new revolutionary technologies. So if any company read this, just contact me if you want to save thousands of euro development costs, and also contact me if you want save thousands of euro translation costs. &amp;#x200B; I could list a lot more here (UCMS translation technology for exmaple), but then this comment just gets too long. &amp;#x200B; Anyone interested in this new technology should read the product presentation and the technical documentation. Nobody here did that, I can see it with the UCMS monitoring tools which allow to watch apache log in real time through a database layer. (Another new technology, see generic database emulator at the product description page). &amp;#x200B; &amp;#x200B; [https://php-ucms.com/en/features/](https://php-ucms.com/en/features/) [https://php-ucms.com/en/docs/](https://php-ucms.com/en/docs/)
[https://slimvoice.co](https://slimvoice.co) is nice
This was such a PITA. Glad we could finally remove our ugly workarounds a couple of months ago
&gt; Nobody has done that yet in the history of mankind This is the part where I realize you are delusional and stop talking to you. Get some help.
Given how many of Wordpress's security issues come from plugins, this arguably wouldn't be a bad thing.
Well, just prove the opposite! You will not find a regular expression which is able to do this, you will not find anybody else who know how to write such regular expressions... And I can do quite different miracles with it ;) &amp;#x200B; Post your proof here! If you are able to deliver one ...
https://en.m.wikipedia.org/wiki/Dunning‚ÄìKruger_effect Seriously, get some help
Happy Cake Day dlegatt! Whenever you find yourself doubting how far you can go, just remember how far you have come.
Desktop link: https://en.wikipedia.org/wiki/Dunning‚ÄìKruger_effect *** ^^/r/HelperBot_ ^^Downvote ^^to ^^remove. ^^Counter: ^^256125
**Dunning‚ÄìKruger effect** In the field of psychology, the Dunning‚ÄìKruger effect is a cognitive bias in which people mistakenly assess their cognitive ability as greater than it is. It is related to the cognitive bias of illusory superiority and comes from the inability of people to recognize their lack of ability. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
If WordPress didn't support plugins, they'd be 0.03% of the Internet instead of 33%. If they actually cared, they'd permit only curated plugins, a-la AppStore, and they'd have a decent API instead of this hook-based mess where everyone is stepping over everyone else's toes.
Until then, hacks exist to get logging working: [https://github.com/moby/moby/issues/6880#issuecomment-344114520](https://github.com/moby/moby/issues/6880#issuecomment-344114520)
The technology is real and exists, and the chosen solution is completely new and therefore revolutionary. It's also much more powerful than current technologies in this field. These are facts that I can prove, period! &amp;#x200B; If you can not or will not believe it, have it checked by an expert or scientist. Then you will find out that all the claims are correct.
dude... he was just messing with you, don't take this seriously, but do get a break ;)
From the document you can tell they are CURRENTLY on Ubertcart (no idea how that was chosen) but they are comparing the features in what they HAVE to what they COULD be using instead. But thanks, I've been using wordpress/woo but as an IT person, there's so much bloat in wordpress and been looking more to drupal so I'll spend time on drupal commerce.
Another self hosted solution that has a crazy nice backend is [sylius.org](https://sylius.org) (symphony backend).
IMHO, what is not KISS: Docker. Docker promises simplicity but finally, it's another layer over layer. We used docker but we tossed it and now we use xcopy and a standard platform (and everything legacy lives in a virtual machine).
I saw that you can use push notification with this project. &amp;#x200B; How to set up them with PHP? Are them some details how to do this with Laravel, Symfony, Slim, other popular frameworks and even without framework?
 This is coming a Symfony Bundle that will integrate this library with all the backend part needed. It is still in initial development.
Is it also possible to do this with other frameworks?
This just saved me a load of time, thanks for posting!
I'm not sure it will, the other languages I work with close over the outer scope as you would expect and it's fine. The fact that PHP's closures don't by default has always been kind of bonkers.
 You can "easily" integrate the backend part in PHP using the following package. With it you get to create subscriptions and send the push notifications. [https://github.com/web-push-libs/web-push-php](https://github.com/web-push-libs/web-push-php)
Once we have typed properties I'd love to see something along the lines of C#'s auto implemented properties: public string Name { get; set; }
But with "fn" the "=&gt;" is superfluous.
No it isn't, there may be a return type hint: `fn($x: Foo): Bar =&gt; $x + 1`. You need the separator or the grammar is ambiguous. But also I would argue visually it works better. The point of the arrow syntax is to denote a [mapping](https://en.wikipedia.org/wiki/Maplet): `&lt;input&gt; ‚Üí &lt;output&gt;`.
I commend you for your persistence. I like to think I know a little about crypto, as well, but if I did this... the WordPress devs would have said no (as they did to you) and then I would given up and not pursued the matter further. Of course, I think it helps that you (it seems to me) do this not only as part of your full time job but also in your free time. Whatever I do, OSS-wise, is done solely in my free time. My 8-5 just has me working on some in-house product that is of no relevance to the greater PHP community.
Ok, that makes sense. I saw "Existing Drupal / Ubercart" but didn't clue in. Drupal Commerce for Drupal 8 is really pleasant to work with (but Drupal itself maybe not).
This is pretty easy to cobble together using the excellent [mPDF](https://mpdf.github.io/). I use it myself, here's some code of a pretty basic example: [Generate Invoices](https://pastebin.com/dn6BSDGa). Don't use it in production, it's bad code. But it should hopefully help you get started.
Have you done composer dump-autoload ?
I did a composer update to install it and that‚Äôs when laravel exploded with its package discovery. I could try a composer dump-autoload but how would that fix my problem if composer update breaks when laravel runs its auto discovery features
Good job with these guys. &amp;#x200B; # Swoole 2019: Simplified and simplified [https://bzdww.com/article/280761/](https://bzdww.com/article/280761/)
My requirements are 1. MySQLi based 2. Uses modern PHP 3. Well maintained 4. Not too complicated. Probably I'll use frameworks in real life projects. But I was curious about what people use those who don't use frameworks or cms.
It is very flexible and quite feature-complete, but setting it up as stand alone component can be pain if it your first time interacting with sf security component
You could step through the composer code to see which directories it's actually looking in. When I do that for the same thing, I normally find a typo...
I‚Äôm probably gonna have to do that. I‚Äôm sure it‚Äôs something small and simple that I‚Äôve overlooked
Try adding the zipcode in composer.json
Use oauth2 from the php league: https://oauth2.thephpleague.com
I'm a Symfony developer but this may be just a composer issue. I would suggest changing this: &amp;#x200B; "repositories": [ { "type": "path", "url": "./packages/health" } ], "require": { .... "health/datasets": "*" }, To this: "repositories": [ { "type": "path", "url": "./packages/health", "options": { "symlink": true } } ], "require": { .... "health/datasets": "dev-master" }, The issue a composer update for the package: $ composer update health/datasets Also make sure he url is correct, you could even try a full path just as a test.
CakePHP has begun breaking out their components quite nicely https://github.com/cakephp/authentication however I imagine the Symfony component is more widely used. I'd start there as /u/eagle_monk suggested.
Can we get a mod up in here?
These are the lines causing the error message: &amp;#x200B; function ADTH\_dashboard\_widgets() { global $wp\_meta\_boxes; add\_meta\_box('aob\_feed\_widget', \_\_('Rockstar Guides and Tutorials', 'adth'), ADTH\_AoB\_feed, 'dashboard', 'normal', 'high'); add\_meta\_box('aob\_extras\_widget', \_\_('Game Changing WordPress Tools', 'adth'), ADTH\_AoB\_recommends, 'dashboard', 'normal', 'high'); }
Try adding single quotes around that ADTH_AoB_feed, like this: 'ADTH_AoB_feed' and see if the warning goes away and the site/theme still works afterwards.
//code golf anyone? $x = htmlentities(@$_GET['x']); $t = @strtotime($x); echo "&lt;form&gt;&lt;input name=x value='$x' placeholder=dob&gt;&lt;input type=submit&gt;"; if($t) echo 'u r ' . (strtotime('now') - $t) / (365.25 * 86400);
Have you considered letting PHP solve this for you? It has a really powerful understanding of dates. https://www.php.net/manual/en/datetime.diff.php
The correct way to use sudo: \`wget [https://nsa.gov/coolstuff.sh](https://nsa.gov/coolstuff.sh) &amp;&amp; chmod +x [coolstuff.sh](https://coolstuff.sh) &amp;&amp; sudo ./coolstuff.sh\`
It Works with the 'ADTH\_AoB\_feed' - your a genius
&gt; PHP's short open tags clash with XML Raise your hand if you've had to use XML in the last 5 years. Anyone? This RFC is a complete waste of time. There's no harm in leaving the short tags if people want to use them. It's very useful for basic templating using if, foreach etc. And if on the off chance your site needs to do some XML, then turn them off and use find/replace to use the full open tag.
Solid explanation and i guess just the right fix for this issue. In php 4 times this was not unusual to use dynamically assigned constant strings as php is guessing them anyways. Saw a lot of that crap. BTT: The issue was there for ages. Due to the php upgrade your setting for `error_reporting` has changed. Expect more issues like that as php reports notices as of now or lower the report level to warnings. Please see https://www.php.net/manual/en/function.error-reporting.php to learn how.
thanks so much for the info
Try r/phphelp
I don't get the repositories part of your composer setup. You tell composer to copy your library from packages within COMPOSER_HOME, which is inside of your app anyways. So why installing the package via composer. Is this a library you developed on your own? The way i do such things is, I point composer repository to the github/gitlab url and use type git.
I read the title as arrow functions but I didint disappointed nice. Nice article
Had No idea about compact/extract! Thanks
In legacy code this was perfectly legal and the right/ recommended way in some cases, e.g. for array keys: $foo[bar] vs. $foo['bar']. It just got more strict over time for various reasons. :) Lots of my old legacy code from the early 2000s uses array keys like that at least. I guess those things won't survive PHP 8 w/o adjustments. :D
I have never seen composer.json's psr4 key used like that so I'm not sure if it's a shortcut. But as per documentation, it should be "autoload": { "psr-4": {...}}. Also you need to dump autoload after that.
I started skimming very soon. The beginning reminded me too much of rich hickey's easy/simple talk. This article tries to discuss half of the problems we have and tries to unify it under KISS. I am actually starting to think that all the helpful acronyms are part of what drags things down. How is an article that explains KISS not remotely KISS? Because it is just very fuzzy, just like any other acronym/principle/mantra you can find in development.
hey hi..can you elaborate??
For the sake of your colleagues you should probably forget about extract again
That‚Äôs pretty bad oversight to commit when writing code. As the theme is no longer maintained and the code quality is questionable, it‚Äôs time to begin migrating to a new theme. Something tells me that miswritten variable is only the tip of the iceberg.
this is not the place to seek help
&gt; simplicity in software This would have been a better title.
I'm currently doing unit testing using PHPUnit and endpoint testing using Postman for a small personal project/training of mine. Need recommendations for functional testing - I read that Codeception would be my best bet? Behat might be a bit of an overkill for my situation... Opinions? Thanks!
According to which rule exactly?
Youre problably right! Nice to know for CodeGolfing though!
I use Codeception in most of my projects and had pretty good experience with it. You need to have a bit of discipline with setting your different suits up and keeping the kinds of tests separated (e.g. not mingling Unit+Functional tests). I recommend you just give it a spin and see for yourself if it suits you. It's pretty easy to get started with and the docs are pretty good (at least for their core parts).
rule number 4
No mention of array_map, array_filter or array_reduce? All very very important functions. Also i'm very interested as to peoples opinions on array() vs [] to create an array. To me [] makes so much more sense because of the way you access an array element but it seems everybody has a personal preference.
Cool, maybe I'll give it a go. Thanks!
Come on, what you're asking from a blatant blogspam article? The purpose of this half-assed article is not to share the knowledge but to promote a corporate blog/snach a penny on ads. Regarding your question, [] is a recent addition to the language, a syntax sugar for array(). There is no difference between the two, neither one makes more *sense* than another. So it's indeed only a matter of a personal preference/ accepted coding standard.
What do you understand under "functional testing"? I've seen so many companies define that term differently.
phpunit is probably used for functional/integration testing more than it is for unit.
&gt;\[\] is a recent addition to the language Recent. Came with PHP 5.4. Released 1st March 2012. 7 years and a few months ago. Recent. &amp;#x200B; I get what you mean, but really, 7 years ago isn't recent :P
``` echo "&lt;form&gt;&lt;input name=x value='" . htmlentities(@$\_GET\['x'\]) . "' placeholder=dob&gt;&lt;input type=submit&gt;"; if(!empty($\_GET\['x'\])) echo 'u r ' . round((strtotime('now') - (int)@strtotime($\_GET\['x'\])) / 31557600); ```
Marketing/documentation - 7/10 Code - 1/10
You are using prepared statements but your code is still susceptible to SQL injection attacks.
Can I ask why? I‚Äôve never used it but it seems kinda useful.
Codeception. It can also run your PHPUnit tests without change.
&gt; Also i'm very interested as to peoples opinions on array() vs [] to create an array While the style guide PSRs don't explicitly say use one or another **all** code examples use brackets only. There is a strong argument in favor of brackets: It makes you faster _skimming_ over code. Imagine any function that takes an array as argument and you write an array literal: $collection-&gt;addMultiple(array( // some lines )); $collection-&gt;addMultiple([ // some lines ]); From just looking at the last line of the first call you won't know that the argument is an array and not a function call or any other expression wrapped in parenthesis. From looking at the bottom example it's immediately obvious there is an array literal from looking exclusively. PhpStorm btw has an inspection for traditional to short array syntax. With "run inspection by name..." you can run and fix it for a whole project with the press of a single button.
When using extract($arr), further down you're most likely going to do something with those extracted variables and anyone unfamiliar with the variable won't know where the hell they are from. Even the IDE won't be able to tell until you specifically annotate where it's from. &amp;#x200B; Just adds to unecessary confusion imho. Plus, if the array isn't static length-wise, you might end up declaring a ton of pointlessly declared variables.
Little bobby tables
It's not an unreasonable request that people have tried the products they recommend. Try a subreddit like /r/crm instead. This subreddit is probably to focused on the programming for you to get the recommendations you seek.
Personally I really like Behat for that use case. I've used it for testing API endpoints in the past, and I've found it does tend to limit the amount of boilerplate I have to write because you can easily reuse step definitions.
I call it a [cargo cult prepared statement](https://phpdelusions.net/pdo/cargo_cult_prepared_statement)
 printf("&lt;form&gt;&lt;input name=x value='%s' type=date&gt;&lt;input type=submit&gt; Age %s", @$_GET["x"], (new DateTime())-&gt;diff(new DateTime(@$_GET["x"]))-&gt;format("%yy %mm %dd"));
Well, I remember when sessions has been moved from phplib to core in PHP4 and it was like wow. So for me it's recent :)
I see, thanks!
Nice throwback to 2008
&gt;Well, I remember when sessions has been moved from phplib to core in PHP4 and it was like wow. So for me it's recent :) I remember having to work out how to write a security fix that necessitated the use of === for PHP3. (for reference, it was basically: `if(($a == $b) &amp;&amp; (gettype($a) == gettype($b)))` though it's been... a very long time) &amp;#x200B; I don't consider any of that recent, though :D
Articles like this make me hate blogs
If you don't want to store usernames/passwords or want to allow users to sign in with external accounts like Google or Facebook, I've only had good experiences with [Firebase](https://github.com/kreait/firebase-php/blob/master/README.md)
Looks like this linguistic issue took more attention than it deserves. Whatever you insists, recent is not a proper word, if it matters that much.
It does a lot of many things üòÇ
&gt;This exclusive climaxes your project. Say what now...?
What language is this? ^((no, I'm not talking about the programming language))
I'm thinking hindi shoved through google translate
Are we at a point where we can set the log level for Stackdriver through Docker?
Come on, what you're asking from a blatant blogspam article? The purpose of this half-assed article is not to share the knowledge but to promote a corporate blog/snach a penny on ads. /u/ZabronWix is just a blogspammer, his links are a shitshow, the most recent one was the usual "[CRUD with sql injection](https://www.reddit.com/r/PHP/comments/bm31j1/simple_php_crud_application/)" tutorial. There is nothing to discuss, just report it for the mods.
The graph at the bottom of the post is rendered incorrectly though; it's a common mistake, ab doesn't output in time sequence. http://www.bradlanders.com/2013/04/15/apache-bench-and-gnuplot-youre-probably-doing-it-wrong/
Never looked into Zend Framework till this moment. [https://docs.zendframework.com/tutorials/in-depth-guide/understanding-routing/](https://docs.zendframework.com/tutorials/in-depth-guide/understanding-routing/) Looks like array hell.
&gt;What madman would evaluate Ubertcart for Drupal instead of Drupal Commerce? lol. XD
I posts stuff to see how the community reacts and if there is mistakes I'll correct them as possible, Im trying my best to bring good quality contents.
Did you try to drag it from `Applications` to the trash?
Really? All the resources I read - even my supervisor insisted that PHPUnit is mainly used for unit testing.
Having skimmed through Behat's documentation, it looked intimidating at first glance. I feel like it would take me some more time to get the hang of it, if I compare it to Codeception.
Good to know, thanks!
From what I understand, it ensures a specific component of the code works. In my case, it is to test that a certain function in a class is working and behaving as expected when given input.
Final-by-default would be an improvement, but as it isn't, typing more redundant boilerplate in our classes with the idea that it makes code better is hardly helpful in the end. When I write a library I keep most of the classes "private" (as in in a subnamespace called "Internal" within the project, with a stern warning that everything in that namespace is subject to change and not to be accessed outside the package). Instead I focus on exposing what I need to expose via interfaces and factories. The few classes I may have to expose directly may get a "final" to stop people from trying things. But I believe instead of trying to constrain every single class in our library from being abused, we need to have a walled off "internal" space where we can shove all our implementation details without bothering with execessive formalities.
phpunit or codeception
( Õ°üëÅÔ∏è Õú ñ Õ°üëÅÔ∏è
You really can use any modern testing library for functional testing, just plug Guzzle to PHPUnit and you can test your APIs or use something like [https://github.com/nesk/puphpeteer/](https://github.com/nesk/puphpeteer/) and test web application with ease. I have found this gem years ago and been using it since in many projects [https://github.com/kahlan/kahlan](https://github.com/kahlan/kahlan). You can adopt any modern-grade HTTP or headless browser wrapper PHP library to test applications in functional way or even for integration testing.
Most of my projects I use Codeception
There is also an `internal` defined in the phpdocs but it isn‚Äôt respected by IDEs.
That's unit testing and you can use PHPUnit for this type of tests. Functional testing is, in general, testing the components (pages, API resources, etc.) of application to adhere business rules and user expectations in isolated manner (no DB or any side-effects). If you develop SPA, than most of the functional testing should be done on frontend side of the application with server mocks. On the other hand, testing APIs functionally can be done with any testing library such as PHPUnit, Codeception or other - you just need to chose right tool to perform API requests and assert responses. Full-scale testing involving backend and frontent sides called integration testing, which often includes DB interactions like in real-world application but on stand or stage environments.
What the fuck is that!? No wonder the devs were fired!
I see, thanks!
All of my classes are final by default and I'm yet to find a situation where the class can't be made so or the result would make the code worse. The obvious exception to that rule are Doctrine entities (because of proxies for lazy loading), but really nothing else. &amp;#x200B; There is a nice article from /u/Ocramius on this topic: [https://ocramius.github.io/blog/when-to-declare-classes-final/](https://ocramius.github.io/blog/when-to-declare-classes-final/)
In my experience, the only time it can get annoying is if you need to mock the class while writing unit tests. I've seen hacks that use reflection to get around this but do not really solve the actual problem... that you can't mock classes that are declared final.
I agree for the most part, however if you need to mock the class, it *may* be a sign that the code should be refactored to use an interface or an abstract class instead. There are also types of classes that should never be mocked anyway such as value objects.
Can anybody recommend ‚Äûhardcore‚Äú programming podcasts? No high level stuff but some talk where you might ‚Äûlearn‚Äú something?
Fight me. Bitch
No, but [here's the source code](https://github.com/php/php-src).
There's this: [http://www.phpinternalsbook.com/](http://www.phpinternalsbook.com/) More recently, Ed Barnard started a series to dive into this topic for me at php\[architect\] [https://www.phparch.com/article/internal-apparatus-how-php-works-show-me-the-code/](https://www.phparch.com/article/internal-apparatus-how-php-works-show-me-the-code/)
isnt it the other way around, integration testing is testing some- or more components but not the entire thing. fully functional (hence functional tests) systems with whatever is needed = functional testing (=== e2e?), usually frontend and backend included, but-- testing a REST API without a frontend can also be functionally tested.
Is this FLOSS? I would like to look assess it for our CI pipelines
Add some functional tests using TravisCI.
This is what got me into PHP core development: https://nikic.github.io/2012/07/27/How-to-add-new-syntactic-features-to-PHP.html
What tools is this using?
Anybody used this? Any cool stories or interesting gotchas?
##r/jira --------------------------------------------- ^(For mobile and non-RES users) ^| [^(More info)](https://np.reddit.com/r/botwatch/comments/6xrrvh/clickablelinkbot_info/) ^| ^(-1 to Remove) ^| [^(Ignore Sub)](https://np.reddit.com/r/ClickableLinkBot/comments/9wy10w/ignore_list/)
I would love for PHP to include something similar to Erlang actors instead of the mess that is pthreads, swoole, amphp, zeromq etc. The actor model is such a beautiful solution to the concurrency problem.
$6.99 an issue, or $4.99 a month? Weird.
Seems like normal subscription pricing to me...
There's no minimum commitment, as far as I can tell, so as I read it, you'd be silly to go for the $6.99 instead of just going for the $4.99 and cancelling before month's end. You even get back-issue access with the subscription.
The thing is, my supervisor doesn't allow me to use Guzzle. I'll look these up, thanks!
Yeah, I also understand it as this. Unit testing is done in isolation, but not functional testing - thus why PHPUnit isn't really the best choice for functional testing.
Everything on this board is confusing because there isn't a message body.
I suggest you to use an SMTP service (like Mailjet, Sendgrid, Mailgun or even Gmail and so on) in order to getting rid of the `mail()` for various reasons (security, efficiency, mail deliverability, etc). Another solution can be SES (Simple Email Service) but it's *very basic*.
`session_start()` will parse the incoming request cookies to see if the session cookie was mentioned by the client. If so, it will hydrate the stored values from that cookie into the `$_SESSION` object. In case that no cookie is present, it will generate a new session id and emit it via the `Set-Cookie` response header which will make the client automatically store it for the following request. The `Set-Cookie` response header will always be present when you call `session_start()`
How do I incorporate this into the MyBB platform, which is set up to work with PHP Mail?
Right, but when does it emit it via the Set-Cookie response header? When session_start() is called? Or is the emitted Set-Header added to a stack of headers that all get output at once, after execution has finished? (Sequencing...)
It‚Äôd added to the stack of headers and emitted before the response body is emitted. For example if you echo anything, the headers will be emitted right before the first echo statement. Headers are sent right before the output buffer is written to.
It‚Äôd added to the stack of headers and emitted before the response body is emitted. For example if you echo anything, the headers will be emitted right before the first echo statement. Headers are sent right before the output buffer is written to.
So even if I've used session_start() and pulled data from $_SESSION, I can still, e.g., use a Location header 302 redirect? Many thanks!
Yes absolutely.
Im getting problems with Scrollable Pagination. When i reac the end of the list, it doesnt load more itens (get a error:"No More itens". And if i remove the button "Read More", it doesnt even try load more itens. Codes: Index &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Spotteds&lt;/title&gt; &lt;script src="http://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"&gt; &lt;style type="text/css"&gt; .ajax-load{ background: #e1e1e1; padding: 10px 0px; width: 100%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="container"&gt; &lt;h2 class="text-center"&gt;Spotteds&lt;/h2&gt; &lt;br/&gt; &lt;div class="col-md-12" id="post-data"&gt; &lt;?php require('db\_connection.php'); $sql = "SELECT \* FROM list ORDER BY id DESC LIMIT 10"; $result = $conn-&gt;query($sql); ?&gt; &lt;?php include('data.php'); ?&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ajax-load text-center" style="display:none"&gt; &lt;p&gt;&lt;img src="https://scripts.guru/wp-content/uploads/2018/12/loader.gif"&gt;Loading More post&lt;/p&gt; &lt;/div&gt; &lt;script type="text/javascript"&gt; $(window).scroll(function() { if($(window).scrollTop() + $(window).height() &gt;= $(document).height()) { var last\_id = $(".post-id:last").attr("id"); loadMoreData(last\_id); } }); function loadMoreData(last\_id){ $.ajax( { url: '/loadMoreData.php?last\_id=' + last\_id, type: "get", beforeSend: function() { $('.ajax-load').show(); } }) .done(function(data) { $('.ajax-load').hide(); $("#post-data").append(data); }) .fail(function(jqXHR, ajaxOptions, thrownError) { alert('Sem menssagens para serem carregadas...'); }); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &amp;#x200B; Data &lt;?php while($post = $result-&gt;fetch\_assoc()){ ?&gt; &lt;div class="post-id" id="&lt;?php echo $post\['id'\]; ?&gt;"&gt; &lt;?php echo 'ID: '; ?&gt; &lt;?php echo $post\['id'\]; ?&gt; &lt;p&gt;&lt;?php echo $post\['details'\]; ?&gt;&lt;/p&gt; &lt;div class="text-right"&gt; &lt;button class="btn btn-success"&gt;'Read More'&lt;/button&gt; &lt;/div&gt; &lt;hr style="margin-top:5px;"&gt; &lt;/div&gt; &lt;?php } ?&gt; &amp;#x200B; LoadMoreData &lt;?php require('db\_connection.php'); $sql = "SELECT \* FROM posts WHERE id &lt; '".$\_GET\['last\_id'\]."' ORDER BY id DESC LIMIT 5"; $result = $mysqli-&gt;query($sql); $json = include('data.php'); echo json\_encode($json); ?&gt;
[https://community.mybb.com/thread-63180.html](https://community.mybb.com/thread-63180.html). I just googled "smtp mybb" not sure if this helps but seems to be resources out there.
Your asking for a visit from little Bobby tables in that query. Look up pdo
sorry, i dont get it (Who is bobby ??? ) Can you show me where to look? Thank you for replying
I'm very interested, recently understood that was is not just a "faster javascript", but actually incredibly useful
As opposed to 10% to 16% space faster?
Without tests, many devs won't touch it as they'll assume it doesn't work or is buggy.
&gt; $sql = "SELECT * FROM list &gt; WHERE id &lt; '".$_GET['last_id']."' ORDER BY id DESC LIMIT 5";
thx, i will search for the problem .
https://xkcd.com/327/
Yep, you right. Something was messed in my head in terms of... Well, terms. ) The thing i described as integration testing is called acceptance testing. Functional and integration testing is kinda same thing.
Nothing I‚Äôm aware of yet.
Well they're all wrong. Look, here's the latest from Laravel documentation, note the namespace is `Unit` but they `RefreshDatabase`. Obviously if you are using a database you are **not** doing unit tests. &lt;?php namespace Tests\Unit; use Tests\TestCase; use Illuminate\Foundation\Testing\RefreshDatabase; class ExampleTest extends TestCase { /** * A basic test example. * * @return void */ public function testBasicTest() { $this-&gt;assertTrue(true); } } https://laravel.com/docs/5.8/testing
In r/PHPhelp you'll have a better chance for a meaningful answer with questions like this.
Yo dawg I heard you like pipelines so I put some pipelines in your pipelines so you can pipeline
\[x\] THIS \^
I was forced to code in Behat for 1/2 of 2016 and believe me, it's as horrible as it first looks. Codeception any day!!
You forgot K8 for even more layers on top. What do you mean by using xcopy?
The idea of simplicity is very fuzzy to me. That's why KISS is fuzzy as well. I agree though, in general principles and acronyms mean everything and nothing. On the other hand, we need to name the principles we should try to follow. We need to abstract them, somehow. I describe the problems I want to put under the definition I give at the beginning of "simplicity / complexity". I always try to stay into this "too many interconnected parts" problem. What do you think is not about simplicity / complexity in this article?
&gt; simplicity in software &gt; &gt; KISS and simplicity are synonyms to me... are am I wrong? What about "KISS in software development: how to avoid complexity?"
You're not wrong, Walter, you're just an asshole.
thanks for the suggests. I will write tests for it.
You're right, I will write tests for it. thank you.
https://docs.bitnami.com/bch/apps/mybb/configuration/configure-smtp/
What about automating fixing instead? :)
Adding layers is the principle of abstraction: it's meant to hide the complexity. Complexity is not always bad. In the case of Docker, it's good to be able to have exactly the same environment everywhere, easily. It has some tradeoff, like everything. You just need to be aware of them as well.
Sexy girls waiting for boys: http://ztfd.xlfudtzk.org/mtaukstw/
Hah, thanks for the heads up üòÇüòÇ
Czech girl orgies: http://ztfd.xlfudtzk.org/mtaukstw/
Check how hot babes party: http://huwt.6r0s7p93.org/bo2hqirx/
You should be able to point your code (You connection string, for example) to the desired SQL instead of using localhost (the one provided by XAMPP) Usually databases block remote root access by default, so you may have to configure the remote SQL server accordingly. Searching your post title's on stackoverflow should provide detailed answers to both. Happy coding.
You don't need to do anything in xampp. Just use the URL and the credentials of the mysql database you want to use in PHP code. BTW, this is not recommended. Always use a local db for development and testing.
why not? :D
Best pr0n: http://oa07.q6vzn0yq.org/hxko22ka/
This can be amazing tool to slowly migrate PHP project to another lang ;)
Need a partner for this weekend? Find one here: http://0fz9.yatv3cuz.org/fam4sc2m/
I maintain a Docker PHP image that builds it from source, you might find it useful: [https://gitlab.com/1ma/dockertronics/blob/master/php/Dockerfile.73](https://gitlab.com/1ma/dockertronics/blob/master/php/Dockerfile.73) I used that "PHP Internals Book" resource that someone else already mentioned as a guide.
Crazy girls do crazy things: http://4cbl.ylgrgm1p.org/vounvhok/
I'm looking forward to not having to use `array_merge` anymore!
Meet the love of your life: http://0fz9.yatv3cuz.org/fam4sc2m/
Petite young females screaming out of pleasure http://3ncy.3t1bjn48.org/biswbab7/
Oh my god this going to be so helpful when writing functional code. Would go really well with some tail call optimisations!
Excellent news and excellent feature, thanks PHP internals, you rock!
This account posts [nothing but links to the same named site](https://www.reddit.com/user/helpdeveu). Nothing more than blatant spam.
&gt; It's possible to do the expansion multiple times, and unlike argument unpacking, ‚Ä¶ can be used anywhere. I wonder why we still have this limitation for arguments.
Seems like it would be a performance hit to check for triggers on every cascaded delete, and might spiral out of control if there was a trigger and millions of records were deleted that all had millions of related foreign records. The initial delete that caused the cascade should have its own trigger that covers everything in a single firing. I've never had to use cascaded updates... why would you use anything other than a fixed internal ID as a foreign key, and why would you need to update that?
Interesting how salathe is the only person voting no for this...
\['some' =&gt; $some, 'thing' =&gt; $thing, ...$else\] = $arrayWithStringKeys; &amp;#x200B; Pretty please?
You mean the ...$else part?
How come?
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
I meant that it was just interesting to me that he's the only red on the vote.
Oh, ok. I thought you had some insight into them based on their past voting habits.
I just checked some of his past votes and hmm ü§î Interesting...
Really? Or are you joking? It's still too early in my timezone for your shenanigans!
Well, I actually did check and he seems to dislike a fair amount of what I like :) Some examples: * https://wiki.php.net/rfc/deprecate_php_short_tags * https://wiki.php.net/rfc/arrow_functions_v2 * https://wiki.php.net/rfc/negative_array_index
Brilliant timing, now they just orphaned their project. &amp;#x200B; \&gt; IMPORTANT: THIS PROJECT IS ORPHANED \- [https://github.com/phpmd/phpmd](https://github.com/phpmd/phpmd)
Great job!
Oh my god, code review is going to be **more** of a nightmare! How many of these voters have recently managed a team of borderline incompetents who know more than enough to shoot themselves and the organization in the feet?
Peter Cowburn salathe About Software Engineer at Akamai by day. &gt; PHP manual editor mostly, and helping to maintain the *.php.net websites, adding bits and pieces to the language itself, discussing and moulding the bright future of PHP! &gt; Archaeologist when I can escape work. My main area of interest is later prehistory in western temperate Europe, particularly the Iron Age of Scotland. Like Indiana Jones, but cold, wet and muddy. He knows how this ends. Badly.