As a Dev: Learn Git or Subversion
Change jobs. Do it now. It sounds like you know what you need to start with. Proper development environments, version control and automated deployment. As for what to learn next it's hard to say from what you've mentioned - if the code you're editing live is procedural, start learning OOP. 
The earliest turtles had teeth and could not retract their heads, but other than this, modern turtles are very similar to their original ancestors.
"full stack" generally means advanced knowledge of every layer of the application stack, including how it is developed and deployed... do you know how to configure network routing tables, or DNS, or TLS/SSL? do you know how to setup a web server environments with multiple front-ends sharing a master/slave database environment with automated backups and recovery? do you know how to use version control systems with forks and branches for dev/test/prod, with an automated build/test/deploy process? HTML/CSS/JS/PHP/MySQL are all just parts of the application layer of the stack... a standard web developer role. if you apply for a "full stack" position, don't be surprised when you're expected to understand all that other stuff and build something from scratch. the way you work is not good, but way more people work that way than they should. maybe even more work that way than don't work that way. it stays like that, because if your clients understood the problem, they wouldn't need you, and they certainly wouldn't pay you... but here they are paying you, so what's the problem? 
[removed]
This is exactly what I did. I was working at a pretty good company for 3 years straight after completing university. The company was great in every way. It was small, casual, pay rises every year. However there was a problem they were using a programming language no one used and the way they developed was all procedural and the framework was a mess. Good thing was I was doing side projects and basically teaching myself everything I needed to know from starting to use Linux as my main os so that I was comfortable with servers to networking and setting up a homelab using proxmox. I started looking for a job and in May I finally found a good job. I applied for a junior position and my new manager told me that the enthusiasm I had is what he liked about me and that my skills were a lot more better than some seniors that applied for the iob(he was looking for senior but he said he wanted to snatch me up before someone else did and offered me the job at the end of the interview! ) The problem with him changing jobs now is that he might have to get a pay cut and if he's okay with that then yeh he should go for it but personally I think he should build up his skills and take his time before he does something drastic. He is in a better position then I was in that he actually has experience in a relevant programming language. He just needs to improve his skill set and once he can show he knows modern standards he should then start looking for a new job 
Nice troll headline that doesn't communicate at all what the article is about. Skipped.
There are two things which are screaming just to quit the job. PHP 5.3, and no version control. Dude - do yourself a favor quit this job, every other company is better than this. If you lead developer does not care about his software he is simply a douche. Lead development is not only a thing about "I do say how the software is developed". He should also take care about the developer experience. It is something like UX but for developers. And this what you are saying is just bullshit of him. So quit - just that simple. As a tipp, try talking to recruiters, this is so easy. Simply keep your CV ready and they are looking for a good job for you where you have no hassle to look for new jobs yourself.
[removed]
Thanks for the tip. I've been learning git outside of work to try and give myself an advantage
Thanks for the feedback. I wanted to make those two points because I've read time and time again about old versions of PHP and version control. I do feel that my workflow is quite tedious and wastes a lot of my time when a lot of it could be automated. 
I wish it was that easy! The job seems stable with clients happy with the work we are producing and more work coming in from referrals and other marketing. I'm very interested in development and love reading and watching about best practices, web application architecture, Dev Ops and other stuff. I feel that I always compare myself to those blog posts or videos and I always seem to come short. I'm practicing OOP at the moment actually.
Thanks for the overview. My apologies for using the wrong term. The clients obvious only ever see the finished product and are always​ happy. Work is steady and it pays the bills but that's not enough for me. I want to become a better developer because I enjoy it and want to increase my salary. 
[removed]
You need to get outside from time to time.
The context is using PHP as template language. My personal solution for those is that I parse the code anyway, so I can do some transforms, and I can recompile this: &lt;?= foo(...) ?&gt; To this: &lt;?= $this-&gt;foo(...) ?&gt; The global functions are then only declared for IDEs and never loaded. The template is included from the context of an object of class Template that has the right method implementations. That's kind of tricky to pull off easily, of course. As a baseline solution, I'd strongly recommend closures: they're the fastest way to encapsulate a method call as a short local name. If you go the function route, you can implement a stack that ensures that every template sees the correct context when calling those functions, here's a proof of concept: class Template { static $renderStack = []; function render($file) { self::$renderStack[] = $this; require $file; // &lt;-- The actual template HTML etc. is here. array_pop(self::$renderStack); } } function lang_get($str) { return end(Template::$renderStack)-&gt;lang-&gt;get($str); } This would allow templates to invoke nested templates, and it all works out.
 People are insecure assholes ikr we'll show those who criticize php!! :D
&gt; I'm considering I feel like if you open source anything, it should be required to have tests. One off projects, etc... that aren't going to be publically used by possibly hundreds/thousands of other developers might not need tests, but yeah this should be the standard with open source in 2017 and onwards.
Ahh, so basically "oops, I forgot I said that and humor is how I defend my ego." Got it!
You might be able to use git for your current work as well. Even with a local repo it will be very helpful when downloading your local copy of the project with the one which has been touched by someone else in the meantime. Git will happily point out any modified files, which will help keeping track of any changes which have been done by other people. Assuming the projects are small enough that a full FTP sync once in a while is possible.
Wat?
**AHH, SO BASICALLY "OOPS, I FORGOT I SAID THAT AND HUMOR IS HOW I DEFEND MY EGO." GOT IT!** 
Simply put, your lead developer has probably just given up and that's probably a bad place to be working. Version control is a must and if it's not part of your workflow at work, learning it separately or just using it for yourself for work is probably a good idea. You don't have to use it to collaborate (and seems like that's not even an option) but at least your own code will be version controlled. I mean thats less than ideal but if there is ever a time you need to rollback a change, you can at least save everyone's ass. PHP 5.3... if your building small sites, I don't really see why someone wouldn't just upgrade. New sites especially should at least be on PHP 7. Really, the only excuse would be a massive amount of legacy code and even then, it needs to be something that's considered. You are using a version that has been EOL'd for 3 years. Not only is it a security risk for clients, but you can't learn anything new and cutting edge. I assume because of the lack of VC and php 5.3, you also aren't doing unit testing or using a modern framework either? What about using composer or a coding style? If not, those are some major things that should be on every php developers resume, even if it's just a little experience. Sounds like a tough situation and if your lead dev is completely against changing, it might be time to consider moving on. Sounds like you are eager to learn and grow as a dev and there are plenty of jobs out there that like that. You can't grow in a job that uses almost 8(?) year old php versions that's been dead for 3 and it could do you more harm than good depending on any bad habits you may pick up from a lead dev that's checked out (no git pun intended). 
&gt; I'm worried that I'm working in a way that developers did 10 years ago Yes, you are - probably even further back. Heck, just PHP 5.3 is 8 years old. Not using version control or proper deployment techniques is beyond inexcusable at this point. Like other posters, I would very, very strongly suggest you change positions. Finding a place with anything more modern infrastructure will put you in a far better position to learn more and enhance your skills. Honestly, don't even worry about the PHP-specific stuff a whole lot. Read some tutorials on Git, because at this point getting a new job in any sane environment will expect you to at least be familiar with it on day one. If you're motivated, excited, ready to learn, and have at least a basic understanding of programming concepts, getting a better but still junior position won't be too much of a stretch. Even an internship - despite being effectively a step back - could be a good way to ramp up quickly. Being honest about your background and your motivation will probably work in your favor for a junior-level position. I'd be happy to go over any specifics if you'd like. Or if you happen to be in the bay area, I can keep an eye out for openings that may fit.
Instead of displaying them in the browser, you should have errors logged to a specific file. I tend to have a terminal window running the command `tail -f /Applications/MAMP/logs/php_error.log` - This will update the terminal as new errors get logged to that file. Check your php config file to see if and where errors are being logged, and just watch that for output.
I watched a team treehouse course about the .htaccess file and php.inni but I don’t understand it. Right now i just have some php file sin brackets and my site is not showing up anymore in the web browser on my local server so I’m trying to figure out what I need to de exactly to be about to get hints for errors. 
**WAT?**
Well, I wanted to implement enums as classes, and have their members be subclasses. Unfortunately, I then realised that would blow up once you have autoloading with one-class-per-file, because if you deserialised an enum member, it would look for a file that doesn't exist. So that meant I was having to hastily rewrite my code to use a single class with multiple instances instead. The second thing was just general trouble with figuring out how best to structure it internally and how to keep track of instances at runtime. None of this is insurmountable, it just meant I missed PHP 7.2's feature freeze. I'll probably revisit it at some point.
oh, I didn't know it.... I think that we should use it.
Well, the horrible way to do it would be: try { //Your Code catch (\Exception $e) { var_dump($e); } What is you local server environment? Windows? Linux? Are you using a manager app (like WAMP)? PHP will absolutely tell you where the error is. Sounds like a syntax error, and so the server is returning a 500 error. Basically, PHP has encountered an error (in your syntax) so it returns an error to apache/nginx, which returns an error to your browser. So you need to find the PHP logs, delete them, then re-run your pages, and inspect your logs.
It's an old gag; “Nobody goes there any more. It’s too crowded.”
Who doesn't use PHP beside something.js? PHP gets much of the hate because of the power given to the developer. With power comes responsibility and that's something a lot of people don't really understand. I feel like most people that say this are just terrible programmers, i'd hate to see them try out C (oh I should mention, which also uses "the arrow" rather than "dot" xDD).
You can check the default PHP error.log which will show you the source of the issue you are experiencing. In a development environment I usually go with the following at the top of my index: error_reporting(E_ALL); ini_set('display_errors', 'On'); Though **DO NOT** and I repeat DO NOT use this in production, you need to error reporting off and display a user friendly message whilst silently logging the stack-trace in the background of the web server. You can wrap said code around a try-catch block to do the above, though don't over use this too much as it can be quite costly on performance I believe. A good package which can handle the back-end error logging is Monolog, it allows you to output errors to many sources; though a single text file located **OUTSIDE** of the web root will usually do the trick.
Where are the tests?
or change php.ini to `error_reporting = E_ALL` and the other `error_` settings
&gt; PHP gets much of the hate because of the power given to the developer. No. This has absolutely nothing to do with it.
Yes it does. Sites running PHP are notoriously known for getting pwnd due to bad developers not taking proper care of input/output. The tools are there, they're just not used enough or effectively thus you get SQLi, XSS, CSRF, and so on.
This is very simple and I don't think there are any *significant* details to debate besides whether it should be done at all, so I can expect a huge discussion on what colour to paint the bikeshed. My favourite colours are red-adjacent, so something in that part of the spectrum is the kind of pigment I might choose for the shed. Though I maybe have too many red things. How about black and white stripes?
Yes please. Only thing I'm unsure about is JsonException inheriting from Exception. It may be out of scope for the RFC but I think the exception tree needs fleshing out a bit - I'd consider inheriting JsonException from either DomainException or InvalidArgumentException, probably the latter. 
 &gt; Afterwards, one of our junior developers sent me a message in Slack Oh the irony, retards...
So, there's two reasons for why it inherits directly from Exception. One is that the JSON extension has a range of different error codes, so I'm not sure if any one specific superclass is appropriate. For all I know that range could get broader in future, too. But the other, more pressing reason is that those exception subclasses you mention are all in SPL, and the JSON extension might initialise itself before SPL has, preventing it from inheriting from any of those subclasses, as I discovered when trying to make it extend RuntimeException. This could be kludged somehow, but it's not worth the hassle. Also, /u/kelunik told me not to inherit from RuntimeException anyway. :p
Absolutely this. Git can be incredibly useful even if you don't have a remote repo to push to. I used to use it in combination with another VC system just to organize different tickets I was working on. Branch for the ticket, do some work, commit, maybe work on another branch, it was good as just an organizational tool. 
Care to elaborate?
Oh god, if that's the case with something such as this, then I can't begin to imagine the world of pain when (if) PHP chooses to move on from its current form of mentally-scaring notice/warning/error reporting. With your explanation though, I completely get why you're inheriting from \Exception.
Maybe there is irony in the question about people shitting on PHP being sent via a hugely successful application powered mostly by PHP. But, as I eluded to in the post, I don't have a great grasp on irony
Well, PHP 7.0 made great strides in moving away from traditional error reporting. I think the future's bright. And I don't think SPL's exception subclasses really add that much value anyway.
I agree. I open sourced a project a couple years ago with no tests and the biggest point of feedback I got was no tests. From then on I test everything I can. There are so many reasons to test, not the least of which is proving to yourself and to others that your code can be trusted.
Can we set this by default at php.ini? 
&gt; (oh I should mention, which also uses "the arrow" rather than "dot" xDD). It uses both, `x-&gt;y` is essentially just a more ergonomic form of `(*x).y`.
It **is** that easy. Start interviewing elsewhere. If you get a decent offer and the circumstances are right, accept it and give notice. It sounds like the only thing keeping you there is you, and the longer you stay, the harder it will be to progress in your career.
Black and white stripes are good, except that your bike shed would look like a zebra, which could make it difficult to spot should you accidentally leave it on the African savanna. 
Touche :) It's a great one, and looking forward see this merged to 7.3 or even better 7.1.something!
Start using composer, start implementing SOLID principles in ur code, apart from learning version control. Power up sublime text with packages such as sublime linter for JS and Php. 
This would be a very welcome addition. I always find myself pasting the same helper functions into each project to do essentially the same thing manually. The inconsistency in PHP functions and error handling continues to be a major frustration.
The clients are happy with what you're doing, but they don't know any better. They see results and that's all they can judge by. Are *you* happy with what you're doing? Obviously not or you wouldn't have posted this. Imagine what you'd learn if you had a job where you weren't coding like it's 1999. The longer you stay in this job, the less junior you become and the more inexcusable it is for you not to know how to do things properly. If I was interviewing you, I could understand your current situation after 2 years. 3 years? 4 years? Not so much. You're hurting your future employment chances and career progression. Change jobs. 
As everyone else is saying. You should probably find a new job. In the mean time you should go about improving your current work environment which is then something you can list on a resume/talk about in an interview. Still being on 5.3 and no version control are obvious flaws. Pick one and start working on implementing it in your work environment. You'll probably have to sell the lead developer on it so give it some thought on the benefits it will provide and the work it will entail. Personal opinion: I feel like subversion will be an easier sell as tracking changes is very tangible and incremental implementation(one project at a time) is easy to stomach. Further personal opinion: I haven't used subversion in a very long time, but GIT is very easy and can even be 'used' without creating separate branches which would be nice for someone adverse to anything over FTP.
[removed]
Yeah but that's always what you get when you do OOP in C. If you want inheritance you need to pass around pointers after all
You have the same problems with NodeJS or Ruby, the language won't protect you from SQLi or CSRF. The only true security issue is the fact PHP files can be altered and then run using a simple URL, the issue doesn't come from the language but from the way PHP is executed. 
We weren't working like that not 10 not 20 years ago. If you like the place, just not the lead developer's way you can try to step up. Start suggesting using git, updates, modern workflow. Not only to the lead developer but to his boss too. Being higher level developer is not only being better at coding. Take more responsibilities and use the influence that comes with it to present change opportunities to decision makers.
nit; json_decode's return value can be differentiated from error: $a = json_decode($b); if ($a === null &amp;&amp; $b === "null") { /* happ shittened */ } But that's just playing to your bikeshed crack. :p I endorse exceptions and welcome our new flag overlords.
I see the appeal of that (not having to always pass JSON_THROW_ON_ERROR), but I don't think that's a good idea. If you have a dependency on library that relies on json_decode's broken error handling and json_last_error(), setting this option would trigger uncaught exceptions.
If you have control over the whole project, working with exceptions is a fine thing. If you only control a plugin, you must not throw exceptions into the main project... I happen to to more plugins than whole projects...
I'm not a friend of "if() else" either, but I saw "safe code" fail so many times... If a failour has bad visible consequences, I definitely put an "if()" around it. (And as a RPG Master I have a big imagination)
I can't offer better advice than anyone else here has already done. However, I can offer some words of encouragement from someone who was basically in your shoes until recently when I handed in my resignation. As soon as I'd quit, even though I still have to stay for the rest of the month, I felt some sort of relief. My own motivation for learning coding stuff in my spare time - in anticipation of my new job - somewhat instantly returned, and at this point I wonder why I didn't stop working in the stone age long ago. Possibly a mix of me not being 100% comfortable that I could actually perform in a new, more modern work environment. Go for it man, the world is out there for you to grab!
Didn't you mean $b !== "null"? Otherwise it would be correct.
I believe one of the issues they see with your approach, is that you may risk inserting the ad in the middle of a sentence, when you simply insert it strictly after 60% of the $content. You may even accidentally insert the $ad inside an HTML tag in the $content I would suggest a slightly different approach using something like DOMDocument. Assuming $content is simply a HTML string with multiple paragraphs &amp;lt;p&gt;, you can use an approach sorta like [this example](https://stackoverflow.com/questions/39984379/how-to-insert-new-element-after-specific-element-in-html-using-php). This allows you to treat the $content HTML in a Javascript-ish fashion but in PHP. To insert the $ad at a percentage of the content, you can perhaps try an approach of couting the number of DOM elements of $content and hitting as close as possible to the desired position. DOMDocument should allow you to do this and more.
&gt; enums as classes Why not just make enums first class objects?
Indeed. PHP is pretty restrictive in what it allows you to do. Think object/scalar semantics, scoping, concurrency, monkeypatching, operators. There are many languages which give you more choices.
&gt; so I can expect a huge discussion on what colour to paint the bikeshed. I propose we rename this flag to JSON_WORK_AS_IT_SHOULD_HAVE_IN_THE_FIRST_PLACE. I'm writing an official letter to the core committee and we can discuss this at our next formal gathering.
Wat?
**MICATHON'S LATEST CREATION** 
When I'm looking at that [color theme](https://camo.githubusercontent.com/58a10894f96fa5fae33f54bfcc45966638dea599/68747470733a2f2f6b617a75616b696d2e6769746875622e696f2f536c69646553686f772d56696d2d666f722d5048502f696d672f76696d382e676966) my head is playing [this sound track](https://youtu.be/Y4YwqS1l8U4?t=42s) for it.
That could also work, but note that this might still insert the ad mid-sentence or even mid-word. Also, this will remove all images and special formatted text without an option to recover them after inserting the ad. That said, as long as it gets the job done, it's not an all-bad solution. Just remember that later refactoring and change in requirements may become a bit more of a hassle to maintain. :) Good luck, chap. And have a good one :)
I don't like exception suffix. : ) I suggest something like JsonParseFailed. Overall, thumb up for idea.
I am in the same boat and am always searching for a self hosted option as well and with pecls php-am support being so bad, I don't really consider it an option. I looked at Fiery, but with its lack of english support and little information about it, I can't really consider it an option either. It looks like it has potential though if it did. It amazes me that there aren't better options out there for such a widely used language.
Yeah that's right. It's pretty copy-pasta for everything, I recently hit upon it a few times when writing a custom JWT library and noticed Firebase had done likewise.
Yet there's way more shitty php websites out there than ruby and nodejs, not being maintained and updated because of those security flaws. That's the point /u/divulging is trying to make. It's not the ONLY reason people shit on php, but it's up there w/ the language issues that dominated in php language in versions 1-4. PHP is an easy target for it's past and accessibility unlike other languages.
Ah, but can't null have surrounding whitespace? ;) Anyway, “happ shittened” is my favourite new phrase :p
First-class?
I think that's a bit unclear. How about JSON_WORK_ACCORDING_TO_THE_IMMACULATE_ORIGINAL_VISION_OF_OUR_HOLY_SAINT_RASMUS_LERDORF?
i.e. not a class; a whole new language construct in their own right.
LOL ARROW PLEBS XDDDDDDDDDDDDDDDDdddddd
Nobody drives in New York City, there's too much traffic.
I did. I'm on minimal sleep and poor food choices. Also boolean logic is hard.
I *swear* this phase once existed in php-src, but I'm not finding it now, even in old branches.
&gt; I think the exception tree needs fleshing out a bit &gt; I'd consider inheriting JsonException from either DomainException or InvalidArgumentException I'm curious, what benefit do you see in having inheritance in very low level exceptions? I can see benefits in having application/domain level exception have some structure to their inheritance, for figuring out systemic problems in an application - but for low level stuff where does the benefit come from?
 $text='{"abc":{"username":"xyz","platform":"def", "stats":{"ranked":{"playtime":251617}}}}'; $o = json_decode($text); $a = json_decode($text,TRUE); If you've got something made of objects, a simple: echo $o-&gt;abc-&gt;stats-&gt;ranked-&gt;playtime is fine. If you've got arrays, then I used to use a helper function: function £($x,$y){return $x[$y];}; echo £(£(£(£($a,"abc"),"stats"),"ranked"),"playtime"); but modern PHP doesn't require this: echo $a["abc"]["stats"]["ranked"]["playtime"]; 
When creating a new component that deals with more than one exception (like most do) usually the very first thing to do exception wise is to create a base class from which all others derive, e.g. PackageNameException. As more standard functions move to throwing exceptions (which is a good thing) it makes sense to collect them all under one particular superclass, so there is a specific catch (...) that can be done to handle and debug those new specific errors. Exception - RuntimeException -- JsonException I can definitely see a case for wanting to catch and handle exceptions thrown by the new (and eventually all) core library functions differently, to facilitate upgrading. I currently have all the errors / warnings / notices thrown as exceptions, but there's little context to them without horrible string parsing, a solid exception tree would help that.
Would extending from RunTimeException be better maybe? Similar to PDO: http://php.net/manual/en/class.pdoexception.php Anyway good concept.
Works perfectly fine thanks a lot ;-)
https://stackoverflow.com/questions/4899420/what-is-the-benefit-of-using-filter-has-var-over-isset
If you want to access global variables, $_GET, $_POST, etc, use some saner Request class ([this](https://symfony.com/doc/current/components/http_foundation.html) for example), preferably with a dependency injection container. The reason is that when you use a proxying class like the above, it makes your code easier to test and has less overall fuckery with the use of global variables. Other than that, you can check _any_ variable with `isset()`, and does not throw error no matter how deep you go (e.g `isset($something-&gt;foo['bar']['something_else']-&gt;bar['baz']))`). Edit: The example above contained a dynamic subkey thatdoesn't work. See /u/gadelat s reply below.
That would be one way to do it, but it's extra work. I might go for that if classes are unworkable.
I still love `Zend/zend_compile.h`'s `uint32_t catch_op; /* ketchup! */`
Needs more Hebrew
&gt; The tools are there, they're just not used enough or effectively The cause is the same as the argument given against frameworks, essentially "doing it wrong is easier". 
Until another language is as easy to write and deploy as PHP it won't away. If everyone who complains about PHP put their heads together and wrote a better language everyone would be better off. But those people are too busy debugging their deployment scripts and writing yet another deployment framework to get that done.
Huh, I'd never heard of filter_has_var until today. I would say it seems redundant, but why the hell are super globals *writable* in the first place? That makes no sense at all. I would stick with isset and generous use of the null coalescing operator ??. Do you want to elaborate on what you think makes it "more secure?" Security isn't really an issue here, since you're sanitising any input anyway, right?
I'd try to arrange it between paragraphs, so the first thing I want is a list of paragraphs: $a = explode("&lt;p&gt;",$text); I need to know the lengths of the text, not counting any embedded HTML formatting: for($i=$n=0;$i&lt;count($a);++$i) $m[$i] = strlen(trim(strip_tags($a[$i]))); and you mentioned 40% of the way through the content? $n = ceil(array_sum($m) * 0.4); // 40% Then I need to scan the lengths until I find the spot after the 40% mark: for($i=0;$n &gt;= 0 &amp;&amp; $i&lt;count($a);++$i) $n -= $m[$i]; ... and splice in the ad tag: array_splice($a, $i+1, 0, "ad tag"); before putting everything back together again: $newtext = implode("&lt;p&gt;",$a);
&gt; Do you want to elaborate on what you think makes it "more secure?" Security isn't really an issue here, since you're sanitising any input anyway, right? Mate I'm new, I'm just throwing phrases around.
Answered above: https://www.reddit.com/r/PHP/comments/6z5kuv/rfc_json_throw_on_error/dmsp48l/
Why developers prefer chocolate instead of Vanilla? Why developers prefer captain kirk instead of Captain Picard? Because it's a preference. Some people feel more productive in one framework over the other. *And that's ok*.
While yes you do have to counter the same vulnerabilities in other languages, it isn't as common to see a Ruby app targeted for example. I feel like this may be for many reasons. 1. Developers going with PHP as their first language, following bad practices and then looking into other languages (such as Ruby) when they already have experience on some of the better practices and methods to handle I/O. By this time it's already too late for PHP's reputation. 2. Developers are often quite lazy, especially with PHP; I've been writing PHP for over 6 years and rarely ever see code that ticks all boxes. For example, people think that just cause the function exists; they should use it: md5(), mysql_*, sha1(), eval() and so on. Hell I've even seen stuff as dumb as md5(md5()) and people STILL injecting raw input variables into a PDO query string rather than binding them. 3. PHP could be considered pretty old, it's been around for some time and for that reason it is widely used a lot more (powers around 80% of the web) than any other language for web development. For this reason, there are a TON of legacy systems lying around there on the web running old versions such as PHP 3 and even some earlier 5 (I believe around 90% of PHP sites are still running PHP 5, while we're moving into 7.2 soon).
What is the best way to find out what failed in the validation? Currently in my code I just know if it passed or failed, but not the errors that caused a failure.
Subjective but I find it easier to grasp and to be productive with. I don't know, the way it is built (and documented, I love that doc) just clicks with me. And way more modifiable, testable and extendable than some says, if you just understand how to do it (yes facades are easily testable). But both are solid choice, I can see why someone would prefer Symfony.
There are methods that allow you to get the errors and those methods are ready to be used in a response so I typically don't try to programmatically pull them apart.
&gt; When creating a new component that deals with more than one exception (like most do) &gt; usually the very first thing to do exception wise is to create a base class from which all others &gt; derive, e.g. PackageNameException. Which is JsonException. &gt; it makes sense to collect them all under one particular superclass, so there is a specific catch (...) that can be done to handle and debug those new specific errors. While I don't fully agree with that, I can see your point, but that's not what you're suggesting: &gt; Exception - RuntimeException -- JsonException There's no specific catch that could be done - other than catch JsonException - that would only catch the new exception rather than any existing one. So I still don't get why you're suggesting an exception hierarchy. 
I never use either: array_key_exists() 4 life.
Jeez I was hoping this is a post dissecting the advanced psychological tactics Taylor uses to market his wares. A dozen title clicks later, I realized it's just another cliffhanger. We'll never know. We'll never know!!!
I think you should reconsider: red is a very suitable color for an Exception IMO.
Because I'm looking to the future, where all current errors / warnings / notices are removed and replace with relevant exceptions, and IMO if the standard functions are throwing exceptions they should all be grouped to be easier to diagnose. &gt; While I don't fully agree with that, I can see your point, but that's not what you're suggesting: It's exactly what I'm suggesting, as catch (...) will match anything up the inheritance chain, meaning: ```php try { $app-&gt;doSomething(...); } catch (BaseForAllPHPFunctionErrors $e) { /* something hasn't been upgraded properly */ } catch (SomeAppError $e) { ... } ``` Beats ```php try { $app-&gt;something(); } catch (Exception $e) { /* Could be anything */ } ```
You think symfony was a waste ... I learned opencart. 
&gt; I'm one of the people who wasted time learning Symfony, just because some java lovers said that it was the future... I think I see the real issue here: you want a Symfony job and can't find one, so you're trying to blame the framework. Laravel has nothing to do with this.
well, i don't use symfony as a whole, but i can only say that symfony/console is one of the most useful and easy component to work on a daily basis
On a related note, I wish they would finally fix `isset()` returning false on existing variables that have a null value. Currently, the only way to differentiate between unset variables and null, is to somehow gather them all in an array and use `array_key_exists()`.
If you're just starting to learn PHP, the distinction isn't worth noting right now. Just follow whatever your video instructor is using, which in this case is isset(). If you're interested in security (which is great because it's so important), make sure you have a firm understanding of the basics of PHP first. Information security is a hefty field to go into, and isn't as straightforward as what function is more secure than another.
Prior to reading this I hadn't heard of filter_has_var(), isset() seems to have done the job fine for me; you can also use the null coalescing operator &gt;= PHP 7.0, though I'd only really use this sparsely and not too deep into logic. Did a little research on filter_has_var() and the most notable difference was that it does not handle arrays quite the same. $_GET['arr'] = 1; for example would return false even though it should actually be true. If anything, I'd say always stick to isset() since it doesn't behave oddly as this. Null coalescing operator: basically returns $_POST['foo'] if it is set and isn't null, otherwise it will return "bar". $input = $_POST['foo'] ?? 'bar'; 
Why not is_null()? 
`is_null()` actually returns true on non-existent variables. Besides, that also gets you E_NOTICE errors. Just about everything I could think of doesn't work. Even `@($nonexistent === null)` returns true.
I used to use array_key_exists on all form data until I learned it was significantly slower than isset.
I generally wouldn't bother for form data, anyway. If "null" is even a possibility, I would probably want to treat it the same way I treat non-existent parameters.
It's significantly slower (or at least was, I've not seen a comparison in PHP 7) than an extremely fast operation, but it is still extremely fast itself, even when dealing with hundreds of thousands of operations. If you ever find yourself writing code where the difference between `isset()` and `array_key_exists()` is at all noticeable, a scripting language probably isn't the appropriate language for the job.
That will never happen though, it’s a major BC break. It’s also not a bug, although I can see it being undesirable for many people. 
Tkx again man! :)
Tkx for the hint!! I will recheck it again and my next posts as well!! Glad you like it btw. :)
Depending on what you are testing for you can also use array_key_exists (http://php.net/manual/en/function.array-key-exists.php)
Now that's a click-bait title!
yes
I agree, limiting function parameters helps make code clearer, however I'm often conflicted about the number of parameters. I think the provided code sample is a perfect example. Incase you didn't read the blog post, this is the sample: &lt;?php class MenuConfig { public $title; public $body; public $buttonText; public $cancellable = false; } $config = new MenuConfig(); $config-&gt;title = 'Foo'; $config-&gt;body = 'Bar'; $config-&gt;buttonText = 'Baz'; $config-&gt;cancellable = true; function createMenu(MenuConfig $config) { // ... } I prefer immutable data transfer objects, with that in mind MenuConfig would end up looking something like this: class MenuConfig { private $title; private $body; private $buttonText; private $cancellable; public function __construct($title, $body, $buttonText, $cancellable = false) { $this-&gt;title = $title; $this-&gt;body = $body; $this-&gt;buttonText = $buttonText; $this-&gt;cancellable = false; } public function getTitle() { return $this-&gt;title; } public function getBody() { return $this-&gt;body; } public function getButtonText() { return $this-&gt;buttonText; } public function isCancellable(): bool { return $this-&gt;cancellable; } } We can ignore the added complexity of the DTO, and focus on the function call: createMenu(new MenuConfig('links', 'html maybe?', 'Click Me')); At this point, I wonder did we make anything clearer? I mean it could be rewritten to: $args = new MenuConfig('links', 'html maybe?', 'Click Me'); createMenu($args); But maybe you like to buld objects instead of using the constructor, that creates the following: $args = (new MenuConfig) -&gt;withTitle('links') -&gt;withBody('html maybe?') -&gt;withButtonText('Click Me'); createMenu($args); I just don't see the previous examples adding any additional worthwhile clarity. 3 or 4 arguments does not seem obscene / bad / code smell / whatever you want to call it.w
Exceptions always end with "Exception"... it's like the one thing we're mostly consistent about.
Meh. I wrapped `json_decode` a long time ago to do this. Doesn't add or subtract much value.
On that theme, perhaps yellow and black, like a wasp or a ⚠️ icon? Also the colours of JS.
&gt; At first I thought "clean" meant "minify" because I'm new to the internet
The MenuConfig is still mutable as its properties are public. That being said, I'd like to add that using a separate object gives you the possibility to do some validation as well; guaranteeing that the configuration is always valid when used, preventing a lot of consumer-level checking. Also, for these kinds of immutable objects it would be lovely to have readonly properties, so you don't need getters.
Welcome! It's a terrible place. 
Sorry I meant in combination with isset(). As in... `if (isset($var) &amp;&amp; !is_null($var)) {` 
That doesn't work either, unfortunately. As I said, `is_null()` also returns true on unset variables. isset() seems to act the same way as !is_null(), except isset generates no notices. [Check it out, in case you don't believe me.](http://sandbox.onlinephpfunctions.com/code/93bde1533f70daa7f4c082157d1cae5833011a54)
shipped!
That isn't true. In case subkey is dynamic, isset won't handle it. https://3v4l.org/fIK2m
Including this one, there are 17 PHP server libaries listed on http://jsonapi.org/implementations/ and I don't think JSONAPI does official libaries. I wouldn't worry about it too much though.
How come? I would have thought it would be more appropriate to move the SPL exceptions into the core.
The PHP equivalent of that JS anon object is just an array and works exactly the same.
It's not a question of "not believing you"... I was just trying to understand so I asked a question. Anyhow, the problem is clearer now... thank you. 
Follow the Symfony tutorial on knpuniversity.com for building a blog. It will cover building the routes, entities and forms. The entities will be database backed in the tutorial but you can simply make them write to a disk file instead. On mobile otherwise I’d link you. 
&gt; but why the hell are super globals writable in the first place? That makes no sense at all We had this discussion on here a while back, and the seeming conclusion was because a LOT of software (especially things like test modules) relies on it being writable, and in future it would be better to have a PHP-level request object instead of changing them to be read-only.
Sorry yeah you are right. I updated my post.
[removed]
It's not a crud app exactly, but my suggestion has data management with items being created/retrieved/deleted, so in terms of functionality there's not a huge difference. I'm not entirely sure it's going to fit what you want, but Octobercms is a Laravel based CMS that uses the filesystem for content storage, so there's data saving/retrieval with pages/partials/content blocks etc. You'll have to check which version of Laravel it's based on.
It's worth pointing out what you have is a json object. If you use `json_decode` you can turn that into an object that you reference with the arrow syntax `$object-&gt;abc-&gt;username` etc. If you use `json_decode($json, true)` you will get it back as a plain array, and use it as you normally would an array, with the square bracket syntax.
Of course I read the examples. &gt; What makes you think this is a form of operator overloading? I havent heard of operator functions before, and the closest thing I could think of is operator overloading. Someone mentioned haskell. I apologize if you wrote this RFC, but I fail to see the its benefit. It just adds another way to do the exact same thing in PHP. PHP is already a hodgepodge of features cherry picked from other languages. This adds to that problem. Meanwhile, a class level operator overloading would be something I could get behind.
&gt; its utility is very low A big big yes. This should be emphasized more. It will have a huge impact on readability, but the benefits are negligible. But hey, Haskell is the cool kid now, mom. 
Seconded. PHP should first work on its identity. And not just a hodgepodge of language features cherry picked from other languages.
Not to complicate things, but I find [empty()](http://php.net/manual/en/function.empty.php) to be the most helpful function since it will check if the variable is set and also if it is null or 0 or an empty string or false, etc. Obviously don't use it on booleans or values that might be 0, but otherwise it is generally more helpful than isset, IMO.
&gt; Welcome to open source software, where you get as much support as you pay for. &gt; If you want some feature, you can either implement it yourself or pay someone to do it. Please dont use this card on us. RFC was posted here to get some feedback. /u/LtAramaki did have some pretty valid feedbacks that I also share. Should probably take that into consideration.
In a nutshell: This RFC has huge impact on readability, with very very low utility/usefulness. Thats what most of the us here are saying here. Was the RFC posted here to get feedback, or was it posted here to get upvotes and backrubbing? Because the way the core devs reacted here, implies the latter. Which reinforces my opinion on the maturity of the community.
Thank you for the suggestion. I am a big fan of OctoberCMS and have a site that runs on it. From a Webmaster perspective, it's awesome. But for the code itself, I fear it's too much for my limited skills for now. Hopefully in the future I could dissect more comfortably such great platforms. 
That's indeed a great resource and I have followed some of their courses with great interest and have learned a lot. I admit that I shied away from the Symfony blog precisely because of the database model but perhaps I should really give it more attention. Thank you.
This is an implementation of the official specs. One of many.
Great suggestions, thanks.
&gt; The MenuConfig is still mutable as its properties are public. They were meant to private, typo in my code.
No problem ;)
Thanks. I noticed that if you use the arrow option you can't have a 'category' labeled with a number. You'll need the brackets instead. $object-&gt;abc-&gt;5-&gt;etc. is not possible
This isn't that hard to write in a micro framework. The only thing with filebased data (without a database) can be that it isn't multi-user per default. On the part where a normal crud application would do stuff with the database, you simply replace that with doing stuff with the file(s). And if you write it in a good way, the rest of the application is unaware that data is coming from file(s) rather then database-tables.
Any valid cases where variables might not exist? Because you can always define them with a default value.
I think this qualifies as a crappy piece of words. &gt; People are insecure assholes looking to make themselves feel better by shitting on people they don’t know because that’s easy and seemingly without repercussions. which was done in this word vomit. How about motivating people? Of course there are juniors in PHP that need help, and of course there are bad programmers, but I've seen them in every know language. I was one of them in the old days. But lucky me, I gained experience. I'm glad that other people do too. (and some will never learn.) But overall people will grow and do better. They become medior, senior, or even "master". If you not willing to show others the path, then they will never grow, and you will never become a master.
you could install Gogs (https://gogs.io/) which you can run as a local git server, and learn in an easy way.
I advice you to gain experience in some of the modern frameworks, if you haven't got that. (make a phonebook application in all of them) and if you can do that, you can move away. In your next jobinterview, you can tell people you have a little experience in framework X, and you love to learn more about it from experienced people, to become a "guru" in it.
I love the documentation, it was so short, that I could read it 10 times. Still, after those 10 times, I still have no clue what it is about. I hope, with the next creation, you improve your skills as a writer. When I walk in a store, I get attracted by the visuals, the outside of the product, the way they tell you what's in the package. If this all fits my fantasy, I will take the package home. Your package has a blanc wrap around it, so I left it in isle 3 for others to be surprised.
What I miss in this piece, is that the first attention of unittesting should be to the high risk part of the program. (and perhaps that it's better to have someone else write tests of your code, and vice versa.) Also the "rule" that a unittest should never exceed a certain time is crap. Unittests are there for quality reasons, and they can run automatically these days (after a commit), so no need to wait for them. I always teach: before you start, run the tests. If it works, then make the change. Run tests again, and improve if you broke anything. Write new tests and run them. Commit. I don't care if it takes 10 minutes, as long as I know it meets our quality standards, it's fine. (and those 10 minutes, you can use for reading specs, fora, answering emails etc.) 
Indeed.
Why didnt you make it as f3ath/json-api then? 
I would suggest using docker
I use Ansible, a lot of people like Chef. The idea is that your configuration is placed under version control, like your code, and becomes automated, testable and repeatable.
Why not make a [shortcode](https://codex.wordpress.org/Shortcode_API) and let the user who's making the post decide where the ad should go? 
I see, thanks. I get the basic idea.
This example is too simple to show the benefit of doing this. Either use a builder pattern (which this essentially is) for more complicated use-cases, or use an associative array for simple cases, like this example. Don't do this for simple cases. If you need default values, set them in an array which you merge the argument array into, i.e. hash options in ruby as advocated by Sandi Metz.
I think many answers here are missing the point. I'll try to address you question more directly: - `filter_has_var` is a relatively new function introduced in 5.2. It's very specific to _request_ parameter validation and filtering, and it has other [associated functions](http://php.net/manual/en/ref.filter.php) like `filter_input` and `filter_var`. Those are meant to process _user_ input only. Also worth mentioning, the reason why more seasoned developers didn't know about it is because it's pretty new and we already had tools for those tasks, either built in web frameworks like Symfony or Zend, or they had working code for that if they were not using a framework. It's a very common task. - `isset` on the other hand is a very different beast. It is pretty low level and has a much more general purpose than `filter_has_var`. It is there to check if a "thing" is defined, and can check many different kinds of things: - `isset($foo)` will tell you if a variable is set in scope. - `isset($foo-&gt;bar)` will tell you if the object `$foo` as a property defined called "bar". - `isset($foo['bar'])` will tell you if an array _index_ is defined. Note that: - There's another function to check if an array index is set: `array_key_exists` and - `isset` can check nested arrays without throwing a warning, like this: `isset($foo['bar']['baz'])` So to sum up things: `filter_has_vars` for user input validation, `isset` for generally checking if stuff is there. Which one should you use: it's up to you. And it doesn't really matter that much as long as you correctly process user input and the code is clear enough for other programmers (and your future self) to understand your intent.
The article states it has a fixed length of 96 characters. Clearly that's incorrect.
Is JMS maintained now? A lot of problems and PRs never merged, we had to fork it. On the other hand the symfony serializer is becoming better. If I had to start again, I'll go with the one from symfony.
I made [this](https://github.com/davidsivocha/slimblog) with Slim. It's a simple file based Microblog, that uses Markdown parsing of text files. Feel free to check it out. The only thing I will say is that it was made with Slim 1.6.3 so it's not a current version. However the core concept is pretty simple and easy to understand and it would be very easy for you to adjust, replicate or clone this using Laravel, Slim3 or Lumen for instance.
&gt; Which reinforces my opinion on the maturity of the community. Ah - the person who gives advice and insults at the same time. This is definitely the type of person I want to follow the wisdom of.
Thats a weird little thing in PHP. You can actually access it, but php has to be aware that it is not a numeric literal, but instead a key. To do that, wrap it in `{}`. https://3v4l.org/q5NBp `$object-&gt;{5}` will work.
That's really interesting. Please keep posting your thoughts in every thread in this sub because you must know you are important and your story matters.
Thank you, thank you. I'm here all week. Wait, you know that. I greet you [with this one](https://www.youtube.com/watch?v=tDMfp_omC0o)
&gt;So, you want to sign up for a Micathon account? Well here is the place to do it! Just fill out the form below and your account will be up and running almost instantly. Once it is set up, you will recieve an email to check that you own the email address you entered. If you enter someone else's email address, your account will be terminated and your details will be submitted to our security team. It's far easier to just use your own email! What kind of [high school nonsense](http://kolechia.heliohost.org/micathon_zeus/site/account/new/index.html) is this[?](https://github.com/Micathon3/Zeus-Web/blob/93a6c325d89e5bc3c981c338d9e815346546f32e/404.php#L7)
If you really want to "level up", stop talking about how you could make everything better and start doing it.
Depends. If you're building a workload, use docker. If you need an environment, use chef/puppet/ansible. All three are nice. 
`static`
They are in core. You can't build PHP without SPL.
Care to explain a bit more? If I make the `Language` class static, and use it like `L::get('Name')`, I'll need a way to get the current language in the `Language` class, which adds a hidden dependency in that class, so I don't think it's a good solution.
Does anyone have any resource on dynamic user management and access control system in php mysql. Thank you
I gave various points and you decided to solely focus on that.
&gt; or Subversion Seriously?
Salt and Chef, are great; however Ansible is stupid easy to learn. It's supported by RHEL and a ton of folks are using it now due to it: 1) Being super easy to use/learn. 2)Really really powerful for such a flat learning curve. Highly recommended for all simple to medium deployments. You could also make a strong argument for docker. It's more lightweight and portable. I think it's harder to maintain and use to a degree but that's just opinion, there are some great docker images available which I use from time to time when needed.
DELETE THIS
Good thing internals are also comedians.
⦁ should probably multiply (based on math lingo)
Not core enough if something in the JSON extension can't depend on them easily.
I can tell you're a real expert in this department.
Obviously that was facetious. I don't know that much about how PHP's core is put together, but I'd be surprised if there wasn't some way to resolve this dependency issue in a sensible manner.
These are super duper awesome! No stickers though? I would love these on my laptop.
A "simple" solution would be to version this php.ini file and using it when starting the project, for instance : php -S localhost:8000 -c ./php.ini You could do an alias in your composer.json or a makefile to simplify the process.
Keep in mind Ansible is like the laravel of PHP. Easy and garbage for anything but trivial use-cases.
We still use it when [the docs builds fail](http://svn.php.net/viewvc/phpdoc/doc-base/trunk/configure.php?revision=342839&amp;view=markup#l89). :)
Wasn't this called Tiger? I messed around with that. Always good to see projects like this. Newcomers like me could use some templates.
This article seems to be 99% about event sourcing and 1% about CQRS ;)
Like the one Symfony Http Foundation provides. I'd be happy if that became a standard.
For the `json_decode` to throw an exception, one should find all usages of this function and use this option (probably overriding the `$depth` argument along the way). Or better yet, create a wrapper function, let’s name it `json_decode2` ;) and it would look like this: function json_decode2($json, $assoc = false, $depth = 512, $options = 0) { return json_decode($json, $assoc, $depth, $options | JSON_TROW_ON_ERROR); } So if all this boilerplate is needed, why would you need the flag instead of checking the `json_last_error()` in your wrapper function? The only downside I see if this were to be a transitional state before it’s changed to be the default in PHP 8.
Wouldn't it be easier to ask everyone in the world to use PHP short array syntax instead of JSON?
I agree :) Swapping CRUD for events is the CQRS part. The rest is all event sourcing.
Storing the full state of a resource will make your database grow extremely fast. One of the benefits of event sourcing is that you have a record of exactly what changed and when.
It depends on the load and your infrastructure sure. In my case adding the full state + metadata is not a problem.
🌐 $conn; 
[DataTables](https://www.datatables.net/) front end with the [Editor Extension](https://editor.datatables.net/). The former is open source while the latter is paid. Some projects at my job have involved killing off spreadsheets that had grown too large for their own good. This combination has been really effective at that. [Here](https://editor.datatables.net/examples/simple/simple.html) is the 'simple' example. There are a bunch of plug-ins as well such as [KeyTable](https://www.datatables.net/extensions/keytable/examples/initialisation/simple.html) which allows for excel-like keyboard navigation. Combined with editor it feels even more like excel. [Combination seen here](https://editor.datatables.net/examples/extensions/keyTable.html) [Inline editing](https://editor.datatables.net/examples/inline-editing/simple.html) works really nicely. My main complaint is that it's not compatible with an ORM like Doctrine. It's not the prettiest lib in the world either. You'll also have to add things like permission checks by using the 'events'. e.g. when the `preEdit` event fires check if the user has write access. Also the developer, Alan, has always provided fantastic support.
Symfony may be the defacto standard (I started using it myself after the previous discussion). It does have a drawback though, that you typically either have to have a request defined globally, or you have to pass the Request via dependency injection for every single thing, and a lot of components, especially third party ones, are not set up to support such.
In your case there is a limited age of the resource (more specifically Shipment) so you probably won't see tremendous growth. Once it hits it's end-point then that's it - it's historic at that point. If this were instead done on your customers instead of their shipments I could see storing the full state of the resource being a problem - if I'm understanding this methodology.
In the true spirit of CQRS you would use a 1N schema that is separate from the ES table in order to achieve faster read speeds. What advantage are you trying to gain by storing snapshots alongside the events?
Read speed, a way of caching basically. And not have to reprocess events constantly to calculate the state.
That's not true at all. Ansible 1 had some concurrency issue and some other stuff that didn't scale well but they've sorted out a lot of the slowness. AWS uses ansible as part of their core tooling for specific things. If it's working at amazons scale it can work and be good for anything IMO.
Yeah shipments live for a couple of days only, every action needs to be logged (as events in this case) and we can't have stale state being saved (version control). That's basically what this solution is for.
high five! lol! bro! lol!
Maybe v2 improved some things. I must admit my experience is limited to v1.7. They managed to kick their toxic BDFL out since then so anything's possible I suppose.
Thanks for your kind words. You can get the hires and print stickers nearby for you and your friends to save on delivery. License is very permissive.
Almost all of the places I've worked at have hacked around this in some form or another, so a definite thumbs up for this. This is on a similar level to `count()` being FINALLY fixed in 7.2.
I guess that's what I'm asking. What advantage does storing the state this way have vs storing the state in a separate, query friendly, table? It seems very difficult/expensive to pull related data this way. I see that you will have access to every state since the models inception but there are still ways that could be done (shadow tables, etc) more efficiently. I'm not attacking your implementation since there are obviously use cases and constraints that I am unaware of. I've been very curious about CQRS/ES lately but have no actual experience with it.
No worries I'm really light hearted with criticism :) reddit is place for discussions! I guess the problem is that I only demostrated an in memory solution which makes people guess a little bit how it would work on a DB. I'm going to add a MySQL example as well. The table has all the Event attributes (id, action, current_state and metadata) + version as fields. The version field is composite unique index with id, so there can be only one version of the model. action, current_state and metadata are all json fields so you can query them easily, I'd use Postgres if I could as it has better json support. To wrap it up the usage is super easy, you should use the store to fire events as you please, and also use the store to read the current state. The maintenance is more about the reducers that will increase in size. And everything is blazing fast: write is append only, the reducers are pure functions and reading is cached. It's a simple and quick solution if you don't have the resources or the will to build a spaceship.
This is exactly what we did with our clients and worked great.
Thank you for sharing. This is definitely not polished enough. But this might be a good starting point if I want to build the system.
Wow, these really look great, thank you. Once I started checking out the plugins, this is really the functionality I was looking for!
"Reducer" seems to bind one particular Projection/Read Model directly to events. Why not project events to a separate Read Model and keep Events singularly responsible for representing behaviour that has happened in the past? The only justification I see for conflating versions Read Models into an event is "convenience". The fact is that Read Models (or "current state" as presented in the article) represent our interpretation of events having occurred in the past within some temporal context. That context can change and our interpretation, also, can change. For this reason, I would never attach an interpretation directly to events 1:1. For me, the events ARE the current state of aggregates in my domain, not a projection. At any rate, really pleased to see discussions on this topic become more and more mainstream in the PHP community, but I hope this topic doesn't turn into another Command Bus, Repository, etc. abuse-fest. CQRS+ES makes sense in some domains but it is probably a "bad idea TM" to build an entire system this way. Some sub-domains will naturally lend themselves to a temporal model while others (such as auth) likely are best implemented via CRUD behind a common interface. My two cents.
Slack is written in php, so it is a bit ironic that some wannabe elitest is bashing on how no one uses php anymore in a Slack chat.
If, instead, the purpose of current_state is to be a sort of snapshot of the aggregate as an alternative to implementing actual Snapshots, I would ask: Why not Snapshots? The Aggregate Root should own how it is serialized for snapshots, in my opinion. In fact, an Aggregates own concept of "state" is nothin more than an internal projection of its events for purposes of enforcing domain invariants within the Aggregate. Because that internal projection could change, I would hesitate to attach it to something so immutable as an Event Stream. 
Wow thanks!!
It is worth pointing out, you shouldn't really have a numeric key. It would be considered an oddity, if you're numbering things like that, go with an array. One of the only uses for that would be to have the key as your ID, but even then there are probably better ways to do it. If you were doing something like `array_values` you'd lose that data, whereas if `id` was a key on the array item, then it would be safe to use the `array_*` functions.
You might have to grant the user privileges: https://www.digitalocean.com/community/tutorials/how-to-create-a-new-user-and-grant-permissions-in-mysql
Good point, the problem here is that the store is being used to read and write, it's no true segregation. And the final bit of the reading happens in the factory method in the aggregate during hydration. So yes it's for convenience, ease of usage was central to the solution. The mechanics is: read and write events + hydrate the model from the current state. Maintaining it feels pretty much like like maintaining event/listeners, but listeners are the reducers.
Besides what's already posted give a good read to this links: - [PHP: the right way](http://www.phptherightway.com/): a good guide on developing PHP applications - [PDO delutions](https://phpdelusions.net/pdo): a guide on how to properly execute queries on your database, IMHO a must read for any PHP developer
Thank you so much. I had ran across yours before but had not figured out the transition of $app-&gt;get('/:article',function($article) use($app) portion to slim3 but I will give it another shot and hopefully get it going. Thank you again!
`http://yoursite.com?isAdministrator=1`
Ansible is considerably better with v2. I don't know anything about ansible project's internal politics, but they have made huge progress. It's becoming less of an ad-hoc scripting language and more of a real configuration management framework with every version.
I suppose I really should update it to use Slim 3 now anyway.
`extract($a);` saved you a click also, don't do this with any user input. this is a really useless article too.
If you enjoy the other aspects of the job and want to stay, I think **you** should take the initiative on implementing Git and migrating to a newer version of PHP. It's clear this hasn't been a priority for them and it probably won't change unless you step up and do something about it. I would start with Git as it'll probably be easier and quicker. You will need to get the lead dev's buy-in on this, and you'll both need to be on the same page when it comes to branching and merging workflows. (In the event they're not interested in using Git, you can still use it locally just for yourself. Put the site in Git and periodically merge in their changes manually. It's not ideal but you can still version your work) Upgrading PHP will take more effort. I'd recommend aiming for PHP 5.6 for existing sites and 7.x for new sites. Good luck! ---- **Edit:** If/when you do look for a new opportunity, telling them you led the effort to implement Git would look great to a new employer ;-) It shows you care about your work, are willing to take initiative, and can learn new things as needed.
Reminds me of register_globals: http://php.net/manual/en/security.globals.php
Extract is a horrible nightmare. http://php.net/manual/en/function.extract.php The result of calling it depends on the value of your array plus the flags passed to the function. See those flags to see just what kind of bizarre mangling of variables can happen. I challenge anyone to come up with a better obfuscation tool or foot-gun. This article wants to turn `$_POST`'s contents into variables and demonstrates that by calling `extract()` with default flags. That overwrites existing variables, which is really good if you don't want to waste your attacker's time.
The best thing about this article is the link to Martin Fowler's article that actually explains stuff instead of being wishy washy bullshit. 
Well visiting this link gives me a Wordpress Installation prompt, so I guess that technique didn't work out well for OP.
Umm, buddy, if I access your website using plain HTTP instead of HTTPS, it gives me the wordpress setup page. You MIGHT want to fix that. Urgently.
Do you want to know? He took it down now but the problem is [the Internet never forgets](http://archive.is/cp1tJ).
Is there some drama in that which I'm missing? It looks like a standard "here's how things started, what my role was, but I'm moving on to new things" post. I interacted with him a few times over the years and only remember him being helpful and kind. It struck me as odd that you'd call him toxic.
Life of the party.
Regarding number of function arguments. clean-code-php says: &gt; Limiting the amount of function parameters is incredibly important because it makes testing your function easier. Having more than three leads to a combinatorial explosion where you have to test tons of different cases with each separate argument. How does moving arguments to an object prevents this explosion? Don't you just have to test all possible combinations of object members now?
And bitcoin symbol Ƀ for cryptocurrency aficionados.
Anyone know how to fix the phpstorm doc blocks generator when it forces you to do one item at a time instead of multiple?
Ask a CCNA to do it for me or reach for the cloud then Ansible, Kubernetes, Jenkins, Gitflow, and Done. Is that full stack enough? Most full stack places I've run into just expect db, backend api, css, js and adobe chops. Your more describing what I've thought of as a DevOps position. If I did routing tables I'd be doing layer 1-4 full time instead of 5-7, probably be getting paid more too.
Generally I build an API server to interact/abstract the database server, and have the frontend query the API server for the data (Json is the best format to return). This also gives you a security advantage because you can harden all your API calls, and you can easily create 3rd party interfaces forbothers that might want your data. Pro-tip: when creating an API call, make sure there is a pass-code and version passed as arguments. This helps later in your projects life cycle.
In my opinion we need to get rid of stringly-typed callables. They hinder/break refactoring and code exploration. // happy $sum = array_reduce($terms, plus, 0); // sad $sum = array_reduce($terms, 'plus', 0); The fact we have separate symbol tables is one of the saddest features of PHP if you try to actually do a functional approach because the string-types end up breaking your analysis and refactoring. This is particularly sad because some of the supposed benefits of functional programming is to improve maintenance. You can mitigate it by making functions which return callables: // happy ? $sum = array_reduce($terms, plus(), 0); Note that this is what C++ does, but in C++ they are almost guaranteed to be optimized away but in PHP we are basically guaranteed they won't be.
Not really applicable though. I don't see how it is not cancer (having to unset tons of vars for example) to write PHP in a way to have a long-running process (some ways are provided ITT but they are cancer). In real-world use cases PHP (applicatioons based on Symfony, Zend, Laravel, perhaps a CMS or Magento, take your pick) has to start up the whole application for just one HTTP request and that comes with allocating memory, querying the database, instantiating objects etc. - doing the same things over and over while actually executing the logic to serve that HTTP request becomes only a few percent of the workload. The extensive caching that everyone _has to_ do in order to achieve even somewhat acceptible performance is proof of that. And I'm not just talking about OpCache. People use things like Redis or Memcached to have objects to survive more than one request, kind of like shared memory. There are quite some platforms that don't have a per-request architecture, including Ruby with Rails on Ruby, including Go, including Node.js, including Java (Spring, Play, Spark, you name it). These platforms have inherently better performance in real world use cases due to this architectural difference alone. In addition to that at least Go and Java have even better performance on that benchmark game. PHP has some advantages but performance in a web environment is not one of them. Perhaps application development time and hosting costs are low. Which is important for startups.
If you write code in a wrong way that a garbage collector from Java, Python or Ruby may not detect that data is unused and therefore could be deleted than that same way would prevent the garbage collector from Haskell to delete it and the same way would prevent an application written in Rust from releasing the allocated memory. Because the only way to "achieve" this is by allocating some memory for some data and keeping it in the scope and then forgetting about it. That's a bug, it has to be fixed. Even in a PHP application.
It's not just "bad code". Magento for example is one of the most used eCommerce software on this planet. It has over 1000 contributers and earns many companies thousands of dollars. It is feature-rich, well-structured, maintainable and highly customizeable. This leads you to a situation where it has to read about 250 files per HTTP request. That's only going to work with an SSD, preferrable an SSD raid, and some huge processing power and huge amounts of RAM. Is it bad software? Read the codebase, then judge. It definitely gets hit in the face by PHP's per-request architecture though. If Magento was the exact same software but written in Java people would save thousands on hosting fees.
GraphQL is providing the API layer you're talking about. I'm not sure what OP means by 2 different DB layers, but GraphQL basically solves the problem of having a single interface to your data.
do you develop it from scratch single handedly? congrats anyway!
Thanks! Yup, the site was all built from scratch. 
Perhaps enlighten us with the techniques used, and what you learned from it. (good work btw)
_Perhaps enlighten_ _Us with the techniques used, and_ _What you learned from it._ &amp;nbsp; &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; ^- ^MarcelloHolland ------------------------------ ^^I'm ^^a ^^bot ^^made ^^by ^^/u/Eight1911. ^^I ^^detect ^^haiku.
You're right, there's nothing interesting in that post. If you want the juice you'd probably have to scour GitHub issue comments.
12 BTW
Thanks! I've learnt a lot about PHP over the course of six months. Going into this I had no idea how to echo from a database and I slowly managed to build a knowledge of PDO stuff and how to make it all work. I'm currently struggling with getting some initial listings, but Bidhype was featured on Product Hunt two days ago (something I'm extremely chuffed about).
&gt;GraphQL is providing the API layer you're talking about. Of course all databases have an API, but that is not what /u/omanisherin was talking about. They add *another* API between the database and the frontend application. Their API is more domain-specific than GraphQL. A customer, for example, may have data stored in multiple different places. Their favorite products might be in a graph database, their orders in an SQL database and perhaps their credit rating can be reached through a third-party service. The point of a domain-specific API is to collect all of this data behind a common interface, hiding the underlying storage. So when you ask for `/customer/4711` you get their orders, favorite products and credit rating from the same place.
&gt; Who doesn't use PHP beside something.js JS is obviously big in the web space but as the websites move more towards being applications I've seen Java and C# really dominating the job market, at least here in the UK anyway. That's not to say PHP is dying it still has a very healthy job market here.
The difference is that Haskell and Rust are both compiled static languages. It is way easier for the compiler to check for such things, whereas impossible in PHP. This "bug" exists in PHP, Java, Python, Ruby, nodejs and plenty of other languages. It is a tough bug, sometimes a leak caused by user-land code, sometimes in C. In both cases, hard to find and sometimes not worth trying to find out.
I literally can't believe somewhere is not using any version control what so ever. Mental 
http://phptherightway.com/
didn't we all back then? show code and we can talk
Laracasts.com my friend. There are plain php courses as well as laravel courses. Many are free 
www.php.net
use the search option on the right site of the page and type "learn php" it has been asked before ;-)
I learnt a lot once I started spending time talking to established PHP developers, I understand that not be the easiest of options. I would recommend spending some time on GitHub and look for some open source you can contribute too. It'll really help you get a feel for best practices of PHP, and it'll get you used to working with existing code. As a book recommendation try [PHP Advanced and Object-Oriented Programming](http://www.peachpit.com/store/php-advanced-and-object-oriented-programming-visual-9780133057799) It helped me get my head around OOP in PHP. I don't think it has been updated for php 7 though so bare that in mind. Best of luck with PHP buddy.
This is precisely the abstraction I use at my data mapper, unfortunately it's not public yet. So all I can say is... it works great, and offer assistance in any implementation/API hurdles should you choose to implement yours.
In other news those guys from your first job are now doing fortunes maintaining corporate software in a language that doesn't have any more developers anymore and they are making millions a month. (I am joking btw, but have seen it happen to a smaller degree than millions a month)
&gt; unfortunately it's not public yet I do look forward to it becoming so.
More so than the guy who says "life of the party" like a walking cliche.
Not sure why this is downvoted. People are so fucking lazy these days, OP is never going to learn anything if they require to be spoonfed everything.
exactly why I typed it. But perhaps it was just unknown, so I tried to teach it. Anyways.... It should be obvious we have this great search option which anybody is free to use. (it works faster than asking the same questions over and over again, and wait for someone else to reply; seach is instant reply...)
https://laracasts.com/series/php-for-beginners
A second addendum (which is just how I personally do things, and I fully expect to be stoned about it): When the major version of a package changes, duplicate the namespace and package to include the version, so two major versions can be used concurrently. I.e. then you can do: // Same "composer.json": "require": { "acme/datamapper": "~1.0", "acme/datamapper2": "~2.0", "acme/datamapper3": "~3.0", } // In the same project (common) or even file (rare, but for the sake of the example): use Acme\Datamapper\Schema; use Acme\Datamapper2\Schema as Schema2; use Acme\Datamapper3\Schema as Schema3; $s1 = new Schema(); $s2 = new Schema2(); $s3 = new Schema3(); We've seen this happen with Guzzle a few times, although they did it in an ad-hoc way and not as a consistent convention they intend to follow (as far as I know). And yet, this approach of theirs is what allowed the latest version of Guzzle to be picked up while you have components that rely on an earlier version in the same project. Smart thinking, smart results. The rule of "concurrent major versions" also follows from the realization of interconnected interdependent systems. If 10 components depend on X version 1.0.0, then if one of the components requires X version 2.0.0, now suddenly all must switch to 2.0.0. As we know, in any bigger systems, changes that require "instant cooperation from everybody at once" are doomed to failure. Many package managers like NPM and Python's modules actually allow you to concurrently load different versions of the same package, so they're blessed not having to do what I propose here. Composer and PHP unfortunately have no such affordance, so sometimes a make-shift solution with imperfect aesthetics is better than pushing the much bigger problem of long-term system evolution under the rug.
&gt; When the major version of a package changes, rename the namespace and package to include the version, so two major versions can be used concurrently. This was one of the rules for PEAR packages as well.
I didn't know this. Well it's unfortunate we forgot this lesson along the way.
I believe this discussion has already happen in the [FIG](https://groups.google.com/forum/#!topic/php-fig/LgY-uKLmXiI) without any clear conclusion
&gt; I believe this discussion has already happen in the FIG without any clear conclusion The situation with FIG's interface namespaces is especially mind-boggling, because *they already have versioning* of their specifications, but have inexplicably decided to name the namespaces after generic words. I.e. it should have been: Fig\Psr3\LoggerInterface Fig\Psr6\CachingInterface Fig\Psr7\RequestInterface ...and so on. How they managed to botch that one up is beyond me. If they'd follow their own PSR numbers in the namespaces, and their own rule not to alter existing PSRs but obsolete them via new ones (IETF style), then when PSR7 needs to be updated, even if it's typehints only, it'd be a new PSR number and all the problems naturally resolve themselves.
iam the only one in the world that love calling functions with -&gt; instead of . ? for concatenation yes i would love + instead of . but for calling functions i think that -&gt; is pretty good 
Ah! That's where I remember it from (and why github couldn't find it)!
Is there something in Composer and/or semver stopping developer doing this now?
Your SSL certificate has some warnings in Firefox.
Not that I'm aware of.
&gt;I'm toward the end of my apprenticeship as a computer scientist and want to study afterwards and that's why I need to know PHP. Are you aware this sentence is illogical?
Head over to meetup.com and search for PHP user groups. They are all over the place. Go hang out, have some pizza and beer, and talk to other PHP devs.
Eh, I'm not going to go read someone's comment history with the intention of painting them a bad person. I imagine if he were really "toxic" as you say, he'd have done something bad enough to warrant an article or something. You should reconsider smearing people like that. It doesn't reflect well on you.
No ways! A talking goat!
What're you gonna do? Ban me?
nodejs/es6 has async operations which means I can scape multiple pages concurrently = much faster scrape time. Promises/async/await syntax means no callback hell which makes my code [much cleaner](http://i.imgur.com/JHSREDD.png). Async + libraries like [puppeteer](https://github.com/GoogleChrome/puppeteer) for headless chrome support makes js a better choice for scraping over php (IMO).
Sure? I was more speaking as a matter of personal etiquette, but we do have rules against that sort of thing here in /r/PHP. I generally only ban people who get really aggro about it, though.
I wouldn't call yourself a full stack dev unless you can also handle server management, sys admin stuff, and actual DBA things not just writing some SQL for queries. For all I know you could know this but include it when you call yourself a full stack dev. Try to understand every single facet of your applications (and how to make it better): - development process - testing - version control - deployment - maintaining multiple servers for QA e.g. dev, test, staging, prod, etc. - how would you handle upgrading from PHP 5.3 to a newer version? - if you had to move hosts for better speed or support would be able to do that? - can you roll back changes after a fuck up? - are you backing up properly? - is your server, database, websites, email server, everything secure? - is your business's work network secure or can I come in get access to it and start sniffing the traffic (overkill but it'll make you look good)? If you guys are still developing on PHP 5.3 (unless you're government and have to) and you don't have version control and you are still ftping for deployment.... just leave and start at a new company that actually cares about staying current and not stagnant. OR Step up and overthrow your lead developer and bring the company into a new age. Prove your worth and that the changes you could bring would be lucrative for your company. This will require you to acquire many new skills and will be a great learning process for both you and the company.
Doesn't GraphQL use facebooks nonsense license? 
No
&gt; but since you need to introduce at least one `use PHPUnit\Framework\TestCase` line at the top of each one of your test classes You don't *need* to at all. You can replace class MyTest extends \PHPUnit_Framework_TestCase with class MyTest extends \PHPUnit\Framework\TestCase Which is a simple search/replace. Since you're only using it once there's no issue of repetition. You can refactor gradually to use "use" later on if you like.
Yes that may be true, but it will require a later second pass to clean it up, and it may conflict with some code style checks, if you have them. Anyhow, it works only if you are in the first, "lucky" case that I wrote of. 
&gt; and it may conflict with some code style checks, if you have them. Most linters can actually automate adding the use statement for you, so no manual second pass would be necessary.
Yes, that would be a very fast way to do that. 
You need to improve that environment and get junior developer in-the-bag is my advice. It will give you talking points, the experience of a slog so you can say you're a self-starter honestly. * Convince them to move to VCS * Convince them to update PHP (that'll be fun, but it's hella-faster now so there are easy-wins along the way) * Read up on CI &amp; CD systems (although you won't have to make one, it helps to understand for example after a command is run if you `echo $?` in a *nix environment, it should say "0") It's absolutely whoever is running that department problem and fault that you're in this position, but it's on you if you don't get out of the situation. Quitting is the easy way out, and won't help you or future employers (you may not get jobs because there will be a perception of lack of dedication). Here are the seven deadly sins AFAIC: * Modifying ***ANY*** libs in-situ and not either * contributing back upstream * putting your own fork in a VCS that you commit to maintain * Using poor commit messages and VCS flows that don't help clue others up on * why a commit was made * knowledge gained fixing (summary not essay) * large 100+ line methods (you're a junior, not an amateur, I'd suggest aiming for &lt; 10 line methods but up to 100 is fine) * rewriting core language features * illegible code * working with / deferring to others * this is equally important not to do too much as to avoid altogether * consistently poor code separation * echoing &amp; performing logic in one file (there are exceptions) * Mega classes that control implementations (look up facade, it's okay to have a mega-class that defers to other classes if the team is fine with it) I'd say once you've got those licked, you can rubber-stamp junior status. The testing comes to play I'd say after junior, then debugging (perhaps), a greater understanding of the domain you're serving (request/response model). You'll start thinking of how to write shorter methods, increase reuse and for moving beyond that you'll need a specialisation.
https://medium.com/@dwalsh.sdlr/using-graphql-why-facebook-now-owns-you-3182751028c9 If you're gonna answer at least make an attempt to be correct.
I wouldn't be surprised if that does happen. The system was really good at what it does. They even got a billion dollar global company as a client. However every update would break something, no organisation at all, absolutely shit user interface, taking more work than they can handle etc etc. I could totally understand why the current developers are still there. However the job was very very boring and they didn't seem like they were learning from their mistakes 
Nothing is stopping us, or I wouldn't suggest it as a practice. But it'd be better if Composer supported parallel major version installation without us having to fork our entire repositories on GitHub for every version to achieve it. Separate repositories and separate packages gets really noisy visually once a package accumulates enough major versions. Imagine a vendor with 10 libraries = 10 packages = pretty neat. Now imagine 10 libraries with 10 versions = 100 packages = not neat... at all.
It’s kind of a pain to implement, since a major version bump will require a change to every namespace declaration in the project, even for unchanged or otherwise compatible files. It’s more of a language limitation than one from Composer. Arguably it’s possible to create some sort of build system (not entirely dissimilar to Phar) to solve this, but it would be quite weird and nonstandard, and would be hard to make work very reliably across different package layouts. 
From my tests Atom is much more cpu hungry than Code or Sublime
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'd be interested to see those. How did you perform them?
Seems I misunderstood the purpose of GraphQL when i created this post. I assumed it was a completely different layer to interact directly with the db. So one thing i am confused about is how the the web app/entities should use the data mapper. I am assuming they would just replace the query builder methods within repo's correct? Also in your implementation are you sending json throughout the app? Very quick/incorrect example of my question regarding db call within a repo `$this-&gt;db('query {user(id:1) {etc.etc.}}')` 
I misunderstood what GraphQL was when posting this, have since learned the difference still need to learn much more though. 
Every time I've used Atom for more than just a dumping ground for random bits of text I've found its performance to be awful. It's a shame because I'd really like to see another IDE that can hold a candle to PHPStorm, and Atom has a really nice interface out of the box that's much better than PHPStorm or Sublime. But I can't use an editor that falls over as soon as I open my codebase up in it.
I have a very different experience with Atom, and I've used it almost exclusively for about 18 months (before: I used PHPStorm primarily and Atom/Sublime secondarily). It is quite stable and fast in my experience.
Please, let me know how I could improve it... It's the first time I do a library that can be extended easily like that. I did it mainly to learn, I don't think it could be useful to someone. 
It's like one line of configuration to have it initialize after the SPL... lol
&gt; Seems I misunderstood the purpose of GraphQL when i created this post. I assumed it was a completely different layer to interact directly with the db. It's a common mistake, and you can *certainly* have a concrete implementation do exactly that. But it's much more. &gt; So one thing i am confused about is how the the web app/entities should use the data mapper. I am assuming they would just replace the query builder methods within repo's correct? The question is not specific, or I can understand it. Can you please rephrase it? &gt; Also in your implementation are you sending json throughout the app? Very quick/incorrect example of my question regarding db call within a repo `$this-&gt;db('query {user(id:1) {etc.etc.}}')` Close, but I don't pass either GraphQL queries as strings, or JSON as strings. I instead communicate with array structures and value objects (which also produce array structures, typically). Writing and working with a GraphQL layer in your app is pretty much an excercise in mapping a query/mutation specification as it travels through each layer of your app, and becomes *another* query/mutation specification, more and more low-level as it approaches the database. First, a quick clarification, I don't use GraphQL, I however use a JSON API on my HTTP endpoints that's extremely similar to it (you specify a tree of fields with custom parameters). I've been doing this before GraphQL existed, and I don't see much point of involving GraphQL as an additional parsing step. But you can easily add GraphQL, as it compiles to JSON, which then becomes pretty much what I do. Let's go through processing a typical request, to see how it all comes together. Scenario: the client is asking me via an HTTP JSON API, for some details about three users. Some fields (name, email, etc.) and also a profile image of certain type (PNG) and max width/height of 128 pixels. I have a "RESTful" frontend for this so results can be cached etc.: GET /api/users;select=(firstName;lastName;email;profileImage;(type=png;size=128));idList=(1858;9371;917)/ The encoding here might be a bit confusing, but basically it's a way to encode hierarchical data in a URL, sort of like "URL-safe JSON" if you will. The "RESTful" API is cute, and fine for the basic use cases, but often fall short when you want to run multiple operations at once, and especially if you want to run them **atomically* (i.e. mix query with commands, and have commands either *all succeed* or *all fail*, no partial failures). So I also have the "batch" frontend that accepts multiple commands/queries via JSON over POST (just one query here, but you could add more): POST /api/ Content-Type: application/json [ ["users", "get", { "select": ["firstName", "lastName", "email", "profileImage", {"type": "png", "size": 128}], "idList": [1858, 9371, 917] }] ] This is the same exact query as above, and I hope this is a bit more readable now. After this point, the respective "RESTful" or "batch" frontend decodes the request, and we arrive at some PHP arrays ( $query = [ 'users', 'get', [ 'select' =&gt; [ 'firstName', 'lastName', 'email', 'profileImage', [ 'type' =&gt; 'png', 'size' =&gt; 128 ] ], 'idList' =&gt; [ 1858, 9371, 917 ], ], ]; Now, just like in GraphQL, parameters for queries and commands are custom and specific to the query/command, they're like method parameters. But some parameters, like "select" have a standard format (again, just like GraphQL field lists), and I accept "select" parameter in two variations, a list (as above) and as a dictionary. If I get a list, I transform it to a dictionary. So this: [ 'firstName', 'lastName', 'email', 'profileImage', [ 'type' =&gt; 'png', 'size' =&gt; 128 ] ], ... becomes this: [ 'firstName' =&gt; true, 'lastName' =&gt; true, 'email' =&gt; true, 'profileImage' =&gt; [ 'type' =&gt; 'png', 'size' =&gt; 128, ] ], This operation is recursive, i.e. if a field has parameters and one of them is "select" (i.e. it has subfields) then I convert that too. I hope it's clear why I support the list variation: most fields don't have parameters, and typing `"foo": true` after every field name gets boring fast. Now that I have the newly massaged array structure, I validate its contents and structure, to make sure everything I read is in the expected format. So it's time to execute the query via my mapper now. Well my mapper works with SQL, not with profile images that have to be resized, so we *split* the data temporarily, fetch from the database, get the image, and join things back into one cohesive result: // I normally have utils to split the array more compactly, but here using plain PHP: if (key_exists('profileImage', $query['select'])) { $image = $query['select']['profileImage']; unset($query['select']['profileImage']); } // Feed the query into our mapper, which **happens** (not coincidentally) // to be taking the same type of query structures in its methods. $users = $mapper -&gt;from('Users') -&gt;select($query['select']) -&gt;where('id', 'IN', $query['idList']) -&gt;fetchAll(); // We need to fetch and merge-in the images: foreach ($users as $i =&gt; $user) { $url = $imageService-&gt;getImageUrl('/assets/avatar_' . $user['id'] . '.jpg', $image['size'], $image['type]); $users[$i]['profileImage'] = $url; } // The query is processed! return $users; I took a few shortcuts for simplicity's sake (i.e. I assume the the client asks for field "id", but if they don't, I need to fetch it, then discard it from the results etc.), but that's all there is to it. And to make this work with GraphQL, all you need is to add another front-end in front of this machine to take GraphQL and parse it to the arrays we need, then everything else is the same again. The key is, as you sensed, to use libraries and mappers that align with this type of workflow. The classical ORMs like Doctrine and Eloquent just suck for this type of workflow. So it's a matter of time, I think, that they go the way of the dinosaurs, because that's the future of APIs. 
I've had quite the opposite experience than what others have mentioned. PhpStorm has always felt slow and clunky to me, always used a fair bit of RAM and the UI has always thrown so much at me. I know it's quite powerful and has quite a few cool features that my co-workers depend on that are really neat, I just could never really flow with PhpStorm. Atom on the other hand has always performed really well for me and does exactly what I need it to do. I've never seen the CPU hogging that others tend to mention. It's also very minimalistic and shows me just the things I want. On top of that it's very easy to port all my settings to a new environment, maybe even get a Docker container for it (overkill, but fun). I haven't tried VS Code and I don't care much for the lack of communication from the author of Sublime (100% personal opinion). With all that said, I really am excited to see what features these packages bring. 
A readme file explain what it is and how to use it. 
Atom was lagging while writing code... I had task manager opened while using them. So far Sublime is the lightest.
&gt; PhpStorm has always felt slow and clunky to me What are your specs? Aside from the slow initial startup, I've not experienced this personally. &gt; I don't care much for the lack of communication from the author of Sublime ? There's updates every month and him responding to feedback on their forums. Is this about when he disappeared and went on vacation for like a year in 2015?
What's the largest codebase you had open in it, in terms of number of classes and lines of code?
Does it have to do anything with the OS/Specs? Cause I also tried to use for one moment on my windows system, Core i5, 8GB RAM and it just slowed the whole system. I eventually had to kill the process the stabilize the system. Then again many, like you, are using and saying its working fine. So wonder if thats the case...
This is what caused me to abandon Atom. It just can't handle large files especially if Git is involved and you're changing branches while the files are open.
You probably want to direct this at /r/laravel.
I was playing with the dictionary structure last night and realized mixing sequential/assoc array configuration would be annoying to deal with ( exactly what you said ), one thing that came to mind was using an array value to hold `profileImage` like fields which may require custom configuration/parsing, did you ever explore this route? For example: [ 'firstName', 'lastName', 'email', [ 'profileImage' =&gt; [ 'type' =&gt; 'png', 'size' =&gt; 128 ], 'friends' =&gt; [ 'firstName', 'email' ] ] ] I was thinking normal sequential values would just return the column data and an assoc array value `profileImage` would map to a specific method. Since we are working with value objects query specific data can be saved to object so within the `profileImage` method I could defer execution until user data has been retrieved/set within object. I read a few graphql php implementations and saw that they parse the graphql syntax to an array pretty similar to yours ( well one included the `column = true` approach but I much prefer the method you have shared, thank you for doing so by the way ). I still have a lot of reading to determine the final route but I was thinking of just making the layer as lightweight as possible. I am going to keep playing with things but i am thinking about the following route &gt; Query Parser ( Handle any conversion of input to dictionary ) &gt; ^ Maps To User -&gt; Value Object/Gateway ( Check cache, if empty request from db driver -&gt; transform data for return if needed ) &gt; ^ Receives Drivers ( Cache, DB ) -&gt; These handle actual data retrieval/interaction with cache/db ( Including using Querybuilder etc. ) Do you check data type at all? I am on the fence about the use for it at least for the applications I am playing with. 
The basic idea of decoupling is good, but I don't think you're doing yourself a favor by using an Active Record implementation like Eloquent since you're sacrificing some of its benefits. If you like Laravel I would suggest looking into the LaravelDoctrine plugin. Also: I recommend to avoid just using simple setters and getter and instead use constructors, names, and logic that matches the specific requirements.
Give VSCode a try and you will not be disappointed.
Tried VSCode for several months. Went back to Atom. Don't understand the obsession with VSCode.
Seems like it got its name right. Massive as a neutron star but small and with barely any features.
Interesting....it depends on for what goals do you want to use...For php framework PHP Storm is best...For other goals I'm using VScode and Brackets... I try to use Atom two times...It's very good.... It's necessary to try again...beta version...
Hmm, you could be right! Perhaps how it's compiled for your platform, perhaps an electron bug in Windows...
Laravel projects are typically quite large. Discovered a couple bugs in the new beta with some of Laravel's code last night though; so it's not perfect.
I can believe that. Sublime has always been a goodie.
I also didn't take to vscode, but I didn't give it a lot of time so...
Yeah, extremely large files tend to be a problem. The largest files I've opened are JS prod builds, but I wouldn't call that normal usage.
TIL about the language server protocol. I'd love to see that implemented in GitHub's web UI (files, pull request diffs, etc.) so that you can navigate your code juste like in an IDE.
People, people, people, you need faster machines. Not cpu-speed, but you need more core-count. Web development usually has applications which are multi-threaded inside, the more threads you can handle, the faster things run. Same with phpstorm. If you only have 2-cores, even with hyper-threading, you will experience lag. But also you need a sizable amount of ram to handle stuff like phpstorm + vm's and such. I went with a Dell 7510 w/ i7-6820HQ w/ 32gb of ram up to 64gb, 4k resolution display. You guy's really need work-horse systems. A macbook pro w/ 16gb of ram is not going to cut it anymore. Maybe the next generation will when they can give you atleast 32gb. My workstation is a xeon 2690 w/ 64gb of ram running 2 ubuntu vm's for 2 different projects both running phpstorm and it runs blazing fast with projects that have thousands of files via composer, additionally running many instances of it simultaneously running phpstorm w/ angular 2 codebase. the i7-U series and i5 series chips are not for us guy's. 
The day software development needed more resources than Dishonored 2...
awesome now they just need to rewrite the entire thing in c/c++
Atom does lag for me but only in my css file seems like packages like pigment ext takes a lot of cpu/ram but I also have 1000lines of LESS
If you want to use type hinting, have a look at https://github.com/barryvdh/laravel-ide-helper. It can generate PhpDoc-comments for your model classes based on your database schema.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I see zero unit tests for your library. People, including myself, mostly avoided libraries that don't have any unit tests
Why so?
Not sure it fits the definition of Event Sourcing if you are storing the whole state with the event. It kinda looks like a "Versionable" with a stored history (log) of actions that were applied. edit: Although, I am doing something similar. I am storing events in an event store for auditing purposes as well as for creating projections (and they could be used to reply the current state of the aggregate if needed), but the current state of the aggregate is persisted in a separate store.
Having had an open source licence for phpstorm denied yesterday due to my using some of the packages I work on to put food on the table, I'm definitely looking for a good alternative. I'm happy to pay for a tool, but when it doesn't exactly match my work flow, it's a value thing to weigh up.
I use this, but it seems to be a bit sketchy around model properties. In that it doesn't always generate them. Everything else is great though :)
Atoms already slow as hell, I cant even begin to imagine how slow it'll be now :| 
&gt; People, people, people, you need faster machines. You cant really justify that when something like sublime works perfectly fine. Atom is slow because its using a html rendering engine designed for websites. You'll never get the same level of performance as a native app, and telling people its their fault for not having a more beefy machine is a bit of a joke. "Theres nothing wrong with my 100mb background image on my website, its your broken 10mbps internet connection - fix that"
&gt; We strongly recommended you use **Atom Beta 1.21** as it includes the necessary file monitoring and process control to ensure the underlying language servers are running properly. I can't even install the `ide-php` package when running the stable version, so "strongly recommend" isn't nearly strong enough.
I'd recommend to give VSCode too a try. It gets pretty good with Intellij IDEA Keybindings, PHP Code Format, PHP IntelliSense and Contextual Duplicate extensions. I'm now trying Atom beta with the IDE packages, but not sure yet.
&gt; one thing that came to mind was using an array value to hold profileImage like fields which may require custom configuration/parsing, did you ever explore this route? For example: &gt; [ &gt; 'firstName', &gt; 'lastName', &gt; 'email', &gt; [ &gt; 'profileImage' =&gt; [ &gt; 'type' =&gt; 'png', &gt; 'size' =&gt; 128 &gt; ], &gt; 'friends' =&gt; [ &gt; 'firstName', &gt; 'email' &gt; ] &gt; ] &gt; ] I have explored literally every trick and hack to factoring this, yeah :) The reason I chose against splitting them in two like you do, is it creates an artificial (from the PoV of the user) boundary between "fields without params" and "fields with params". The goal of APIs like GraphQL and mine is to make the API *uniform* and *hide implementation details* rather than expose them (i.e. what's a field vs. what's a method). More concretely, it creates the following pragmatic hurdles: **One**. it doesn't allow a field to have *optional* parameters. If you split them in two and declare the ones with options are a different category of data (from methods) you can't have fields where sometimes you use the defaults for convenience, and sometimes you exert extra control via options to get exactly what you want. **Two**. From the above it also follows you can't start with with a field being just a DB field, and later adding evolving it to have options. A real-world example would be the profile image. In a basic API, the URL to the profile image would be just another database field in table "users". Over time you can add an image service to convert and resize it for you on the fly, so you'll have options. So what happens with all the existing API calls that treat it as a field now have to treat it as a method? You can break them (very bad), you can bump the API version (not good), or you can support a field being expressed as either a method or a field, and you convert between them on the fly. However, **three** :-), the problem now is you can't order the fields in the natural way they come into your mind, and moving them from the category "without options" to the category "with options" changed the field order and creates a much noisier diff in your repository. Compare adding options to a field in both formats, when it's not right at the end. Before: "foo", "bar", "baz", "qux", After (mine): "foo", "bar", { "size": 128, "type": "png" }, "baz", "qux", After (yours): "foo", "baz", "qux", { "bar": { "size": 128, "type": "png" } } Aside from having to move "bar" from second to last position, notice that your version requires more typing and doesn't allow you to scan the list of fields requested in a neat single column. Essentially what my chosen format achieves is you can think of the field list is that it's a *dictionary with optional values*, where the only characteristic thing is instead of typing ":" (in JSON) or "=&gt;" (in PHP), you type ",". I think that's a mental model that one quickly gets comfortable with. It works quite well with variadic functions, too, my `-&gt;select()` method from above also supports field lists through variadics and I love how clean it looks: $mapper -&gt;select( 'foo', 'bar', [ 'size' =&gt; 128, 'type' =&gt; 'png' ], 'baz', 'qux' ); &gt; I still have a lot of reading to determine the final route but I was thinking of just making the layer as lightweight as possible. We have the same thinking, I think if we put on the scales the ability to have optional parameters, and evolve our API to add parameters to previously parameter-less fields, the conversion is worth it. Plus, in my case even database fields can sometimes have parameters, so the distinction "fields" vs. "methods" was not practical. When you think about performance don't forget that parsing/transforming the API request is *not a part of your domain*, and can be scaled infinitely (i.e. you can add as many front-end servers to convert requests for your business/database logic as you want). Such transforms are also very easy to make practically free through a C extension for super-high-load scenarios. If the list conversion bothers you, it shouldn't, it's as light as any other variation we'd use :-), in fact here it is: https://3v4l.org/a1094 Also the detection of dict vs. list formats (if you may receive either) is basically free (performance-wise): if (isset($select[0])) $select = convert($select); &gt; I am going to keep playing with things but i am thinking about the following route &gt; Query Parser ( Handle any conversion of input to dictionary ) &gt; ^ Maps To User -&gt; Value Object/Gateway ( Check cache, if empty request from db driver -&gt; transform data for return if needed ) &gt; ^ Receives Drivers ( Cache, DB ) -&gt; These handle actual data retrieval/interaction with cache/db ( Including using Querybuilder etc. ) &gt; Do you check data type at all? I am on the fence about the use for it at least for the applications I am playing with. I think using objects for your DB records with GraphQL-like APIs is not pragmatic, because at any point of time those objects would be 80% empty (high number of fields, and a small subset requested). Also you'd be creating those objects from arrays (result set) only to be instantly converting them back to arrays (API JSON response). There's no value in all that extra work. Value Objects are still useful, but not for encapsulating whole entities, but specific values where it's worth it (for example: datetime values, authentication tokens, in some cases monetary amounts etc.). Careful with cache: people often rush to place cache before everything and sometimes ironically achieve the opposite results (i.e. the extra logic and burden of maintaining, checking the freshness of, and fetching from cache is slower than having no cache at all). A recent example is MySQL announced they're dropping their query cache because in practice it doesn't matter or may even slow you down. Regarding "type checking", I validate and check everything, but I'm not sure what you mean exactly, can you elaborate :)?
What's the use case for it? I can't see why I would use this when I have so many different view templating engines on offer...
That's where most of the criticism comes from I agree. At the same time the current state is the previous state for the next new event. So it's the full state, but only for a while. I took it from redux.
&gt;I cannot study if I don't know PHP
Cool.
So you're saying 16gb ram isn't enough to edit plain text files? What a time to be alive.
not exactly like this. I need to know PHP for my final exam. So I mainly need it to pass the apprenticeship.
I am not too concerned about parsing time just questioning to have a better understanding of the reasoning behind the implementation, I know caching and other methods can for the most part help, I was mainly concerned with ease of use and trying to avoid going down one path now to change my mind later. I see your point about the boundry between column/method. I just realized something, what was the reason for passing parameters as an array vs how GraphQL handles params `method(paramName: "value", paramTwo: "valuetwo")` As far as the type checking goes GraphQL requires the available columns/data to be typehinted and it validates type on return I believe ( throws error if doesn't match ) [example](http://graphql.org/) BTW feel free to tell me when the questions become to much, trying to gather the most data possible to help with the decision making process :D and thank you again for the help. 
&gt; the i7-U series and i5 series chips are not for us guy's My i7-4510U runs ST3/VSCode without any lag whatsoever, that too, when working with a large Laravel codebase. Atom, on the other hand, freezes often when working with the same.
&gt; As far as the type checking goes GraphQL requires the available columns/data to be typehinted and it validates type on return I believe ( throws error if doesn't match ) example I have a library for building "formatters" (think validate and transform) and I use it both for validating input and for making sure output is in the right shape (although I don't always use it for output, when the data I have is already in the right format, guaranteed). It's similar to GraphQL in that it's a "schema" of sort. It's different in that the schema is not some custom syntax, it's just a basic PHP API you can use for processing any kind of input/output (the one I gave an [example of here](https://www.reddit.com/r/PHP/comments/6yjy20/ask_rphp_what_is_your_favorite_validation_library/dmq3ncg/)). &gt; BTW feel free to tell me when the questions become to much, trying to gather the most data possible to help with the decision making process :D and thank you again for the help. Nah, keep asking ;-)
That "vacation" is still ongoing? What are some of the recently added [features](https://www.sublimetext.com/3). It's been a while since I heard about that new UI and it's still not released?
I'm running Windows 10 on a i7-4510U machine. Opened up a fresh Laravel project in ST3, VSCode and Atom. Here's the memory usage: https://imgur.com/ojrZnDr 
The part I think that makes Atom stand out above Sublime and PHPStorm is that it's completely open source and has a developer mode. So if you find a bug, you can open the devtools console find it, and submit a fix right away, not submit a ticket and hope that in the next release it's fixed or it's big enough to warrant a new release asap.
Check the official documentation for this: http://www.yiiframework.com/doc-2.0/guide-intro-upgrade-from-v1.html
That is a good point!
Found this in source code: `defined('FOO') || define('FOO', 'bar');` How such construction is called? Never seen it before in php code.
Funny that you say that because SB3 just released lol https://www.sublimetext.com/blog/articles/sublime-text-3-point-0
Does any of you use it in production ? Compare to Magento2 ...how good is it? 
We worked with this quite a bit during its beta phase, and almost went with it for our big replatform project. I very much enjoyed working with it. It wasn't nearly as painful as Magento, but was still very powerful and extensible. I'd recommend taking a look at it.
There is [http://sqlbuddy.com/](http://sqlbuddy.com/). It's a skinny, user-friendly version of phpMyAdmin. Check, double-check and triple check the user permissions if you go the direct access to the database route and make regular backups.
Any platform who rates them selves by the number of stars they have on Github is a no for me
Don't use PHP to manage servers or credentials. Use a tool like Ansible that is meant for it.
&gt; or, god forbid, execute SQL commands directly to their server through console What? That's the only sane it should be done, over SSH obviously and not have the DB on a public facing port.
I'm curious how much 'damage' has already been done to Atom's popularity at this point. It started slowly chipping away at Sublime's userbase but never really showed that it could entirely replace it. Performance was the main issue I'd hear about which sent many people back to Sublime. Then VSCode came out and has really impressed a lot of people. IMO VSCode is a very capable sublime replacement with a very promising future(Open source, the MS team are pushing out requested features constantly, performance is more than acceptable). I guess this 'IDE' version is an attempt to find a place between text editors and the more full featured and established IDEs like Visual Studio and the JetBrains line.
I don't think you understood my question. I am wanting to set up a 'easy installation' page for my project so that anybody can set up an SQL database with relevant credentials to store the data submitted from their site. It's a blog / forum hybrid I am creating and the audience isn't necessarily tech-savvy. Just as Wordpress and others offer a simplified way to set up the database (by simply entering in some credentials), I would like to achieve the same.
I've been on beta all this time? Wow. 
I couldn't even get the IDE version to work, granted I haven't put much effort into it. It's highly unlikely it'll convince me away from PHPStorm.
That's an asinine comment. They are an open source project, so activity and popularity on their source repo is an important metric. They were simply giving some interesting numbers related to that activity and popularity and you cherry picked the number of github stars as some immediate disqualifier? 
I've used it for several years in production - it's wonderful. I can't compare it to M2 but it's a dream compared to M1.
It looks nice, I like that they separated it with multiple bundles that can be reused on their own in symfony projects. The code seems clean
LOL yeah i was was like wait 3.x just finally came out. geez only been like 10 other editors that have released and had lots of updates in that time.
I can. We've used M2 and Sylius (well, back when it was in beta). Even when it was in Beta, Sylius was a dream to work with compared to either version of Magento. Everything is cleaner, more straightforward. Very easy to work with and extend. We vetted it for our major site replatform and very nearly went with it over M2. The only, and i mean ONLY reason we went M2 instead is because the higher powers didn't want to gamble on a new system when we already had M1 experience. We thoroughly vetted it, met with Lakion developers (the company that wrote it), wrote extension modules for it of varying function and complexity to test what it was like to work in it day-to-day. We even had a dev-off where we had two teams try to write the same simple module (a notification module -- put messages at the top of the site in a little notification bar, configurable from the back end) in both M2 and Sylius, and gave both teams one sprint (2 weeks here) to see how much they could get done. The Sylius team not only completed the module, but had enough extra time left over to add additional features to the module that weren't in the task, but made sense and made the module more flexible. The M2 team barely got the backend admin panel finished. If you have the flexibility to give it a go, I really recommend taking a serious look at Sylius for any ecomm projects you have going on.
It's been a while but the editor and website do look promising.
I typically have a `BaseUnitTest` class my other tests extend from, so upgrading means I only have to replace a single `use` statement. I don't use any of the removed methods mentioned in the article, but your base unit test class could even alias them to your tests will still run while you're incrementally replacing said method calls.
activity and popularity metrics can easily be gamed... in reality they mean nothing. 
Last change log on their website was 23 September 2016, i for sure thought the development was dead.
Use `type: project` in your composer.json and the [scripts](https://getcomposer.org/doc/articles/scripts.md) object (e.g `post-install-cmd`) to specify what to run. Users will then run `composer create-project your/project` and get their app properly set up. See [symfony-standard](https://github.com/symfony/symfony-standard/blob/3.3/composer.json) project for example.
For now I'm working with standard PHP.
Composer is standard PHP. Even better, composer is the standard when it comes to package management. Wouldn't recommend building stuff without it, even if it was just for autoloading.
You're basically saying you don't want to use Eloquent. I will try to help, how many people work on this project? * 1-3 =&gt; stick with Eloquent, don't worry too much about decoupling it * 3+ =&gt; ask your lead developer * "but i'm the lead developer!" =&gt; look at @fractis response
Thank you for your assistance but what you are suggesting isn't what I am looking for. I checked out Composer and it is a means to add packages and libraries, which isn't what I want. I only want the user to navigate to a PHP page, enter in some details for a database to be created and then have the whole thing set up and ready for them. No additional stuff besides standard PHP and SQL.
That aside, it's a dumb reason for not using a piece of software.
Does anyone know if Sylius can host multiple shops with multiple different templates.. 
I think that's a form of [short circuiting](https://stackoverflow.com/questions/9344305/what-is-short-circuiting-and-how-is-it-used-when-programming-in-java), because if `defined('FOO')` is true then `define('FOO', 'bar')` is never actually called. I don't especially like it, though.
So this is... Operator Overloading? Or if not, can anyone explain the difference? 
my "theme" seems to be completely borked now. horrid red-orange gradients and lines all over the place.. missing images? Switched to "default" theme... all is well.. it seems that now the color schemes have control of the left-side file list.. **edit:** a) I mentioned that I solved the issue by switching themes. Monokai is working just fine for me with the other theme. b) I'm [clearly not the only one](https://forum.sublimetext.com/t/very-colorful-tabs/31244/10?u=wbond) that got a rude first-impression of this release c) So&amp;hellip; why the downvotes? 
So "best practices" is not what you're looking for. A simple bash script to prompt for credentials and run db init for you, then.
"full" is an absolute term... there is no "enough". 
Hmm. I'm beginning to suspect that I haven't explained what I am looking for properly with this post. Feels frustrating.
who is "the user"? how did they download your software? as you said, composer is a means to add packages... now imagine your software is a package, and the user adds that package to their server using composer. now the user doesn't have to do anything... the DB is already set up. if you just want a PHP page to execute SQL statements, what is stopping you?
https://www.sublimetext.com/3dev is where you should be looking
It sounds to me like you need to add a package similar to `propel` that can create and seed a database. 
Thank you very much!
This defines a function corresponding to each operator. It doesn't let you do so yourself.
thanks for the info
&gt; It's been a while Yeah, but he's been perfecting the ~~update~~build with nearly updates every month so it's all good. https://www.sublimetext.com/3dev Plus I get a discount for owning st2 and it costs me $30 :)
seems like some logs are missing from that list as well because last week I had my editor update w/ some changes
The code is beyond clean and it's all 100% test covered. On such large code base you definitely find some odd things, but mostly if it makes sense, a PR is accepted quite fast. The biggest downside is there are very little in terms of plugins/modules, but to be honest you are not gonna use Sylius for a plug &amp; play type e-commerce site that does not require or require very minimal dev time, so it's a blessing on other hand because those still require integration time.
Yes i've read the doc, but i'm still confused on how to go about it, will i just start change the yii 1 syntax to yii2? is that all i'll need to do?
To answer your question directly: Take down the configuration from your `install.php` file, format it into JSON, write it into a `config.json` file that your code expects to find, then unlink the `install.php` file. This will require write-access from the server to the configuration location and the install directory. Your database setup should be stored in a set of migration files. At their simplest, these would consist of SQL statements to create the base schema. Each one should be a class with an `up` method that does one step in the schema-creation process. Systems that I've seen have install scripts like this will sometimes write the configuration file contents to the page and direct the user to copy and paste it into a location on the server. They also sometimes direct the user to manually remove the install directory after installation. If you're truly interested in PHP best practices, don't be afraid to use Composer to pull in libraries. Most well-supported libraries handle edge cases and non-obvious security issues that you'd never think of in a decade of writing code in a bubble isolated from code produced by the wider community. Your install script could even download Composer and invoke it during the installation process. Otherwise, you're going to continually end up reinventing the wheel and doing it poorly each time. This is not an indictment of your present or future skill level, but rather part-and-parcel with software development. Each component is a _lot_ of work to correctly build and maintain.
No, there isn't anything wrong with the release, just the theme you were using is referencing files that no longer exist. Since there isn't anything for us to fix on our end, you'd be stuck on 3126 forever. See https://forum.sublimetext.com/t/very-colorful-tabs/31244/10?u=wbond for more details about what is likely wrong with your theme.
That's strange. In a medium sized project with 20+ the ide helper works flawless, never missing anything. Any specifics what is going wrong? 
It sounds as if the Monokai theme is referencing assets from the old Default theme. The author will need to update it.
Can somehow show me what the touch bar options look like on MacOS for Sublime 3?
Methinks you don't need my email address for this.
So one part of the headline is enough to reject looking any deeper? You crazy.
Wow this is really nice, thanks!
I edited the original post. I'm not using Laravel, I'm just using eloquent and everything else is "homemade" without any framework. So what you say is to stay away from "simple" getters and setters and go instead with simple methods but related with our business logic, right? Can you give me some examples maybe?
For what it's worth, from reading the Sublime forums a couple weeks ago, there are two full time developers working on this software. I was concerned that it was falling into permanent development hell for a while there. I love Sublime and use it frequently, but can these two developers keep up with something like VS Code that has a much larger development team and much faster iterations? Perhaps there's not that much more innovation to be had in the text editor /w plugins ide space so it doesn't really matter.
I'm interested in setting the model's fields the correct type. php docs comments are not enough. I want to be sure that if the client is sending a double when instead it should send a string, this double is not set or cast "automatically" by the model, if this makes any sense
I edited the original message. I'm not using laravel :)
Don't much care for the new font they decided to go with in the tabs and all that. Other than that, seems like a solid release.
We are 5 developers at the moment. We don't use laravel and the whole application is "homemade" except for the ORM. Fractal responses look awesome but then they still don't ensure that what I save in the database has the correct type, they are more formatters and this can be done already with presenters that take as input a model, right? I care about the type that the model fields have. Maybe I shouldn't care at all? 
Sure, I recommend checking out these slides from a talk: https://github.com/dave-redfern/better-entities/blob/master/docs/slides-only.pdf
Almost short enough to tweet instead of write a blog post of.
&gt; If an experienced developer that uses another framework comes by and sees that Laravel app, it might be easy to conclude that the problem lies with Laravel, and not with the inexperience of the junior programmer who just begon his/her journey in coding. Said no reasonable programmer ever. The problem is usually with the implementation, not the stack. I've never touched Laravel, but Id assume those people over there know what they are doing for the most part.
I find it lovely to work with when I can. It's a great product and wish I got to work with it in my current role as we mainly use Magento for E-commerce. If the guys where to sell the idea to my boss I think I'd buy them a beer lol. Sure Id need to upskill and it doesn't have all the 'modules' but I want to really enjoy it.
Since 0.15 they released their multichannel support and their theme support has came later. Possible 0.17? Not sure but yes it is there.
Awesome thanks. 
Agile is not a single methodology. Even if you need precision and developer time doesn't matter, an iterative approach is still usually better. The main point of iterating is generate and then respond to feedback. Even the act of starting and writing code will in itself generate a lot of feedback.
Don't just quit your job. Try to improve it. Talk to the lead dev about implementing version control (git) to help keep track of changes a bit. Look at what it takes to upgrade php and how big of a code base you have. Don't be a quitter. 
Magento 2 is like hell on Earth bundled up into a hellspawn of code that makes me want to claw my own eyes out when attempting to do anything with it. How does this compare?
But in a tweet I wouldn't understand this about the author: &gt; When not coding he’s probably rehearsing with his kraut rock band. He loves waffles and butterflies. ~~I also love waffles with butterflies!~~ **EDIT:** Looks like I didn't read this right the first time around. 
&gt; Said no reasonable programmer ever. The problem is usually with the implementation, not the stack. It can't be both at once... it's logically impossible, right? /s What does that even mean "the problem is usually with the implementation, not the stack". That stack is also "an implementation" made by human beings, or do you think frameworks are dropped to us from the Gods above? Laravel does commit plenty of architectural sins and promotes patterns through its own documentation which are industry-wide known anti-patterns. So I think we can be comfortable to assign *some* blame to Laravel if we see a botched Laravel app. &gt; I've never touched Laravel, but Id assume those people over there know what they are doing for the most part. Ha-ha, nice one. 
Ridiculous. I do use Atom as my main editor, but claiming that you need 64GB to edit plain text files is absolutely crazy.
IMHO, this is the wrong approach to the problem. Why treat the environment/system as something your application is at the mercy while you control modular dependencies? Why share your language runtime with other applications? Why run your application in any environment other than what that version of it was built and testing for? [Habitat] (http://habitat.sh) does an amazing job solving this problem. Your app granularly defines everything its environment needs to have, to whatever version specificity you want. It gets built in a clean room empty system, and when you publish a version of it that version is locked into every byte of environmental code you designed it for, down to the ELF interpreter. It does this in a very clever way that let's your distribute and run the app efficiently in any sort of environment from bare metal to containers. The stack of shit under you app should be an internal detail uses never need to care about. Focusing on what it exposes like semver does is necessary to truly blackbox your app at let people use it as a reliable cog in building bigger things
If there's no interest in the effort, you should leave this project up there so we can point to it as an empirical proof that PHP's function names and argument order *don't matter*. It'll be good, just not the kind of good you expected ;-).
Haha, I will! I don't know how proofworthy it is, though. Argument order does matter to me, + I've created the repo, and I still haven't found any time to work on the thing. So far, it's empirical proof that PHP developers don't have time to fix PHP, if anything because you can gauge interest by stars, and &gt; 80 in a month in not _nothing_.
I happen to have a lot of respect for ~~framework~~ open-source developers. After meeting the Cake Devs at a recent conference I found them to be highly intelligent and dedicated with an amazing grasp of computer science. I think most people who devote their time to a large widely used framework would fall into that same category. Do bugs happen? Hell yes, but the lionshare are in "userland" code where unit-tests are the exception and a small team works on it. Not on large well developed frameworks with solid test coverage and wide adoption... But I guess it must be the stack since your implementation is dropped from the Gods above?
This is just the intro to an article. Author needs to write more then 3 paragraphs and a link to another article. 
It can't be worse than Netbeans. Full disclosure: Happy Netbeans user.
Thanks I'll give this thing a shot next time I need an ecommerce solution. The first thing its got going for it is its not named Magento :cringe:
I Remember Taylor Otwel in twitter using stars to praise Laravel
The problem is perhaps that those of us who know the language well enough to be bothered by this, and spend enough time working with it for it to matter, also know it well enough that these are basically insignificant issues for us.
While JS is growing I don't think it'll come close to PHP for webdev any time soon. It has however been great for general apps, for e.g. VS Code (which I love) and many other IDE's are written with it. I haven't really seen many Java/C# web applications, maybe a few ASP sites but it's rare to see even them. I also find that most Java based web apps I stumble across are pretty old or large enterprise.
This website is literally unusable on mobile. I get the newsletter pop up and can’t close it. It just redirects me to another page that pops it up too. 
Depends on whether you prefer configuring Symfony with XML or not. 
+1 for using GitLab
&gt; argument order does matter for me May I ask, what IDE you are using?
Ask for a raise. Get ignored. Find a new job.
Eeeeeeeeh. ¯\\\_(ツ)_/¯
[removed]
This is a great addition to the universe of tools. It adopts a similar constraint-based analysis that tools like Flow and Typescript's checker use, which means you don't need to annotate methods with return types and parameter types. It's the first tool for PHP I've seen that comes at the problem with an academic approach, rather than a make-my-code-a-bit-better approach. The downside of that is that analysis can take staggeringly longer – single-threaded, it takes 30x longer to a moderately-sized codebase than other static analysis tools (and multi-threaded it's more like 60x). While there are definitely some optimisations to be made, it's always going to be slower than a tool that stops at the boundaries of methods. Also it has a bunch of false positives on a codebase I believe to be well-typed, but I assume those will be ironed out in time.
I'm currently working on [adding the ability to fill in missing property types](https://github.com/vimeo/psalm/issues/204) and I wonder whether this tool could do something similar – the idea being that documented parameter &amp; return types make it easier for a developer to understand what a given method does at a glance, *even if* a sophisticated tool such as Phlint can reason around those omissions.
The pages were so slow to load I just left before being able to read the documentation… Reminds me why we switched to GitHub at work.
Bit off-topic, but GitLab is not having a good evening: https://status.gitlab.com/
So the typo in the title is due to strstr? The post title, not the article.
Yes, it's a typo. Every time I post on Reddit I am trying to make a better title but these last minute changes always fail me :)
Funny. We had a small code camp in the company yesterday and the speaker was like "There are people that often complain about PHP and that the function names are bad etc... and then there are these developers that doing PHP for years and don't give a single shit about it.". Someone in the audience then said "So, haters gonna hate?". I hear complaining about PHP a lot. And I rarely understand why. Someone asked what "!==" means, because he know only the unstrict variant and while the speaker tried to explain it, I throw in `strpos` as an perfect example. He then said that this is one of the inconsistencies of PHP and why it receives some hate. I mean.. for me `strpos` is one of the most reasonable things ever. You get your number value for a successfull result.. but what else you can return if even "0" is a successfull result? Well, only the boolean `false` is remaining. And in the end.. for me, developing is to understand the core rules of the language, know the existing functions, know the common mistakes and anti-patterns, know the best practies and then it's just a mix of planing and using logic to come to your goal. It actually doesn't matter which language you use.. this reason I don't get why every month a new coding language appears and everyone be like "omg! kotlin, the future!" and after a week, 60% less people us it and after a year a new language will appear that will be "the future of coding". Similiar with Ruby&amp;Rails, Node.js, Angular JS.. I understand that a big amount of coders still using it and love it, it's okey. But damn.. why invent the wheel always new, when the existing one functions good and brings you to your goal? Yea Winter Tires are not the best on Summer, but they can still be used and are good. And in Winter they are even better. PHP is one of the biggest, successfull languages that exists and so many successfull business have PHP in use.. so why not. The problem is that (like the speaker said): "PHP is so easy to learn that even the baker at the side street can &gt;learn&lt; it and build some small, completly ugly, but working code, for his own need." \*edit\*: I noticed that I may completly speaked around your post.. I am sorry :)
What are the main differences between this and phpstan?
You can host your own gitlab instance. I'm doing it at work. It's perfect.
I can't upvote enought this statement. Apart money, learning is important everytime. Be ready for next hyped language. Or tech use (like machine learning atm).
Intelligent and experienced people do make bad decisions at times though. In fact - to quote Dumbledore - their mistakes tend to be "correspondingly huger". In my mind the problem with Laravel was some of the core principles they set out with. Mostly, that of sacrificing good code design to make an "artisan" framework that looked and felt simple. To their genuine credit, they did manage that goal. I just don't believe it was a very good concept to begin with. I don't see that as something developers really need. 
https://twitter.com/gitlabstatus/status/908224302251696128 for a permalink
Still slow as hell...
&gt; ... this mean that you need to start looking for interview questions and star to memorizing all the questions and the answers. I'd personally rather spend that time studying something that might actually be useful on a day-to-day basis. Read up on the latest languages. Study design patterns. Learn that one technique you always meant to learn but never quite got around to. Maybe I'm being picky, but if getting the job depends on memorizing some random "interview question", rather than on knowledge, skills and experience with development, I'd rather just move on.
Looks interesting but website is too slow, in fact it cannot load some [elements for display](https://i.imgur.com/RsbTQYL.png)!
I would love to test this out however the PHP IDE has a minimum dependency of atom 1.21 which is still in beta and Atom has historically been problematic to say the least. There is also no guarantee that damieng(maintainer of php-ide) will not just continuously bump the dependency to stupid requirements. Will stick with a sublime/phpstorm combo.
GitLab are currently getting hammered: https://status.gitlab.com/
Damn that page is too slow. I couldn't get past the any page to see how it works. This should be -1 
&gt; most Java based web apps I stumble across are pretty old or large enterprise That's the space I've been in for 10 years and Java or C# do dominate that landscape, PHP or JS seem to be the popular choice in smaller companies or start ups (which is what my current role is)
`php artisan ide-helper:models` generates annotations for the models (and other stuff), but it no longer seem to include class properties it once did.
Please, crysis 3 on ultra will forever be the benchmark of resource acceptability :)
&gt; I love Sublime and use it frequently, but can these two developers keep up with something like VS Code that has a much larger development team and much faster iterations? It wil be extremely difficult for them to compete with the pace of such a large open source platform such as VS Code
Hey, thanks for your work. One question though: where I can check complete rules list (https://gitlab.com/phlint/phlint/tree/master/documentation/rule - this look rather as incomplete)?
This library isn't very original, but it helps me to use compact (binary) GUIDs (not following UUIDv4, nor any other version) that are DB-friendly (they're compatible with B-Tree indexes in the sense that no index rebuilds have to be performed by the DB engine due to out-of-order insertions). https://github.com/Litipk/Unicity I have done some adaptations to Laravel's Eloquent and also Doctrine, but they're privative :( .
Meh. Changing function names I've used for 12 years would make it worse for me.
You have something wrong around so ... I'm working with it everyday and got no problems
I might agree but I mean—I'm not saying it would change anyone's life, just that it might be useful.
[removed]
There is no slow initial startup if you use an SSD.
Alright, after a few failed attempts I believe I am going in the right direction. Currently trying to determine the best way to retrieve data from db. In most GraphQL examples the datasource is just a returned array that is then 'cached' within a collection so further queries can check the collection before making another db query attempt. Do you handle querying in a similar way? If so do you just return all columns from the table or re-fetch if a new column from the same user is requested in the batch? This specifically applies when doing something like pulling friends of a friend similar to most graphql examples. 
It's easy to conclude there are problems with laravel no matter who uses it.
&gt; the project has kind of stalled for a month This pretty much shows how much the 'inconsistencies' really matter; not enough to sustain people working to fix them for multiple weeks, which is a lot less time than it would take to fix them in core.
How is it vs nodejs?
Hello there.
Don't do a best 40 list if you can't find 40 ;-) You disqualify yourself by calling HTML and CSS programming languages xD Meteor, Knockout, ExtJS are JS Frameworks. Why the hell extjs 4 (it's at version 6) but non the less nobody should use or even talk about extjs if you don't want to suffer. Guzzle, Fuelphp aren't frameworks they are just libraries.
Give points to every item you mention. Pick the top 5, and make a hello world with it. Give points for it from that, pick the top 3, and make a phonebook applications with it. Give points select the one with the highest points. this is how I roll ;-)
It seems to be an old page, which just repeats the elevator pitches for the underlying websites. Perhaps this was written by a crawler program. :-(
[removed]
I think /u/sirber is specifically asking about a performance comparison between the two.
Why are you yelling?
This isn't a list of the best php frameworks. This is a list of all the frameworks your crappy bot could find.
/r/phphelp
low quality post
I'm using this to power a web socket server, and also an HTTP API without any need for a web server. Loving it! Not live yet, so can't talk about performance, but I am not expecting any issues.
Urgh, that spammy sidebar... `:=(` Reported as spam - there's nothing in your account but links. 
I wonder if the 85 GH stars came from the kind of folks who spend considerable amounts of time saying how terrible PHP is, actively going out of their way to tell beginners to avoid it, and **who do not use it themselves at all**? 
Out of curiosity, if you're running the entire business off a single server, what's the plan for when the server breaks? Isn't there a standby server? If there is a standby server (but something tells me there's not), you could set up the standby to host both PHP 5.3 and 7.x, and then start migrating customers to 7 by testing it out on the standby server. The risk would be low and the performance and security improvements alone should be enough motivation. This way the migration can happen gradually, essential for a small team, and it can be customer-transparent. By the end you have the "main" server not running any web service anymore, and then you can upgrade the PHP there to be 7.x as well, and use it as the web standby. Your lead developer should have already set a plan like this in motion. Either they're being blocked by management for purchasing a new server (red flag), or they're a lead developer in title only (redder flag).
No idea what you're doing to have so many performance issues. It's certainly not the most efficient piece of technology, but I've been running it in a Docker container going on almost 2 years and It's been great.
Na, it has always been slow wherever I've seen it installed. It's also almost unusable for very big diffs. Don't get me wrong though, it's not unworkably slow most of the time, but you never get the feeling of it being _fast_.
It's ok most of the time although you never get the feeling of it being fast, but for big diffs it's painfully sluggish. It's not just my personal impression with my setup, it's a recurrent feeling wherever I saw it installed. I wouldn't go as far as saying is blazingly fast either though, but it is faster than GitLab most of the time.
They're still developing this? I thought this was superceded by [Amp](https://amphp.org).
ReactPHP is actually still under heavy development and use. ReactPHP event-loop installs are 3.5 million vs. Amp's 80k There are also some very exciting things coming with http-server middleware, which IMO blows Amp out of the water.
Oh boy I sure can't wait to start "Zubr"'ing all my core method calls.
&gt; simulates coroutines What do you mean, it *simulates* co-routines? They're literally co-routines.
PHPStan requires PHP 7, so unfortunately I can't use it for most of my current projects at the moment.
phpstan (and other similar static analysis tools) stops at the boundary of functions – so it won't detect the bug in this code: function takesInt(int $i) : void {} function foo($i) : void { takesInt($i); } function bar($i) : void { foo($i); } bar("hello"); See PhpStan's results [here](https://phpstan.org/r/7f0c015f62e445b7686f0298f35e765f). Psalm (my static analysis tool) does a *little* better, in that it can help you incrementally add typehints to your parameters - if you paste the above code at https://getpsalm.org you'll see a bunch of warnings. So basically, if your codebase lacks docblocks/typehints, and isn't too large, you may want to experiment with phlint.
They're 100% coroutines and 100% promises but 0% A+. 
Don't compare absolute install counts when you know full well React is an older project. Only fixed time period comparisons are in any way relevant, e.g. *monthly installs*. Assuming everyone needs async for HTTP is an incredibly short-sighted assumption. I seriously doubt anything is going to be "blown out of the watter" by "middleware", even if we did all use HTTP.
HIPSTERS"4"EVA!!!!!
Can I use something like this to run already built function asynchronously? 
[What the fuck am I reading](https://gitlab.com/phlint/phlint/blob/657c976b447faa2e3e37419241dc2f49bf15595b/phlint.php#L51)?
Remind me why this is a good thing?
GitLab is free and open source and it is innovating way faster than GitHub.
Hey cxcom, we don't need a framework war here. Please be civil. It's fine to opine that X is better than Y, but it's not fine here to say someone is being short-sighted or disingenuous. There's room for both projects `:-)`. Would you have time to introduce Amp in a fresh thread, for those who have not heard of it? Comparing and contrasting it to ReactPHP would be very interesting. 
No, you can't. You need a separate process or thread for that, but doing one thread / process per function call is pretty expensive. You can spawn a worker and let it handle multiple tasks, one after the other. There are libraries like [`amphp/parallel`](https://github.com/amphp/parallel) that make things easier, so you don't have to manually handle the child processes.
I don't agree with your assertion, but I'll play along. Last 30 days installs: React 212,925 vs Amp 6,815 No one is making the assumption that "everyone needs async for HTTP". I'm not sure where you go that from.
Another terrible, outdated tutorial. Not only does it use the now removed mysql_* functions, but it uses addslashes for "escaping" The method used for displaying images is not only dumb (because individual image files cannot be cached on the client side), but is limited to displaying only jpeg files. Depending on limits, you'll also likely run into memory issues using this method, because all the image files displayed are loaded into the script memory at the same time. There's no checking of file contents (mime type) to confirm the files are actually jpegs, which potentially results in a remote file execution vulnerability.
You can compare the relative numbers as well, Amp's is much lower. But there's no need for a fight. All ReactPHP libraries are compatible with Amp, you can easily combine libraries from both projects in a single app. ReactPHP is mostly callback based, while Amp tries to avoid them. They use different approaches, which is completely valid. Both have up- and downsides.
My main concern would be memory management, I know it improved vastly since 5 but I'm still very skeptical
Never, at any time, was I not being civil. Now I'm not being civil: please keep your nonsense to yourself. 
Can you please explain some other tutorial to do the same. Hope you will help me
All files need Refactoring. If they don't, you built Stonehenge in code. 
I seem to have offended you - allow me to reassure you that this was not my intention. Nevertheless, my advice stands. I shall allow you the last word, if you wish for it. 
Ah, thanks for the pointer. I will keep an eye on that! I'm arranging my system modules in Docker containers, so if it does get out of hand, I can do a seamless restart of the affected service. 
Changelog: https://github.com/php/php-src/blob/php-7.2.0RC2/NEWS Upgrade notes: https://github.com/php/php-src/blob/php-7.2.0RC2/UPGRADING
Exactly! I don't know why I'm modded down...
Most people who use Eloquent don't care about having such strict getters and setters. It doesn't mean you're wrong, just that maybe you picked the wrong tool based on your preferences. Maybe Doctrine would fit your team's philosophy better. But... you didn't pick Doctrine, you picked Eloquent and we have to deal with it, right? So I guess it won't hurt to customize Eloquent to your needs, and add more strict getters/setters, I'd just have a conversation with your team about the pros/cons, and make sure everyone is on the same boat. It would be bad if other team members start complaining that it's not working exactly like Eloquent anymore. The pros: * decoupling, testing, stricter types I can list a few cons: * You need to write it yourself. You lose all the benefits of using popular open source libraries. * You can't point to Eloquent's documentation to new team members, the original documentation might help sometimes, but sometimes it won't * Bugs, custom code might have more bugs than widely used and tested libraries * Your custom ORM will need more boilerplate code and it will take more time to write queries Besides all the technical stuff, I think you should also consider whether your business needs to deliver things faster with less programming hours (Eloquent) or deliver better tested software even tho it will consume much more time (custom ORM built upon Eloquent). Good luck! 
They don't all have the same priority though.
&gt; Id assume those people over there know what they are doing for the most part. LOL
&gt; I don't see that as something developers really need. Senior Devs do not.... Junior and intermediate devs... do. Laravel enables Junior/Intermediate Devs to be a lead on a project b/c there are literally no choices to make... you use laravel done. 
I ran background tasks for days/weeks with no memory leaks in 5. The only problem is PDO sucks because it won't close connections, it only closes when the script ends. So we ran out of connections and had to hard code mssql_* commands. Err, maybe we went with ZF3 DB adapter that didn't use PDO? I don't remember, but memory was not a concern at all.
&gt; Intelligent and experienced people do make bad decisions at times though. Obviously. If you took my comments as giving someone a free pass then you took my comments too far.
I wouldn't say "heavy". Last year I was looking at PPM (which is like uwsgi in PHP) and they use ReactPHP but they mostly wanted to switch to AMP because some React tasks were open for like 7 months (EDIT 2 years) waiting on the most perfect master rewrite of everything to be glorious and use chunked HTTP. https://github.com/reactphp/http/pull/41 I've also wrote a driver for the loop sub-project which ended in "your testing harness cannot test drivers that are actually async so I can't write unit tests without completely rewriting everything can you please just merge this because it works" and that was left sitting for a year.
Surely a human dev can determine what needs to be refactored better than a program?
GitLab is the Lidl of open source hosting.
How does it work? What version of PHP it supports? It gave me long list of errors, e.g.: PHP Warning: PHP Startup: Unable to load dynamic library '*....../......./*extensions/no-debug-non-zts-20160303/tokenizer.so' ********* Unable to invoke undefined *...\....\DOMDocument* for the expression *new \DOMDocument()* in */opt/.... ********* Unable to invoke undefined *.....\.....\mb_strlen* for the expression *mb_strlen($title)* ********* Type declaration requires undefined __PhpParser\Node\NullableType__ *?string* in Looks like it does not support namespace or I am using it wrong? 
What is that?
I don't understand the json_encode new thing, What I understand is that starting from php 7.2 by default should be converted to array not to object, but checking 3v4l doesn't seems to be thecase https://3v4l.org/QvU2D ?
https://github.com/Sylius/Sylius/blob/master/src/Sylius/Bundle/CustomerBundle/DependencyInjection/Configuration.php Wow
Thanks for the reply! The way code inferences are done long term I am even thinking about implementing http://langserver.org/ so instead of adding additional annotations you could get the info straight in the IDE at real time. But that is a bit far away for now.
You can tell PDO to close the connection by setting its object to null.
Thanks for the question! The depth of analysis is the main difference between Phlint and other PHP analyzers in general. I think that the following example visualizes in nicely. Consider running both tools against this sample: &lt;?php function foo ($a) { return function ($b) use ($a) { return $a + $b; }; } $myFoo = foo(1); $myFoo('a'); PHPStan: $ phpstan analyze --level 7 sample.php 1/1 [============================] 100% [OK] No errors Phlint: $ phlint sample.php Importing php standard definitions ... Loading code ... Analyzing code ... Provided variable *$b* of type *string* is not compatible in the expression *$a + $b* in *sample.php:5*. Trace #1: Function *("a") use (1)* specialized for the expression *$myFoo('a')* in *sample.php:10*. Done in 1,308.96ms Maximum memory usage is 32.36MB 
And thank you for the reply. Yes, that is the place where it should be. And yes, it is incomplete and outdated. Thanks for bringing that to my attention I will look into updating that over the next couple of days. I know it's not ideal but in the meantime you can find them here: https://gitlab.com/phlint/phlint/tree/master/code/phlint/rule 
Hiya. Thanks for the feedback. PHP Warning: PHP Startup: Unable to load dynamic library '*....../......./*extensions/no-debug-non-zts-20160303/tokenizer.so' This is a PHP startup warning which happens even before the script execution starts. Unable to invoke undefined *...\....\DOMDocument* for the expression *new \DOMDocument()* in */opt/.... Unable to invoke undefined *.....\.....\mb_strlen* for the expression *mb_strlen($title)* These two are actually here intentionally. If you look them up you will see that they are in PHP extensions that are not necessarily always enabled. So you would basically get similar errors if you would disable "dom" and "mbstring" extensions from your "php.ini". As Phlint can read the dependencies from Composer adding "ext-dom" and "ext-mbstring" to "composer.json" will let it know that your projects is using those extensions and the errors will go away. Type declaration requires undefined __PhpParser\Node\NullableType__ *?string* in This is a false-positive 🙈 
Sorry for not being clear in my earlier post. There is nothing wrong in my PHP and no extension is disabled. All these extensions are enabled by default and this project works perfectly fine from CLI/Apache - no issues there at all. "dom/mbstring/tokenizer/Xdebug/SimpleXML/libxml/etc/etc" are enabled and I never faced a problem. This is the first time that I have seen a problem with extensions.
Yes, but only if I may ask why it's ok for a language to be so deficient in certain aspects that you have to rely on an IDE for you to work comfortably with it.
They can't fix them in core, because they would break every PHP library and website in existence. As for what matters, if people don't immediately drop their work to go work on some random loser's repo doesn't mean that the idea behind it or the project itself don't matter. People didn't believe in computers, didn't believe in software being more important than hardware, didn't believe in object-oriented programming, didn't believe in Bitcoin, didn't believe in electric cars, etc. etc.
Oh sorry I didn't mean it like that. So if you are saying that when you run, for example, "php -v" from command line you don't get that warning then there is one more thing I completely forgot about. When you run Phlint and if XDebug is enabled it tries to restart itself in PHP without XDebug (because it is so operation heavy with XDebug is just tooo slow). And the only way to do that is to disable loading of "php.ini". But then, unfortunately, on *nix systems "tokenizer" and "json" need to be loaded explicitly as they are not compiled into PHP. If you let me know what system/distribution you are using and what PHP version I can take a look at what might have good wrong. Not all those extensions are enabled by default on all systems. For example, "mbstring" is not enabled by default on windows while "dom" is not enabled by default on all *nix distributions. Basically only definitions of extension that are always loaded on all systems are always loaded in Phlint and others need to be specified as a dependency through Composer. 
Where the hell is the pipe operator
You can tell it, but it don't listen. https://gist.github.com/markkimsal/49935cc36ede1f56de3ca35f3e85f7e5 show processlist; it will hang around for 100 seconds.
You'll also have to close the statement, and unset all references to `$conn`.
In that example, if `$conn=null;$data=null;` does it behave?
¯\\\_(ツ)_/¯ 
 Hi! This is just a friendly reminder letting you know that you should type the shrug emote with three backslashes to format it correctly: Enter this - ¯\\\\\\\_(ツ)_/¯ And it appears like this - ¯\\\_(ツ)_/¯ --- *^If ^the ^formatting ^is ^broke, ^or ^you ^think ^OP ^got ^the ^shrug ^correct, ^please ^see [^this ^thread](https://www.reddit.com/r/john_yukis_bots/comments/6tr5vq/u_you_dropped_this_a_shrug_fixing_bot/)^.* ***^Commands:*** *^!ignoreme, ^!explain* 
All contributors are in Poland, so we picked a Polish name: Zubr (or actually it's spelled Żubr) means buffalo, and it's also a brand of beer and vodka (Żubròwka). EDIT: sorry, I see that you're a troll. Don't bother replying.
!explain
 ***Explanation...*** When trying to type the shoulder shrug emote, the \ makes the special character in front of it disappear. So if you typed the shoulder shrug guy with one backslash, it removes the formatting that the two underscores would do. If you typed two backslashes, then the second backslash cancels out the first backslash, making them both disappear, as well as the two underscores disappear as they make the face turn in to italics. By having three backslashes, the third backslash cancels out the second backslash, but still allows the first backslash to remove the formatting, but still appear visible. One backslash - ¯\_(ツ)_/¯ Two backslashes - ¯\\_(ツ)_/¯ Three backslashes - ¯\\\_(ツ)_/¯ --- *^If ^the ^formatting ^is ^broke, ^or ^you ^think ^OP ^got ^the ^shrug ^correct, ^please ^see [^this ^thread](https://www.reddit.com/r/john_yukis_bots/comments/6tr5vq/u_you_dropped_this_a_shrug_fixing_bot/)^.* ***^Commands:*** *^!ignoreme, ^!explain* 
Oh, you're right, bot. It _is_ a backslash...
&gt; you never get the feeling of it being fast Are you expecting your self-hosted GitLab instance on 4gb - 8gb of RAM to compare in performance to the beefy servers at GitHub? Obviously your mileage will vary and I will say when we had it running on only 4gb of RAM it was relatively slow at times, but 8gb of RAM keeps our 5 person dev team and dozens of daily builds running _fast_. 
I believe you still have to provide the JSON_OBJECT_AS_ARRAY flag See https://3v4l.org/5TUiN for the difference
I'd like some clarification on what I can do with something like ReactPHP. Our API connects to various other APIs as well as running inventory checks for our own home grown products. So say I have 2 methods I call, one is local_vendor(), the other is remote_vendor(). Using ReactPHP could I run remote_vendor() which will go out and talk to another API, then immediately call local_vendor() without waiting on the remote, then come back and merge the results from remote into my local? I've been looking at this as a way of boosting our applications performance and it would be nice if ReactPHP could accomplish this. Anyone? Also, if AMP can do this as well let me know. Thanks.
First, I didn't downvote you. Second, it's a RFC, a proposal for changes in PHP, not a PSR which is a recomendation for framework interoperability by the PHP-FIG. Third, you can pass arrays through $_GET, just do this: url/?numbers[]=1&amp;numbers[]=2. 
Perhaps I read it wrong but since php 7.2 the default behavior is to use that flag when there isn't any value as second argument or is null 
I'm not a ReactPHP user but yes, it lets you make two API requests asynchronously. But it's not a trivial task, ~~you need to change the way your application works, let it run inside the ReactPHP event loop and monitor it for memory leaks, you also need a framework/library that can understand ReactPHP requests, you can't use $_GET, and so on~~. IIRC you can use Guzzle to make asynchronous calls to two HTTP endpoints without ReactPHP, but don't expect nothing as easy as node.js promises: http://docs.guzzlephp.org/en/stable/faq.html#can-guzzle-send-asynchronous-requests
Eh my actual use-case is: - SOAP API (i.e. App\Service\SoapVendorName::getAvailability) - HTTP GET API (i.e. App\Service\GetVendorName::getAvailability) - Local Check (i.e. App\Service\LocalInventory::getAvailability) I need to split these into separate threads with promises or something. I am fuzzy on the names, but I'd like to kick off the GET API and SOAP API at the same time, do my local checks, then come back and combine all the results when I'm done. Each of these are divided into their own service and return back a common response format so we can easily merge as many of them as we need. So basically I envision this pseudo code: // async calls $AsyncLibrary-&gt;promise(App\Service\SoapVendorName::getAvailability()); $AsyncLibrary-&gt;promise(App\Service\GetVendorName::getAvailability()); // still not waiting on them $results = App\Service\LocalInventory::getAvailability(); // now waiting on async calls foreach ($AsyncLibrary-&gt;responses() as $i) { // merge into $results } return $results; I am familiar with how I could do this in Guzzle, but thats not the best solution IMO and I'll hold off until I find what I am looking for rather than a hacked together solution like that would be. Or maybe I'll move some of this into Node one day, rather just stay in PHP though.
No, the default behavior hasn't changed. `json_decode` has an `$options` parameter which can be passed a `JSON_OBJECT_AS_ARRAY` constant. This [has the same effect as setting assoc to TRUE](http://php.net/manual/en/function.json-decode.php). The difference is that PHP 7.2 no longer ignores the `JSON_OBJECT_AS_ARRAY` option when the assoc parameter is set to null.
you mean this? https://wiki.php.net/rfc/pipe-operator that'd be nice i don't think the `$$` sigil is necessary though... well, not if we had short-arrow functions anyway. then the syntax would be |&gt; $x =&gt; func(1,$x,3) and we don't need a magic var. furthermore, you could nest the pipings without conflict.
Yes. nonce's are there to combat DOS. Beyond that, it matters what the code is trying to do based on who is doing it. If everything you are doing is an admin doing it then all is fine based on your description. Any request that is verified to not be an admin will end up doing nothing.
Levi and I have talked about partial function application as a possible way of making pipeop work, though short lambdas would be reasonably brief as well. Either of those are their own hills to die on though. :/
Thanks for not down voting me. I kind of went on a 'drunken' rant there. I forgot about the arrays in URI. I haven't been actively programming in a couple years, but I see some of the PSR's that are coming out and I'm like "Why did they decide to do an awesome feature and such a strange way".
No problems, and thank you =)
[removed]
Yes, you can totally do that. You need a slight rewrite of these functions though to be non-blocking. There's an [example in `amphp/artax`](https://github.com/amphp/artax/blob/master/examples/6-parallel-requests.php) doing exactly that. You don't need to run your entire application inside the event loop, you can also use `Amp\Promise\wait()` which will run the event loop only as long as the passed promise isn't resolved yet.
More specifically can I do this: https://www.reddit.com/r/PHP/comments/701emy/eventdriven_nonblocking_io_with_php/dn0usrv/ I'm not looking to do multiple HTTP Requests at the same time, I can already do that with cURL, I'm looking to run multiple pieces of code at the same time.
It'd be good if we had static method import for the purpose of piping brevity, too, i.e... use static Math; // Imports all static methods as function names. foo(); // Calls Math::foo()
Only I/O can happen concurrently, no function calls etc, see https://www.reddit.com/r/PHP/comments/701emy/eventdriven_nonblocking_io_with_php/dmzwktc/?st=j7ll7cb7&amp;sh=5428326d.
Basically, ~~React's patent licensing has changed~~ Apache's license has changed and disallows React to be bundled with any Apache software. This is something Automattic cannot ask everyone in the Wordpress community to accept. While they are pretty sure they will never have an issue with React's license, asking all Wordpress users to also accept React's license isn't realistic. The bottom line, if someone tries to sue Facebook and they find out there are running a Wordpress website, then bye bye website. Side note, someone has already setup an issue for choosing the next Javascript framework. https://github.com/WordPress/gutenberg/issues/2733 Overall I feel bad for the team, its hard to make the right decision that will impact the software used by so many people.
Just an update on this. The generator had been throwing a warning about doctrine/dbal not being included that I had been ignoring. It's now working fine.
Are you talking about in AMP or PHP? Cause I am pretty sure its possible in the later. In PHP I'd do this with http://php.net/manual/en/pcntl.setup.php unfortunately its not designed to work with web servers, I am basically looking to do multithreading but in a web server.
5 Magnificent PHP Frameworks for Developers #1 Cake PHP Framework: #2 Laravel PHP Framework: #3 Slim PHP Frameworks: #4 Symfony Framework: #5 Codeigniter Framework: Any other framework you need to mention here?
As Amp is written in PHP, obviously both. Amp just abstracts the low level things, so you don't have to deal with them.
Gitlab is a little sluggish compared to github, but it's got great CI and github really needs some competition.
&gt; React's patent licensing has changed It has not. (Last tweaked april 2015, otherwise unchanged since oct 2014.) The issue is basically that nobody really thought about it too much. :)
Such a dumb comment :o
Uh ... your right, It wasn't Facebook that changed it was Apache. https://www.apache.org/legal/resolved.html#category-x &gt; WHICH LICENSES MAY NOT BE INCLUDED WITHIN APACHE PRODUCTS? &gt; The Facebook BSD+Patents license includes a specification of a PATENTS file that passes along risk to downstream consumers of our software imbalanced in favor of the licensor, not the licensee, thereby violating our Apache legal policy of being a universal donor. The terms of Facebook BSD+Patents license are not a subset of those found in the ALv2, and they cannot be sublicensed as ALv2.
Thank you for finding a way to formulate my thoughts for me. Learning the "rules" of your language is just part of the game.
Yep. Although it's not like their policies have *changed*, someone just brought it to their attention and they finally issued a ruling, and that made everyone start to think about it.
It looks great! Building an app using ReactPHP might be difficult to test integration-wise. As there is no way provided to control time or the event loop. I would love to see a mock coming with the framework. This could be as simple as optionally injecting a time provider in the factory and letting underlying implementations use that provider instead of core PHP's time functions (time, sleep, usleep, utime).
My brain absolutely freezes when I read stuff like that. No wonder lawyers can earn so much.
classes full of static methods are just a bad workaround for lack of function autoloading
Well, I don't know either, but I guess that's worth measuring. In essence, how many regular PHP users want to fix this? Me, I just rely on NetBean's auto-complete, and I keep meaning to try PhpStorm... `:=)` 
Have side projects. Learn how to build a whole stack, even if you do some areas non-optimally. Learn how to deploy, upgrade, maintain. Have users, have a dialogue with them, look after them. 
Would someone copy+paste this article into a comment, for the benefit of folks who are not on LinkedIn? 
Is it really comparable to Magento? I think it's a nifty platform, but not even close to Magento for now. This article agrees with me too! https://magenticians.com/sylius-v1-0-0-released/
Unfortunately, slogans like these don't resolve the conceptual problems with function autoloading. So you're very welcome to think whatever you think, but you still don't have solutions for the following issues of function autoloading: Namespaces -------------- The fate of autoloading functions was sealed in PHP 5.3 when the "fallback to global" hack was instituted to avoid having to type backslash in front of functions when you're in a namespace. Class autoloading is a simple two-step process: - Is the class with resolved absolute name "\X\Y" loaded? - No? Try to autoload it. Here's roughly what this would look with functions: - Is the function with resolved absolute name "\X\y" loaded? - No? Try "y" in the global space, is that loaded? - No? Try to autoload... but what "\X\y" or "y"? Let's say "X\y". There's already a problem up there, it's ambiguous what should be autoloaded. But that's the smaller issue, we can say "look, global functions are reserved for PHP, autoload namespaced ones only". That's kind of OK, although it adds to the confusion of PHP's awkward legacy semantics. But there's a much bigger problem hiding in plain sight in those three steps. Let's say hundreds of people have a *namespaced* function called "foo()" in hundred different namespaces. If PHP decides to introduce "foo()" in the global namespace after some point release, guess what happens? All those hundred "foo()" functions suddenly **can't be autoloaded anymore, as the global function shadows them**. This means as far as autoloading is concerned, namespacing doesn't work. Everything is global, because if there's a global one, you can't autoload the namespaced ones. Solve **that**, and then tell me static imports are a "bad workaround". File resolution --------------- PSR-0, PSR-4 and its similar spin-offs use a simple trick to map a class name to a file: namespaces = directory; class = filename. This is not ideal, because in a modern application this still can result in hundreds of files being loaded on every request. Of course, opcache comes to the rescue, but the autoload function still runs, and opcache still has to resolve a tree of pointers to provide or copy to the specific thread for every autoloaded file, plus by default opcache checks the mtime of every file it caches, to detect changes (not detecting changes is not practical for most small-to-medium sites). So bottom line is opcache *doesn't eliminate the overhead of file autoloading*, it just helps *reduce it*. So how would we resolve functions to filenames? Let's take the naive approach. One namespace, 20 functions = one directory, 20 files. If these files are in one namespace they're probably cohesive and likely to be used together, but they're *separate files regardless* which is 20 times the autoload overhead of one class with 20 static methods. Not fun at all. So maybe we do something else. We resolve "\Vendor\Library\Funcnamespace\funcname" to directory "Vendors/Library/Funcnamespace.php" instead, and we load all functions in one namespace in one go. ***Oops!*** We just reinvented static method autoloading with classes! Except we reinvented it poorly. Because while we're loading all those 20 functions from one file, it still requires 20 `use` statements to call those functions in a given file. I'll be conservative and assume we're only using 10 of those 20 functions we just loaded. How would the `use` statements look? Here's my so-called *"bad workaround"*: use static Foo\Bar\Math; Here's your supposedly *superior solution*: use function Foo\Bar\Math\one; use function Foo\Bar\Math\two; use function Foo\Bar\Math\three; use function Foo\Bar\Math\four; use function Foo\Bar\Math\five; use function Foo\Bar\Math\six; use function Foo\Bar\Math\seven; use function Foo\Bar\Math\eight; use function Foo\Bar\Math\nine; use function Foo\Bar\Math\ten; You'd say "woah, bogus, because we can group use statements in PHP 7 now!". I haven't seen a *single IDE* do that. So: - If you rely on an IDE - it'd look like the above. - If you don't want to rely on an IDE... ...then instead of typing this manually: use static Foo\Bar\Math; ...you're looking at typing all this manually: use function Foo\Bar\Math\{one, two, three, four, five, six, seven, eight, nine, ten}; Yeah doesn't look like fun either way. What's the benefit of functions again? ------------------------------------------ I'd like to hear you argue how functions are better in any way compared to static methods, if we'd be able to call them by the same short name. Static methods are a *perfect superset* of functions. They **are** functions, but with these additional benefits: - You can inherit methods from a parent class, or quickly assemble related static methods from different traits in one class. Traits even allow renaming the methods if you want. With plain functions this would require manual delegation which is slower to type, and slower to run, i.e. : `function foo($a, &amp;$b, $c = null) { return bar($a, $b, $c); }`. - You can have non-public static methods for sharing common internal reusable logic across methods, without exposing it to your users. - You can have static methods share non-public state, without exposing it to your users (which can be used for "evil", but also can be very practical and useful, for ex. look-up tables, memoization etc.). So, now I want to hear your list of benefits for functions over static methods. I hope it amounts to more than more sloganeering like "when you want a function use a function".
Good stuff, as usual.
Who wants to bet they go with Vue?
I take PHP *super* seriously. [This is the face I make](https://static.tumblr.com/ea55f4a090674049cb7bfb1319dacd5c/ov0cvvk/sV1mwrspc/tumblr_static_capaldi_s_furrowed_eyebrows.jpg) when I think about PHP.
Php Inspections (EA Extended) is a Static Code Analysis tool for PhpStorm and Idea Ultimate. * Rules list: https://github.com/kalessil/phpinspectionsea/blob/master/RULES.md * Getting started: https://github.com/kalessil/phpinspectionsea/blob/master/docs/getting-started.md * Showcases: https://github.com/search?l=PHP&amp;o=desc&amp;q=php+inspections+%28ea+extended%29&amp;s=created&amp;type=Issues&amp;utf8=%E2%9C%93 
[removed]
You might find this channel helpful: https://www.youtube.com/user/ljfrench009
Do you have to poop? You look like you have to poop.
Please explain why anyone should give a shit.
That, too, is something to take seriously.
Patents Clause. Like Santa Clause, but it can steal your silverware; and should you complain that gift you got last year will turn to coal.
I appreciate you posting this, but I don't really share the sentiments of the author. &gt; We started with the apparent paradox that PHP is a really bad language Yeah, well, I'd say that's a bad place to start. And to be technically correct, the article started by saying "Most programmers who have only casually used PHP know ... that it is a bad language". Also, really puts me off the rest of the article.
What's the point of hack? It's totting typehinting and return types but those were recently included in PHP
&gt; PHP originally stood for “Personal Home Page.” What happened to PHP Hypertext Preprocessor?
It's like the author never heard of the `===` operator. 
There are _many_ other bits to Hack. Off the top of my head; more core data types and core async libraries are two big differences.
I don't get the attraction of HHVM these days now that you have the language and speed improvements that came with PHP 7. I also don't see how HHVM can be called "more economic" given how much memory it consumes. If you want a fast, type-checked language for web development that uses a lot of memory, why not just use Java?
There was literally a link to it in the article: http://php.net/manual/en/history.php.php **tl;dr**: &gt; It was renamed simply 'PHP', with the meaning becoming a recursive acronym - PHP: Hypertext Preprocessor.
&gt; https://magenticians.com/sylius-v1-0-0-released/ A Magento blog might be a little biased.
Correct. The author is living in the past. Hack is dead and open source projects are dropping support for it accordingly.
Must be from c#
PHPoop
I've been tasked with creating a system to merge a bunch of data from different sources and find connections and correlations. I did a quick and dirty version of it in less than a day in PHP, but the "real developers" want it to be in their craptastic collection of various programming languages, frameworks, and databases. It took two days to get the data layer running locally, and when we went to get the business logic and view layers running it was discovered that the instructions were out of date and it can't actually run. If I had just used a language that ran on a server that I could then copy to another server and run I'd probably be done by now. It's been two weeks and I'm still not in a place where I can write code. But I'm paid by the hour so they can waste as much of my time/their money as they want.
&gt; Only I/O can happen concurrently, no function calls etc It doesn't mean you can't benefit from this, if it's the IO that's slowing you down, just requesting the three IO operations asynchronously will save you some time, even if the response will be processed serially after received. You said you're using SOAP, i'm curious about how hard it is to make a non-blocking SOAP request, i guess it is hard
It has generics. Still a pretty big missing feature in PHP.
The author is the guy who wrote HipHop VM. Pretty sure he knows... https://www.linkedin.com/in/keith-adams-1b45185/
We'll under the hood SOAP gets sent over HTTP/HTTPS, there is probably a way to hack a solution together where I could use Guzzle promises to send it, but then I'd lose out on the benefits of PHPs native SOAP library. I may have misread /u/kelunik. Are we talking Network I/O or Disk I/O?
Thanks so much for the update :) Highly recommend this plug-in for PHPStorm! Unrelated to the update, but today I noticed the `gettype` rule on an old code base I'm modernizing, maybe I create something for it on php cs fixer ;)
He was pretty clear in the article about why they don't "just use java". The bulk of the article explained that pretty clearly actually. Developing with PHP is faster.
Network I/O, Disk I/O is mostly sync and only implemented asynchronously via threads.
I rely on autocomplete, too, but that's crazy. Only with PHP I always have to double-check the argument order (or use autocomplete). I started this thing because of a comment on Hacker News, it's probably more of an experiment that an actually library that one uses, but honestly I will use it because it's namespaced—so it won't affect other components, and I have a strong desire to get shit done as quickly as possible, and PHP's inconsistencies slow me down a lot. 
Why would I want to explain anything to you? You're a troll, you just opened this account and you're already at -13 comment karma. Unless you're 12 (which might be), come back to me when you want to talk like a normal person and you stopped leaving retarded comments all over Reddit just because accounts can be anonymous.
Thank you /u/space_possum =) Go ahead, I think porting the rule to cs fixer is totally making sense.
The author does not live in the past. The article is from October 2016 - almost a year ago.
I'd like to know this too. We're on a major crossroads from moving on from Magento 1.9.
What about it?
&gt; CR and LF characters then your PHP contact form is open for abuse No it is not. This is the equivalent of escaping html before inserting data into the database. Use a proper mail library (like a normal person) and you won't have the problem at all. Or if you are so inclined to not use a mail library (again you really should) escape / sanitize data based on the context at the last possible moment before using it. There may be other valid reason for stripping CR/LF characters, but if it is to prevent header injection you are sending mails wrong. 
People shouldn't evaluate the usefulness of technology by their own merit but by the merit of their coworkers/partners/friends, whoever you are doing projects with. You for example may know `===` (and the other variants), the auther may know it, I may know it. But we all may have coworkers that do not know. Or we all may forget use it every now and then. This cannot happen in a strongly typed language, where you'd have to implement equality comparison between two types yourself.
Perfect name for a package/library!
Another bullshit article about bullshit that convinces me of nothing.
well this article is about a year old. [Was discussed here 11 months ago](https://www.reddit.com/r/PHP/comments/57blxo/taking_php_seriously/) so maybe that's why it's coming across as old. Maybe they have dropped Hack by now
I've always thought of you as a curmudgeonly Peter Capaldi type, more Malcolm Tucker than The Doctor, though.
`use PHP\oop;` New whoops package.
"Today, in 2016 ..." 
Cannot wait for that feature to come to us.
&gt; The fate of autoloading functions was sealed in PHP 5.3 when the "fallback to global" hack was instituted to avoid having to type backslash in front of functions when you're in a namespace. Nope. I used to think this, but so long as 1) there's no autoloading in the root namespace and 2) functions in a given namespace are in the same file, it's fine. &gt; Except we reinvented it poorly. Because while we're loading all those 20 functions from one file, it still requires 20 use statements to call those functions in a given file. Nope: use ajf\foo\bar as fb; fb\a(); fb\b(); &gt; I'd like to hear you argue how functions are better in any way compared to static methods, if we'd be able to call them by the same short name. `\` is shorter than `::`. But more importantly, “static methods” are a tenuous concept as-is without abusing them to make function libraries where the functions really are not related to eachother. &gt; They are functions, but with these additional benefits: &gt; * You can inherit methods from a parent class, Static method inheritance is a bug, not a feature, and I'd challenge you to present an actual use for it. If I could I'd remove it, but as-is I'm probably going to try to add a mechanism to let you turn it off on a per-member basis. It's a huge pain. &gt; You can have non-public static methods for sharing common internal reusable logic across methods, without exposing it to your users Yep. We ought to have modules, but unfortunately don't right now.
Hack supports [async](https://docs.hhvm.com/hack/async/introduction), which seems pretty cool although it has quite some limitations.
more like "WordPress 4.8.1 password reset feature lets you set the 'From:' address when an admin email address and server name haven't been explicitly configured". they claim this is a vulnerability because you could create an account, kill the email address for that account, then hammer the password reset which will bounce an email back to wordpress@server-you-want-to-flood.com. i can't imagine how rate-limiting or filters aren't already mitigating this. the "stealing an account" part is a long shot that someone would respond to the email rather than clicking on the link.
Incidentally, here's an ultra-basic implementation of pipeop using Levi's simplified (no $$ token) version: https://gist.github.com/sgolemon/2b08b14d08861d1329d3529599f75022 Usage: $a = "hello" |&gt; 'strtoupper' |&gt; function($x) { return $x . " world"; }; // $a === "HELLO world"; Basically, RHS of the |&gt; is any callable expression which gets one arg from the LHS.
They forgot the part where you can (and probably should) use a `finally` block to cleanup resources in a generator. But otherwise I like this article, and I love generators.
&gt; Nope. I used to think this, but so long as 1) there's no autoloading in the root namespace and 2) functions in a given namespace are in the same file, it's fine. You didn't address the problem that I said is the ***biggest*** issue of them all - namely PHP introducing function "foo()" in the global space blocks any namespaced "foo()" from loading. Which would make function autoloading very fragile and unreliable. What would have happened if I had my own autoloaded "\Foo\Bar\password_hash()" when PHP introduced "\password_hash()"? It would cease autoloading and PHP would incorrectly (from my PoV) resolve to the global one. This can't simply be hand-waved away. It has to be addressed. &gt; Nope: &gt; use ajf\foo\bar as fb; We can already do that with static methods. If it was optimal, I wouldn't be talking about static imports. &gt; &gt; I'd like to hear you argue how functions are better in any way compared to static methods, if we'd be able to call them by the same short name. &gt; \ is shorter than :: You can't be serious... Also with static imports there's neither "\" nor "::", so it doesn't even apply. &gt; But more importantly, “static methods” are a tenuous concept as-is ... I'm afraid there's no substance in that statement. Name any practical problem with static methods. I named very specific practical benefits like encapsulation, reuse and aliasing. "I need to share internal logic between two functions" is a clearly defined real-world problem, that static methods provide a tangible solution for. "Static methods are a tenuous concept" is not a definition of an actual problem. &gt; ... without abusing them to make function libraries where the functions really are not related to eachother. So, you'd go for one function per file? Good, now you also have an autoloading/IO performance issue on your hands to resolve, that I clearly defined in my previous post, and you didn't address. You didn't address the biggest issues I mentioned. &gt; Static method inheritance is a bug, not a feature... So. More slogans... &gt; &gt; You can have non-public static methods for sharing common internal reusable logic across methods, without exposing it to your users &gt; Yep. We ought to have modules, but unfortunately don't right now. We do have modules with functions right now, they're just called "classes with static methods". Yes, a class fulfills two nearly independent roles. That's fine if you don't get stuck on how things are *named* and focus on their *function* and *role* in a project. If I take a step back, everything you want we already have, but you just want to reimplement once more so that it's not called "classes". You're welcome to go for it, if you feel it's important to have function modules implemented twice. I just mentioned static import as it would introduce a genuinely new capability in PHP, given we'd **never** have properly working function autoloading.
I'm fine with that. House M.D. also works.
&gt;You didn't address the problem that I said is the biggest issue of them all - namely PHP introducing function "foo()" in the global space blocks any namespaced "foo()" from loading. Which would make function autoloading very fragile and unreliable. I actually did address this implicitly, but maybe I should spell it out: Namespaced functions shadow root-namespace functions, not the other way around. And so, so long as every function in a given namespace is in the same file, there's no problem. &gt; What would have happened if I had my own autoloaded "\Foo\Bar\password_hash()" when PHP introduced "\password_hash()"? It would cease autoloading and PHP would incorrectly (from my PoV) resolve to the global one. Only if you're using a one-function-per-file paradigm. Why would you do that? &gt; We can already do that with static methods. I know. &gt; Also with static imports there's neither "\" nor "::" Yes, but I thought you said you didn't want to import everything individually. &gt; I'm afraid there's no substance in that statement. Name any practical problem with static methods. Static methods are global functions associated to a particular class, not methods on an object. This means they don't obey LSP because classes aren't objects. Yet they're inherited. This is annoying for all sorts of use cases. The big one is static methods used as constructors are forced to be “compatible” with the methods they “override”, and they inherit them so now your subclasses have a bunch of useless methods for creating instances of their *parents*. ¯\\\_(ツ)_/¯ &gt; So, you'd go for one function per file? No. &gt; We do have modules with functions right now, they're just called "classes with static methods". Get back to me when we have private classes.
 Hi! This is just a friendly reminder letting you know that you should type the shrug emote with three backslashes to format it correctly: Enter this - ¯\\\\\\\_(ツ)_/¯ And it appears like this - ¯\\\_(ツ)_/¯ --- *^If ^the ^formatting ^is ^broke, ^or ^you ^think ^OP ^got ^the ^shrug ^correct, ^please ^see [^this ^thread](https://www.reddit.com/r/john_yukis_bots/comments/6tr5vq/u_you_dropped_this_a_shrug_fixing_bot/)^.* ***^Commands:*** *^!ignoreme, ^!explain* 
!ignoreme
 Okay I have added you to my ignore list. This is the last comment I will ever reply to you. If you wish to be removed from the ignore list in the future, please PM my owner, whose profile can be found in the footer below. --- *^I ^am ^a ^bot. ^My ^owner ^is ^[John_Yuki](https://www.reddit.com/user/John_Yuki/).* 
This article was posted almost one year ago... whats your pointing posting it now? 
I find the "swapping search backends" example fairly naive, like many other examples given when people are first exploring these concepts. Presumably if you're switching search back ends, you are switching for some particular reason. Perhaps the new engine has some extras options and powerful features you want to take advantage of in certain parts of your application. Those new options now need to be exposed through your adapter interface so your application can use them in some cases and not use them in others. So your abstraction is already leaky in that sense. The "just drop in a new adapter" line, while I've heard it repeated for about 10 years now, has always been more of a blog talking point than something that frequently occurs when building actual business applications.
&gt; I actually did address this implicitly, but maybe I should spell it out: Namespaced functions shadow root-namespace functions, not the other way around. And so, so long as every function in a given namespace is in the same file, there's no problem. Do you even realize how much "WTF" is present in this "solution" of yours? Let me spell it out back at ya. So if I define a file with functions in namespace "Vendor\MyProject" and I decide to use them from another file (say defining a class) that's also in namespace "Vendor\MyProject" .... I can't. Not a valid use case, just mysteriously ceases to work on global function name collisions, and screw PHP users. You're effectively placing the following restrictions on function autoloading: *"If a namespace contains even one function, then that namespace can only be declared in* ***one file***. *I.e. everything that can be in that namespace should be in that one file, because it contains a function."* Do you know what this sounds like? A class with static methods. Except ***unlike*** a class, the rule here is completely unclear and implicit. While the fact you can't split a class in multiple files is quite apparent from the syntax and PHP runtime behavior itself. &gt; Only if you're using a one-function-per-file paradigm. Why would you do that? Are you the same guy who said ***this***: &gt; “static methods” are a tenuous concept as-is without abusing them to make function libraries **where the functions really are not related to eachother** [sic] So let me try and hold those two thoughts of yours at once in my head: 1. Why would I put functions in a namespace in multiple files? Silly LtAramaki! Of course I'd put them in one file! 2. Why would static methods be grouped by class in one file? Silly LtAramaki! Of course I'd rather split them in multiple files! ***Ughhhh....*** I can't do it. I don't know how you do it. Your thought process is a mystery. &gt; &gt; Also with static imports there's neither "\" nor "::" &gt; Yes, but I thought you said you didn't want to import everything individually. Yes, that's how static imports work, in particular the wildcard import from my very first example. You import the class, and then you type the method directly, there's neither "\" nor "::". If you don't even understand ***that*** about static imports, then the fact you feel like you can pass judgment on it becomes even more bizarre. &gt; Static methods are global functions associated to a particular class, not methods on an object. This means they don't obey LSP because classes aren't objects. Yes they aren't objects, so they don't have to obey LSP. So don't talk about LSP. Functions in namespaces don't follow LSP, and static methods in classes also don't have to follow LSP (PHP tries to, isn't useful, isn't harmful, just is). &gt; The big one is static methods used as constructors are forced to be “compatible” with the methods they “override”, and they inherit them so now your subclasses have a bunch of useless methods for creating instances of their parents. Then either use `static` or don't put the factory methods on the damn class. Jeez, that was simple? Also it has nothing to do with the use-case of using static methods in place of functions, so can we focus a little and spare me your life's story? &gt; Get back to me when we have private classes. A method has visibility *today*. Functions don't. Would I like class visibility? Sure! Is it relevant to what we're talking about? No! Just yet another unrelated remark courtesy of /u/the_alias_of_andrea.
PHP is still the fastest language for deving or prototyping most backend services with. TBH it is unfairly maginalized. I flows easily between paradigms like functional and OOP and that really irritates some purists. 
You're downvoted. Just wanted to leave a comment to let you know how much I enjoyed this. God bless
Will php ever have a magic method `__toArray` ? Which is triggered by typecasting `$blah = (array) $object;` Then you could serialize your array the way you want to? Would be a pretty cool feature in say PHP 7.3.
Hack is still powering one of the [largest websites in the world](https://www.facebook.com). While open-source adoption may not be high, the language is anything but dead.
Do you do anything besides spamming YouTube videos and throwing insults at people?
How can I set `apcu` value for my website from cli? Edit: I'm using mod_php.
The post is a year old, nobody would use HHVM today. Libraries left and right are ripping out legacy HHVM support.
Ah, another 'other people hate php / framework x and I couldn't care less' post. Beating the dead horse very well indeed.
"There are only two kinds of languages: the ones people complain about and the ones nobody uses"
So does python, that's not why PHP has its reputation.
But... but... PHP is bad because it just is. You have to use a dollar sign to signify variables! That means it's bad!
Wait a minute. Its 2017 and SugarCRM appears to NOT be using binded parameters? If I am reading that right, I stopped reading. The best part about this is, as of this writing, the post above this on /r/php is titled "Taking PHP Seriously" :ffs: Not a PHP basher here, just a concerned PHP developer.
To clarify, are you wanting to write this yourself for educational purposes or do you just need it done? If you just need it done you might look to a framework.
For both, but mainly wanting to get it done. Do you have any recommendations for specific frameworks for me to learn and approximate length it might take? I don't need to do anything complex, just would like users to create their own accounts and associate data with the user account. I think that is pretty simple! Thanks for your help
That's kinda the beauty of using a framework. That functionality has been written over and over, so why spend time on it when you can focus on what your app is intended to do? I'm partial to Laravel because of the community and resources available. Check out Laracasts. There's a free series that'll get you up and running with the basics (routing, models, controllers, relationships, etc.). The docs are great too.
&gt; but what else you can return if even "0" is a successfull result? nit; You could do like Javascript and return -1
Thanks, I was also going to suggest Laravel. I'll be looking more into it then. Cheers!
This is not PHP's fault it's the developers who won't learn until it's too late. 
A quick read to address https://github.com/laravel/internals/issues/11 TL;DR; You can sortBy() on multiple fields in collections if you list them in reverse order. The post explains why. I generally keep my Laravel stuff in https://www.reddit.com/r/laravel but I think this is a decent beginner level programming example, so putting it out here as well. If you can bubble sort, you can skip this ;-) 
Shouldn't take you more than a half-hour. Use Laravel or Symfony and save yourself a monotonous headache.
Wow, this makes it seem pretty easy - here's hoping I can do it in a few multiples of that only! (I've never used MySQL and PHP together, or did much web back-end stuff!) Thanks for your help
&gt; Apache's license has changed The Apache licenses haven't changed, the ASF however decided that projects under its control could not use React, other open source projects that use the Apache license are still OK to use React.
Symfony with FOSUserBundle 🎉
I think PHP should replace all request related superglobals ($_GET, $_POST, etc.) with an object implementing PSR 7 Request Interface. Why? After so many years working Symfony request objects it feels so natural and right it should be the norm.
I can't follow this at all. It talks about a function called securexss, it describes escaping HTML, then shows it being used to escape SQL queries. Did I read that right?
That's not at all why PHP has a bad rep lol
There's also the part where it's a poorly specced mess of a collection of libraries :P PhP 7 has improved it a little however.
1 year is not long at all in the world of programming languages
Pythons OOP is laughable at best.
&gt; Pythons OOP is laughable at best. It's quite clear from your previous comments that you know nothing about it, so maybe just ease up a bit on the off-topic, inflammatory opining.
Tkx man :)
Yes, I may not have much experience with it, but I have read the official documentation. Which means I have no idea how the dev experience fares, and I never claimed that. But I know in detail how OOP has been implemented in many languages including Python, and my opinion stands. Python has packages, similar to Perl, that have some notions from OOP, but not in any depth. If you have worked with Java/C++, you must be very aware of that fact as well. If you want to prove me wrong, please state some facts about the topic, do not attack my credibility. If you do not, then just ignore me and we will have both a better day.
Tkx for your comment. :) Yes, the example is naive, but I don't think we need use a very complex example to explain the idea behind Ports &amp; Adapters. Nevertheless, it is true that building a well abstracted interface is not always easy, but that's a challenge we have as developers. If software development was easy, everybody would do it and we would always end up with great software. 😬 For this pattern to be well implemented it is essential that we build interfaces that are well abstracted from the tool and adapter implementation, while adjusted to our application needs. Without this, we would lose the main purpose of this pattern. From my experience with large business applications, when the interface is well designed and there is no extra functionality being added (maybe we are replacing tools just because of performance, patents or such), we can indeed "just drop in a new adapter". If there is new functionality being added, then it can happen that we aren't even changing tools, we just need some extra functionality that we didn't need before and therefore did not implement in the interface nor the adapter. Either way, this need comes from within our application, not from the external tool, so we would always need to make changes in our application. This pattern just makes it easier. Furthermore, in my experience, if the interface is well designed we can, most of the times, add this new functionality without breaking backwards compatibility of the interface. This means that we can add new functionality and change our application code only where we need that new functionality, by adding arguments to method calls or replacing method calls. In the end, using this pattern doesn't mean all our challenges are going to magically disappear, but it will definitely help a lot. I think I will update my post to reflect these thoughts! Again, thanks a lot for your comments. I really appreciate it. :)
I don't agree with much in that article. The syntax of PHP is quite imperfect but the the author mentions Ruby, Erlang and Haskell as possible replacements. Ruby looks even more old-fashioned than PHP, Erlang is a functional programming language which may appeal to mathematicians but not web developers and Haskell seems like a language that requires a PhD in computer science.
&gt; Most programmers who have only casually used PHP know ... that it is a bad language The problem has got a lot to do with the fact the PHP continues to be treated as an entry level programming language. When I was at college, they introduced us to PHP in the way of entry level platforms like Wordpress and simple server side scripting with includes and regular expression and little or no design or architecture. When we were ready to learn about enterprise level web development they switched over to Ruby with Rails and Java. That promotes the idea that PHP is for hacking stuff together with wordpress plugins and proper software demands a more sophisticated language. In work we get graduate developers who come to us having done modules in enterprise software development, object oriented programming, design patterns, data structures, algorithms etc. but it doesn't occur to them that they can apply those skills to a PHP project. They think PHP is for doing the sort of stuff they learned about in first year.
I'm not sure this is correct. The sorting functions do not guarantee that items with the same value are returned in a particular order. In other words if you have Taylor,Otwell &amp; Jeff,Otwell then sorting by first name puts Jeff first, but then sorting by last name doesn't guarantee Jeff will still be first. They both have the same last name so could be returned in either order.
Make sure to introduce yourself to Cal Evans if you haven't met him before. 
Depends on your exact vision - different people put different meaning into this (as evidenced by being in the Sylius Slack for almost a year now and being one of the most active people there). Short answer - yes, there is multi-channel feature. Long answer - depends, you really have to come into the slack and ask specific questions. And don't expect building a project on Sylius being a "fast and cheap" affair - it's not meant for that type of projects. It's for the marathon type projects that need to live and evolve for years and maybe into the decades. And use 1.0.0 only, do not use anything before that. Also, PHP 7.1+ **ONLY**
The thing is, Sylius is not really a ready shop, it's a framework. In essence that means it should be use by developers only to build a customer-specific solution. It's mean to be extended and overridden from the default functionality. And oh boy, when you start to get the internals and how things coupled and work (admittedly, took me bigger part of the year to get there, but I also went through the alpha, beta and RC stages with the project and added quite a few very sizeable contributions myself) - things start to move at orbital speeds. It is never going to be a direct competitor to platforms that you can just install, drop in a theme and start just using. But it's a blessing for a Symfony savvy developers (or in my case, I basically entered Symfony on a serious basis with Sylius).
What is it with these inline fully-qualified class paths when we have 'use'? I've seen a lot of this in the Magento codebase. It's insane.
&gt; I made up the term ‘MPDPL.’ Making up a fancy-sounding word for programming languages you happen to like and describing it as a “paradigm” is… strange.
IMHO `===` is not a complete solution to the equality problem. It's 90% of the way there, but for example, `1.0 !== 1`, and it doesn't fix `&lt;` or `&gt;`. Luckily PHP 7's type declarations make the former less of an issue.
I'm an experienced C# developer and I like its static type system and the syntax, but I consider Python the nicest scripting language I've ever worked with, far superior to PHP (the strong typing alone was reason enough for me to dump PHP for most projects) and still able to get the job done fast. It doesn't need PHP's or Java's verbosity, it just works by convention. In general, everything just works. Compared to Python PHP's abstractions are laughable, it does too many things too C-like. I've really never experienced as many "Wow, that really just works" moments as with Python. Don't get me wrong, adapting more and more Java concepts is definitely an improvement to PHP compared to its old state, but that doesn't mean other languages not doing (and not having to do) this are laughable/inferior. The only thing I miss about PHP is its easy deployment. Install, upload, run, that's it. You don't get that with Python, unfortunately. 
I believe try and catch should be part-and-parcel of anyone starting out with PHP... Yet, so little use it...
Completely agree. I do not understand why it is so overlooked 
PHP is great. It's probably the language I have the most experience with and have used in production. That being said, don't be a PHP developer, be a developer. Know the strengths and weaknesses of the language. Know when to use it and when not to. Processing large pipelines of data and easily creating scalable queues and workers is not one of PHP's strengths. Even with Slack, yes there are parts that are PHP, but most likely not the parts where timing and milliseconds matters. The socket connections they use aren't PHP, most of the backend probably isn't. Figure out where PHP fits into your application and use it there. But also be aware of other languages and techniques that will help your project be the best it can.
Where's the confusion? Calling the function twice will obviously overwrite the first `sortBy()` call. If you want to retrieve DB rows in using a multi oder-by, use the [query builder's orderBy](https://laravel.com/docs/5.5/queries#ordering-grouping-limit-and-offset) to let the db layer handle it: DB::table('something') -&gt;orderBy('name', 'desc')
I see lots of potential issues with your approach. It would work ok with returning HTML view but it would broke any API JsonResponse. Also, you should check https://github.com/barryvdh/laravel-debugbar which does that out of the box. 
Wow, it looks like he's done a lot with PHP. I'll definitely give his talk a listen!
What comes next will shock you.
Because outputting the error messages to the browser is one of the easiest ways for newbies to see the error. What would be great would be an exception class that output *that* an error occurred and logged it and a stack trace to an HTML file that we could look at. 
Good point. As long as you don't use HHVM, you can do that: https://3v4l.org/apsDZ
Make your code better with this one simple trick! 
It's not my experience that people don't use it (or use it very little). I guess it depends on the crowd you're around, and the libraries you favor.
That bundle is only useful if you don't want to customize anything, so it's pretty much useless
Says a lot for the crowd I hang out with, then... 😁
the main issue I have with PHP is the millions of dated articles on working with PHP. So a lot of new users end up using dangerous MySQL connection strings, or fail to sanitize input. However that is easily remedied. 
Is this a advert for Udemy courses?
Quite contrary, it is used much more often than it should be. Noobs like the OP are writing stupid useless handlers which are doing more harm than good. Basically you never need a try catch to report an error. And the OP is doing exactly this. 
I guess there are a lot of pre PHP 5 developers who are accustomed to if/else and a lot of developers are obsessed with speed and have the idea that exceptions slows down the execution of their code.
Exception handling is big and clunky where you are using PHP in a stateless context, such as when you are serving a web page. Too many frameworks rely on a structure of exception handling that result in cryptic or nonexistent error messages on the client side for issues that really should be handled by the controller logic. Failed validation, for example, is not something that should result in a chain of exceptions producing the output.
&gt; Because outputting the error messages to the browser is one of the easiest ways for newbies to see the error. Plot twist: the video is telling you to do exactly that.
While try and catch is indeed a great operator, your particular example is terrible, exceptions should never be handled like this. 
To be fair mysql_ was removed in PHP7(that everyone should be using by now). My main problem with PHP is just that it generally feels poorly designed(Multiple methods that do the same thing but "differently" and such). When you know how to work with PHP it's alright though; you get things done with it.
Here we can observe the usual awful example of Exception handling, an extremely common case among newbie deverlopers. The main problem here is that the OP **clearly have no idea what to do with Exception they caught**. Honestly, I hope nobody consider that stupid error message spat right to the browser's screen to be the *real* use case. But... what else? The OP have no idea. And I'll tell you why. One needs the great try..catch operator here just like a fish needs a bicycle. Try catch can be used if it may alter the script execution course. But if we don't have the data that needs to be processed, we don't have much alternatives whatsoever. All we can do here is to end the script execution. And we don't need no try and catch to do that. The good use case for the try and catch operator is when one can *handle* the error. Means to overcome, to mitigate it. To find a way around. For the imaginary case from the video it *could* be setting some default values instead of those to be gotten from CSV. Such a case could have been a good example for the try catch, if applicable. 
To be honest, most of time try and catch is simply misused, only to bluntly output the error message. Just like the OP did in their video.
1. Blogspam 2. Affiliate links 3. All links point to udemy That's a bingo
Got an example? I've never seen a framework that is showing a cryptic or a nonexistent error message for a site visitor. Only a generic error page with apologies, just like it should be. 
Looks like somebody needs a shadow ban. 
That's fine, if only you were to work on your project. I would guess that unless you can reach a critical mass with this library, you would slow other developers down by having chosen to use it. And, if your idea was to gain steam, it would apply sufficient upward pressure for PHP devs to fix naming/ordering in the core, again rendering fix libraries of this kind redundant. That all said, whilst I would not use this for the reasons stated, I like that you're putting this out there. It is much more productive than some of the negativity PHP gets, which is only for the purposes of writing it off as beyond saving. 
&gt; That's fine, if only you were to work on your project. Mh? Don't understand. &gt; unless you can reach a critical mass with this library, you would slow other developers down by having chosen to use it Why? Sorry, I don't get it. &gt; And, if your idea was to gain steam, it would apply sufficient upward pressure for PHP devs to fix naming/ordering in the core, again rendering fix libraries of this kind redundant. They'll never do it, luckily for everyone. All existing code would break overnight. &gt; It is much more productive than some of the negativity PHP gets, which is only for the purposes of writing it off as beyond saving. Meh, fuck them. PHP is totally fine and I'm productive with it, I don't get if it's trendy or whatever, as long as I can get my work done. Having said that, if something can improve my (and possibly other's) productivity even 5%, it's worth a try.
Sent you a private message with system details. Removing xdebug did away the extension loading error but did not fix other problems.
I'll be there as well. This will be my sixth ZendCon. I'm looking forward to the lineup of speakers and sessions they've put together this year.
I'll make this my last answer, since I think "fuck them" is not in keeping with the professionalism this community needs. I understand it's not easy to receive critical feedback on your projects, but everyone receives it! I hope that my replies are taken in the constructive manner in which they are intended. My first point was that if you work on a project solo, you can do what you like, and you can specify what libraries you like. However, if you wish for other people to work on your project (whether it is closed/commercial or open source) then library/style decisions become harder, because you have to (should!) take other people's opinions into account. Given that most people will just stick with the PHP functions, they will either have to adopt your functions at a productivity cost to them, or you use the ones they prefer, at a (perceived) productivity cost to you. 
Now imagine that your generic error page gets returned as part of an AJAX request. The user doesn't see the error, but the spinner keeps spinning. The user refreshes the page and maybe everything loads the next time, but the user doesn't have any information to help diagnose the issue. So you decide AJAX responses need their own custom exception handling, and you fight with the framework and the configuration to get what you want, quite possibly you break the abstraction to get it to work. Anyway, my point is that errors should be handled at the controller level, not by exceptions that exist in a wholly different scope.
&gt; but the spinner keeps spinning. Come on, it simply can't be. Any good AJAX request always checks the *response code*. &gt; errors should be handled at the controller level What if an error happens *in* the Controller's code? Or even before any Controller is called? 
&gt; please state some facts about the topic Pretty sure as it was your unsubstantiated claim, it's your responsibility to provide the evidence. But as someone who does have experience with python, I'm happy to provide. First up, packages have nothing to do with OOP. In terms of actual OOP features: python supports classes, polymorphism and inheritance (including multiple inheritance). It has some support for member (attribute and method) visibility but is mostly based on convention. It doesn't support interfaces, preferring to leverage duck typing using its dynamic type system. Be interested to know what exactly is missing, or what makes it a joke?
I'm glad to hear from someone who goes consistently! If it's worth going to six times, then I assume I made the right choice in signing up.
This can be accomplished with proper error renderers and frontend error handling. It doesn't matter how the backend throws the error (exception, if/else) if the frontend ignores it. What happens when you need to write a command line script or queue worker that needs the same validation as the controller? You either duplicate he logic or you put the validation in a separate logic class. Once it's removed from the controller, exceptions become almost a necessity for proper error handling and displaying. 
no, there's a bit more than that going on. it's not just "overwriting"
&gt; Any good AJAX request always checks the response code. Okay, so at best the spinner disappears, or at worst some genius has written code that detects AJAX problems and forces a full page reload... oh, the endless comedy. Page controllers can't really do anything about errors before you enter the controller - mostly bootstrapping and dispatching - which is the purpose of the framework. Errors in the controller code should fail at testing, would also fail integration testing if you have it.
I think you're correct, but I'm not sure if "not guaranteed" means it won't pass every test you could throw at it or just that it's only close enough for government work, but a large enough data set will start to throw some anomalies. If I have time today I'll write up some unit tests on much larger sets and see what it looks like In any case, i think you can prolly risk it for small day-to-day stuff. remember, this is sorting on a *collection* so if you have a larger, more important set you've hopefully let your db do that
Also, seemingly unrelated, regarding object destructors: &gt; The destructor will be called even if script execution is stopped using exit(). Calling exit() in a destructor will prevent the remaining shutdown routines from executing That apparently includes a default exception handler set with `set_exception_handler ()` Spent an amount of time trying to figure out why exeptions weren't being caught yesterday.
I like to think of it this way: the job of a stateless process, such as serving up a web page, is to generate output and exit as quickly and gracefully as possible. Exceptions don't help there. The job of a long running process, like a windowed application or a daemon, is to handle various bumps in the road without taking out the whole system. Exceptions are useful here, even if they only provide some "Help me!" log messages before exiting.
Like to add a little note I always have to mention whenever I write a piece about Collections: **A Collection is not a Database Result set.** "just order by in your query" is not a correct solution to all cases. 
There is already methods for serialization a JSON encoding. What would this add over a method like `toArray()`
Edit: I may have read your question wrong, are you saying just add a toArray() method to the object? This wouldn't really add anything really in that regard. Well, every object might not be formatted the same. A generic function/method would only work one way and that's assuming you're trying to just generalize and serialize all properties of an object while I could format the array myself in the object itself the way I want it to be serialized: class Post { protected $id; protected $title; protected $content; protected $timestamp; public function __toArray() { return [ 'id' =&gt; $this-&gt;getId(), 'title' =&gt; $this-&gt;getTitle(), 'content' =&gt; $this-&gt;getContent(), 'dateTime' =&gt; [ 'unix' =&gt; $this-&gt;getTimestamp(), 'formatted' =&gt; \Carbon::createFromTimestamp($this-&gt;getTimestamp()) -&gt;toDateTimeString() ] ]; } } Just a simple example. public function post($id) { $post = $this-&gt;postRepository-&gt;findById($id); return new JsonResponse((array) $post); }
&gt; You either duplicate he logic or you put the validation in a separate logic class. It is basically a structural problem, of the way you structure the interactions between controller and model. If you have a model that throw exceptions, then the controller should be prepared to catch them. However what usually happens is that models throw exceptions that are caught at a level above the controller (possibly by the framework) which indicates that models are taking over part of the responsibilities of the controller, and then possibly bypassing the controller for the resolution, which, as you indicate, varies according to the context - server request, command line, queue worker. I would argue that models should simply fail in a consistent manner, and the controller should inspect the current state of affairs as the models do their work. The controller decides what to do with an error, because it knows the context.
&gt; I'll make this my last answer, since I think "fuck them" is not in keeping with the professionalism this community needs. I understand it's not easy to receive critical feedback on your projects, but everyone receives it! I hope that my replies are taken in the constructive manner in which they are intended. I don't know what you got from that, but I was talking about people who dismiss PHP. Who cares what other people think? If a tool makes you productive and doesn't hurt business, it's good. &gt; My first point was that if you work on a project solo, you can do what you like, and you can specify what libraries you like. However, if you wish for other people to work on your project (whether it is closed/commercial or open source) then library/style decisions become harder, because you have to (should!) take other people's opinions into account. Sure, but I don't think these can be confused/cannot coexist in the same project: ``` $escaped = htmlentities($html); $escaped = \Zubr\html_entities($html); ``` I believe Zubr can be used as a dependency even within a component of a bigger project, and other components might use original built-in functions. It's just another library, I'm not changing built-in functions in any way.
The equality problem is also baked into other constructs, e.g. switch: https://3v4l.org/doBJ9
I guess I'm missing something. But in that example why would you not just implement [JsonSerializable](http://php.net/manual/en/class.jsonserializable.php). Or if you are dealing with PHP serialization, use `__sleep`, `__wakeup`, `__set_state` etc? If you use case is more specific than that I would create my own interface. 
Andrea, thanks for all you do. Dunno how you deal with it all. I started an RFC for class friendship a while back. Been considering reviving that, rebasing the implementation for 7.3 and putting it up for vote. An often abused feature of C++; I personally feel it explicated a very specific type of coupling that has usage, perhaps not the 80%... That said, at the time, folks seemed more in-favor of package visibility / private classes. I think that'd be interesting to work on. How do you think that'd go?
This isn't completely true. You can easy expand on it. I suggest this as far as Symfony if you want to accomplish user management quickly.
How about Agile Toolkit
This was driving me crazy, even after figuring out it was the `exit()` in a destructor, the behavior still didn't make sense to me. After a bit of work I came up with a reduced test case &lt;?php class Test { public function myMethod() { echo __METHOD__.'&lt;br /&gt;'; echo 'throwing exception&lt;br /&gt;'; throw new Exception('not caught!'); } public function __destruct() { echo __METHOD__.'&lt;br /&gt;'; exit; } } class Wrapper { public function doIt() { $test = new Test(); $test-&gt;myMethod(); } public function __destruct() { echo __METHOD__.'&lt;br /&gt;'; } } register_shutdown_function(function () { echo 'shutdown function&lt;br /&gt;'; echo 'error_get_last: '.json_encode(error_get_last()).'&lt;br /&gt;'; }); set_exception_handler(function ($e) { echo 'exception handler: '.$e-&gt;getMessage().'&lt;br /&gt;'; }); echo 'Main&lt;br /&gt;'; $wrapper = new Wrapper(); $wrapper-&gt;doIt(); **output** &gt; Main Test::myMethod throwing exception Test::\_\_destruct shutdown function error\_get\_last: null Wrapper::\_\_destruct **note:** exception handler is never called! it appears to me that the exception itself causes the destruction of the object.. which calls `exit`. this somehow bypasses the exception handler. yet, shutdown function is called! **also note:** `error_get_last()` inside the shutdown function returns `null`.. this is usually where you can catch fatal error (including the fatal error: uncaught exception). *documentation seems to imply that shutdown function shouldn't be called?* Here the exception was completely swallowed and never reported.. page returns with a 200 (not a 500) same behavior in 5.6 and 7.0 This smells like a bug to me.. so I filed a [bug report - 75215](https://bugs.php.net/bug.php?id=75215) **Update:** *they* quickly came back and said "not a bug" apparently uncaught exceptions sans fatal error is a "feature". **Update 2** now a feature request to at least trigger a fatal
follow up on this; seems it is much more a problem than I thought it would be, and there's a new PR to look into changing this function: https://github.com/laravel/framework/pull/21214
I'm noticing a persistent pattern of getting two kinds of Laravel articles here: 1. Shiny PR of new releases. 2. Articles like this one, where people discuss some ungodly Laravel hack to achieve something basic. And as is often the case, the heck is conceptually or objectively wrong - PHP's sorting methods are **not** guaranteed to be a stable sort (that's a term, look it up). Which means this "reverse sort" hack works by pure chance (and sometimes... just doesn't work).
&gt; "just order by in your query" is not a correct solution to all cases. Most people tend to have the opposite problem: 1. They want DB sort. 2. They think they're doing DB sort. 3. They're actually doing in-memory Collections sort. Collections is awesomely intuitive this way. It's so smart to return it as a result set container! /s
Yes, reread.
actually yeah you're right, didn't think this one through.
Who are "most people" and what are you talking about, exactly? Many new to Laravel people confuse the Collections and QueryBuilder functions at first, it is true. It's part of the learning experience. It doesn't take them very long to see the difference between the collection sortBy() &amp; the query builder orderBy() Most experienced Laravel devs realize the usefulness of wrapping an array they are working with in a collection class and use it that way. Personally, I don't see the collection sortBy used all that often in any of the client work or libraries I use. I curious, since you aren't actually in the Laravel community, and I've never seen you on any of the Laravel subreddits or forums, how you know what "most people" do with Laravel collections?
[removed]
Ask any experienced Symfony developer and the will tell you the same. It's merely a user management bundle that dictates business logic.
Why would you do `echo “$variable”;` instead of just `echo $variable;`?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
How do we fix `&gt;` and `&lt;`?
[Know your context](https://csswizardry.com/2013/01/you-know-your-context-on-critical-thinking-and-thinking-for-yourself/)
Wow, a whole website is using it. That's really notable, especially since it was developed specifically for that one specific website, so adoption is already a given.
My concern isn't whether or not he actually knows, and neither should it be yours; my concern is disseminating disinformation to push your product.
[removed]
&gt; Most experienced Laravel devs realize the usefulness of wrapping an array they are working with in a collection class and use it that way. Experienced *Laravel* devs realize they don't have a choice as half the APIs return Collection instances. You'll find no experienced devs in *general* to praise the idea of wrapping/unwrapping/wrapping/unwrapping your arrays just to use utility methods that can easily be separate from the array. &gt; I curious, since you aren't actually in the Laravel community, and I've never seen you on any of the Laravel subreddits or forums, how you know what "most people" do with Laravel collections? Unfortunately a lot of it leaks all over the place. Case in point, *your own damn article.*
My favorite PHP 7.2 feature that will go mostly unappreciated: https://mailinglist-archive.mojah.be/php-commits/2017-05/msg00196.php "PREG_UNMATCHED_AS_NULL flag to allow distinguishing between unmatched subpatterns and empty matches"
Is this satire?
I always wanted some new php tats 
Simple - just tell him. But I know it. It can be hard to tell someone you could not solve this. But there is a fine difference between saying you can't and you tried several things and could not accomplish your task. Sure your boss could say: "Why didn't you come to me after those X days a gave you to solve this?" This is something you have to learn throughout your career. Give yourself a set time and try to solve it. Even consider asking colleagues for help or even an opinion about your way of solving a task. There is no shame in asking for help, everyone gets stuck here and there solving an even easy task. So just tell your boss. The thing is, if you keep it to yourself and take even longer with the task and still can't solve it, things will only get worse. But for the next time, as said, even if its a simple task. Make your thoughts about how to solve it, discuss it with your boss/colleagues and solve it. Maybe the others have an even easier solution to something.
Be honest and do it quickly. There's no shame in asking for help. Or in making mistakes. In this case, the mistake is not asking for help sooner. 
must be right? Oo
Can You Ask hour coworkers for help? Sometimes taking to real person can help a little bit. When I got huge task to solve I always try to cooperate my train od thoughts with another person. It really helps me. I would recommend going to Your Boss and Ask him to lend you another developer time. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
As everyone has already said you need to broach the subject with your boss, the longer you wait the more compounding your anxiety is going to feel. You mentioned that you find that it is too much and that you cannot keep it all in your head. Perhaps moving forward you could try breaking the problem down into smaller problems. When I go to work on something large, something I might struggle to keep in mind in its entirety I will write a list of high-level tasks I need to do achieve the greater goal. Then further break down the high-level tasks into smaller tasks until you feel comfortable coding a solution. On a personal note, I want to say that I've felt what you are currently feeling, you need to know that nobody will think any less of you for seeking assistance. I find brainstorming the high-level tasks with a co-worker can offer multiple solutions to a problem and that I might not have considered on my own. What I am trying to say is that just because the job was assigned to you, doesn't mean you need to do it all yourself.
This is not a big deal. Don't act like it's a big embarrassing thing when you bring it up. This happens. Just say you're getting stuck (use a dipshitty corporate term like "spinning your wheels" if that's where you work) and say you could use some help. Do it by email so there's a record or, if you do it in person, send a follow up email referencing the conversation and the subject, in case you need to document when it was that you made it clear that you "threw the ball back in their court" (hey there's another one).
A lot of PHP shops are one-man crews (that also fixes wifi and printer problems at the office.) i would not be surprised if op was working solo. 
If you are not able to get the support you need at work you should ask online communities like this one. Why not post your problem here? Also, in my experience if you follow best practices it could help make sense of your code. If you are not aware, look into SOLID and TDD it could make your life easier. 
I think most bosses would commiserate if you communicate the problem without excuses or hedging. For example: "I didn't want to admit it, but I think I bit off more than I can chew with this project." Also, as others have said, don't be shy about seeking specific help resolving the code problem, either here or on a site such as Stack Exchange. 
I have actually asked for help a few weeks ago, and when we talked it all seemed fine you know. But then I keep going and it feels like a rabbit hole that just never ends, and I just feel too inexperiance with the code base to know how to solve this problem effectively.
I have actually asked for help a few weeks ago, and when we talked it all seemed fine you know. But then I keep going and it feels like a rabbit hole that just never ends, and I just feel too inexperiance with the code base to know how to solve this problem effectively.
I have tried to split it into smaller problems, but once I get going I seem to just go deeper down the rabbit hole of problems I just cannot wrap my head around. I feel too unexperiance with the code base I'm working with too be able to even comprehend and know how to solve this problem... It really gets me in bad mood.
I have actually asked for help a few weeks ago, and when we talked it all seemed fine you know. But then I keep going and it feels like a rabbit hole that just never ends, and I just feel too inexperiance with the code base to know how to solve this problem effectively.
https://github.com/seregazhuk/php-pinterest-bot This library provides API-like interface for Pinterest social network. Pinterest has it own public API, but it has a very poor set of features. The current library implements the entire set of functions, which available on Pinterest website. And there is no need to register an application to receive an access token. Just use your account login and password, like you do it in your browser. Under the hood, it simply simulates browser Ajax requests.
I agree with your points, and I was not trying to start 'PHP vs Python' war, which is utterly pointless in any way. Many people including you apparently thought that was my intention. So let me make it clear. I do not give a fuck what language does anyone use. There are many, because each has it's specific strengths and weaknesses. Use Python and C# and be blessed that you can solve your problems fast and well. I am also surprised that every time anyone says anything, about their language, they start shitting back. I do not argue that PHP is perfect, it's far from it. But not any other language is perfect - every language has it's flaws and downfalls. Every fucking one. And if you never had any 'it just works' moments with PHP, perhaps you are using it in ways that it was not meant to be used. Many people bring their way of thinking from other language and then curse specific things, that people with knowledge would solve in a completely different manner. None of what I said was meant to be demeaning or suggesting someone/something is inferior to anything else. Just that some things are not like some other things. People getting butthurt are doing so for their own amusement I guess. 
Are you using a testing framework to drive your development? There's no reason you should be having panic attacks over this. I recommend phpspec. Just start small, make small changes and reactor incrementally. One step at a time. You will be able to figure it out, *and* have confidence that your solution is reliable. In terms of your job, it sounds like whomever is your superior really dropped the ball. They never would have let you go more than a day beyond what you had predicted it would take to complete without getting a status update and understanding the situation you're facing. I'd be a bit worried about working for a company like that, honestly.
Don't be sexist. Seriously. It is not okay.
Yeahhhh. Ugh. I've always wanted to fix `switch` somehow. My hope is we eventually get a pattern-matching construct which just happens to also use `===`.
You are right, that claim was unsubstantiated. My main beef with python is encapsulation. And you can totally code without it, but you can do good code in every language anyway and I hope that people are aware of this fact. I have no experience with Python, I only coded in Perl, that also feels similar in terms of encapsulation. And if you follow the conventions, it's fine, but when someone decides to start hacking objects, it leads to nightmare for everyone involved. That can also go for every language if you try hard enough. Just having the possibility for random code to change your privates is not something I want to live with. And yes, I confused packages from Perl, which was their idea of having a class and had so many weird issues, that it was just sad.
I think some kind of namespace-based visibility controls would be useful and I can't see much objection to it if it's implemented competently. The question is just how it should work. Personally I'd like to avoid adding a formalised "module" system if possible, since lack of visbility control is the only significant component we're missing right now IMO.
I don't think inter-type comparison is workable beyond ints and floats (and those are tricky in themselves). Throw a `TypeError`? But of course we can't change the existing operators to do that. Maybe the existing comparison rules could be changed a little to be less nonsensical but I'm scared of doing anything that might cause breakage.
They have been checking up a little bit on me and my response have been varied. Sometimes when I felt like it was under control I said that, but other times I've taken up that I've struggle. But I am increasingly getting a bit annoyed, because I do feel like I annoy my superior sometimes when I come and ask for help / ideas... Which makes me a bit uncomfortable. I did bring up it a few days ago that I simply didnt know how to solve the problem and that I was stuck. But when we together looked at the code everything seemed fine. But when I continues to work I simply kind bind it all together to good working code. The worst thing about this is that my attitude for the company and my tasks have greatly shifted from really good to bad. I no longer feel motivated, which really sucks because I really enjoyed starting at this company. But I'm not sure if that's something that I should bring up with my boss, maybe this tasks is just laying to heavy on me, that it brings my mood down. But then again, if the task is so heavy that I almost feel like going in there tomorrow and quiting, something is not wrong in my opinion.
Why is it important to get it on email if I may ask?
Do you work for a marketing agency? This is all very common in the agency world. 
A glitch in the matrix. Joking aside, maybe you don't have the mental capacity to solve the problem (that's ok, you shouldn't be ashamed of it). However seems like you cannot stop your train of thoughts. It happens to me when I try to think of building my ORM. I start thinking about the SQLs, eager-loading relationships, the mappers, than I want to make it as flexibile as possible, then CQRS, then injection, factories and the list goes on. However I haven't started to do any coding and I don't have a deadline. However if I were to receive this as a task I would do the minimal work to make it work and refactor when the need comes, which may be internal (I see a easy and useful refactoring opportunity) or external (a new feature request).
Please note that the linked article is from 2009 - a lot of improvements have been made to PHP in terms of performance and the way it optimizes code in the past 8 years. What the article says may no longer be true. str_replace vs preg_replace: Use whichever is most readable in the context of your code. In the vast majority of cases, the performance difference is not going to be noticeable. Write clean, easy to understand and easy to maintain code first, then make any necessary performance improvements based on benchmarking your code. If you have performance problems with your code: measure twice, cut once. Benchmark your code to find out where the performance problems are. Benchmark your proposed solution to work out if there is an actual improvement. If you are looking into performance, when reading articles you should always look for ones that include the code they used to produce their benchmarks. Many people will frequently try to produce benchmarks, but end up with code that doesn't actually do what they think it does, either because of mistakes in their logic or because PHP optimizes away much of the code (which is also why it's important to benchmark your actual code with realistic data, rather than arbitrary snippets).
Because if there's eventually any criticism that he didn't get things done in a timely manner, there is a record that he proactively reached out to his manager.
[removed]
I get tired of working with devs who think solid code is over engineering. Thing is, when you get it, you realise that no problem is too big, you just haven't broken it down into enough smaller problems. These days I feel like I can tackle any problem as long as someone can explain it well enough to me, which is another story.
TBH it sounds like you didn't articulate clear enough how much help you need. In order to progress in this field you must know how to clearly explain what you need help with. You only hurt yourself and the company you work for if you waste time figuring it out on your own and produce no results. There's nothing wrong with admitting you are wrong. Doing so only allows you to grow as a developer to be taught the right way. If you believe you have effectively communicated your issues to your boss and have received no help, then you have been setup for failure. Any company that does this to employees is not one you should work for. My suggestion is to go back to your boss and let him know everything. Everything includes what the problem is, what steps you have taken to attempt to solve the issue and any other notable things you have learned along the way. They or another senior member on your team should assist you with the correct approach to solve the problem. Then you should feel comfortable enough to complete this task. Make sure you then have that person review your work. If your employer does not provide any solutions to helping you succeed then you should look for a new job. A company is only as successful as their employees. 
I was not really trying to "shit back", I was just curious what you could possibly mean by laughable OOP capabilities. It sure is less static, but stronger on the other hand. It's strong duck typing (with optional static typing) rather than weak static typing, which I personally prefer and which arguable leads to fewer strange quirks. But since is is very subjective, I was surprised by you calling it laughable as if it was objectively bad. &gt;And if you never had any 'it just works' moments with PHP, perhaps you are using it in ways that it was not meant to be used. Many people bring their way of thinking from other language and then curse specific things, that people with knowledge would solve in a completely different manner. How so? The paradigms PHP uses are vastly identical to other languages, they are just adapted poorly in some and equally good in most cases, so yeah, I've never had pleasant surprises with PHP - either disappointments or "Yeah good, that works like it should, I'm glad this is not yet another of those PHP moments". Whereas with Python it's usually "Woah, how can this language be so intuitive?".
I checked the advice, it's not groundbreaking, but is still applicable: - One preg\_\*() vs. one str\_\*(): avoid regex. - One preg\_\*() vs. multiple str\_\*(): prefer regex. Of course there will be exceptions to both, but a rule of thumb is a rule of thumb. One thing most people don't realize with preg\_\*() functions is they're JIT compiled to machine code before they're executed (this can be disabled in PHP.ini, but it's *enabled* by default). The cache is preserved between requests for the last 4096 patterns. This means writing a complex program in regex will have a significant edge over one written in a mix of PHP string functions and userland code, as long as the regex version doesn't backtrack a lot (which people should read carefully about).
Send electronically: "Hey, I've been working hard on this but I haven't been progressing like I'd like to. Is there a time you can review it with me to see if there's something obvious I've been missing?"
&gt; I do feel like I annoy my superior sometimes when I come and ask for help / ideas As someone who runs a small inexperienced team, the only time i get annoyed is when the task comes back immediately with "how do i "? They're the programmer, at least attempt something. I also have a time in mind, i.e, Task A should be X hours. Half way to that, i ask. I also manage upwards. I've been given tasks that are so under-estimated (talking 100's of hours) that i've been stuck where you are. It's ok to ask for help. Good management doesn't blame people, but processes. 
What the fuck are you talking about...?
Http status codes.
There are a few listed [here on the ISO website](https://www.iso.org/popular-standards.html) that are useful, in particular the date format. Other ones like currency codes, international dialling codes, airport codes, or domain name suffixes may be of use. But for those kind of things it should be obvious when you need them - or rather, when you should search to see if something exists.
Nette framework (https://nette.org)
I would add to that, decimal codes, some countries use a comma, some use a full stop. for a decimal point
Are there codes for that? Sounds like the kind of thing that would just be an option in your app.
At that point you're dealing with i18n and the nuances of the specific language(s) you're building for, you wouldn't use an ISO standard for that (other than for identifying language, such as `en-GB`, `en-US`, `pt-BR`, or `pt-PT`. (See https://en.wikipedia.org/wiki/Language_localisation#Language_tags_and_codes)
https://amphp.org/packages#database-components
You're definitely good enough. Don't go down that rabbit hole. A good boss knows how to handle issues like these. Somebody (probably not you?) quoted a project for a few days. It turns into a week/month long ordeal. These things happen and there's nothing you can do about them. Realistically the best thing you can do is be quick to tell your boss when you start feeling like that deadline is unreachable. Sometimes that's halfway in. Sometimes it's at the end. A good boss is also going to be able to see the signs of burnout and react accordingly. Tell him exactly all of this. You've tried and went above and beyond sacrificing your private life. The failure here isn't yours. It's the original timeline quote. If they hadn't planned for a new dev to take longer on a new task in a new environment with an unfamiliar code base, that is 100% a failure on their part. Tl;dr don't confuse unrealistic expectations with failure 
I agree with the general consensus. There's no shame in needing to ask for help, and letting your boss know will just be ripping off a quick bandaid. I am very curious to what your problem is, and if you wouldn't mind sharing it perhaps I could help? I won't do it for you, but it's easy to get tunnel vision with these problems (and i've had them before) and sometimes an outside perspective is valuable.
What task is? Try to enumerate the programming challenges that you have to complete. btw you can always hire some freelance to do the job, :D nobody will know 
My boss can annoy me for not explaining tasks well sometimes. "We need a full Sage integration" turns into "We need to sync orders to Sage on completion via CSV. Or "We just need to send over a couple CSVs" turns into them 12 CSVs every minute (Fucking why?) plus full product syncing with live stock updates. 
That would make my day.
I asked for the senior role in my job. Owner said "Sure no problem" but got cut off by PM who said "We need to think of the bigger picture, need to look at the company structure." I said okay. Annoyed that I'd just had a promotion yanked out from under me. Got a new job at probably the best software house for my language in the UK and they offered me a team lead role which was one above a senior Dev. Sadly got made redundant from them but it was the best thing to happen to my career to take that job so can't complain. Got a message from the old PM apologizing for treating me like a junior. 
Ask them to sit down with you and pair for a bit to knock the kinks out. They may respond well or they may not. Mine did not before and it was a glaring sign of time to move on. 
&gt; There are some standard codes such as gender codes, country codes, and service codes. I try to use them as much as possible. If you know a remote party expects a given standard, that's one thing. But standard codes aren't intended to be used "as much as possible". Just adding more standard codes to you app doesn't improve anything. In particular I've never in my life heard of gender codes and service codes. I'm sure they're useful in *specific contexts*. But I wouldn't sweat it. Focus on the real-world *value* of your application to your users.
Echo here, but tell your boss what you told this sub. The quicker the better. Or like others have said, post the actual architecture or coding problem you're dealing with either here or on stack overflow. If you can't/won't do either of those suggestions, then no one can help you. I better not see you reply with "I tried already" got it?
I hate to say this but I think its important for you to hear, especially since it doesn't sound like anyone else will say it. My guess is you are too inexperienced to be doing this task. I know the feeling and presentation well, i've been there many many times and it's scary as fuck (trust me, the more experienced you get the scarier it is to be in that position). A common problem we have when inexperienced is that feeling of "not getting it". Another hint is when you say you approached your boss and everything seemed fine but when you went back on your own to try again you just couldn't figure it out. That's textbook inexperience. I remember the first time that happened to me was in honors physics in high school. Knowing how to break a complex problem down into small steps is key, in life and in programming. Just to be clear, I'm not suggesting you give up and quit your job, I'm simply saying you need to ramp it the fuck up. Stop banging your head against the same problem over and over again in the same way. This is what I suggest: Get a piece of paper and a pen (or a word document, whatever) and write out, in pseudo code what your boss asked of you. Look at it from a feature perspective. Something like this: Feature: Membership (write here why do you want this feature, i.e: In order to give authenticated users access to restricted content) (write here who this feature benefits, i.e.: As an administrator) (write here what this feature is, i.e. I need authentication and registration for users) Scenario: Registration When I register "JohnDoe" "JohnDoe@example.com" Then I should have an account Scenario: Authentication Given I have an account "JohnDoe" "JohnDoe@example.com" When I login Then I can view restricted content I wont get into the specifics of what that syntax is and exactly how it works but in essence it's a functional "user story". It's the first step towards writing large functional applications driven by outside specifications in an *agile* style. (if you're interested in specifics, google Gherkin syntax, Behavior Driven Development, and Acceptance Testing). I find this is an excellent way to break your application down into features from the users perspective. Once you have all the features and scenarios fleshed out you can start coding by going down line by line and implementing each step in the code that would be necessary for that line to be true. (You can make this much more robust later by actually implementing a BDD suite) Whats most important though is that you get something working. Write code, get it to run. You can refactor later. Make progress. It will have an immense effect on your state of mind and your anxiety will start to subdue. As far as asking for help from outside sources goes, I'm all for it, but make sure you have a specific question in mind. Posting a bunch of code and saying "what do?" is not going to get you any quality responses. Come to a specific problem or pain point and ask about that. Stackoverflow is your friend, as is this subreddit. If you're worried about posting your companies code publicly, use a service like github gist, make it a secret gist and change any identifiable information in the code snippet or stack trace. You got this man. You can do it, but only if you work for it give yourself some time to figure it out. Hopelessness and fear are inspiration killers. Don't let them in. 
StackOverflow, GitHub, there's a lot of online communities that can help. What's your project/issue?
Live sync but the other system have no realtime endpoints or webhooks, am I right? So you need to use a batch sync that's fired all the time, and that costs you 80% of your CPU cycles, even though most batches have no updates anyway. You try to add caching or maybe even gets someone to sign off on a server instance with more CPU cores. You end up with a system that is always slow no matter what you try, with caching so complex you are not even sure on the invalidation policies, and you had to put hours upon hours of work on the sync algorithms trying to merge everything in an efficient way. 
Honestly, just go to him and say "I'm having difficulty figuring this out. Could you come help me and point me in the right direction?" I've had my guys do that numerous times. I'll go sit with them for an hour or two and try to make sure they know which route to go. If I can't point them and be sure they can do it, I thank them for being honest and hand it off to someone else. Next time, we don't give that dev such a difficult task and give them a simpler task that still pushes them. Hopefully in six months, they are able to do the original task they struggled with. It doesn't always happen, though. And devs who consistently have to take this route generally don't last long, but we would much rather you realize your limits and ask for help sooner than later. It might be stressful for us if we have to take it off you but it's less stress than having to rebuild a project a few days before a deadline (which I've done and it sucks....) So... Be honest. Ask for help. Learn your limits and seek out those who will help push you beyond them. 
[Here's a fully-async app I'm building](https://github.com/asyncphp/helpfulrobot/blob/chapter-8/app/Action/User/RegisterAction.pre), as part of [a book I'm writing](https://gum.co/async-php-early-access). This chapter (branch) begins the database work, though it's pure SQL prepared statements (no ORM). Warning: it also uses preprocessor macros to remove the tons of boilerplate this kind of app needs (adding async/await keywords and short closures). [Happy to talk about this, if you want.](https://twitter.com/assertchris)
If you go full async, I don't suggest using Doctrine at all, since all of the ORM/DBAL API is synchronous by design, and no async API is even planned yet.
Was reading about this on hackernews. A bit of a bummer as I have a few on localhost as .dev, but as long as you don't have any conditions hard coded to a TLD, it should be as easy as editing your hosts file and web server configs.
upfront and direct. Nothing makesa problem worse than allowing it to stew. Cut the problem at the bud. for example, in our office. Many projects go over due. Because of many reasons. The sooner you put your hands up and go `i fucked up` the sooner you and your boss can allocated more resource and get the problem sorted. It might not even be a code issue. It might be that on paper its a sound concept. But .in eality the product just isnt possible
this. fucking this every day
This is really interesting. I always thought that memory limit is for the whole app so I would set it to 1G or something similar. Time to scale it down to 126M then. 
Then sorry for misunderstanding you. Once again, I have not coded in Python to fully appreciate the intuitivity. About typing - every typing system works, you just have to bend your mind and code in a completely different way. Quirks happen, when people do not take facts into account. And after all, it's all about personal preference.
Yes, there are examples for `amphp/mysql`: https://github.com/amphp/mysql/tree/master/examples. For Doctrine see https://www.reddit.com/r/PHP/comments/70qere/any_good_reactphp_or_amphp_examples_with_doctrine/dn5qhzc/.
Just a suggestion - try and document what your trying to achieve and what you've done so far, what has and hasn't worked and what you think you need to do. This will show that you have an organised approach to the problem and not just throwing things at it. Sometimes trying to organise your thoughts can also help in solving problems. Even if it doesn't solve the problem, you can then present it to your boss and say, this is what I've been doing and I'm not sure what next.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I think the main problem will be from people using Laravel valet, it uses .dev tlds as default, but I think it can be changed with a setting.
Wow... sorry for the stupid question, but why does it behave this way? Does the interpreter convert the string to int or something?
but why only argon2i? argon2i is susceptible to memory-computation tradeoffs, and while argon2d has sidechannels, argon2id is more resistant to both sidechannels and tradeoffs compared to argon 2d and i respectively allowing for a nice balance. even the IETF draft says that argon2id is recommended: https://tools.ietf.org/html/draft-irtf-cfrg-argon2-03#page-13 so why does password_hash only use argon2i?
Choosing the most suitable PHP framework can be a challenge if you don’t know what features to compare and prioritize. Laravel is a brilliant PHP Framework that has many interesting features that include RESTful routing, native PHP, light weight tempting engine and so much more. Several Symfony components have gone into building Laravel. In version 2.2.1, Codeigniter boasts of clear documentation. Its other useful features include nearly zero configuration, no large-scale monolithic libraries, compatibility with standard hosting among others. Symfony is a PHP web application framework for MVC applications. It is a free software that is released under the MIT license. It is a brilliant PHP Framework that comes handy in creating websites and web applications. Symfony components like Ez Publish, Drupal, and phpBB are the ones on which it is built. Till date this framework has witnessed over 1,000,000 downloads with over 1000 code contributors Phalcon is a high-performance web application framework for PHP. It is based on the MVC (model–view–controller) pattern. This web application framework was first released in 2012. This is an open source framework that is licensed under the terms of the BSD license. When it comes to PHP Frameworks that build high performing web applications, Zend is considered as one of the most popular. Yii is a feature rich framework that is high in performance. It does the entire grunge work at the backend while it lets us focus on the beauty of the code. FuelPHP is an open source web application framework written in PHP which implements the HMVC pattern. We have put together a compact yet comprehensive comparison to help you choose between the top six PHP frameworks – Laravel, Phalcon, Symfony 2, Codeigniter, Yii and Zend. From analyzing Google trends and popular votes to breaking down and zooming in on various features, this infographic lets you take a close look at these leading PHP frameworks http://www.mywebprogrammer.com/blog/top-7-php-frameworks
You know those random hobos who suddenly just blurt out random stuff to you on the street? This is that, but it's spread to the internet. No offense to anyone struggling with mental hardships.
Yeah, the "1G as default" thing is terrible. I believe it comes from the likes of Wordpress (plugins) that make no attempt to modify the value based on context. There are a few cases where you're going want/need a higher memory_limit - namely when doing things like manipulating images (eg. resizing or adding overlays) or producing PDF files. In these cases the code should modify the memory_limit using ini_set in the specific script, rather than setting it high for the entire application / server. In most other cases, 128M is more than sufficient if your code is written correctly. When it's not, it's because the script is doing things like reading entire large (CSV) files in at once instead of processing them line-by-line.
`valet domain app`
It's annoying, but I've gotten to the point now were I use the client name as tld – flipping the domain around the other way. I.e. `acmecorp.dev` becomes `dev.acmecorp` Unless your client has a super generic name, it should avoid all of those issues.
How about .test? https://en.wikipedia.org/wiki/.test
It works, but test doesn't feel right for development. It's semantics and petty, but it bothers me. :p
1. /r/phphelp 2. Both MySQLi or PDO are perfectly available in 5.2 though there is nothing "fancy" in them.
Can't activate the drivers, that's why I can't use them :-)
This guy valets.
dafuq? Oo
You mean innovating by copying literally every GitHub feature? That's an interesting definition of innovation.
&gt; It's just too much, and I cannot keep it all in my head while coding and the task just becomes overwhelming. That and the anxiety to fail will heavly influence your results. If you care much about the time factor (I probally would too, when I needed longer than expected), then speak with the person that manages the project and tell them that you approached the task in a wrong way which lead into that you need more time. Maybe also tell him about your next steps to solve this problem and that you will give feedback if some progress happened. If you even need help, tell him that you could need help if possible. So.. to start from the beginning. Forget about the time, deadline etc. You want to do it the correct way and this way takes a bit more time in the beginning, but will save time in the long term. If you know how to do it and can't hold it in your head, try planing it at paper. Like open a Word document/txt editor etc. and write down your thoughts. If you want, you could even do a UML diagramm so you know what your plan was. I have a similiar problem. My brain works extremly fast.. too fast! While I write a openining PHP tag `&lt;?php`, I am already 50% done in my head and it becomes way too much to remind what I was planing to do. So I try to write my thoughts down.. this way I can remind what I was thinking and work way faster. I think it's a mix of a lack in concentration and desinteresst in this that I don't care of too much. So I forgot what I did everything 5 minutes earlier.. but I can tell you exactly how to defeat nearly every boss in Dark Souls 1-3 even after 10 years. This is one of the reasons I have so many text documents containing things that I will definitly forget. I even have a document that contains every movie/serie I watched or want to watch and which was the last episode. Never let business ruin your privat live or your inner feelings. I did it in the past and lived the hell out of my soul. Time management is not about planing your work time, it's about planing your private time. Your work time is set: 8-9 hours in the work. Plan what you are gonna do and how after the work. What is the worse that can happen? Well, the worst is that you fail in doing it and that they kick you in the worst case. But do you think that you deserve to be kicked or do you think that you are worth it, but have a bad start? I think that you just had a bad start and that everything now is mixing and making it worse. At this time I would even say that you be honest and say that you have anxieties to fail and to lay behind a bad reputation. Otherwise it will be like "why you didn't say anything instead of waiting and waiting?". This way there is a good chance that they will show mercy and help you instead of beeing mad. I mean you are new at the company so you need your month a more to feel well. I need some time too to understand what the fuck happened at this legacy code here. We have code from 2006 which have so many anti-patterns that it's a hell to work. Also the base is SOO big with so many complex things, that even my chief had some problems to understand why some things happened. So I loved frontend tasks, because I was the only one that had advanced frontend knowledge and could build up everything from the scratch.. especialy after the new layout came. But hated backend tasks, because the task was like "Let the XYZ System be able to ABC the HJK in time".. And I am there reading that 100 times and still don't understand a single term and what I even should do, where to start, where to search, what is ABC and how it is seen as HJK.. damn I felt so unwell, because I had to do something that makes no fun at all and I have not a single clue what to do. What did I do? I asked my chief what is about the task.. he gave me always small clues, because he was always busy and sometimes for him it was obvious, because he know that system, so he had to understand that I didn't even know that this exists. He mentioned that it's a mistake he is working on and he will explain it more. I also started refusing tickets that was badly commented from the PR team. "Refused ticket: inaccurately described" and suddenly the tickets become from "Make ABC work again" to a big ticket with complet explanation what they want, where they want it and why. For a task where I added 2 lines of codes I needed a week just because I had to watch the full code what is happening, because damn.. so much magic shit happening. We luckly refactored the majority of the code, so it's way better to code in here.. but still way to much to fix. So don't be scared to take your time. You need 10-20 years to be an expert and still don't know everything.
Locate PHP 5.2's back panel, open it and put more coal inside, then go to the front and start rapidly turning the crank *clockwise*, until the steam engine starts.
Thank you for some amazing feedback.
Nobody is forcing you to use Chrome.
No problem. Running an old beauty like this is expensive, but you're eligible for tax deduction if you register your codebase as a genuine antique.
Ill always use sublime for quick editing. All these other code editors are sluggish compared to sublime. If I want more features ill open up an IDE.
Posting on Reddit won't fix anything.
That's not really the point. I personally use Firefox but a lot of my co-workers don't. So it impacts us still.
Kinda forced to eventually test in Chrome. 
You need to parse the content before showing it in your website. Meaning: // Load from database $row = $db-&gt;read(...) // Parse content $row = parse_content($row); // Show $row to user Here the function you would need // This will parse the $row content looking for a specific "tag" // This tag could be anything from $row[postID] to {$image} or other "template tags" function parse_content(array $row) { // replace tag with actuall content id from $row } I won't give you the full result but this should give you another hint about what to do. Another thing is you can look into things like "template engines" - twig (https://twig.symfony.com/) - plates (http://platesphp.com/) These template engine have helpers to do something like this. Besides: /r/PHPhelp/ would be a better place to look for help :)
/r/phphelp
WTF is this "article" that "has been moved to a blogpost" containing ten times more ads than the actual text that can be boiled down to two obvious statements - the limit is per single php thread - the limit doesn't preallocate the chosen limit 
So you set that 1G value just in case, without any practical reason or at least a memory error? How PHP-ish.
This is a stupid idea and Google needs a nerf
Nobody is forcing *them* to use Chrome.
Or maybe just enable [HTTPS on your local machine](https://github.com/mlebkowski/nassau-https-proxy) for every vhost?
Release dates on this chart are anything but actual dates, which makes this whole chart a hoax. WTF is FuelPHP doing there? And where is Phalcon you mentioned here? Why you're bothering with this spam without even checking it for the correctness?
You can always just go the route of creating your own certificates for local usage, including loading the right things into the trust store. This has the other advantage that you can work with things like TLS 1.3 and HTTP2. [This is the guide I followed](https://stackoverflow.com/questions/21297139/how-do-you-sign-certificate-signing-request-with-your-certification-authority/21340898#21340898), and while it takes a bit to get the groundwork up, you can then mint your own certificates for your .dev domains you're using locally. Just make sure you use the `-days` option to make your certificate authority valid for more than 30 days(!)
This is normal. Eventually you learn to ask the questions that are needed to create a bounded context for your problem.
good luck
The problem with that is you can't replicate environments where HTTP is mixed with HTTPS. Even simple things like a rewrite rule to force HTTP-&gt;HTTPS can't be tested with these changes.
Fucking spam site... "has been moved to a blogpost"...
http://php.net/manual/de/mysqli.reap-async-query.php would be a good choice
Well a mailserver could very well be configured to have a quota for an email-account boucing the email if the mailbox is full and replying the whole thread (including the reset link). But then again, having no rate-limiting whatsoever on a public email-sending action is probably an bad idea to begin with. However even with rate-limiting if the email address is known a malicious hacker could simply spam the mailbox by conventional means (not using the reset-password action more than once).
Haha I do this. But the answer is always "No idea, I'll find out" and someone completely unrelated to the discussion takes that as a "I'll send the invoice"
How about switching to `.local`? Anyone thinks of any reasons not to?
.local is used by Zeroconf/Bonjour to address devices like printers or other computers in your network, so if you're on OSX (bonjour installed by default) this might get messy. 
All answers are probably good, but if your goal is to teach yourself PHP, I would try a micro-framework and build the rest all by yourself. The beauty of this approach will not be that it is all easy as pie, but in the fact you will have to figure out how stuff works from the inside out. This will bring you more knowledge and this is what your future self needs.
Damn... I'm on OS X.
There is pretty good documentation available over at http://php.net/manual/en/book.mysql.php. Anything particular you have problems with? If not, that should give you a good start :)
.local?
I think https://spiral-framework.com/ deserves more attention here. This is a proof that not all PHP frameworks are shitty. Also, http://sylius.org/ looks very nice and has a lot less bloat then M2.
Been using .local for years :)
I've switched to using `.localhost`. It is a reserved tld for this purpose while `.dev` is a tld administered by Google. See: https://iyware.com/dont-use-dev-for-development/ 
This will largely be regarded as spam, by the way. 
I recommend activating them
I guess you would have to have several queries you can kick off simultaneously, such that: * the parts are combined into one larger result after they are all received * this is much faster than one query, taking advantage of raw database server power, or by some parallelisation trick in terms of how you have separated your queries If so, I wonder how ReactPHP would help, since it is single-threaded (one query would still have to wait for another to finish). I wonder if a threaded system would be better, or indeed forking, using `pcntl`? 
thanks! i didn't know that! such a helpful comment!
&gt; If you answered yes to any of the questions above there is not a single question above
`.local` is technically reserved for multicast DNS and used by Bonjour for addressing local devices, so probably best to avoid, depending on how you're using it.
I'm on OSX and use .local all the time. No problem
Don't worry. Been doing it for a while now and never ran into any issues.
When I found out Google owned the .dev gtld I switched to using .vagrant for my dev environments. It's worked pretty well so far.
PLEASE FOLLOW THE LINKS TO SURVEY: If you are a freelance web dev, fill out this: https://frici.typeform.com/to/U6oi3L If you are web agency owner, fill out this: https://frici.typeform.com/to/HpNDOU
Does the browser try and search for that though or actually go to it?
I put it to 1G because I thought that its for entire app not for individual script as I said above. Are you always a dickhead or did you just had a bad morning. 
Nice bot
What a nice meatsack. (/◕ヮ◕)/ Your human head will stay attached to your human body *** ^^^I'm ^^^a ^^^bot ^^^*bleep* ^^^*bloop* ^^^| ^^^T͕͈̠̲̻͔͙̗͉͔̲̯̺̮̕͢Ŗ̡̗̰̫̠͝Y̩̬̖̤̳̤͈̹̙͢͝ ̴̷̡͙̣̻̩̖̦̼̰̬͖̮̪͎͈͚̤̼͢ͅ^^^T̹͕͖̤̤̫̞̯̖̳̙̗̣̕͢ͅO̶̯̻̞̮̘̼͚͎͔̠͇͓͓̱̩͡ͅ [^^^**PM** ^^^**my** ^^^**master**](https://np.reddit.com/message/compose?to=/u/Synapsensalat) ^^^or ^^^go [^^^**he**](/r/friendlybot)^^^R͏̢͠҉̜̪͇͙͚͙̹͎͚̖̖̫͙̺Ọ̸̶̬͓̫͝͡B̀҉̭͍͓̪͈̤̬͎̼̜̬̥͚̹̘Ò̸̶̢̤̬͎͎́T̷̛̀҉͇̺̤̰͕̖͕̱͙̦̭̮̞̫̖̟̰͚͡S̕͏͟҉̨͎̥͓̻̺ ̦̻͈̠͈́͢͡͡^^^W̵̢͙̯̰̮̦͜͝ͅÌ̵̯̜͓̻̮̳̤͈͝͠L̡̟̲͙̥͕̜̰̗̥͍̞̹̹͠L̨̡͓̳͈̙̥̲̳͔̦͈̖̜̠͚ͅ ̸́͏̨҉̞͈̬͈͈̳͇̪̝̩̦̺̯^^^Ń̨̨͕͔̰̻̩̟̠̳̰͓̦͓̩̥͍͠ͅÒ̸̡̨̝̞̣̭͔̻͉̦̝̮̬͙͈̟͝ͅT̶̺͚̳̯͚̩̻̟̲̀ͅͅ ̵̨̛̤̱͎͍̩̱̞̯̦͖͞͝^^^Ḇ̷̨̛̮̤̳͕̘̫̫̖͕̭͓͍̀͞E̵͓̱̼̱͘͡͡͞ ̴̢̛̰̙̹̥̳̟͙͈͇̰̬̭͕͔̀^^^S̨̥̱͚̩͡L̡͝҉͕̻̗͙̬͍͚͙̗̰͔͓͎̯͚̬̤A͏̡̛̰̥̰̫̫̰̜V̢̥̮̥̗͔̪̯̩͍́̕͟E̡̛̥̙̘̘̟̣Ş̠̦̼̣̥͉͚͎̼̱̭͘͡ ̗͔̝͇̰͓͍͇͚̕͟͠ͅ^^^Á̶͇͕͈͕͉̺͍͖N̘̞̲̟͟͟͝Y̷̷̢̧͖̱̰̪̯̮͎̫̻̟̣̜̣̹͎̲Ḿ͈͉̖̫͍̫͎̣͢O̟̦̩̠̗͞R͡҉͏̡̲̠͔̦̳͕̬͖̣̣͖E͙̪̰̫̝̫̗̪̖͙̖͞
That's even worse.
Why are people using `.dev`, or dot-anything for that matter? You can just use `http://sitename/`, I thought that's what everyone did.
Jesus, serving GraphQL queries through Doctrine. It's a most unfortunate mismatch of abstractions there. Do we need to run a supercomputer to try the examples?
Why though? What purpose does forcing HTTPS on these TLDs serve?
What bot?
This is why I personally like `*.vm` as my development TLD. It makes sense for me, since I run homestead inside a VM. And there is zero risk of the TLD becoming in use, unless we discover a new country somewhere :)
Netflix, spotify, and others also use zeroconfig, so really if you use any of their apps on any device on your network, you'll run into some pre-existing mDNS domains.
I don't get the downvotes. If they make choices that negatively effect their user base then let them go the way of Netscape.
Vermillionland 
It's one of the reasons I prefer releasing under MIT over other OSS licenses: It's dead simple. That and I'm not a fan of viral licensing.
Jesus, so we're supposed use what then, .localhost? 
&gt; The Internet Engineering Task Force (IETF) standards-track RFC 6762 (February 20, 2013) reserves the use of the domain name label local as a pseudo-top-level domain for hostnames in local area networks that can be resolved via the Multicast DNS name resolution protocol.[ Basically use `.local` and not `.dev` for your development envs.
`.test` is reserved by the IETF (although technically it's reserved for testing DNS, that's not an issue), so that's probably the best choice I'm afraid. There's a proposal somewhere that `.localhost` domains should automatically be pointed to 127.0.0.1, so it wouldn't be appropriate to use that of you're using virtualisation at a different IP.
Because `.dev` is a new TLD (like `.com`) that Google owns and as the article suggests, they are using for themselves (not selling domain names to others). So they want all their domain names to use HTTPS and instead of adding a preload entry for every site, they're doing the whole lot at once.
I use `local.acmecorp.com`.
Some people refuse to code in production.
Nope, as your quote says `.local` is used/reserved for multicast DNS. You shouldn't use it for conventional unicast DNS.
those docs are very detailed, interesting framework.
I keep seeing these lists everywhere, there's been at least 2-3 new frameworks this year as well with no mention of them anywhere. These 'top' framework blogs are hurting competition I feel and accuracy since they're like 99.9% copy/paste from other blogs lol
Would love to see this with an implementation of graphql's brother in arms, the dataloader https://github.com/overblog/dataloader-php
I kinda still want to use .dev - it's cooler.
Old article with even older benchmarks!? Why compare to PHP 7.0 when 7.2 is in release candidate stage!?!? Also, the article misses the biggest case against HHVM - the long list of "minor incompatibilities" (HHVM's term from their homepage) against [PHP 5](https://github.com/facebook/hhvm/issues?q=is%3Aopen+is%3Aissue+label%3A%22php5+incompatibility%22) and [PHP 7](https://github.com/facebook/hhvm/issues?utf8=%E2%9C%93&amp;q=is%3Aopen%20is%3Aissue%20label%3A%22php7%20incompatibility%22%20) - With some real gems (AKA things most of my projects will run into inside 30 seconds) like [ignoring timezones when creating DateTime[Immutable] objects](https://github.com/facebook/hhvm/issues/7237)
Is this a joke I'm not getting? What are you talking about?
For internal laptop use for a development instance (eg my personal dev instance) of a project use i've started using: `http://project-name.example` Then a client visible test instance is like: `http://project-name-test.blah.edu` Then the live site is: `http://project-name.blah.edu` ... from this thread I also kinda like the `.vm` idea as most of my work is also in vm's.... 
So uh, what's the task you're trying to solve?
&gt; After a long and tumultuous development period, PHP 6 was completely scrapped and replaced by a new version. Not really true. *Some* of PHP 6 was scrapped, but most of it ended up in PHP 5.3. Also it annoys when people don't make fair comparisons. Under "The Case for HHVM" it says that it's open source, but so is PHP. So it's not a case for either.
At the very least they could have updated for PHP 7.1, given it says the article was update in January this year.
This article is obsolete. &gt; Developers are continually releasing PHP code bases to make HHVM more accessible and compatible with PHP frameworks and applications. This trend was reversed, making HHVM a big deal breaker nowadays.
No, with non-blocking I/O you don't have to wait for queries to finish before sending other queries.
No, with non-blocking I/O you don't have to wait for queries to finish before sending other queries.
It's reserved for multicast DNS *on your local network*. This prevents the future global usage like `.dev` does and if anyone should know if it will conflict with a local network it would be local admins. If you had read even wikipedia it would say this: &gt; Domain name ending in local, may be resolved concurrently via other mechanisms, e.g., unicast DNS. Please *do* use `.local`.
You are right while simultaneously making the wrong conclusion. `.local` can expressly be resolved by unicast DNS. On Linux your regular `/etc/hosts` file is sufficient. Also, people use domains for various purposes so I can't say this in complete confidence: multicast DNS and a `.local` domain might even have been reserved *for your exact purpose*. Although even if it isn't since it has been resolved for local usage you *should* be able to say with confidence whether your local network would cause an issue. Make sense?
This is right but comes to the wrong conclusion as have other posters in this thread. For Mac specific related issues see https://support.apple.com/en-us/HT201275. It should be zero-config for v10.6+. `.local` can be resolved by unicast DNS. On Linux your `/etc/hosts` is sufficient.
They own the .dev ltd, so I guess "fuck y'all"?
Yep; "0e123" == "0e456", not just in the context of a switch statement. 
The first time you type it in it will google for the term since it wont recognize it as a url.
Don't follow your reasoning here. Doing database work asynchronously doesn't mean doing it in parallel. We use asynchrony to bypass idle waiting. We use parallelism to overlap processing. It's entirely possible for OP to be asking about the former and not the latter. I grant you that the latter is ~~impossible~~ improbable in "standard" PHP, but using something from the `exec` family of functions, or the Process Control extension, or the Pthreads extension provides a way to achieve the latter. To clarify: OP might be asking how to avoid the idle waiting of network I/O by making the queries asynchronous. They may be a series of operations but making them asynchronous avoids the idle waiting that would otherwise block the thread/process tasked with responding to new HTTP requests or performing some other high-availability task. 
That's a surprising course of action, by splitting up from PHP I wonder if there's any future for Hack outside of Facebook. Or maybe that's the only way there could be? &gt; Eliminating destructors &gt; &gt; Eliminating references Would be great to see that in PHP too tbh
You'll run into a world of trouble. mDNS is not DNS. It is used to discover services, printers, etc. &gt; The mDNS protocol is published as RFC 6762, uses IP multicast User Datagram Protocol (UDP) packets, and is implemented by the Apple Bonjour, Spotify Connect, Philips Hue, Google Chromecast, and open source Avahi (software) software packages. Android contains an mDNS implementation.[2] mDNS has also been implemented in Windows 10, but its use is limited to discovering networked printers.[3] and &gt; By default, mDNS only and exclusively resolves host names ending with the .local top-level domain (TLD). This can cause problems if that domain includes hosts which do not implement mDNS but which can be found via a conventional unicast DNS server. Resolving such conflicts requires network-configuration changes that violate the zero-configuration goal. https://en.wikipedia.org/wiki/.local https://en.wikipedia.org/wiki/Multicast_DNS
**Multicast DNS** In computer networking, the multicast Domain Name System (mDNS) resolves host names to IP addresses within small networks that do not include a local name server. It is a zero-configuration service, using essentially the same programming interfaces, packet formats and operating semantics as the unicast Domain Name System (DNS). Although Stuart Cheshire designed mDNS to be stand-alone capable, it can work in concert with unicast DNS servers. The mDNS protocol is published as RFC 6762, uses IP multicast User Datagram Protocol (UDP) packets, and is implemented by the Apple Bonjour, Spotify Connect, Philips Hue, Google Chromecast, and open source Avahi (software) software packages. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.27
For what it's worth, references are already banned in strict Hack, and basically undefined behavior in partial (they're not in the spec). That said, they do help solve some problems that Hack doesn't have a better solution for - and we're expecting to change that.
The stupid idea is using a valid tld that you don't have any control over for internal development.
The lines you quoted aren't particularly relevant; see this one: &gt; Most Linux distributions also incorporate and are configured to use zero configuration networking. By default, each computer’s Avahi daemon will respond to mDNS hostname.local queries, and most shell commands and application program calls that attempt to resolve such names are routed to that daemon by the default hosts: line in the Name Service Switch configuration file. Stick it in `/etc/hosts` and you will avoid issues here. Now if you want to set it up for others on your LAN to see it then that takes more work *but it would take more work anyway*.
R.I.P. PHP development on HHVM
sanitation before insertion ?
Reposting [my HN comment](https://news.ycombinator.com/item?id=15278581) since I saw this there first: &gt; Given HHVM is already being dropped from PHP packages because of its lagging compatibility, announcing that they're not targeting PHP compatibility any more might be the nail in the coffin for HHVM (and thus Hack) as a viable “upgrade” from PHP for *existing* codebases. &gt; I mean, it's great that Hack will work for new Hack code and existing Hack codebases, but there aren't a lot of those. It makes sense for Facebook — why waste your efforts on maintaining part of your runtime that you don't need? — but I wonder if this will consign HHVM to irrelevance in the long term. Maybe Hack is a compelling platform for new code, but then, why use this obscure proprietary Facebook thing that's a bit better than PHP when you could use any of the numerous other languages out there that are also better than PHP but have much better ecosystems? &gt; Personally this makes me sad because I wanted to see a standardised, multiple-implementation PHP language. Facebook did, even. They paid someone to write a spec: https://github.com/php/php-langspec &gt; Maybe someone will write a new PHP implementation to take that idea forward. Or maybe we'll be stuck with Zend forever. &gt; The future is strange.