&gt; You don't need an interface if there is only ever going to be one implementation I don't think this is right. I'd reword it as: &gt; You don't need an interface if there is only ever going to be one implementation and that implementation is never going to change and any other objects that talk to that implementation are never going to change. If an object has behaviour then it implicitly has an interface (semanticly). Collaborators couple to that interface when they send / receive messages through it. If an implementation is the same as the interface then collaborators are tied to the implementation. This is not good as it makes change harder.
There's already old and existing code in Zend Framework which worked around php errors by trapping them with set_error_handler and throwing framework level exceptions instead. It looks like this deficiency fix was years in the making. I'm glad that the root is an interface as well. 
So by in house you mean in Linode's house :)
So don't refactor, plan to do it right the first time. You probably won't, but the effort of planning it that way is not wasted. If you're thinking about writing an application to be portable from the get-go, then it's not as much additional work if you do switch (and if you don't switch, it's not that much additional effort 'wasted'). It's a trade-off, but there's value in writing the code to be portable in the first place, even if you don't move it anywhere.
I mean before it was implemented using AutoModerator, perhaps rename it something like the "Weekly Moronic questions thread"?
I wonder what the future holds for Zend / PHP. Here's looking to Rogue Wave to update the community with their plans.
&gt; So if you can turn off that stupid default, you can also turn on UTF8 connections and not use prepared statements, but escape. That would also be secure. &gt; Counter-argument? I don't really have much of one. I tell non-experts to use prepared statements because they make it far easier to do the right thing. That's not to say it's the *only* way, but it allows us to teach people to cultivate habits that reduce the likelihood of a critical oversight that leads to pushing a remotely exploitable vulnerability in production. For people who are in a hurry, who make mistakes, who really *don't know any better*, I believe that teaching people to adopt better habits will result in a net security gain. It doesn't mean that escaping is less effective, just that it's an optional step and burdens the implementors more than prepared statements, which are safer by default (as long as you don't concat to the query string). If you're a careful and experienced programmer, I'm confident you can avoid vulnerabilities through proper escaping. Experienced devs are more likely to fuck up passing data to `unserialize()` than they are SQL handling.
&gt; It doesn't mean that escaping is less effective, just that it's an optional step Binding an argument is also an optional step: $st = $d-&gt;prepare("SELECT * FROM foo WHERE id = $injection"); $st-&gt;exec(); So maybe you should focus the wording of your advice on how precisely to handle parameters: "escape properly or bind parameters"... instead of saying "use prepared statements". I have personally reviewed code using prepared statements which was vulnerable to injection like the above. The developer was very proud that they know they should use prepared statements.
In the context of habits, it's easier to teach the upcoming generation to do this: $arrayOfData = $db-&gt;safeQuery("SELECT * FROM foo WHERE id = ?", [$injection]); Than it is to remember to escape everywhere.
i heard the team behind the project has been sending out emails to package adopters, calling for commit reverts.
I've switched from Sentry to Gatekeeper and its been a seamless transition for me
rogue who? their website is even powered by windows/iis/asp
That's common practice in many frameworks. 
Unless Magento updates to support PHP 7?
- puli install - that's what she said
yes, composer is a framework agnostic package manager, as you just said yourself.
If we are going to sticky the thread throughout the week, may I propose the following names: moronic monday twit tuesday witless wednesday thoughtless thursday foolish friday simple saturday stupid sunday
Sentinel, works great and I'm waiting for the next release with addons support
This is the letter I sent to their PR department 3 hours ago. No response yet. To: amanda.evans@roguewave.com Hi Amanda, I have made PHP the cornerstone of my career for my entire adult life, learning it at age 16 in 1998. I am deeply troubled that a non-PHP, one dedicated to C++ and Java, that doesn't seem to make web apps, has taken over the corporation that controls the language. I heartily believe that your company must issue a press release *immediately* [like in the next few hours... NOT tomorrow] that your team 1) does not hold baseless anti-PHP sentiments that are so common in the C++ and Java communities in particular, and that 2) your dedication to the project remains strong. We also need to hear 3) whether or not the core PHP contributors, namely Rasmus Lerdorf, Zeev and others on the Internals team are still stewards of the project, and whether they will still receive salaries for this work, or whether PHP will become, by necessity, a side project for them. 4) Because HHVM exists as a valid alternative, we need to have reassurance that you're not going to a) change the PHP license to anything else and 5) are motivated [and promise!] to steward PHP for at least X years. You just acquired an ENTIRE economy. Please treat my message as a canary in the coal mine, because I can guarantee you SEVERAL MILLION PHP developers will have the exact same questions and concerns as me. Please make sure this correspondence gets in front of your superiors soon. 
You think Facebook could have tossed them a bone.
&gt;underscoring our goal to make developers heroes Ugh... blech.
Perhaps Newbie Weekly?
Oh that looks nice. 
Oh ah, this is related to sentinel I guess.... 
Yeah I am with you. The above letter seems to be a knee-jerk. Zend doesn't own PHP. It owns the Zend Engine, which is the major 'implementation' of PHP language. It would make absolutely no sense for them to start messing with the license (tightening it)
They don't even own it. It lives in the php-src repo and only one zend employee works on it vs the bunch of volunteers. They can't even pull it out, worst case they can stop contributing to it.
They can release new versions of the license but that wont apply to the current zend engine retro actively.
"C and C++ have a reputation of being difficult and complex" if C is harder, then i have not found any language much easy. 
I suppose Zend forgot to include this clause in the acquisition contract: 1.5.2 Before this contract can take effect, the BUYER must rewrite their entire website in PHP, and every office in the company is required to contain at least one elephpant at least 5 by 5 by 5 inches size, placed in a clearly visible central location. And also, SELLER requires that the BUYER reissues new business cards to ALL their employees where their name is spelled with "$" in front, like this: $john $doe. 
Do you really think their engineers had much say in this decision? 
Do you think there's a conspiracy against you and people are following you everywhere? :) 
Well, it's not funny.
&gt; So Wave Software is a rogue outfit? Yes, they're a council of super-villains. &gt; Will they start hiding malware in the code?! No, they plan to use PHP to complete a collection of ancient languages that will open a portal to their home dimension where alien soldiers are waiting to attack Earth. If that doesn't work, plan B is to embed AI into PHP so it becomes self-aware and starts building terminators and time machines and people and terminators start going back and forth in time until no one can figure out what's going on anymore. But if that also doesn't work... yeah... it'll be malware. That's their plan C. The PHP malware will use a bit of your CPU on every web request to mine bitcoins, so they can fund their acquisition of Ruby, and maybe Clojure.
Checks out. https://www.youtube.com/watch?v=Rw1cdRew-Zg
Like turnkey images? They're good, it all depends on your needs
"Under the hood (wink wink)" Priceless :)
You not finding it funny doesn't make it not funny for everyone.
You can't change titles of post on reddit, AFAIK.
Point taken. I think I'll just put the OCD to rest and use isset
IIRC Rogue Wave is well known for buying up companies, mismanaging them and fucking them up so... bye Zend!
https://www.youtube.com/watch?v=LgNAf_xK-P8
https://github.com/WebAssembly Yes, it's a thing. =P
This plugin seems to force set the color scheme every time the IDE loads; which removes the ability to customize the scheme, which is a shame because I'm really liking it. Having to spend the time to change scheme on every load is very annoying
Nothing off hand, that's why I said IIRC - they were a company my old boss used to work with.
TL;DR: Puli isn't a replacement / alternative to Composer. While Composer is a package manager used to install packages and their dependencies, Puli is used to describe where resources such as assets, translations, etc are located inside your own package. This way frameworks can find those resources without forcing you to adhere to a specific directory structure in your own package. Of course that's not everything there is to it, but it's the general gist of it.
And?
&gt; I don't think what it means in Romanian matters much in this case It doesn't. It's pretty hard to come up with names as it is, not to mention trying to avoid every little slang word of every language. Why would others care if some romanians do have some giggles when using it anyway? Meh..
ZF2 sucks donkey balls compared to other frameworks. Zend Studio is just Eclipse, nuff said there. I'm just curious what this means for the future of PHP.
Rogue Wave is still around?
http://imgur.com/GBraBcgl.png ... is it, really? 
It's so light weight, there's not even any tests! Looks promising though. Sometimes I feel Doctrine has become a monster.
Something your post doesn't consider is that sometimes just upgrading a framework across one or more major version boundaries comes with the same kinds of problems that you'd expect from switching frameworks. So, your 0.001% probability can suddenly become an extremely large probability with any app that you want to keep up-to-date over any significant length of time.
Postmark is pretty awesome for automated non-recurring emailing.
Yeah, that's a good point.
As I said, I like Lumen. If that wouldn't exist, I'd use Slim. Both use the same router. If I don't need to build an ultra fast micro service, I usually go for full Laravel. The convenience of developing with that beats everything so far.
Have you even used ZF2?
But, why? Does this have a use-case, or is it just for the lolz? Because, I can't think of any good reason this use be useful. 
Never heard of them or their products. How the hell they acquired Zend (one woudl think that would not be cheap) For those interested about Rouge Wave https://en.wikipedia.org/wiki/Rogue_Wave_Software 
I don't recall OTOH if PHP has self-executing functions but in JavaScript you can put the () after the closing brace to execute it immediately. For example give this a try: $thing = function() { return "thing value"; }(); // note the parentheses here echo $thing:
Do you think I'd make remarks like that if I hadn't? Now begone you troll. I'm all out of food.
Just backing up your point that they have purchased a lot of companies...... Growth by acquisition is usually a riskier path to growth than organic revenue growth. 
Who?
&gt; My years of coding in x86 and RISC assembly tell me otherwise... Come on, if you really wrote assembler you would have said "My years of writing Assembler for x86 and RISC arch's" =P 
&gt; rything was developed here, it's more understandable why they'd be hesitant. At least it won't be lik Doesn't CentOS 5 have half a decade more of updates and security fixes? Why upgrade?
Honestly, I'd like to know why you hate it so much, which frameworks that you prefer, and why. I've used Zend Framework since around 0.5 and, honestly, find it to be a very quick framework to get up and running with minimal fuss. Other than the Service Manager is a bit of a pain to understand, it's not terribly different than Symfony 2. 
..they say that a hero can save us...but I'm not going to stand here and wait
The first thing I would do is identify what your resource is. It sounds like a channel is a singular thing, so this could be a clue to needing a term to mean "group of channels". Since I do not know about your specific domain, this API could be suited for a TV channel type of API, or a twitch/youtube channel type of API. I will assume the latter. If a `parent.id` channel and an `id` channel are the same resource with the exception that `parent.id` contains a list of pointers to other channels, then I would say it is acceptable for this to be wrapped up as one resource. `/channels` will return a list of all channels. `/channels/{channelId}` will return an individual channel resource with a key called `children` and be pointers to the other resources. If there is more to a parent channel than it just containing other channels, then I would try come up with a word to mean what that "parent channel" is and expose that as a resource. `/parentChannels` will list all of these parent channels. You can think of it as a "channel group". `/parentChannels/{parentId}` will return information about the specific parent channel. `/parentChannels/{parentId}/channels` will return the list of children channels a parent channel has. `/parentChannels/{parentId}/channels/{channelId}` will return the individual channel. Now when you include this "OR" into the mix, you have a couple options. I would say the most practical solution in most cases would be to expose a search endpoint like your `?q=(channel.id:1 OR channel.parent_id:1)` since it is specific criteria. You can also treat a channel to always return the channel.id and all the children of `parent_id` (of course you lose the flexibility of picking one or the other. This is a business rule to decide on) Even after deciding to not like any of these, another option would be to expose a custom search endpoint that either explicitly or implicitly defines these rules. `/channels/search?id=1&amp;includeParent=true`
It was many moons ago... so I've lost any edge I had, anyway, even if I can't talk the talk anymore. :P
All I can think of that is similar would be the magic "__toString" method for objects http://php.net/manual/en/language.oop5.magic.php#object.tostring
no dice, the only thing you can do in php is to approximate a self-invoking anonymous function with: call_user_func(function() { return "thing value"; }); 
you did this to us
The data types that you are assigning are different. In your first example you are assigning a closure to the value of an array key. A closure must be executed. `echo $data['thing1']();` works in this case. In your second example you are assigning the *result* of the closure to an array key. The result of said closure is a string. Thus `$data['thing1']` is a string, not a closure, and can be echoed as such.
If you have deep arrays, I'd propose a function like this: $source = maybe($array, 'controller', 'options', 'data', 'source'); Or this: $source = maybe($array, 'controller.options.data.source'); Then you can replace all instances of this with "??" when you go PHP7. Despite it's slower, it avoids duplication which I feel is more important most of the times, as it aids readability and reduces chances for bugs, especially if this is application code, and not some tight loop in a tiny, heavily reusable library. If it's 1-2 keys, I'd repeat them in an isset, if it's 3-4 or more keys, I'd go with a function like this. But you know, something I notice, as I gain more experience, I encounter way less situations where I need to dig into deep configuration arrays like in that example above. It's typically a sign someone has a "God configuration" array instead of relying on more flexible and far less error-prone constructor configuration (i.e. "dependency injection").
Facebook does not use the Zend interpreter, they use HipHop. As I understand the only contribution Zend makes to PHP Working Group is the interpreter. And at this point the PHP Working Group does the majority of the maintenance/improvements to the interpreter. I could be wrong, but I don't think this purchase will really affect Facebook or the future of PHP much.
Is it the priority that it be *funny to some*, or be designed to guide people to ask questions there, instead of making main threads about stuff like : - What is the difference between a repository and a DAL. - How to password hash - How not to repeat issset(thing to repeat) ? thing to repeat : null - Hey guys, I got a syntax error, halp - What is the difference between value and entity - Why you not use a framework - Why you use a framework - What is the difference between PHP and potato If the priority is that it be *funny* instead of *useful*, may I suggest some people have their priorities wrong :)?
Pimple (the service locator/di container) does this using `ArrayAccess::offsetGet` https://github.com/silexphp/Pimple The source is an easy read. 
Came for the typical laravel brogrammer cries. 
In which ways are Puphpet and Phansible different from Vagrant?
It's funny! When I try to point out this same shit below, hours before you, people laugh and snicker and call me a conspiracy theorist and downvote me to hell. If you aren't at least a little bit scared about this and PHP's future, amid an amazing vacuum of silence from the new corporate overlords... i mean, stewards, you're nuts! Especially with PHP 7 at such a critical stage. But no, everyone's going to tell you that EVERYONE who contributes to PHP does so on their spare time, without compensation from Zend, (no none at all!) out of the goodness of their hearts and that Zend Corp only has vestigal stakes in PHP due to ancient heritage. Bullshit.
And if it *is* true that Zend Corp hasn't been financing the lead developers, then *shame* *shame* on them! That is NO WAY to run a company. My question is, how can a non-web company no one has ever heard of possibly be good stewards? And how much did the acquisition cost, exactly? Ball park? Did Zeev and Rasmus split most of the loot or did it go to some shadowy private equity group? Perhaps they could have told us they were going to throw in the towel after years of playing catchup with HHVM + HackLang, and we could have started a KickStarter campaign or something to buy them out ourselves? If every PHP dev contributed $10, I'm sure we could probably beat whatever they got.
&gt; It's funny! When I try to point out this same shit below, hours before you, people laugh and snicker and call me a conspiracy theorist and downvote me to hell. I re-read my comment and I can see how it can be interpreted to have a different tone than intended. My point was to point out Zend's contributions, **not** to tell people to panic because Zend was acquired. I think it's slightly sad Zend was acquired, because it means they weren't profitable enough to stand on their own, but I'm not panicked. The problem in your attitude is sending emails to Rogue Wave's PR and insisting on immediate statements and talking about how C++ developers hate PHP and so on. &gt; If you aren't at least a little bit scared about this and PHP's future, amid an amazing vacuum of silence from the new corporate overlords... i mean, stewards, you're nuts! Especially with PHP 7 at such a critical stage. I'm not scared about anything, I just recognize that long-term HHVM may take over if PHP doesn't innovate as fast as Zend has helped it innovate. The key word here is **long-term**. As for PHP7, it's basically completed. There's 0% chance of any of this affecting PHP7 in any way. In fact, I suspect the announcement of this acquisition was delayed until late in the RC stages for PHP7 precisely to eliminate any fears this might disrupt the schedule. &gt; But no, everyone's going to tell you that EVERYONE who contributes to PHP does so on their spare time, without compensation from Zend, (no none at all!) out of the goodness of their hearts and that Zend Corp only has vestigal stakes in PHP due to ancient heritage. &gt; Bullshit. I think we can recognize the effort and contributions of Zend without having to inject so much drama into it. PHP is good right now, and for the next 4-5 years it's entirely unfounded to fear or panic about its future. And, you know, if in 10 years PHP has stagnated, there's HHVM, Node, Python, Ruby, etc. and the world will keep turning.
Just firing off the hip here but wouldn't using $$thing work? I'll double check when I get to a machine but $$ has caused some weird effects when I've miss typed code in the past. 
It's for lolz.
&gt;plan B is to embed AI into PHP so it becomes self-aware Sometimes I think this is already the case.
That's just not good enough in this day and age.
&gt; HHVM is already not that much better than PHP 7 &lt;-- Source ?? The source is the PHP 7 benchmarks which show PHP 7 almost as fast, and sometimes *faster* than HHVM for real apps. https://www.zend.com/en/resources/php7_infographic And PHP 7 is adding some essential Hack features like scalar typehints and return typehints. And there's already talk about generics in PHP 7.1 or 7.2. If you think I'm missing something big about Hack, share it. The collections API is fully implementable in PHP, you don't need language support for that, it's full of Composer packages like that. I'm fond of Hack's shapes, but it's not something I miss too much. &gt; The biggest selling point in hhvm is not php, its hack.. So that we could migrate the app to a more saner language.. gradually.. Hack is a static type system, which means technically you don't need runtime support for it, and there's already a Hack -&gt; PHP compiler. You don't need HHVM for this. And as I said, if you want a "saner" language, which for you seems to mean "closer to a statically typed language", go for Java. I value PHP for being a highly dynamic, designed-for-the-purpose flexible language that I can deploy piece-meal to servers. If I didn't value that, I'd just switch to Java.
The Eternal ~~September~~ Monday effect.
&gt; And as I said, if you want a "saner" language, which for you seems to mean "closer to a statically typed language", go for Java. &lt;-- And is there any way to migrate existing code to java gradually?? The source is the PHP 7 benchmarks which show PHP 7 almost as fast, and sometimes faster than HHVM for real apps. https://www.zend.com/en/resources/php7_infographic &lt;-- For small workloads, I believe.. If you think I'm missing something big about Hack &lt;-- Async And there's already talk about generics in PHP 7.1 or 7.2. &lt;-- I believe it will be too hard to get generics into php.. even if someone has made an implementation.
&gt; And is there any way to migrate existing code to java gradually?? Yes, it's writing modular software. Bad architecture can prevent you from being flexible in that aspect, that's why architecture matters. **EDIT:** BTW if you have questions about how this is done, I'd be happy to share my experience. Basically all my projects are hybrids in terms of languages used. Just please keep questions specific, so I can give specific answers. &gt; For small workloads, I believe... So I give you benchmarks, but you choose to believe things. Ok. &gt; If you think I'm missing something big about Hack &lt;-- Async Async is neat, but I think if you use PHP to its strengths as a front-end there isn't that much need for async in it, is there? At most I've needed is futures, which retain a synchronous workflow for asynchronously fetched payloads. Async for HHVM exists mostly to address a specific issue in the way Facebook implemented their code internally, in which they had to use ad-hoc state machines to fetch info from many "chatty" internal services. They made a public presentation about it (btw the way they wrote that code initially... can't unsee, there were better ways, even without async). Chatty APIs are commonly recognized as a poor way to design a remote API, and async was the workaround that allowed them to achieve an acceptable latency. Also, PHP 5.5 introduced generators, and 7.0 extends this support (https://wiki.php.net/rfc/generator-delegation). The resulting generator support enables one to easily implement co-routines (which is how async operates under the hood - it's co-routines). Some syntax sugar to expose this as async would be nice, but the feature is there already. 
https://www.youtube.com/watch?v=TYck8dc5PrE
&gt; Yes, it's writing modular software Care to explain more on this.
This makes me feel uncomfortable: https://github.com/catfan/Medoo/blob/master/medoo.php#L150
&gt; The skinny is the project is split into modules that communicate via an API that's platform neutral. A tiny example /Hello world kinda/ would be much appreciated (if its not that hard). Edit: I had to handle a hybrid app, which too is partially php-java. And the existing app (legacy app) had , the php part write's a sync table which specifies an opcode and the corresponding values /parameters/ in aparticular db, The java service runs in the background and checks this table to see whether thers any operations left.. I know this sucks, And i would like to improve the current workflow in a saner manner, but i couldnt think of how i should approch the problem. 
Maybe it's those people's fault that they interpret a joke as snobbery... it's just a joke man.
Read my comment above for explanation and link to slides.
I have read it in the meantime, it's a much clearer explanation than anything on the homepage of the documentation, thank you for that. But it's still not something that seems very useful for me since I'm always working inside frameworks.
&gt; There were plans for a new major version Yes, just like with PHP 6. There were not just plans, they had an alpha. &gt; several people were working on things publicly Why don't you list the "things" people have been working on publicly? Let me remind you: PHP NG conflicted with a patch that would support &gt;2GB strings. As you said, PHP NG won on technical merits, because not only it also supported &gt;2GB strings, but it was twice faster while using much less RAM. It would be laughable if it happened the other way. BTW, do you know why Zend had to work on PHP NG in secret and "drop it" on the world? Because otherwise *the idea* of PHP NG would have died a horrible death before it even had a chance, in the toxic environment that the PHP internal discussion lists is. The best way to convince someone is to show them, and "showing them" in this case took some time to develop internally for Zend, because it involved major changes to the PHP core. So Zend did right, and this is why PHP needs someone like Zend to thrive in the long-term. The fact you don't appreciate this and seem to focus on how Zend violated the process despite they *were right on a technical merit*, only seems to confirm my point. The process should serve PHP, PHP shouldn't serve the process. If the process can't do what Zend did repeatedly, the process is broken.
&gt; Why don't you list the "things" people have been working on publicly? I'm not your personal assistant. I won't be going through crowded archives to please you. It's the Internet age, do your own research. &gt; in the toxic environment that the PHP internal discussion lists is. You mean the toxicity created and perpetrated by people like Zeev and Andy? Over the years, a lot of attempts to "fix" parts of PHP have been blocked (either via vote, or flamewars) by people associated with Zend. Why? Because Zend has a vested interest in keeping the status quo. The most recent example being Zeev's mind boggling crusade against strong types. &gt; Zend did right, and this is why PHP needs someone like Zend to thrive in the long-term. Completely disagree. A *much* better solution would be a foundation like PSF, that will govern the project and set the rules. Python benefited *immensely* from PSF. No reason it won't work for PHP.
&gt; I'm not your personal assistant. I won't be going through crowded archives to please you. It's the Internet age, do your own research. I already *said what it was*. A patch to support &gt;2GB strings. That's what caused the "big scandal" with PHP NG. My point was you're deliberately vague because you don't have much of an argument. &gt; Because Zend has a vested interest in keeping the status quo. Yes, that's why they *rewrote* the PHP engine for the third time? :) Are you serious? &gt; Python benefited immensely from PSF. No reason it won't work for PHP. Yes I hear Python 3 was welcomed by the developers and everyone instantly switched to it. There's no controversy and drama in there at all. Everything is going swimmingly. We need to copy that.
Composer loads classes. Puli loads all the other resources. There is no overlap, Puli is not trying to replace Composer so this is not the case of "yet another standard".
You would get a better response if you provided concrete tests instead of just your word, at least from this sub. 
Why do you need to parse routes at all? The browser is already handling the "routing" to the proper php script, so why add another layer of complexity on top of it and ruin the scalability? Rasmus Lerdof: http://www.ustream.tv/recorded/1509596 from 8:00 to 13:00. 
Yes and no. As the copyright holder they can allow a copyright change, but they have to get buy-in from everyone that has committed to Zend Engine, as each contributor still retains copyright to their own patch contributions. It's much the same thing as what Joomla Framework went through switching to LGPL. The chances of a license change happening are slim to non-existant. If it does happen, the PHP group will just use the newest version of the engine with the current Zend license. Zend/RogueWave can't force them to use a non-OSS-licensed engine. 
I'm more of a code artisan.
what about custom operators? how would you do a 'Like' ? The array approach is really a dirty unreadable hack
Those 2 give you a webpage/GUI for creating a Vagrant environment. They both _use_ vagrant. You can start your own Vagrantfile and go to town adding puppet/ansible provisioning on your own. Or you can use those 2 webpages and have it do it for you (which you can customize after downloading). It is possible, in theory, to DIY and end up with exactly the same files as Puphpet and Phansible provide. Think of them like HTML5Boilerplate, they aren't adding anything new to Vagrant, just taking care of a lot of stuff out of the box for you 
Nope, that's the syntax for a [variable variable](http://php.net/manual/en/language.variables.variable.php), which only works if `$thing` is a string and contains the name of another variable in scope. Since `$thing` contains a function in this example, and you can't convert functions to strings, you get a fatal error if you try it.
&gt; Edit: I had to handle a hybrid app, which too is partially php-java. And the existing app (legacy app) had , the php part write's a sync table which specifies an opcode and the corresponding values /parameters/ in aparticular db, The java service runs in the background and checks this table to see whether thers any operations left.. I know this sucks, And i would like to improve the current workflow in a saner manner, but i couldnt think of how i should approch the problem. I'd just add then that the comment with the example, when I said a "proxy" to a remote service I meant a socket or a message bus. In the most basic case this can be an HTTP request (Java is then an internal HTTP server), for higher efficiency you can send JSON (including a binary JSON dialect) over TCP directly, and for even higher efficiency there are Thrift, Google Protobufs, and the various message servers like ZeroMQ etc. Going from a solution with operations in a table shouldn't be much of a jump. As for "opcodes" that's fine, but it helps to have a structure to them, say, specific endpoints with specific method names, forming an endpoint hierarchy which is easy to extend and follow (you can still map that to numeric or shorter codes, but in one place in PHP and one place in Java, so it's easy to change on both sides).
"Fat" is "Dick" in German, doesn't really change anything.
This is a decent attempt at trying to introduce the idea of routing, and why you'd use it at a basic level, however I think that both this Reddit post, and your blog posts titles are incorrectly named. Your post (as you've said elsewhere in the comments) illustrates _an_ approach to get some form of routing working, without a framework - and that's cool, so title your blog post as that. "Basic Routing with PHP", or "How to Implement Basic Routing in PHP", etc. I would say that your approach is quite a dated approach, and is not necessarily all that modern. For instance, modern frameworks / libraries tend to have configuration that allows any URL to point to any controller. One common way that the routing is actually handled is via generating regular expressions from some kind of DSL, and then storing each of the regular expressions in an array so that each of them can matched against when a request comes in (preferably with some kind of caching...). &gt; Sadly there is no way to solve this in PHP. So this has to be done on the webserver level itself. This actually isn't true, take a look at the other keys available in `$_SERVER`. On that note too, Nginx is very, very widely used nowadays, it'd be good to maybe have either the problem solved in PHP, or show potential configuration for both Apache and Nginx. One final thing, before I have to get off of lunch break :D, think about how your current implementation limits URL structure, think about the kinds of URLs it forces you to use - this is one thing that will really put people off it. Also, on that note, your router should absolutely _not_ be the thing that calls your controller, or in fact, even what makes an instance of your controller. It should return a piece of information that can be used by something else to create your controller. This is for example what the Symfony Kernel does. Here is a Router that I made a while ago that follows some of the things that I've talked about in this comment, feel free to have a poke around: https://github.com/strident/Router
This style of routing is dating back to Zend Framework 1.x, not using a routing map, lack of being able to create customised route paths to point to specific controllers/actions, no method control, the inability to easily manage possible callbacks pre or post route matching/non-match or management of parameters/expression parsing in the path. It unfortunately lacks scalability and explicitly binds your URL structure to your controller/action schema. your SEO/marketing team will fuss like hell. 
Check out [PHPixie Database](http://phpixie.com/components/database.html) component btw. It has all that medoo does, with MongoDB and 100% test coverage :)
Thanks for your extensive feedback. You are right and I changed up the title a little bit. I changed your idea up a bit to this: "A basic Routing approach with PHP". Also I wanted to keep the approach as small and simple as possible. Of course it would be easy to add further configurations to the router to handle routing on a pattern matching basis, but I didn't wanted to go too deep. That's why my Router is also instantiating the controllers. In a real project I would probably break up those responsibilities and create some sort of FrontController/Application class which is giving the information to the router and goes on with the information it got back from the Router, like you said. And thanks for linking your approach, will have a look into it later today :)
&gt; We tested it locally. my favorite! http://programmingexcuses.com/ also, &gt;Security - Prevent SQL injection. this should be a given, not a main feature in 2015
Late to the party but I think his point was that CakePHP does use composer.
where is the no part? you did not point out anything wrong in my reply. as I mentioned before Zend (as the company) have control over the Zend Engine License: 4. Zend Technologies Ltd. may publish revised and/or new versions of the license from time to time. Each version will be given a distinguishing version number. Once covered code has been published under a particular version of the license, you may always continue to use it under the terms of that version. You may also choose to use such covered code under the terms of any subsequent version of the license published by Zend Technologies Ltd. No one other than Zend Technologies Ltd. has the right to modify the terms applicable to covered code created under this License. but as I also stated they can't update the Zend Engine License used in php-src. the worst thing that could happen is that they release a new ZE License which won't get approved by the php-src devs and they stop contributing and/or request the Zend Engine in php-src to be renamed so that it doesn't contain Zend anymore. Assuming that they can convince the php devs that the ZE in php-src is a "derived work": 3. The names "Zend" and "Zend Engine" must not be used to endorse or promote products derived from this software without prior permission from Zend Technologies Ltd. For written permission, please contact license@zend.com. 
&gt;tested it locally Literally "it works on my machine".
Good suggestions. I'll rename it to Weekly Discussion and have it stickied for the entire week. -Mat
Yes of course.
Either way, if you build this using WebSockets or just using Ajax style refreshing, I would use Redis for storing the data. Redis is meant for queue-able, non-important data such as cache, statistics, sessions etc. You can even set a [Time to Live using EXPIRE](http://redis.io/commands/expire) on Redis keys - this will automatically purge keys after a certain time so you don't have to.
Awesome :)
&gt; In a thread on php-internals a couple real world examples were offered. &gt;* Keeping constants in a parent class private like a Database Username/Password Really? 
I know it sounds funny, and that's not exactly a great example of private constants, but... actually, if you think about it, there's nothing stopping you from declaring your app configuration as a class with private constants which contains a factory method for a connection. I actually do that, the file may be outside the repository, but this doesn't mean it can't be a PHP class. I think it's good to have private and protected constants. I've had to use self::$PROPERTIES_LIKE_THIS when I needed private constants before. Internal bit flags, as the RFC points out.
If you want a quick start, you can use a 3rd party service to host the push infrastructure for you, like Pusher.com. Then if you start getting serious traffic you can host it yourself with Node.JS through websockets. If you want to check an example of a Pusher.com integration, check Laravel 5.1+ (event broadcasting). It'll give you a starting point to use as a reference for your own implementation.
To be fair to the author, they didn't title it "How advanced Routing works". All features you talk about can be added fairly easily (or integrated through existing routers) once you get the *basic* idea. 
Well you yourself said that using arrays for criteria statements is subpar. E.g. that LIKE example
&gt; We're bikeshedding over an issue that has a 0.001% probability of ever happening. 0.001% chance per codebase is very different from 0.001% chance per user session. The first is fun to argue about but ultimately wastes time in most cases. The second though is very important when you have anything close to a large userbase. If you serve 1,000,000 sessions per month, which is not by any means a lot, your 0.001% error will generate 10 bad experiences, which is certainly enough to cause a bad review or other problematic things.
I was confused too. Turns out Light Table is another editor: http://lighttable.com/
There is no public speech API from Google. The speech recognition API is [tightly bound to the Chromium project](http://www.chromium.org/developers/how-tos/api-keys). Check out the big fat yellow warning box at the top of that page. The speech synthesis API, as part of Google Translate, is not a public API and should not be used like one. You'll want to find alternate ways to accomplish whatever it is that you're trying to accomplish.
&gt;Redis is meant for ... sessions Last time I looked into redis for session storage, the lack of session locking was the reason I stopped considering it. Has there been any development in this area?
Fair point, at least it gives some points on what routing systems are and should be able to do in the wild generally. 
/u/dracony, you've been around this sub for almost two years using it as a marketing platform for yourself. Which is, mostly, fine. Good content gets rewarded. But you've made so many posts here that were spoken with such confidence and lacked so much knowledge or understanding that I have a hard time now seeing anything you post without expecting the contents to a grab-bag of the things that I expect to hear from my junior developers on their worst days. Still, I've really tried to go into your threads recently with an open mind. But reading through this thread and your comments in it, where you basically take an absolutist stance that maybe *we* can't deal with framework upgrades and codebase transitions, but *you* can... it's just hard. I really don't want to think of you the way I think of Jeff. Jeff was a junior dev that worked for me years ago. He thought he was the absolute shit, and when his confidence and incompetence got him in trouble, he criticized the co-workers that came to save his ass for causing the problem in the first place. But I still see the same /u/dracony in this thread that [was astoundingly egocentric in trying to explain he wasn't sexist](https://www.reddit.com/r/PHP/comments/2iwzzu/phpixie_logo_is_not_sexist_shocking_proof/), [decided to re-implement FastRoute because he didn't like regular expressions](https://www.reddit.com/r/PHP/comments/2lkjux/do_we_need_regexp_in_our_routes/), [couldn't understand what a reserved word is](https://www.reddit.com/r/PHP/comments/25bo5m/please_fix_the_damn_parser/), [tried to explain to the whole programming community why we were all morons for using Dependency Injection](https://www.reddit.com/r/PHP/comments/1x6y1t/you_dont_need_a_fancy_dependency_injection/), [claimed that no one ever needed CSRF tokens because HTTP headers existed](https://www.reddit.com/r/webdev/comments/35l7t8/simple_way_to_prevent_csrf_attacks_without_using/), [tried to explain to Phil Sturgeon how he was wrong about what OOP was and how Symfony worked](https://www.reddit.com/r/PHP/comments/1ka8bx/symfony2_being_oop_only_on_the_surface/)... I could go on. The point is that I sadly, (and I'm being earnest about that), think that you haven't really changed much. This post read like you heard someone smart make this argument and you're trying to repeat it. Like many of the topics you enjoy discussing, there's interesting things here to discuss. I'm just not sure that you actually want to discuss anything, and if you do, I'm not sure what I'll need to teach you before we can have that discussion. The plain truth is I'm not confident you actually have the experience of maintaining a product's codebase. That's somewhat of a prerequisite to having this discussion.
Honest question: what do you love about the idea and what is the idea? I'm trying to figure out what this does, but I'm not quite sure yet. I feel that a lot of the APIs could be *much* simpler and retain the same functionality. I understand there are two components, Foundation the basic (for a very weird definition of "basic") DBAL, and Model Manager is the ORM. I sort of understand where they're going with "projections", the concept of independent entities and multiple possible mappings appeals strongly to me and it seems like something I have internally, but the API is way, way out there. It feels almost as if they specifically tried to make it look more complex than it could've been.
I see, I'll search another alternative. Thank you.
Yes that's what it's supposed to be. But my first title was a bit misleading because it made it look like it's the only way to go. But the new title "A basic Routing approach with PHP" should give a better picture of what the post is about. Thanks for reading guys.
Looks nice. Any other recommendation alike? I'm thinking of using mysqli or PDO directly for my next site, as I want it as bare, simple and lightweight as possible.. 
If you are not under SSL no method is secure.. Am I right? I'm starting a new site soon for some clients, and like you I'm currently researching about updated and current best secure authentication, but then I often remember they don't have SSL available in their server, so I feel it is worthless the effort.. 
Oh yea that is a good one, surprised we don't have 'scope constants'(?) already since it is a thing in C. I don't think I should include it is this RFC though, I worry it would make people argue and stop the RFC from getting in sorry. I would love to make a patch for it though, and work on getting it in post this RFC! There might be a fair amount of arguing over it though, since you already can accomplish it with static variables. Might be worth starting a discussion first, so you don't get your hopes up and just have it voted out. 
I dont really agree with the "never going to change" thing. An interface may change, whats bad aboyt that ? Ita just versioning
I'll push a fix for this issue very soon
Do not worry about their choice to go with WordPress. Generic CMS solutions offers a very good cost-to-publish ratio vs a home made CMS. WordPress can be extended though plugins and often does not requires a developer to make changes. It is often cheaper/easier for a company to go with a widely popular CMS than to pay a developer in-house to work on their site versus working on the product they are supposed to be delivering.
If you're confident in your PHP skills, then a proper framework like Laravel or Symfony is unquestionably the way to go. Wordpress, Joomla, and Drupal are for developers *not* confident in their PHP skills, or for developers who have *carefully* weighed the advantages and disadvantages of going with a canned CMS vs custom (for example, some light content management with a full ecommerce platform == Magento. No matter how confident you are as a programmer, that simply too much to code yourself in a framework. It doesn't make business sense). The fact that your old company replaced your Laravel work with Wordpress doesn't necessarily mean they thought it was bad - it could have just meant that they needed to make an upgrade and what you built just didn't have that functionality built in, and they didn't have any other developers to spare to build it. Our company has nothing but "senior" developers working for it, but we still have a Wordpress site. The reasoning being is we didn't have the bandwidth to spare, so we let some of our technical PMs + designer (who has some development experience) build and launch the site. You're on the right track for pushing for more Laravel and Symfony. Those are the tools that let you build bigger, more complex projects that you can charge more for. They are also better at building custom CMSs, because Wordpress is just a shitty codebase that's far too frustrating to customize and extend. I think back to all of the Wordpress sites I've built, and it's kind of hilarious how many hours were wasted trying to get Wordpress to be something it's not. Meanwhile simple, straight-forward solutions could have been coded in a proper framework in probably 1/5th the time. But that said, you do have to be a fairly confident PHP developer to make margins doing custom work in a framework vs using Wordpress. The shortcuts Wordpress gives you lose their mileage the more experienced you are as a developer, because you can implement similar things yourself in a negligible amount of time.
Yes, I do know who Rasmus is. I also know that this video is from 2009. In 2009, the current version of PHP was 5.2. Rasmus is quite famous for declaring that he is not a programmer, on more than one occasion. He says in the video you linked that the front controller is a terrible pattern for scalability, but plenty of other developers, programmers, and software engineers would disagree.
Here's my advice - WP is not a measuring stick and even if, not a good one. Unless it is hosted by Wordpress.com themselves, I would not touch it with a ten foot pole. See [this article from two days ago](https://www.reddit.com/r/netsec/comments/3np49r/angler_exposed_generating_millions_in_revenue/) . Every single website which redirected the unsuspecting victims of this ransomware crypto locker was hosted on - WP. Also, company motivations are different than yours as a professional and as such, you will not be measured by their failures or successes. If you didn't take part in or get to influence bringing WP in house, why should you shoulder the mental weight of that decision. What are you good at ?
Thank you for your in-depth answer! After I started using Symfony/Laravel I too laughed at how much time I spent swetting over Joomla, trying to squeeze it into a mold it didn't fit... But still.. I think the main problem that you described for me is that I am not a confident PHP developer... Sure, I'm proud of every project I create successfully, but only if it's a project I did for myself or my 'on the side clients'. Now that I work for a bigger company than before and have to deliver on bigger, and more sophisticated, projects I lose my confidence very very fast. What I think is also an issue is that I don't have any experience writing my own CMS. I always used Sonata/Frozennode or the Symfony GeneratorBundle to make a CMS(/ERP) that functions how I want it to function. But I don't have a guide, a mentor, to tell me what to do and how to do it correctly. As I stated before, I am completely self-taught. The couple of classes I did attend were a complete waste of time, and money... I would love to work in Symfony, day and night, and I know I can make whatever **I** want with it. I'm just not a confident enough developer to push it on the company, let alone build what **they** want with it the way **they** want it...
In fact, there are some business concerns. Managing Wordress site require less skillfull PHP programmers (in the most cases). They are paid less too, which is somewhat good for some businesses, and enough for managing several simple websites. But perfomance benefits that experienced dev can take from switching to Laravel or another framework is also valuable. Not mentioning that refactoring can speed up future improvements. Symfony/Laravel pair is a good choice for a lot of modern PHP projects. If you are working with a team of other devs also weight their skills before making you choice. If you are working alone, then don't even waste a minute but learn about chosen framework - in my opinion, for a developer it's better to move forward as a professional, not backwards to scaling Wordpress. Don't hesistate asking questions here or on StackOverflow to move forward faster. There is not so much you should learn to get started, only a handful of really important themes. http://phptherightway.com, Matt Zandstra's book would be enough to dig into any framework on the entry level. But honestly, the best way to learn Symfony2 is to do it with a skillful team.
[removed]
That is really neat feature.
[removed]
It's pretty straightforward... What is your specific problem? Did your read the doc? &lt;?php $client = SoapClient("some.wsdl", array('trace' =&gt; 1)); $result = $client-&gt;SomeFunction(); echo "Response:\n" . $client-&gt;__getLastResponse() . "\n"; ?&gt; 
[removed]
Thanks! I had seen 'PHP the Right Way' mentioned before, but I thought it was an actual book, not a site. What I've read so far has already been helpful! I saw Modern PHP on Amazon earlier, but was afraid it might gloss over some of the things I'm looking to get caught up on.
You know, this is why you should pick fancy new tech things for your username.
Thanks for the tip, didn't even know that existed!
&gt; Yes, that's why they rewrote the PHP engine for the third time? :) Are you serious? Considering 2/3 of the authors of PHPNG did not work for Zend... Considering that out of the literally dozens of contributors who contributed to the Zend engine 3.0, only one was actually employed by Zend... But yes, they should get credit. Their name is on it after all. Sigh...
In my experience, there is a ridiculous abundance of Java developers (*especially* at universities). Newer developers often apply for jobs using languages outside of their experience, either because they want to explore something new, or they can't find any other jobs. Not a bad thing, in my opinion.
The problem is that we are in a VERY time sensitive situation. I will not hire anyone that is not a PHP programmer. I'm hiring someone to do what i don't have time to do, if i will need to explain everything, and spend a lot of time fixing shitty code, i rather invest that money in redbull and adderal and code myself.
I've decided to email them a ridiculous test. They will have to create a page with bootstrap that asks the user for 10 numbers, and then via Ajax print in a bootstrap modal the min/max/avg value, and the distance of the value relative to the avg. I will give them 5 days to do so. I'm also going to evaluate their ability to use arrays, the design of the page, and their ability to handle errors and validate inputs. And of course, the cleanness/documentation of the code.
This is not a java developer problem, this is a your hiring process sucks problem. I've hired people for PHP jobs that have never used it before, and the language has never once been an issue. Similarly, I've been hired for a rails contract despite never having touched it. OP, if you can communicate what needs to be done, any seasoned developer should be able to make an impact. And if you can't, it doesn't matter what languages they know.
I do get a say in who we fire though... so I suppose that's the "test". Most of the people who know some PHP can be trained in the right way to program PHP. I think the problem comes in when you get a Java guy and they set off to build an application in the same way you would in Java and they get lost in the weeds or expect months of planning before writing a single line. PHP programmers tend to expect instantaneous feedback and fast results.
I know that! But i must hire someone in the next week, no time to do a great search.
You are hiring wrong. You are the problem with the current hiring mentality. I am also about 50% sure you are trolling.
i'm pretty sure any decent dev that knows any language can figure that out in a few hours max.
Well, if any of them DO have the string PHP, hopefully the candidate will know well enough to wrap it in single quotes. 
Dude, seriously?! https://nikic.github.io/2012/01/09/Disproving-the-Single-Quotes-Performance-Myth.html
More complicated than D7. I hope the leadership on Drupal decides to go in the other direction for D9.
http://knpuniversity.com/ do have some good videos. 
&gt; I'm curious are there any objective benchmarks comparing Drupal 8 with Drupal 7? Not yet. A lot of the performance stuff just landed in the last couple of weeks, and more gets done during the RC cycle. That said, Drupal 8 during the betas was underperforming Drupal 7 by 2-4x (though generally getting better with every beta).
&gt; I hope the leadership on Drupal decides to go in the other direction for D9. I don't want to say something like this could *never* happen, but it's more likely we'll find complex life on Mars or one of Jupiter's moons. The Drupal leadership is very, very much invested in how Drupal 8 is designed, and there is so much stuff that is now possible in Drupal 8—that wasn't possible with the old architecture—that Drupal 9 will not come out for at least a decade, if at all. And if/when it does come out, it's almost certainly not going to be a Drupal-7-to-Drupal-8 type change. If you don't want to leave the Drupal 7 island, your hopes are better left directed at [Backdrop](https://backdropcms.org) ever becoming a thing that real people use in real-world scenarios.
I don't understand Backdrop at all? What was the point of creating a brand new CMS that is pretty much D7, yet different enough that you have to waste time porting your site to it?
You nailed the major problem with it and why it'll probably never see major adoption. Drupal has always had a culture of BC breaks every major version, but some people didn't like how much Drupal 8 was changing, so they decided to create Backdrop as their vision of what they thought Drupal 8 should've been. The bet with Backdrop is that people will take one look at Drupal 8, say "nope, not going to do that", see that nobody is supporting Drupal 7 now that Drupal 8 is out, and make the business decision when it comes time to update their old sites that Backdrop is the lesser of two evils. But it's far more likely people not willing to make the investment in Drupal 8 will fall out of the ecosystem entirely by letting their old sites rot or moving to something like Wordpress or Joomla!.
Because drupal does not understand the business side of things
Puli becomes useful once you use packages in and of different frameworks, independent of the actual framework you use. That's the goal: Making packaging independent of frameworks.
I can't say I will miss Drupal. It created a lot of work for no good reason whatsoever and I guess that's the strategy with D8, give enterprise something that will create a lot of revenue for Drupal's proprietors.
Ivona provides a TTS api for developers, it's an Amazon company -- wish they would just make it a part of AWS. It's a bit pricey, but it's a pretty good API
This reminds me of [Joel's article](http://www.joelonsoftware.com/articles/fog0000000069.html). That the single worst strategic mistake that any software company can make: rewrite the code from scratch. 
&gt; Magento has always masked many errors by using an error handler. Sounds like its magento's fault for hiding errors from plugin devs...
This could cause memory problems with very large CSV files. Streaming, chunking or the method described in the tutorial are far safer approaches for such a task. 
Sorry, but this is possibly the worst thing you can say about D8. I don't know if you've been in any conversation with a Drupal core contributor or a conference, or anything, but restructuring Drupal to be a modern CMS with modern PHP development practices is *essential* for its survival. The decision to do this was the right one; we're not going to attract modern developers using design paradigms from over 10 years ago. It's funny that you say "more complicated" because in a lot of places, it's been made simpler. Just look at the themeing layer.
What they have done is make a cluster fuck of Drupal's 10 year old design, which was wrong to begin with, and Symfony's overcomplicated MVC. I don't want to touch this thing with a 10 foot pole. I like the simplicity of Laravel or Yii2. If anyone thinks that this is going to attract any modern PHP developers to Drupal, there is something terribly wrong with them and their intellect. 
They didn't rewrite from scratch. They just made it OO. Almost as big a commitment though.
&gt; Every feature he, or the client, asked me I tried my best to deliver it as good as I could. And I always did, eventually. Maybe it didn't always look too good, code-wise, but it worked and the clients were happy... That's a very good trait, but also a dangerous one, because that sounds like "I get shit done, no matter how fugly", which easily leads to huge technology debt. Sometimes it's okay to say "That's not possible in the way you imagine, but we could instead do this, which would be much more maintainable". &gt; I don't have the confidence to say "I will make everything using &lt;insert CMS/Framework&gt;". That's actually a good thing, because it would be stupid to try to press everything into one CMS/Framework. Different situation demand different tools. And that means sometimes you just need a wordpress page, sometimes you need a framework, and sometimes a framework would be too much, but a CMS doesn't fit either, so you cobble together some composer packages and create your own little thing. The vibe I'm getting from your posts feels very similar to where I was about three years ago. I was working in a little web agency with another php programmer. We were both the same level, so we hardly ever learned new things. Then I switched to a bigger company with about 20 programmers and in the first six months I learned more than in the six years before. Mainly because I could rub minds with people who were waaaaay advanced to what I'd done so far. So my suggestion for you would be to find a way to rub minds with people who have more experience then you. Be that a regular php user meetup or whatever. Because the best thing you can do for yourself is to continue growing. Web development is a fast moving target and what's a great solution today might very well be "Ugh, I can't believe we did that" in two years. If you are comfortable with Simfony/Laravel now, use it. But don't stagnate. Keep your eyes open, learn new things, and if one day you find "Laravel 12 can't do for me what I need, but SuperFramework2020+++ does it just fine!" switch to that on your next project. I think that's also what you should tell your bosses. "We'll use X for now, but as the playing field changes we will change our methodologies". That's the only sane choice.
Alright this is not my own article, I just find it very interesting and referenced it from Mathias Verraes's website. I personally like this DDD approach a lot better than CRUD on anemic domain models. What do you think? 
I really like this theme, but it hides inspection warnings/errors like "method not found in current class". I would like to have like a squiggly line, but I can't find the right setting. Anyone got any clue?
Laravel is built on Symfony - so if do laracast option, you will touch on quite a few points on how this are approached / solved with the framework.
Magento doesn't hide the errors. It logs them to a file, which unfortunately few people think to check while writing new code.
CRUD maps very well with your typical data persistence commands, eg SQL; C = INSERT R = SELECT...where id = ... U = UPDATE...where id = ... D = DELETE...where id = ... To say using those SQL commands or CRUD in general is an anti-pattern highlights a misunderstanding of what CRUD actually is. Encapsulating business logic, which seems to be what the article is actually about, is good practice, but at a basic level; the author's $order-&gt;pay($customer, $money) method would really be an Update, or Create if the $order object hadn't already been persisted.
If it doesn't display them to the developer while in non production mode thats as good as suppressing them entirely.
Because the Drupal content management tools are flexible enough to manage the most complex use cases. I work on a site with 300 content editors and 4 levels of approval before something gets released. There are a lot of enterprise cms's but they (generally) cost a fortune, and its hard to share custom development between instances of them. Drupal's module system enables this. Also can you name any other open source enterprise cms worth looking at? See the Australian government's GovCMS solution for an example of how you can have many different use cases sharing the same code. Note that I'm not trying to defend Drupal's frontend here, personally it frustrates me and I think separating the front and backends is going to take off big time for Drupal. Once we get some nice Angular libraries built around Drupal's built in APIs app development will be super fast. Perhaps the most exciting thing about d8 is that we have no idea the limits of what the new architecture makes possible, and what sort of innovation we will see in the contrib space. Given the pluggable nature of things it might even be possible to yank out all the complexity and make something more wordpress like and make it more usable by the little guys. Sorry rambling..
It is available in book format as well. https://leanpub.com/phptherightway/
Try http://blackfire.io , it will show you everything there is to know about what's happening.
You could try reading &gt;/etc/*-release Also: This is not a support subreddit.
That is nice, but is overpower! I just wanted some analytics, like request per endpoint and stuff like that! Thanks anyway!
To turn your functional code into something professional and modern, while also learning best practices, I would recommend [Modernizing Legacy PHP apps](https://leanpub.com/mlaphp).
No one is going to use Backdrop. They just wanted notoriety for being the first people to really fork Drupal. There is no way in hell I will bother learning how to use it nor entertain any bid asking to.
Exciting. I just finished writing the static code for my personal website. Maybe I'll try to create a theme in Drupal 8. 
&gt; They just wanted notoriety for being the first people to really fork Drupal. Really? Are you involved in the community (?), because I've never heard that one from anywhere. They basically made themselves pariahs with this fork. I'm not sure who thinks that kind of notoriety is beneficial to their careers, but it's not the folks who created Backdrop. The point was to create a more understandable successor to D7 should D8 flop, and if D8 flops it's going to have been a really smart move.
As a seasoned professional with more than 15 years in the business, I'll say you make a mistake if you pass on an experienced engineer simply because they lack a string on their resume. Learning a particular language is relatively trivial. Learning to code is what's hard. I've done probably hundreds of projects in PHP. I've also worked in .NET, classic ASP, Python, perl, c/c++ and some Java. The past 5 years or so have been largely Ruby. JavaScript should go without saying. What I've learned is that under the skin, languages have more similarities than differences. Sure, some have [_special features_](http://i.imgur.com/FigQvTh.jpg), but there are MANY commonalities. If you've been paying attention, you should at least have some awareness about the odd bits of the various languages in common use today. I don't consider myself a language specialist. I'm an engineer and any language is just a tool. I'll learn to use a new tool very quickly. But if I didn't already know how to _code_, I'd be nothing but a liability to your organization. Change your thinking about hiring. Hire engineers, not strings on resumes. Hire people who show a history of _solving problems_ with code ... not the guy who's good at rattling off things he's memorized. For instance, when I interview a candidate, I _never_ specify a language for white-board exercises. I let them choose what they're currently most comfortable with ... even pseudo-code is acceptable. I'm not interested in whether he's memorized a bunch of libraries or esoteric control structures. I want to see how he thinks about solving the problem presented.
@qxxx The animation shows the integration of PHP with Light Table. The editor natively allows inline code evaluation for Clojure and ClojureScript. Support for other languages was brought progressively via plugins. The very first step of this project was about to render the standard output (or uncaught exception) from the evaluation of a script selected using the connect bar. The next step would consist in evaluating arbitrary expressions instead of the whole editor buffer. 
Depending of the incoming i can send you a working example till lunch time! Seriously. You should ask for a full stack test like doing some crud operations (and some data relationship), with some framework and deploy with vagrant or something. I worked with PHP in the past and i still do some freelancers with it but my main language is Java and, now, i'm working with Ruby. And a more complex test would be great to see how they do things.
&gt; `/etc/*-release` So I have to use `exec` for this? I'm sorry, will post help requests to `/r/phphelp` in future.
A lot of PHP projects also borrow a lot from Java, Doctrine2 and Hibernate for instance.
Enums are not far away, methinks. There was a discussion on Internals about it recently. Here's a work in progress RFC: https://wiki.php.net/rfc/enum.
https://www.reddit.com/r/PHP/comments/3nummc/rfc_under_discussion_class_constant_visibility/cvsfy3l
It would be worth, how you are utilizing it. Worth for me may not be worth for you or someone else. But I do recommend it for you will not loose anything, but only learn something better.
Ok, thanks. I'm just trying to learn how to write web apps in PHP. I think I'd like to specialize in a few frameworks and at least be familiar with some others. I just didn't know if these videos were worth $25/month, I'll take your word that they are.
IMO, KnpUniversity is the best Symfony tutorials I ever seen. I think it worth. BTW, you could check some free screencasts on KnpUniversity to understand you like it or no.
There are reasons other than performance to use single quotes.
http://phptherightway.com/
You monster!!! What about the carbon footprint?! Java resume stack, meet my nephew crayons.
Priorities dude... reddit &gt; work &gt; eat &gt; sleep [repeat]
Not OP, but... From the doc : combineTo $a = A::create(['a', 'b', 'c']); $$a-&gt;combineTo([1, 2, 3]); $$a-&gt;toArray(); // [1 =&gt; 'a', 2 =&gt; 'b', 3 =&gt; 'c'] combineWith $$a = A::create([1, 2, 3]); $$a-&gt;combineWith(['a', 'b', 'c']); $$a-&gt;toArray(); // [1 =&gt; 'a', 2 =&gt; 'b', 3 =&gt; 'c'] `CombineTo` take an existing array and change the keys to the array passed as arguments and `combineWith` take an existing array and change the values to the array passed as argument. The name is not clear (maybe something like `replaceKeysWith` and `replaceValuesWith` would be better), but there would be no way to distinguish behaviors if there was only one combine method. The multiple interfaces provide code extensibility as you can reuse the interfaces to implement your own version. You can also specify which part of the class a certain method uses. It provides a form of contract and enhance flexibility. Also, see the [Interface Segregation Principle](https://en.wikipedia.org/wiki/Interface_segregation_principle).
That would be great! However that RFC is not accepted yet (and unfortunately it's a topic that's been discussed on an off for years as you know better than me) and even if it was accepted it would be available in 7.1, so userland implementations are still useful for some time ;)
Private constants are still under discussion, so there is little difference in that sense.
Some places are not even legally allowed to delete data, and others want to keep the data anyway. So often you don't even need delete. If you use event streams then you don't need update either. So… yes, you can avoid CRUD (specifically UD).
The market to me is companies that bought into Drupal but are either having a hard time finding the funds to upgrade their site to D8 or having a hard time finding D8 devs because D8 uptake isn't there. I think their chances are slim, but crazy stuff happens. Like I said to begin with, if D8 tanks then Backdrop is going to become a much more attractive option for the current developer pool. edit: it's not philosophical, it's just business. You spent all this time learning these skills that D8 is going to invalidate. If D8 tanks, then those skills need to move into something else, and Backdrop could provide an option for developers and businesses.
Am I correct in thinking this is useful for the following: * Migrating Assets for Sites that are load balanced/on multiple servers * Distributing content to Devs/Workforce remotely * ? I use Gulp(/Grunt) for asset generation so what I'm working on locally is not whats distributed to the server (css min/spritesmith/js-concat etc). Most production files are stored as PSD/ESP/Uncompressed and then downsampled to whatever is needed. Most projects 1-10gb of assets. How would Puli manage this?
So we do agree that the method names use are not clear enough because I'll have to go look every time in the doc before using them. I am well aware of the Interface Segregation Principle. But to me the number of Interfaces failed to properly address the package main issue. Let's take the `A::unshift` method with the current codebase to explain my problem: use Arrayzy\ImmutableArray; use Arrayzy\MutableArray; $immArr = new ImmutableArray([1, 2, 3]); $mutArr = new MutableArray([1, 2, 3]); $altImmArr = $immArr-&gt;unshift(0); $mutArr-&gt;unshift(0); echo $mutArr, PHP_EOL; //expect '0, 1, 2, 3' echo $immArr, PHP_EOL; //expect '1, 2, 3' but I get '0, 1, 2, 3' echo $altImmArr, PHP_EOL; //expect '0, 1, 2, 3' var_dump($immArr === $altImmArr); //expect 'false' but I get 'true' To be truly immutable the immutable class should **never** change but must return a new instance with the modified data where applicable. Yes, both classes share the same public API signature but they do not share the same interfaces. This is the same problem you face, for instance, with `DateTime` and `DateTimeImmutable`.
Personally I like $order-&gt;pay($customer, $money). My reason is that between these two domain models, Customer(a user entity) is more generic, reusable and portable, while Order(an order/item entity) is more specific to the underlying application/business. Wherever this pay method will be, it makes its containing model dependent on the other model being passed as parameter. An order needs a user to exist and cannot be ported to another project in isolation anyway, but a user does not need to make an order and can be ported anywhere else just by itself. All kinds of web applications need a user, but not all of them need an order(such as blogging sites). As a result, its better to make Order dependent on Customer(the order is already inherently dependent on customer anyway, likely through a foreign key column), than the other way around. 
You are right that the immutable classes should be deterministic. Every time you do $immArr = new ImmutableArray([1, 2, 3]); $immArr-&gt;unshift(0); you should always have `[0, 1, 2, 3]` as result even if you call an other `unshift` on the original class, the parameter of the call should be the only element added.
&gt; Personally I like $order-&gt;pay($customer, $money). My reason is that between these two domain models, Customer(a user entity) is more generic, reusable and portable, while Order(an order/item entity) is more specific to the underlying application/business. Yup, I fully align with that thinking. &gt; Wherever this pay method will be, it makes its containing model dependent on the other model being passed as parameter. It's not the same however. You need to modify Customer when you add another model, while with the approach we both prefer, Customer can be *used* in another model, but Customer doesn't have to know about it. Or more specifically, $customer-&gt;pay() is *circular coupling* (customer depends on order, order depends on customer internally), while $order-&gt;pay($customer) is *coupling in a single direction*, which is always preferable. Also I tried to hint that this idea of passing models into other models really doesn't pan out in larger apps. You pass tokens and ids instead. Why load the Customer at all, when what you need to pass is a token? Pass the token, then you don't need to load Customer at all. &gt; As a result, its better to make Order dependent on Customer(the order is already inherently dependent on customer anyway, likely through a foreign key column), than the other way around. Yup.
[removed]
There is no one true path for any language, IMO. And what path you take with PHP is a combination of what sort of application development interests you in conjunction with your coding style and preferences (as PHP offers many ways to do the same things). So if I was you, I'd look at what kind of apps you're interested in developing and then take a look at what PHP has to offer - including the various PHP frameworks like Laravel, Symfony and Zend. If you want to build your own custom CMS, you'll take a very different path than if you want to build a web service that provides real time real estate market data via an API. In general, I'd strongly advise looking into design patterns, as PHP is so flexible that it's easy to produce bad code - I liked [O'Reilly's PHP Design Patterns](http://shop.oreilly.com/product/0636920028062.do), for a place to start.
And when was the last time you actually looked at the drupal 8 core? All those theme_ functions are gone and moved into twig templates except two in the admin part, but those two are on the kill list from the twig team to. 
Sounds like a initial plan. Thanks!
&gt; PSR-2, write code that adheres to them No one will ever force me to put opening curly braces on the next line. *No one, I say!*
I've been thinking about another aproach as well. Yes you have a User, but that does not always mean Customer. So what if you have different objects representing the different roles of the ultimate User. Imagine you have an app that offers payment ( where you have orders and products and stuff ). You also might have other parts in the app where the user can post reviews. What if, on top of the User ( which would kinda be the class responsible for authentication and similar things ), you also create Customer and Reviewer classes which kinda are coupled to the use case of their own "module". So you can create a Customer class based on a User, and use it just like prorposed on the article, in the context of the module of payment. This idea for me has been in my head for a month or so, I haven't really started to implement it in my production apps, but I have a new "hobby" app I want to build and I will try to follow this approach in every module of the app. This way it will be much easier to do roll based stuff in the app. So instead of doing stuff like "if($user-&gt;hasRole('administrator'))" I would just instantiate and AdministratorUser object and be able to call staff like Administrator-&gt;banUser($user) without the User class it self having the banUser method even though it might not have the actuall capability ( not being administrator ).
I know, but my answer remains valid. Also - when they created the standard - didn't the obvious inconsistency strike them, or what? (...the hell) :)
Depends what you want to master? Phpwtfs and know all the inconsistencies? The ecosystem and all the frameworks? The best practices? But to be honest, it's kinda a paradox, but the thing that helped me become better with writing PHP was learning other languages. ;)
I think you make a point too, but can you enlighten me on why the domain logic for user banning should be inside Administrator domain model? I think the user banning logic should be inside the User model in general, since the operation is essentially mutating the internal state of a User model. It's better for the User model to manage its own state, as opposed to administrator acting like a service provider/mediator. Unless, of course, you need certain information from administrator to ban user(ie. if you need to show the user which administrator bans him/her), but I doubt its necessary from realistic point of view. 
Somehow seeing "WP" and "quality interfaces" in the same sentence makes my brain hurt.
This is what I'm most curious about. Just because they used object syntax, doesn't mean it's OO design. And even if it's impeccable OO design, that doesn't mean it's a good tool for your use case. A tool built to fit myriad undefined use cases is a tool that will fit none of them particularly well. I remember one of the original architects of Drupal saying "Drupal is almost always *a* tool to solve a problem, but almost never *the right tool* to solve a problem." (paraphrasing).
I think CRUD can be treated like a lower-level infrastructure layer that the Domain layer can utilize - I don't think they are mutually exclusive approaches to the same problem. That said, when I work with active record, I tend to follow a similar approach to this article. I tend to encapsulate the infrastructure parts of CRUD, and expose only a public interface that better describes the intended behavior of the object. Not because I'm trying to pretend that I'm not using active record, just that I want it to be clear to other developers *how* the AR model is meant to be used.
&gt; paving the way for higher quality interfaces on your legacy databases All right, I'll be the person asking the stupid questions this time. How is a REST API "paving the way for higher quality interfaces on your legacy databases". I read that a few times and I don't understand what this sentence means.
Don't be discouraged because your site is replaced by wordpress, it's usually because of maintenance costs - which can be 0 in wordpress thanks to all the 3rd party modules. Those same 3rd party modules, however, are the reason why wordpress is considered insecure, because WPs main code base is better than what you and I can achieve, but 3rd party modules can be made by anyone in any way, and are usually the main entry point for a breach. About learning suggestions - I have a few: 1. Talk to people about programming / infrastructure / 3rd party libraries. When someone explains something to you, try to explain it back to them. They will correct you if you're wrong, and it will cement the info in your memory. If you are alone in the company - ask them to hire a junior that you can train. This will have the same effect. 2. Try to be a programmer that uses PHP, not a php programmer. Try a second language just to see differences of approach for various problems. I quite like Python, especially it's multithreading capabilities (which are almost absent in PHP). 3. Take the Zend certificate - it will force you to go through a lot of the manual, and learn about the existence of features and concepts you may not know exist. About frameworks, I recommend Symphony for medium/large applications, and Phalcon for APIs or small apps where performance is critical. You can defend your choice for Symphony with: "It's a mature framework with a big and active community, I have successfully worked with it on various other projects, and it's versatile enough to work on both small and huge websites - best example I can think of is youporn :)" Good luck!
I figured it out. That user modified his brain to run with memcache, and we now see the results.
PSR-2 is NOT necessary PSR-1 and PSR-4 should be what to look at first when it comes the PSRs making sites in different frameworks is a great ida so add to /u/ihsw list Laravel and Zend
http://www.phptherightway.com/
Yeah, that's super exciting! Is there a good way for a non-internals person such as myself to provide feedback (other than PM'ing you, seeing that you're the author)?
Yep. There's a lot of legwork involved but a *master* should have no issue moving from one framework to another. And I agree with the PSR point you made, it's more of a guideline.
2005 called, they want their code back.
See this list https://laracasts.com/recommended-reading
&amp;action=remove ...? Nope
There is really no point in lying, since the amount of work would be roughly the same anyway. To estimate the time you would need to know your download speed, which already requires inspecting the download connection. So file_get_cotents is out of the question anyway. Which leaves the easiest solution to fork a downloading process and monitor it. The actual solution is to shell_exec wget, redirect its output to a temporary file. And then read that file in a while loop extracting progress information from it. This sounds complex on first glance but is actually about 10 lines of code
Curious, how is the problem of performance addressed with these enums? Having every enum in its own file, and be a full class... sounds slow in several different ways.
 &lt;html xmlns = "http://www.w3.org/1999/xhtml"&gt; For real? Is PHPClasses like a remote island that time forgot?
Probably it was not the best example as CQRS mentioned, but i just wanted to illustrate the idea of having functionality for a special case of a user ( or basically a user with a role ) isolated from the basic user. 
Interesting, thanks, but that's a paid service. I should have mentioned the whole source code available thing...
So who knows wtf, I'm hardly an expert but I really don't like any of the examples in the article. There's an entity (or many) getting lost in the mix. You don't generally pay an order, you pay an invoice. An invoice could have a bunch of line items with multiple orders on it, or an order could span multiple invoices with multiple line items, who knows! It's also SUPER common to have an invoice with multiple payments on it, for different line items, or just because. I actually have absolutely no idea what a good solution might be, because context is everything and the example gives very little to go on aside from some hand wavy relationship between orders and customers to try and establish some kind of boundaries for the experiment. It's hand wavy enough, and has raised enough questions in this thread already, and in the article itself, that if we were spit balling and I were writing code on a napkin, I might throw this down to account for many possible types of relationships and payments and gremlins. $invoice = $order-&gt;invoice($customer); // Because reddit says value objects are the cats pajamas $payment = $invoice-&gt;pay(new Money($invoice-&gt;balance(), $invoice-&gt;currency())); // Because completeness $mailer-&gt;send($payment-&gt;mailableReceipt()); This implies a relationship between $order and $customer through a $invoice that is not at all well defined, on purpose. That's an implementation detail that could change without impacting the API of any of those entities. Same goes for the invoice and payment. Makes sense that the payment would belong to the invoice, but maybe it belongs to multiple invoices. That's not important for this code to work and could change later without breaking BC. FWIW, I don't even like those entities, I'd rather have stuff wrapped up in a payment processor and a lovely little anemic namespace but I'm trying to stick with the theme of the article. 
&gt; though perhaps PHPUnit is very close to JUnit? Pretty much any "XUnit" testing framework is inspired by JUnit https://en.wikipedia.org/wiki/XUnit
Just add `final` to properties instead of messing with constants?
You should be able to append anything to a jpeg, the header has a length stored in it and everything after that should be ignored...
Well, of course the example is simplified, and your example is also simplified, because you might want to have an entity to track the specific monetary transaction that fulfills the invoice, etc. But the point was, no matter the context, $customer-&gt;pay($order) is almost always a bad idea. And I say "almost" just to hedge my bets, not because I can point out a good exception. As for the entities, they're too scattered for my own taste, as well, but I guess that's a topic for another thread.
&gt; Make an AngularJS-based web front-end to that Symfony website What's that got to do with mastering *PHP*... Aside from that your reply seems to be "master symfony related things". There's a world of other stuff out there to learn.
I agree with what you said. However, from the *hiring* standpoint picking someone with only college experience and no side projects of any kind has more risk. From my hiring experience I would much prefer candidates with only personal projects and no formal training over somebody with only formal training.
&gt; This is not an issue. The files should be in opcache. There is not really much performance hit for these being classes over something simpler either. The opcache doesn't eliminate the overhead of loading a lot of files entirely, the only way to see what's going on in practice would be a benchmark. And don't you agree inner classes can produce more cohesive classes, if the enums are defined inside the class using them? &gt; What happens if the $enum doesn't end up being an enum? They just get ignored? TypeError, of course. The purpose of type safe enums is to type hint for them. If you don't and then attempt to use them as enums, then you'll get what's coming for you. But in the common case, it'll allow for more readable and succinct code. It works great in Swift.
I think what you are looking for is a mDNS (Multicast DNS) service to run on the device that will announce the services it offices to other network devices. 
It is just the inconsistency why this rule is chosen, it makes it easy to distinguish opening braces that denote a class of method body, and braces which define control flow bodies. 
is there a way to patch xml-rpc to protect against this?
I think you are worrying too much about choosing a framework. This is one of the rules - just go with something and stick with it. At one of my jobs I rewrote critical piece of a system from pure PHP 5 to the Yii 2. It's not that hard to rewrite something from Laravel to Symfony either, and if in the future you will decide to do it - that's not a problem, especially when you're working alone. They are all looks alike, you just need to choose one and practice with it a lot for year or two and you'll catch that idea. Framework is just a collection of patterns, components and rules to help you to build things. If you want to save your time, write code that other developers could understand easily and don't reinvent the wheel all the time, go with some framework. The good way to dive into Symfony 2 as a starter is https://knpuniversity.com/, you can find some of their stuff for free, just google. ZF is now not so popular as it was in old good times of ZF1. If you are not sure in your Symfony skills, I'd suggest you to choose Laravel. Anyway, whatever you choose will be good enough (mabe not optimal, but you will learn to find optimal decisions only with experience), you should just like it and stick to it (cause every framework has it's own cons, and you'll never find an ideal one). You'd better connect with other PHP devs in your local area/chats/IRC/Stack Overflow/here, read a lot and you'll become much more confident! I also suggest you to find meetups/conferences and to go there and talk with other devs. I was only PHP developer at one of my past jobs too, but the feeling "nobody here knows how to do this, so I need to reach out to the others" helped me to move forward and connect with the rest of the community. You'll gain your confidence with getting more experience.
I had a problem where someone was doing something similar to one of my sites years ago. I made a fail2ban rule that said if you hit that xlm-rpc url more than 5 times in a one minute period to block that IP for 20 minutes. That fixed the issue. Maybe you could do something similar.
Each one's path are reflections of their own professional and personal history. Difficult to answer your question. Focus on accumulating programming experience (10,000-Hour Rule)
Isn't this a typical case where attackers are trying to find another attack vector when the admin login page is (hopefully) often blocked or rate limited? I guess in this case where you can do multiple queries per request, you should have the rate limiting in place for both, the requests and the total amount of queries.
Thank you for your suggestion. I just created [PR](https://github.com/bocharsky-bw/Arrayzy/pull/18) to change names with something clearer.
Hmm, at first sight it's a nice idea! I just opened [issue](https://github.com/bocharsky-bw/Arrayzy/issues/19) based on it, but I need ponder about it a bit and let you know, thank you!
Right there with you. I refuse to do it. Its ugly as fuck
Correct, but I think this is an implementation detail. Perhaps there is no real delete or update taking place in actual storage, but on the above conceptual level, you generally still update or delete stuff.
 * Edit xmlrpc.php and put die() near the top. * Use an apache rewrite rule to block requests to it. * Add something like : if(function_exists('add_filter') &amp;&amp; !isset($_GET['w3pcloud'])) { add_filter('xmlrpc_enabled', '__return_false'); } to wp-config.php - which should block xmlrpc requests. * fail2ban (look for requests to xmlrpc.php, but note, attackers often request http://site.com/xmlrpc.php/xmlrpc.php to try and get around simple regexp blocks. * Add a auto_prepend file via .htaccess, which checks whether it's a request to xmlrpc.php and selectively allows it based on whatever. 
I'm missing OctoberCMS from that list, which is a shame. It's been gaining a lot of momentum the last year, and rightfully so. 
I've had to deal with the same thing. Front end work is quite tedious. But we think that because we like the don't repeat yourself, make it and move on approach to the backend stuff. Some of the things I've found that make front end work better for me is; I write JavaScript like I do PHP. I'll make an object and give it methods by simply adding to the objects prototype. It really makes front end JS feel more backend-ish. I use SCSS for all my CSS, it's less tedious and has a programming feel to it, since it's got variables, include, mixins, and thugs of that nature. And well, there just is no getting around HTML. But I only write when I need, as vanilla as possible as I use SCSS and JS to really support the HTML. I rarely use brower or node. I'll install my dependencies manually. I do sometimes use gulp, but very rarely. Mostly I rely on things like file watchers in PHPStorm to compile my SCSS file. Another thing I do to make front end work better is use Smarty or Twig as a front end template system. That really helps a lot. In laravel I use smarty. In symfony I use twig. As far as your controllers. I don't know much about your project but, you could think about all your needs at once, then lay down the code for your controller to handle your REST calls and your UI routes all at once. At least that way you're not going back and forth, which, to me, really makes it feel like it's just dragging on and on. Or could you have two different apps? One that's pure REST api, and one that is just a dummy front end? I do feel like you might be taking a step backwards by throwing more technology at something that isn't a problem though. Angular JS seems like something you might not need. You really should decide if it's actually solving a problem you have, or are you using it because you're trying to stay away from the tediousness of traditional front end work. Maybe you can find someone that would like to help out on front end? Either way, don't get discouraged, if you've got a good idea, go for it!
I still don't know if my CMS is ready for the cloud...
My god, there are so many things wrong with this, about the only thing it does *right* is use PDO instead of the mysql functions. I mean shit, the meta keywords tag has been useless for [over a decade](http://googlewebmastercentral.blogspot.com/2009/09/google-does-not-use-keywords-meta-tag.html), come the hell on. 
Is your CMS running on a server right now? Congrats. It's running on the cloud. Is it running on your local computer? Congrats, it's running on a local cloud. Is it running on a computer somewhere in the known universe? Congrats, it's still on the cloud. The cloud is just someone else's computer.
A (single) server or your local computer does not scale horizontally. Most legacy CMS don't support this "feature" out of the box. They heavily rely on the local filesystem and are not designed with "the cloud" in mind. 
www.phptherightway.com
Yeah, you're right, guys. I think it could be consider as a bug so I created an [issue](https://github.com/bocharsky-bw/Arrayzy/issues/21) for it.
Not being able to leave a trailing comma would be annoying though :/
You can still use framework features the "apple way" and not turn out like googles monsters. You put too much decoupling when in the real world, businesses don't have time for you to worry about your code being perfectly decoupled from the framework. They want features now.
cough spring framework cough.
The important question for people to be asking with WordPress is: Why is wordpress getting a rest API at all, what am I going to do? Query the posts for my own site .... sounds .... redundant?
When I am in that spot, I just make it look ugly (quick and dirty HTML and CSS), get functionality up and running using PHP and JS or your language of choice, then I focus on making it beautiful. I don't bother learning frameworks because you can always refactor a project later that takes advantage of framework benefits. If you're spending time learning frameworks, you might be wasting time that you could be writing code for the project. I spent a few years learning a bunch of frameworks and such and ended up never using them and forgetting everything about them.
We using private security log + custom filters for intruders like attacks. https://dl.dropboxusercontent.com/u/2508926/private-security.png Here is a log of just different script kiddies who trying to hack us. Maximum 3 tries per IP than IP banned for month or so... Fully custom build of activity monitor + security + users audit tool. no issues since 2012. P/S/ xml rpc disable if you need. `add_filter('xmlrpc_enabled', '__return_false');`
Not a helpful reply in anyway what so ever. I bet you call these tools 'bullshit' because you don't know how to use them I don't subscribe to ALL the 'hype' tools either, but calling them bullshit is a sign of ignorance.
There is some genuinely nice stuff on phpClasses. This is one of the many shit ones....
Wow. I had seen bits and pieces of this narrative unfold over the past year and had no idea it was resolved. I'm really looking forward to PHP 7!
The new CSPRNG feature was made possible by the Herculean efforts of [lt](https://github.com/lt) and [SammyK](https://github.com/SammyK), and the exceptional change in RC3 was driven by [trowski](https://github.com/trowski) and [ircmaxell](https://github.com/ircmaxell).
I'm not aware of any writeups from these companies talking about the challenges that Active Record created for their business. Do you have any evidence for your claim that it "ends projects"? I think that sort of propaganda is extremely harmful to the community.
&gt; I'm not aware of any writeups from these companies talking about the challenges that Active Record created for their business. I was insufficiently specific. I am looking for their *technical* reporting, not their *business* reporting. Are you aware of any? For my part, I am aware of technical reporting from people more experienced than myself stating that Active Record becomes more of a pain the more you use it. Such reporting confirms my own experience with Active Record on multiple projects as well. One example: http://www.mehdi-khalili.com/orm-anti-patterns-part-1-active-record/ Another example, in two parts: Cake moved away from Active Record in its earlier versions and toward Data Mapper in its most recent version; likewise, Doctrine moved away from Active Record in v1 toward Data Mapper in v2. That's another indicator Active Record may not do that well in long-lived codebases. But perhaps they're all propagandists too, who are "extremely harmful to the community."
Is it made of water?
JS+CSS+HTML still work, so does PHP4 and 5.2. Just as there are lots of good reasons to use PHP 5.3+, there are plenty of good reasons to want to use other tools as well. Use the right tool for the job.
You are starting over. The tools you mentioned are part of a contemporary javascript &amp; node js workflow. This is as sophisticated as any PHP will get. I use Foundation. It's way easier than the options you listed and does a lot: http://foundation.zurb.com/docs/ You can even use Composer to install it: "require": { "components/foundation": "5.5.*" "config": { "component-dir": "public/components", "component-baseurl": "/components" } Easy to get up and running, Sass/Less compilers can be integrated into your workflow later. Good luck. 
I've used smarty for like 9 years now. That's one reason. but I also like the portability of the templates. if I use blade then decide later to move to a different framework, or remove the framework all together, I'd have to either rewrite all my templates, or shoehorn blade into whatever it is I'm wanting to use. Not to mention PHPStorm does smarty better than blade (well it did when I started the project)
Hi there /u/qu1m, I think this would be better in /r/forhire - this sub is for news and articles. 
Using Angular is a bad idea at this moment as v2 is rewritten from the ground up, but not stable yet, and any project done in Angular v1 right now will be stuck with an abandoned version of a framework which the community has consensus about wasn't that great to begin with. Excessive complexity, questionable features, inner platform effect. As a PHP developer I'd suggest try React. The stateless approach to building views is very similar to PHP templating and the component itself is drastically simpler.
It's still a strange problem to discuss, because a CMS system is read heavy and write light. Add a caching proxy on top of *any CMS at all* and boom, infinite CMS horizontal scalability. A CMS concerns itself with managing content, scaling reads is a separate concern, which can be solved independently. Also the advice "sessions must be centralized" is the opposite of optimizing for horizontal scalability.
Thx for the step by step explanation! I will surely look in to the Demo you linked.
Previous post was here: https://www.reddit.com/r/PHP/comments/3i8urx/i_just_released_a_package_i_worked_on_for_another/ If anyone is interested in contributing I am more than open to outside contributions. The library is released under GPL v2 and follows Semantic Versioning (now that 1.0.0 has been released). The next major version will occur when I rip out the MathProvider and turn it into its own library for dealing with statistics math and large number math in PHP (which will probably depend on ext-stats). [Contributing Guidelines](https://github.com/JordanRL/Newton/blob/dev/CONTRIBUTING.md) | [Changelog](https://github.com/JordanRL/Newton/blob/dev/CHANGELOG.md)
Is all this just so you don't have ActualController extends BaseController extends SymfonyConttroller ? Seems like the complete wrong use case of a trait to me.
ie. compass
I'm not sure how is job market in Brazil, but this is not the way to go here in San Francisco. If I'm looking for a job, I at first want to talk to company about project, my skill set , what they are looking for, to see if there is mutual match. If everything sounds cool, I'd do small test project, but definitely not as s first step. I don't want to invest few hours of time and energy into something what I don't know anything about. If I'd be doing this for every company which I talk to when looking for a job / project, I would spent way too much time doing free stuff for companies which I never want to work for
I feel that the functionality of WordPress is very quickly and easy to replicate within a framework, and will be far more extensible for business needs beyond basic content management, however, it's really the out-of-the-box dashboard that WP provides that is the selling point. People are familiar with it, and it is very polished and easy to use. To build anything comparable from scratch would take significant time.
A trait is for horizontal re-use without inheritance. But if your helper functions depend on functions of the Symfony controller class, the inheriting from it is the *only* way to ensure that those required functions are in the classes. Putting it in a trait is a lot of obfuscation that'll just make it harder to debug in 3 months.
Yeah I guess that makes sense. I'm not even sure why I wanted to do it now.
I've read a few articles recently that suggest the use of an abstract "Base" class is a minor code smell, because it ends up being a poorly-named catch-all for code that only some descendants use. So rather than `BaseController` having a bunch of generic utility functions, define more expressive traits for them. For example: class FooController extends BaseController vs. class FooController extends SymfonyController { use GeneratesXmlResponses; }
Genuine question: What would you use this for? Any application I can think off has another language as best tool for the job. 
It's more complicated if you make it so. That being said, it's perfectly fine to use HTML/CSS/JS without angular, react, etc. just, because everybody is using it now. These are phases which will pass and technologies that are truly innovating will stick. Just remember when PHP without a MVC framework wasn't considered PHP... Nowadays you can toss together a simple project from independent packages, really fast, without using MVC at all. It has to be noted that front-end code does evolve, with HTML5, CSS transpilers and ES6, but use these technologies if you feel it fills a gap in your development process and makes you a better programmer, don't just use it for the sake of using it. 
What I'm using it for is the server side of a game, but really there are many (niche) use cases for something like this. And while some other languages might be better for this application, that doesn't mean that they are better for the combination of application/developer/userbase. PHP is not inherently bad at these things, or slow at them either. It's just that the libraries don't exist for it. Which is actually exactly why this should exist. :) I think a common use case for this could be converting shipping weights, although this library is way overkill for something like that. (Still, it won't be slow at something like that.) Another use case that might come up in PHP is localization in general... being able to display a user's height/weight/etc., or the properties of an item, in any conversion that you want. Your question has merit though. It was asked the last time I posted this too. The bottom line is this combination of details: 1. PHP is not especially bad at this *sort* of thing. 2. The libraries to do this sort of thing don't currently exist in PHP. 3. Ergo, the notion that this shouldn't be made because there are languages better at it is not a good argument, since the main advantage they have is that they have a library written already. Now PHP does too. I'll wait and see what other people might do with this.
For somebody called WorstDeveloperEver, you gave him some really good advices.
Great job! I actually have a use for this. Thank you very much
Sweet! Always hated this wasn't maintained anymore!
I very like runkit, it is the ultimate way to do metaprogramming, and with it PHP is about as dynamic as Python and Ruby. If its bundled with PHP by default, it will make a plugin/hook system a lot easier to design, user and extend. I really hope one day it makes to PHP's core, along with other amazing PECL packages such as pthread. Unfortunately, the runkit version on PECL is outdated. Since Dmitry Zenovich was not the original coder of runkit, he doesnt have permission to update runkit on PECL. I really hope the original author of runkit would give the permission to maintain runkit to Zenovich, he deserves applause for the hard work. If I aint developing a project anymore, Id definitely love to entrust it to someone who has the skills and enthusiasm to continue its development. I hope for the best of runkit.
Learning and deploying with multiple frameworks is not a trivial affair for one person. Reading documentation alone can take days, weeks or even months to fully absorb what many of the popular frameworks are doing in the industry right now. By focusing on core languages, one can make a prototype of their business idea to see how things are going to go. So a quick and dirty front end of basic HTML and CSS, JS with simple AJAX, PHP for some back-end stuff could be an end-to-end solution for an entire business. These are things that many developers already know, or have dabbled in enough to make a quick review pretty easy to get up and running. One of the problems with many web frameworks is that they end up being a bolt-on language for people who dislike the inefficiencies of JS. Plus a whole framework can change direction suddenly due to politics and suddenly whole businesses that relied on that framework have to suddenly shift to a forked framework (ie. Node.js and io.js), or learn to live with the new direction of the framework that they've invested years into. Or the whole project can die out and they have to refactor their entire business platform around a competing framework that wasn't around when their launched their company or was in its infancy at the time. Frameworks come with a lot of bullshit so it can in fact be easier to avoid them until they hit the big leagues and need extra efficiency.
How much do you value sleep? Take a look at PHP the Right Way for good intro into PHP: http://www.phptherightway.com/
I've been putting about 25 hours a week into this self-teaching thing without losing sleep, so I guess I have around 150 hours for this PHP thing. I'll check out the link though, thanks!
What's the best kind of project to work on? I've been thinking about doing two at the same time, one Wordpress site that I can use as a blog/place to experiment with and some app that uses a MVC framework. 
I can definitely see the scenario you're describing. There seems to be some job postings out there though were a just a small business that needs someone to launch a site for them and configure it a little which is the kind of job I'm expecting to get to be honest.
Let's say you had 6 weeks, 25 hours a week, so about 150 hours total to learn PHP. How are you going to spend it to maximize learning PHP? I know I'm not going to be the best developer out there, all I know is that I'll be a little smarter than I am now.
Wait how do you build plugins with a "Restful" (I hope its restful) API? I assume that WP requries you to implement the API your self or at least some kind of authorization and thus plugins would need authentication to run said API Requests? WP doesn't seem like it requires or needs an API to be implemented because its not "generally" (note the quotes) used for building "real" applications.
&gt;However, you're correct. We have way too many package managers nowadays. NPM, Gem, Composer, Bower. Someone has to write a package manager that manages package managers. :P On Arch Linux you can install most of these tools from the official repositories, and it makes sense to do so because you can actually keep them up to date.
Hi! Developer here with the same exact background as you. Bootstrap is great, and while I understand the concepts, I try to think on my feet like I would as a developer, and hope that it works. For the past 2 weeks, I've been working on just frontend, and I love it! It's bringing out the creativity in me. I can sit there and visualize how I want stuff laid out, and in the beginning, I was trying to do table like structures for my data, but quickly realized that shouldn't be my goal, so I started trying to comprehend how to "condense" data when in mobile vs desktop. Here's some key elements that helped me out: hidden-*, visible-*: very valuable when needing to rearrange columns (if you can't use simple stacking) float left: every *-col-* is floated left, and the widths are based on 12 columns (I'm sure you know), 4 = 33% width; 8 = 66% width; 12 = 100% width). A 100% width column will obviously push any other floated elements to the next line. I can't think of any more at the moment, but it's extremely powerful.
You don't really want extensions in the core. I can say with some confidence that things like runkit and pthreads will never be core, and actually are better off in the wild. When you donate some code to core - donate it is what you actually do - you hand over control and release schedule of your extension, to the will of every contributor and the PHP release schedule. This means you cannot release fixes at will, which should be a big enough problem to put you off. It also means anyone can do anything they can get past an RFC, it means major changes to *your* code need to be RFC'd ... this is a crappy situation to be in, believe me. Some (very few) extensions are a good candidate for that, once they have existed for a few years ... extensions as complex as runkit and pthreads are definitely not, and never will be.
I wouldn't want to have to work with someone who taught themselves their trade in 6 weeks, not programming, not baking, not building, not anything ... but least of all programming. Despite there being many youtube videos that claim to teach you a variety of things in a few minutes, they don't, they show you stuff for a few minutes, which is a different thing altogether. Sometimes you are able to copy what you have seen, others you need to watch it over and over. If you could remember, word-for-word, a whole programming book, you might be able to make use of that information. We don't read (research) to remember every word, we read to inform and expand our opinions, reading is great for that. But you have to read many, many books (or blogs, podcasts, whatever) before your pool of opinions is large enough to be useful, relevant. 6 weeks is simply not long enough, in my opinion. It's long enough to make a start, so get to reading, but get access to more books. Include some books that aren't PHP specific, like [this one](https://en.wikipedia.org/wiki/Design_Patterns). Don't read a single book, and think that's enough to get started, it's enough to give you an appetite to know more, which is what you should be concentrating on. *Disclaimer: I can easily be wrong, happens all the time ...*
php the right way - http://www.phptherightway.com/ : All modern PHP in a single place
I don't understand the question. The API merely exposes some REST endpoints you can ping for data. It authenticates using OAuth and you generate tokens beforehand (currently [very clumsy](http://www.sitepoint.com/wp-api-and-oauth-using-wordpress-without-wordpress/) - will hopefully be much simpler). What do you mean by "real" applications? Being able to review post submissions, create a new author account, moderate comments, or reschedule a scheduled post from an app you made for your staff's phones sounds quite real to me.
Everything written by [this guy](http://www.sitepoint.com/author/agervasio/) should be a mandatory read. It's amazingly readable but also very educational. It'll help you a lot with modern best practices, even if the posts are a couple years old.
I've worked on huge, monolithic corporate applications, and it's true that these kind of projects are much more rigid, there still room for improvement, especially if the business requires old features rewritten or new features added.
Got it, thanks!
Thanks for the encouragement :)
&gt; What have you been doing in the last 10 years and how did you survived as a programmer by not learning new stuff every day? Is this really necessary for you to help OP learn what the buzzwords mean?
Thanks, but I'm asking about writing Hack on top of PHP, not about using HHVM.
Laravel is a PHP-exclusive framework, making its use of the word PHP specific. As for your other point about facades: yeah I'm one of those people who think Taylor should have chosen a better name for them.
That was the first book I read, but it is not complete in itself, merely pointers to even more documents to be digested. 
Been there, done that, not TLDR.
Okay thank you. So what you are saying is, that instead of PHP frontend making an HTTP (for example via cURL) request to the Microservice, it should connect to a Message Queue like RabbitMQ and send whatever action the user performed. But how do you get the responses from the backend? I'm guessing the backend also sends responses to the Message Queue, but this is asynchronous. Does the user make ajax requests to a PHP frontend script that checks for messages?
Aren't Laravel's Facades different from the Facade pattern though? I haven't used Laravel, but I've heard this point brought up before. Edit: Looks like Laravel's Facades are actually service locators (yuck).
Wait what? The guy is giving you the TLDR.
I've only played with it in tutorials, but grunt/gulp aren't necessarily front end exclusive, it looks like you can use them for all sorts of back end task management stuff, too. 
&gt; "I have read the usual recommended books, and now I want a dictionary to quickly look up a summary of a buzzword to refesh my understanding". The thing is, you haven't. You said *"I am now trying to modernize my knowledge as quickly as possible"*. You won't get there with a TLDR dictionary. But with your experience, you'll still get there fast. Here's my quicklist: - The book [Modern PHP](http://shop.oreilly.com/product/0636920033868.do) by O'Reilly actually touches on everything you're interested in and should get you up to speed in no time - Get your head around object oriented programming in PHP. The [OOP Bootcamp](https://laracasts.com/series/object-oriented-bootcamp-in-php) series on laracasts.com should help. They also have good lessons on traits and whatnot. - Use packages, don't reinvent the wheel. packagist.com is a searchengine for libraries you can install with the composer command line tool. - autoloading (PSR-0 and PSR-4): You don't want any include()s in your code. Use an autoloader for that. Most people use what comes with composer. The bootcamp series has a lesson on that. - use vagrant as your development environment - use a modern editor like Sublime Text, vim or an IDE like PhpStorm - Save patterns for later. Patterns are tools to solve problems you've actually come across. You'll never really get them into your head until you've created your own problem that a certain design pattern solves. When you're totally comfortable with all the above, go ahead and get a book on design patterns.
For me Laravel was a nice and quick entry into all of this and laracasts helped a lot. From there, you'll have no problems going on with Symfony2 or anything else.
If you have a background in modern object oriented development, it's like looking at the crap you wrote 15 years ago and being forced to work with it.
In your post you asked what these things were and the guy gave you a one-liner for every one of those services.
Actually I said "I'm asking if there is a dictionary or glossary for quick lookups" but I do appreciate the extra education.
I gave you a more comprehensive reply elsewhere in this thread.
&gt; Laravel is a PHP-exclusive framework, making its use of the word **wrong**. FTFY. Seriously, there's a reason why we use common terminology in engineering. Imagine the look a mechanic would give you when you suggest that your steering wheel needs an oil change. Design patterns share a name (and in general, naming conventions exist) so that any SW engineer can look at something and know roughly what it does, or quickly describe a component without walking through the implementation. OP - I like [this book](http://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124/ref=sr_1_1?ie=UTF8&amp;qid=1444511841&amp;sr=8-1&amp;keywords=head+first+design+patterns) for learning about design patterns. It's not perfect and java-heavy, but overall gets the terminology right and has decent examples. Wikipedia can go surprisingly far here, too. Each of the five pieces of SOLID design have their own article, Dependency Inversion included. That specifically tends to have over-complicated phrasing and examples. It basically means keep `new` outside of your class definition, and instead accept an object of the same type as an argument.
Maybe I can give an example: - Version 1) "composer" - https://getcomposer.org/ - Dependency Manager for PHP - Version 2) "composer" - Command to automate the resolution of library dependency within a PHP application. Missing libraries are automatically fetched from Packagists. (Website: xxx and xxx) - Version 3) "composer" - "A command line application (written in PHP) that manages the dependency of PHP library packages. It works with the Packagist depository to automatically resolve dependency, fetch the sources, install them into the correct directory, and updates the Autoloading configuration files. Each application gets its own package directory, so it is possible for each application to use different versions of libraries. If a library is not registered on Packagist, see PSRx for ways to link them into the application. (Website: xxx, Documentation: xxxx, Tutorial: xxxx) I am looking for Version 3. The essentials in a few paragraph.
The two can hardly be compared. PhpStorm is an ide specifically built for php, atom is a text editor.
I second Mustache, but I also want to recommend Twig (a Symphony component). Twig can be installed standalone without Symphony, and it is essentially an object-oriented way to template --- blocks defined in parent template, can be selectively overridden by blocks of same name in the child templates. This makes it easy to join many application-specific pages to the same underlying layout.
PHPStorm is built for coding php. As it is an IDE, you will be given tools needed to help with your development on your projects natively like Git, terminal, database browser, the ability to run tests easily and most important, code intelligence for auto completion, unused code and so on. A text editor is great but will hinder you ii the long run (from my experience) Hope that helps 😊
I have a little library that uses the google text-to-speech api (as well as a few others): https://github.com/duncan3dc/speaker
Your book seems very practical for someone rewriting legacy code to use modern paradigms. Kudos.
Curious. Does it allow you to jump from base methods to every inherited/overridden method? And click on a constant to see all the places where it's referenced?
This isn't necessarily going to help you but just weighing in with my personal experienced having used both. PHPStorm I've used for about 2 years now, and Atom I've been using for a few months. I switched from using PHPStorm to Atom. The reason was at work I use a Mac and I found PHPStorm would become unusable quite often, until I restarted the machine. I wasn't sure if it was my specific set-up or something else but I loaded Atom up with a lot of plugins and coded away and I don't actually find I have many problems with it. I use it for projects at work as well as Laravel based projects at home, everything works fine enough. As mentioned by blocsonic, being able to right click and go to definition is a great feature and I found that with an Atom package that had this functionality it wasn't too reliable, woudl sometimes take me to very odd places. On my home computer right now I have both PHPStorm and Atom open for the same project with the same file open. Atom is using 0% CPU and 44MB of memory while PHPStorm is using 0% CPU and 790MB of memory, though watching it idle, doing nothing at all with it, the memory usage has climbed while Atom has actually dropped. But as also mentioned PHPStorm is a fully featured PHP IDE while Atom is a text editor with extensions so this comparison isn't necessarily a fair look at the two but it could show that it really depends on the size of project and what you plan to do with it. There are things about PHPStorm I miss and seeing this post I've actually decided to give PHPStorm another shot, at home on Windows at least. 
If you are starting to learn PHP, stick with a text editor like Atom (Sublime/Notepad++), otherwise you'll need to learn how to use an IDE as well. When I first started, I tried Aptana Studio and Netbeans, and both felt overwhelming, so I ended up using Sublime for several years.
It's ok, I deserve to be chided for not keeping up with the trends, as I left university 30 years ago, and my first program was written on punch cards in Fortran. But the people who taught me made the moon landing happen so they are smart.
Hi I am probably not qualified to give advice, as I am just this year getting into frameworks, but I have coded two projects in Laravel and one in Slim, so I have a bit of experience to share. I want to say that a framework is often confused with a library, but there is a fundamental difference. A framework is the "master" while libraries are "minions". In other words, the flow of control is inverted in a framework. In the frameworks I have used, you configure the Routing (map a URL path to a function call), and then pass control to the framework. - After the framework sorted out the protocol parts (session, security, HTTP action verbs etc), it will make a call into your functions. Some frameworks can be made to Autoload codes on demand, so you only use what you need for a specific routed call. - At the end of the page-specific function, you return the values to the framework. The framework will complete the rest of the page, including protocol, tagging the cache, redirecting, whatever. By using a framework like Laravel or Slim, I reduce the codes I need to write to a bare minimum. The caveat is that the framework is like a blackbox, with a lot of the complexity happening "by magic". Poorly documented frameworks make debugging hell.
I think 6 weeks is a good solid amount of time for a competent programmer to learn a new language. There are also many tools and design patterns to learn, but they are separate from PHP itself, and not knowing all of them is not going to stop you from writing a basic PHP program. Wordpress is a fairly small LAMP application, based on old code that is written legacy-style, not the modern style that uses frameworks and autoloading libraries. But this is not bad. The code is clean and documented well, and can be walked through in less than a week. There are no command line steps in the installation. And the application comes in one self-contained bundle that can be easily installed on any cheap webhosting platform. All these make Wordpress the number one blogging software. Knowledge of the trendy modern stuffs, Angular, Laravel, Cake, etc. are good for bragging rights but in the Wordpress developer context is not essential, as WP Plugins are also written legacy-style as callbacks and hooks. If you limit yourself to just learning PHP syntax and OOP, WP basic blogging, custom types/fields/taxonomy, plugin architecture, XMLRPC apis, and one front end technology like Bootstrap, you should be able to be productive developer in 6 weeks.
My point wasn't that Taylor came up with the concept, just that the word "facade" as the rest of the programming world knows it, means something else than what Taylor means by the word "facade". The fact that you don't like that, doesn't make me wrong. I'm perfectly well aware of how you feel about the way Taylor uses the word, because I've seen you argue about it here, and since [you know I agree with you](https://www.reddit.com/r/PHP/comments/3o77dq/is_there_a_good_resource_for_tldr_descriptions_of/cvusls9), I don't understand why you feel the need to explain this to me. Don't shoot the messenger here Paul, please take your issues with /u/utotwel's terminology up with him, thanks.
&gt; The reason was at work I use a Mac and I found PHPStorm would become unusable quite often, until I restarted the machine. I have used PhpStorm on two different Macs and have never had issues. Did you open a ticket? What was the issue?
The question here is more: Super Text Editor vs. IDE I've been a Sublime Text 3 guy for a while, and have dabbled with Atom at several different points along it's development. There were a couple of stability issues that kept me from making the transition. Now considering you're jumping into a framework, and you sound pretty fresh? I'd suggest the IDE -- you get more out-of-the box debugging capability/testing; and for a new MVC that could be invaluable. I recently shadowed another developer for a new job, and watching him work on PHPStorm, I definitely thought "Man, I wish I had some of those tools". It saves a lot of legwork. For me, my procedural code stays pretty basic; print out the input, output, a few __LINE__ to follow the logical train-of-thought, and I can get the job done. But it takes a few more iterations to do so.
http://www.thebitworks.com/wordpress-sites-getting-hacked/
You have an infected theme. Updating WordPress will not update the theme, assuming it's a custom theme, so the malicious code is still there. From the error, it seems whatever it's attempting to do is failing. I would suggest reinstalling the theme or switching to a different one altogether as there may be other snippets of code floating around in the themes files. As far as what it's doing, it doesn't matter, whatever it is, you don't want it doing it.
Either you have your mascots backwards (elephant == republican), or by Democrat you mean donkey aka jackass. So your question is either "Do I have to be a Republican to use PHP?" or "Do I have to be a jackass to use PHP?". Please clarify.
It can't deal with files over 1.5 MB. It will just lock up. It also doesn't like compressed or minified code so if you accidentally open a compressed CSS file be prepared to reboot the app.
He's probably using a EAP. The 9th version is the best yet and I have been using it since 5.x.
Use an IDE. It tells you a lot about the code your writing and provides so much info.
Hah, you seem very sure of this for someone who hasn't even started coding PHP.
A very logical reason is that enterprises probably were developed when Zend1 And Symfony1 were the latest hot thing on the market. And then the more savvy ones upgraded to Zend2 and Symfony2 respectively
I rather think that Java / ASP.NET are rather in use at those classical enterprises. However Zend is in my opinion for that companies the first choice, mainly because they have their "Zend Certified Engineers" stuff and contribute a lot to PHP itself (Zend Engine)
I do see a lot of Laravel usage in smaller companies, but the bigger ones probably have some inertia as Laravel picked up steam only very recently, while Zend and Symfony have been around for many years, and popular since version 1. Laravel also does tend to sacrifice proper architecture in some well known areas for a quicker start and an easier learning curve, and bigger companies probably see through that and prefer something that has a lesser chance of turning their codebase into a "legacy codebase" over time.
The whole WP folder has been replaced with the new files. I uploaded my version of the theme (unmodified) and changed the loggin keys. This shouldn't happen again, but was wondering what the code does. Thanks!
Thanks! It all points to his weak password as the culprit. Hope this doesn't happen again!
Oh, I know. I've already taken all steps I could think of to fix the issue and ensure it won't happen again. I was mostly curious to know what the code did and maybe an idea on how it got there in the first place. Thanks!
This would be so much better if PHP had operator overloading and user-defined literals. 
I've used both. PhpStorm is better than Atom + packages in my experience. Atom will probably catch up eventually but for now the integration with PHP is much better in PhpStorm. It's little things - a million other small features, specific to PHP.
Try them both. My money is on PhpStorm.
Symfony2 [by far] -&gt; Wordpress -&gt; ZF1 -&gt; Symfony1 -&gt; ZF2 -&gt; Joomla -&gt; Drupal -&gt; CodeIgniter / Kohana -&gt; Laravel -&gt; Cake. That's how I see the landscape in the $200,000/year contractor category. I see extremely few projects (1 or 2) running ZF2, although a HELL lot of them, including pretty much everyone of my major projects, involve ZF2 components, notably Zend\Permissions\Acl, Zend\Permissions\Rbac, and Zend\Search\Lucene. And, yes, a LOT of non-tech enterprises use both Wordpress and Drupal as "frameworks". I have guys contracted out to work for several Executive Branch departments, and they *all* use Drupal-as-a-framework. The Obama admin is almost 100% like that.
Interestingly, that github page crashes my firefox every time. 
Why Symfony2 though? No personal experience but I've only heard bad things.
Unless you list out what bad things you've heard, we can only guess. I use SF2 exclusively when spinning up new projects, and I have less complaints about it than most software I use to build with.
If your persistence layer is using Eloquent your repository would probably call 'save()' on the model so Eloquent would handle dates. If you're not using Eloquent or anything else then it is up to the implementation. Checkout https://github.com/anlutro/laravel-repository is works for versions 4-5 and is good for starting out. Your repository handles persistence not managing business logic. If you have a creator class for the model then that logic could go there. You'd inject the repository and use it to check if any models have that slug you're wanting and once you've prepared the slug you can use the repository to persist the new model. However the following link has this logic in the model https://github.com/laravelio/laravel.io/blob/master/app/Forum/Threads/Thread.php A real repository will not manipulate or validate the model. It persists models and gets models.
That's the case with any framework, though, and sounds like as much of a documentation problem than anything else (if Doctrine is representative of SF2 as a whole, then I'd agree). It's a framework, not a turnkey solution.
Symfony, Typo3 Flow, Zend.... 
/u/javiereguiluz suggestion, when posting links to github, don't point to master, but to certain commits. The master over time changes and the links have no use later ;) . Thank you.
One usage I can think off the top of my head would be dynamic class instantiation.
One of the biggest pros of using Illuminate\Foundation\Providers\ArtisanServiceProvider::class as opposed to "Illuminate\Foundation\Providers\ArtisanServiceProvider" is that it's so much easier to find the usages of a class in your IDE. I use this when I have to work with ZF2, it makes it way more bearable :)
So how come we can instantiate class with Illuminate\Foundation\Providers\ArtisanServiceProvider but not with Illuminate\Foundation\Providers\ArtisanServiceProvider::class 
Well, no PHP frameworks are widely used in enterprise to be quite honest (not that I've ever seen at least). Java and .Net are the dominant players (for very good reasons though). There is a fair amount of Python as well (and seems to be growing). Some Ruby (RoR) here and there. If you are looking to be employable to enterprise, I would start jumping into the Java world sooner than later. Don't get me wrong though, Laravel and Symphony are both great frameworks, but PHP has a bit of a bad rap that's not going to go away any time soon in enterprise-land.
I would call version 1 the TLDR ;-). You seem to have it down. Start such a website and I'll help you fill in the blanks. You don't only need this for yourself, do you? 
You can: $x = Foo::class; $y = new $x();
In the following situations: $className = "Illuminate\Foundation\Providers\ArtisanServiceProvider"; $className = Illuminate\Foundation\Providers\ArtisanServiceProvider::class; the value of $className is identical. 
&gt; If that class does not exist, you're going to get an immediate error thrown in PHP when it tries to call ::class on it, That is actually not true. It is just converted to a string at compile time without autoloading. The following code works and prints ``Not\Existing\CustomClass`` but the class does not exist and is not loaded in any way: echo \Not\Existing\CustomClass::class . "\n"; So ``::class`` only helps when working with IDEs. 
Check what plug in are being used too. They are often the place where vulnerabilities are found
TIL, updated my post.
Why Sublime? That's also just a text editor. The better alternative to compare apples to apples is something like Netbeans
I get .NET, but wouldn't the appropriate answer involve specific Java and Python frameworks?
It's for all students and individuals who code... video describe that how to search on google for a stuff and get help from various professional websites for programming like www.stackoverflow.com etc.,,, video about for sending e-mail from your php script in localhost ( 127.0.0.1 ).... some useful guidence for beginners that how to search on google or stackoverflow etc.,, and create your php script like example showing in this video.. Target of Video is : Send mail from localhost in php
The most difficult thing to learn in Magento isn't the code, it's EAV modeling.
I may have been using EAP actually you're right. Though I had the same version on Windows and had no issues there. So chances are it's not an issue anymore on my work Mac either.
I'm glad to see your edit. I was going to point out someone doing www.mysite.com/router.php&amp;method=www.satan.com/malicious_code.php I usually do a something like: if (method_exists($this-&gt;request[something] &amp;&amp; in_array($whitelist, $something)){ $this-&gt;$something; } &gt;modern standalone router that uses the oldskool I haven't really kept up with the newest and coolest, I just use what works, what's easiest to get going with. I'm not in any way familiar with Laravel (for example) and the setup seems daunting to even get started. I'm mostly a back-end person, so I just work on something already built and incorporate with w/ever that is. I'm either not smart enough, or too stubborn to understand why a decent framework needs to be 4-10 directories and 50 files deep to start out with.
I personally have heard much worse things about ZF than about Laravel (and having used both, can definitely say that both versions of ZF are much more of a headache to maintain, although maybe my predecessor who created the ZF apps I maintain just used poor design patterns). The only bad thing I hear about Laravel on a regular basis is that it uses an active record based ORM. Of course, Zend has certifications and was until last week the company that owns the PHP engine itself. Corporations tend to prefer software that comes from another corporation under the false assumption that it's somehow "better" because of enterprise-grade support. Otherwise there would be a lot fewer companies running on Java and .NET. (Of course on the Symfony side I have heard nothing but good things, and would probably choose it over Laravel for any large-scale app. Laravel seems to be better for smaller apps because it's very easy to get a project up and running.)
the EAP versions are 'bleeding edge' and while it has the newest features, it is rarely optimized as a release would be. I used the 9.5 EAP last week and went back down to the 9.0 official release due to chuggy response.
“XML combines the efficiency of text files with the readability of binary files” “XML is a classic political compromise: it balances the needs of man and machine by being equally unreadable to both.” 
I have a project that I started in angular recently. Should I rewrite it in react? Also, what would I use if I needed functions to change the dom? (I.e. Click a button and filter a list based on that selected option)
It is hosted on their server not yours, it reports a ton of server info to them when people browse your site and it is very likely the server is infected.
Black magic
&gt; I'm not aware of any modern standalone router that uses the oldskool /controller/controller-method/arg1/arg2 routing method Could you give an example of a modern way routing would be done please?
Ahhh, that makes more sense. Will browse the rest of the server to check if anything else is infected. Thanks!
I personally think [phroute](https://github.com/mrjgreen/phroute) has a slightly cleaner API, and supports grouping, prefixes etc. It's basically Laravel's ultra clean API, wrapped around nikic/fast-route.
Would like to add [mjgreen/phroute](https://github.com/mrjgreen/phroute) to this. It's Laravel's super clean and intuitive routing API built on nikic/fast-route.
It's not just a router, and more than 3 classes deep, but it's a very lightweight and stupid simple framework: http://www.slimframework.com/ I felt it was appropriate because the router in the framework is simple and lightweight, but also, a router alone doesn't make an application; you'll eventually need some kind of persisting, etc. (Internally it uses https://github.com/nikic/FastRoute as it's router)
Hi, `::class` creator here. I have an interesting perspective on when to use it, and it is worth noting that my perspective has changed over time. The original post to internals was here: http://news.php.net/php.internals/59931 TLDR; Basically `::class` is a framework coping mechanism. That's how and when it should be used, IMO. At the time I wanted to create it, I was heavily invested in building ZF1+2. ZF2, PHPUnit, Symfony were all large monolithic (to a large degree) frameworks striving to be good object-oriented citizens (SOLID and all that). They all expect you to give up control of creating instances of your classes to them (ie: they might call `new` on the classes you write) to various degrees. One of the pieces of information (overlooking the whole injecting dependencies thing) you need to give the framework in order for it to create instances of your classes is the class name. Using the class names in strings means it is highly unqualified; so you'll have a much harder time refactoring that name later because you'll basically be looking at every string in your code base, and even then you have to worry about context of the string before replacing it with an updated name. With `::class`, the class name is always qualified as a class name and as such, refactoring class names is much easier to do and get right (like in PHPStorm's refactor command). Another benefit: since class names become a first class citizen, they can make use of namespaces `use ns\long\sub\classname; $c = classname::class;` so you don't have to write out the fully qualified class name, in a string... all over the place. Currently, I try to avoid frameworks that require heavy `::class` usage during development. For the most part, I try to cut out any frameworks that have some kind of auto-wiring DI container that make use of heavy reflection or heavy amounts of user metadata. My ranty-opinion: Closure style/Pimple style, containers are essentially all one should really need. 
:(
Huh, TIL. 
My FTP's root got hit. I had 1.5 million copies of index.php scattered in random places on the site. still trying to clear it out. At this point I'm pretty much just deleting everything and uploading from backups. So, if they got some files on your server, they could have used that to create files all over the darn place. Good luck.
&gt; Binary classification Only sith deal in absolutes. More seriously I don't agree with this article. In your example you take the benefits of encapsulation (making sure a configuration X is valid) and say that you get these benefits by "forbidding to use scalar types". But those benefits are just because you encapsulated some behavior in its own class and I believe it has nothing to do with scalar types. I.e. if you have behavior to encapsulate, use a class. If not, then feel free to use scalar types. Example: class Product { public function __construct(int $id, string $name, Price $price, bool $disabled) … } Here: - I encapsulated the price value in its own class because there is behavior related to a price (e.g. making sure it's always a positive integer, etc.) - I didn't encapsulate the other parameters because they don't have behavior to encapsulate Other example: class RedisCache { public function __construct(string $host, LoggerInterface $logger) … } Why should I encapsulate the host in an object? Sure the object could check that the host is valid but 1) I don't care because if it's invalid RedisCache will throw an explicit "connection exception" anyway and 2) a value object shouldn't really go and connect through the network… --- Also taking your point the other way: &gt; Value Objects, constructed only with scalar values. The [single best example for what a value object is](https://github.com/mathiasverraes/money) contains another (value) object (`Money` contains an amout + a `Currency`). So I think this is another example that the "binary classification" (either this or not but not a mix) isn't appropriate.
Spring and Django.
It's not actively maintained (the link), last updated 21 Apr 2014... That is quite some time ago
Yes, outdated core software will also have vulnerabilities. Most updates will be to address security issues and its all well documented, so you can see how easy it might be for a would-be hacker to hijack a site so out-of-date
Well he is comparing an IDE to a text editor, So I just gave him a better text editor choice. But still in the end you just can't compare an IDE to a text editor. 
Wait what? Seems like you've never coded in C++11 or higher and never seen C++ template madness or a larger project. In your case you probably just wrap your methods in a class and that's it. And then you say that you can't say the same for Java. You know that most of PHP OOP is derived from Java right? implements, extends, interface, modifier declaration and all that is Java syntax or strongly motivated Java syntax. In C++ you don't have those keywords. You have multiple inheritation which Java and of course PHP do not even support. If you use an interface you will declare pure virtual functions. If you extend a class you derive from it and so on. Memory management is a lot easier in C++ now due to RAII and its smart pointers but I also don't see why Java makes it hard for you. You just write new (as in php!) and that's it. That being said doing it the 'simple' C++ way is most of the time also the right way since usually the PHP =&gt; C++ scenarios most of the time boil down to pure number crunching. Sorry for that late reply but it bugged me...
Yes. People just don't realize how popular Python is.
Magento seems quite popular where I live, and in demand. Usually when a position as a PHP-developer is advertised they will also require experience with Magento or Laravel (or both).
&gt; When i started learning oop my models were extremely large. I handled all input sanitation/validation/escaping ( when retrieving data ) and sometimes i added in service layer type of logic. I think the model should be designed in a way that you can not create invalid data and put them inside the database by circumventing the model and using the ORM/db access directly. As a result, the model should take care of invalid data and verify that certain constrains are fulfilled. E.g. if a tournament requires a name and a location, the model should enforce that. Escaping/sanitation is not part of the model. The model should not know if it is used in a HTML context, for JavaScript output or on the command line. So it can not escape the data. That should be handled by the view. And preventing SQL injection is the responsibility of the ORM. Also the model should only allow data that strictly fulfils its requirements. So no sanitation is required in the model. &gt; Since reading/learning i have split everything up but i am left with a few questions. &gt; &gt; ** Should A Model ( Repo ) Convert Timestamps? ** I split my models into service layers, entity, and repository. Lets say i have a table that holds epoch time stamps for a tournament. When creating a new tournament or retrieving a tournament from the database is it acceptable to convert times ( using time helper ) to the correct time format? The same format is required across the entire site ( tournaments are displayed on their own page + sidebars of every page ) there is maybe 2 places where the timezone is different. For those places i can always reconvert the time. Converting timestamps to displayable date/time formats is the job of the view. If you add a new localization to the website, you should not need to touch the model. The language/region specific view should handle this. If you have a date or time input, the view (form) should also handle the conversion to the canonical format stored in the model. (When I say view, you could also use a dedicated service method/class for reusability). &gt; ** Should A Model ( Repo ) Convert Names Into Slugs? ** Same as above but instead use slug class to convert name to slug when creating new user etc. The model has to take care of the slug (a short/nick name, right?). Otherwise you could insert elements without a slug by circumventing the repo. &gt; ** If I Am Taking The Wrong Approach Should Repo Only Contain Db Calls/Edits And Thats It? ** The repo is responsible for loading and persisting model data. All your queries should be there, preferably parametrized. E.g. "select 10 newest tournaments" should be a method of the repository. But it could also be ``RepoClass::selectNewestTournaments($results)`` so you can reuse the method.
What are you going to use it for?
Dicking around with a rocket video game I started a few years ago. 
Hey, firstly congrats on starting a blog, I checked a few months ago and you did not have one back then. As for the post itself, the only thing I can add is that it probably makes sense only if you have a bunch of such arguments. If you have only one or two scalar arguments, separating them in a value class seems a bit extranous to me. So perhaps your idea could be better refactored into some immutable configuration object pattern, that allows both scalar value and immutable value objects. It is (well was actually) very common amongFlash game devs, as some constructors generally had a lot of parameters.
&gt; It's Laravel's super clean and intuitive routing API built on nikic/fast-route. FYI: I'm pretty sure its not Laravel's. Laravel appears to use [Illuminate/Routing](https://github.com/laravel/framework/blob/5.1/src/Illuminate/Routing/Router.php), its README compares performance with the Laravel router, and there doesn't seem to be any other relationship with Laravel.
Silex is pretty simple. http://silex.sensiolabs.org
Frameworks aren't for beginners, though. You should have a solid understanding of your language and design patterns before looking into frameworks.
Not just a personal preference here but I would bump Drupal ahead of Joomla and Wordpress if were talking in terms of Frameworks. As CMS's, depending on your needs, sure WP or Joomla might be a better solution. But Drupal is used widely by governments and enterprise around the world. The latest version of Drupal 8 has web services and integration built into its core and can be run "headless" - that is, stack on your own front end! It makes it an excellent tool for integration with other systems. In fact, here in Australia, Drupal is the defacto standard for government. I started a contract about 3 months ago as Tech lead on a Drupal project for a large, government cultural institution and I am the highest paid person here, pretty close to the figure you mentioned, and I earn more money than anyone I know by a large margin because the demand for Drupal skills are so high. However, as a counter point, maybe the reason you have it lower on the list is because its quite a learning curve, even and maybe because of experienced developers. Traditionally Drupal has done things its own way. In Drupal 7, when other frameworks were embracing everything the newer versions of PHP and their OOP and Java-like features provided, Drupal was still building its own procedural functions for everything. Even just wrappers for simple PHP functions. However I can tell you, having worked on Drupal 8 core, Drupal 8 is a major refactoring of the architecture. There is no backwards compatibility from 8 to 7 because they are so vastly different. Drupal 8 was built to modernise Drupal, and bring it inline with other major frameworks and to use commonly accepted techniques that developers would likely find on in other frameworks. Things like composer, dependency injection, autoloading etc. The first step of it doing this was to utilise Symfony's excellent components, and thus I agree with you listing Symfony as the leader in frameworks.
And Magento includes components from both zend and symfony, which is the most accurate snapshot of modern php development.
&gt; I.e. if you have behaviour to encapsulate, use a class. If not, then feel free to use scalar types. When something that depends on something that has a type, it means that it is possible to tell the DIC how to create that type of object in general, without explicitly wiring up the connection between the object and the thing that is dependent on it. If it's just a scalar type, then you need to create the explicit binding, i.e. when this type of object is created, use this value as its 1st parameter (or whichever parameter is named host). While it's not always appropriate to do that, having to wire up every single dependency by hand in an application is a pita.
Scalar values are not really non OO. Just treat them as an immutable final class with no methods. =)
I think the author intuitively understands there is a sharp line in the mental model and mechanics of objects that materialize actors, services, and those which are data, i.e. glorified structs. Whether that sharp line should be reified in the form of "always/never use scalars" is questionable, although structs should be serializable, as they are both a unit of communication, and a unit of persistable state, so building them out of primitive values like arrays and scalars helps.
No particular issue, I just wanted a sense check that this was an appropriate "pattern" for error collection and handling. I guess my main concern was that I'm loading a bunch of responsibilities onto the service layer - validating the operation, and actually performing it - but I'm ok with that service being a bit dirty if it's re-usable, and the application layer stays clean. Concerning named parameters, how do you address the issue of making the arguments known and explicit? I feel like every attempt I've made to make arguments more flexible, has required me to dig into the source code, and look for all the places they are used. For a relatively stable API, I feel like positional arguments is the lesser of the two evils. But I *REALLY* wish the circle of PHP elders would pass a damn named parameter RFC so you can have the best of both worlds: flexibility, AND explicit argument signature.
For the error collection I tend to also include the possibility for returning error source "path" (like name of an input field or others), machine error code and machine readable error details (arbitrary assoc array), as well as returning multiple errors at once, instead of just one. I suspect you have facilities for this, but it's my experience that these features are needed for robust error reporting from the service layer.
The amount of content Laracasts manages to put out is overwhelming. I mean you would not belive how many takes it took to record the Vagrant setup video and that one is not even particularly long. I really have no idea what kind of genetic technology they used to clone the Laracasts guy to be able to generate so much stuff.
In that particular case, I think it removes a layer of indirection--a named unique class-method called "indexPage"--that the user might not want to have to manage and keep in-sync.
It's less about safety and more about encapsulation and inversion of control. Now, a direct access would need to use isset() first or PHP7's null coalesce operator "??", but more importantly, an HTTP request in Symfony can come from different sources because it's given to you, including internal (virtual) requests, while $_POST is a global variable that you need to reach out and read. To be frank, you can get a lot of the benefits of inversion by simply passing $_POST as an argument to your code from your bootstrap file: function doSomething($url, $query, $body) { ... } doSomething($_SERVER['REQUEST_URI'], $_GET, $_POST); So you know, this might work just fine for you, depends if you need the Symfony abstraction for the other convenience tools it has and for interop with existing component that use it or produce it.
I'd like to see some discussion on this rather than just down votes 
Further, it also makes the sample code for router documentation a lot simpler. Pretty much everyone should recognize that closures and named functions are almost always interchangeable, but the documentation very obviously shows that the third parameter (in your example) will be invoked when the route matches. Other than simple pages (`return (new View('some/view'))-&gt;render();` or such), you'll usually want to break it out into somewhere else. Or at most, pass a closure that just proxies through to an actual controller.
[removed]
It's for best practices (encapsulation as detailed by another poster), and makes testing way easier - you *really* don't want to mess around with global state like that in unit tests (it can easily leak across tests, causing both false positives and false negatives). Each test can create a mock request and pass that around as needed; contrast that to throwing around `$_POST['foo'] = 'bar';`floating around all of your unit tests and then trying to clean up between tests.
 try { $result = $clanService-&gt;startNewTeam($clanID, $gameID); } catch (ServiceException $e) { $this-&gt;logger-&gt;error($message = $e-&gt;getMessage()); return $this-&gt;redirector-&gt;route('clan.home')-&gt;withError($message); } return $this-&gt;redirector-&gt;route('clan.details', [$clanID])-&gt;withSuccess('Team created successfully'); The advantage of this is you can catch the result of the processing in startNewTeam to perform some operations with it.
Are you using my library? No -&gt; Use my library. Yes -&gt; Good.
Did anyone else look at the new [preg_replace_callback_array()](http://php.net/manual/en/function.preg-replace-callback-array.php) and immediately think: "Oh hey, a full-blown router implementation in a single native php function!" How inadvisable would it be to implement a router with that? How would it perform, relative to existing, dedicated router implementations (given they're all running in php7, of course)?
People are free to disagree or offer their own suggestions. This is a good a place as any to discuss them. But many won't. The handful of people who have the expertise to seriously recommend a cryptography library will also recognize that the ones I suggested aren't broken. And a lot of the folks without the expertise just don't like it when I'm decisive. So they'll down vote and silently move on.
Only the bottommost one, Halite, is *mine*. And it's not stable yet. Libsodium: I contributed very little. Defuse's library: He named me a coauthor because I contributed a bunch (mcrypt to openssl migration, made it PSR-4 compatible). It's still his library and he has sole commit access. So not only is this a gross mischaracterization of what I wrote, it doesn't even make sense. The only path that ends up at a library that I own is currently unreachable because the answer to the question is "No".
next part of send email from localhost in php - part 2/3
Yo! I'mma let you finish, but sending mail with [Swiftmailer](http://swiftmailer.org/) causes much less headaches than trying to do it yourself. 
Or use tags which are a little easier to manage.
&gt; More than 75% of the websites that you regularly visit, including the likes of WordPress, Wikipedia, Yahoo and Facebook use PHP as their web development framework. Managed to fuck up in the very first sentence ))
&gt; In my case, if the subscription creation fails on Paypal (due to bad credentials, invalid parameters, etc.) I wouldn't want the subscription to be created. Would that work with what you're saying? No. I was assuming a seperated case, where a use creates a legally binding contract (Subscription) and the fulfillment are seperated. So the contact would be created first, then the paypal payment is a seperate process. If you want your Subscription to fail and be reverted, you are in quite a nasty spot. My suggestion would be to still keep the entry, but have it marked as "invalid" or something. Regarding the actual logic i see two options: - I would not change the business model from the original example, instead modify the repository to queue the subscription into an asynchronous process that handles the fulfillment at paypal. - OR if you need the validation (credentials etc), you should actually do it when constructing the domain command, thus even prevent it being sent off to the command handler.
I can actually tell you, i implemented a system quite similar. On our webpage users can book subscriptions and pay via different methods (including paypal). What i actually do, is create a Subscription once the user completes the checkout, which has ONE SubsciptionInterval, containing the start and end, to it. The software then tries to request payment from out payment provider, using the entered credential for this interval. As long as this happens, i keep the user on a "payment commencing" page, continuously refreshing it. If the payment provider returns to me that i need to redirect the user to paypal, i do. If they use CC and payment works i redirect the user to a success page. Now the catch: If payment fails, because they do not complete paypal checkout, business intelligence can track failed subscriptions and see where users quit. If paypal payment works, i keep the transactions for paypal recurring payments, and once their subscription ends, i can automatical renew it (if they desire) by adding another SubscriptionInterval and requesting payment again. My point is: seperating the Subscription itself from fulfillment helps :)
We have a similar system (we also support different types of payment, including manually-validated bank accounts), so knowing that it works in your use-case gives me confidence in this approach. I'll study these changes and also try to add "fulfillment" to our vocabulary! Thanks for your help :)
This is rather like suggesting people protect against SQL injection by using bin2hex(). Sure, it works, but it's kinda missing the point. Plus, interoperability is often more important security. Sure, XSalsa20 might offer better security, but I'm trying to send data to an application that expects RC4 and rewriting the application I'm trying to send data too simply isn't an option.
What you are hinting at here is Liskov Substitution Principle, which aids us greatly in testing and flexibility of adapter exchange. Like u/dracony says below, scalar types are necessary for OO. Encapsulation helps us write better code.
Well: public DOMDocument::__construct ([ string $version [, string $encoding ]] )
Well if it is mutable it is clearly not a value object by definition =) Also it can process HTML and XML which is a lot of logic
This is a rather good point to raise. &gt; This is rather like suggesting people protect against SQL injection by using bin2hex(). I'd rather liken it to suggesting people protect against SQL injection by using parametrized queries. It's great in general, but not if you specifically don't use a database platform that supports them. (It also, most likely, isn't relevant to `$nosqlSolutionOfToday`, for that matter.) If anyone believes that you have any other concern that overrides security, then the general advice I give to a general audience obviously doesn't apply to your situation. This flowchart is for people whose requirements are simply, "I want to encrypt data securely." For the record: when dealing with clients (i.e. people who are *paying for my time* to help them), I don't give general advice, I offer specific and individually tailored solutions to their requirements. What I offer freely aims to solve at least 50% of the questions I encounter. :)
Is there a reason an assoc array in the constructor won't do here? This is what I do, as all data comes as arrays anyway (from the request, from db...).
I don't feel strongly about it one way or the other. It's a built-in class, so probably not worth arguing about.
How do you do that? you mean in a docblock?
&gt; Closures are simply code statement blocks you can pass as a parameter. Yeah....except they're way more costly than function strings. Each time the code `$fn = function();` is run this is [the engine code](http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_closures.c#553) that gets called. For callables that are function names, all that is done is a reference to the string is added, which is way lighter. &gt; now you need to manage names and avoid name collisions, I don't normally find this to be an issue. 
&gt; I've always been under the impression that exceptions are for exceptional situations The impression is right. But it is an exceptional situation for the application if it can not perform the requested action because something went wrong. May it be internally or caused by the provided data. So exceptions are the right tool here IMHO.
They went the pragmatic route and did an incremental rewrite, what's wrong with that? No one said 8.0 would be perfect, but it's certainly better.
BTW as long as you use caching, FastRoute is faster than all the other routers (even ones that claim to be faster than FastRoute).
That should do it :). Thanks for the help :).
You need to partner up. Laravel has a community that large because: - It's **brutally simple** to get started with, first and foremost. You *might* have that down already, so good job. - It has a **neutral design**. Everything is pleasant to the eye, and feels *evergreen*. If I look at Laravel's logo in 5 years, as generic as it might be, I won't feel like it's outdated. Pixie, on the other hand, - and I'm sorry if this sounds harsh - just isn't very pleasant to look at (and I don't care about sexism or other stuff people decimated you for before - it's the brand name and the visuals of pixies that just don't sit right with male adults - your target audience). If I were at a hackathon / hackerspace and was working on a project using PHPixie, I'd be tempted to hide my screen when others passed me by if the logo were displayed. With Laravel, I couldn't care less. **Lesson: remove the aesthetic factor by making it neutral or pleasant.** - Taylor **partnered** with Jeff to get regular **video tutorials** out. Profits are shared, and Jeff gets an early peek at new stuff, thus being able to produce videos way before the features are released, in turn being able to release the videos on the same day the features are released. - Same thing with Stauffer for **written content**. That's two types of content (video vs text) talking about more or less the same stuff, covering both preferences of would-be users. Both of these areas are **not done by Taylor**. You mentioned in another comment that you just don't have time for this - neither does Taylor. That's why he delegated these tasks. - Once momentum had been built up, it was time to roll the ball downhill and start **exponential gains**. Laracon was thought up, then Larajobs came into the mix (same deal as the two above). The principle of compound interest applies to community building as well. The last step is critical for maintaining a community and fostering its self-replication. With this, Taylor made sure that even if he died tomorrow, Laravel wouldn't. The community steamroller is in full swing, and too many people (and companies) have the Laravel needle in their arm.
PHP Package Checklist is handy http://phppackagechecklist.com/
Is `&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;` a valid `$name`?
abstract public function giveMeWhatINeedMan();
I think this is a good learning experience, but Elastic Beanstalk creates the EC2 instances and load balancers for you. All you have to do is upload your PHP site in a ZIP file, and you're good to go. I would personally say that Elastic Beanstalk is for the beginner, and manually deploying and configuring your own EC2 instances with LAMP would more a little more intermediate 
Exactly, I'm saying it *should* be shoved in their face... And it's not really a complaint, just an observation that we get so many almost identical questions asked regularly.
Validation and behavior encapsulation aren't necessarily the same. You can have a validation layer, you don't always need it in value objects. In `RedisCache`, is `143.10.32.1` a valid `$host`? A value object wouldn't guarantee that it's a valid IP address on the current network that points to a running Redis instance… What if `$host` is `"foobar"`: is it valid? It depends on the DNS now… Other example: in `User`, is `mnapoli` a valid `$username`? A value object wouldn't guarantee that it's not used by any other user for example.
We found much the same thing when we switched to node-sass.
To expand and possibly clarify on this slightly: If: 1 THB = 1.243 USD Then: 1 USD = (1/1.243) THB
yes. first make sure link_type gets defined as a property of that object.
Well, it's not a bad practice. I don't think it has especially something to do with DDD. I learned it more as a code smell: "If your class has too many objects in it's constructor it's probably doing too many things with scalar objects. Try to refactor to several smaller objects with small parts of their business rules."
Heroku is decent. They run well, easy to deploy, and has excellent customer service. I dislike how little control you have over the box, like configurations and stuff. Seems like you have to roll your own buildpack to do anything slightly out of the norm. Also, I wouldn't call Amazon "ridiculously expensive". Not when you take a step back and look at all of the things you get. AWS isn't just about running a server, it's about building and running massive complex infrastructure. If you just need AWS for one or two instances then eh, yeah, you can find that cheaper from places like Linode or DigitalOcean.
Php doesn't care, this was a zero value nitpick.
[removed]
That is not a valid flowchart. It starts with a decision that is not within a decision diamond. There is no start symbol. The end points are using process symbols, not end symbols. For flow charts, please use the appropriate symbols (and yes, there is a standard). http://www.edrawsoft.com/flowchart-symbols.php http://www.edrawsoft.com/flow-chart-design.php http://www.hci.com.au/hcisite2/toolkit/flowchar.htm The ANSI Standard symbols from 1970: http://it.toolbox.com/blogs/enterprise-solutions/ansi-standard-flowchart-symbols-20726 Here's a whitepaper from 1970. http://www.fh-jena.de/~kleine/history/software/IBM-FlowchartingTechniques-GC20-8152-1.pdf 
As much as i love the symfony stuff, the router isn't really light weight.
If not PagodaBox, how about Google's App Engine or running your own Dokku on a VPS?
[removed]
AppFog is easily the best. Other than that, AppEngine.
On a side note, you should check your exchange rates. It's about 1USD=35THB right now.
If the idea is hashed out, you can get by with one senior dev and one top notch graphic designer with animation skills but you will have to steal them from somewhere else and that kind of talent will cost you .. about .. 250K a year in salaries if you're serious and want to succeed - and that's only if your idea is good.
So you will hire people for being sited doing nothing more than thinking? You probably will want to equip with games and stuff similar to Google. Still, if someone of your developers have a very good idea, they probably wont share with you. IMO you better learn web development and try to think an idea, but to be realistic, everything was done, the only thing that you can do is copy and improve other ideas. 
If you are feeling a bit adventurous, you could try setting up [dokku](https://github.com/progrium/dokku) on digitalocean - there is an official image on DO - and run your own PaaS. Note: PaaS systems - and stuff like AWS - are expensive for a reason. They provide systems that you never thought you'd need without the required effort to build them.
In a DDD system, I **would** use reflection to break encapsulation, but only when saving/loading entities from the DB. This is because DDD Repositories are responsible for maintaining the *illusion* that every entity is sitting around, available in memory.
I really like www.chunkhost.com. $5 a month for a full linux vm. Great performance too!
And how about performance? I heard that reflection is extremely slow, even slower than call_user_func_array(). 
It depends on what you're trying to build and who you're trying to build it for. You can start out with an idea on building an app for doctors, but if you're not a doctor and no one on your team is a doctor - how will you know what you should put in the app? There are companies that exist that do this sort of thing, they have people with ideas for companies that come to them and say, I want to build an app for doctors - and then the company will connect them to all the people they need to make it happen: project managers, full stack developers, graphic designers, etc. They might take equity or connect to an investor to pay the bills and hope it works out but most times it won't. Bottom line is, you need a very large bank balance to make this work. You can't just hire a php developer and get cracking on building apps. Well you could, but you shouldn't. 
Here you go: https://3v4l.org/W6ZSe Basically to convert the fractional part, you're doing a reciprocal operation from the way you do the whole part. Note that this has precision issues. Increasing the precision passed to base_convert_fraction will help with this. An alternative course of action would be to decompose the float into mantissa and exponent, and base convert those. That would give better fidelity, but this is something of a strange exercise anyway, so ymmv.
Typical bad codeigniter blog post. In a controller, $this-&gt;brand-&gt;insert(. What year is this? I stopped reading right over there.
Note that in the real world, converting from A-&gt;B-&gt;C is often different than A-&gt;C. If you work with a lot of money, the differences start to matter.
Is it really *simpler*?
Can anyone explain what the appeal is of these PaaS providers is? Is it just so you don't have to learn much about running your own servers or something? But then you need to learn a vendor specific way of setting things up anyway? So seems to me that time would be better invested just learning and setting up the software on your own VPS. Also how can you test properly in development without having the same server config?
+1 for fortrabbit. Awesome platform, excellent support, easy scaling, fait pricing. I've been using them for mission-critical apps for more than a year now and they never disappoint.
Awesome. Thank you, I'd rather use another library for this, since base conversion is a solved problem in computer science. 
Heroku is hosted on Amazon servers, so you're paying for the AWS stuff plus Heroku's proprietary platform. Only paying for AWS wouldn't seem ridiculously expensive in comparison.
The Dokku image DigitalOcean provides is kinda iffy with some node apps (I know where I am). Give dokku-alt a look, along with dokku-alt-manager. dokku-alt-manager is a web-based interface for dokku, with some nice additions, like the ability to dokku-alt as a service from inside another docker container. Definitely worth checking out: https://github.com/dokku-alt/dokku-alt
A little one about commands and events... When using a commands and domain events - is it ok if the command *returns* a value? for instance, lets say I have a controller method which creates a new user, but needs to return the resulting entity, as it's an API. I might do something like this. public function store($request) { return $this-&gt;user-&gt;save($request-&gt;all()); } Where the return value of save is the saved model including timestamps etc. In command land I might do something like: public function store($request) { $this-&gt;dispatch(new CreateUserCommand($request-&gt;all()); } but I still need the result in order to return my JSON. I'm using Laravel and it's built in command bus - but I suppose the real theory wouldn't go astray either. Laravel does allow me to do this: public function store($request) { return $this-&gt;dispatch( ... ); } But I'm curious as to whether or not this is wrong and if so why? what are the alternatives. Thanks!
I use DigitalOcean and so far so good!
modern php, but most complex and important side effect of modern development isnt there.. testing. might be good anyway, gonna read it
This was just an example made on the spot :)
Except it seems like dokku-alt is a dead project, while the original dokku project is getting multiple commits daily. 
Stupid question but what is the difference between these services and the old fashioned shared hosting?
Seconded. I use Fortrabbit for a website that makes use of the workers, cron and DB and find it's rock solid (touch wood). I haven't tried their new SSD backed infra, but look forward to trying it when it's fully migrated. Their technical support is great and they're always quick to respond with accurate answers.
Seeing the activity on /r/yii/ ...
They usually abstract the concept of your server infrastructure into things which can run your app. You buy some compute time and some storage and some network traffic, tell it where you want to replicate, tell it how you want it to automatically scale under load and off you go. Sure there is ultimately servers somewhere doing the work, but in essence you get a "platform" that you can mount your app in and all the business of being a server is (to varying degrees, depending on who you use) abstracted away. There are downsides. Typically you have less control and less choice when it comes to installing non-standard features... and the convenience usually costs a bit more
I'm glad you took /u/phpdevster advice o starting Pixiecasts =)
I really really need to do something about my voice sounding like Im eating an apple at the same time =\
I feel that for me Yii and laravel are pretty much the same type of framework. Symfony and Zend are another type of Framework. By this I mean that Yii and Laravel both have heavy "influences" from Ruby on Rails. Active Record, Code Scaffolding etc. I have also noticed hat most people that do not like Laravel for whatever reasons do not like Yii for the same reasons. Same for people who prefer Laravel over Symfony/Zend also are more likely to prefer Yii. One of the major "issues" with Yii is that Yii 1.1 and Yii2 are drastically different and a lot of the reviews and overviews you will see are all for Yii 1.1. This is not far to Yii and its developers because they completely rewrote the whole Framework from the ground up so that it is a "modern" PHP framework. I have used Yii, Laravel, and Symfony professionally and for me they are all have somewhat the same development flow. I mean at the end of the day its up to the skills of the developer and how they organize their code if the framework is a good fit for them. TL;DR Yii is fine if that is what you need. If you do not like AR do not use Yii or Laravel. If you do not mind AR or know how to use it correctly then the application development of Yii2 vs Laravel 5 vs Symfony2 should be familiar if you use the correct OOP practices. That being correctly decoupling your code and writing it to be framework agnostic. This is also a very shallow explanation without much in depth details so sorry for that.
Let me know if you find out, I've never had a satisfactory answer to this. I pay $19 per month to ServerGrove for a Debian vhost, and I host 4-5 small sites on it with different domains. For each site I manually run a deployment script each time I merge to master, although I could easily add a hook to do this. Really don't see what benefits PaaS would give me.
look at drupal 8 code
&gt; next PHP code style standard Why would they make another coding style standard?
Because of language evolution. Existing style standard doesn't mention new constructs at all.
Where do I get an amazon instance for $7/mo?
That's actually a neat idea. I should try smaller takes
don't.
Instead of looking at the source code of frameworks, you might find it easier if you look at the source code for projects built using these frameworks, or low level code. I don't want to post too many links but a good example would be https://github.com/CodepadME/laravel-tricks for the Laravel framework, you can also see the functioning website for this code base too which helps. There are many projects on Github like this.
Ok, but that's my question. How to find these projects that are written in a php framework.
Yes, it's very useful, as I've mentioned in the [book](https://gum.co/skjRR). In fact, in the freetime people like Donald Knuth are reading sources like it is science fiction. Off the top of my head: https://www.reddit.com/r/PHP/comments/338atn/introducing_the_symfony_demo_application_symfony/ https://www.reddit.com/r/symfony/comments/205w7z/good_open_source_symfony_projects_to_contribute/ https://github.com/Sylius/Sylius https://github.com/stfalcon/portfolio https://github.com/EmanueleMinotto/awesome-symfony2 https://github.com/lisachenko Good luck!
https://www.google.co.uk/?#safe=off&amp;q=symfony+based+open+source+projects
You've still got to secure whatever you're running on (i.e an Amazon EC2 instance for example). You can never just ignore security and assume by using a 3rd party system you're secure.
I meant OS-level security becomes someone else's problem when you use one of the PaaS services rather than run your own server instance on DigitalOcean/Linode/AWS/Dedicated etc
Before naming the tool as "modern" this should be implemented: * MySQL is hardcoded. There's other database engines available: PostgreSQL, SQLite, etc. * Some kind of standard code style. Spaces and tabs are being mixed. * Composer auto-loading instead of writing your own autoloader. * PHPUnit tests. PHPUnit is included by composer.json but it's not being used. * https://github.com/Javanile/SchemaDB/blob/master/src/Javanile/SchemaDB/Database.php#L63 contains a hardcoded debug=1. This value should probably be settable in a constructor or as a static property. * Column names are not being escaped. There's valid column names that are also reserved keywords in MySQL, those need to be escaped. PDO gives you that for free. See https://github.com/Javanile/SchemaDB/blob/master/src/Javanile/SchemaDB/MysqlComposer.php#L189 * Full SQL injection vulnerabilities. Please use prepared statements. https://github.com/Javanile/SchemaDB/blob/master/src/Javanile/SchemaDB/Storable.php#L171 This library is outright dangerous to use in production.
Yeah that makes sense. Especially the PCI compliance stuff if a company were taking card details but didn't have the resources to do this themselves. I guess I'm coming from it having spent half my career as a sysadmin, so perhaps I'm underestimating a lot of this stuff for most developers. &gt; Running apt-get update on a production server that handles several million dollars in transactions will quite frankly get you fired. I was a bit confused about this bit? Why wouldn't you run updates on a live server? (obviously after testing on dev/staging) What would the alternative be?
so 4? where some of those one can make the argument where they don't even use standard PHP... 
php-7 will require new psr's for code styling :) finally return types \o/
If Drupal 8 is built on Symfony 2, how is that not a framework (hybrid)?
1) It's hip and cooler 2) It's fine-tuned. You know exactly what you'll get. No such thing as unlimited this or that. If you're getting 128 MB dedicated, that is yours to keep. 3) Scaling. The biggest advantage is scaling. You expect the traffic to go up? Spin up more instances. Only pay for that one day your traffic went up. If you have an ecommerce shop, then only for 10 days before xmas as an example. Also, several instances mean you can cater to many requests in parallel. So instead of making just one instance big, you have several smaller ones. This is why it's ideal for apps; like mine. As more and more people install my app, I can keep on increasing the number of instances. 
Reason I never want to configure my own box is because of security. Making it secure like a fortknox is not a trivial task. And I know absolutely nothing. It's also a fast-changing field. A new exploit, you gotta fix that ASAP. That's too much learning, and I can't do that on my own. I understand it's a great skill to have, but I am just not equipped for it.
Exactly that. I can't set up my own server to save my life. Setting it up once is probably something I would be able to do using tutorial or whatever. But the problem is security and patches and stuff. That's a whole discipline in itself. Keeping your server secure is not trivial. On top of that, if something goes wrong with the server, you must fix it all all by yourself. With a PaaS, I can wake up in the night, just click one button and its done. The backend is taken care of by their engineers, not me.
My colleague has found that one of the PHP functions doesn't do quite what he wants and has written a custom replacement. It's a general-purpose utility function that could be quite useful in many circumstances. How do we reconcile this with dependency injection? i.e. If he uses this function in a class, then it's a hidden dependency (as it also is if it's say a static method on a class - e.g. Utility::utility_function()) Adding it to a class and injecting it as a service on the other hand seems incredibly long-winded especially since it's a single function. Thanks for any suggestions/replies on how to handle this sort of thing :)
look
after that...
something like what's happening inside is not visible outside? magic box is suitable? But I was a beginner at that stage so everything was a magical black box for me at that time? even the command line.. :P
Thanks for the detailed answer, I'll try yii.
::class returns a string of the Class with the fully qualified namespace. The former returns the Class... you cannot instantiate a class with a string which is why the ::class one fails.
I agree that exceptions are not for error handling. What I would recommend is using a "Payload" object to pass return type data around. That way its encapsulated, and you can Factorize its creation. ``` interface IPayloadFactory { public function createSuccessPayload($data = []); public function createFailurePayload($data = []); } ``` 
I have a component to map data structures in OOP way, here is example of simple mapping https://github.com/spiral/guide/blob/master/odm/standalone.md#standalone-example https://github.com/spiral/guide/blob/master/odm/oop.md#compositions-and-complex-types I'v been using it to filter, validate and manipulate nested JSON stuctures for a while, but i'm not sure if ODM can handle all required features you need.
I am fortrabbit co-founder. this thread is of course very interesting for us. we can learn what you expect from hosting — I guess we are sometimes to deep into it. I have blogged about **P**HP **H**osting **P**ossibilities around half a year ago: http://blog.fortrabbit.com/php-hosting-possibilities that overview might help categorizing different solutions and also names some more alternatives, not mentioned here yet.
I don't think you would need to use DI for utility functions, but if you necessarily needed this I'd go with a DIC like [pimple](http://pimple.sensiolabs.org/) to do what you want and pass the container around.
I haven't really heard of this before, but I can't say as I think I'd ever really use it. It's introducing more bothersome to locate state that can affect the outcome of the execution of the same code which is something that PHP already has enough of to start with in php.ini and ini_set. &gt;Imagine that you use a third-party library (or a framework) and at some point you need to change its behavior. However, the code to be changed is in a private-method of some class in this library. The obvious solution is to edit a file that contains the method. Is it the obvious solution? It's a private method - the maintainer of the library has basically advertised you should never program against it or imagine it will continue to exist as it does now. The obvious solution is to not depend on anything marked 'private'. If, for whatever reason, you really must then what seems obvious to me is to instead inherit from the class and wrap it to provide the desired interface, and to carefully ensure that any updates to the library invoke relevant tests to ensure that the upstream didn't break my code by changing the private interfaces before going live. Mucking bout with the run-time to clobber the existing method is just a much less obvious and less testable version of what I just said above. &gt;With runkit you can also organize updating of the program code on the fly That's just not something PHP is meant to do. It's not something nearly any language is meant to do. If you're talking about a system where a few unserviced requests are fine it's much more stable to just take the system down, update and bring it back up. You can often do so in less than 10 seconds if you have an established cycle to put new code live. If you do care about any downtime the only solution I know of that's reasonably proven in the real world is the Erlang VM's. (Well the only solution I know of that wasn't made in-house for a specific system.) Trying to update the source code for an interpreted language on the fly is tempting the God of untested edge cases to cause interesting errors to arise. It's plenty possible that code passing every test in a good unit-testing setup could fail in some miserable way if you happen to be in the middle of an update during a request's processing. 
Try replacing the `+` with `%2B`. Cookie values should be sent percent-encoded.
What if this were a front end problem? I'm getting the cookie from elsewhere (an internal log in server), and simply passing it on. Would that simply indicate a problem further upstream (i.e. the log in server response?) Or, should I be handling that inside my front end code - Angular side. I would have thought Angular's $http module would automagically do stuff like this for me. Learned loads today, mentally tiring but interesting all the same. 
The "+" symbol is the URL equivalent of a space. You should URL encode it or use [setrawcookie](http://php.net/manual/en/function.setrawcookie.php) 
&gt; Yeah....except they're way more costly than function strings. Each time the code $fn = function(); is run this is the engine code[1] that gets called. How often are you calling `indexPage` in a single request.... Once? What you are suggesting is more than a simple micro-optimization..... Its basically a nano-optimization on something that didnt need optimizing in the first place.
My experience with V2 runs up to about 2-3 months past its release. They were still running into issues where their network infrastructure was breaking, causing our clients' sites to go down. By now they may have all of the kinks worked out. As of ~June 2015 it was still too unreliable, and we were planning to move everything off PagodaBox onto something else. We just hadn't figured out what that "something else" was yet before I left. As far as I know Viaduct works the same way as PagodaBox. The UI is less polished, but you can control the number of instances, the size of the processes, etc. I'm not 100% about the actual system architecture though. I am also in North America. To be honest we mostly used Viaduct for static sites since you can host them on there for free...until they decide to no longer do that of course. Here is the literature on that: https://viaduct.io/pricing &gt; No such thing as a free lunch? There is with us! Every Viaduct application contains a free 350MB process &amp; hobby level database with 1GB disk space so you can deploy small apps without paying a penny.
I am glad this thread is back. No idea why the original one disappeared, I personally very like runkit and it can be useful in various circumstances. Congrats Zenovich for such amazing work to keep maintaining this extension. 
I appreciate the effort. I know how hard it is to maintain documentation and make/write tutorials for the stuff you publish to the world. 
[removed]
I dont think so. Without runkit, all the other approaches to make plugins are awkward, slow or extremely complex. Of course runkit can be abused if not used properly, turning codebase into a mess. But it is supposed to be an advanced tool, so you shouldnt touch it if you dont know how to do it right. Just like Python and Ruby's metaclass, its powerful tool for good programmers to use to simplify the tasks. 
Looking at AWS vs other IaaS solutions, it can also be about what's right for the job you're doing. I'm of the mind you need to be platform agnostic and find what fits right for the client/job/business. I like Rackspace for that as close to bare metal experience as possible, but they're hard as hell to scale. For applications that need to scale, or have more performance demand, AWS fits better.
lol
Whoops. The title confused me. I'm going to keep it and check it out anyway, might recommend it to a friend
Thanks! You can see the old one by its direct link https://www.reddit.com/r/PHP/comments/3o5hnd/dmitry_zenovichs_technical_blog_runkit_104_php5/
I'll just throw this in there for a concrete opinion - while I prefer Laravel above all, I would use Symfony before Yii. I find Yii's API a bit convoluted, and the documentation is not organized well and/or doesn't get to the point. Also, just from looking at Yii's code, I can see it's not crafted with the same quality that Symfony is. So IMO, Symfony offers better documentation and better code quality than Yii, despite having an equally obtuse API. Feature-for-feature, I really have no basis for comparison. I don't really use a framework for its bells and whistles, because the more bells and whistles it has, the more assumptions it needs to make to implement them. This means it's either luck that the bells and whistles are a good fit for your use case, or you spend so much time writing code to wrap the bells and whistles that they weren't really advantageous feature to begin with. I've found that Laravel gets the basic stuff (routing, controllers, CRUD modeling, dependency injection container, and templating) the most correct, and has *hands down* the best documentation for it.
Typo3 Flow, yeah right? Who uses that?
The only Symfony component Magento is using is Console and I'm pretty sure they're using the Symfony1 version of that. Otherwise Magento uses Zend 1. That means nothing is namespaced (except for the pseudo-namespacing they do with their classnames). Compared to lots of other stuff around Magento is well engineered but I wouldn't call is a snapshot of modern PHP.
So I ended up using your library (thank you) and made mine dependent on it. :) 
Kind of a silly response, but obviously PHPUnit. Everything else depends on the project requirements.
I have used many languages and frameworks, I have been using Yii 1.1 then Yii2 for the past 18 months or so. I have nothing negative to report. For everything I have needed I have been pleasantly surprised. I can definitely recommend it, Yii2 especially.
Saves hours of work for everyone on your team, but is slowing you down a few seconds. How is that a problem? If you run composer dumpauto -o ...it will make your program even faster (-o =optimize). Too much RAM? Works fine on my $35 Raspberry Pi. Are you on a c64 or P1?
If you are running on a public VM, maybe you should change your release cycle to not run composer on the vm, but before, and rsync up.
http://www.sitepoint.com/introduction-silex-symfony-micro-framework/#controllers and the Laravel docs go on to say that you should use controllers. Yes the anonymous function way is possible in all of these, and perfectly fine for a dozen or so routes. 
Agreed.
&gt; Looking at AWS vs other IaaS solutions, it can also be about what's right for the job you're doing. I'm of the mind you need to be platform agnostic and find what fits right for the client/job/business. Spot on, totally agree with you! &gt; I like Rackspace for that as close to bare metal experience as possible, but they're hard as hell to scale. For applications that need to scale, or have more performance demand, AWS fits better. Funny you mentioned Rackspace, we just migrated from Rackspace to AWS because of the reason you mentioned (scalability). 
It used to be. Node.js upstream had a shitty cdn, which affected not only dokku but heroku (and rails, since they use coffeescript/node for asset pipelines). Hella lolz. Heroku just switched to their own cdn and called it a day. As an aside, I'd probably never use dokku for many reasons - maintenance being one - but also because I'm one of the dokku maintainers ;)
So you do that in production? Looks like the start of a project. TBH, pulling down all the dependences manually and putting them in place manually, not to mention the added fun of making sure everything is autoloaded correctly, would be more time consuming.
[lstrojny/functional-php](https://github.com/lstrojny/functional-php)
To be fair, you have to be a wizard to learn that from their pricing calculator. And by calculator I mean a car salesman.
Yeah i Hear ya, Drupal 8 has all just switch over to using Symfony 2, yay it's awesome, but fuuuuuuuuu.... layers upon layers upon layers of objects I can't figure out how to debug... at what point do you go back to flat file content management?
Or just Drupal 7.
Well the No button is easy: &lt;button onclick="history.go(-1)"&gt;No&lt;/button&gt; Many things are best solved with javascript. 
For "yes", you could use a javascript alert('Thanks'), but it's much better to find a script for an in-page dialog (not really a popup), and use that.
Yeah I got that working thanks! Might try the yes button with JS
&gt; CI, deprecated Was CodeIgniter deprecated? From their site, it doesn't appear so.
I tend to think that with a little planning you don't need a framework unless the application is pretty complex. In fact the codebase generated makes a simple app unmanageable quickly. At my current employment I maintain a CI app built by multiple devs over the past 15 years or so (I've been there 5 months) and it's a monstrosity. It's an insurance application "integrated" into a wordpress installation. It has two user databases that need to agree and every section of it (11 in all plus various subsections) has up to 6 or 7 locations where essentially the same code would need to be changed for even minor modifications to be consistant throughout the various states of the application lifecycle. It frustrates the hell out of me because it's only a single page insurance application with some validation yet somehow it took a couple hundred files. Sorry for the rant but I think sometime a framework is overkill.
Hear hear!
Wordpress is not a framework though, so I don't think that's a great example. I'm developing a CRM application now and switching from vanilla PHP to Laravel has increased development speed by a factor of about 5 by my estimates. Not to mention the code is cleaner, more secure and easier to maintain. I've deployed a couple of small single page apps built in Laravel in an afternoon that would have taken weeks without it. 
If interested, please feel free to reach out! Else, die you useless scum.
The phrasing of your comment doesn't explain why you're interested in this, just that you want to be certified. Considering that, I'd go for whichever one is the cheapest/least amount of effort.
On your question 1... it's important to agree to some terminology that both you and the business have common ground on, and be prepared for that terminology to change in the future. When it changes you should update your codebase to reflect the language of the business. So if it is Country now, and the business wants to call it Location, change it to location. The software is a reflection of business processes typically - you'll save yourself a pile of confusion in translating concepts if you just agree to call things what the business calls them. 
But shouldn't a developer understand the platform his code is running on? If you server config differs then you can't be happy in the knowledge nothing will break and die?
PHPSpec. Excellent BDD testing framework that's much more readable and less verbose than assertion based frameworks such as PHPUnit.
Use Laravel. Thats the simplest answer I can give you. Yes, learn about VM's and build your site within one. Learn about modern tooling only as much as is needed for your project. Do NOT start writing raw PHP. Any project that is a business size application will require a framework anyways, or you'll end up creating you own little one that nobody knows by the time you are done.
On that topic of debugging: I hear ya. A good IDE (personally love PHPStorm, but there's others out there) and Xdebug will go a long way.
From their site, script.aculo.us is state of the art.
Then you're using it wrong. Visit phptherightway.com and learn to code correctly. There's a reason all self respecting developers use it.
thanks for your interest. a bit offtopic here: we really really want to come to the US and we are planning it for a loooong time. but we have learned that we need to be really careful about communicating ETAs.
Just grab a copy of Laravel 5, subscribe to Laracasts, and call it a day. It is a really solid and supported framework with a flexible folder structure. I was a CodeIgniter guy for a few years. After I took a look at Laravel I knew it was "the future." It has a lot more of an object oriented feel to it than CodeIgniter, and it doesn't have nearly as opinionated of a structure. The types of apps I was making were a better fit for Laravel's CLI commands since I was creating lots of tasks that were run via cron jobs. Kohana is basically an updated version of CodeIgniter, or at least it started out that way. It is a CodeIgniter fork that originally aimed to drop support for PHP4 and focus on the more advanced features in PHP5. I'm not 100% sure how its codebase compares to CodeIgniter now. CodeIgniter is not deprecated by the way. It changed ownership a little while ago, and people continue to develop for it. Laravel leverages some Symfony packages I do believe. If it doesn't now, it did at one time. I suppose there is a possibility that much of it has been re-written from scratch by Taylor Ottwel (the creator of Laravel) by now.
[fzaninotto/Faker](https://github.com/fzaninotto/Faker) for realistic test data and [filp/whoops](https://github.com/filp/whoops) for better error messages (for dev env only ofc) are part of almost every project I write
You test against the PaaS service to prevent this...exactly the same as you would with "standard" infrastructure. You'd have a dev and staging environment which mirror production. You use automated integration testing to sanity test your deployments (post deploy regression testing etc). There are multitude of ways to be "happy in the knowledge that nothing will break and die" that do not involve having to be an expert on building and maintaining servers. And no, I don't think the developer need *necessarily* understand the platform their code is running on (beyond knowing that components and versions that are available on that platform). They are developers, not server admins. Mixing the two isn't something we should necessarily be advocating. Server admin is a specialist skill - we wouldn't ask the operations team members to understand the code we're running on their servers. 
&gt; I suppose there is a possibility that much of it has been re-written from scratch by Taylor Ottwel (the creator of Laravel) by now. this is exactly why not to use laravel
&gt;I can't decide if I should install a virtual machine as a dev box to host vagrant to spin up VM to develop the app...or if I should just godaddy and raw php. Firstly, you should never godaddy anything, now go read php the right way 3 times as penance for your sins. Secondly * Use digitalocean, their VM's start at $5 a month and are easily backed up, trashed and restored. They also have a tutorial for setting up practically anything you would want * Use symfony2 as a framework. You will still be able to write raw PHP if you want, but at least you will have some decent tools and a good place to start refactoring when the time comes. You could also look at laravel, but the rest aren't worth the time unless you inherit a project * Use doctrine and migrations. Again, you can still drop into raw sql whenever you want, but you will still have the advantage of a decent toolset when you need it. * Buy PHPStorm. Seriously, can't be explained, just do it, it's the only software I pay for. * Start writing code and learning as you go. Things to keep an eye out for are db tools like snapshots/fixtures, automated testing with phpspec/behat/phpunit, TDD and DDD, automated deployment/provisioning with tools like ANsible, analysis and metrics tools like ELK and statsd/grafana
Stop making jokes or waxing poetry, and just learn the goddamn thing--that's what the decent salary is for. I have been in you position before, ie. out of one's comfort zone with what seems like an overwhelming amount of things to catch up with, but it's a case of rolling up one's sleeves and getting started. You might not get back that feeling of "I know almost everything there is to know about PHP" from old days, but there is nothing stopping you from learning a framework or two and becoming productive again if you are diligent enough.
 $candidates = ez_curl("https://jobz.io/rest/get_a_coder", "Ayy lmao, spare nerf gun over here, any1 in?"); array_reduce($candidates, function($rockstarninja, $nextchump) { return (pass_helloworld_test($nextchump) &amp;&amp; $nextchump-&gt;salary &lt; $rockstarninja-&gt;salary) ? $nextchump : $rockstarninja; }, array_rand($mechanical_turk_guys));
Maybe you could make some kind of Translation service? So lets say you have a ApplicationNaming interface and a BusinessNaming interface which you can implement into your classes like country etc. Internally you work with the classes that implement the ApplicationNaming interface, but if you need to switch to the other Naming format then you translate your ApplicationNaming classes to BusinessNaming classes by calling a translation service (or reverse) Like this: $namingTranslator-&gt;translateTo(ApplicationNaming $appNaming, BusinessNaming $businessNaming); $namingTranslator-&gt;translateFrom(BusinessNaming $businessNaming, ApplicationNaming $appNaming); 
Being ok in the controller layer is an interesting point :) I think in this case it was something to do with merging a pair of arrays for passing to a form type (symfony). One common case that seems to come up sometimes is the need for a nice "slugify" function. Thanks - will advise to inject them I guess - it's worth the little bit of pain to keep the dependencies clear and obvious (and testable :)
nikic/iter
Wordpress is not a framework and has very limited core apis. The rope whose this were either under instruction that it had to work in Wordpress or didn't know any better. Same thing happens in Drupal but at least it slightly resembles a framework albeit a framework built from spaghetti :)
You can try and get the business to use generic terminology but if they don't want to...you just gotta go with what they call things. Because they'll talk about *those things* in meetings and having everyone trying to use a terminology rosetta stone to decode what each other is talking about is tedious and shit. *Hopefully* you are lucky enough to work for a company which is collaborative and doesn't mind having discussions about these kinds of things but if not you just have to grin and bear it.
I think it's funnier if you think that the use of die() was intentional :)
Because for a small app you probably don't need all the advanced features and bloat that comes with a full fat framework.
You'd use small and simple apps to practise and gain experience with the big frameworks so that when you finally have to build that big app in a big framework you have at least some clue of how things work. The term "micro" in micro-framework doesn't refer to the size or complexity of the app you're building with it, it refers to the lack of features in the framework itself. 
[Bazinga Faker](https://github.com/willdurand/BazingaFakerBundle) makes using Faker a very simple process with Symfony also. 
Except he's wrong, it still uses tons of Symfony packages.
sure. I looked at it a few month ago, and there was several things I didn't like. a few examples (from what i recall, and not complete) * they make a big fuzz about using symfony, but they are only using a few parts, and seem to struggle with some of the concepts behind what they are using * they insist on their own coding standard, rather than to join in with coding standards every big framework including symfony is uisng * they do stuff like putting everything to the webroot * they've build an island, by putting up their own packagist instance, and using packages from there and the most important part why I said "don't": if someone uses drupal8 code to learn, he won't learn about real world examples of modern PHP usage, he will learn the drupal8 way. I would have loved to give a better answer, normally i'd send people to phptherightway, but he asked for projects where he can read source.
SHoot me your skype :)
This isn't inconsistency. It's misalignment of business goals and application implementation or evolution of business goals. Communicate with them more, figure out the business goals and stop thinking the name is the most important. The goal is the most important. Understand the goal, but also council that early over abstraction has its own dangers. It sounds like they want to be acquired so naming with their industry is important to them. In that case learn that naming and get it documented. Everything you've mentioned is a more generic name of the things you have. Why not have a thing called location and only store a country? That's fine. Then once you have additional data you can store it on your location object. The day underneath could still be a table named country and anothrr named location with more info including references to country. It sounds to me like you've over specified the domain as you see it now and too specifically named things anyway. The business is telling you that and you see it as inconsistency, but the inconsistency seems to be with understanding the business goals. Don't write shims and translators and other BS, refactor this inconsistency out of your app over time and communicate to the business that you'll make steps every week to get consistent.
Sigh... at least make it correct. That undefined var is just annoying.
What exactly do you hope to achieve through these "tests"?
I mean, is this normal in some places? The amount of work seems absolutely crazy as just a part of the interview process. I would have to imagine that drives away a lot of great candidates who don't want to spend a week working for free. 
And more consistent. First they use `print`, then suddenly `echo`.
Not quite there yet, I have not dropped in enough buzzwords to really get them excited. He is merely starting to froth at the mouth with anticipation.
You've gotten used to being an expert and forgotten that experts learn slower. Embrace your inner novice. Didn't entirely mean that to sound like bad Eastern philosophy, but that's my advice anyway.
Yeah it can, recruiters will do literally anything for that commision. A few years ago a recruiter put forward a likely candidate for a job that the company had advertised. CV looked really promising so we get him in. The recruiter had doctored his CV and changed every instance of Java to PHP/Python. Worse though is that he was actually looking to make a career change to C/C++ and the recruiter told him it would be heavy a C++ environment. It really was not.
At least he did not attempt a try catch with AwwComeOnINeedToEatException()
No commission, he is not eating this month :)
Oh I believe that recruiters change resumes to fit roles all the time. I don't have a problem if you actually had experience in C and they just highlight. It's completely different if you're a PHP expert, never touch low level code, and they change it to C. Or worse. I see you're experience in front-end javascript. Let's change that to java.
My only suggestion is to stay farrrrrrrrrrrrrr farrrrrrrrr away from things they can google. Switch it to an in office interview where they have to perform a code task. You can immediately see if they are competent or not. One specific task that I had to do once was create an RSS feed. It's quite challenging to do in say an hour.
I know this person is a troll, but if a newcomer to PHP asks why composer is important, here is a good response.
Recruiter: java, javascript... same thing!
Job security! "I'm trying to hire someone to learn what I do, but no one will interview!"
It's a very small application.. Just a CRUD, acl and api call ... . The colleagues here can do this is about 4-5 hours... .
I don't understand? It's so easy, man. First, just learn **HTML**, **CSS**, **JavaScript**, **jQuery**. Then you'll want to pick up a server side language. You're a **PHP** dev so keep using that, but then pick up a framework like **Laravel** or **Lumen** and grab all the other goodies that complement it like **Envoyer** and **Forge**, and use a **Digital Ocean** or **Linode** (I love Linode) server. Of course you'll need to learn some basic server management and how to secure a server with **SSH** keys. You'll need basic **terminal** command line, **git**, **composer**. Also learn basic **HTTP** and **REST** and how to debug with **Chrome Dev Tools**. I recommend learning **nginx** and picking up a cache like **APC** or **memcache**. As for databases, **MySQL** or **Postgres** are the popular choices, but don't forget to learn how to take advantage of **Redis**. Now that that is out of the way, lets get back to the backend again, you'll likely want to learn some additional things like **OAUTH2**, **Websockets**, **SOA**. Oh back to the server, learn **vagrant** and **homestead** either through **virtualbox** or **vmware**. Ok now let's move to the front end. You'll need to pick up **SASS**, **LESS**, **Stylus**, **POSTCSS**, **Bootstrap**, **Foundation**, **Gulp**, **Grunt**, **Bower**, **Require.js**, **Angular.js** (or other JS framework like **Backbone.js**, **Ember.js**, **React.js**), then make sure to take advantage of **coffee script**, and... actually, just learn all of this: https://coggle.it/diagram/52e97f8c5a143de239005d1b/56212c4e4c505e0045c0d3bda59b77e5977c2c9bd40f3fd0b451bdcf8da4aa52
I'm so excited for this. 
You're telling me you can build out user authentication, access controls, an API to manage a resource, and integrate with OAuth from *scratch* in 4-5 hours? I'd hate to read the pen-test report that follows.
[removed]
It happens more than you think. I've corrected many recruiters who have used the two interchangeably.
Note that there is some missing whitespace in the output, though. There is no space after "Hi there!"
You should have 80% of the application already written and then give them tasks to complete it. That would * show you they know basics of PHP * are familiar with frameworks and critical thinking * can work with existing code bases * allow you to test their knowledge of specific facets without having to make them do it all from scratch * decrease the test time dramatically * not waste everyone's fucking time
It’s in Europe. Seems to be going for the equivalent of “a position where you can make lots of ca$h.”
If that was the case I don't really see why that is a problem. As long as the framework as a whole still plays nicely with other Composer-style packages who really cares whether the base framework uses a Symfony package or a custom written one for say...routing?
Yep. You're right. It still uses a few Symfony packages. Per [Laravel's package.json](https://github.com/laravel/framework/blob/5.1/composer.json): * "symfony/console": "2.7.*", * "symfony/css-selector": "2.7.*", * "symfony/debug": "2.7.*", * "symfony/dom-crawler": "2.7.*", * "symfony/finder": "2.7.*", * "symfony/http-foundation": "2.7.*", * "symfony/http-kernel": "2.7.*", * "symfony/process": "2.7.*", * "symfony/routing": "2.7.*", * "symfony/translation": "2.7.*", * "symfony/var-dumper": "2.7.*", 
Honestly I've never gotten to a face to face interview with anything from a 3rd party recruiter. Company recruiters are much better IMHO.
Many articles/blog posts compare the different frameworks; you can get a pretty good idea of what's popular and what are the strengths/weaknesses in a couple of days. If you still can't decide between some, then the difference is probably not critical--just pick one. Laravel and Symfony are fine and popular, but you could get the job done with Zend too. 
I would suggest starting here: http://symfony.com/blog/create-your-own-framework-on-top-of-the-symfony-components It does a great job of teaching you how to use composer and how to integrate different components into your app, as well as why you would want to use an HTTP abstraction layer vs calling echo $_GET['foo']. These skills can easily transfer to other frameworks and make them easier to understand, they are not just limited to symfony or silex.
Yeah, makes sense. Otherwise people keep asking why the product's late. I personally heard good things about fortrabbit and the only thing that stopped me was the lack of a US server.
To be fair he didn't say it had to be from scratch. At least not in the OP. Like I assume you could use a third party OAuth lib and he wouldn't have a problem with it. But none-the-less I agree with your sentiment - it's a silly test that's just a waste of time.
&gt; Else, die you **rebel** scum. FTFY
Are your colleagues junior to "medior" PHP devs?
best advice i can give on all recruiters is ask for a copy of the resume they are submitting on your behalf incase you get an interview offer.. if it looks different than the one you gave to the recruiter.. walk away. other people are honest and want money like that recruiter did.
That's what I was afraid of with Drupal 8. Everyone's all "it's built on Symfony components therefore it must be better!!!@22!@", but that's not how well designed code works. A tool built to solve every hypothetical problem with heavy assumptions is going to be an obtuse motherfucker to work with.
Okay great, thanks for the info.
Hey op, just cus I don't understand all this negativity i'd just like to say that I don't think it's overreaching at all... I remember going through similar interview processes (given a week to complete a task); if I really wanted to work for them I would complete the task, otherwise I would not. It's a decent way to filter candidates based on motivation. This wasn't in the US which might have something to do with it? Now I'm employed and when recruiting what we do is almost identical, but everything is done in office. 2 hour spec analysis + paper design followed by 2 hour implementation of a part of it (login, acl, 5 field crud, api call). Most don't finish but we don't expect them to.
I guess i am thinking about it too much
And indeed: RC5 has been retagged :)
&gt; I guess i am thinking about it too much It's possible... way easier to do in AJAX with a nice ORM. Of course this generator likely wont have any sort of validation or anything... but its pretty easy to do this in say Slim. $app-&gt;get('/products', function () { $app-&gt;render("products.php", array("products" =&gt; Products::all()-&gt;toArray()); } $app-&gt;put('/product/:id', function ($id) { $product = Product::find($id); $product-&gt;update_attributes($app-&gt;request-&gt;put()); } ... etc 
Anyone else find it annoying how much Guzzle changes versions?
OP: Here's an actionable suggestion. Timebox your assessment to N hours, where N is in the range 1..4. If this is a take-home task that you expect the applicant to hand in, at their own leisure, within a week, that's one thing, but make sure it can't take longer than a reasonable amount of time. (Also, make sure it's a reasonably light work load.) One way to do this is to take a simple application that is already finished, carve out a feature (say: take a lightweight blog platform you built and you remove the tag feature), then ask every applicant to reimplement the feature you removed. Collect facts (did they write unit tests? is their solution vulnerable to SQL injection?) and base your hiring decision on the quality.
here's mine: http://lazymofo.wdschools.com/
The whole MMORPG realm has been overdone with PHP applications. Honestly, I would like to do an MMORPG in some functional language like Clojure perhaps or Haskell 
They need to be able to edit out your contact info and put their company's logo in place of it. A legitimate reason, I suppose. They don't want the company going around them and contacting you directly because then they don't get their commission. Granted I've never actually submitted my resume to any recruiters who I didn't want to work with, so I've never had issues with them faking my resume. If someone contacts me (a PHP/Javascript dev) with a C# position (which happens ALL THE TIME) I just tell them no. Unfortunately I do frequently get recruiters who try to "persuade" me into interviewing for a job I don't want. "Only" once has it gotten so bad that I had to threaten to report the recruiter to the police for harassment.
Oh go on, I *dare* you. Cool, you did it! I'm getting my coat...bye!
beberlei/assert (https://github.com/beberlei/assert) Super simple input validation. I use it everywhere and it has saved me a bunch of times. 
I'm waiting to learn how to decouple my app from php :)
Whatever language you choose has very little to no effect on the end user. Why use those languages over a much simpler language? What benefits does it give to the end user?
Join *insert mafia name here* we run on Clojure and stuff. Yeh that's really going to mean something to gen pop ^_^
That might be why you're always getting -23487 on your comments, because your jokes sound like pointless/ignorant trollolol.
I'm more annoyed by the lack of proper documentation. A few loose examples that cover only a few use cases doesn't count.
As long as I'm running the project, there won't be another major version bump any time soon.
Can you open issues suggesting documentation updates, or better yet, help out and submit pull requests to add better documentation?
OT but, I had started a new project, and chose to use Guzzle. When I started, it was version 3. It couldn't have been but two or three months later and suddenly it was on 5. Since I hadn't locked into a version in composer, a composer update grabbed it and broke some stuff. Which I suppose proves Phils point, but I digress.
guzzle/guzzle
Right right I'm not blindly advocating always having abstractions for everything, im pointing out the way abstractions are used to add a buffer to changes in dependency. If A uses B and B changes all the time then maybe shove a C in the way, so you only have to change C when B changes. It's a trade off. Using a SDK, HTTP client, etc. might be easier without the abstraction, but it'll be less brittle with it. Sometimes I do, sometimes I don't, Repositories are the same. Sometimes I shove my ORM usage right in the controller and fuck anyone who wants to judge me for that.
this type of abstraction work work perfectly with doctrine, but active record - not so much ... Although I see your point.
"Simultaneous" meaning all 60k over "what period of time" -- a second, a minute? That will help determine your performance/scalability needs.
Unless you're Google or are offering are shit ton of a lot of money people /aren't/ going to highly motivated to work for you. They may have a passing interest or curiosity but every barrier you put up to employment is one more reason /not/ to work for you. The market place for devs is pretty competitive and if you want a dev to work for your company instead of another you're gonna need to sell yourself to that dev hard and not play the stupid games with devs that the op is proposing. At least with your company it sounds like they do their stuff all in house instead of expecting people to do it at home. It's pretty standard for tech interviews to take a half day so if that day is spent doing 3 back to back interviews or is spent working on a 2h long implementation it's whatever. But giving people homework assignments when they're not even employed? It's just gonna rub people the wrong way.
CakePHP has a CRUD generator: http://book.cakephp.org/3.0/en/bake.html and http://book.cakephp.org/3.0/en/bake/usage.html It will build forms, controllers, models, etc. using your existing database schema if it follows their convention. If you have an "exotic" database you can create the models yourself and the system can generate the controllers / forms / views. 
Sorry, knew I should of quantified that, so around 30k-60k per hour during peak times (few hours around lunch, first thing in the morning), then dropping to approx 10-20k for the rest of the working day. This info was gleamed from the client via Google Analytics and some calculations, so can't verify - the projects dropped on my lap and just doing some initial fact finding
I haven't benchmarked my PDO wrapper but, here it is: https://github.com/ellisgl/GeekLab-GLPDO
Ah that's good to know, I've got experience in propel 1.6 so nice to know its still in the running - thanks for the link!
I don't like this. Arrays are totally different use case to me. An array is usually a bunch of items than vary between implementation in the same codebase. Think multiple forms that feed into the same save functionality. Each has their own list of fields but the save functionality only cares about it being in an array. Calling a function/method is usually consistent with the parameters you use unless you are using the splat functionality for params.
*cough*: - https://github.com/zendframework/zend-escaper/blob/d643a846c4e810aae74220892b6009bf419c52cd/src/Escaper.php - https://github.com/zendframework-c/zend-escaper/blob/82ee7a7380a9efc04c7fd5edd5de9bcd351a18b9/zend/escaper/escaper.zep - http://framework.zend.com/manual/current/en/modules/zend.escaper.introduction.html EDIT: Yes, I know the RFC mentions those, but I'm highly against having userland stuff ported to core *just because*.
60k over a "few" hours (3?) means roughly 20k/hour, divided by 3600 seconds in an hour, means roughly 5-6 requests/second if they're divided evenly. That's a big "if" because I don't know what kind of spikes you're going to see: if you get spikes of 100x more per second that changes the calculus. So, if we're talking a continuous 5-6 requests a second, just about any ORM should be sufficient, provided you avoid standard pitfalls like N+1 problems. My guess is that the key will be handling the number of writes at the database level. I am not a DBA but I imagine even a stock MySQL server should be able to deal with that.
When you say "just about any ORM should be sufficient" do you think I should be worried about the memory/CPU footprint of using an ORM against a simple PDO wrapper? Obviously adding/upgrading hardware at can solve issues like this, but would be good to get your thoughts.
Interesting. Is there a nice dark sublime theme too? So used to it these days. Php Storm is so ugly to look at when you first open it up
- [Splitting viewports is supported by default](https://www.jetbrains.com/phpstorm/help/splitting-and-unsplitting-editor-window.html) - [Looks like this plugin gives you the code preview thing](https://plugins.jetbrains.com/plugin/7275?pr=clion) There's some great plugins out there. I particularly like [this one](https://plugins.jetbrains.com/plugin/4455?pr=clion), which shows you the shortkey for that function you just clicked (teaching you to use shortkeys instead of clicking around). 
Your ``mysqli_query()`` call failed because you have an error in your SQL. You have to check for ``$result !== false`` to make sure your query did not error. I personally would recommend to use the object oriented style: $connect = new mysqli("localhost", ...); $result = $connect-&gt;query($query); instead of $connect = mysqli_connect("localhost", ...); $result = mysqli_query($connect, $query); I find it a lot cleaner and your IDE will probably show you the possible methods via auto completion. I also would recommend to make MySQLi throw exceptions with ``mysqli_report(MYSQLI_REPORT_ERROR);`` (for real errors like SQL errors) or ``mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT);`` (for real errors and warnings).
I would urge you to use PDO if possible. It's best to learn the current standard, this is very out of date now. I can provide a few useful resources if you'd like. EDIT: Here's a good article. http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers
If you really want this now, you can use an array with the `...` operator. Eg https://3v4l.org/HDmPr
 function isPerfectForJob(resume) { if (resume.contains(someSemblanceOfPrograming)) { return true; } else { return true; } }
I'm torn on this one, but in the end I think allowing trailing commas in method calls are a *bad* idea: * They are far-more-likely to indicate an error by the programmer (compared to hardcoded arrays) * Function calls with lots and lots of positional arguments are something to *discourage* anyway. People shouldn't *need* to be adding/removing hardcoded items as much as with arrays. 
Interested to hear your argument for this. Do you think it leads to less maintainable code or do you think the maintainability it provides is not worth the overhead of writing a class?
I don't know why but my IP is blacklisted, op. 
From the link: &gt; Some people have asked about this, since return; and return null; are technically equivalent in PHP; when a return value isn't specified, PHP will produce null for you. However, choosing one over the other suggests intent. If you specify a value, it suggests the value is significant. In a void function, the return value is insignificant: it's always the same and has no actual usefulness. Specifying it explicitly with return null; is pointless, because it doesn't really matter what value the function is going to return. &gt; &gt; Since void signifies an unimportant return value that won't be used, this proposal requires you to not specify one. This extends to null just as it does to any other value.
Yeah. I agree with OP from pure semantics, but I like the forced consistency the RFC brings. 
Sometimes I wonder why I bothered to quit writing C or Java.
I think this is way too much. A whiteboard pseudo code session should suffice to gauge the level of one's critical thinking.
They can still copy/paste the text from the pdf into their own Word document, which is what they usually do anyway. In my case my cv is a web page, and i print it to pdf if someone requests it as pdf. That print has an URL on top so they can always get to the most up to date version of the CV, and yet I still get calls from recruiters that have a 2-year old version of the cv that don't get the concept of a web page.
but that Word document will be marked with their name, unless they take specific action to remove that information.
The error is in the SQL comment: there has to be a space after the two dashes. The SQL syntax error is causing the `mysqli_query` to fail, so it returns `false` instead of an actual MySQL result, hence the error message. Also, your teacher or whoever wrote that SQL comment, is right: you're not doing anything with the profile table, so your users will be loaded with other folks' profiles. Having said that, tell your mentor that they need to test their code before handing it back to you. Take this opportunity to let this experienced programmer teach you, that testing your programs is more important than writing the code. You can't fix any bugs that you didn't spot because you didn't test well enough! Most importantly though, **your code is extremely unsafe** and you need to be aware of this if you're going to work with SQL queries. Read [this](http://php.net/manual/en/security.database.sql-injection.php) from the PHP manual and check out [phptherightway.com](http://www.phptherightway.com/) while you're at it. Don't do this for yourself, do it for your users, whose data you're leaving wide open for hackers to steal. Please learn this stuff before you have to learn it the hard way!
Closing the `&lt;?php` bracket is considered bad practice so I'd say he got that right.
I don't know if you do this, but when I initialize a property in the constructor, I don't assign it a default in the class. But if I don't initialize it in the constructor, I'd often type this: protected $foo = null; There is no difference. It'll be null either way, but one demonstrates intent to leave the variable as null, and the other demonstrates an intent to initialize it in the constructor before use. Also technically null isn't the absence of a value, or we wouldn't need ?? in PHP 7 and isset() would behave same as key_exists() for arrays. But they don't. This is a big issue for values that mean "no value", that if you're not very careful in how you design an API, the difference leaks, and now you need to treat it like a value. And this is what has happened in many languages.
&gt; Just a CRUD, acl and api call What exactly would you call a large complex application? The same thing with an animated gif? 
Yii has one too (I think most major frameworks do): http://www.yiiframework.com/doc-2.0/ext-gii-index.html
use RedbeanPHP sql functions like getAll, getCell, getCol... there is no overhead when using these functions they are just simple wrapper over PDO
&gt; but what benefits does it have over treating null as no return value I believe the intent is that returning `null` is an actual value that can be manipulated like any other, whereas specifying void as a return type could potentially be used to signal a specific intention and reduce logic errors as a result. For example, the PHP interpreter will throw an exception if you try and return a valid from a void return function, because it's obviously a logic error of some kind. Additionally, a future RFC might also throw an exception if you try to assign the return value from a void return function for the same reason.
Because there's a fundamental conceptual difference between `null` and not returning anything. A function that does not return anything doesn't produce a value for consumption by the caller. Attempting to use the result of that function invocation makes no sense **and reveals a fundamental misunderstanding of the function you are invoking**. Returning `null` on the other hand indicates that the function does (logically) produce a value, it's just that it didn't produce one this particular time it was invoked. Differentiating between them allows the compiler/interpreter/etc. (depending on the language) to catch programmer mistakes/misunderstandings: If you try and consume a value from a function that doesn't produce one you don't get `null` (i.e. the function produces a value it just didn't produce one this time) you actually get an error and are impelled to reevaluate your code (i.e. you discover the structural flaw in your program rather than it being disguised).
60k visitors doesn't necessarily mean only 60k DB requests. Depending on the application -&gt; many parts of the site can be db powered, like various footer header widgets In our app we have to hit a database 20-30 times per page in order to collect all of the data needed to render the page. 
Came here to ask this. I agree - null makes a lot more sense with the rest of PHP.
You should check out Laravel homestead vagrant box. It is a great box for just plain PHP dev even if you aren't using Laravel as it has a bunch of PHP extensions installed by default. Also you can just follow the docs on Laravel's site and they have instructions on how to get it up and running and they are super easy to follow. Also there are videos on laracasts.com with guides on how to get it up and running, although I'm not sure if those videos are free or not (some are and some aren't). Also: definitely use vagrant
Nice, thanks. I'm going to try this option first and see how I like it.
Lubuntu, or the more polished XUbuntu if you like pretty things. I'm a fan of XUbuntu personally.
[Scotchbox](https://box.scotch.io/) is ready to go for LAMP development - its what it was built for. (scroll down on the page for basic features and tutorials for how to use it) Even comes with node tools for pipeline processing.
Thanks, I'll try XUbuntu if it doesn't work out with Lubuntu. Honestly, I don't need bells and whistles, I just want two write code and test it quickly. Fastest route from Development to Testing to Staging to Production is really all I need right now.
&gt; I tend to think that with a little planning you don't need a framework unless the application is pretty complex. Or you're working on an application someone else will inherit, working with other people, or you just don't hate yourself. Seriously, use a framework. "It's just a simple app" sounds like a reasonable thing to say but clients/employers change the scope and add in features at the last minute and before you know it your simple app is a full fledged email client and is sending daily reports to the entire company. Why not build it on something simple that you can grow with than have to rebuild it later or spaghetti code the shit out of it?!
Thanks! It feels like this class (or a similar one) "should/could be/is" a de-facto standard of how a PHP-programmer should deal with escaping? Should not this type of interface be built in within the ordinary PHP distro/extension? Or are there arguments against that?
Why do you think that returning something is a better option? In your example return value shouldn't be an indicator whether the argument passed to the method was valid (either a boolean instead of string or simply an invalid format).
Great characterization of why XML isn't used anywhere else in the world anymore. :-) XML is a beast, but with a huge, declarative config app, it can be a necessary beast. Seriously though, what would you recommend as an alternative? YAML? JSON? ...? JSON + JSON Schema seem like a possible candidate. *edit for tone &amp; qualification* 
It's not meant to indicate the input was valid, it's meant to indicate the operation succeeded. I've never liked void functions. If a function is supposed to do something please at least give me an indication it succeeded or not. How are you going to write tests around void? Rely on everything else working? Even if you want to give no indication for whatever reason, why not at least pass pack a chainable reference? GP's example code could benefit from such sugar. $time = $clock-&gt;setFormat('c')-&gt;getTime(); &amp;nbsp; [edit: Sorry. Thought you were the person I originally replied to. Fixed.]
Not sure I follow? "What are the most widely used php framework by enterprises?" != "What is the most accurate snapshot of modern PHP development?" If your question were asked, I'd never list Magento 1 as an answer. It's 8 years old! Also, Magento 1 doesn't use Symfony - at all.
*\^--- I like this person*
Just to be clear: Magento 2 absolutely will run on PHP 7.
Vagrant. Stick with your mac (tons of extremely well know developers use them, and use them for a reason) and use Vagrant for your development. There's no FTPing or moving files.
Sure, if you want to return value to indicate success, it's perfectly fine. It probably depends on the context though. I'll try to explain my point of view using the same example. The way I see it, there is a set of predefined time formats that are supported. Using anything else shouldn't be permitted. Therefore the actual problem lies within the argument validation. If the method doesn't have any side effects (which it definitely shouldn't), then it doesn't make sense to check for it's result when all it does is set the argument value on a private/protected property. &gt; How are you going to write tests around void? Rely on everything else working? Why should I have problems testing this? If I'm testing a method that depends on setting time format, I would confirm that the `setFormat` has been called. Then I simply would test the actual method since I don't particularly care about anything else at this point. `setFormat` should already have it's own test verifying that only certain arguments are accepted. It isn't any different from testing return values. What I'm trying to say is that return values are probably better suited to methods that actually perform some operations (for example, `sendMessage`, `createReport` etc.) instead of simple setters.
Hey, I'm liking Lubuntu, but I'm having an issue. How do I view my website that's hosted on the VM? Is there a local IP address I must visit on my host Windows machine? Basically, the VM is my development environment and I want to see the site prior to launching it on the production server (duh). What am I missing?
Yeah, I agree with mentioning it. No expectation of return value -- use void. Expectation of null return value -- use null.
My biggest issue with adding it to PHP is that `void` is being proposed as a compile time error, not a runtime one. It's literally just parsing for `return` with a value. Seems to me that's just a rigid early bail. As a dev, it doesn't actually get me anything I can use other than a syntactical problem outside of the existing behavior. Further, though a little nitpicky: I can appreciate the beauty of a nice exception block. The thing is, if these are such simple methods what's throwing in them? If there's no validation in the method what reason would it ever have to throw? DB exception maybe? Seems to me, you'd want to alter the object and perform some kind of save operation for the DB later (one query vs several - likely not void or will have at least some logic in it). Some other lib being called and throwing? I can see that. [edit: forgot your second part - I actually don't know the history of void. I should look that up. I've been writing code for decades and it's always been there in a bunch of languages. In such languages, I've often seen it used when rich exception handling is the order of the day. I've just never been around when it's proposed. It's just one of those things I've used more as a pattern than a need. Often for things like setters, adding an informative return can be as simple as `return !empty($ret);` or `return $newVal === $this-&gt;_val;`.] [edit 2: [Looked it up.](https://en.wikipedia.org/wiki/Void_type) I found this bit interesting: &gt; Some early C compilers had the feature, now seen as an annoyance, of generating a warning on any function call that did not use the function's returned value. Old code sometimes casts such function calls to void to suppress this warning. ]
I didn't mix up anything. Magento 2 is far from production ready. I was of course talking about the most *current* version of Magento which is Magento 1.9.x. It uses ZF1 and one component of Symfony.
Out of genuine curiosity, do you add a trailing comma to the last item in your arrays right now? I think I would have agreed with this point of view before I started using the `multiline_array_trailing_comma` option in the [PHP Code Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer). However, now that I'm used to it, it's so nice not having to think about the comma when moving items around. And it doesn't have to be lots of items either...it's handy with only 2-3 items as well. Also, this doesn't always have to do with having lots of arguments, so while I understand your second argument, I don't know that it's fair to throw the baby out with the bath water. I'll often split my parameter list into new lines even when there are only 2-3 items. It can really help with legibility, especially when the function/method is long, or the argument variable names are long. It's also helpful in situations where you make other method calls or new up additional objects right in your argument list, to avoid the completely unnecessary temporary variable.
I understand the subtle difference in intent, but the end result is the same: your `void` hinted function will still evaluate to `null` in an expression, so it *is*, in fact, lying if you look at it from that perspective. If we're going to do `void`, PHP needs to throw an error when the function is used in an expression context. Otherwise, we should just do `null`.
It's not about OS mismatch, it's about being able to develop apps independently from one another, each having its own dependencies without clashing with another (PHP version, extensions installed, etc).
Personally, I don't like the taste of the "makes diffs smaller" kool-aid. You don't ugly up your language's syntax to work around deficiencies in your tools - you modify those tools, or use/create different ones.
Sane answer for /u/Danack and /u/donatj: You cannot both specify `null` as a return type and make compile-time checks. Suppose the following: function myFunc($id) : null { //instanceof MyEntityClass if found, null if not. $entity = $this-&gt;entityManager-&gt;getRepository(MyEntityClass::class)-&gt;find($id); return $entity; } This snippet should fail occasionally (when the entity is found), but would also succeed sometimes (when the entity is not found). The check would have to be placed in runtime, instead of compile-time. A `void` type explicitly forbids any return (even `null`), in whenever case. It doesn't matter the semantics, if the returned object is `null` (which is the equivalent of `void`/`empty` in php), `false`, `0`. If any expression is found with `return &lt;something&gt;` for a function/method that should not return anything, it will throw an error.
I chuckled.
JS supports trailing commas? I know JSON doesn't, at least not in my experience. Being used to trailing commas in PHP arrays I frequently do it in JSON on accident.
I am interested to try php7, but how to install this on ubuntu 14.04, am trying to add zend deb channel to source.list, but apt still can't find the php7 or php7-nightly
I would tend to agree that contextual escaping functions seem like obvious candidates for inclusion. They satisfy all of the "core-worthy" criteria that I know of: there is only one correct way to solve the problem, the use-case is extremely common, the risk of developers implementing it incorrectly in user-land is extremely high, and the repercussions for implementing it incorrectly can be devastatingly severe. I mean, this reads like a check-list for all the reasons password hashing made it into core, for example (and deservedly so).
It's not lying because void doesn't necessarily mean a function can't be used in an expression.
Locally or in a VM? for a VM I would just recommend Laravel Homestead and the php-7 branch. Locally you could try the PHP7 PPA https://launchpad.net/~ondrej/+archive/ubuntu/php-7.0
Compiling it from source is quite straight forward in my opinion, at least once you install all dev packages you need. If you try this route and have any problem we could try to help you.
It's already spaghetti. I understand how MVC works but years of different people working on this app has destroyed any organization. Is there a development tool for CI I'm not aware of that can centralize some of this code? Or even a PHP tool of some sort to help trace the origin of what is spit out? I've done ok so far but it feels like I'm flying by the seat of my pants every time I need to make changes.
&gt; as it's more accurate in describing what will actually happen, vs. lying to you to satisfy what you want to happen... This is the major reason why I don't think we should add void. Immediately once it's been added it will become a lingering phpsadness, that void functions return something rather than being void. And there will almost inevitably be an RFC two years down a line to make the functions marked as void actually not have a usable return value. 
Thanks! 1) As a result of &lt;https://github.com/relayphp/Relay.Relay/issues/5&gt;, it's so that the Relay can be used both for "server" middleware, and for "client" middleware. See also &lt;https://github.com/relayphp/Relay.Relay/issues/15&gt;. 2a) You're the second one to ask: &lt;https://github.com/relayphp/Relay.Relay/pull/17&gt; I'll take a look and make sure. 2b) That will take some investigation. 
thanks, ondrej's ppa works :)
Where are you getting that Magento 2 is "far from production ready"? We're releasing it next month. There are already M2 EE sites in development. Also, can you tell me which Symfony component M1 uses? [I don't find it.](https://github.com/OpenMage/magento-mirror/search?utf8=%E2%9C%93&amp;q=symfony)
I think I understand you. I should've mentioned that the link was a POC. In M2 it is as you say much more modular, as even the framework is abstracted away from the functional modules.
Actually, as of right now, `$value = myFunc(5);` is perfectly acceptable, even if `myFunc` has no return. PHP will simply assign `null`, as it already does for functions with no returns. Declaring a function as `void` is meant to avoid even `null` returns. You can't return anything. At all. Declaring it as `null` means you can return something, that something must be `null`. And therefore, you have to move the check to runtime, as you can return an object that may or may not be null. However, I do agree with you that the compiler should check for a return assignment on void functions. I've commented on the PR on github asking how the compiler will behave on such case. If it simply assigns `null` to the variable, then it makes no sense to disallow a `null` return type on a void function.
According to a Symfony site I found, it uses the Console component. Great to hear M2 is being released so soon. I'm involved in the German Magento dev community and there was no talk about the release at all. Is there an upgrade path from existing 1.9 installations? How is adoption among extension devs? This is really good news. I love how M2 finally uses the modern approaches to PHP development, that I use in all my other projects. I also love the amount of work you put in the new documentation. Do you have some kind of dev blog that one could follow? Edit: Just found the [Migration Guide](http://devdocs.magento.com/guides/v2.0/migration/bk-migration-guide.html)
Have you had a chance to play with it yet? I made a vagrant install to play around with it a few days ago as it's likely one of my clients will be moving to their platform [Magento 2 vagrant Gist](https://gist.github.com/Lewiscowles1986/f68dbf82b532838a76ed)
JS does, JSON doesn't. JSON is a lot more minimal, but that's ok because it's intended to be a machine format (I realize people use it for everything, like Composer's JSON config, but that's not the main purpose of it).
I have. I've spoken at a couple dozen conferences this year about it, and I've taught one of the M2 Fundamentals classes. Thanks for sharing the vagrant file.
Probably the post you found is talking about http://magerun.net/ - a great addon, but not part of core. Best things to follow are http://devdocs.magento.com and http://alankent.me/ 
&gt; Declaring a function as void is meant to avoid even null returns. My reading of the RFC is that null would still be returned. The RFC does not mention removing the default null return. And so even with this RFC: $value = myFunc(5); Is still going to be valid (but bogus) code. Hence this [comment](https://en.reddit.com/r/PHP/comments/3os32j/rfc_void_return_type_revived/cw0kiz0).
On your benchmarks I was running the loop, reqs/sec didn't work for some reason. But on my benchmark I wasn't timing the setup, only the matching.
Is mysqli not as safe as PDO? 
Just been playing around with profiling. What is a good amount to shave off a typical request? I managed to find a few easy wins and save about 100ms (from ~650ms to ~550ms). How much further is it worth going? The next couple of functions are around 20ms, then after that there are load more ranging from 1-5ms - individually negligible of course, but they add up. Any other tips for deciding what to target and improve?
Yes, there was the [skip parameters one](https://wiki.php.net/rfc/skipparams) but it got voted down.
Running it over and over to find out I needed another library was so frustrating. Eventually it worked though 
It really depends on how much budget is allocated to this. PCI compliance requires a lot of time, paperwork, and formalities. Using something like Stripe can alleviate the PCI requirements. I would personally use Shopify ( shopify.com ). For ~30$ a month you have a full site with a CMS, PCI compliance taken care for you, a built-in paymeent gateway, themes, apps, a REST API, etc.
For a PHP app? I would try this totally innovative, extremely fast, new &amp; improved approach: https://github.com/mrkrstphr/array-config
I advise you learn to use docker. It's a fairly steep learning curve, but if you know how to use it then you can spin up a new PHP 7 container with a single terminal command and start using it in a few seconds
If they hired a contractor who cares? Let them hire a contractor for all their work, as long as the work gets done for the amount you're paying does it really matter who did it?
Some companies have 4-5 hours of just interviews before you even go on-site. It's not that unreasonable. What I think is unreasonable is to expect to get paid for everything, you see it time and time again for silly stuff like an interview process.
Is there a requirements script that could determine if your system meets the needs?
You need to re-evaluate what "senior" means. 4 hours wouldn't even cover the testing time.
Thanks, alakent.me has some really interesting posts.
What happens if you sign an NDA? I guess you could ask the contractor to sign an NDA as well but idk that that'd save you from a lawsuit yourself.
Awesome. I'm using relay as the default middleware layer for my framework. To the first comment's point, I really think it was a mistake of PSR-7 to have two separate interfaces for requests and I'm happy that Relay does not tie you to the ServerRequestInterface. Now I just need to beef up my messages for more PSR-7 compatibility.
I'm not talking about Apache on the virtual image itself. In Vagrant the Apache running on the VM is using the default port 80 but you access it from a different port with your browser (on your computer outside the VM). Maybe it's different when using Virtualbox directly though?
 sudo add-apt-repository ppa:ondrej/php-7.0 sudo apt-get remove php5* sudo apt-get update sudo apt-get install php To add extensions: sudo apt-get install php-curl sudo apt-get install php-mysql etc. I've installed PHP 7.0RC4 on three machines on Ubuntu 14.04, and all of them were throwing an error on CLI and showing blank pages in the browser with no apache logs: zend_mm_heap corrupted I had to add the following line to `/etc/apache2/envvars` to make it work on Apache: export USE_ZEND_ALLOC=0 I've added the same line to `~/.bashrc` to get my CLI working again.
thank you but I don't think there is a need for PCI compliance or anything like that. It's a very small business with 10 products only. The payment gateway will be handled by a local bank that provides the processing (only way in my country; Lebanon). I'm thinking about Shopify but that means I'll be out of job :P. We'll see how it goes with the client. Thanks though.
I checked out Magento, it felt way overcomplicated for my needs. I'm currently considering going pure Laravel and use some of the available plugins like LaravelShoppingCart.
I observed a decrease in requests per second on various applications during standard performance tests. https://bugs.php.net/bug.php?id=70613
&gt; stupidly simple Yup. 
As soon you process a VISA, MasterCard, or AMEX credit card the PCI ( Payment Card Industry ) requirements applies. Before getting into e-commerce make sure you understand the requirements at: https://www.pcisecuritystandards.org/ Using something like PayPal or Stripe ( currently not available in Lebanon ) will greatly reduce what needs to be handled by you. Prestashop, Magento, SpreeCommerce are good options although they will cost more than Shopify or LemonStand ( https://lemonstand.com/ )
Eager to test out the new features. 
fuck!
Well, personally, I don't think the request should represent things like server params, as it's not actually part of the request. It breaks encapsulation. There are some things which ARE part of the request, but are generally derivative from other things, for example, request attributes and query params. Why can't I set a query param on a client request? I understand why I can't set an attribute as there's no standard way to derive those, but that could easily stand as a general collection principle for meta data since they are not actually explicitly defined in the request, but depend on either end's composition or parsing. Other things are not actually server request specific, but just require a slightly more nuanced interface. For example, why are cookies only abstracted in server requests? Can you not send cookie values as a client? Of course you can. Same for uploaded files. 
I halt every VM I'm not actively using. No accumulation. &gt; Also, is it really that hard to write deployment scripts that one needs a special tool aside from bash? Not sure I understand the question. Writing deployment scripts isn't all too hard in any scenario.
thanks I will look into it. Just as an example: I did implement a payment solution for a local e-ticketing website and never bothered with PCI compliance. I only spoke with the bank to give api access and it was ready to go. Looks like I have some things to read =). Thank you.
You are correct. I don't even remember why this discussion started, but I learned a new thing today. Thank you. And I've always agreed with you that it's far more important to warn "Hey, this function returns NOTHING, don't try to use its value because it doesn't exist!" then it is to warn "Hey, this function can't return anything, stop trying to return things!".
5th world country o ya!
&gt; Prestashop, Magento, SpreeCommerce are good options although they will cost more than Shopify or LemonStand Incorrect for Shopify. If I'm shipping products and want realtime rates then Shopify is $180/month. Prestashop is free. Hosting for Prestashop can be as low as $5/month.
Magento Go (easy) Magento (powerful) Magento 2 (the new shit)
docker doesn't have virtualization layer, so performance impact will be very small.
So I began using the PDO version and established a connection with my localhost which seems to be working. I am working on sanitizing it but how do I redirect to the main page once successful? if ($_POST['submit']) { $username = strip_tags(trim($_POST['username'])); $password = strip_tags(trim($_POST['password'])); $errors = array( 'username' =&gt; $username, 'password' =&gt; $password ); if (empty($username) &amp;&amp; empty($password)) { $errors[] = "Please fill out all fields."; } if ($errors) { $_SESSION['login-err'] = implode('&lt;br /&gt;',$errors); // Save the error messages in the session header("Location: login.php"); exit; } else { header("Location: index.php"); exit; } }
Your problem is that `$errors` is never empty when you do the check.
Thanks, but I can't be the only developer that signs on for it! Anyone that's interested can contact me directly to get invited to the org on github with write access.
Can you give an example of a language where a void function invocation can be used in an expression?
It took one single core hack. They have one line of weird syntax somewhere, I forget where exactly but I think it was in a base controller class somewhere, and if you fix that, then it seems to work flawlessly.
&gt; Immediately once it's been added it will become a lingering phpsadness, that void functions return something rather than being void. Why? It's not unique to PHP. &gt; And there will almost inevitably be an RFC two years down a line to make the functions marked as void actually not have a usable return value. That would break far too much. I think an `E_NOTICE` or something is more likely: that you could choose to convert to an exception if you want.
&gt; All functions have a return null; in them. There's actually a special flag on the implicit null-return at the end of a function which means it's treated differently from a normal return statement.
I really like this idea, and I'd be up for joining. However, it seems kind of overkill that you have 5 separate projects for organizing teams. I think you'd have a more cohesive and effective group if you start out by putting everyone together, and less chance of people being unpleasant to each other due to some perceived status from being in a more experienced group. If the group gets big enough, maybe then it would make sense to split people. I'd say throw everyone together and let their contributions sort out who knows what they're talking about.
The teams are self-selecting. You ask for the team(s) you want, and you're added to them. The Project.git repo is the central organizing repo, the repo we are working on will be separate from all of these (since it will be forked). The team repos are just a place where someone can leave an open issue for a specific team. The issues list on our forked repos will have labels for each of the teams, and each issue we want to get done in that two weeks will be tagged with the team(s) that should try and take care of it. No one will need to be on a specific team to do any type of work, I'm not putting together a dev shop here. It's just to help people organize the whole project in their head. I mean, imagine if we've been doing this for 6 months and there's 200 people on the project? Having at least the self-selected groups each person belongs to would be helpful, and being able to open an issue with a specific team that's not related to a repo we are working on would also be helpful. It's more for future proofing.
Sounds reasonable to me.
Bank gateways often offer something like Paypal standard payments only with their processing solution, which is usually a better option than paypal or the like if they are already paying the terminal fee for a brick and mortar setup. Not that its clear that this is the case with his client or that it also works this way in Lebanon.
Not to my knowledge. The first two week project "sprint" will begin on November 12th, as a congrats to the PHP team for releasing PHP7. That gives us enough time to put together our branching strategy, the guidelines, and decide which project will be our first.
As a fellow Laravel dev, I'd still go with Magento for the flexibility. For your project, maybe even check out Magento 2 which will be officially released next month. It handles very similar to Laravel (install with composer, ...). You'll still need some time to get aquainted with Magento2, but the new developer docs are quite nice. You can also be sure that it will handle all your needs. With other solutions you'll often reach a point where you realize that solution won't cut it anymore. I use Magento for one page one product solutions and don't regret it.
How are you sure there aren't any odd corner cases?
Neat, have you considered making a PR into Laravel with this?
This is awesome! Why this isn't in the core I don't know.
PHP certification is too common nowadays. That's why I want to do framework specific certification. 
Worthless reply given the need for validation. Great sarcasm though, 10/10.
Magento Go was discontinued in February this year (if you are determined to use a hosted Magento [Zoey/Pixafy](https://www.zoeycommerce.com/) are doing a good job). Magento 2 is still in "Merchant Beta", you'd be brave to use that right now.
This isn't in core because you can write a function to do it, e.g. public function country() { return $this-&gt;user-&gt;country; } The only benefit this adds is allowing you to use it as a property.
http://i.ytimg.com/vi/hEfa0C897H4/maxresdefault.jpg
[removed]
A large part of the python standard library is written in python. Do you think PHP should start doing this as well?
There is no suitable answer to this question because it isn't really a question. Video tags are documented in the html5 spec. You have the correct set up, but obviously your template engine isnt providing either 1) a valid url to a video, or 2) a video that is video/mp4, and we can't guess because we have no idea what $video (the only php relevent bit of your post) consists of.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required)
The design looks really nice aswel! Good job!
http://vignette4.wikia.nocookie.net/walkingdead/images/3/34/Wut......jpg/revision/latest?cb=20131121222224
Doesn't have to be practical. OP stated it's a simple web app. It's combining front end and back end. Good simple challenge.
I didn't use them though. But input field is Bootstrap design.
Show me on the doll which part is PHP.
Why not go all out and call them subroutines instead? I mean, you're telling a function to specifically not return a value, but you're using it in the same way as a returned value type comparison. I also don't like how return and return null are not equivelant anymore. Is void going to be a full blown type now too? What about return (void) null; ? ---- I really think this should wait until return values from 7.0 has been used enough in the wild to find a use for this. To me this seems unnecessary at the moment and speculatively trying to solve a need that hasn't presented itself yet.
Thought this was a /r/web_design post first, nice work!
Uhh, this is an image. Where's the app?
Processwire + Padloper.
Pay 9$ for Laracasts.com, watch most of them and start playing with laravel. I think you'll be glad you did. Laracasts will help you get past that lost feeling quickly.
It's /r/PHP, show us your code :)
My first website is a fictive carpooling website I'm ( supposedly ) making with a friend with a management of users, cars and trips The only problem I got is I can't create users with the web host I use so I use sessions for users connections I don't even know if that's a good idea
It's a mobile app that I made as a practise to cover some important things in programming language, in this case PHP.Here is the link http://responsivewebsite.netne.net (free hosting with ads).
&gt; The only problem I got is I can't create users with the web host I use so I use sessions for users connections I don't even know if that's a good idea What
Not sure if you realize this man, but you're kind of a cunt. 
No, not really. What web host are you using that you don't have access to a database?
You'll get more differing suggestions than letters in the alphabet, but I think most would agree getting to grips with a good framework is key, and I think Laracasts is an amazing resource for getting up and running really quickly.
Neat! Now make it an ajax call! Also I don't understand the arrows, and I wanna put in floating point numbers!
But the length of code is the same..
doesn't seem to convert 0 degrees.
My experience with that was more time on the phone/skype/etc than I had ever spent in my life up to that point, and code that would never pass a review in the US
For your requirements don't even look at magento. It's a over complicated slow whore (as others said and i agree). Go for open cart, prestashop or wordpress with woo commerce.
Check Idiorm and Paris http://j4mie.github.io/idiormandparis/ . It's really nice and simple to work with. 
You're right.I will try to fix it.
[It seems you misplaced a space](https://i.imgur.com/u8DllxQ.png). Also you need to [escape HTML output](http://firstwebsite.comyr.com/index.php?Tf=&amp;Tc=%3Cscript%3Ealert%281%29;%3C/script%3E). Then you need to [sanitize user input](http://firstwebsite.comyr.com/index.php?Tf=&amp;Tc[]=1). Other than that it looks pretty neat. Congratulations on this step, you're on the right track. *EDIT: mentioning HTML escaping instead of only sanitizing input.
Yeah I have a "users" table in my database with login, md5-ed password and all, and when a user completes the form and clicks "connect" it will check in the database and create a "login" variable in $_SESSION saying with which login he's connected I had the intention to make a "Create user" at signup and then connecting the user to the database whith his own account ( and permissions ) but i can't I don't even know which way is supposed to be the right one because I didn't learn PHP that deep in courses but it still works
The database connection credentials are going to be static, you simply verify the user against the table, but connecting to the database should be done the same way across all users. If you can run a SELECT statement against your table, then I see no reason you can't call and INSERT when the user wants to create an id.
Good, you don't create a new database user every time a new user is added to your site, you create a new ROW in a TABLE.
Oh that's what I was thinking, it seemed weird to create a user each time, I was like " how the fuck do big websites manage that much users ? " So yeah I have user rows and I use the PHP sessions to change their status ( connected or not ) Thanks :)
Great work but you have some security issues, you always need to escape the user submitted data before echoing it http://firstwebsite.comyr.com/index.php?Tc=%3Cscript%3Ealert%281%29;%3C/script%3E. You can do that with the following command: htmlspecialchars($str, ENT_QUOTES, 'UTF-8'); And you should also validate the submitted data to check that is indeed a number. Remember, never trust the user. Apart from that nice work for first project.
I like the design.
Thank you ! 
I thought that was a bug too.But -40℉ == -40℃ is correct. -40 x 1.8 +32 = -40
Colors are nice, simple idea, well executed. But let's say we want real time, how are you going to achieve that? Better yet, how about pop up the temperature based on the user's location and have a toggle between C/F? Obviously pointed questions because you should be looking to front end frameworks for stuff like that. Blaze.js, React.js, Angular and even jQuery can do this for you in real time. [Here's a simple example in jQuery](http://codepen.io/thatgibbyguy/pen/zvPxvW). The reason for real time is that this is what people expect, and that processing such simple code on the backend will become expensive over time, especially when it can be done in the browser. Good work though! You're on a good tract.
I think he was trolling. -40 is a pretty well known number that is the same.
Well, I don't say "performance". I say "fast." Fast for PHP developers. I think there is a nuanced difference. 
Follow this link: http://firstwebsite.comyr.com/index.php?Tf=John%20Snow&amp;Tc=
imho yaml is easier to read and write, making it faster for the developer. That's the whole point of using it...
I strongly disagree. Not seeing a lot of difference between: database: driver: pgsql host: localhost name: awesomedb user: awesomesauce password: mustangSally And: return [ 'database' =&gt; [ 'driver' =&gt; 'pgsql', 'host' =&gt; 'localhost', 'name' =&gt; 'awesomedb', 'user' =&gt; 'awesomesauce', 'password' =&gt; 'mustangSally' ] ]; Except that the first will shit bricks if you get the spaces wrong, which IMHO is worse.
Just an example: you can't use `MyClass::class` in YAML. `MyClass::class` is faster to write thank to autocompletion and the IDE, and it's also a big plus when refactoring.
Well the 4 first paragraphs talk about loading a file on each request. I may be misinterpreting that though.
I keep reading arguments like "PHP repeatedly launches and dies so x is a bad idea because of performance". It's interesting to note that is a non issue in languages like ruby since you can use a ruby web server, and it doesn't _have_ to be an issue with PHP if projects like [react/http](https://github.com/reactphp/http) take off.
Yeah, maybe it needs work. The first paragraph is about "what is configuration file" Clearly transpiling to PHP solves "perfomance" but the difference between Apache loading it's text configuration and a PHP app loading a text configuration is that, in the first, performance of booting up is not a factor where as in PHP it is. Which is supposed to flow into why PHP Developers use PHP in the first place. To be "fast." EDIT: Changed blog text a bit to try to say this.
Haahaha
yes it's not much of a difference for a very simplistic example... and when using the new array notation, which should be widely available since lower versions are not supported anymore, but let's not kid ourselves.
as said, a good IDE has autocompletion and refactoring for yaml files.
"Server CPU limit reached" Looks like we broke it.
Hey. Do you have a comment on why there's an index.php in the /pub **and** the root folder? The installation documents don't even talk about pointing the webserver to the pub folder (which is how it should be). Why?
Yea, I agree that writing it as an ajax call would be good for learning. Just if you're going to use javascript anyway, might as well just calculate it all client side.
What font is that on the button?
Most likely because you'll need to escape the `$` so it doesn't try to use the PHP variable $x. echo exec ("x=4; echo \$x") 
That turned out to be it. I also ended up using the system command. Thanks!
TIL I would be great at programming _and_ politics.
Do take a look at heroku :)
They just use SASS/prepos and do it the old fashioned way. Which is what I usually do, except on days I feel lazy as hell. 
Oh, sweet. So potentially you could just include the production CSS file in your project =D But then you have to just assume that everything is... yeah, on second though, I don't really know your situation so it's dumb of me to speculate. There's so much to a CSS framework these days... hard to separate the core functionality (grid/container/typography) from the chrome (carousels, buttons, accordions, etc). I feel like I'm rambling now. Carry on :D 
Yeah, that's cool too. Native PHP configuration by any means.
Thanks for the suggestions, I'm reviewing them now.
While that's true, I don't think it's a big deal in all honesty. I've been using Laravel for quite a while now, building all kinds of apps of varying degrees of complexity, and I can say with some confidence that using relation calls is a super quick way to make a mess of your app and make it almost impossible to maintain and change. I love active record, but letting relations leak all over the place is a line I've learned not to cross. As such, I vastly prefer explicit methods that do in fact return models and collections for relations, and any relation-based queries are either 100% encapsulated within the model, or at most, a repository. And even then, I try to figure out why I need to do relation chaining in the first place - it most often points to an inappropriate relational data structure that doesn't adequately reflect the needs of my problem domain. I consider this: $article-&gt;getCountry(); // always returns a model To be so very much better than this: $article-&gt;country; // returns a model $article-&gt;country()-&gt;...... // relation chain of doom scattered somewhere else. So what if I want to do something like this to filter articles by a country code? $articles = Article::whereHas('country', function($q) use ($countryCode) { $q-&gt;where('code', $countryCode); }); I can't do that without the relation. But that's ok, because I can still do this: $countryID = Country::where('code', $countryCode)-&gt;id; $articles = Article::whereHas('user', function($q) use ($countryID) { $q-&gt;where('country_id', $countryID); }); Or, I can better understand how my relations should exist, and modify the data structure accordingly so I can just do this: $articles = Article::whereHas('user', function($q) use ($countryCode) { $q-&gt;where('country_code', $countryCode); }); Or I can add a country_id relation directly on the articles table if I find that being able to filter articles by country is a key part of my problem domain. The data is still normalized - the fact that both users and articles have relations to the same country is wholly irrelevant, but I've improved my relational structure, simplified my code, and more than likely improved query performance.
Obviously. It's more of a learning experiment.
Cool!
Yeah sorry I spend to much time speaking with the the dutch and that. They use 3 grades; junior, medior, and senior. Middle developer basically means just a developer but is stated as a lot of people will just place developer without their junior tag.
Disagree. Who gives a fuck about constraints when you are trying to have fun? Why are you writing tests unless it is actually saving you time? Just pop off a bunch of mostly working code for the mvp ie go build shit! 
Is Bootstrap too mainstream for your hipster developers? :-p Seriously, though, why do they hate it? Not enough flexibility? 
It looks absolutely amazing for a first web-app, well done!
Not a bad idea though. Seems like it would make a good next step after a calculator/converter.
They have 2 reasons, too inflexible for most of their needs, but more importantly because it is used as a crutch by people who cannot develop and they hate getting that kind of code handed too them. I mean they aren't against proper developers using it, but they do just take a general dislike to it for that. Like us and our general disregard for 'Wordpress' developers. (Not that you don't get real ones - you obviously do and they can be great, just so many self titled ones are...less than stellar.)
Well I did made some things with CSS before but thank you :)
This sounds a lot like my current job...every single day. The biggest difference between the hackathon experience and our day to day work, is that at least there are some form of specifications and requirements at a hackathon. At work, we rarely get anything other than a general direction, then after we build something, the feedback comes in letting us know it wasn't what they were looking for and to try again. Rinse and repeat as necessary
Nice idea, country me in, my github Login is Korri !
YAML has no predefined semantics that link what you type in there to your codebase. You can develop a plugin for a *specific* YAML schema in a *specific* framework, but that then gets quite involved. A bigger question mark is the need to write lots of configuration. The only things that really need to be in a configuration file are really the things that change between deployments. A debug flag, a couple of DB connections, few API secret keys, few ports about this or that daemon, what else is there? Why should we involve a parser and a specialized plugin IDE to pass a few scalars to PHP?
&gt; When YAML/XML/INI files get favoured for configuration data, it's because of fictional configuration tools. There aren't any. Parallels with REST APIs are amusing.
I haven't seen an IDE that will autocomplete YAML keys (XML might help here), PHP class names or constants. The only exception is with the Symfony plugin but it works only with Symfony config. If we could avoid having to write a plugin per framework and library that would be great.
He is only using a font package from a Bootstrap-centric CDN. Everything else looks hand styled.
I find it odd that it returns results with decimals but won't accept one to convert. 
But Users class extends Table class which hidden from user too. I think it's clear and separates logic about DB operations and filter options into different places. UPD: Ahh, you talk about just this example? It's an example, don't take it too hard.
Ah - now i see where you are going with that `new Query()` - in my opinion that is not very clear at the very first sight ... therefore not a good solution. I do not think that your API should really separate db/non db methods at all. In general I do not care what lies behind my Model =&gt; I just want a general and nice way of accessing it without too many hassle - and even without really knowing what is used in the background So maybe do not use the viewpoint from the database but the model instead, e.g. you want: to create a model via User::create() ==&gt; and the class decides itself what happens than! Keep your API as clean as possible.
Yeah, yeah, btw that advice "Keep your API as clean as possible" sounds familar for me, because I told the same about five years ago to a newbie that came to the forum I did talk on. But thanks for opinion.
http://www.vezbadiv.comxa.com/index.php?Tf=%3Cimg%20src=http://i.imgur.com/iWKad22.jpg%3E
It offers my own view on how DB library should look and work. Also, intuitive way for writing queries and other stuff.
Thanks. If I stick with .htaccess, then turning on logging and dealing with the log file is the only way to determine if rules are being used?
You bastard :D
We used bolt recently to make a site for a client. It was super awesome to work with. Everything is built with modern principles. Nearly anything you want to do can be done via the various organized config files. Edit: this article inspired me to finish and publish [my blog post about the project](https://designspike.com/blog/implementing-a-fully-featured-website-and-cms-with-bolt/)
I don't understand why your Users entity would have a method to search for users.
"It sounds like you want to know which rules are used..." Yes. I want to know if specific rules are being used - and how often.
"Practical PHP Test" outside of education is the complete opposite of "practical". If you want to gauge how well potential candidates know PHP, then it's on you to know how to ask the right questions and conduct a proper interview. All this proves is how little you value your candidates' time.
I can understand Bootstrap hate. It's pretty rigid and can be a pain to make some things work correctly. If you know what you're doing on the frontend it's really not that much harder to just do the responsive stuff yourself, and you won't be fighting the bootstrap framework to do things it wasn't designed to. That and it adds a ton of extra HTML markup which can be annoying in its own right.
Yea I was wondering that myself too. It's good for learning, but this can all be done client side and is arguably the better solution.
You are on the right path, I have couple of specific feedback points that will save you a ton of trouble down the road: - Make Users non-static, so you can configure it through its constructor and pass connection, schema, tables to use etc. A static class is not configurable. $users-&gt;select((new Query())...); - Decouple Users from the user entity. Users the DB layer for users, and User the entity class. In time you will need many ways of creating, saving and loading a user, and not all of them are from the DB. Say memcached, Redis, etc. You don't fall into the trap of piling all this in the DB layer and ending up with a God object ORM like many ORMs on the market.
Sounds like a classic [SRP](https://en.wikipedia.org/wiki/Single_responsibility_principle) violation. The entity itself shouldn't know about how it's being stored, no less how to query storage for other instances.
You can capture a lot more in a mapper than you can in a direct query. The very basic cases will always look similar, except in your case you didn't even bother to bind the params, which means you can't customize them at runtime, while OP's API is ready for this by default. What about that hardcoded table name too? You never had tables change names in the middle of a project before, or table names between modules collide and you need to resolve this in config? Tables should be either injected, or abstracted away. OP abstracts it away. But we also have type mapping, data mapping, expression abstractions, join abstractions and so on. Lots of interesting things you can put in a mapper, instead of writing them over and over and over and over again as strings. I agree with you about I one thing - I'm sick and tired of people that fear SQL and try to wrap it in leaky abstractions that cause more trouble than they save. But OPs API seems close to SQL and a mapper is not necessarily about avoiding SQL, but rather about encapsulating it for proper reuse, and mapping the relational data to the domain and back.
I usually roll my own using bootstrap. One time I bought a bootstrap admin theme, but I ended up changing it alot and also I did not like how they implemented the js. If a theme exactly matches your needs it should be Ok to buy one.
That looks nicely done, and for $18 it's not much of an investment.
I hear ya. I've tried a few, and for the moment I'm sticking with AdminDesigns. Those 24 bucks have saved me lots of front-end pain. http://themeforest.net/item/admindesigns-bootstrap-admin-template-framework/9903221
Wow, I really like this one. Thanks!
I was reading comments from this person's version on another site and it seems he's done updating this theme. Just a heads up.
I roll my own with a front end framework like bootstrap, foundation, skeleton, etc. also check [AdminLTE](https://almsaeedstudio.com/), it's an open source admin dashboard &amp; control panel theme for bootstrap 3
Not bad for lightweight use. I can think of a couple of non-profits this would be used for. Thanks for the suggestion
My design skills suck. If I used the box feature in photoshop it would end up being a circle it's so bad, so I just buy the themes from Themeforest and implement them. Doing it myself would be terrible and hiring someone would be expensive for something very few people would see/care about and thus be better spent elsewhere.
&gt; it's already feeling outdated compared to what I'm seeing out there now. Such as?
Great post (y)
https://github.com/rdash/rdash-angular simple and non bloated build my working demo , replace angular with jquery :D, using silex and several package at the backend here http://silexstarter.xsanisty.com/admin (admin@admin.com|password)
Someone is already messing with your sample site (since you gave out that password). You should change it :)
indeed, the search functionality should be within the repository or service layer. Putting it inside domain model is clearly violating SRP, as domain models should only contain business logic, not data access/persistence logic. 
http://blog.codinghorror.com/the-php-singularity/ This article was very good to read about why PHP stays relevant despite all the criticism. Just like the author pointed out: if you want to write a script/software that runs on almost every server with zero friction or configuration hassels, PHP is damn near your only option. 
We bought SmartAdmin at work and it worked out really well for us. Loads of elements, plugins and components. Based on Bootstrap and looks pretty decent. Got it for a few client sites and they all seem happy with it. Definitely worth paying for it over the cost of having to design and develop something custom
No one noticed that, great job.There shouldn't be an option to convert below -273.15 °C and -459.67 °F.
Those all appear to be front end talks. Could you point to any specific ones that talk about the backend? Caching is quite hard with my particular app since it's a user-heavy dynamic app but I am working on that too.
The problem with that is that .htaccess is too complicated to begin with - part of what I'm trying to resolve. We've got 15 years of some my changes and many other people's changes, for marketing campaigns that no one remembers, and for 2 different revisions of the core software (VBulletin and Joomla). I'm better off just getting out the machete and hacking pieces off, and see if anyone complains.
So I decided to take your advice and `get-in` is really nice. Looking for some feedback though: https://packagist.org/packages/g4mr/configs
I made my own for the first time around and it was a lot of work! At least for me because well I will do front end work I don't particularly enjoy it especially when this was at a time when there were so many GS libraries flying around. So I've decided that purchasing admin panels is way more cost effective in terms of time and resources. There are quite a few market places out there that have admin panels so if you're like me and don't particularly enjoy front end I definitely recommend you shop around and buy.
My opinion may be worth the weight of a feather, since my design skills are dull. But, seems that recent bootstrap admin panel designs are a little tighter. For example, the side menu has no gap with the main content. It's also usually some form of slider. The side menu in my example is more of a floating element than it is a slider. Things look to be flatter in the newer panels as well. I think it's this flatter look that seems more modern to my untrained eyes. 
That's how I was feeling. And the replies to this post seem to validate that. 
I might get this as my new "quick go to" theme 
I do this for CMS work. It's allowed me to offer non admin services. So far, I've know used WordPress, as it's the one I'm most familiar with rolling out and explaining. But I'll be taking a look at craft cms as well. Thank you. 
I using sonata admin panel. Very easy to create new views and forms. http://demo.sonata-project.org/
No, not right now. That's a good idea though! I'll work on getting one up!
The one you linked in your content is pretty inferior compared to AdminLTE ...
You can insert based on expressions and sub-selects. You can argue only that a common case of insert can be wrapped, and I can argue the same for the rest.
In your first step you should always have a demo... no one will install your CMS without seeing something which sounds interesting... I built 3 CMS over the last 2-3 years, and they all sucked... What's to say yours is interesting?
It sounds like it would be easier to experiment and document personally, but if you feel like it works for you...
Why not just... $data = new \stdClass; $data-&gt;foo = 'foo'; $data-&gt;bar = 'bar'; Anyway, some time ago I thinked about how to make this stdClass objects immutable. Something like Object.freeze in JS and here anonymous classes can be useful. 
I already downloaded the LTE version and will begin tweaking it for a current pro bono project for a non profit. SmartAdmin looks to be a little more detailed, by looks alone. But you're right, if I were to use LTE and not like it, I'd rethink my stance :)
&gt; This is typically the kind of thing people jump on immediately after they learn what SQL is and how to use it. man, I know PHP and code in PHP for 6-7 years already and created a lot of projects that used DB, you're hurting me by making those conclusions.
Batshit crazy. That's how we did things back in the old days with IIS and ASP and you didn't want to purchase the URL Rewriter module for IIS. You will regret this.
Ah gotcha. 
It takes guts to post one's work as Open Source. I really recommend you to check out http://www.phptherightway.com though.
Besides the exception throwing I don't see why there's a `__get` and `__set` here. The magic methods `__get` and `__set` do not get called if there's an accessible member. In your case the properties are retrieved without the `__get` method and they are stored without the `__set`method. The only difference without the magic methods is that bad properties return null, and when set it triggers an notice error (see https://3v4l.org/HDOGr). If it is just the exceptions you care about, this works just as well: https://3v4l.org/F8UfQ Personally I'd still prefer a class with some public properties instead of this even if the class is only used once. 
Thanks, anything specific?
I'm familiar with CodeIgniter, but not enough to pick it up right now and build something with it. Outside of not using mysqli::prepared, what would you point out to be something else that makes it a badly designed product? Thanks for your comment, it helps a lot.
Haha cheers. In the context of the rest of the project, I shouldn't have been surprised. They've got all the goods: structural view code being echoed out (constructed with tables and inline styles, no less!), database queries inside potentially endless loops, a root password that contains the string "123".... the list goes on. It's a real shit-show. Cheers, for the confirmation, looks like that's something else on the list to sort out. =/
There is a huge difference between one of the mainstream ORMs, and the simple abstraction of a command or query. Check my name. Your opinion is conflating too many unrelated things together under the moniker ORM and I think this is why you can't see why people find such abstractions useful. I've been using an internal relational mapper for SQL databases for years now, and I've not had a single issue with it, and I'm really deep into SQL and how it's implemented, I'm not running away from it, so case in point, it's possible to do it right, and what OP is doing is a relative good example of a basic DAL, save for the flaws I pointed out in another comment here. By the way... the remarks I that I'm replacing "stable SQL" with "unstable PHP"... Please don't make me question your intellectual honesty. If you feel there are concrete issues with the approach, discuss that, don't tell people people should use more raw SQL because PHP is "unstable"...
Fuck SmartAdmin!!! Such a waste of money. We bought this at work too back when it was with Wrap Bootstrap, then it migrated to BootstrapHunter and we weren't allowed to migrate the license. I really hate using this "mashup" theme thing. It has a lot of jQuery plugins that are out of date. There were LESS/Sass compilation issues. It doesn't support IE8 and it's ugly as fuck. Our main admin platform is built on SmartAdmin and we hate it. We nicknamed it StupidAdmin. I FUCKING hate this theme. The documentation sucks. It looks like it includes DataTables. Doesn't work out the box. You have to configure it. I don't mind, I prefer that. But my boss expected the tables to just WORK and they wouldn't. 
Please don't buy it. Read my comment above. It's ugly too. 
Does anyone know of a good resource for documenting my routes, ala phpdoc? I'm using Slim to create a JSON api. End result I'd like to have a list of my end points, documented variables from the routes, and acceptable _GET/_POST parameters as well.
Wouldn't a struct basically be a value object with no method or constructor?
This will actually raise an error if you try to get at a nonexistent property. StdClass will just create it on the fly. 
You should strive to follow the SOLID principles in your general framework design as well as the generally accepted best practices for development. Starting the best practices angle there are a few things: - Why are you not managing your third party dependencies with composer? - You should take advantage that most popular packages are following [PSR4](http://www.php-fig.org/psr/psr-4/) and take advantage of that for Autoload - Following that, why are you not following PSR4? - There is also a standard for logging, which this class does not follow: https://github.com/helllomatt/Theamus/blob/master/system/log.class.php - Just for the sake of not having to maintain so much yourself, why a custom db class when Doctrine DBAL is available? Or an HTTP library when Guzzle is in the wild? Or a logging utility when Monolog is available? Your goal is to make a CMS not a framework so use these popular libraries to develop your actual product (making something yourself is not useless, but you need to take a good hard look at what you're trying to accomplish and not miss the forest for the trees) SOLID stuff: - Why does [Theamus](https://github.com/helllomatt/Theamus/blob/master/system/Theamus.php) do so much? If it's meant as an application bootstrap it really only need to get the compiled configuration, your DI container, call your router, and call it a day. - Passing around the Theamus object like I've mentioned before is bad, it's a god object by design and every class you pass it to will hide it's dependencies by pulling them from it. 
[Well...](http://i.imgur.com/rSA0L8h.gifv)
&gt; I'd never seen that before and can't decide if it's batshit crazy or genius. Could be either - if applied as a [Front Controller](http://www.onlamp.com/pub/a/php/2004/07/08/front_controller.html) with a well-organized MVC or HMVC implementation, this is a [DRY](https://en.wikipedia.org/wiki/Don't_repeat_yourself) approach that's vastly superior than creating a separate PHP script chock-full of `require()`'s or (shudder) `include()`'s. ... but you're dealing with a one-pager so it's a batshit crazy implementation. &gt; Are there any SEO implications to doing something like this? So long as the implementation returns the proper HTTP response codes for different cases (**somewhere** there'd better be a 404 response for URI's which don't map into application functionality) it's not a problem for modern search engines. (e.g. MediaWiki / Wikipedia passes everything through a front controller)
I played around with it on a side project and didn't experience any of these issues. DataTables worked out of the box. With these themes you know you are going to gut 90% of its plugins and just use it as a bootstrap theme. No issue with out of date versions. It'd be nice if they used bower but you get what you pay for. No need for documentation either. Its pretty straightforward that its a mash up of css and html to get you moving fast and wiring up stuff. That said - It's pretty ugly compared to other themes
Interesting fact. I wonder then, how does ~~cool kids~~ next generation building static websites with PHP today? :)
I've added blog sample to the repository
Thanks for the suggestions. I'm using ubuntu for everything now. So you're not using homebrew on a VM, but you use it for Databases? I need to look into homebrew - I have no idea how it works.