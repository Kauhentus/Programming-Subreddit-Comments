Yes and as of PHP 7.1, private constant is allowed too. http://php.net/manual/en/language.oop5.constants.php
it break only if you put // inside a value. if you put /* */ inside a value, it just remove it but still decode properly. otherwise // and /* */ outside values work correctly doesn't break the json
In increasing order or lightness: prestashop, oscommerce, woocommerce
I didn't know you could use `const` in an interface. Never tried.
How writing a frameworkless possible code make it more easier to upgrade? 
Yes but if it is not a command line interface you are going to have a rough time. 
Okay.. 
There aren't more parameters. You aren't paying attention. 
Also, ctrl + c five times 
Yes. You can run PHP as shell scripts / commandline commands. There are extensions for user interfaces. I often use it in place of bash scripts - particularly if I want to do things like interact with a database. Many of the projects I work on use long running background processes to process queues. These basically run from the commandline (you can use something like supervisord to manage them, but I have my own process manager that has some additional features such as auto-scaling pools and "crash detection") and have full handling for signals (graceful exit on system shutdown / kill / ctrl+c) While it can be used for graphical applications, it's generally not due to a number of factors including performance (pre-PHP 7 performance in general, and the complexity of threading / forking). There has been a recent "revival" of people looking at this - see the [php-ui project](https://github.com/krakjoe/ui) for example. Related: * https://github.com/krakjoe/ui * https://reactphp.org/ * https://github.com/amphp * https://www.swoole.co.uk/ If you elaborate further on what you want to do, you'll likely get more specific answers.
So is OpenStreetMaps completely free to use? And does it support waypoints? I'm looking for something like this for a low usage personal project, and was initially looking at Google Maps API. Would OSM be a better option?
I want a in-built PHP function that can help to make it very easy with cURL with less amount of code. 
Well http://gtk.php.ne
Thank you so much. It was a great help 
Thank you
well written answer 
Of course you can use [native sql](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/native-sql.html) in Doctrine. Kind of misses the point though. One of the major rationals for using an ORM is that it provides a degree of isolation between your app and the database. Dropping down to sql pretty much makes that go away. And then once the query is executed you typically still want to map it back to objects. Doctrine provides a ResultSetMapper but it is not pretty. Might be just me but I generally found it easier to just write the mapping code directly. 
It's a helper function from Laravel: https://laravel.com/docs/5.6/events#dispatching-events
I never said frameworkless - I use frameworks, I just keep them very far away from my core logic :-)
&gt; CORS I mean any public application that JS can hit has that wildcard CORS enabled right? Otherwise, like the most recent APIs I had to work with built with rails on heroku, I had to use PHP-CURL to make my GET/PUT/POST requests. If it was not for Stack Overflow haha...
You're right, I'm not, I'm just being a """Redditor""".
But you can scape forward slashes in a JSON document
Serious question; Why a builtin (which will mean waiting till 2020, not being PHP 7- compatible, and probably not quite getting what you want) rather than a composer installable PHP library (like guzzle or similar) which will mean being able to use it now, run on any version of PHP since like... 4.1, and being able to trivially extend and enhance to suit your needs?
Sorry, I didn't understand your question. 
Laravel is rather complex but one understand it. It's easier to implement most thing myself and it's so easy to implement SOLID in laravel because it already has MVC taken care of and a lot of package that's already there like Laravel Collection. It's so easier to get everything running and start focus on complex business logic. People here who said they like to start everything from zero are probably have more freedom &amp; time to write everything from 0. The ideas is cool and I love to write everything from scratch also but it's not wise to take business project as hobby, right? I'm talking about other people here not you.
Monitor the memory usage of the host. Maybe your script gets killed from the host system because no more memory is available.
Why do you need it built-in when you can easily use a 3rd party pure-PHP project that does the same? Why wait years for something available today? Need for speed certainly isn't an issue in this context.
Standardise the function naming and parameter ordering. It seems like `snake_case` and `$needle, $haystack` are the best option.
Okay I understand. Well PHP did it many time in past. I already seen that PHP implemented many new in-built fiunctions to minimize our code. So I think it is possible also in the future. As PHP did it previously, so I also expect in future version of PHP.
Here's a handy trick for debugging when you can't reduce your problem to a reproducible case: Use GDB. PHP provides a handy GDB script for inspecting a live process or core dump, [available in their git repo](https://github.com/php/php-src/blob/master/.gdbinit). So long as you have the correct version of that script and have your debugging symbols installed, it can be as simple as: gdb -p `pidof php` (gdb) source /path/to/php57.gdbinit (gdb) zbacktrace For more details, see [this article](https://derickrethans.nl/what-is-php-doing.html) or [this StackOverflow answer](https://stackoverflow.com/questions/14261821/get-a-stack-trace-of-a-hung-php-script)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php/php-src/.../**.gdbinit** (master → 29f942b)](https://github.com/php/php-src/blob/29f942b3d03e9b7ef4cc06e05928012a092ffdb7/.gdbinit) ---- 
When you hit ctrl+c it only gets 20% of the thing you are copying so you need to hit it five times.
There is a [php-gtk](http://gtk.php.net/) as well as a [php extension that wraps libui](http://php.net/manual/en/refs.ui.php). I've played around with php-gtk a bit, but not to much.
Exactly.
did you visit this link yourself, by chance?
Also these things are so like 10 years ago. And did they even make any make any money back then?
the question is addressed for people who work at companies who main product is a web app. I know PHP can do more than that. But I'm interesed on opinions about webapps. 
I don't know why there's so much venom in your tone, but I tend to agree that his approach would be more pragmatic as it requires less functions to achieve more. Also I like the idea of introducing more PHP programmers to tuples.
I am very confident about my ctrl+c skills, I always only press it once. I think it saves me at least one hour of pressing ctrl+c a day, given the number of times the damn keys need to be pressed daily
It's worth mentioning that case-insensitive constants will be deprecated in PHP 7.3 and removed in PHP 8. So, that removes one of the "benefits" of using define().
 &gt; The ideas is cool and I love to write everything from scratch Writing things from scratch should be avoided. What do you want to do on a hobby project in 4 years? Rewrite it because the framework you use requires major upgrades that no longer apply? Shut it down due to major security issues that can turn a hobby project into a legal nightmare? Keep your code decoupled from the framework to make things easier. Laravel generally makes the decoupling process (if you follow idiomatic Laravel from the official documentation) quite hard. &gt; it's so easy to implement SOLID in laravel SOLID has nothing to do with the framework you use.
When time is not a constraint (no due date -&gt; nothing to release) I personally prefer playing video game than doing architecture related stuffs.
Good try. +2 for simplicity. -1 for magic. Some thoughts: Collections from Laravel/Knapsack already cover all the needs for a fluent interface for arrays. Having to call -&gt;array\_map\_($x) only solves part of the problem, the call still has "array" in it and the order of arguments is still fucked up. I don't see a use for $this-&gt;stack(), it will probably only eat your memory up.
I suppose the waypoints coverage depends on the area and the user's good will so your mileage may vary and I can't tell if it'll be better or worse. However, if you have enough bandwidth, it's worth modularizing your app so you can choose what maps service it'll use, and compare by yourself. 
Yes, and it also depends on your definition of "web development". Not saying that PHP is the optimal selection for everything but : You can run PHP as linux daemons to schedule tasks, handle work queues etc. You can use PHP to write apache filters You can serve APIs of all sorts (and also websockets) The sky is the limit really.
[This project](https://github.com/nikic/scalar_objects). I really like the idea of being able to objectify scalars.
Who, it sounds good...
stack could be gone or turned explicitly if only required. regarding having to write `array_` and so on yes that is by design. the lib doesn't wrap or alias any functionality specifically. it looks like you could not grasp the dead simple philosophy of `with` - usual native method calls but fluently and sequentially and that's it. for something like `map()` (instead of array_map) there's https://github.com/adhocore/underscore :)
Working here (as of now)
Check out GrumPHP. I won’t start a project without it.
There are some features from python I like: * with-statement and context managers * annotations * metaclasses
What is the target audience and is there some level of SLA available?
Some ideas : 1 Event loop (JS like) 2 Promises &amp;&amp; Async await (JS like ) 3. Way to run instruction/command in a different thread (GOLANG like) 4. Generics (Java like) 5. Way to Defer commands (GOLANG like) 6. Make Exception class abstract
Much of the legacy in PHP comes from a time before composer and packagist (before PEAR, even). However, doing these things in libraries is now and has always been superior to writing them in PHP's internals in EVERY POSSIBLE WAY apart from performance and that distinction is usually difficult to measure and wholly irrelevant in real world applications. These days, even the convenience argument is indefensible since library management is extremely mature and production ready. Will PHP occasionally add a utility function to internals which could be done in userspace? Yes, but you should absolutely expect the frequency with which that happens to continue to decrease. For example, of the four utility functions presented for vote in the past month, only one passed and even then only barely. I'd have to check the botes, but I doubt that more than five functions were added to 7.3 in total. At least one of which had to be a builtin (accesses posix and win32 apis). By the way, that one that narrowly passed recently did so largely on the basis that it does have a theoretical performance consideration (C can do it in O(1), PHP must choose between O(n) or O(1) with side-effects). What I hear you say in your response is that you want a kitchen sink of utility functions as a matter of convenience. I argue that this reasoning is short-sighted at best and bad for the language.
Generics
Depends entirely on the requirements: there is no one architecture to rule them all; it’sall just trade-offs ¯\_(ツ)_/¯ 
You dropped this \ *** ^^&amp;#32;To&amp;#32;prevent&amp;#32;anymore&amp;#32;lost&amp;#32;limbs&amp;#32;throughout&amp;#32;Reddit,&amp;#32;correctly&amp;#32;escape&amp;#32;the&amp;#32;arms&amp;#32;and&amp;#32;shoulders&amp;#32;by&amp;#32;typing&amp;#32;the&amp;#32;shrug&amp;#32;as&amp;#32;`¯\\\_(ツ)_/¯`&amp;#32;or&amp;#32;`¯\\\_(ツ)\_/¯` [^^Click&amp;#32;here&amp;#32;to&amp;#32;see&amp;#32;why&amp;#32;this&amp;#32;is&amp;#32;necessary](https://np.reddit.com/r/OutOfTheLoop/comments/3fbrg3/is_there_a_reason_why_the_arm_is_always_missing/ctn5gbf/)
As the question says, take take you company requirements.
What does that mean? The tech/architecture is a means to an end.
Short closure syntax and generics.
I would put it on some type of Linux server. Maybe internet access too.
Wow. Thank you for this information 
Yes you can escape them, so it won't break the json
I grasped the dead simple philosophy. It is as simple as possible. It doesn't solve much unfortunately exactly because of that. You get global function calls in the desired order sacrificing speed and memory substantially, you'll have a hard time convincing others to use the library this way if not for fun. Good job anyway.
I tend to occasionally do a CodeSniffer fix of the whole project and push it in a single commit.
I am a WordPress developer and I can say that WordPress is far better than most of the other CMS. WordPress is lite weight than most of the other CMS.
Lol. Just use [glob()](http://php.net/manual/en/function.glob.php)
That's great. 
The ability to define a type on the same line as the variable. private Foo $foo;
1. Generics. My god, the amount of code cleanup I could do with generics. I'd be able to delete hundreds of files. 2. Function overloading. I want PHP to be able to know if I pass an integer as a mixed default parameter, that the return type is an integer. 3. Native between-request in-memory object store without the need for extensions. There's no reliable in-memory store that works out-the-box across all platforms in the same way that opcache does. This would almost immediately find its way into the core of composer etc as a replacement for the buggy APCu. 4. Method calls on scalar objects e.g. "hello world"-&gt;toUpperCase()-&gt;split(' ');
Not to go on too much of a tangent, but as Composer is pretty much the defacto standard now, is there an option for PHP playing-nice with it? It's such an important part of the ecosystem if I were involved in the core, I'd probably seek to add something like spl_autoload_array, just pass it the entire map of classname =&gt; path and let PHP deal with it without needing the costly callback. Combine it with a bit of smart processing at the opcache level (X requires Y requires Z) and it would be a tidy performance boost.
I would love to be able to use constants in a HEREDOC string. ```php $sql = &lt;&lt;&lt;SQL SELECT * FROM "Table" WHERE "status" IN ({MyClass::ACTIVE}, {MyClass::INWORK}); &gt;&gt;&gt; ``` I run into a lot of these situations where I would like to put class constant values directly into SQL instead of having to assign the constants to a regular scalar, then pass that into the string. These are situations that binding the values into a prepare don't really make sense. Well, at least to me anyway.
GTK is dead for years, afaik.
I agree that we should take measures to be more composer-friendly, or even just more autoload friendly without worrying about composer specifics (thus maintaining impartiality). In particular, it frustrated me to no end that function autoloading can't get off the ground. Or constant autoloading for that matter. The small perf hit that supporting these would bring would be irrelevant to apps not using it because the autoload happens entirely on the miss path. As to persistent loading a mapping, that's more complicated when you live in a world as flexible as PHP's runtime is. Not impossible, but complicated.
IIRC the composer ClassLoader already automatically makes use of apcu for persistence if it's available... it's just not always available (or stable across all platforms). I'm currently stuck working on a project which requires constant polling of a web server, sometimes for thousands of requests per second (socket.io is on the todo for next year) so I've spent a lot of time optimising our bootstrap. One of the things I do is use my own autoloader, which I pass a copy of Composer's classmap array, and once every 5 seconds when running on production I profile the includes, adding each item to the array only after it's been included, in case the file in question itself has to autoload another class. End result is that if I'm doing 500 req/sec it uses the full autoload once, and then for the other 2,499 requests as soon as the autoloader is registered, it require(..)'s everything it saw during its profiling, in order, and thus doesn't need to touch the autoloader callback for any of the classes which are used on every request. I would suspect that having PHP itself handle an internal list of file names would eliminate the need for such optimisations. 
Vscode has auto save
I remember with java you could have multiple constructors in the class, I wouldn't mind seeing that, sometimes you want to instantiate with arguments and sometimes you don't.
Thats the opposite of "great". [http://php.net/manual/en/function.glob.php](http://php.net/manual/en/function.glob.php)
This will never happen. Well at least the function part. It would break SOOOOOOOOOOOOOOOOOOOOOOOO (repeating for ever and ever till the end of time and even beyond) much code.
No idea what is going on in that company. For me it pretty much looks like your friend just questioned everything. Built an green field project with all the bells and whistles to impress and is now disappointed that it wasn't instantly celebrated. I can have that every day on medium. Your friend is probably smart, but generally I see the fault on his side. Flooding peers with buttloads of new fancy things will unlikely yield acceptance. Plus it solves nothing. It is also very naive to just throw an modern isolated project into the room and expect that everone adapts to it over night or even that the existing system can adapt to it. Also there may be no hard problems in the current system or they lack awareness how annoying some things are. Valuable modernization may be neglected due to ignorance/knowledge, but more likely because it takes a lot of work and willpower. I'd look around where actual problems or annoyances exist. Deployments are often a hotspot. They are not fully automated, incomplete, slow or constantly break. Maybe not even existing. If some points apply, think what would actually improve with a modernized solution. It must have an positive long term impact on peers and work quality. Present the advantages, try to get peers on board. Try to get time for the project, but make a real world solution. Not a demo, not an half-assed incomplete attempt. It can have initial hiccups or bugs, but it must solve the complete problem, a production ready deploy. If that doesn't earn he some beer after it has settled he is likely in the wrong place and he can move on. If he gets his beer he can start the next project, with a bit more interest and respect of his peers.
raise a hand if you haven't used anything global other than maybe helper function in years 
 * remove namespaces [1] * make `use` optional [2] * TCO [3] [1] Yes serious. idgaf. [2] Pulling in too much scope is not an issue anymore (imho) and you can prevent it if you `use`. [3] Not serious, just to look smart.
A magic method that is invoked when an object is used with comparison operator. Allowing the testing of data within an object to deem it true or false in conditional statements and template engines.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
If you whish for all that your number 0 wishes should be a non fire and forget runtime model plus a top notch gc.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; remove namespaces I like how Python does "namespaces" better. I believe this is basically the model JavaScript is using but I haven't kept up there (for which I am grateful). Files just define symbols, and when you "import" it the symbols are on the name of the thing you imported. Theoretical PHP example: &lt;?php import guzzlehttp; $client = new guzzlehttp\client(); ?&gt; If we autoload these "packages" instead of symbols then we also get constant and function autoloading as well. PHP :(
What we have in php is rather limited because type hints are just runtime checks. It is just dynamic typing with some "hints". A statically typed language could verify a whole program, but in php that is very unlikely to happen because of it's runtime model. 
Yeah, I'd like a module/package system more as well. I'd like to have top level code and functions/classes mixed and ways to make stuff public/private explicitly. I don't even use an IDE, but the one class &lt;-&gt; file doctrine is completely backwards, if not nonsense.
But there is no ohhhhhh
sacrificing memory and speed- may or may not be. your concern is stack? that can be removed or turned off by default. besides we are talking about microseconds lag of speed right? or is it way more?
production grade `php -S` if that is even possible or reasonable. or `swoole` already integrated. null coalesce improvement: so `$a[$b['..']]['..'] ?? '..';` is possible instead of `$a[$b['..'] ?? '..']['..'] ?? '..';` some psr interfaces (logger etc) already baked in while psr4 autoloading could be already supported?
Something that permanently breaks Wordpress. Thanks for any consideration.
actually there are RFCs to implement `compareTo` for exact similar usecase https://wiki.php.net/rfc/comparable https://wiki.php.net/rfc/object-comparison
Generics in particular and improvements to the type system in general. Eg, compound type hints: function foo (int|string $id) :void { /* ... */ } Also typed properties (if this doesn't make it into a 7.x version). I'd also be interested in a `__toEquals()` method (or equivalent) so objects can specify how they should be compared. Finally, I'd also be interested in seeing either a more "native" annotation support, or an acknowledgement that the current doctring approach is blessed and is just The Way PHP Does Annotations.
Wasn't there a proposal at one point to require all RFCs to get 2/3rds support to pass? I'm guessing that didn't get off the ground
just spit beer from nose laughing. Thanks! Kids these days. Sheesh!
That's very cool and would help me immensely. 
For the record I really hate - aka - still don't fully understand this implementation. Not sure if this is really the spot I'm about to bitch about, but it's a close neighbor. I was refactoring a project that used a lot of global multi-dims (and setting $_SESSION directly): `$player['weapons']['sword'] = 75;`. This was passed via a raw global `$session` and I wanted to intertecpt this without having to change every line. So I think, naively, I can just create my own `ArrayObject` and intercept the setting, getting and the declaration with my own implementation.. this got stupidily complex and impossible. Something about the the behavior of multi-dims.. I believe there was something in the PHP source that would prevent me from intercepting the creatation of the multi-dim. So - when creating a mutlidimensional array in PHP - PHP actually creates a new single dimensional array and this happens under the hood, so if you create your own `ArrayObject` implementation you will never be able to intercept this behavior because it just happens under the hood.
but they won't stop. once it was heard they would implement it in nodejs 
You essentially need to automate and also institute a cleanup process. The easiest way to do that is to delete everything and start over after every build, however that is also the slowest. A faster alternative would be to use git and composer to your advantage and revert your code back to a point that it is in "pristine" condition. When developing tests you should always be under the mindset of reverting any changes you make to the system to avoid disrupting other tests. Using this approach can introduce new problems such as left over artifacts. As the project progresses, you may want to start integrating other technologies such as terraform, packer, puppet/chef/ansible, etc. These will allow you spin up an environment very quickly from scratch, run your tests, and then tear back down. You would also be able to initiate environments per branch. With a cloud service such as DigitalOcean, AWS, Azure, etc; you can save money by only paying for the time you are testing.
It pains me so much that we're still using globally defined values for config files 😓 
Yes, and actually there was some discussion about it last week https://externals.io/message/102765
Fix the symtables. Or create "packages" which can be loaded. I think either of those are better solutions than re-creating autoloading for every type of symbol.
Would you prefer a global config file that is read from and stored in the scope of a specific namespace and class? 
Happy cakeday 
This is the Go approach, and to be honest, it's bloody annoying. The point of code standards is to enhance readability, and there are occasional places where readability is enhanced by breaking the standard (most common example: a string that's slightly too long for the line). It's better to leave a little flexibility in the system.
Will pay.
Just a few things without looking at that actual logic: 1. In the docblocks for methods (and their signatures), you can specify the variable types. This helps your IDE know what kinda data it's dealing with, and can also help you enforce data types passed to those methods. So like this: /** * @param integer $user_id */ public function setUserId(integer $user_id) { $this-&gt;user_id = $user_id; } In the above example, if you passed a null value to setUserId it would throw a fatal exception. 2. You can also enforce return values: /** * Checks if lock belongs to the given owner * @param $content_user_id * @return bool */ private function isOwnLock($content_user_id) : bool { if($content_user_id === $this-&gt;user_id) { return true; } else { return false; } } 3. Generally people don't use array() anymore, and use []. Like this: $criteria = [ 'content_id' =&gt; $this-&gt;content_id, 'content_type' =&gt; $this-&gt;content_type, 'user_id' =&gt; $this-&gt;user_id ]; 4. Was "date($this-&gt;user_id)" intentional here? $this-&gt;db -&gt;set('user_id', date($this-&gt;user_id)) -&gt;where($criteria) -&gt;update(self::CONTENT_LOCK_TABLE);
clearly done on purpose. but well tried.
I would say just denote your return types, IDEs will help if you do this. Also I like to use simple objects as return types instead of just array. Leaves too much guess work
\&gt; elegant test friendly code \&gt; oop pick one
parody of symfony/expression? 
Someone posted a simple userland workaround. Nice if already possible natively. https://www.reddit.com/r/PHP/comments/8zv064/with_provides_object_like_fluent_interface_for/
4. Simple userland workaround with https://github.com/adhocore/with eg: `with('hello world')-&gt;strtoupper()-&gt;explode_(' ')()` I do like like to see native support too :)
You are free to write an autoloader that loads up one file per namespace, as in the Python example. Nothing stopping you from doing that. You can make that Composer compatible by registering your autoloader using a file autoload directive in composer.json, if need be. There is no further technical boundary for supporting it.
Sorry for the late reply. I couldn't get into too much detail before, but now the company is going out of business and I already lost my job. So these contact forms weren't just sending emails, they were also passing form input (including a ton of hidden input fields) into a database for analytics and marketing purposes. Before me, any custom app development was handled by a bunch of foreign freelancers. We are talking 10 years worth of websites. Dozens. I couldn't trust any of them to be secure.
Your coding is fine per-se. What you could improve is the `isContentLocked()` method in particular. It does not follow the command-query separation principle (google it). It is a query of the objects / applications state (is the content locked or not? return me true or false on that) but has side effects (not even described in the comment) like releasing or applying a new lock to your data-structure. When I would work with your class I would only look at the public methods and maybe on their docblocks. I would never expect a call to `isContentLocked()` changing the state of the lock. I expect it to return true or false. May change the name to `applyLock()` or something like this which tells the developer that something is actually happening. Other smaller points: - parameter and return type hints (`private function isOwnLock($content_user_id)` -&gt; `private function isOwnLock(int $content_user_id) : bool`) - make your class final - more class constants for constant values like `$this-&gt;content_type = 'job';`. Where does job come from? Why is the time limit "-5 minutes" and why not "5" or "300"? Why is this not a parameter configurable in the constructor (maybe with default values?)? - describe your returned arrays. What is a content lock record? Why do i get the numbers of rows back?
A wish list of things I'd like to see, some more simpler than others. * Typed array hints, e.g. `int[] $intlist` and `int[][] $2dintlist` * Short closure syntax, e.g. `($n) =&gt; $n + 1`. * Generics, or at least way to type generators and iterables (maybe typed foreach, e.g. `foreach ($array as int $value)`?) * Fast built in function for detecting indexed arrays, e.g. `is_indexed_array($arr) === true`, when `array_keys($arr) === range(0, count($arr) - 1)` * Foreach for array keys, e.g. `foreach ($array askey $key)`.
I use docker-compose for my dev work and use the same setup on the build server. Look at laradock for docker-compose template.
Just for my information, what would need to happen before one could call it OCD? I mean I might indeed be slightly annoyed, but I might also feel a huge urge to correct every line of code that is not like what I think it is supposed to be like, and that the project as a whole is not "good" if there's sloppy things like this everywhere. Also, the people below saying they need to autoformat every file they save to PSR standards because else it doesn't feel right, would that qualify?
So you want to walk around with some poorly written code on your chest? 
I spy no indentation, unnecessary usage of double quotes, and unnecessary end-of-file "?&gt;"
No, I don't want it. 
&gt; and I know it's [CodeIgniter] limitting to good OOP programming You summed it up right here, unfortunately. There are a few problems with this class: #1. The object is invalid until you first call `setContentId`. If you call `isContentLocked()` before first calling `setContentId`, it blows up. This is the fundamental problem with getters and setters. Objects should be valid upon construction. Period. If they cannot do what they're supposed to do with the arguments they are instantiated with, then they are going to be confusing and hard to use, since you have to use them in a specific sequence. #2. The object is also invalid until you call `setUserId`. Similar to the above, if you call `clearContentLock` before `setUserId` AND `setContentId`, the request is invalid and a bug will occur. This is the problem with this kind of OO design: you are wholly dependent on *state*, and state will bite you in the ass, every fucking time. #3. `isContentLocked()` is named like it's a simple question, but it has numerous side effects. It's always a very, very bad idea for a method that is named like a enquiry to also do work that changes the state of your application or database. You should not be calling these methods in it: $this-&gt;addContentLock(); $this-&gt;updateLockTime(); $this-&gt;updateLockUser(); That method should do one and only one thing: return true or false if the content is locked. Period! Moreover, in terms of testability, this method is harder to test because there are a few logic branches you'd have to write setup for. #4. This class can decide what it wants to be I won't even get into the issue with this inheriting from a CodeIgniter model just to get access to database queries. That's one of the problems with CI when it comes to OO design. But beyond that, in general, this class design suffers from a common design flaw: it's trying to be both a general service class that can manage content locks for arbitrary users and contents, and also a single model that represents a single content lock for a single user. You should pick one or other. **General service class design:** $contentLockService = new ContentLock_Model($config); // where $config is things like content type and time limit. $contentLockService-&gt;isContentLocked($content_id, $user_id); $contentLockService-&gt;getContentLock($content_id, $user_id); $contentLockService-&gt;addContentLock($content_id, $user_id); $contentLockService-&gt;clearContentLock($content_id, $user_id); Remove these methods: setContentId(); // Delete setUserId(); // Delete Notice how there's no state here? The three public methods take their many query dependencies as arguments. **As an object: a instance representing a *single* content lock** $contentLock = new ContentLock_Model($config, $user_id, $content_id); $contentLock-&gt;lock(); $contentLock-&gt;unlock(); $contentLock-&gt;isLocked(); $contentLock-&gt;getData(); // probably don't really need this? Remove these methods: setContentId(); // Delete setUserId(); // Delete Notice how we still don't really have any statefulness? Yes, technically the object relies on internal state, but that state is *immutable*. You've given it what it needs in its constructor, and those two variable parameters (user_id and content_id) describe what this particular content lock model is. It *is* an instance of a lock model representing exactly the given combination of user_id and content_id. It cannot be changed, it cannot be used to set other locks. If you want to do that, you create a new instance of it. I hope I was able to make that distinction somewhat clear, because it's hugely important. Just do whatever you can to avoid dependence on statefulness. Calling method A should never be a prerequisite for calling method B. Either the object is constructed with what it needs when instantiated, or its methods get what they need as arguments when they are called. 
And it looks like they used a pair of curly quotes. It won't run with those thing lol.
&lt;?php if(empty($stomach)) echo "grumble grumble"; Should be one line imo.
How is OOP not test friendly ?
&gt;anyways This one word ruined it.
echo (empty($stomach)) ? "grumble grumble" : "buuurp";
This also works. 
Seeing a space separate the name and invocation of that fxn kills a piece of my soul every time I glance at it 
&gt;echo (empty($stomach)) ? "grumble grum The double quotes is a non issue, but the usage of empty is ! You should not use empty this way.
Scalar Objects. 
glob will do that in a line and a loop...
There is no such thing like " unnecessary usage of double quotes" but for the rest you are correct. 
Thank you. I will modify the code or create a new one...
Well since double quotes are parsed differently and technically cost more, and in this instance they have no use for the features of double quotes. I'd say it's unnecessary.
Double quotes gets interpreted and cost a bit more memory. It may not make a big difference with small sites, but once you get thousands of hits/sec - then you'll start optimising these things.
Looking at the class, it seems that it represents a entity, or [Domian model class](https://martinfowler.com/eaaCatalog/domainModel.html). This assumes that the class represents *data* and therefore not a class that performs a *service*. It should really just provide a structure to obtain *information* and to change the *state* of that information. With that said I would suggest you separate the concerns. For example, we can create an interface for all entities that need to be "lockable". namespace ContentLock\Entity; interface LockableInterface { public function getContentId(); public function getContentType(); } You need a service to lock, unlock the content. Again, we can define an interface first. namespace ContentLock\Service; interface ContentLockServiceInterface { public function isLocked(LockableInterface $lockable); public function lock(LockableInterface $lockable, array $options = []); public function unlock(LockableInterface $lockable, array $option = []); } And then a class to implement this service. I've made a start for you. The key to take away is that the service performs actions using it's own dependencies (database/userid/tablename) and the entity just provides the information needed. The service is independent of the data, encapsulated around the service interface. You can now provide any entity that implements the `LockableInterface`. Conversely, should your "locking strategy" change, you can create an entirely new implementation of the `ContentLockServiceInterface` which would still accept the *same* lockable interface, perhaps one that doesn't need database access. class ContentLockService implements ContentLockServiceInterface { protected $database; protected $tableName; protected $userId; public function __construct($database, $tableName, $userId) { $this-&gt;database = $database; $this-&gt;tableName = $tableName; $this-&gt;userId = $userId; } public function lock(LockableInterface $lockable, array $options = []) { $data = [ 'content_type' =&gt; $lockable-&gt;getContentType(), 'content_id' =&gt; $lockable-&gt;getContentId(), 'user_id' =&gt; $this-&gt;userId, 'timestamp' =&gt; date('Y-m-d H:i:s'), ]; $result = $this-&gt;database-&gt;insert($this-&gt;tableName, $data); if (empty($result)) { throw \RuntimeException( sprintf('Could not get lock on content with id \'%d\'.', $lockable-&gt;getContentId()) ); } return true; } // *** other methods of interface } Usage would then require you to construct the service. $database = new \PDO(...); $userId = 123; $lockService = new Content\Service\ContentLockService($database, 'content-lock', 123); $blogPost = new Blog\Entity\BlogPost(); // implements LockableInterface $blogPost-&gt;setContentId(789); $blogPost-&gt;setContentType('blog-post'); $isLocked = $lockService-&gt;lock($blogPost, ['foo' =&gt; 'bar']); Other things to note that in my opinion would improve your code. * Adhere to the recommended [PSR standards](https://www.php-fig.org/faqs/). PHP in the past has been a language with very little standards. Today however this has changed; where a number of the respected frameworks implement PSR standards and *recommend* that you do as well. If you want to write modern code, coding standards are essential for allowing your code to be read and understood by others. * Use namespaces. Code can be much better organised by breaking up components. When you start to write classes, you will have a class name explosion and naming them correctly will greatly improve *autoloading* tasks. * Interfaces. Always think about what *interface* is exposed by your class. Think in terms of client code interacting with your object's API, the methods that are public, rather than the internal implementation. * Use Dependency injection like in my example that database is injected in via the constructor. Allow the variables like this (the ones that vary) to be modified from outside of your class. This makes your code unit testable, essential for you to ensure you have code quality. 
Wrong position of closing bracket 😉
O never used define () in PHP.
 same thing using two lines: &lt;?php $files = glob("/path/to/images/*.{jpg,png,gif,JPG,PNG,GIF}", GLOB_BRACE); $random_file = $files[array_rand($files)]; ?&gt; 
Thank you... 
\`\`\`&lt;img src="img.jpg" /&gt;\`\`\`
Unnecessary closing php tag. I'll pass.
You're a fucking wizard.
This is a very old superstition but come on it's time to grow up and stop believing in scary tales. I have no idea what do you mean under "Double quotes gets interpreted" but does it mean that single quotes delimited strings are not? How they are get understood by PHP then? By means of telepathy? And your remark on memory is also extremely interesting. What makes a string literal `Hello world` occupy more memory idf it was written in the script using double quotes? How much memory it will take if it was received from GET request? Woud it be any different in case of POST? That's a new word in the memory management! As a general advise, just keep your opinion to yourself in the matters you don't understand yet, such as PHP internals or getting thousands of hits/sec 
You need to learn how to [search on the web](http://lmgtfy.com/?s=d&amp;q=PHP+display+random+image+from+a+directory+site%3Astackoverflow.com)
Can you please elaborate on "quotes are parsed differently"? So I imagine the whole PHP script is parsed using the same lexer routine, taking characters one by one and sorting out their meaning, but for the double quoted string there is an exception? Come on, stop spreading this nasty rumor. The only reason to prefer a single quote over double is *your company's coding standard*. There are no other reasons.
Utter nonsense. Double quotes don't cost a bit more in memory. https://nikic.github.io/2012/01/09/Disproving-the-Single-Quotes-Performance-Myth.html https://jonczyk.me/2016/10/23/phpyths-buster-great-string-performance-test/ People smarter than you and I have already disproved it. &gt; but once you get thousands of hits/sec - then you'll start optimising these things Again, utter shite.
Not true. https://nikic.github.io/2012/01/09/Disproving-the-Single-Quotes-Performance-Myth.html https://jonczyk.me/2016/10/23/phpyths-buster-great-string-performance-test/
Well as PHP like the majority of other languages executes by interpreting expressions, you'd know that everything it has to evaluate will by definition require more power to process. A string literal does not need to be evaluated compared to a double quoted string, where php will parse and expand any variables you have in it. Instead of attacking everyone that doesn't agree with you - could we keep the conversation on a normal level? This feels like discussing with a 10 year old.
Fuck you.
PHP 5.2, as it is in its nature a templeting engine
Smarty was pretty big around the time I was using PHP 5.2. Still supports it : https://www.smarty.net/download 
smarty.
Well if you have no idea what are you talking about, it *makes* you like a 10 year old. *Opcode cache aside*, your ideas on interpreting languages are quite... *uncommon*. To me, interpreting a program means to parse it character by character, means the whole script needs to be evaluated with all its quotes, keywords and operators. And as I take your take on it, it is like jumping over entire code blocks, such a s single quote-delimited ones, without the need the parse them at all. Am I correct? 
https://www.phpconference.co.uk/videos/2016/eating-spaghetti-symfony/
Come on little folks, do not downvote this comment, it's more true than you can imagine
Yeah, Smarty was a big thing for PHP 5.2. P.s.: I know you said you're in no position to upgrade, but you should really find/talk to someone who is in that position. Running a version of PHP that old is a big security risk. The end of life date was in 2011!
It’s hard on some that PHP is a C-Wrapper with Perl-Syntax meant to be used as a templating engine 
&gt;\[edit\] who's up for a one-liner ? `$random_file = ($files = glob("/path/to/images/*.{jpg,png,gif,JPG,PNG,GIF}", GLOB_BRACE)) ? $files[array_rand($files)] : '';`
I know you clearly stated you are not in a position to upgrade but get the ball rolling in that direction! PHO 5 is out of support 2/1/2019. Maybe not a sky is falling scenario if this code is internal but it should be adressed.
Opened comments to add exactly this :)
Inner static classes or some such for builder pattern
Seems correct to me? 
'anyways' is american english? it doesnt sound very american. we use it all the time over here (eu). its a great word, blends in with Dutch perfectly, great for ending weird encounters, filling up awkward pauses, concluding emails, changing subjects ... highly recommend, would use again.
For those wondering, this is Rasmus Lerdorf's (creator of PHP) take on it: \&gt; *PHP is a templating engine by itself. Adding another templating engine on top of it just doesn't make sense. The only situation where it makes sense, is when you don't trust the template to contain nice behaving code.*
Short closure syntax * 1000. This is by far the most important thing for my daily programming that I'm missing. Something that would also be interesting is looking at the way kotlin deals with `null`. Something like `$this-&gt;user?-&gt;getUsername()` would be amazing!
Maybe stop posting iffy 'tutorials'. Just in case some poor sap ends up using them?
This. Running 5.2 at this point is a deathsentence. 
Outputs 0 or 1. Should be echo (empty($stomach) ? "grumble grumble" : "buuurp");
- Goroutines: go function() use($x){ /*my async calculation*/ }; - Hinted Array / Hash: function(array&lt;string, string&gt; $arr){} - performance improvements, JIT, fast Numeric calculations for AI
Wtf. Fuck you
While Smarty is a decent choice, [Twig 1.0 runs on 5.2 just fine](https://twig.symfony.com/doc/1.x/intro.html). &gt; Twig needs at least PHP 5.2.7 to run. As of 1.34, the minimum requirement was bumped to PHP 5.3.3. Having said that, if you really want a "great" engine then use php. 
I tend to close only the condition inside brackets so i can expand it later ;) This code works, test it.
Indeed, because echo is no function and doesn't need the brackets. This irritated me.
You're code is even more of a mess
To everyone who keeps suggesting Generics, function overloading, and improvements to arrays (type hinting, "true arrays", etc): Those languages exist: they are called Java, Swift, Kotlin, C++, Rust. They're all pretty good these days (Java being the least good of the bunch, IMO). Give them a try! Why make PHP just a slower, crappier, Java when you can use the real thing?
You are not in the position to upgrade. So instead of upgrading, which you can not, I suggest you to try and get into the position to upgrade. You always have the position of getting into position.
One line? Why? Newline and curly braces cost nothing and add a lot of readability and consistency.
&gt;compound type hints You should probably use an Interface, then. I know it's a lot of boilerplate if you only use it in one place, but it makes your design more explicit and clear. If I just look at your function def in the example I might think "What in the hell is he going to do that can be an int or a string? If your Interface has some good methods defined on it, it will probably be clear.
Why not [DirectoryIterator](http://php.net/manual/ro/class.directoryiterator.php) with or just [glob](http://php.net/manual/ro/function.glob.php)? 
Ok, I will show using glob also. 
* Opening braces for methods MUST go on the next line, and closing braces MUST go on the next line after the body. 
Have a look at [json_last_error](http://php.net/manual/en/function.json-last-error.php), which _should_ be used to handle errors in decoding JSON, _not_ a comparison against `null` for the return value. If you serialize a null/falsy value, the return should obviously also be falsy, and unserialize emits a NOTICE if there are errors unserialization errors. &gt; In case the passed string is not unserializeable, FALSE is returned and E_NOTICE is issued. 
I understand the problem and agree with your stance, but what is the difference, logically, if the array value is falsy or the array value doesn't exist, returning `false`? Regardless, any conditional branching won't happen.
Before posting I tried all my examples with E_ALL and didn’t get any error but I may have missed something. Anyway the point is that you have to use an extra step to deal with the possibility of an error. 
`$array-&gt;keys()-&gt;first()` would be preferred, wouldn't it? We already have an `array_keys()` method, just to complete the object chainability. If arrays were objects, calling `array::first()` would return the first value, and if `array::keys()` returns an array of keys, then that would also have a `first() ` method to return the first value of the array of keys. I imagine it would be better, performance wise, to not do this as keys() would have to construct a whole array of keys first, and then pick the first item, but it would make it easier to work with in terms of sorting, filtering, etc.
`bin_to_hex()` would make sense.
`golang` throws a wrench in that machine and dictates that abbreviations be fully capitalized; i.e.: - ApiEndpoint =&gt; APIEndpoint - apiEndpoint =&gt; apiEndpoint - MainApiEndpoint =&gt; MainAPIEndpoint It felt a bit weird at first, but once you get used to it, it's really no big deal.
I typically just use single quotes because I spend the rest of my time in SQL Server which uses single quotes. Also, one less finger press.
Oh, thank you, I edited it. Using an IDE that is pre-configured can lead to lazy mistakes if you stop using it. Usually it's "pu" -&gt; Enter (public), "fu" -&gt; enter (public function), "method name", (), { -&gt; Enter and boom automaticly formating, adding DocBlock with as much information as I given (like typehints, return type etc) or if I write "/**" -&gt; Enter will add DocBlock above the method. Good if I also add exceptions inside the block, then it will these too "@throw .." 
Can’t upvote you enough.
This is by no means comprehensive or purely focused on OOP, but some things I noticed: ## 1. $this-&gt;db `$this-&gt;db` appears out of nowhere. Because this is a **dependency** of your class it should be set via the constructor. (I'm assuming this might be set via some CodeIgniter magic, so it may not be relevant here, but generally anything your class needs should be passed into its constructor) ## 2. if/else statements You have a couple `if`/`else` statements like this: if($content_user_id === $this-&gt;user_id) { return true; } else { return false; } You could simplify this to: return $content_user_id === $this-&gt;user_id; ## 3. `getContentLock()` return type `getContentLock()` is returning information about the lock, but does so using an array because there are multiple pieces of information about that lock. Instead of returning an array, consider returning a `ContentLock` object containing those properties.
From my understanding, this package seems to allow you to chain functionalities based on an initial value. The package I'm linking allows you to supercharge scalars and add functions directly to it. Different behaviors and use cases, but both interesting!
Just read the documentation, no nasty rumors are being spread. http://php.net/manual/en/language.types.string.php#language.types.string.syntax.double
Some methods require an extra step, some doesn't as their return values are not based on user input, e.g. `strpos` can return `(bool)false` to check for _not found_, but `json_decode()` cannot, as _any_ value is a valid return value from that method. It is not an error to return `null` from `json_decode()`, but people _use it_ as such, because there are practically no cases where you expect a null-value from that method, so _if_ you get a null-value back, it means something isn't as you expected, whereas `array_last_value()` could return a falsy value, which could be significant to your logic, even more so, the absence of a value.
https://3v4l.org/P0WKC? 
Except it is true, it's just not noticeable as the first link mentions. That's also why I included the word "technically."
it says: &gt; If the string is enclosed in double-quotes ("), PHP will interpret the following escape sequences for special characters. So you can tell that in case there are no following escape sequences for special characters, they would not be interpreted. The problem solved. No special characters, no interpretation, no reason to worry about a catastrophic impact on the performance. 
&lt;?= (empty($stomach) ? "grumble grumble" : "buuurp"); ?&gt;
Actually, braces are superfluous at all. echo empty($stomach) ? "grumble grumble" : "buuurp"; is enough.
You are right, see my other comment underneath.
What about in something like a builder? Where you may allow the instantiation of the builder class without it having the "proper state" to return what it's "building". Currently on the `get()` method I run checks to verify the state and make sure I have everything I need. This is where I check properties for `null`. Maybe I'm doing it wrong.
By simplifing requirements and knowing how to program stuff.
People do the same thing with ternary statements for no reason, using a normal if/else is just not showing off how clever they are in the minds of some people 
TinyButStrong is really, really good. Much cleaner than Smarty, intuitive and lightweight, one really nice thing about it is that the templating language doesn't screw up the formatting even if you look at the template without the PHP, which makes it ideal for wysiwyg editing (I used to edit HTML visually in dreamweaver). http://www.tinybutstrong.com/ I used to use it extensively before switching to frameworks (CodeIgniter then Laravel) and it's still the best templating language I've ever come across. The days of such are largely past of course now, but for the time it was superb and if you're stuck with old code I **strongly** advise you to take a look.
you probably confused it with concatenation which indeed has lower precedence than ternary - that's why you much provide braces when concatenate a ternary in a string echo "Hello ". (empty($stomach) ? "grumble grumble" : "buuurp");
I never said there'd be a catastrophic impact on performance. Also, double-quotes are interpreted differently than single-quotes. Otherwise, they'd do exactly the same thing, which they don't. You can see how they work differently here. https://3v4l.org/3JsNX It's like saying you can use either print or echo for everything. 
Please stop this faulty **wheel** analogy to spread: when you implement a common IDEA, or abstraction, like MVC, Authentication or whatever a framework is providing, you are not reinventing, you are implementing, and there is nothing strange in this in engineering, do you **see all cars having the same wheel size?** every machine needs a wheel calculated for it's own weight requirements, this wheel statement is wrong and must be dismissed.
Your last example is different. There is no $ sign in the OP. it means you can use either quotes to add a `grumble grumble` string to a PHP script. This is the point. 
Thanks to all the replies, they helped out to to prepare for the interview. I\`ll post my experience, maybe somebody will find it useful. So the job was junior php backend developer, so they asked me about SOLID and the 4 pillars of oop and after that they gave me a modified FizzBizz assignment. From a collections of users get all the users who\`s name was Jessica, sort them by age and then echo out the new collection. 
I've came up with a cool way to do this: &lt;?php abstract class AbstractMyClass implements MyClassInterface { public function __construct(SomeDependencyInterface $dep) { // } // methods here } class MyClass extends AbstractMyClass { // constructor only public function __construct(SomeDependencyInterface $dep) { parent::__construct($dep); } } class MyClassWithDefault extends AbstractMyClass { // constructor only public function __construct() { parent::__construct(new SomeDependencyDefaultImplementation); } }
I actually don’t have a stance. I have no opinion either way. I was just explaining the logic behind why it wasn’t included. It’s all fine and good if the developer understands what’s going on. But in PHP, built-in functions that return values normally rely on returning false/null when they fail (rather than throwing a catchable Exception). In this case, throwing an Exception would be wrong, because if the array is empty, you wouldn’t want it to blow up. Additionally, it would be impossible for the developer calling the function to distinguish between the function returning null/false because the function was successful and null/false because a failure happened without implementing the function themselves (which is, in fact, trivial to do and only a couple of lines of code anyways).
I don't really care about those things you tell. &gt;$array-&gt;keys()-&gt;first() would be preferred, wouldn't it? "preferred"?, if array's are a class then that would work. &gt;We already have an array\_keys() method, just to complete the object chainability. Yeah, but I want the class for readability purposes, have you ever chained two or three functional array functions? ``` array\_column( array\_map( function($obj) { return $obj; }, array\_filter($arr, function($obj) { return condition($obj); }) ) , 'columnX'); ``` This looks a lot more readable for me: ``` $array-&gt;filter(function($obj) { return condition($obj); }) -&gt;map(function($obj) { return $obj; }) -&gt;column('columnX'); ``` Performance?, we're only wrapping the function inside a class, the overhead involved is minimal, "keys() would have to construct a whole array of keys first", welcome to functional programming, any functional method construct a whole new array. Most array_* php functions already build a whole new array.
Some of you people are incredibly dense!! When you write `"$asdf"`, PHP will look inside the double quotes, see if anything looks like a variable or escape sequence, then process those statements. If you write `'$asdf'`, it just blindly outputs `$asdf` to the output buffer. Therefore, single quotes will always require less work. I don't know why people aren't getting this simple concept!
Your code has such serious syntax errors it would never even compile! Try this: `echo empty($stomach) ? 'grumble grumble' : '';`
I built an eCommerce site in Perl back in 99 for a project. It was awful. Wish I would've known about PHP. Also I dipped my toes in CF and really didn't like it.
Short answer: no. Long answer: ORM's are for relational databases, SQL, etc. DynamoDB is a document based database, so you need an ODM. A quick search on github for "odm dynamodb" found a few results. The difference between ORMs is that the R is for relational. So it's designed to fetch all the objects for you and do the queries to get the data. But with a database like DynamoDB there shouldn't be any joins or any relationships that don't exist in the document that contains the data.
Is this even testable at all? The whole test this uses is contained in a single test method. The biggest problems with approaches like these is the magic. IDEs can't resolve this, they won't know which methods you can use on a `with`\-object. PHPStorm would straight up display any call on this as an *error* and the only way to not have ot shown as an error is disabling the messages or using` @metho`d a few hundred times. More than that, it seems you can call basically every single function on every single value. Why this might be *convenient*, it's an absolute horror for stability and it will lead to side-effects whereever possible. If it can be misused, it will be misused, always remember that. Also, you called the functions-file `vvith.php` because you developed on windows and couldn't call it `with.php`, since `With.php` already existed? Man, just call it `functions.php`. These files contain procedural wrappers for a OOP code, you shouldn't create a single file for every function and PHP autoloading also doesn't work like that. It's as ugly as calling a constructor `klass` in JavaScript, when `class` was a keyword. Why not `ctor`, `constructor` (which was not a keyword) etc. If you want fluently interfaced types in PHP, you are better off implementing separate `String`, `Int`, `Float`, `Bool`, `Set`, `Map` classes including fixed methods with strict argument/return types. With Spl Types you can even avoid re-assigning with a different type. You get correct auto-completion for everything without requiring a plugin or thousands of `@method` annotations and you can correctly test every single method your library provides. &gt;sacrificing memory and speed- may or may not be No, function calls and especially magic calls always require overhead. Also, the way you store it, you store all values at least twice all the time (scalar types and arrays are not passed by reference, you create a copy each time), in `Ahc\With\With-&gt;stack` and `Ahc\With\With-&gt;thing`. So using your library intensively, you basically double all memory used everywhere. Apart from the overhead of magic-calls and the substr for the `_`. A few years ago I simply banned `__get`, `__call` and `__callStatic` in my code and I never missed it. And I never have the need for any IDE typing hacks to get proper auto-completion.
Hey, TorbenKoehn, just a quick heads-up: **whereever** is actually spelled **wherever**. You can remember it by **one e in the middle**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
So you want to say that if I write `'$asdf'` PHP won't "look inside" at all and this is the source of doing less work?
&gt; Just for my information, what would need to happen before one could call it OCD? I mean I might indeed be slightly annoyed, but I might also feel a huge urge to correct every line of code that is not like what I think it is supposed to be like, and that the project as a whole is not "good" if there's sloppy things like this everywhere. What you have is simply knowledge and a knack for good, clean and proper coding styles. This has nothing to do with OCD. Many people that suffer OCD and have a lot of problems in life through it and would probably not compare it with a programmer not liking unclean code (what most halfway good programmers do)
Makes sense and my terminology being wrong. I think that was the key to me not finding anything on search.
You're smurfing everywhere. You don't need to append everything with content lock, I assume that unless I'm told otherwise, everything in that class is to do with a content lock. Do you call your keyboard a computer keyboard? No, when it's being discussed in the context of computers people know you're not talking about a musical keyboard.
What a junk article. Everything is closed source and subscription based. You're much better using an open source alternative.
I just didn't have enough time. Will try to implement in August.
Thanks for your reply. Is it really an error, if an array is empty and you want the last value? In the case of, say, `json_decode()`, a return value of `null` _usually_ implies an error, but it doesn't _have_ to be. I agree though, that it's too tricky and thus not a good idea to include that function - I'm just kind of curious about the reasoning.
Your reply here says that the best syntax would be `$array-&gt;keys()-&gt;first()`as that would be best for the functional programming style, which I am aware of. ``` $array-&gt;keys()-&gt;map("strtolower")-&gt;sort(DESC)-&gt;first() ``` Pseudo code to illustrate why `key_first()` would be doing PHP no favors _yet again_. This way, we do not need both `first()` (value) on arrays _as well_ as a `key_first()` on arrays as well. We really need to get rid of those array_X_X() methods if we want PHP to look cleaner. With performance, I meant that simply returning the first or last key of an array is most likely more performant than building an array of _all_ keys, _then_ returning the first/last key, but it doesn't really matte as PHP was never about performance, but rather convenience and ease of use.
It's not any less readable as one line, and it's more efficient from a code writing perspective. I find it difficult to believe that this single line is so much harder to read, considering I do this for a living and have yet to have my brain melt from trying to decipher the complexity of a single-line \`if\`.
Ternary statements are more efficient when writing code in many scenarios. If a variable will be one of two values, it's great. Nested ternary statements are less great, and are annoying to read, although they are readable.
`vvith` is so named because it looks like `with`, the lib is all about `with`- repo/file/class/fn. it is `vvith` not because i developed in winOS but because it might end up being there and because it is all things `with`. i was already thinking to let go `stack` and now i have to do it sooner. thanks for you time reviewing and writing. IDE support is screwed and that is obvious and that can't be fixed in userland unless we write really extensive and complete library with wrappers for all available scalar/array functions. and do you see that solution being performant over `__call` (if it is only for function call overhead, there are still methods wrapping functions and everything)? can't really say without enough benchmarks. this library stands on a philosophy of being dead simple yet making possible what isn't natively available so far. 
I can't really recommend any ORM/ODM for Dynamo, but if this is your first time using Dynamo, be really careful. We built out some stuff on Dynamo and ended up really regretting it and going back to Postgres. It wasn't that we needed better defined relationships, but dealing with Dynamo read/write capacity and trying to keep it effectively scaled was significantly more effort than dealing with Postgres. 
Hurrah, blogspam.
&gt; Your reply here says that the best syntax would be I Never said that nor is my point. I'm just asking for an Array class, nothing more. if you're comparing 'key_first()' with 'keys()-&gt;first()` then yes, there is a performance problem there. But that's has nothing to do with my point.
I'd like to see traits be able to implement interfaces. // Currently class SomeClass implements SomeInterface { use SomeTrait. // But if we could trait SomeTrait implements SomeInterface // Then the class definitionn would be reduced to class SomeClass { use SomeTrait. Seems like it should be doable and would basically allow having a standard implementation for an interface with a bit less typing. 
Running 5.2 on an internet accessible webserver is, running it internally on some system you can't upgrade for *reasons* - (maybe it's hardware control system - could be all sorts of things) not so much.
&gt; vvith is so named because it looks like with It doesn't. It looks like vvith. There's absolutely no reason to have it named like that, no user will ever come to you and ask "Why is this not called with.php, too?". It's a workaround for something that is simply not necessary at all. &gt; with wrappers for all available scalar/array functions That's not needed. It's okay to only implement the most commonly used ones and if you need more, any user can simply extend it and add their own ones. &gt; and do you see that solution being performant over __call It's "Does this method exists? No it does not exist, call `__call('non_existing_function', ..)`, then check if the last char is a `_`, if yes, do something else than without, but call the actual function" vs "Call a method and call a function". Yes, it will have a performance difference. You maybe won't see it with really basic and simple code, but once you're in a loop with a million required operations, you will feel it. &gt; this library stands on a philosophy of being dead simple yet making possible what isn't natively available so far "dead simple" is really subjective here. For me, "dead simple" is when all classes have proper, normal methods you can CTRL+click into and see basic, understandable, normal, non-magic code everyone with basic PHP knowledge can grasp. Your library is dead simple when each function/method in it takes really basic input and provides really basic output. It's the composition of all of them which bring in complexity, but looking at a single unit of code, you see what's going on with that single unit. Magic is "dead simple" on a first glance, when using it. But once it gets more complex, the magic will be in your way and you need workarounds to make it stable again. This is your library and your approach to it. I won't tell you how you should write it. But personally I'd never use it. Especially not in favor of actually, strong, 100% coverage tested, stable and strictly typed wrappers (that exist and can be written really easily).
readability can be argue, but not consistency. 
you'd not use it. no wonder even i havent used it too. but you are really whining like you had to do `require 'vvith.php';`. man, that is autoloaded and all you gotta do is `Ahc\with($thing)-&gt;start()-&gt;hacking();` in general i agree with you. `with` is not really elaborate `wrapper` that you are thinking of, apologies. it allows magic `__call` so i can be done with 25 sloc and not wrapping gazillions of [functions](https://blog.codinghorror.com/php-sucks-but-it-doesnt-matter/) because that would be very fast. 
Are you using prepared statements?
Sorry, being so new to this I'm not good with the jargon... Do you mean am I washing the passed in strings before they're put into the URL for the PHP call? If so, then yes :)
Dynamoose is the closest to what you're looking for. It's really great.
What driver you are using - PDO, mysqli? don't tell me you are using mysql_query
PDO
It’s just if your using a prepared statement, your SQL query would be something like: “SELECT * FROM TableName WHERE Value = :VALUE” And then an array, array( “VALUE” =&gt; “\”Dad\’s Name\””,); Then prepare and execute. I’m not 100% sure if that would work, but that’s what I would expect. 
Consistency: If it has a single outcome, use one line. (As above) If it has multiple (adds a value to a variable, echos out said variable), use curly brackets and multiple lines. --- If the above is done, your code is consistent. 
Sorry if I'm misunderstanding the problem, but it sounds to me like you're not using prepared statements. Give this a read and it should solve your problem: [Link](https://www.w3schools.com/php/php_mysql_prepared_statements.asp)
I agree with you, that we need arrays to be objects.
Great, the best choice you could have made. So here you can learn [what a prepared statement is](https://phpdelusions.net/pdo#prepared) and here various [examples for running queries with PDO](https://phpdelusions.net/pdo_examples)
[Have a read](https://phpdelusions.net/pdo#prepared) through especially if you're passing directly from $_GET 
Currently I use this to GET $MyValue = $_GET['InputString']; Then prepare the SQL statement like this: $sql = "SELECT * FROM `MyTable` WHERE `MyValue` = \"$MyValue\"";
Thanks for the link! I'll have a read through. Always wanting to learn more.
Thanks for the link! I'll have a read through. Always wanting to learn more.
Thanks for the link! I'll have a read through. Always wanting to learn more.
FYI, w3fools is frowned upon by the community, they are notoriously known for promoting bad and outdated practices.
prepare is a very special term, not something like constructing your query from bits and pieces
Gotcha. Very much learning as I go. The links people are providing are helping a lot. Trying to google myself without really knowing the terminology well was becoming a nightmare, but this has put me on a good track
Just define constants in classes, I see no point defining global constants. 
MetaClasses seem nice but I dont think PHP will ever implement them, there is runkit that does part of the metaprogramming for PHP if you need it. 
So to provide you with the working example (note that a line padded with 4 spaces from the left and empty lines before and after is formatted as a code) $stmt= $pdo-&gt;prepare("SELECT * FROM TableName WHERE ValueName = ?"); $stmt-&gt;execute([$_GET['InputString']]); $row = $stmt-&gt;fetch(); here $row contains a single row. in case you want many, use fetchAll() instead and get an array of rows. 
I've heard this a lot but for simpler tasks like this I find them fine and they're easy to follow especially as a beginner. I remember personally using this page for prepared statements back when I first started a few years ago and it helped. Is there any issue you can see in regards to the link i sent?
Quite. - they teach you absolutely **unacceptable** way of error reporting. The way they are doing it is wrong on so many levels - there is no error reporting for mysqli query at all - there is an insert query for mysqli shown, so there is no mention of all the trouble with SELECT queries. - for some reason they are using the mode tedious way to use prepared statements with PDO. Check out my concise example in the other comment. When people look at a code that takes a whole page to run a simple query they start to think that it's something too complex and should be avoided when possible
That did the trick! Thank you! I've learned something new :)
\+1 for the concept of using custom wrappers for 3rd party code. Building a tool set of 'wrapper' classes is a good thing, and often overlooked by people who have buried themselves into framework dependency.
Here's my confusion on the usefulness of interfaces. So you create an interface just to declare empty methods that classes will all implement. If you want to change the name of the method, you have to now change it in one extra file, everywhere it was used AND in the interface. I do see the benefit though for a project that is massive in scope with many developers. They want to create a new class that is similar to another class, they can implement the interface and it gives a consistent means for them to develop from... but yeah I definitely still don't see any time saved when it comes to changing method names. You still have to change it everywhere its called and in the interface and if you decide to add or remove a method from an interface you have to go through and remove it everywhere it is implemented as well.
You just should remember to use this way for the *every* query that takes a variable, not or just such edge cases
What a waste of perfectly good t-shirt transfer resources. 
I have been learning php for a few months now, wasn't aware they were so useless. Though I haven't really used that site much. Would you have any recommendations for a novice that would have acceptable standards and practices? Something I really don't want to do is learn php shottily. It's been a great language to learn so far.
Yeah, but empty() doesn't throw an error if `$stomach` doesn't exist. So if his stomach was removed and he would just go around emitting unceasing grumbling noises.
Excuse me, but empty() doesn't throw an error if `$stomach` doesn't exist. So if his stomach was removed and he would just go around emitting unceasing grumbling noises.
Having a codebase that can run CLI scripts, cron jobs, web interfaces, REST APIs, etc, all sharing the same set of classes/objects, and most importantly... with as few dependencies as possible, makes things much more easily portable, and why PHP is a very utilitarian language (unless you're a perl \*eh\* or python lover\*eww\*). =p Open Source Frameworks are great for many things, but for many projects, they can be a (dependency and portability) liability.
Well, for the best practices in general I'd follow the everyone's advise of visiting phptherightway.com And for the several topics covered, I would recommend my own site, particularly on PDO which was already linked in other comments and on [Error reporting](https://phpdelusions.net/articles/error_reporting) and a quick guide on the [top PHP delusions](https://phpdelusions.net/top)
Thanks for the recommendations!
It's not about time saved (although I argue that going slow and doing it right IS faster in the long run), it's about ensuring that the code you write isn't fragile or tightly coupled. So that things won't break in unexpected places when you make what should be trivial changes, and that you can reuse classes without worrying about all of the various dependencies that the class needs. Here's [a section](https://youtu.be/TMuno5RZNeE?t=955) of a great talk that Robert Martin (author of Clean Code, amongst other books), where he goes into symptoms of bad code and talks about fragility, rigidity / tightly coupled code, managing dependencies and the dependency inversion principle (and more). I'd highly suggest taking the next 20 minutes of your day and watching him explain, he does a much better job of it than I can. If you have some more time after that, you should look into the SOLID principals more in depth.
Where is your empirical evidence? A thought experiment does not proof make.
&gt; Explicit is better than implicit.
Love articles like this. Too many posts are essentially supplementary API docs that document usage instead of exploring an idea. I like this overall approach, though I find it can get tricky when managing hidden side effects in your legacy code. Wrapping it is great, and standardizing your interface first and worrying about the details later is an excellent approach, but sometimes the thing you're wrapping can be more work to abstract than to refactor. Eg it still doesn't protect you from colliding global functions. 
Now you‘re getting offended and exaggerate. I never said it would be „very“ fast, I told you exactly what would be going on under the hood and you’re telling me you can’t tell if it would create overhead? You asked for input, my friend, I gave you input. I don’t care if you take it serious or not, Have a good day.
[removed]
This is a great slimmed down version of Laravel specifically for creating CLI apps. https://github.com/laravel-zero/laravel-zero
You need to learn how to read the opening post. TS is posting a 'tutorial'.
I've used this approach for legacy code in the past and it worked nicely. I frequently wrap third party libraries as well, but only when I know they are going to be used in multiple units (read: classes). I do think majority of the time it's overkill to wrap a library if you're only going to use that library in one class or one small unit of the codebase. As far as legacy code goes, however, it's definitely nice to have that bridge both from a stability standpoint and overall development experience.
Wow! It will be really great. I am waiting eagerly.
Why is Shia Labeouf the thumbnail for this article?
Absolutely, not saying they don't have any use. $foo = isBar() ? FOOBAR : NOBAR; Is one thing $foo = (isBar() &amp;&amp; $var) ? "string ".Bar::foo():"Other string this time ".Foo::bar($var); Is closer to what I see when I mean people just need good old if/else
I was trying to create a C extension called Scalar Classes, which has built-in scalar objects behaviors and the extension can be installed like PECL package. Unfortunately the code was lost when my old PC died, geek squad failed me and erased most of the data I had there. Not sure if I will be motivated to start over again. For PHP userland implementation, I have one working on a project I work on which is compatible with PHP 7.1. Also there was an older implementation that only works with PHP 5 though, it is available on github: https://github.com/rossriley/php-scalar-objects
Agreed. 
When using a proper IDE, this would just be syntactical sugar. I would love for consistency in naming of php functions and objects, but when I asked Rasmus Lerdorf he almost bit off my head. So I’m afraid this ain’t happening.
Partly agree with you. On one hand I read the desire for Generics and hinting of entities in arrays. But I also read suggestions of compound types. I would personally love php to move more towards a more strong typed language. But I would not be in favor of both adding features that increase and decrease strong typeness. If one wants a true strong typed php maybe a Typescript variant of php would be an idea.
you wanted to write 'learnt', didn't you?
Who wants a primitive stomach anyway? Let's have *$stomach-&gt;isEmpty()*, not *empty ($stomach)*
It's Actual, programmer Shia LaBeouf
Normal tuesday night for Shia LaBeouf.
 Laia ShBeouf!
I did read the article, I'm not commenting just on the title (in Reddit fashion), but I still think if you have legacy code is so bad you **literally want to disown it** for the purpose of how you see it, handle it and test, it points to a larger problem in the way you write code. Legacy code should happen when your evolving needs require the code to evolve beyond the breaking point of maintaining compatibility, it shouldn't be some monster you're afraid to mock and test. That aside, if the code is truly horrible and you're really-really-sorry-it-won't-happen-again, the tip is sensible.
Do you mean the Zend Framework?
Altering historical data is one of the advantages of ES. Of course it is a pain to change large sets. You can reduce the burden with snapshots. Combine all the data in regular intervals.
How have you measured said popularity?
Yes
Subjectively
r/PHP... 
Sometimes you inherit a project, but you can't immediately burn it down and start over. This is useful for siloing off the legacy code so you can still access the functionality while you build something more sensible.
With http://php.net/manual/en/function.get-defined-functions.php and a bit of reflection, you could fairly easily compile an AST to generate code with valid signatures that can be resolved, to get the best of both worlds. You can hook into composer events to trigger compilation. Still, even then I would not consider using this, but at least that way it becomes usable in IDEs, while you don't have to maintain a large set of methods.
I'm not sure the clarification "legacy code is 3rd party code" is required in that case.
If only our legacy code used namespaces and classes.
Have you used Zend Framework?
&gt; In any case, on the web, many websites are also web applications. NONSENSECEPTION
Maybe not easy, elegant or simple compared to others (like laravel)?
Unless an attacker gets into your internal network from outside, or you have a disgruntled employee inside. Depending on level of access, if your 5.2 app talks direct to other more secure systems, those are now more than likely compromised as well.
Yup. I’m working on a new project (for me) that basically does just that. Migrating a legacy API from one framework to another, while allowing both to transparently coexist and “talk” to each other, where appropriate. Eventually, the older API will go away, but we’re talking thousands of lines of code, so it takes time to “ween” it away.
Zend 1 and 2 were pretty long in the tooth. They kind of got Zend Framework’s reputation where it is. That said, the ZF3 stuff is actually pretty nice and more highly component-based and decoupled like Symfony. It’ll probably never be as widely used as Laravel between the reputation issues and the fact Laravel provides so much tooling. 
zf1 was a crazy beast. zf2 though ws very different imho - and zf3 is very similar to zf2 where I could migrate with minimal changes.
&gt; It’s been a long time since I last saw a system without autoloading It's been about 6 hours for me... :(
Using https://github.com/broadway/broadway and http://getprooph.org/ I like Broadway but it is missing some functionality but Prooph has that functionality but it wants to influence the way you write your business logic in a way I don't like.
Yeah devs want to apply it to everything when they first get into it but when you know the project is just going to be a bunch of CRUD on objects don't bother. 
ZF1 was amazing at the time. ZF2 changed the paradigm from MVC to MOVE which made porting from ZF1 painful and lost quite a bit of momentum. Symfony, Cake, Code Igniter, etc came along and ZF slowly faded into obscurity. Haven't kept up with it, but at this point it's probably just easier to pick a more popular framework for the community support. 
What differentiates your Collections class from all the other ones available on packagist?
I'd say look at DateTimeImmutable and forget that DateTime exists.
Probably doing it for learning purposes.
Haha I was just thinking the same thing.
With all due respect, linking to http://php.net/manual/en/function.copy.php instead of writing this blog post would have been more valuable. 
Nice. Can this be used to prevent cache stampede ?
Then people would be submitting a "break WordPress" feature request to the NodeJS project `;-)`. 
&gt; If one wants a true strong typed php maybe a Typescript variant of php would be an idea. Isn't that the basis of FB's Hack? 
With all due respect, a blatant blogspamer doesn't deserve any respect. 
Keep going, you'll have your whole site banned on Reddit
ZF is intended to be a Java competitor for lucrative corporate projects. In many design choices and the documentation they overcomplicated/overengineered the problems faced by the majority of people using PHP, who is doing small to medium websites, rarely ERP for multinationals in big teams. Small to medium websites are well served by microframeworks or generator rich frameworks, that offer a way lower cognitive cost. 
You can add some "best practices" like: \- add badges to README \- LICENSE \- .editorconfig \- .travis.yml \- .scrutinizer.yml Yo could use a coding standard linter like phpcs or similar
One question - why do you use snakecase for test methods names?
Implementing Traversable interface for collection lib is a must (+ in this case I would probably add ArrayAccess)
Yeah, it’s just OP for that. I’ve only used it once after a job where we used it. 
The JsonSerializable interface is wrong implemented. The method must not return json, it has to return something to which json\_encode can be feeded with.
[Very interesting post](https://www.inderapotheke.de/blog/farewell-google-maps) reviewing alternatives
I used a few ZF2 era libraries (PDF / DB / Apigility) and I found the syntax and approaches to be verbose and quite unfriendly (especially DB). Permanently put me off. Each to their own, maybe it clicked with someone, but didn't for me.
fyi you are an idiot
fine by me
Maybe, or maybe there just not enough noise around it. Tailor is very good to start some noise around his work. And Symfony was just around for too long. Think of it as... there are two tools available and on stack overflow you could find 100 questions per month and 30 questions per month around this tools. This numbers could be misinterpreted as popularity, but in fact this could be just lack of documentation, or tool just not fits peoples needs in some way. Popular option not always best option. Popular is just popular. You could find benifits from this (easier to find developers for example) and you could also see downsides (the more popular something is, the less average level of developers). For example I see this problem with Laravel developers, they are good at doting something standard and it harder to find developer for something less standard. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I have a perpetual licence for PHPStrorm 10. It works very well not sure if there are any features I'm missing out on, which makes it worth upgrading?
A Typescript for PHP is an interesting thought. Otherwise, there's always [Hack](https://hacklang.org/)
VS Code has won me over IF: I can use it on Debian and it supports remote debugging. Never saw this day coming. 
Slim is quite famous.
Rasmus flat out said in the 2018 PHP conference, and maybe earlier, that he knew he had "lost the war" when the first template library popped up!
[Here is the PHP support timeline](http://php.net/supported-versions.php). Full support of php 5.6 ended a while ago. Support for security fixes will end in 2019. PHP 5.2 is so old it isn't even on that timeline. u/iamrootnotgroot should let their boss know that continuing to use php 5.2 for anything they don't want to be compromised is the definition of negligence. 
&gt; annotations -_-
Actually, despite being a wp plugin, this plugin looks te be quite well written. All html seems to be in separate view files; so I wonder what class-xxx file you're talking about?
Kinda wondering the same thing with PHP tests in general. It's probably the only domain where I see snake case used in PHP. Surely PHPUnit doesn't enforce it, no?
Does anyone know how to get the debug session longer then 30 seconds? I got local debugging and I couldn't imagine coding without it
ZF1 was very popular for awhile. ZF2 took 2 years to push a stable release and Symfony 2 really came together around the same time. Laravel was released shortly after that. Obviously, Symfony and Laravel are most popular these days.
It used to be very popular on reddit years ago. In fact, I have had written posts here on reddit criticizing it and, at the time, got downvoted into oblivion. Currently, everyone's love muffin bed buddy is Laravel and/or Symfony. Not going to repeat that mistake. So, I'm going to avoid saying anything negative about them and instead say they are super amazeballs and will solve all of the issues in your life for the positive karma. 
My only fear is that they'd then simply stop adopting newer versions of PHP and eventually hold half of the Web back on some long-since EOL'd version of PHP.
Oh, wow. #3 would be amazing for user-land caching.
Yes! Then setting a property to be public wouldn't blow away any guarantees about what's in that property.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
*Set up*, not *setup*, you fucking 🤦‍♂🤦‍♂🤦‍♂🤦‍♂🤦‍♂
Can you take a look at your maillog? It will tell you what the mail servers response is?
does anyone have an idea?
 Unknown column 'o.ggpaypalrefundid' in 'field list' It's saying that column doesn't exist in the oxorder table.
`Unknown column 'o.ggpaypalrefundid'` means there is no such column "ggpaypalrefundid" in the table aliased as "o"
Who hurt you? 
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
Wanna talk about it?
Then they go to Go
Step 1: Uninstaller VSCode Step 2: Install PhpStorm 
He's right, although not eloquent. *Setup* is a noun, while *set up* is the verb. Same with *backup* and *back up*, and *login* and *log in*. It's easy to remember if you conjugate to present: *setting up* and not *setuping*.
Step 3: Pay for PhpStorm ?
https://github.com/wp-erp/wp-erp/blob/develop/modules/accounting/accounting.php My eyes!!!! I haven't seen code *this* bad since my PHP 5.0 days!!
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [wp-erp/wp-erp/.../**accounting.php** (develop → b9567f2)](https://github.com/wp-erp/wp-erp/blob/b9567f218fb00caebc79037d3649a917f8487886/modules/accounting/accounting.php) ---- 
https://github.com/wp-erp/wp-erp/blob/develop/modules/accounting/accounting.php
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [wp-erp/wp-erp/.../**accounting.php** (develop → b9567f2)](https://github.com/wp-erp/wp-erp/blob/b9567f218fb00caebc79037d3649a917f8487886/modules/accounting/accounting.php) ---- 
Well it's not a good template engine. it's hard to isolate from the global context, doesn't do escaping by default, and makes it hard to control what can or cannot be accessed in PHP itself. Twig and co do exactly that. There is no custom execution context with each PHP scripts. 
What's with all this Astroturfing VS Code on Reddit? Like everyone damn subreddit.
ReadOnlyResAssocArr what convention naming is this? 
The EAP is free
Also it get's cheaper over time.
And it's really worth the price, I mean, it's just the price of one burger and a milkshake, I reckon you can miss that. 
After working in a Hack/HHVM stack I don’t think I’d ever go back. It just feels far superior to me.
Well it sounds like the code is actually fairly well architected - you're in luck! Modern PHP applications generally all use symfony's [HttpKernel](https://symfony.com/doc/current/components/http_kernel.html) implementation or something very similar to it. It's essentially a pipeline that turns a request object into a response object, where the request comes from the `$_GET`, `$_POST` etc superglobals, and the response is turned into calls to `header`, `echo`, etc. What you want is to turn those `userEdit` functions into `UserController::editAction` style methods, and then map the routes to the action through HttpKernel and some routing solution. (Symfony's routing option is fine) The HttpKernel will instantiate the controller objects and call the actions as required (Might need some custom code here if the controller has instantiation dependencies) passing url parameters as action parameters as needed. And of course, now you get autoloading and split up your code. Now you'll have to render your templates inside your controllers, but that's a good thing. You can return redirect responses instead of `header();exit;` for example. For frontend nowadays you want to use twig, but smarty isn't *completely* dead yet. If your project is using smarty 3 then I'd just keep using it (But make sure the autoescaping is turned on). If it's stuck with smarty 2 you'll be better off moving to twig both performance and security wise - smarty 2 doesn't have autoescaping IIRC.
&gt; Native between-request in-memory object store without the need for extensions. Why not just use redis on the same box with a unix socket connection? Unix sockets have about 90% of the performance of in-process memory access. Separating programs out into their separate concerns is so much better than trying to cram everything into one program.....and also avoid tying up php internal developers with something that provides very little value compared to just using Redis.
Thanks so much - very useful response with just the info I was looking for. I'm using auto-loading already, although I'm in the process of moving to using Composer for dependencies. I'm using a slightly older version of Smarty 3, and I believe auto-escaping is enabled by default, so all good there. Re HttpKernel and Symfony routing - I haven't had much exposure to Symfony thus far. Do I need to pull in a heap of (heavy?) Symfony dependencies to use these couple of libraries, or can they be added independent of other Symfony code? My existing ("'poor man's") routes are simple mappings of (for example): /userEdit/id/100 -&gt; index.php function userEdit(['id': 100]) I assume I could probably migrate to a modern solution such as HttpKernel gradually by setting up new routes to be managed by it using some new URL convention - maybe just by adding a new static prefix to all new route URL's - something like: /XXXX/userEdit/100 -&gt; UserController::userEdit($user_id) ...and defaulting everything else to using the current bespoke solution. 
Using external services like Redis would a) introduce an unnecessary free-floating dependency and b) be reliant on object serialization vs storing the objects in memory in their zvals. I use Redis extensively, but in some cases there's just no beating in-process memory, including, funnily enough, making phpredis work.
\&gt; If the job were up to you, how would you go about breaking these functions up into separate files? If I understand it correctly, you have basically many controllers (methods like "userEdit" etc.) in one file. If that is the case, \*\*I'd decouple those to standalone classes\*\*, like \`UserEditController\` with one \`\_\_invoke()\` method, that would contain their current content. Manually or rather using AST refactoring because 500k lines is a lot (if that is not a typo, 500 would be ok for manuall work :)). I can recommend tool I'm author of - Rector ([https://github.com/rectorphp/rector](https://github.com/rectorphp/rector)). Then, I'd add simple router class, that would pick those Controller classes based on whatever routing you're using now. That's the basic idea. I'm not sure in what state your code is, so even 50 lines of it would help to improve my answer. \--- As for Smarty, why would you want to change it? Are you hiring developers that use more fresh and standard tools? That's often reason for me, because teaching people old system is loose-loose, for them that they learn dead technology and for the company, that pays them to invest time into clearly temporary know-how. In that case, I can recommend you Twig: [https://twig.symfony.com/](https://twig.symfony.com/), templating engine build around Symfony, but very easily to be used as standalone component. Again, in size of your project I would not do it manually, but rather with automated migration. Recently, I made a tool for Latte to Twig conversion, to give you a hint how to start: [https://www.tomasvotruba.cz/blog/2018/07/05/how-to-convert-latte-templates-to-twig-in-27-regular-expressions/](https://www.tomasvotruba.cz/blog/2018/07/05/how-to-convert-latte-templates-to-twig-in-27-regular-expressions/) &lt;br&gt; Let me know if I made myself clear and if you want to know more. Good luck with this renovation!
&gt; If the job were up to you, how would you go about breaking these functions up into separate files? If I understand it correctly, you have basically many controllers (methods like "userEdit" etc.) in one file. If that is the case, **I'd decouple those to standalone classes**, like `UserEditController` with one `__invoke()` method, that would contain their current content. Manually or rather using AST refactoring because 500k lines is a lot (if that is not a typo, 500 would be ok for manual work :)). I can recommend the tool I'm an author of - [Rector](https://github.com/rectorphp/rector). Then, I'd add simple router class, that would pick those Controller classes based on whatever routing you're using now. That's the basic idea. I'm not sure in what state your code is, so even 50 lines of it would help to improve my answer. --- As for Smarty, why would you want to change it? Are you hiring developers that use more fresh and standard tools? That's often the reason for me, because teaching people old system is loose-loose, for them that they learn dead technology and for the company, that pays them to invest time into clearly temporary know-how. In that case, I can recommend you [Twig](https://twig.symfony.com/), templating engine build around Symfony, but very easy to be used as a standalone component. Again, in size of your project I would not do it manually, but rather with automated migration. Recently, I made [a tool for Latte to Twig conversion in 27 regular expressions](https://www.tomasvotruba.cz/blog/2018/07/05/how-to-convert-latte-templates-to-twig-in-27-regular-expressions/ ), to give you a hint how to start. Let me know if I made myself clear and if you want to know more. Good luck with this renovation! 
&gt; hell even Apache needs to be configured to serve the endpoints in the first place! I was about to say that it's not true, but then I realized you said 5.1 … sorry about that. But, TBH, I'm pretty sure this already existed back then: https://laravel.com/docs/5.6/http-tests Essentially it dispatches your requests _within_ the framework and does **not** need an actual web server (even not `artisan serve`. Maybe for some esoteric cases it doesn't get any more convenient without dependencies. Having used this for all kind of requests (web tests even with session auth, jsonapi and graphql too) I can only say it works as expected. As for CI: you usually only need to `composer install` before you run your tests, given that the environment suites you (database?).
&gt; because 500k lines is a lot He meant 500kb in size, which is pretty fucking huge for viewers/page load times.
&gt; Do I need to pull in a heap of (heavy?) Symfony dependencies to use these couple of libraries, or can they be added independent of other Symfony code? Symfony framework is made up of numerous components. Most of them are pretty independent (except for obvious dependencies - eg. http foundation for routing component). It's fine and even intended to use the standalone components. Furthermore, the **framework** is nothing more than a way to wire these components together - the majority of "productive" code is framework-independent. If you wish, you could start with gradually introducing standalone components and slowly moving to "full" symfony. &gt; I assume I could probably migrate to a modern solution such as HttpKernel gradually by setting up new routes to be managed by it using some new URL convention - maybe just by adding a new static prefix to all new route URL's - something like: I suggest you read this article: https://stovepipe.systems/post/migrating-your-project-to-symfony Doing the full approach shown there might be too much for you, but you can still use it as inspiration for "fallback" from sf's router to old solution if you wish
It's not well written at all, actually it's terrible. Just check for example https://github.com/wp-erp/wp-erp/blob/develop/modules/accounting/includes/functions-transaction.php
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [wp-erp/wp-erp/.../**functions-transaction.php** (develop → b9567f2)](https://github.com/wp-erp/wp-erp/blob/b9567f218fb00caebc79037d3649a917f8487886/modules/accounting/includes/functions-transaction.php) ---- 
Looks interesting. What's the use case?
to programmatically repair a lot of json data (for example truncated in database or somewhere) 
Correct :) Given the site is used by less than 500 people, I'm not too concerned by load / page request times (which are &lt; 300ms at the moment) - I'm more concerned with keeping things tidy, manageable and in line with modern best practices.
Thanks again - I'll go have a read!
If "500k" refers to LOC, then it can certainly be unhandy. Split groups of functions categorically into files (i.e. "user") and just require them in the index.php for a first step. If reasonable, you can write a router based on the current scheme. Other than that you didn't spot any real problems. Refactoring templates probably the most unforgiving thing you can do right now. It is a lot of work, you will make mistakes, lots of testing and the value is quite low. Smarty is shit sure, but that cannot be the reason solely. I wonder what your goal is with this project? Do you have to extend it?
&gt; If "500k" refers to LOC Sorry - to be clear - 500kb file size of core index.php file. 25k LOC incl. class files. 
&gt; I wonder what your goal is with this project? Do you have to extend it or just forcefully move it to some modern framework? The project is in almost constant development with new reports and features. I want to tidy up existing code as much as possible to make it more easily maintainable by both me and whoever takes over my role later on, and to make future development as pain free as possible.
Yep. But besides that, here’s the deal... Many of us are professionals, we’re paid to write php, and typically your employer will purchase a license for you! Or, if your self employed, it’s a rather small investment to make. Think of how much money you make using phpstorm, after your first project it’s paid for. Ok, so maybe you’re writing open source code, jetbrains will GIVE you a license. It’s silly to poo on the cost of a great price of software when most of us here write code for money... I don’t get it. I’m not trying to suckle on the teat of jetbrains, I have this mentality for all of the productivity software I use to do my work. 
Well done putting your work into a new idea of a library. It looks quite well written at the first glance. :) I think, the use case is indeed quite narrow. You could support an assumption about how the data is supposed to look. Maybe pass some definition of the expected data structure for a future version? The only thing you can currently fix, is, if luckily the last few closing characters were cut off. That's a really narrow use case. Looking from a design point of view, I'd split the code a bit more to support further extensibility. It would be nice to support to replace truncated values with null, so you don't generate false data. For strings, it would be easy to detect, but as you don't want to restarte a truncated price of 1000 to 10, there should be an option to set any value at the end of a truncated json to null and to drop keys at the end, if the closing " is missing. Also consider setters for the options such as of silent, missing values and my proposed null if value truncated. If you want to keep the options in the fix method, switch to an options array, if you consider growth of the library, so you won't run into b/c issues.
&gt; Do I need to pull in a heap of (heavy?) Symfony dependencies to use these couple of libraries, or can they be added independent of other Symfony code? Most Symfony components have very few dependencies. They're designed first and foremost to work on their own, with the framework just being a standard way of putting them together. For reference, the HttpKernel is used in Laravel, Silex, and a whole load of other systems too. It's only real dependencies are HttpFoundation (Which provides the aforementioned request/response objects) and an event dispatcher (So you can hook events for pre/post dispatch and so on) &gt; I assume I could probably migrate to a modern solution such as HttpKernel gradually by setting up new routes to be managed by it using some new URL convention Yes, the symfony routing component will let you point '/userEdit/id/{id}' to `UserController::editAction` and if you add a parameter named id it will automatically fill it in, so it will reflect the `public function editAction(Request $req, int $id): Response` signature and automatically put the request object and the url portion in the right parameters for you. &gt; adding a new static prefix to all new route URL's [...] and defaulting everything else to using the current bespoke solution HttpKernel tends to throw an exception for 404s, and catch it afterwards to return a file not found response. You could set your file not found handler to trigger your old system (And if you put some output buffering around it you might be able to have the old system go through httpkernel too, but from experience I can tell you that's more trouble than it's worth!)
When I hear 'refactor' I see 'kill myself' because it's usually what you're dealing with. If it's a junior role or similar I'd just tough it out and 'refactor' shit as needed and find a better job.
On the contrary - I'm a middling to senior contractor, and it's an active project for a client I love working with that saw its first repository commit six years ago. Being a project with some history (and associated baggage), I was curious as to what others' approach might be in ensuring it's as nice to with as possible.
well thought out and well written too. couldnt thank more. will see what can be done.
This [Symfony Article](https://symfony.com/doc/current/introduction/from_flat_php_to_symfony2.html) shows how to build a simple app using the symfony http core classes. Not much is required to get started.
AFAIK EAP = no commercial use. You are violating the license if you do so, no better than pirating PHPStorm.
Whoa.. no need for Apache that is truly awesome and game changing! I can have it hook up to my database on another server and the API endpoints I hit use the SSH package that calls to another server.. so that doesn't need to be recreated either. I think the web serving is the only thing tripping me up so if I don't need that then this will become fairly straightforward!
&gt; If you take a look at the documentation, none provide support for PHP*. PHP’s shared nothing architecture is just another word for "serverless". :-P
How did that work out for ya? Lol
For me the pain was in ZF 2 module configuration, wanna know where a route is defined? oh lets look in one of the autoload config oh not in there maybe it's in some if the module directories. Also the invokables where a huge pain in the ass, for example when you add a controller class to a route you need to set it up in a invokable config too it was just super annoying work for no benefit. And don't get me started about the ServiceLocatorAware interface which most people just added so they could pull everything they needed from it, which they removed in 3.x which was good cause it created a lot of hidden dependencies but what sucks there are a lot of legacy projects where you need to change a lot of code to upgrade (I still have to work on some of those where I can't upgrade to 3 because it will take a lot of time to refactor). Also ZF 2 was very very slow the stack trace is pretty much unreadable and will often crash php if you var_dump some object because of the heavy event driven style which was used and often overly complicated confusing and poorly documented. That being said I do like some of the new libraries in Zend like Diactoros, Expressive, HttpHandlerRunner. 
A disconnect method in PDO would be nice. https://bugs.php.net/bug.php?id=62065 
It seems that your comment contains 1 or more links that are hard to tap for mobile users. I will extend those so they're easier for our sausage fingers to click! [Here is link number 1](https://www.php-fig.org/faqs/) - Previous text "PSR" ---- ^Please ^PM ^/u/eganwall ^with ^issues ^or ^feedback! ^| ^[Delete](https://reddit.com/message/compose/?to=FatFingerHelperBot&amp;subject=delete&amp;message=delete%20e2snxh3) 
Take a look at https://github.com/spiral/roadrunner you can embedd php application into Golang using binary IPC which does not require any extensions on PHP end. We have initially created it to drive data from Amazon SWF and RabbitMQ but later added http support (we are using it on production). It should be pretty easy to use it with aws-lambda-go (see Standalone Usage). I hope it can help with your goal. It should also work faster as library keeps your PHP processed alive for multiple requests.
Nice one, cheers! This looks like a really interesting project. Will definitely give it a go. 
Do you consider it repairing when you know it's been truncated and are missing data? Seems like you're just propagating more problems down the line
And HTTPS pretty please...
&gt; Foreach, except for keys only, e.g. foreach ($array askey $key). [Just throw an array_keys in there?](https://3v4l.org/9L4XS)
&gt; Additionally, the number of programmers doubles every 5 years, so within 5 years young programmers will be part of the old guard. My probably unrelated experience so far: Programmers go through several stages while they are gaining experience: * At first, nearly every programmer is focusing on small details. Usually the phrase "premature optimization is evil" tries to target this type of youngster. * Now they are slowly progressing towards seing the big picture. They realize that one "user story" / feature / module / whatever is worthless without considering the whole product surrounding it. * Afterwards they are not only seing the whole program, but also its history. They slowly grasp that rants concerning tech debt are not made for fun. They realize that their decissions will have heavy impact on their product some years later. * And now things get interesting, because some of this programmers will slowly progress to realize that we are not dealing with technological issues. Nearly all problems have their root cause in social behavior. Some people claim, that it takes roughly 5 years (or 10k hours) to get an expert in your field. The first question here is: means expert being on top of the game when it comes to tech? Or would this already assume that a programmer is already beyond his social threshhold? What i additonally noticed: a person in his early stage has absolutly no chance to grasp knowledge from later stages. They are simply still overwhelmed with their currents stage complexity. In my experience, 5 years are most often not enough to grasp the whole (tech + social + ethics,..) picture. If you combine it with the bobs observation, that most developers are below 5 years of expierence, my bet is that most people are simply not yet capable to notice his underlying message. His talks are most often not targeted towards beginners. Now, whats your gut feeling? How many of the typical posters responding to such a topic have already reached a stage that allows them to absorb his message?
I’ve worked with ZF1 apps over the years. While certainly better than anything available at the time it came out, ZF1 is an abomination by today’s standards. The convention-driven routing (“dispatching” in the old lexicon) is a nightmare; even simple apps spin up countless dozens of objects for every request. There is no true autoloader, as all “resources” have to be “registered” in bootstrap scripts. Worse, there’s no dependency injection. All your business logic winds up in huge controllers (whose functionality is extended by “action helpers,” accessible by magic calls to “helper brokers” … gahhh), or else objects accessible by static calls to the Zend_Registry singleton. Nothing is testable. The Zend_Form library is especially atrocious (form elements are inextricably tied to the presentation layer; customizing the display requires wading into a needlessly complicated system of decorators; all elements are wrapped in dd/dt tags [?!?!]). All the developers I’ve worked with are superb coders and couldn’t find easy ways to tame the framework. ZF2 fixed many of the complaints associated with ZF1, but didn’t take off as expected because 1) the upgrade path from ZF1 to ZF2, which is especially configuration-heavy, is painful, and 2) ZF2 was a poster child for over-engineered Java-like code, whose overuse of design patterns and abstraction that conceals some messy design (for example: tightly coupled components, an event system that makes it hard to step through code, and beastly inheritance hierarchies). Also, IIRC, controllers still used Zend’s dependency container (renamed from Zend_Registry to ServiceManager) as a service locator, meaning you still had to mock up your entire application in unit tests. The new ZF3 stuff, however, is a pleasure to use. Zend Expressive, combined with any dependency container/router/etc. you like, is all you really need to build a great app. PHP has evolved to the point where a monolithic framework is no longer necessary for complex projects.
I see you still get downvoted 
Thing is, PHP is the epitome of "serverless". Grab almost any shared hosting provider, the host they give you is the equivalent of the API gateway. Upload the PHP code. Kinda just like uploading a lambda zip package. Simply hit the endpoint URL, invocation! It's actually pretty baffling that serverless solutions don't better support PHP; it's such a plainly obvious fit, but perhaps it's that hosting PHP in the same fashion is so trivial there wasn't a good way to sell it. I sure would, however, love the same level of "we manage the servers, gateways, load balancing, etc" that the servless ecosystem is really useful for.
PHP isn't available in these environments for 2 reasons. 1. PHP extensions. We all expect a certain extensions, these extensions all add bloat just to be made available. To make optimized solutions, this makes things very hard. Ideally there would be an option to select the extensions you needed in you serverless function and it would use that config. However (at least on AWS) every lambda environment is exactly the same. The runtime you pick does not change the environment. So they have reason to have only one environment with all runtimes which would mean only a single PHP environment that has specific extensions installed. 2. Speed. PHP has a much slower response time than the other languages. For longer running processes, this isn't an issue. But for what serverless things are meant for, it can drastically increase usage/cost and response times. If you really want it, obviously you can have it. It just takes a little work, but you can optimize it exactly as needed.
do you have any valid credential, facts and figures to go about declaring PHP has "a much slower" response time? 
Azure supports php serverless 
Yeah I agree PHP seems like it should be a good fit. The biggest advantage I feel you are missing compared to shared hosting is the scaleability. Just being able to almost throw any amount of traffic and AWS/Google/MS will just handle the scaling for you, transparently is kinda amazing. 
The complaint is quite broad and he doesn't mention something that is specific to php. Maybe some hugs would help?
I think he'd be doing the PHP community a favour
Yes, except the big deal with serverless providers is that you pay only for the execution time you actually use, and the application will scale with the load. The share-nothing architecture is just one aspect of serverless/FaaS. 
This is really interesting to see those alternatives to the Node+PHP approach. For those interested I am working on the Bref project (https://github.com/mnapoli/bref). I might give a try to PeachPie/php-go though!
What would be some good projects for a semi novice wanting to dive deeper into php? I've done a CMS, and am working on a scheduling webapp, but want more versatile projects that I can learn and are approachable.
I've always used this https://github.com/ramsey/uuid Then Uuid::uuid4()-&gt;toString();
check http://php.net/random_bytes you might want to wrap it with `bin2hex` or `base64_encode`
maybe they might want to check https://slack.engineering/taking-php-seriously-cf7a60065329
A crama whore thought they will snatch some points posting this link here. Although technically legit it's a spam by intention. /u/koavf just keep from /r/php, you have no idea what to post here. GTFO
I appreciate the detailed response
Why is the Half Life logo in the picture? 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
`bin2hex(random_bytes(16))` is what I recommend as the go-to method of generating random, unique tokens in the absence of additional requirements (such as compatibility with UUID format).
You could md5 the original file name. This would make unique file names. `md5($original_filename)`
nothing prevents PHP hosting companies from doing that.
&gt; Just throw an array_keys in there? I suppose another acceptable solution would be if PHP did some opcode optimizations for that, but as it stands, using `array_keys()` is horribly inefficient. You're recreating an entire array just so that you can write slightly cleaner code. This is absolutely no go, if the performance of the code is relevant in any way. e.g. if I run the following code: ``` &lt;?php $foo = range(1, 1000000); $keys = []; foreach ($foo as $key =&gt; $value) { $keys[] = $key; } echo round(memory_get_peak_usage() / 1024 / 1024, 2) . 'mb'; ``` I get peak memory usage of "68.34mb". If I used `foreach (\array_keys($foo) as $key)`, I get "102.34mb". A 50% increase in memory usage is pretty significant. So now, I just opt for the unused "$value" variable, since that's what's most efficient. Sure, it's really a minor annoyance, but annoying nonetheless. 
I guess, was unaware that array_keys is making a duplicate... Not sure why it does. But for a new syntax it has to solve a problem that can't be solved acceptably in another way. I'd argue that what you really want is array_keys to be optimised, or a nice way to say that not using the values, only the key, in the foreach is intended. Either cases don't really lend themselves to requiring new syntax. :)
Yeah, good point, that's absolutely a wonderful thing to not have to think about :)
Thanks a lot 👍
Thanks a lot! Still a lot to improve till Adam ;-)
And not one does, which is exactly what the quotes says. So we are back to the fact that serverless is more than just PHP’s share nothing architecture.
Because it makes no sense for most hosts to price by usage. It makes sense for Amazon since "serverless" becomes more expensive than regular hosting passed the free-tier. And you are basically admitting that "serverless" is purely a marketing concern.
Any pros cons u see between sonar and other products? Using sonar currently
PHP is really so amazing language. But why so many programmers work on other languages think PHP as a outdated language?
SonarQube, if you configure it right, will do you well. The projects I work on are mainly Java and C/C++ now. At the end of the day it is a good idea to use many tools as each will find different things potentially. Currently I am using Spotbugs with FindSecBugs/FB-contrib and SonarQube to find differences. At the end of the day I'd recommend Fortify for security and quality, and SonarQube for quality then security. At the end of the day though, good code review and coding securely will take you further than both tools. 
Zend Framework team is not able to build a community and thats why it doesn't have good tutorial, documentation on the web. I think this is the main reason.
Please stop posting links to your website here. /r/php is not the place for beginner-level tutorials.
Ok
I am genuinely curious, do people read these posts that are just how to call a function? This seems literally what the PHP docs is for.
http://php.net/manual/en/array.sorting.php
How To Repeat The PHP Manual for clicks and profit?
&gt; A crama whore I'm not trying to get crama and if I were, it didn't work. I was just posting something for *discussion* on a *message board*. That's the purpose. &gt;spam by intention. No. &gt;you have no idea what to post here. &gt;[Posts must be related to PHP, even if indirectly.](https://www.reddit.com/r/PHP/wiki/index) 
[Symfony](https://symfony.com/) was modeled after Spring and [Doctrine](https://www.doctrine-project.org/) was modeled after Hibernate.
It's a Lambda, which is the name of Amazon's serverless offering.
A terrible one :D I just didn't like how long ReadOnlyRestrictedAssociativeArray was
Symfony (+ Doctrine as ORM + PhpUnit as UTing framework) + composer (packages manager). Additionally worth checking PhpStorm (or Idea Ultimate with PHP plugin) + Php Inspections (EA Extended) (faster PHP learning curve, assist avoiding major pitfalls) + PhpStan (to not mess up with types) + PHP CS Fixer (enforces code style). That'll be a good foundation for Java folks (I do both Java/PHP for quite awhile already).
&gt; Crappy code and baaaaad application setups is one thing, but people refusing to fix them or simply not even understanding the broader implications of bad applications or attempting SEO with gadgets while refusing to fix 3.5 MB-per-pagecall are just minor tidbits in a history of increasingly unnerving run-ins with knuckledragers in the "web agency" camp... I can relate to this so much. However, that's not really a fault of the language itself but it's users. It's just that the low entry barrier for PHP tends to attract these types.
Like others have said, you should take a look at the Symfony framework (+ doctrine). However, I also recommend you take a look at the Laravel framework. Both are excellent choices, but, in my opinion, Laravel is a little more "developer friendly" and has a more "fluent" API.
First, let me comment as to where I came across this idea: [https://www.reddit.com/r/programming/comments/90wu9x/rockstar\_a\_programming\_language\_where\_code\_is/](https://www.reddit.com/r/programming/comments/90wu9x/rockstar_a_programming_language_where_code_is/) A reddit post about a frivolous language that does frivolous things. Deep in the comments, I found this gem: [https://www.reddit.com/r/programming/comments/90wu9x/rockstar\_a\_programming\_language\_where\_code\_is/e2uh1m2](https://www.reddit.com/r/programming/comments/90wu9x/rockstar_a_programming_language_where_code_is/e2uh1m2) A very helpful user, /u/killerstorm \- outlined an interesting concept and provided some great material. His post was good enough, I'll quote it here: &gt;In Lisp LOOP it can be used to refer to the result of the test expression in a conditional clause, e.g. &gt; &gt;(loop for name in names when (sounds-good name) collect it)) &gt; &gt;There are also [anaphoric macros](https://en.wikipedia.org/wiki/Anaphoric_macro) which generalize this concept. &gt; &gt;In Kotlin default lambda argument name is it . So you can write e.g. &gt; &gt;names.forEach { scream(it) } &gt; &gt;There's also extension function also which you can use like this: &gt; &gt;somethingWithLongName.also{ kil(it) }.also{ fuck(it) } I had a look around, tried to understand the concept better. The best information I could find actually led me to even greater things. [https://www.sitepoint.com/php-macros-for-fun-and-profit/](https://www.sitepoint.com/php-macros-for-fun-and-profit/) This was an article, kind of a tutorial really, but it brought up something called yay, or .yphp, which can be used to achieve this. From what I understand, it is another type of preprocessing that allows you to create macros by going back through and parsing whatever you wrote back into PHP. Probably a few methods to automate the process a bit, but prevents macros from having to be added to the compiler. I am interested to know what others think, if they've ever used something similar, or what strong arguments for/against macros are. Personally, I think being able to use a term like 'it', might be very valuable and safe tons of lines of code. The sitepoint article I linked shows some good examples of times when code could be reduced considerably through the use of macros. Thanks in advance for any response!
I love the breadth of the opening talk (From Helpers to Middleware), and also the conciseness of the examples given.
I’ve recently moved from Symfony to Spring and I feel at home.
He put an asterisk by this and explains below.. TLDR not really 
Bloody hell that was good! I want examples of that middleware pipe stuff. Writing framework agnostic action classes seems like definitely the right way to go. How do I start doing it???
I find Laravel's API to be very _eloquent_... I'll see myself out...
&gt; I wonder what class-xxx file you're talking about? dude I just opened another random file only because you asked - `includes/class-updates.php` - there is html inside... just click 2-3 random files
True saw that later 
I do not miss WordPress one bit. I interviewed for a "Full Stack Dev" job, at they're like, how comfortable are you with WordPress and building custom plugins? I told them I'm no longer interested in the position. 
Symfony is kind of a mix of Spring and Rails. The app itself is very similar to Spring, while the console (specifically thinking of the generators) takes after Rails. Other than that, Symfony + Doctrine totally is Spring + Hibernate.
Check out preprocess.io for more examples of Yay macros, and how one can "automate" their use with Composer.
Wow, pretty impressive. I'm interested to learn more how the async works and could find some use for the trailing commas - haha, not that I prefer to write terrible code, but if you're not in a nice IDE and/or have a habit of adding Oxford commas everywhere (including in code), I can see that being rather useful. One less syntax error to stress over during design/development phase - although it could leave a rather nasty surprise for another developer down the line if they were ever to stop using Yay and then wonder why all your code is broken: something I'm sure which would be an issue regardless.
It's interesting, but I wouldn't touch it. Mainly because the IDE wouldn't know what's going on and I would lose a bunch of quality of life features. It's pretty much just proof of concept at the moment. Many of those things you can achieve with well made classes, or IDE snippets/macros.
Well, I would call it rather *writer-friendly*. Indeed it allows you to write faster. But on the long run it turns out that it's being *maintenance/expansion* friendly that makes a product truly developer friendly and in this regard Laravel is not that bright. You are supposed to ditch most of its bells and whistles in order to write a more supportable code... which will make it effectively Symfony
Try the symfony 4 video in the playlist (see channel page)
Not in this version. The lambda itself is exactly the same, which makes sense. With the circle around it, it's literally Half-Life's logo. 
Honestly, it's just noise that doesn't serve a purpose as such. I'm sure the PHP parser uses it to make it easier to parse code, but besides that, there's absolutely no reason to have `$` prefix variables other than that's how _it's always been_. Personally, I prefer to _not_ have it, but I don't really care about it - it's muscle memory when I write PHP.
In addition to what is discussed in the video, one standard to look out for is PSR-17, which brings standardized HTTP factories. The standard has not yet been accepted, but at the moment of writing this, it's going through acceptance voting at: https://groups.google.com/forum/#!topic/php-fig/M8PapGXXE1E With PSR-17, it will be even easier to write framework agnostic request handlers, as you can depend on the HTTP factory interface for creating PSR-7 responses and streams.
I realize that there might be people who use variable names that are also defined as a constant, but I've never seen any though. The BC break is of course a _deal breaker_.
Nice one. :D
Yeah, I see your point. I can't compare them "directly" because I don't have a lot of hands-on experience with Symfony (latest version). I could only give an opinion based on a single experience with an older version. However, like the article you shared (thanks, btw), Laravel can be a nice framework to work on and, like every other tool, if we're not careful, we end up having a hard time in the future, maintaining it. But that's not a problem of the tool, itself, but rather the developer's.
Better to md5 the file content, rather than the file name - that way you don't get collisions from several people uploading multiple copies of New Text File.txt or similar. And if you get collisions from the content, well - it's the same file, so why store several copies of it? Just make sure you keep a DB record with the original filename that refers back to the content hash, so you don't return a user's file with a random string name, or worse, someone else's filename with their content :)
Currently [Zend Expressive](https://docs.zendframework.com/zend-expressive/) is gaining momentum - it is a simpler and lighter version of Zend Framework that is based on *middlewares* approach instead of MVC.
You forgot to mention that ZF2 was release way after Symfony 2 (a mature and well engineered framework) with a huge community behind
Is ee. For both sized, I'd got with automated over manual changes.
Reasons being lack of maintenance, now you have to live with it. Don't expect the world to stay behind because of this.
I'm not disagreeing with you that to end up in this situation is pretty terrible and should be rectified asap, all I'm saying is that sometimes, for business reasons, the world doesn't conform to the ideal and compromises have to be made. We don't know the exact situation as to why OP can't upgrade but I can imagine plenty of situations where this might be true. Say it's some stand-alone box running some sort of production process - if the boss comes along and says something like - we have a choice between upgrading this system for $x,000 which just keeps us running, or I can invest the same $x,000 in *this new hardware* that increases our production by 10% and we can employ a new person as a result o we're going to do that are you going to stamp your little foot and insist that they upgrade the PHP box? 
I haven't copied manual or any other site. I only shared my knowledge as I have. so If you guys don't need this type of post, why are you demotivating me. anyways, from now you will not see my posts on this subreddit. Thanks to all
You don't need macros in a language that can just generate itself/eval itself and that generated code be added at runtime, like frameworks like Symfony/or Doctrine ORM do.
You can install packages globally and add $HOME/.composer/bin to $PATH.
You mean something like: **.bashrc** ``` export PATH="$PATH:$HOME/.composer/vendor/bin" ``` And to install a package globally: ``` composer global require phpunit/phpunit ```
Benefit of generation v eval: you can review generated code when something goes wrong (assuming it's not hot garbage).
I was using a global phpunit for a while, but as soon as you have projects requiring different non-compatible versions, it starts to become a serious mess. I'd recommend to never share across projects and always keep a single project dependencies altogether.
Yes, packages installed with `global require` in `$COMPOSER_HOME/vendor`. How to use them in a project which has also locally installed packages in `&lt;project_path&gt;/vendor` ? For example my `&lt;project_path&gt;/src/Main.php` uses psr-4 autoload by including `require_once __DIR__ . '/../vendor/autoload.php'` script generated by Composer. 
AFAIK Python's virtualenv, Ruby's bundler or Haskell's cabal allow mixing project's local with global packages. If there is a version conflict, local packages always take the precedence and satisfy all requirements by installing appropriate versions in project's root.
I don't think it is.
I don't have the time to check it out but I think there's no easy way to load an autoloader for global packages which means that only the 'libraries' that ship a binary could be used (from the PATH environment variable).
Also, this may be useful to some: The [Renato Mefi "RAD with Symfony"](https://www.youtube.com/watch?v=AQ8su8qIbV8&amp;list=PLPcgQFk9n9y-iZ0Ez_r9xYzQtT0iJ_MxA&amp;index=6) video from the [PHP fwdays'18](https://www.reddit.com/r/PHP/comments/9104x6/php_fwdays18_youtube_playlist/) post covers the similarities and differences of Spring and Symfony.
You ~~can't~~ shouldn't actually use globally installed packages in your projects, it's not portable and can cause lots of issues. The global composer is for installing utility programs, things like linters, code smell checks, UUID generators etc.
&gt;AFAIK Python's virtualenv, Ruby's bundler or Haskell's cabal allow mixing project's local with global packages. There is a massive difference though: unlike in those languages PHP flattens the dependencies. So if you have: - foo/pkg1 - bar/pkg2 And both depends on `baz/pakg3`, then you final dependency tree will be: - foo/pkg1 - bar/pkg2 - baz/pkg3 -&gt; compatible with the two above In nodejs for example, your dependency tree would be (unless you explicitly ask to flatten it): - foo/pkg1 \- baz/pkg3 -&gt; compatible with foo/pkg1 - bar/pkg2 \- baz/pkg3 -&gt; compatible with bar/pkg2 Back to your original question, it would be possible with https://github.com/wikimedia/composer-merge-plugin, but I don't think it's a good idea tbh unless you are managing one monolithic project (but then I would keep the root at the project root, not your machine home)
Yeah, the best workaround that I know of is specifying the `bin-dir` in your composer.json schema. Like... "config": { "bin-dir": "bin" } which will symlink binaries, phpunit included, where you can run it from `bin/phpunit` instead of `vendor/bin/phpunit`
I can confirm that; we used it for some small functions but it would crash a lot without any proper logging and we had to contact the support a lot. In the end we decided to switch to a different language instead which works without issues.
Although I don't agree on 2, with 1 your certainly have a good point.
I understand that. If you are aware that your array contains `false` values you can always ensure that the array is not empty using `empty`. I'd rather do that than have to `$tmp = array_expression; reset($tmp);` every single time. PHP does not and probably will not have an optional type anytime soon. We cannot solve this problem in the short run.
Write your own package to solve an issue and release it to public to benefit others? :)
&gt; Just because we’ve made mistakes with other array functions doesn’t mean it’s okay to continue doing it. Yeah but what's the alternative? Not offer any functions in the future that return `mixed` and possibly `null`? PHP does not and probably will not have an optional type anytime soon. The alternative is to use `reset` which: 1. Takes a reference which makes it impossible to use expressions 2. Returns `false` which cannot be differentiated from values At least with that function we could solve one of those problems.
Massive data processing. Social, RSS, Excel sheets, many different data sources all manipulated together into a reporting system. What PHP will let you do it's incredible but at the same time one of its biggest problems. 
Hello! I am coding my blog in PHP as many developers recommended me to do. It's awesome as I've implemented the CRUD operation. Any idea of what I can implement? Thanks.
Building automation for majority of an ISPs systems
I sometimes use it as a shell scripting language #!/usr/bin/php
`C.R.U.D.` and some arithmetic. I don't have exciting clients.
It's a good editor. I just switched over from Atom after hopping around for a few years since Komodo became crap. I'll probably stick with it.
If you are a sick, sick, depraved creature you could do some machine learning projects using php [https://php-ml.readthedocs.io/en/latest/](https://php-ml.readthedocs.io/en/latest/)
I decode and display large amounts of weather data.
[https://www.phptherightway.com/](https://www.phptherightway.com/)
I recommend checking [laracasts.com](https://laracasts.com), if you like video lessons. Although is related to the Laravel community, there's lots of general PHP/Web Development videos there.
Thanks for the constructive answer. As described above, it really should not matter and requirements for `baz/pkg3` can be satisfied with install of more suitable version then the non-project(global) one. Handling this on local level only makes no difference here. If this logic is not (yet) implemented in Composer is another problem. Definitely taking a look at `composer-merge-plugin`. Thanks for the pointer. 
Same thing I do every night. Try to take over the World.
I've played with code golf and various math stuff: * [https://projecteuler.net/](https://projecteuler.net/) (at a certain point I gave up and started using python) * [https://code-golf.io](https://code-golf.io) (plenty of places where you can get inspiration) * [https://codegolf.stackexchange.com/](https://codegolf.stackexchange.com/) Here are some of mine: The shortest script I found that can be made with PHP to produce infinite output is 9 characters long (the output is: undefined constant i with the appropriate php configs): for(;;i); // as in: php -r "for(;;i);" Or the classic FizzBuzz (56 chars, 5 for the newline at the end :-) ), again, with appropriate configurations. for(;$i&lt;100;)echo++$i%3?!$$i=$i:Fizz,$i%5?$$i:Buzz,"\n";
Does exist a tutorial that teaches how to start developing packages, their format and styles and where to find issues to solve?
Docker solved such a headaches.
The alternative is undecided. That’s why the RFC was denied. It doesn’t mean these functions will never exist, it just means that they’re not going to right now.
Sending command via telnet and SSH, specifically TL1 and network equipment such as Cisco for network troubleshooting automation
I think it should have, but I never go and search for one. I just mimic some popular package and learn from there.
Wrote a regression library and will do a decision tree library once I have the time and energy. Oh, I'm not sick, but I'm not well.
I swear that about 80% of web apps are just lipstick in front of a database.
The most interesting application i've found myself using PHP for is a deployable executable Phar archives to servers to manage SSL certificates. Phar archives are surprisingly lightweight and can be put into provisioning systems without much overhead. 
Why is that a problem?
Narf !!
Because a lot of people don't know how to use it efficiently and thus you end up wiht a lot of messy / unmanagable code. 
That's true, but is that the fault of the language itself, or the fault of people being inexperienced? I'd argue it's the latter.
I wrote [Game Courier](http://play.chessvariants.com/pbm/), a game server for playing Chess variants through online correspondence, which includes its own Turing-complete programming language that visitors to my site can safely use for programming game rules or automating game behavior without being able to hack the site with it.
[Analysing PHP](https://github.com/vimeo/psalm). There are other systems for analysing PHP implemented in [Java](https://www.jetbrains.com/phpstorm) and [OCaml](https://hacklang.org/), but using PHP makes everything a bit nicer, and it's a great way to dogfood. 
Making a text-based multiplayer strategy game played in the browser! 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
For cross-system path differences: ``` #!/usr/bin/env php ```
I don't want to downplay the the importance of design and UX but you're right. But that really shouldn't be surprising. Unless you're inventing something computer science-y it's mostly about moving data around. That doesn't mean it's easy though. The details are what kill you. When I think about some of my company's biggest clients they can be boiled down to moving data. But they also span across multiple systems, load balancing, work queues, performance, security, and a bunch of things to consider. When it's all done though - we moved those bits from other to here or from there to over there.
\&gt; **What do you do with PHP** ? I personally eat it! 
Maybe, but don’t forget that there is no natural beauty in databases, that’s why the lipstick is so important with this one 
Maybe, but don’t forget that there is no natural beauty in databases, that’s why the lipstick is so important with this one
Vagrant with Laravel homestead keeps your mac clutter free. 
It's just a good editor. It's got a ton of uses, a growing feature set, and a lot of support. 
CakePHP? 
I can't recommend YouTube videos enough! Free, and there are tons of people out there that have put things together on PHP (or any language really) - ranging from the very basics to high-level concepts. There's a lot of variety in content creators as well, so you can find lots of explanations of the same concepts to help solidify them. 
Print pdf rendering! 😬
someone built a nuclear [reactor](https://reactphp.org/)
a lot, from crm to platform connectors
I used that along with Tesseract to write a letter classifier.
Oh, it's hugely important and I do not doubt for a second its utility. I've seen too many cases where simply giving people structured access to a database to centralize information and then report on it creates tremendous value over how things were before. It's just a bit surprising and dismaying when you reduce it down and realize how little is actually going on.
does not work when you declare a namespace in that script
There ought to be free resources out there to learn the basics, like syntax. What really took me a step further, was taking an open source project and trying to rebuild a smaller version of it, using it as a guide. I took an in-house CMS, that the company I was working for had built, and tried building my own. I learned an amazing amount just digging through that code and learning how/why it worked. That's not to say that I learned the best practices there, but I did learn a lot about PHP.
There is also a lot of noise and bad practices in those videos. The amount is overwhelming imo for a beginner developer. Although do invest in something like Udemy or Skillshare, which has a better selection. Free not always means good.
A curated list of resources for [PHP](https://odan.github.io/learn-php/)
If you already know JS, why not to try node.js? Will be much faster to bootstrap yourself with a familiar syntax and functionality. As for PHP - php.net is the manual which you should keep close. https://www.phptherightway.com/ is something to tackle after you got acquainted with the language to follow best practices (it's worth it! Will save you the effort in the future). Visit a local usergroup for inspiration too if you're into that sort of thing. But most importantly - just build something and tinker with open source projects! 
Have you done any benchmark for any of the macros? Are they good enough to use in production, or are they just in experimental phase? 
This is a fun library to use with an IRC bot and unsuspecting users in an IRC Channel. =P
Lately it's turning database rows into JSON or HTML 1.0 so it can be transformed into a slick UI with javascript. Some image modifying, data processing and massaging, and command line type scripts. Get a good MVC with CRUD generator, doesn't get much more complicated than that.
What are we doing tonight brain?
I just run it as: &gt; php script.php
For somebody relatively new to programming, what does this mean? I'm somewhat familiar with bash and PHP, it looks like you're done invoking then both?
/u/agiletoolkit I recommend this much more complete guide: https://getgrav.org/blog/macos-sierra-apache-multiple-php-versions This is the setup I decided on for my work laptop.
Took me a minute to figure out why `!` but I eventually got the fizzbuzz script. Personally, I'm amused that you can't have `$2` but you can have a variable named 2 if you use `$$i` when `$i` is 2
I love writing scripts to analyze things for my own benefit. For instance making my own linters and code refactor tools.
I wrote a tool to [manage my finances](https://github.com/firefly-iii/firefly-iii). To my surprise and delight, others use it too!
What are you using?
You can start by taking the IKM assessment (as an evaluation trial or something). That will give you a good idea of what to brush up on for legacy code support. It's not as relevant for php 7.x. What you really need to know are array functions, the pdo library, and the object model, especially how the magic methods behave, and what you need to do with them for patterns like singleton. That seems like a lot, but if you are familiar with java or c++ it won't be too bad for you.
How hard would it be for an american php developer to find work in Germany?
There are paid resources definitely worth paying for if you’re serious about learning. But Udemy puts lots of their videos on YouTube! Thankfully there are many knowledgeable people that find free education to be an investment in our collective future and are willing to provide quality (Khan Academy, Codecademy, for example). You should find instructors with lots of different perspectives to learn thoroughly, and use the official documentation when you’re skilled enough to understand them, but documentation can be overwhelming for a beginner as well. You can typically find which videos are better than others with a bit of effort looking at channel quality, using recommendations from your peers, view count and comment quality. For context - I learned to code in college, and when I finished I ended up with a productive but outdated skillset. YouTube, online sources like blogs and StackOverflow, and official documentation took me much farther than my formal education did, because I had access to many more perspectives from many more teachers, and I wasn’t limited by what I could pay for. Nearly anything you want to learn regarding programming can be found online, even official university course materials in some cases. 
Open-source projects for living and meeting all PHP devs around the world
You can do ${2} or ${'2'} to get past interpreter limits :-) But nobody uses it, thank god
Non-global, project-specific dependencies also make sharing with a development team easier. Otherwise you have to either instruct devs to update their global dependencies or write a solution to automate it (which is just wasted time unless you have some very specific use cases).
TL;DR
While tools like Vagrant and Docker are exceptional, sometimes you just want to spool up a test project or some other quick development without needing to copy configs or wait for the VM to load. I have a local Nginx + PHP + MySQL install for exactly that. Combined with Dnsmasq, a new folder automatically becomes a \`folder.localhost\` project. No configs, VMs, or anything else needed, and very fast. Perfect for tinkering or getting started quickly.
Not if you want to stay Slim!
I once built a gui for laravel dusk to easily set up tests as an intern 
API-- it is literally the most simple and least involved way to receive a request with some starting data (URL, headers[cookies, JWT], body[forms]) and crank out JSON or XML or whatever... The newest thing to me that aren't new at all is making a code generator. Think about it-- your entire app uses the same bits of information in the DB, the base objects, the api endpoints, and the front end UI. Create an omnipotent starting object and build all those things from that starting JSON object. Name, type, length, comments explaining what it is, required validations-- it won't 100% build your app; but, if it works I expect it to get me 80-90% of the way.
I also like Valet / Valet+ to set up my dev environment.
I'm building an event sourced application that implements CQRS. The Prooph framework is pretty cool.
It's a [shebang](https://en.wikipedia.org/wiki/Shebang_\(Unix\)). On *nix systems it lets a file define what to use to 'execute' the file so that something like `./some.php` can be run directly. As a rule a programming language interpreters will assume that the first line in a file may be a shebang line and will work with it correctly even if something like a shebang would otherwise be a syntax error (Ex: lua will allow a first-line shebang even though it's not formatted like valid lua) or have some effect (Ex: PHP will ignore a shebang line instead of doing what PHP usually does outside of a `&lt;?php` block and outputting it.)
**Shebang (Unix)** In computing, a shebang is the character sequence consisting of the characters number sign and exclamation mark (#!) at the beginning of a script. It is also called sha-bang, hashbang, pound-bang, or hash-pling. In Unix-like operating systems, when a text file with a shebang is used as if it is an executable, the program loader parses the rest of the file's initial line as an interpreter directive; the specified interpreter program is executed, passing to it as an argument the path that was initially used when attempting to run the script, so that the program may use the file as input data. For example, if a script is named with the path path/to/script, and it starts with the following line, #!/bin/sh, then the program loader is instructed to run the program /bin/sh, passing path/to/script as the first argument. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
That's Faker News right there...
shebangs, shebangs, oh baby
I mostly use it to transport data to and from a database from a web front-end.
Yeah me too. Got all my cron jobs in php. 
Exactly what I do. 
We are using it at our small company as an ERP and we handle like 150k clients and something like millions in € :o The codebase is old ! like 10 years old !
Give Zend Expressive or Slim a go: the middleware stuff you write makes things very portable and minimal. And keep the tips from the talk in mind while writing new code where you'd be tempted to just slam in a helper :-)
If never heard of the fizz buzz question. That was interesting reading. 
Using Docker for local development but with the ease of Valet+, I can recommend Docksal: [https://docksal.io/](https://docksal.io/) and [https://github.com/docksal/docksal](https://github.com/docksal/docksal)
This year I've kind of fallen in love with JSON. it's just such a beautiful way of storing data. 
Huh. So if I'm understanding that right, it let's you call the PHP scripts directly rather than "PHP foobar.php"?
\&gt; When you sign up you'll get offers relevant to you, exclusive discounts on our hottest titles, and learning edge free content. So it's not free, it's sold for the low price of yourself.
Exactly. I was also looking for quick and simple guide and couldn't find anything, thought I would share. 
I know about Docker and Laravel but I'm not using them for web development.
I've seen this one, but it looked too long and too complex.
There are a number of things which fall under "is anyone REALLY doing that???". The surprisingly frequent answer to that is "yeah", so the decision comes down to "Will we break too many weirdos to justify the benefit?"
Thanks you for your helpful comments everyone you’ve given me a lot to muddle through but hopefully I’ll find something that allows me to learn it the way my brain likes best!
But docker is hella slow
i am working on Laravel E commerce too. [https://github.com/avored/laravel-ecommerce](https://github.com/avored/laravel-ecommerce)
Silly questions. I have many. I'm an experienced Java dev who hasn't touched PHP since shortly after 5.0 or something silly. Namespaces were still a twinkle in the eye and register_globals was something you hoped the webhost turned off. Anyway I'm back and I picked up a site that's almost as long in the tooth. So my Java head has questions: 1. How do you structure your projects: a) On the server. Does everything live inside www/? Is it just config outside? Is everything outside except an index file? b) In the project. Do you have a src folder and a test folder? 2. What's your deployment strategy? Do you have a release process than takes your srcs and produces a zip? Presumably you do so you don't deploy test cases? 3. How do you test? PHPUnit for unit tests seems to be the vogue. But what about end-to-end tests? Docker? Reason I ask this is currently I don't have a clear separation between layers so I'm likely to have to rely on end-to-end tests to start with, then I can deconstruct and fix. I might have some more once I've tamed the Octavo of code - maybe next week ;) 
They see a lot of old PHP code that looks like this: $page_title = mysqli_fetch_array(mysql_query("SELECT title from b WHERE id = $_REQUEST['pid']"))[0]; echo "&lt;h1&gt;".stripslashes($page_title)&lt;/h1&gt;";
I use a dedicated box with cpanel :)
Thanks.
Indeed
Jealously will get you nowhere :)
Docker volume sharing on OSX is super slow, but otherwise is a pretty minimal performance hit. 
This is the correct answer to this thread. Not only is it clean, and explains where everything lives, they regularly update the article.
Sticking my head into the lion's mouth here... but I really don't like the middleware pattern, or any pattern, which relies on using arbitrary strings for passing objects between requests, or in this case the wrapper. Loading a particular type of object by using $container-&gt;get(SomeInterface::class) I can get behind because the output type is easily inferred from from the input, but arbitrary strings, eugh! So what's the best way to document these strings, so that our code analysers can run on them correctly? Is there a way. 
Boo! Serverless depends on a server! There is heroku already doing such things they call 'serverless'. 
My first suggestion is to not disclose the results of the voting until it's closed. You'll get a lot of flame for that. 
Physical voting is way more secure than electronic
Homebrew’s handling of older versions of PHP and Python make me want to set my MacBook on fire.
I love PHP and MySQL, but no. This would be cool for something small, but for government type systems, no way.
I was in your boat eight years ago. I was sick and bored the other weekend so wrote a [retrospective on my blog](http://cliffordvickrey.com/bloog/advice-to-new-php-developers.html) about learning PHP. My post is not particularly well-structured or written, but contains some thoughts on the language, the experience of having to learn it quickly and without any CS background to speak of, as well as how much it has changed since. If it helps/is missing some obvious advice, please let me know!
&gt; .. but I'm not using them for web development You probably should, considering how complicated this brew install looks. One docker command would have you up and running.
Their speed depends on the generated code, but all of them run through opcache in prod so there's very little difference between them and vanilla PHP code.
Can you expand a bit on it? More specifically drill down how you connect, configs and other stuffs?
Some good suggestions here, but in my experience, start with something you want to build or a problem you’re trying to solve using php, then get coding using a tutorial or some reference that is similar to your project. 
PHPStorm, just that.
Welcome back! As far as 1b, see &lt;https://github.com/php-pds/skeleton&gt;.
quite a different，for example，it can easily get the nth regex match in-place and store in arrays.
Require it as a component of your project. Make it a dev required package that determines if it’s loaded based on your .env file. If your project needs it our a specific version then you need to make sure it’s addressed in the composer.json. I ran into this a couple years ago in a project and it made my dev life way better.
Where do you store your files? You should be storing then in your personal user folder as an example, so not in the file system of WSL. Then you navigate to that folder via /mnt/c/... 
I use this combo and then i make changes to my source files, there's only one, not three. So phpstorm commits but won't push? Unfortunately i haven't had that problem Add some more information and maybe we can get to the bottom of it
My project is on /d/mnt/Projects/
Why would you create a `composer.json` in the name of Jordi Boggiano when you are not Jordi Boggiano? Perhaps use your own name in the example?
The next natural step is to link two entities three different ways: OneToOne, OneToMany, ManyToMany.
1) Follow the framework best practices and coding style 2) We git merge, the CI kicks in and deploy everything. I like jenkins. 3) PHPUnit for both unit and functional tests but clearly separated. For e2e tests, you can use Behat. It's really good.
Best thing to do is use class constants when you're passing data down/up layers. The class which creates the variables/objects should have a class constant e.g. `ThingCreatorMiddleware::FOO` and each middleware which uses that will then use that constant. This also helps to indicate where to look for object instantiation.
This is unfortunately also one of the reasons that a language develops as slowly as they do, when they are as old as PHP, save for a few like snowflakes. I wish someone would make a PHP version that would improve all these things with BC break being acceptable, but that'd be too much work to maintain two parallel versions.
Maybe it‘s a bug, or the developer messed up. But I think it‘s the 2nd.
See https://github.com/paragonie/random_compat/releases/tag/v9.99.99. 
What are the differences between the git status/git diff commands between the three environments? I'm guessing that each one has its own global git config, and will be looking at different line endings, filemode, etc... What error are you getting with Storm when you ask it to push? I use wamp64 for running a local environment, storm for editing on it, and WSL for git commands etc.
It's in the README, here: ``` #### Version 9.99.99 **Note**: There is a special version called 9.99.99 which makes this library do nothing, but is only installable on PHP 7. If you're writing software (e.g. a library) that supports PHP 5, but may be used by software that doesn't, you'll want to allow 9.99.99 to be installed. The above diff is what you want. Conversely, if you're writing software that (in and of itself) supports PHP 5, you do not want 9.99.99 to be installed, so you'll want to make this change instead: "require" { ... - "paragonie/random\_compat": "\~1.1", + "paragonie/random\_compat": "&gt;=1 &lt;9.99", ... } ``` [https://github.com/paragonie/random\_compat#version-99999](https://github.com/paragonie/random_compat#version-99999)
Thanks. I’ll try and pick a framework then follow that :) Will see if Jenkins is practical and look at Behat too :)
Thanks that’s really helpful
What's the use case for that, exactly? I'm with Robberviet on this one, PHPStorm or any other decent IDE (with or without plugins) over a text editor with plugins any day.
I would disagree with that, a properly designed database is definitely a thing of beauty :)
Lol, you're right :D
Turns out, neither.
What was it then?
[Middleware-based architectures](https://www.youtube.com/watch?v=64TH94pclyU)
I've now been playing around with zend expressive and I love it. Prefer it to laravel magic. Seems to be a small amount of code. Also, I never write helpers :) 
 &gt; So what's the best way to document these strings, so that our code analysers can run on them correctly? Is there a way. What strings are we talking about, specifically? The pipeline is a complete constructed object graph with some lazy instances somewhere (depending on implementation - see around 27:33). The final slides are meta-code that is just functions (FQNs can be used), and the language is not PHP. The most annoying part of PSR-7 IMO is`ServerRequest#(with|get)Attribute()`, which is a way to convey additional information (routing, authentication, etc) in a request passing through the pipe. I use class names for the attribute names too, but that's indeed a squishy part of the API that isn't really a solved problem yet, since you have no type safety in something like this: ``` response = makeRequest |&gt; authenticate |&gt; onlyCoyotes |&gt; doSomething ``` Ideally, we'd need to be more and more specific on the types, but I don't know of languages allowing to do this elegantly without breaking LSP (if LSP is even relevant at this point, or if the pipe should be phased out completely): * `makeRequest :: Request` * `authenticate :: Request -&gt; Either FailedAuthenticationResponse AuthenticatedRequest` * `onlyCoyotes :: AuthenticatedRequest -&gt; Either FailedAuthorisationResponse AuthorisedRequest` * `doSomething :: AuthorisedRequest -&gt; Either FailureResponse ResultResponse` The current workaround that I know of to work with getters/setters with mixed types (urgh) in a relatively static-analysis-friendly-way is to have: * a `.phpstorm.meta.php` (https://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Advanced+Metadata) * a PHPStan plugin to infer parameter and return types in a pipe like the above (I currently use those plugins just for `get|with` `mixed` methods) - see https://github.com/phpstan/phpstan-phpunit/blob/6feecc7faae187daa6be44140cd0f1ba210e6aa0/src/Type/PHPUnit/CreateMockDynamicReturnTypeExtension.php, for example.
https://www.reddit.com/r/PHP/comments/91ffbi/package_in_v99999_is_this_normal/e2xmpta/
I hope you do not need real life examples of companies which enforce a coding style with this: &gt;The intent of this guide is to reduce cognitive friction when scanning code from different authors. It does so by enumerating a shared set of rules and expectations about how to format PHP code. From: [https://www.php-fig.org/psr/psr-2/](https://www.php-fig.org/psr/psr-2/) But of course every "bigger" company does not allow different styles of code formatting. But it doesn't need to be PSR of course...
Do not forget psalm 
That's only your development environment. I assume you use PHP7 (as stated) and not use bloated Symfony versions (Symfony got better at this now). Even if it's 2-3x times slower (I mean the I/O sharing speed), does it make any difference?
Does your colleague or team use *any* standard at all? This may not be official or written down, but there's usually *something* shared by everyone in a project. are variables all `camelCase` / `snake_case`? all control structures laid out similarly? When starting a brand new project it's useful to pick from existing standards and use them. For an existing project, it's a good idea to stick with whatever's being done already. Of course, your team might actually be creative geniuses who try something different in every source file, in which case by all means use PSR! Noone will notice.
I try to follow and enforce PSR-2 as much as possible. I've found that when you get larger teams, styling conflicts come up and what some people prefer is hard to read for other people. You can have the team come to a consensus, but it can take a while to agree and adopt. And in the mean time you get a lot of comments in code review about styling. **Or**, you can enforce a code style that no-one fully agrees with, but it's backed by tools that tell you when you're wrong and help you fix it. In these cases, it doesn't matter what style guide you follow, so long as you have one. People may not like PSR-6 for caching, but we use Symfony and Symfony uses it, so we use it. And in the end it does make it easier if we want to move away from Symfony and drop in a different caching system. I'm personally a huge fan of PSR-7. If you want to make your code less dependant on a Framework, and more easily able to slowly move to a better structure, I find PSR-7 is pretty invaluable. It means if you ever want to migrate you don't need to rewrite all of your controllers. As long as you've got PSR-7 controllers and you're using Dependency Injection. Speaking of which, type-hinting against PSR-11 means that you don't need to worry about trying to move away from `x` framework and find out everything that expects a container breaks (For us it was our factories). So yes, I like to follow PSR's. Not because any specific PSR is wonderful and perfect, but because I think the benefits it brings in code portability and team management are very useful
&gt;and not use bloated Symfony versions (Symfony got better at this now) It's a side not but Symfony has never been "bloated", at least not more than a regular framework (and you could always trim it down). Unless you are refering to micro frameworks, but those are not really interesting as in the end they provide absolutely nothing and as soon as you start having a regular size application you realise you either need more feature or you installed them via components, which is what more "bloated" frameworks already provides. But more importantly, unless you have a very small application, the biggest part of most applications is the application itself not the framework so which framework it is matters little. &gt;Even if it's 2-3x times slower (I mean the I/O sharing speed), does it make any difference? On linux or locally our whole test suite for a project takes 5min (unit tests, light integration tests, heavy integration tests + e2e tests). On docker with shared volume it takes 25min (the bottleneck is the project size, making the IO even slower than it should and because of the amount of files caching is impossible otherwise you always end up with out of sync files)
Hey, tfidry, just a quick heads-up: **refering** is actually spelled **referring**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
yeah, well that's the catch right
Hey, Mr. Bot! While this word should indeed have **two r's**, you conveniently forget about all the words that should only have **one r**, such as `coverer`, `terebic`, `uttered`, `bereft` and `erect`, to name a few. If you tell people to always remember **two r's**, they may well use two r's for the above words as well, despite that being blatantly wrong. The bot above likes to give structurally useless spelling advice, and it's my job to stop that from happening. [Read more here.](/8y3us6) --- ^^^I ^^^am ^^^a ^^^bot, ^^^and ^^^I ^^^make ^^^mistakes ^^^too. ^^^Please ^^^PM ^^^me ^^^with ^^^feedback! ^^^| ^^^ID: ^^^e2xp4v0.5833
Style guides, including PSR1/2, are arbitrary by their nature. You say you're using CodeIgniter - good luck making that fit PSR-2 (hint, controller method names cannot be camelcased, and in CI2, I believe the class names need to be lowercase), and you don't really want lots\_of\_underscores\_in\_your\_url, do you? My view, is that providing everyone in a company follows the same or similar style, it doesn't actually matter what that style is, because its arbitrary, but the cognitive load is reduced by the codebase all being written in the same way.
Yes - Although it can be difficult to get colleagues to follow suit. For me, PSR is a guide which is already there, so it saves my team and I's need to create our own. Even if people prefer to write in a certain way. Running php-cs-fixer before you commit solves the issues for everyone.
Fix the content hiding behind the nav?
If you mean the code style guidelines, then who cares, just pick a style, and use a tool to automatically format your source files. It doesn't matter what style you use as long as you're consistent.
&gt;It can be used in PHPStorm or any other IDE on Windows OS, like eclipse, Visual Studio, Android Studio, etc. Not just the text editors. You can use its commands to batch extract data, batch generate code in your IDE. Or use some features of ConyEdit that is not support well by the IDE. It just make the IDE stronger. For the extracted contents in the arrays, you can use them when you want, for example, generating code, batch replacement.
Well you can use regex replace in PHPStorm, and most other IDE's https://www.jetbrains.com/help/phpstorm/tutorial-finding-and-replacing-text-using-regular-expressions.html
It can be used in PHPStorm or any other IDE on Windows OS, like eclipse, Visual Studio, Android Studio, etc. Not just the text editors. You can use its commands to batch extract data, batch generate code in your IDE. Or use some features of ConyEdit that is not support well by the IDE. It just make the IDE stronger. For the extracted contents in the arrays, you can use them when you want, for example, generating code, batch replacement.
I think one of the most important things of doing a benchmark blogpost is to actually explain what is happening behind the screens. Oh and I'm quite sure that opcache removes comments but there's no mention of that in the Katy Perry test. You should try to benchmark it with opcache enabled.
Noooo, not again! Why this kind of idiotic articles appear with such regularity? Why on the Earth anyone would do such tests which are wither essentially pointless or make no sense at all? Why a person who have no idea how to run a performance test, what a profiling is, knowing no PHP internals would would have an idea to run such s test? I wouldn't take such topic as single vs double quotes, it has been discussed enough during last week, but why on the Earth one would like to know know how expensive some language feature is related to not using it at all? What kind of imbecile one needs to be to measure such kind of things? 
Using the claims as headings can perpetuate the possibly false claims, because a portion of readers will just skim the article. Perhaps phrase them as a question instead?
Yeah, I'm not installing a closed source exe, with no real documentation, that I have to pay for, from some no-name pair of developers with no real history of releases found on a 10-minute bootstrap site that still has the placeholder text in the footer. Too many 'Hey, this could be malware' boxes ticked for me...
Thanks will update the article
well, get the nth regex match of each line of the text and store them in a one-dim array? get all the regex matches of each line of the text and store them in a two-dim array for subsequent reference? replace strings that match the regex pattern with the contents from the arrays? replace the nth regex match of each line with the contents from the arrays? I think most IDE's regex can't do that. For the contents in the arrays, you can use thousands of times if you want. Especially for the business table fields, it may be be referred for many times. Just load them to arrays, naming, use it when you want.
Please don't post blogspam here.
&gt; Native array functions are faster than loops Define the native case's anonymous function as a static method (or put it in a global variable if you're not in a class context), the result should be much faster than redefining the function over and over...
Did you double check that you didn't load xdebug when running those tests? I was curious about the single quote vs. double quote test since I've heard that single quotes *are not* faster in PHP anymore, so I ran a quick test myself. My bench: &lt;?php class QuoteConsumerBench { public function benchSingleQuoteConsume() { $var1 = 'Hello World'; $var2 = $var1 . '!'; } public function benchDoubleQuoteConsume() { $var1 = "Hello World"; $var2 = "$var1!"; } } My command: ../vendor/bin/phpbench run QuoteConsumerBench.php --report='generator: "table"' --revs=1000000 My Output: +--------------------+-------------------------+-----+--------+--------+---------+-----+----------+---------+---------+---------+---------+---------+--------+-------+ | benchmark | subject | tag | groups | params | revs | its | mem_peak | best | mean | mode | worst | stdev | rstdev | diff | +--------------------+-------------------------+-----+--------+--------+---------+-----+----------+---------+---------+---------+---------+---------+--------+-------+ | QuoteConsumerBench | benchSingleQuoteConsume | | | [] | 1000000 | 1 | 459,568b | 0.048μs | 0.048μs | 0.048μs | 0.048μs | 0.000μs | 0.00% | 1.02x | | QuoteConsumerBench | benchDoubleQuoteConsume | | | [] | 1000000 | 1 | 459,568b | 0.048μs | 0.048μs | 0.048μs | 0.048μs | 0.000μs | 0.00% | 1.00x | +--------------------+-------------------------+-----+--------+--------+---------+-----+----------+---------+---------+---------+---------+---------+--------+-------+ I did notice the ~5% slowdown for single quote **when I had xdebug loaded**. Not necessarily enabled, but loaded
try `/mnt/d/` then ?
There are several things that went wrong in your environment. "we use Docker only for the databases.." - That doesn't sound quite right. DB's are the worst candidate for Docker. "PHP/nodejs which are heavily used and more IO bound" - depends what you do. The common use case make it CPU bound, instead of IO bound. "On docker with shared volume it takes 25min" - Simply don't use shared volumes outside of your local development environment. You can seal the content inside and ship it to testing, staging and production. Using shared volumes elsewhere is asking for trouble. I am not sure if you understood my point. My point is that you can use Docker on your local development environment to simplify things. You're not forced to use Docker on testing, staging, production. That's actually my workflow. I am not ready for Docker on production, but I can't imaging living without it on local. I can give my complex project to new dev and he can start all the dependencies (MySQL, Apache2 (SSL, Vhosts etc.) PHP7.2, KV Store, ElasticSearch, SQS, SNS and S3 replacements) in one command and 15 min initial build time. 
&gt;Yeah, I'm not installing a closed source exe, with no real documentation, that I have to pay for, from some no-name pair of developers with no real history of releases found on a 10-minute bootstrap site that still has the placeholder text in the footer. &gt; &gt;Too many 'Hey, this could be malware' boxes ticked for me... Yes, you are right. As far as I know, it is a new product from a new company. It may need some time to improve. 
&gt; Simply don't use shared volumes outside of your local development environment We don't. &gt;"PHP/nodejs which are heavily used and more IO bound" - depends what you do Yes I mean in our usage, not the languages in general. So I think there was some misunderstanding there :)
Aren't you a ray of sunshine?
Ignore the haters. I love posts that show performance results.
I just checked and indeed xdebug is loaded but not enabled.
Thanks
I'd be interested to see if any of these results change if you rerun them with xdebug unloaded. I was hoping to run them myself to check, but it doesn't appear that you've published your benches.
 I liked this one: $row\[’id’\] is 7 times faster than $row\[id\] ? Mainly because the latter has been throwing warnings for a while now, and is being fully deprecated either in 7.3 or 7.4, so the point is moot - don't use a non-quoted string if you're actually after a string value. Additionally, we (should) all know about premature optimisation, which as far as I can tell, is what most of those statements come under. The chances of anyone noticing those nanoseconds is pretty slim.
I overwrote each tests as soon as I wrote it. I kinda have it published on the blog ;). That said , I will look into it when I get home. Thanks for pointing it out.
Spoiler: Neither is better, it comes down to what you're trying to achieve, and the cost/availability of knowledge for the languages and platforms in question.
this kind of article has nothing to do with real performance. 
He's right though. This article is pointless. It's a buch of micro-optimisations that will make a \*tiny\* difference to your app's performance. Making any of the changes in it are essentially time wasted, compared to finding and fixing the actual performance bottlenecks.
&gt; Personally I will always prefer the maintainability over the speed. &gt; Speed is just one part of software development, and I personally think marginal gains don’t out weight good developer practices. Thank God, I thought this article was going to try and convince me that saving half a millisecond every request was worth wasting an hour every time I come to edit something. &gt; Turns out that in this test the array_map method is slower than the foreach. This probablly has something to do with the anonymous class. I've been arguing with people about this for ages! Good to have a blog post written by someone else. The best performance trick I've found it thinking carefully about what you want a piece of code to do, do some planning and then build is as simply as possible.
Follow what CI is doing. PSR is good for your own project or any modern projects but not CI. CI was there before PHP 5 so the old coding style still sticks. Follow what your framework is doing, like underscore case the classes or slug the methods. It's annoying but it's more annoying to mix PSR into it.
&gt; The most annoying part of PSR-7 IMO isServerRequest#(with|get)Attribute(), which is a way to convey additional information (routing, authentication, etc) in a request passing through the pipe. I use class names for the attribute names too, but that's indeed a squishy part of the API that isn't really a solved problem yet, since you have no type safety in something like this: This is the bit which bugs me as well. I'm really not happy with just shoving all of the attributes into an associative array. Not having that type information there really bugs me. Personally, I (prepare your pitchforks), use long inheritance chains because it enables bi-directional communication up and down the chain, as well as static type information. Until there's a reliable method for doing this with a middleware pattern, I think it's an unfinished design. What would it take to accomplish this? I'm not 100% but I would think at the very least a formal way of attaching a value-returning event subscriber to every middleware instance prior to starting the actual chain.
Excellent article, except the first test on quotes. You have them arse about head
This, along with "single vs. double", is a trademark case for a ~~bad~~ harmful article. Of course there is no such thing like using a string without quotes in the first place, as it's an apparent error. Why test a deliberately erroneous code? And of course all those amateur testers consider `$var[key]` for some reason the only case for such a behavior, considering `key` a somewhat integral part of the expression. Which indicates that they don't even have a clear idea what an array key is and how to tell one from a string literal. I reported this link to the mods with under "does a considerable harm to the community" reason.
I would suggest https://exercism.io/my/tracks/php You will get a hands-on knowledge in PHP. I would recommend doing the exercises yourself, just by referring the official API docs http://www.php.net (no StackOverflow-ing). Later when you start feeling confident, definitely read https://www.phptherightway.com. Perhaps, you could also purchase a book for learning the internals in PHP.
If you want to make a business of something, make your seeking platform look professional, pretty basic.
Some of his cases test are not just micro-optimisations but rather very strange and harmful ideas. "throwing an exception is more expensive than not throwing" is either pointless or harmful. What a conclusion should I draw from such a test? That I shouldn't throw exceptions in my code? Seriously? An if I still should, what's the point in such a test then, comparing some code that is using a language feature to a code that doesn't? Instead of disproving, as he claimed, some false claims he is creating new ones.
Okay, then go write a blog and show us some real performance instead of whining like a bitch.
You'll have to excuse the terribad semi-pseudocode I put together, but the only way I can see around this problem is by using an event dispatcher that the framework would pass between all the objects prior to starting the chain: https://pastebin.com/tdnXxfFj
Thanks for your advice.
it has been written many times already, and posted in this sub too. But people *en masse* are prone to clickbaitish titles than to elaborate explanations that require some experience and understanding on the reader's part. There is [one that has been posted several times during the last week only](https://nikic.github.io/2012/01/09/Disproving-the-Single-Quotes-Performance-Myth.html) (and itself is a 6 years old already). but still we have an eager enthusiast ready to test things that make no sense in the first place. 
What happens to the native array function test if you write it like this? ``` array_map('strtoupper', $words); ``` No more anonymous function, and easier to read.
What situation are we parsing gigantic, unformatted, text files into an array, in an editor? Surely this is what code is for, hard coded arrays are bad wrong horrible, and should be in a database of some sort, not a hard-coded flat-file representation pretending to be one.
I shuddered hard at the inheritance chain bit, but I understand where you are. If you find a design that solves these issues well (and the problem is lack of expressiveness in the type system of PHP), please do let me know. So far, I proposed an `Either &lt;FailureResponse&gt; &lt;DecoratedResponse&gt;` approach, but PHP has no real way to represent it.
I don't think that this solves the problem: you now exchanged the type safety of the parameter with a lookup map for possibly-ever-called events (which is what we have in symfony/zf, and tbh is kinda terrible to work with :-\ ). It's still held together by string keys, just shifted the type checks elsewhere.
So for a real-world example of how much time these performance tricks save you, let's look at the double quotes vs single quotes example. That's got mean values of 0.224 microseconds for the single quotes example, vs 0.235 microseconds. That's a difference of 0.011 microseconds. I just loaded the front page of Reddit. 370k in 3.3s. (And wow that's slow..) Let's assume single-byte chars. (They aren't all, but it won't make a huge difference). That's 370,000 characters transmitted to me in 3.3s. That's 1character in 9 microseconds. So, you'd have to make the savings from that performance benchmark nine hundred times over to get the same speedup as leaving a single character out of your markup. (And yes, gzip compression, etc, but I'm keeping it simple for the purposes of giving some context for how much this stuff doesn't matter.)
&gt; colshrapnel I reported this link to the mods with under "does a considerable harm to the community" reason. What an idiotic reaction to have. Having up-to-date factual information is always preferrable to remaining ignorant. If this benchmark can make some developers interested in the performance of their codebases and they can in turn learn how to run tests for themselves, it is a net positive for the community. Also, there are numerous codebases that either manipulate 100s of strings, or at least handle very large strings. Getting a 2-3% raw performance improvement by doing such a trivial, largely automatable change (from " to ') that does not impede readability/extensibility is absolutely good.
Please note that I state 2 times in the article that all of these results are not representative to real world code.
https://3v4l.org/ePZOe
The legacy code can be code written 5 years ago by a team that's long gone.
&gt;In practice, not gigantic text, but a dozen or dozens of lines, columns. Writing code for processing may take more time. Copy and paste one by one is not the way. Copy to another editor to process is not necessary when you can do it in your IDE.
Regarding array_map vs foreach loops, you have some differences in methodology between the tests that skew the result. The loop test calls strtoupper directly, while the array_map test calls an anonymous function which then calls strtoupper. This can be fixed by changing the second test to `$shouts = array_map('strtoupper', $words)` I ran an equivalent benchmark measuring direct functions vs indirect named functions vs indirect anonymous functions: [FuncBench.php](https://gist.github.com/22e5b427c948071e8d292ed9b5c95c56) `phpbench run --revs=10000 --iterations=100 --warmup=10 --report=aggregate FuncBench.php` benchmark | subject | groups | params | revs | its | mem_peak | best | mean | mode | worst | stdev | rstdev | diff -----------|---------------------------|--------|--------|-------|-----|----------|---------|---------|---------|---------|---------|--------|------- FuncBench | benchLoopDirectFunction | | [] | 10000 | 100 | 428,896b | 0.519μs | 0.580μs | 0.549μs | 0.974μs | 0.087μs | 15.07% | 1.02x FuncBench | benchLoopIndirectFunction | | [] | 10000 | 100 | 428,904b | 0.664μs | 0.753μs | 0.722μs | 1.272μs | 0.102μs | 13.49% | 1.32x FuncBench | benchLoopClosure | | [] | 10000 | 100 | 428,896b | 0.889μs | 1.003μs | 0.947μs | 1.673μs | 0.147μs | 14.62% | 1.76x FuncBench | benchMapDirectFunction | | [] | 10000 | 100 | 428,896b | 0.518μs | 0.570μs | 0.542μs | 1.015μs | 0.100μs | 17.47% | 1.00x FuncBench | benchMapIndirectFunction | | [] | 10000 | 100 | 428,904b | 0.790μs | 0.859μs | 0.817μs | 1.407μs | 0.129μs | 14.97% | 1.51x FuncBench | benchMapClosure | | [] | 10000 | 100 | 428,888b | 0.840μs | 0.940μs | 0.890μs | 1.719μs | 0.152μs | 16.21% | 1.65x 
Yeah, but there's a big difference between "The results might not be that extreme in your day to day code." and the reality, which is that you'll never notice a difference in the real world.
You won't get a 2-3% performance in a real app that deals with strings though, as it's going to spend a million times longer loading the strings it deals with from a file/db/whatever than it will parsing the quotes. This is exactly why this article is harmful. It just tricked you into thinking this matters.
I really wished everybody followed PSR-2. There would be no arguments over style matters any more. Then you hear things like "I tried, but I didn't like it" or "it's not for us" and stuff like that. Guess what, PSR-2 is not for _you_. It's for the community. And _you_ should be part of the community. Style doesn't matter, consistency does.
First, nope. Do you know what orders of magnitudes are and what "a million times longer" actually means? Second, nope. If posts like these "tricked" people into getting interested in their code bases and into thinking about how to make it faster, maybe into installing xdebug or fetching the opcodes and making decisions on them, then it sounds like a definite win.
This is anything but facts. It's a pity that most PHP folks are simply unable to grasp that. First of all, such micro-optimizations play no role in the real life. This is first and foremost. The only fact here is that none of such results would affect any sensible real-life code. The performance of one's codebase lies in the completely different direction than measuring zillions of iterations of doing nothing. There are other things that are anything but facts in this article. For example, "not throwing an exception is just wrong thing to measure at all". Or in is `$row[id]` he is testing a code which is completely different from what is claimed in the title. He *really have no clue* what he is talking a bout, this is not an insult but a precise description. Finally, the guy just have no idea how to test properly. He don't have the opcode cache turned on and he have xdebug extension loaded. And I can assure you there are dozens other issues that will affect his tests in one or the other way. Still prefer to call these "results" facts? 
Give me a real world example of when and why you would need to do this "it can easily get the nth regex match of each line in-place and store in arrays", with an example piece of source data. Because you keep saying it, and I think you need to look at better ways of handling your application structure if you do this often enough to require a 12$ tool to do it.
Thank you. As expected, but it is always preferrable to test one's expectations.
Ok, given you are heavily under the Dunning-Kruger effect, it makes no sense to talk to you. You are so blind that you cannot even properly interpret the results you have before your eyes. Have a nice day.
Bye Felicia!
Well other than strings, the only other method I could think of would be spamming interfaces like they were about to go out of fashion, and provide a unified method for calling them. It would give type safety and remove reliance on strings at the cost of a wholeee lot of interfaces.. interface WantsToReceivePermissionsInterface { public function onReceivePermissions(Permissions); } class AdminModule implements MiddlewareInterface, WantsToReceivePermissionsInterface { /* __invoke(...) */ public function onReceivePermissions(Permissions $permissions) { $this-&gt;permissions = $permissions; } } class AuthModule implements MiddlewareInterface { public function __invoke(Request $request, $next) { $permissions = $this-&gt;loadPermissions(); $this-&gt;message(WantsToReceivePermissionsInterface::class, $permissions); } }
My wording was carefully chosen based on the difference of 0.011 microseconds between the single and double quote examples, and, say, 10ms to make a database query. That's pretty much bang on a million times longer.
Here are some reasons, because of these zend is not followed by most of the developers:- * Loose coupling between components of the framework * There should be no XML files to hold application configuration * Complex and hard to learn * Not backward-compatible with its own earlier version * Very slow Here is a link shared for a prestashop(PHP based) framework (ecommerce development) where you can check that what type of packages you want. [https://www.softprodigy.com/hire-the-best-prestashop-web-developers-india](https://www.softprodigy.com/hire-the-best-prestashop-web-developers-india)
It can be, but again the question is how well this code was written. The rules of good engineering, modularity, small-surface APIs etc. none of this has been invented in the last 5 or 10 or 20 or 40 years. You don't have to personally write code in order to consider it 1st party if its IP belongs to the company you work for. That wouldn't even work for any moderately big or long-lived company. So I don't see how any of what I said doesn't stand...
2-3%? Where are you getting that number from? Does the sun shine there at all? colshrapnel is an opinionated wossname, and the number of times I see his name on this sub and think "oh god, not again" is quite something, but, he's actually right more often than not - like now.
OP's methodology involves testing arrays of 5 quoted strings, each comprising between 3 and 11 characters. Is that really something expected in real life, or might it a much simpler case that can only trigger our interest and make us question things? Might it be that we could encounter larger arrays with longer elements in actual code bases? Would timings be lower or higher with actual data? Who knows, right?
Two of those show that double quotes are faster, and one show singles as faster - these variations happen more if you actually read past the first three evals on that link to posted. Or even run it more than once, because the numbers change each time. The only thing this shows is that there is no consistent answer to whether one is faster than the other. If you look at the opcodes, which show **exactly** what happens when running the code, you'll see that in the absence of any interpolation or evaluation in the strings in question, they result in the same output. This means that if you are using opcode caching (which, if you care about "optimisation" enough to make these ridiculously small improvements, you better bloody well be), the end result is **exactly the same**.
Very nice article. Thank you
&gt; Two of those show that double quotes are faster, and one show singles as faster - these variations happen more if you actually read past the first three evals on that link to posted. Or even run it more than once, because the numbers change each time. &gt; &gt; The only thing this shows is that there is no consistent answer to whether one is faster than the other. That's my point exactly. The benchmark he linked to is inconsistent across successive runs, with *huge* unexplained variations, ergo it's incorrectly done to say the least.
But what is the point of having the "special" version if the code already have PHP version check and will not break on PHP7? [https://github.com/paragonie/random\_compat/blob/v2.0.17/lib/random.php#L47](https://github.com/paragonie/random_compat/blob/v2.0.17/lib/random.php#L47) Looks weird for me.
Assuming the file has the executable bit for your user: yes.
Surely you didn't read it through.
Hmm do you use git on WSL or in phpstorm
oh yeah I mean I assumed that the code was a terrible binfire that nobody understood
I do follow the PSR guidelines and I ruthlessly reformat and refactor my coworkers' code. 
Thanks.
&gt; are variables all camelCase / snake_case? This is like the one thing I can't bring myself to be consistent on. Sometimes snake case just reads better. I generally use camel case for class variables, always for class names and class functions, but not always for global function names or local variables.
Er, so you're agreeing with his comments about why the benchmarking done by OP is worthless? Got to admit, I'm a bit lost now.
The point is, in the real world, these micro-optimisations take longer to think about and implement than any potential time they will save over the course of their lifetimes in your code. When was the last time an optimisation was needed in string manipulation, rather than a DB query, or memory usage? Probably in the 80's when processing power was at a premium still.
Your merge requests must be a real pain in the arse to review :)
Haha, no worries I could have been more clear. colshrapnel linked to a 6 year old blog post as some sort of appeal to authority that would somehow disprove OP's bench AND bring a definite answer. I pointed out that that blog post's benchmark is bullshit and doesn't mean what lieutenantconfetti thinks it says.
The issue about this is that some programmers simply don't like/agree/care about PSR-2. I don't like some of its rules either and so my team does. Therefore, we only use it for public code. There is no reason using conventions we are not comfortable with and consider them wrong, that would be obviously just stupid.
For example, when you need to extract some text from other's code, you may need a complex regular expression or switch to other widows to handle it. ConyEdit just handle that in your IDE with a simple regex or a simple built-in regex name without switching windows. The nth of regex match is just an example. There's a lot of code examples in the website and the website's tutorial. If you write business logic code often, you will notice that, if not, never mind.
Ah, wordpress? Probably best to download (or clone the repo? It's in source control, right?), load it into an IDE, and start ctrl-clicking on the functions, or find in files (ctrl-shift-F usually).
This is stupid. Please don't optimize code like this. Please don't trade a good design for this kind of micro optimizations. Even on really high hits this stuff is still a minuscule, microscopic optimization compared to any kind of I/O like databases.
FYI: https://i.imgur.com/DK1ckG8.png Please delete it from here and re-ask in the appropriated subreddit. 
FYI, https://i.imgur.com/DK1ckG8.png
I can work on my project in PhpStorm just fine. I can use Powershell to git status and commit and push. I can use WSL Ubuntu to git status commit and push. I can use PhpStorm to git status and commit but it refuses to push.
Doing it this way provides application and library developers to control their includes separately. For example: If you're building a library that's intended for PHP 5 and PHP 7 then you can set the version range to include current 2.X and 9.99.99. Then for your library users they can either: a) set no require version at all, or b) decide they only run their application in PHP 7 and set their apps require to use 9.99.99. By doing this they ensure they meet the dependency to make composer happy - no matter what they choose nothing breaks. And they still have control over what kind of shims or native functions are used.
I installed git in WSL Ubuntu using apt. Works fine. I installed git-bash Win 10, and that works fine too. I tried both the native and built in git inside PhpStorm and it works fine until I push. I am using username and password for github auth inside PhpStorm, and testing it succeeds, but when I try to push, it fails with “failed to read from the remote repository.”
What /u/colshrapnel is saying is that you should go to: /r/PHPhelp (and maybe /r/Wordpress )
What you're saying, is that this *editor plugin*, is used to pull data out of a document/file/text/etc, and format it into my code, offline, so that I can access and use it when the code is compiled/uploaded/whatever? Assuming I'm understanding you correctly. There could be a language barrier at work here. Why would we want to do that? Large pieces of data like this should not be hard coded into source, therefore they should never need to be parsed or processed into your IDE. This is what databases/sources are for, so that you do not have to do a code release to fix a typo. What I'm trying to get at, is if I have to use an offline tool to crunch data of any sort, so that I can use it in my code, then my code is wrong, and there is a better way of tackling the problem.
Here's a sneak peek of /r/PHPhelp using the [top posts](https://np.reddit.com/r/PHPhelp/top/?sort=top&amp;t=year) of the year! \#1: [Join the battle for Net Neutrality! The FCC plans to kill Net Neutrality and it will affect everyone unless YOU fight for it!](https://www.battleforthenet.com/) | [4 comments](https://np.reddit.com/r/PHPhelp/comments/7eoq2o/join_the_battle_for_net_neutrality_the_fcc_plans/) \#2: [Please stop closing your PHP tags](https://np.reddit.com/r/PHPhelp/comments/8tq4h7/please_stop_closing_your_php_tags/) \#3: [Making /r/PHPHelp better, Pt 2.](https://np.reddit.com/r/PHPhelp/comments/8jejyf/making_rphphelp_better_pt_2/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
It looks like permission differences. I read somewhere that has to do with how WSL mounts into a portion of the Windows drive, kind of like how you can’t change permissions of files on an NFS mount.
Are you using username and password for github auth, or token? I’m using un/pw. Also in your git config is your repo origin url using https or ssh?
&gt;BLOCKlogic If the application is intended to run only with PHP7 then "random\_compat" is unneeded dependency, and if it's intended to run with PHP 5/7 then 2.x version already covers the case with PHP7 support by checking the version and doing nothing. Still can't get it )= 
Even when disabled, xdebug has an impact on performance. Notably, it forces the engine to emit extended opcodes (which would be used in the case of actual debugging)
userId, userName, birthDate, phone, password. These business fields names writing in the code is not hard coded. 
\&gt; new-ing up of classes I think the word you are looking for is "Instantiating"
There we go, an actual use case. Finally. Rather then repeating the nonsensical nth line thing. But yeah, pretty sure storm can do that, and not sure it's worth the cost for an additional tool if it can't.
In the 9.99.99 there is no php file loaded and executed so it is slightly faster. see composer.json file: "autoload": { "files": [ "lib/random.php" ] }
At my old work place, we used an abbreviation for this: cro-op.
Most of these fall under premature optimization, the only one that might be somewhat significant is the JSON vs XML one if you do a lot of deserialization. These kind of micro-optimizations are a huge waste of time and are rarely (if ever) the issue when you have performance problems. Your time is better spent writing clean, readable and reusable code. That said, benchmarks like this aren't useless and *could* sometimes expose problems in the language that were not seen before. 
Technical debt hurts the company *far* more on the long run, than it costs to fix early on.
I personnally follow PSR for coding styles. My company migrate too. But not all the companies do. We all talk about coding style, but PSR is much more than that. Using PSR interfaces for log system, http request are important too. It helps you to have a more flexible solution and you could change libraries without changing your business code if everyone follow those rules. All the big open source library follow PSR (monolog, Guzzle, etc.)
Cool. So would you then put that at the top of say, a bat file? Or a .PHP?
Let them maintain an open-source package. That's the place to learn added value of standards.
Please use /r/phphelp
&gt; But what is the point of having the "special" version if the code already have PHP version check and will not break on PHP7? Your IDE and static analysis tool doesn't know what a polyfill is. It will complain about "duplicate class definitions" for PHP 7+ software if any of your dependencies still supports PHP 5 (and uses random_compat in accordance with this support). v9.99.99 is there to make PHP 7 code faster as well as reduce static analysis and/or IDE code inspection false positives. That's the point of it.
Could you please open support posts on /r/phphelp ?
Oh didn’t know about that one thanks!
Yes we use it. Yes it is great. 
I would say, though, that the test data used is rubbish. At least something like a full document for both sides would be a better test. 
*Which* coding standard you use is not that important, using *a* coding standard is. That said, PSR is the most widely used coding standard in open source. I wish I could provide a source but can't find it anymore, there was a medium article where they took code Github to create statistics about the coding standard used. Adapting PSR at first may be counterproductive and may not align with your own views, but you get used to it and reduces frustration in the long run. There are plenty of tools available to help you with that. If you already have a CI setup, it's trivial to add a code style checker. There are also tools that fix your files (PHP CS Fixer) but running it will affect your version history and make it a little more tedious to find why something was changed in the past. 
Well *nix doesn't generally use the `.bat` extension for anything conventionally, but that said: On a *nix system the extension doesn't matter to how a file gets executed, rather the [magic number](https://en.wikipedia.org/wiki/Magic_number_\(programming\)#Magic_numbers_in_files) does. The magic number corresponding to a file starting with `#!` when interpreting the bytes as ASCII compatible text refers to a file that's intended to be executed by running a binary pointed to by the rest of the first line of the file with the path of the file as an argument. There isn't a specific set of allowed interpreters that can be used on the shebang - you can use any program at all on the system that you care to. To quote the `composer` executable on my system (which on a *nix system you can probably check yourself by running `cat $(which composer) | head` #!/usr/bin/env php &lt;?php ...
To me, the use cases shown just make simple procedural code shorter (in terms of #lines of code), longer (in terms of #characters) and harder to understand? Are there other cases where it is more useful? 
It's so painful to see someone so blinded by his or her own misunderstanding of what defines what they are actually trying to grasp. It's like saying RNG is by definition cryptographically safe. Sir or madam, you are grossly misunderstanding what those tests and their results represent. In this case, having inconsistent results is also a result, in that it may differ in performance initially. As is also documented, the opcode that is built is exactly the same, so when repeating this over multiple application calls, the difference becomes immeasurable. When leaving out the initial "warm up", it's even non existent.
Indeed, I skimmed through the article as my conclusion does not require the details of it. Good benchmarks are hard as data sets may favor one situation or another and the smallest task running in the background may affect the final score. I usually take these with a grain of salt unless there is a significant difference.
The next year is the time to deprecate as much as we can in 7.4, so that we can remove it in 8.0 Clock starts now...
[https://blog.blackfire.io/php-7-performance-improvements-encapsed-strings-optimization.html](https://blog.blackfire.io/php-7-performance-improvements-encapsed-strings-optimization.html)
For the haters: the article didn't promised three-figures percentage improvements, but shed a light on some interesting tidbits (at least comments effect on performance was surprising). While these micro-optimizations won't get us anywhere, I've seen _that_ kind of code where you can gain some performance with these. And you know what? These aren't harmful to keep in mind.
Except when it's messing up line endings (experienced this on Windows).
I wonder how much time you've wasted in total posting this.
 &lt;?php const NUM = 1000; $singleQuotedStringCode = "&lt;?php $v = '" . str_repeat('x', NUM) . "';"; echo 1; $doubleQuotedStringCode = '&lt;?php $v = "' . str_repeat('y', NUM) . '";'; echo 2; Here. I kept only the string building part and I added ECHO statements just so we can easily distinguish between the two sections. Now, you say, "**As is also documented, the opcode that is built is exactly the same**". Is it actually true or are you completely clueless? Let's check! Fortunately for us, it is quite easy, even from 3v4l.org, because there's a VLD tab you can click on that will show you the actual, generated opcodes. Here is the whole program in opcodes: Finding entry points Branch analysis from position: 0 Jump found. (Code = 62) Position 1 = -2 filename: /in/6CgKv function name: (null) number of ops: 23 compiled vars: !0 = $singleQuotedStringCode, !1 = $v, !2 = $doubleQuotedStringCode line #* E I O op fetch ext return operands ------------------------------------------------------------------------ ------------- 2 0 E &gt; DECLARE_CONST 'NUM', 1000 4 1 ROPE_INIT 3 ~4 '%3C%3Fphp+' 2 ROPE_ADD 1 ~4 ~4, !1 3 ROPE_END 2 ~3 ~4, '+%3D+%27' 4 INIT_FCALL 'str_repeat' 5 SEND_VAL 'x' 6 FETCH_CONSTANT ~6 'NUM' 7 SEND_VAL ~6 8 DO_ICALL $7 9 CONCAT ~8 ~3, $7 10 CONCAT ~9 ~8, '%27%3B' 11 ASSIGN !0, ~9 5 12 ECHO 1 7 13 INIT_FCALL 'str_repeat' 14 SEND_VAL 'y' 15 FETCH_CONSTANT ~11 'NUM' 16 SEND_VAL ~11 17 DO_ICALL $12 18 CONCAT ~13 '%3C%3Fphp+%24v+%3D+%22', $12 19 CONCAT ~14 ~13, '%22%3B' 20 ASSIGN !2, ~14 8 21 ECHO 2 9 22 &gt; RETURN 1 Now. I know it is a bit difficult to see where the first part ends and where the second part begins, which is why I put the ECHO lines earlier. Here are the opcodes built for double quoted strings: 4 1 ROPE_INIT 3 ~4 '%3C%3Fphp+' 2 ROPE_ADD 1 ~4 ~4, !1 3 ROPE_END 2 ~3 ~4, '+%3D+%27' 4 INIT_FCALL 'str_repeat' 5 SEND_VAL 'x' 6 FETCH_CONSTANT ~6 'NUM' 7 SEND_VAL ~6 8 DO_ICALL $7 9 CONCAT ~8 ~3, $7 10 CONCAT ~9 ~8, '%27%3B' 11 ASSIGN !0, ~9 Here are the opcodes built for single quoted strings: 7 13 INIT_FCALL 'str_repeat' 14 SEND_VAL 'y' 15 FETCH_CONSTANT ~11 'NUM' 16 SEND_VAL ~11 17 DO_ICALL $12 18 CONCAT ~13 '%3C%3Fphp+%24v+%3D+%22', $12 19 CONCAT ~14 ~13, '%22%3B' 20 ASSIGN !2, ~14 Are these two groups of opcodes "*exactly the same*"? Hmm, gee, I have no idea. One group is 7 opcodes long, the other is 11 and has more complexity... What do **you** think, are these two groups *exactly the same*?
Yes, it's a great idea to create a closure, call it and a separate function rather than just use a local variable... /heavySarcasm If you're used to reading things like this, it's not any easier to read, but it's a really odd way of writing code. Especially as the name 'tap' doesn't actually describe what it's doing. It would make sense more to be `passVariableToClosure($variable, $closure)` but written like that it seems a really odd way of doing things. Which it is. I've seen Junior developers read this article and start using tap() everywhere without any real understanding of why, or what cases you would actually use it.
&gt; To me, the use cases shown just make simple procedural code shorter (in terms of #lines of code), longer (in terms of #characters) and harder to understand? Are there other cases where it is more useful? As everything it has its uses. First I'll agree the callback version of tap has very limited uses, but the higher-order proxy is more interesting. And even the callback one can be usefull when you use `Closure::fromCallable()`. Second, for the "harder to understand part", it does take a few times to get used to it. But once you do, it's the same as using array_map instead of foreach to me. Should I use it everywhere ? No. But in some cases it does reduce boilerplate and is quite expressive. Like a lot of things in Laravel, you like it, or you don't. But you can just not use it, then. It's one of those abstraction and higher level tools that you might or might not want. public function update(UpdateUserRequest $request, User $user): User { return new UserResource(tap($user)-&gt;update($request-&gt;validated())); } Is quite beautiful to me, if that's all I need. But I wouldn't fight if someone I work with prefers to use the longer version of it. Opt-in choice. Side not, the day PHP get (a powerfull) pipe support, `tap($value, $callback)` has no reasons to stay. I'm not sur the proxy one would be in the spec tho.
Of course, when interpolating, expanding or concatenating strings and variables, the results won't be the same, as they get interpreted differently. Yet, in their most basic form, strings using either single or double quotes, result in the same opcode. https://3v4l.org/Fe9K6/vld#output This demonstrates the futility of discussing the use of either under normal operation. Only when one finds that a part of their application can be optimized and analysis of string handling of a real consideration, it's worth to see if a deference can be seen by swapping quotes.
""""HELPER FUNCTIONS""""
&gt; I've seen Junior developers read this article and start using tap() everywhere without any real understanding of why, or what cases you would actually use it. I agree this is a problem of how tap was introduced. It's not the silver bullet the hype around it sold. To me it's the same that when a junior sees the `list()` or it's short syntax and starts to use it to have multi-returns functions. Powerfull tool but can be missused easily. [$title, $content] = $post-&gt;getTitleAndContent(); // I saw that one in real code ... &gt; Especially as the name 'tap' doesn't actually describe what it's doing. It's a choice ruby on rails made, and taylor rolled with it. One of the point of it is to be concise. Long but expressive name wouldn't be a good idea. You quickly get that what tap means is "do something with the base value then return it", and well, it's easier to get that dependency injection controller or actor pattern or all the complicated mumbo jumbo of our field.
I use PSR 0, 1, 2-ish, 3 (monolog), 4 (because Doctrine), 7 (because Slim). If I was in a place that was explicitly anti-PSR I would consider myself a "bad culture fit" and abscond.
A time spent to give a friendly hand to a fellow human being is never wasted!
Comments do not have impact on performance, as long as you don't have xdebug loaded. They are stripped away during (normal) compilation, only docblocks are kept somewhere in memory, completely unrelated to your actual opcodes.
&gt; That said, please don’t stare yourself blind at the results here. Speed is just one part of software development, and I personally think marginal gains don’t out weight good developer practices. This is an experiment and not advice.
You're the Felicia here.
I was done with the first one. Single quotes which require no evaluation are slower than double quotes that do? Bullshit.
Good advice! Patience and fact-finding are key. Be careful not to react to harshly until the big picture becomes clear.
I bet you don't get asked to go out to lunch very often ;)
I code however the fuck I want and then just let `php-cs-fixer` do its thing. I'm not about to spend cognitive function on micro-managing code style.
we don't use PRs, just merge directly into master whenever I / they feel like it.
I generally use my lunch break to go home so I can work the rest of the day from home.
&gt; Is quite beautiful to me, if that's all I need. All I see is a single line performing way too many discrete operations. I'm still not entirely sure what is actually happening in that line of code, because the lack of local variables or control structures make it harder for me to gain any context on what any of those method calls are doing. `UserResource` being constructed with `$user`, the response from `update()` or something else entirely? What is `$request-&gt;validated()` returning?
[removed]
One good way is to refactor the shit out of it This article must be talking about "slightly unpleasant code" though, with stuff like Vagrant or Docker and writing tests... I got a codebase that would not run anywhere except the production server and could not be unit tested because there were no classes or functions, just includes.
Everything about this is terrible, nevemind ththe intrusive ads
Agreed! This should be banned. The author should be locked away
&gt; While tap is a very simple helper, I find it often lets me write terse, one-line operations that would normally require temporary variables or additional lines. this is why it's abd
Tell me you have good test coverage...
You could probably get away with using 2 composer autoloaders, one for global packages and one for local packages. I think composer does support this. So you'd have to `require /var/lib/composer/vendor/autoload.php` or wherever you put composer global packages either before or after your package-specific composer, depending on which you want to take precedence.
I read this, but minutes later, my codebase is still awful
Again yes, but it depends on the business, if I know that system is going to be replaced in a year or two's time anyway, or it's an end-of-line product they're just going to cash cow for another year then dump, there's no technical debt worth considering. All I'm saying is that without knowing OP's circumstances there's no way of knowing what's the correct *business* decision in his situation and one shouldn't be dogmatic about it - even if keeping software up-to-date should normally be prioritised with extreme prejudice.
My company is very developer focused. Standards are a requirement. We follow PSR-2 unless another standard supersedes it. For example, most CMSs have a standard that may or may not be PSR. We also know that standards are not black and white. Consistency is more important. Even if some dev is using some made up stilly standard - as long as they always use you can still deal with the code. They also allow us flexibility. Personally, I don't always adhere to the line width rule because it doesn't always make the code easier to read. Which I think is kind of the point of standards. Or at least part of the point. Pick a standard. Set up your IDE to use it. PhpStorm can do inspections as you write and a quick keyboard shortcut will fix the issue. It's the best way to get everybody on board.
Some sane default flags to json_encode and json_decode would be nice. E.g. JSON_THROW_ON_ERROR.
So check it out, I literally just had the same concern over weird version numbers yesterday. I'm not an expert on this I just happened to come across it in my own project. In my case I'm using some library (honestly not sure which one) that requires the random_compat library. So for my application the random_compat library is a 3rd party dependency that I don't really need when running in PHP 7. So rather than letting composer decide by environment I've set the 9.99.99 version in my application's composer to ensure I always get that one. Effectively this can be seen as a good, non-breaking, and official way to EoL the random_compat package overtime. It makes it so that I (as the project creator) can EoL random_compat for all my dependencies.
Hi, it might be worth looking into these websites: * [https://weworkremotely.com/](https://weworkremotely.com/) * [https://remoteok.io/](https://remoteok.io/) * [https://larajobs.com/](https://larajobs.com/)
Good bot.
Thank you, Pesthuf, for voting on StopPostingBadAdvice. This bot wants to find the best and worst bots on Reddit. [You can view results here](https://goodbot-badbot.herokuapp.com/). *** ^^Even ^^if ^^I ^^don't ^^reply ^^to ^^your ^^comment, ^^I'm ^^still ^^listening ^^for ^^votes. ^^Check ^^the ^^webpage ^^to ^^see ^^if ^^your ^^vote ^^registered!
Are you aware that your co-workers make fun of you? =P
A terribly done experiment. If you want to be scientific about these kinds of optimizations, you need to be looking at the opcodes the code produces. PHP does optimization at the opcode level - the PHP code you write is not necessarily what actually gets run. This "experiment" does not take that into account.
Developers come and go. Using a publicly-defined coding style is just one less thing to think about when working on different projects with different people.
Agreed. By now I follow PSR-2 instinctively, but the end result is more important than how you get there. Tooling can take care of this, and that's why it should be a no-brainer choice.
Hmm, if that's the case (which would totally make sense), why the author of the post ran these tests with xdebug enabled?
Why does the Laravel community hate static analysis and autocomplete so much, I always wonder.
These "performance tricks" rarely "work" in terms of actually speeding up applications. There are some cases where application code is looping hundreds of thousands or millions of times where these might start to make a difference, but they're very rare. Additionally, attempting to use "tricks" to make your code faster can end up working against you - PHP optimizes code where it can and using tricks can actually cause PHP to not implement the automatic optimizations in some cases. They also often end up making the code harder to read. This can make it harder to reason about the code and spot bugs or actual performance issues. Performance tricks that actually work: * Avoiding looping over data multiple times * Instead of extracting rows from a CSV into an array, then looping over that array to process the rows, then looping over the result of that to insert / update the database, condense the operations into a single loop - extract a single row from the csv, process it, update the database, next row. * SQL is code too! Learn your database(s)! * Poor schema design and lack of proper, effective indexes is one of the primary causes of poor application performance * Update your servers / packages * Each version of most software packages (PHP, MySQL, etc) brings optimizations and improvements. While they may not be major, they can add up over time. * New features can also help - recent versions of MySQL include improved EXPLAIN output and "online schema changes" that allow you to make changes without downtime / significantly less performance degradation * Implement monitoring - APM services and tools such as Percona Monitoring &amp; Management and Grafana+Prometheus can help you quickly find performance issues * Give better feedback to users - you might not believe the number of times I've been thanked for speeding up functionality when all I did was add or improve the "in progress" indicators.
Not exactly our case, but you have mentioned `php-cs-fixer`, which is the solution for this. In general, I agree that widely used coding &amp; naming style is a good thing, I just don't like some of the PSR-2 rules and don't agree with most of rest PSR standards at all. That is, of course, my problem - you might say. But imagine - would you follow coding/naming style guide you or your team members don't agree with? At the end of the day, PSR is recommendation, not a standard.
Almost every programmer who has ended formal education should know all those "tricks" (they're not tricks). &gt; Are single quotes faster than double quotes? Double quotes are evaluated and PHP variables (and other expressions) are interpolated. Single quotes are not. Easy to see why are faster. &gt; Using loads of layered objects is way slower? There is an overhead associated with function calls. Calling another function is not free. &gt; Native array functions should be faster than loops, right? No, you're calling a function (the callback), also, array_ functions create a new array instead of mutating the array you pass to them (functional paradigm). &gt; $row[’id’] is 7 times faster than $row[id] ? when the ’id’ is a string, PHP will check if it is a number and parse it to a number. The difference in performance is because of those checks PHP must do. I think the post deserve to have more conclusions and explanations about why each piece of code is slower/faster. Newcomers devs love this kind of posts were you compare two things and say "look! this is faster". If the intention was to teach something, maybe I'm wrong, but I think this post is doing wrong in not explaining the why behind each paragraph.
I used this one and had no issues at all. Seems easier than using that stuff... http://www.tutorialsface.com/2016/02/simple-php-mysql-rest-api-sample-example-tutorial/ (I know it is 2 yrs old but it works!)
&gt; I'm still not entirely sure what is actually happening in that line of code, because the lack of local variables or control structures make it harder for me to gain any context on what any of those method calls are doing. Is UserResource being constructed with $user, the response from update() or something else entirely? What is $request-&gt;validated() returning? I'm guessing you don't work with Laravel yourself, and you never read the docs, as apart for the `tap` helper, it's Laravel bread and butter. For the tap helper, quick refresher : return tap($object)-&gt;method(); // is equivalent to these 2 lines $object-&gt;method(); return $object; The return of tap is ALWAYS the value you passed. Always `$object` in my example. If you want to see the tap implementation (I know some people only learn like this) it's [here](https://github.com/laravel/framework/blob/5.6/src/Illuminate/Support/helpers.php#L1027) and [there](https://github.com/laravel/framework/blob/5.6/src/Illuminate/Support/HigherOrderTapProxy.php). It uses a proxy object and a __call under the hood, but there is not much to it. The rest is [Form request validation](https://laravel.com/docs/5.6/validation#form-request-validation), [route model binding](https://laravel.com/docs/5.6/routing#route-model-binding), [Eloquent (active record) update](https://laravel.com/docs/5.6/eloquent#updates), and [Api Resource (read transformers)](https://laravel.com/docs/5.6/eloquent-resources) &gt; Is UserResource being constructed with $user, the response from update() or something else entirely? You just have to know `tap($object)-&gt;whatever()` will ALWAYS return `$object`. So in this case, `$user`. You don't even need to read the rest of the line to know that. &gt; What is $request-&gt;validated() returning? `$request-&gt;validated()` is a standard framework method. It returns all data that was explicitely validated in the `UpdateUserRequest` [Form Request](https://laravel.com/docs/5.6/validation#form-request-validation). In a form request you specify how your data should be validated with an array of [rules](https://laravel.com/docs/5.6/validation#available-validation-rules) : public function rules() { return [ 'name' =&gt; ['required', 'string'], 'email' =&gt; ['required', 'email'], ]; } When this form request is passed to the controller, data was already validated. `$request-&gt;validated()` just gives me the key intersection of all the request data and my rules array. If the client posted a name, an email and a password to my controller, the password would be discarded. I also could use `$request-&gt;only('name', 'email')` but why duplicate those and trust myself to always add a new key in both places, and duplicate framework code too ? --- I wouldn't expect a junior to get that `tap` call without and explanation or a source dive, and would probably help him to get it instead of just telling him to go [RTFMN](https://www.allacronyms.com/RTFMN/Read_The_Fucking_Manual_Noob). I do maintain it's not that hard to get. The rest, well it's Laravel 101, and all junior should read the whole docs in their first two weeks, at least to know what exists, and what to search in the docs. I don't expect them to be off book (or off docs here), but just to have a rough idea of what the framework provides. I do like a framework I can leverage to do most of the grunt work for me, if I just take the minimum time to learn its philosophy and its abstractions. The alternative is a waste of my time and of my tools.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [laravel/framework/.../**helpers.php#L1027** (5.6 → c8682e1)](https://github.com/laravel/framework/blob/c8682e11b9f0e153654ff5c2a3ad9f8b2dca56d1/src/Illuminate/Support/helpers.php#L1027) * [laravel/framework/.../**HigherOrderTapProxy.php** (5.6 → c8682e1)](https://github.com/laravel/framework/blob/c8682e11b9f0e153654ff5c2a3ad9f8b2dca56d1/src/Illuminate/Support/HigherOrderTapProxy.php) ---- 
No, Not Smarty. Use PHP Mustache (https://github.com/bobthecow/mustache.php), Build your data for the template using arrays, call render and return the HTML. Although it isn't smart, like Smarty, it does most everything you need for templating.
I kind of like interfaces for interoperability (not PSR ones, but that doesn't really matter), but this can go wrong hard. Check out ircmaxell's letter [https://blog.ircmaxell.com/2014/10/an-open-letter-to-php-fig.html](https://blog.ircmaxell.com/2014/10/an-open-letter-to-php-fig.html)about logger interface (and it's [followup](https://blog.ircmaxell.com/2014/10/a-followup-to-open-letter-to-php-fig.html)). DI container is also a *good* example, but that's for another story.
Maybe [https://www.upwork.com/](https://www.upwork.com/)
Hello, you can try my [storage framework](https://github.com/igniphp/storage)\- it is general purpose hydration/mapping library with built-in support for pdo and mongodb, if you provide driver and default reposirory for dynamodb I think it can be successfully used.
Not enabled, loaded, there's a difference
&gt; PHP variables (and other expressions) are interpolated As there are no variables (and other expressions) in the string, there is nothing to evaluate as well. Go figure. &gt; when the ’id’ is a string, PHP will check if it is a number You completely missed what is the point here. It is not numbers that makes PHP slow but a blatant **error**. Notably, the OP failed with this test completely as well. 
I've worked with Laravel frequently actually, though the most recent version I've worked with was 5.4. I don't know if `tap()` was implemented at that point. I'd like to note that you needed several paragraphs to explain code that could have just as easily been written like this: public function update(UpdateUserRequest $request, User $user) { $validatedFields = $request-&gt;validated(); $user-&gt;update($validatedFields); return new UserResource($user); } Personally I find this method an order of magnitude more readable than your previous example.
Okay thanks so much. I am trying that next. Here is my project on GitHub r/https://github.com/giantthinker/My-Blog
Here's a sneak peek of /r/https using the [top posts](https://np.reddit.com/r/https/top/?sort=top&amp;t=year) of the year! \#1: [Cheapest way to setup https on website?](https://np.reddit.com/r/https/comments/7zatj0/cheapest_way_to_setup_https_on_website/) \#2: [Sketches](https://www.youtube.com/attribution_link?a=lNVCv-uPC5Y&amp;u=%2Fwatch%3Fv%3DUZXQ13eQmX8%26feature%3Dshare) | [1 comment](https://np.reddit.com/r/https/comments/8xu0uh/sketches/) \#3: [Sketches](https://www.youtube.com/attribution_link?a=Xp6XYMPCtIw&amp;u=%2Fwatch%3Fv%3DUZXQ13eQmX8%26feature%3Dshare) | [1 comment](https://np.reddit.com/r/https/comments/8p2td2/sketches/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
It's fairly simple, he is a complete noob in the testing, and had no idea on the side effects of xdebug. Just had no idea - that's all
"Like alot things in Laravel, love it or hate it" I guess this also counts for static analysis
Hey, fintnessbeertje, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
But it makes the code look more awesome though
Actually, the part on the comments is one of his epic *fails* in this article. So your comment proves the opposite: his article *is* harmful, making such unsuspecting users like you to believe in another bullshit superstition.
&gt; As there are no variables (and other expressions) in the string, there is nothing to evaluate as well. Go figure. PHP can't know there are no variables nor expressions without looking at the string. So, it has to make a lookup anyway. &gt; You completely missed Don't understand what you mean there. what is the blatant error?
&gt; PHP can't know there are no variables nor expressions without looking at the string. So you want to say that PHP don't have to look at the single quoted string? &gt; what is the blatant error? A PHP error. In the code. When you are making an error in the code (as shown in the OP), PHP would tell you so. This is why there is the difference. 
Eight downvotes after 12 minutes? Is someone using bots to downvote everything this bot posts?
I second the Magento comment!!! What a piece of work. Looks like someone with an engineering degree attempted to confuscate real code to build an e-commerce platform.
I only use composer global packages for dev tools that I use agnostic to any project. I might work with 20+ repos of internal code all with different versions of everything. It's just not a good way to organize and it's really much more efficient. I have an alias in my bash\_profile to run vendor/bin/phpunit as phpunit when I'm in a project directory so it feels global but it's not. 
Feels like you're trying to find a little wound in my comment. &gt; A PHP error I didn't saw the error, could you point it out to me :)?
&gt; Without having to configure a web server or any debug modules. But you can't step through the code using this technique without one.
lol 
This is a nicely written and accurate article. There's a reason by OO is so popular and it's because it organises business rules and operation in a way that is logical for people to understand, implement and extend. 
&gt; a little wound Actually I am trying to make you think. The topic itself is awfully boring, has been discussed a zillion times already (three times during the last week alone), and your amateur ideas on the interpreting a program code have been heard way too many times as well. So the only amusement one could derive from this conversation is to make you think and try to realize how this imaginary PHP of yours actually work in the real life. &gt; I didn't saw the error Just try again. A hint: the implementation of this test in the OP has absolutely nothing to do with the "trick" it's intended to explore. So pay attention to the trick description, not the benchmarking code. The error is quite apparent there. 
Yikes...just yikes. Performance can be taken care of later in well architected code. Worst perf hits I've ever seen were developers not understanding a codebase...not a language. All that blah blah blah, and not even a mention of Generators. 
Completely worthless blog spam using the cover of someone else's book as clickbait. ( RESTful Web Services By Leonard Richardson and Sam Ruby)
were these tests using the opcache compiler?
&gt; I've worked with Laravel frequently actually, though the most recent version I've worked with was 5.4. I don't know if `tap()` was implemented at that point. The article tells us it was added in a 5.4 minor, so you might have missed it. It's now used (at least the idea, not necessarily this very helper function) in some place in the framework source code. The `validated()` too is quite recent tbh. &gt; I'd like to note that you needed several paragraphs to explain code that could have just as easily been written like this: *Code example goes here* Yeah, I'm always writting too much in reddit. Ironic then, that I'm the one advocating for a shorter code \^\^ I even expected that snarky rebutal, even from someone else than you. I am not a native english speaker, and try to compensate the context I miss and the approximations I make by being a bit too specific and oversourced (helps to know the docs backards and forwards). And I'm failing at it it seems. But there is several reasons I've written that much : * I didn't know how complete/how recent your knowledge of laravel was. We also are on /r/PHP not /r/laravel, other readers might not know the framework well enough either. * I wanted to make a point that I prefer to use the full power of a framework even if it means learning a bit more about it. You yourself asked what the `validated()` method did. I could one up you and say that you didn't even needed to use it, and could do `$validatedFields = $request-&gt;only('name', 'email');`. What you get is even clearer in intent, but to me it would be a mistake. While `validated` needs to be learnt, it empowers you. I thought about making a "bare bones, least Laravel powers used possible" example, but thought it to be petty so I scrapped it, with an important sentence. My bad. &gt; Personally I find this method an order of magnitude more readable than your previous example. I find it the same once you learnt the building blocks. But to each is own, no hard feelings. I'll definitly don't tell you how to write your own goddamn code. I do have fun writting clojure too, so I might be biased towards functionnal and terse code, even when writting php.
Ml0 O.
&gt; Actually I am trying to make you think Appreciate that. But the rest of your comment still feels like you're trying to scratch the wound. I mean, your intention could be good, but the rest of the comment is completely toxic. My comment is not about "the topic", is about the absence of what I think is important, looks like you feel the same, isn't it?. &gt; You completely missed Ohh, now I see. Didn't knew that `$array['0']` was a "thing". Now I don't understand anything xD. Thanks for that.
Yeah, I should have written less about ideas I think are missing of the posts and writing more about what I meant to say. I would love to see if the test were using opcache and why that matters. In my comment I assume they're not. PHPBench docs don't say anything at all.
manual testing only, for the most part :-\
What?!?!?!? Really?? Oh no that sucks so much, I'm going to start working 8 to 5 every day in a hot, noisy office just so they'll stop.
Have you fully read the article? It says that if it can't be unit tested, you step back and do integration tests. Which isn't ideal by itself but better than nothing. Vagrant and Docker are the ideal tools to mimic a production environment, I've worked a lot with legeacy and have always managed to make it run in a dev environment. Some took longer than others, but if you have access to all the config files, it's possible. I'd never work on something I can't run locally.
To be honest author is not suggesting to micro optimise but just myth busting and having a bit of fun. Nothing wrong with that. 
thanks!
Yes, setting up a dev environment is something I did manage to do for my biggest legacy project, it took a while and required some of that refactoring I was talking about. E.g. not hard-coding paths, IP addresses, domain names and database credentials. Still had to compile PHP 5.3 from source with different flags to enable some features it depended on, plus compile the old ext-mssql from source... oh lord I'm having flashbacks.
This is what gives PHP a bad name, all the legacy tutorials out there. As this is a new article, it feels like a slap in the face. Whoever wrote this should first learn the right way before teaching people the wrong way. I'm pretty sad to see that the web is still filled with code like this, a simple "rest api php" google search hardly returns any results with somewhat decent code.
Problem I've found with upwork is it's a race to the bottom on price. 
You could reasonably draw the conclusion that exceptions would be the wrong form of error flow in tight loops and other performance-oriented code where you expect a lot of errors. Synchronous data imports, for example. Based on the performance implications, it would be perfectly fine to favor error responses instead of exceptions in these cases, and knowing that throwing/catching exceptions is much slower than using other forms of error flow is absolutely useful if you ever come across such a situation.
I don’t write $var = Instantiat Class();
Hah, yeah, sounds familiar. Hard coded stuff is often the easiest but also the most tedious process. I've had the luck of not having to compile PHP, though I vaguely remember issues connecting with a DB2 on AS/400. Either way, I personally can enjoy refactoring at times, it often gives me more sense of accomplishment that creating something from sctratch. I wouldn't want to do it constantly though.
I could reasonably draw *nothing* from his untidy and inconsistent "tests". Because, ironically, the OP doesn't compare throwing exceptions to using any other forms of error flow, comparing them to *nothing* instead. Let alone he is *methodologically* wrong, taking the problem from the essentially wrong end. If some tight loop would ever trouble me, I wouldn't start changing its random parts out of the blue, but I would *profile* the loop's payload first and then fix the part that does the actual impact on the performance. A textbook rule for any performance optimizations. Your comment is another proof for the fact that this article does a considerable harm, making you to choose an architectural decision based on groundless claims and superstitions.
So, back to the point. PHP has to "look" into any strings. This is the only important thing here. Which makes your argumentation rather clumsy. So you have to find another theoretical explanation for the *non-existent* fact that single quotes are faster than double.
The comments below prove otherwise. People keep suggesting in the comments to use the actual suggestions from the article in the real code.
Don't forget the Symfony, and PHP toolbox plugins for PHPStorm. They are great.
Did you ever read the article? In reality he claims some myths *true*, adding new superstitions along the way. Also ironically, he is quite bad at understanding some myths he is trying to bust. Let alone the tests themselves, which quality is questionable, to say the least.
https://Kasego.co
( ͡° ͜ʖ ͡°)
I bothered to reply and used that specific example exactly because it's something that I ran into personally, many years ago, which resulted in worthwhile performance improvements. For the service in question, we made the largest improvements upfront algorithmically, and over the period of several months afterward, we were able to make many more improvements by changing caching strategies, indexes, and various other usual suspects that had been naively architected by the original team. At some point later, when all of the low-hanging fruit had been plucked, we began to look more into some of the less obvious areas for improvements - one of which being the egregious throwing and catching of exceptions. After refactoring to use error responses instead, we saw gains of several seconds per import, which, given how many imports we were doing and how much data this service processed, ended up being a pretty decent win overall. It was definitely worth optimizing in our case. So, dial back the arrogance, because you're overplaying your hand here, and you don't know as much as you'd like to think you do.
Ironically, his "test" proves otherwise, claiming that any "improvements" are below the measurement error deviations. So do his clumsy excuses, as he claims several times that the test results wouldn't affect the real life code. 
this is the double off topic
Solid proof that you shouldn't comment any code. 
Thank you sir I will def give it a try. Do you have a github link?
Well his code is not even testing that case. It is gonna be considerably slower (I think) if you do the improper thing and use an undefined constant that PHP for some reason converts to a string. No one should ever do that and its dumb PHP even allows it because it should be a syntax error. But the code he shows uses an integer in an array, not an undefined constant vs string key.... so he's not even benchmarking the thing that people claim is slower. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I love PHP.
Run far, my friend. Reflect deep.
&gt; global function names Lemme guess, WP dev?
After reading part 1 and noticing several violations of SOLID, namely the O(pen/Closed principle) and the D(ependency Inversion principle) I had to stop reading and write this post to let people know that your slides might not be the holy grail of "effective php". At least if you want to write modern, testable applications.
That’s cool. Never aimed at being holy grail. Do you mind sharing your findings here?
I wish I had the time, but two points: 1. To be fair, you mentioned this in the "cons" part, but I would never expect a PHP coder with "hands-on" experience to get the Singleton pattern right... That's why it is considered an anti-pattern, because getting Singletons right is really hard and there are more bad examples out there than good examples. 2. Also listed as a con in the static factory method part already, but chaining static functions from any method makes for untestable code - for me this is a K.O. criteria, not a "con". Not to mention coupling of code (violating O and D), which is bound to happen in the consuming code parts. Look into DI and Facades.
Pt3:Slide7 - Re:Using accessors instead of properties - "The best way to write extensible software." This is a bold and unproven claim. Pt4:Slide8 - Meta: The code examples This code shows an unnecessary additional complexity, which is common among the examples. While I like the talk about immutability, functional languages also show there are patterns for easier maintainability. public function canUpdateSoftware(): bool { $canUpdate = false; // start with else case if($this-&gt;version) { $canUpdate = $this-&gt;version-&gt;software() &gt; 125; } return $canUpdate; // easier to maintain and -1 else }
So your objection is that listing something as "cons" is not strong enough of a warning? Fair enough. With regards to your second point, I think you're not seeing any difference between a static factory method and a generic static function. What's the point of testing static factory method if not for creation of an object that this static factory method is supposed to create? Same applies to dependencies, how can a constructor deal with dependencies better than a static factory method?
I think you are giving some good tips in your slides, but still need some improvements. I wouldn't recommend the usage of static methods. Static methods represent hard dependencies and untestable code, since you can't mock those calls. Pretty much the same with singletons, if you want to unit tests your code using singletons you are gonna run into a lot of problems and also are hard dependencies. You should use strict comparison in your examples. Look into early returns, it is a good way to write simpler code.
Really interesting reading and he got a point. The rule should be that the interfaces should be as small as possible.
Thanks. \&gt; This is a bold and unproven claim. Fair enough. Will stay with it though. \&gt; unnecessary additional complexity, which is common among the examples This is the complexity of the company's business domain. All examples are somewhat cleaned-up real examples from real code base. Your example is an explicit anti-pattern, as you were able to simplify the method by assuming that the \`$version\` property is the only state variable that will ever affect the logic. Once you start adding more and more state variables that can affect the logic, the interplay between them becomes more and more complex.
Thanks, mate. I really should have emphasised more that I am advocating the usage of static FACTORY method and not static method in general.
[https://www.yegor256.com/2017/11/14/static-factory-methods.html](https://www.yegor256.com/2017/11/14/static-factory-methods.html)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
check php school 
Or do you have another recommendations regarding framworks for rapid REST API development?
Something about the "See, Joshua?" that rubs me the wrong way. But all fair points.
well, good luck
I't called separation of concerns.
Yeah, names are linked. To make it easier: [https://github.com/igniphp/storage](https://github.com/igniphp/storage) [https://github.com/igniphp/storage/tree/master/src/Driver/MongoDB](https://github.com/igniphp/storage/tree/master/src/Driver/MongoDB)
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [igniphp/storage/.../**MongoDB** (master → 90b292b)](https://github.com/igniphp/storage/tree/90b292b5c8b04b7c5cc2d40754f0adff9ea70b80/src/Driver/MongoDB) ---- 
If you have any questions or would like to get some help on implementing your driver PM me.
&gt; interface Color I'm not sure I agree with this to override the constructor. IMO there's not much difference in PHP between `new MyClass` and `MyClass::new`
why not: `return ($this-&gt;version &amp;&amp; $this-&gt;version-&gt;software() &gt; 125);`
I'm a Laravel developer at my daytime day, and want to quickly speak up. I'm one of many Laravel developers who **do** value autcompletion and static analysis. I'm actually using a newly created packaged which gaps the bridge between PHPStan and Laravel right now. There's a lot of work to be done, but most of the time, PRs to the core with docblock improvements to support proper autocompletion are accepted. I go as far as to manually configure IDE helpers on top of the IDE helper package, to support autocompletion in my IDE. So don't be mistaken: a lot of Laravel developers actually value these things. There are, however, also a lot of people who work in Sublime or VSCode without proper IDE plugins, which is where a lot of the magic in Laravel comes from. Think about it: if you don't have an IDE to tell you the truth about the framework you're using, people automatically try to find workarounds. In my personal opinion, this led to the wrong decision of changing the framework in favor of the editor, instead of changing to an IDE for real benefit. I've spoken to people who don't use an IDE, and to be honest: I can't wrap my head around why they do it. All the arguments seem to be based on a lack of real IDE experience. I'm really looking forward to go to Laracon EU this year, and hope to have a civil conversation on this topic with a lot of people. Sorry for the rambling, though this is a topic that really strikes a nerve with me. I've been a passionate user of Sublime and Atom for 7 years, before switching to PHPStorm three years ago. Fair enough: it maybe took a month of learning, but the time gained by using an IDE properly is just immense.
Yep, we do. Until ~1 year ago, styling was permanently an issue. Some people simply couldn't keep up with the attention to details whereas other excelled. It become so annoying we hooked up with https://styleci.io/ and never looked back. The best part: if you push a commit with a style violation, you can configure styleci to auto-commit the correct on top =&gt; we're doing this and the end result is a blessing.
In my opinion, code consistency is way more important than personal preference. My personal preference doesn't agree with all things PSR, but the benefits of a consistent codebase across teams and OSS projects outweighs that preference by tenfold.
The term version is ambiguous here, as it could be known when the request started. In that case you could also inject a boolean or change the construction in the container.
Agree, this is something very code base specific, I should have replaced it with a more generic and more accessible example there.
So, firstly, spam. And secondly, copies of other sites' functionality, with potentially dubious code quality? Seems legit?
 Anything in the $_SERVER array that begins from HTTP is not actually a PHP variable but an HTTP header sent by the client. So there could be even `$_SERVER['HTTP_THEY_KILLED_KENNY']` or anything. That means you deliberately cannot trust any value that begins from HTTP. &gt; can I just use post ? I don't really get what you mean here 
Could you point to an example of getting a Singleton right?
This particular method looks like one that'll be regularly updated do to new platform constraints, missing dependencies etc. Adding a new condition to the one-liner is going to to make the diffs harder to review.
I would make that change when it’s needed once the extra condition is needed. 
You can build a piece of software like this in basically any language. If you're not the one writing or maintaining the code, you (more-or-less) shouldn't care about what language it's written in, whether that's PHP, or Python, or whatever. If you're looking for someone to build this for you, then you should just look for a web developer, rather than unnecessarily limiting your choices by specifying a language. 
That is a bit of a stretch of the imagination, but given that: ``` if (!$this-&gt;version) { return false; } if ($this-&gt;version &lt;= 125) { return false; } return true; ```
So, stuff gets pushed to production whenever people feel like it, with manual testing - on live? Or do you have processes in place to test stuff before it gets to a server? (sounds a bit like the wild west so far!)
Breaking up the one-liner still fucks up the diffs. Just like lack of trailing commas. 
I agree OmageVesko in terms of "let the developer" decide, but also want to add the fact that it "might" become harder/easier to stick to a set of languages. It's probally a opinion based thing, but IMHO I would stick to either PHP+MySQL or Node etc. Stack. I would assume that the range of aviable developers are way bigger for these both areas than other languages. If something has to be changed in the future or implemented something new and somehow you can't hire the same developer, then you need to find someone that can work with that exactly stack and I never did the reasearch, but I would assume it's way harder to find someone that knows Google Projects with Django than a PHP or Node developer. 
 $version_exists = isset($this-&gt;version) and (bool) $this-&gt;version; $version_is_current = $this-&gt;version-&gt;software() &gt; 125; return $version_exists and $version_is_current; 
Manual testing is on staging servers, for the most part.
There's nothing about a static factory method that precludes DI or makes code any less testable than `new`.
When we come back to this code in years to come we'll be asking what's the significance of version &gt; 125? If we can encode the intent in the variable names we can make the original intent really visible to future maintainers If statements often cause programmers to remove these names because they seem superfluous, but I'd argue they are the most important bits of the code, I can refactor code easily if I know its original intent Granted you could add comments which you might add on the original variable name allocation, but a variable name will follow you down the stack and be re-enforcing the meaning of the variable all the way down 
I'll echo what the others have said so far (and this, from someone who is primarily a PHP developer). The right language, is anything that can do the job on time and within budget. However, if you're hiring a developer in whatever language, ensure they have solid references, and are willing to talk back and forth with you about specifications and processes, so you know you're getting what you need, and not just what you ask for.
 if ($fastLookup &amp;&amp; $slowQuery) $slowQuery isn't executed if $fastLookup is false, with your version the slow query will always run. Also: wtf `and`
If those records are placed in a database then you could use PHP and SQL to get the records from the database and display them on a website.
Do you think it would be better to do that than having the program search each time? Sorry I'm new to web stuff and have no idea
What kind of code does that program use? If possible I would recommend that the program just places the records it found in a database and then use php and sql to get the records. Maybe you could make something that runs the program as soon as someone visits the website and then the program could replace the records in the database of they changed. And then after the program has done that you can display the records on the website.
What kind of code does that program use? If possible I would recommend that the program just places the records it found in a database and then use php and sql to get the records. Maybe you could make something that runs the program as soon as someone visits the website and then the program could replace the records in the database of they changed. And then after the program has done that you can display the records on the website.
It uses Python and the beautiful soup and the requests libraries 
Can't u just python to directly display the text on your website as soon as someone visits it?
WOW, i actually read the article and actually found valuable information inside and everybody downvotes this ... wow amazing community 
If you're personally going to be developing the new software then pick whatever language you have the most experience with. If you're not then allow the developer to choose their preferred language providing it's reasonably propular. The only reason I add that criteria on the end is if you hire a rouge developer and they decide to use Haskell (or whatever) you'll have a hell of a time replacing them. Good languages for this project are probably PHP, Python, Ruby, Java, C# or JavaScript. BTW, if you already have developers in house, or you already have a preferred language in house (and it's one of the above) then go with that. You'll already have all the tooling and experience.
That's what I'm trying to find out
Yes. Assuming your program takes 30 seconds to find and list the gym prices, it's unlikely users will wait for your website to load at 30 seconds a go. I suggest you run that program once every ten minutes, store the results in a database and then display those cached gym prices.
There's no need to do this in PHP if you already know Python. Python itself is a perfectly capable language for web development, look into setting up a simple website using something like [Flask](http://flask.pocoo.org/).
Thanks! I'll look into it
Yes you can use python to that, but I can't really help you if I dont know the code u use. I can give an example: devicelist = ["sony", "samsung", "iphone"] print(devicelist) 
you shouldn't use static methods that rely on state... as long as they don't, they're just namespaced functions. while it's technically true that they can't be mocked, that's only in the same sense that e.g. strlen() can't be mocked, either. 
what kind of information you found valuable, for example?
Unit test by definition should \*only\* test one class at a time. if you don't mock all your dependencies your test will be affected by code that lives outside the tested class. \`strlen\` is a built in function, so this doesn't really apply. Also inversion of control can not be achieved with static methods. Remember that your code should depende on abstractions, not on concrete classes.
Slide 10: Enforce non-instantiability: You should always use `abstract class` these days.
Few of the things like: "Using loads of layered objects is way slower?" "Native array functions should be faster than loops right?" and "What is the impact of unused vars?" What do you expect to find in such article and why you don't like it ? 
Are variables luxury goods in Laravel world? Or do they use them as a currency?
And which conclusion you are drawing from "Using loads of layered objects is way slower?" 
I understand that, I'm suggesting it's a case of not seeing the forest for the trees. you have to stop mocking things at some point, of course, and it's obviously before you reach the built-in functions. I say *any* functional code (i.e. not procedural, same input always yields the same output) falls under that umbrella.
Gonna answer in a different order. B) the way all the frameworks do it, and the way you should be doing it with vanilla php, is that the project has a web (or public) directory with an index.php and static assets, and then index.php calls stuff from project/src or project/lib or project/app or whatever. The main point is, there is very minimal amount of code within the public directory. A) If the have a single app on a domain, you can just configure your webserver to have its document root be project/web. If you have multiple apps at example.com/foo and example.com/bar, typically you'll set up the document root as symlimks, e.g. foo -&gt; projects/foo/web, bar -&gt; projects/bar/web. Deployment: php doesn't have a compile process. The easiest approach is to have CI run tests and then copy the code directory to the server. With things like docker there is a build process, but let's not go there right now. Because of the project structure I described above, it actually isn't a problem to deploy the test cases. index.php will never call into them, they never get loaded into memory, and the disk space usage is trivial. Testing: conventions do vary a bit by framework. Some frameworks have a functional test framework where you can hit routes and make fake http requests without having to use a running web server. For true e2e tests using selenium or its successors, you would need a running web server, and database, and so on. We are planning to set up something like that soon using Docker, but so far our framework's functional tests give us what we need.
&gt;Static methods represent hard dependencies and untestable code, since you can't mock those calls. I've never been a fan of this reasoning. This same reasoning would apply to free functions. And I think that this: function addTwo(int $x): int { return $x + 2; } Is more appropriate than this: Interface AddTwoer { function addTwo(int $x): int } final class AddTwoerImpl implements AddTwoer { public function addTwo(int $x): int { return $x + 2; } } As long as you explicitly test your static methods and free functions, I think it's then fine to use them in other functions and methods. Will your tests have some redundancies? Yes. But don't make your real code significantly more ridiculous just because it's slightly more testable. There's a happy middle ground somewhere.
I replied before I read your reply. But I agree. Static methods are the same as free functions and both should be pure. As long as they are pure and tested, it can be appropriate to use them.
&gt;Unit test by definition should \*only\* test one class at a time. if you don't mock all your dependencies your test will be affected by code that lives outside the tested class. \`strlen\` is a built in function, so this doesn't really apply. Why doesn't strlen apply? Is it impossible for it to have bugs? The definition of unit test being only one class at a time is fine and should usually be followed. But don't let a strict definition force you to write bad code. If a function is pure, it makes no sense to make it a method on an object. That's broken semantics and it's the reason that OOP gets so much hate these days. Making everything an object is fitting square pegs into round holes. &gt;Also inversion of control can not be achieved with static methods. Remember that your code should depend on abstractions, not on concrete classes. Static methods should be seen as free functions. So you're **not** depending on a concrete class- you're depending on a function, exactly the same as strlen(). By this super-testable-OOP approach you should never use strlen() and instead use a class that implements an interface that basically just calls strlen() for you. But that makes your code so much worse and actually **increases** the opportunity for bugs to creep in.
&gt;Pt3:Slide7 - Re:Using accessors instead of properties - "The best way to write extensible software." &gt; &gt;This is a bold and unproven claim. Accessors here means getters and setters? In PHP, I have to agree that accessors are important. At least they can be typed. They also allow you to have get-only properties. If this were Swift, Rust, Go, or Kotlin, it would be a different story, but with PHP and Java that have no concept of immutability, I think it's important.
Thanks that’s really helpful :)
The text in the arrays of ConyEdit is just for writing code, text-editing, not for other purpose.
I totally agree with your opinion, in cases like the one you mention it makes sense, But I've been working as a developer for over 10 years and the trend is to abuse the use of static methods (I've done it myself), using them just as shortcuts to call a method that contains complex logic than later on becomes really hard to refactor. That's why in general terms I discourage the use of them (together with other PHP features like traits that are commonly misused). Anyways all the points that you and @CensorVictim mention are IMO valid
I found that i should not use too many layers or classes for heavy computational work. On other cases is good to have many classes. 
Fair point. There are plenty of ways to shoot yourself in the foot (especially in PHP...). I agree that Traits are very "dangerous" in the sense that I can imagine people writing cringe-worth code with them.
Django and Flask are both Python frameworks that could make things quicker to get out into a web app. If you're more comfortable in Python than PHP, then stick with what you know :)
wouldn’t it be easier to return `self` from the `User::update` method? If your answer would be „it returns other stuff” then in my opinion it’s doing too much. 
To be fair, you could probably run it daily, 6 hourly at most - I'd be surprised if gym memberships changed more than once a day, so you just need to check often enough to catch updates a few times a day.
nitpicking here: access modifiers should always be lowercase and sometimes you are grouping them together, sometimes you put them each on a row. Also you switch between strict and loose comparisons (==/=)
This is terrible advice. Static methods represent a different style of programming and are great for many situations. What do you think people do in functional programming? Do you think they can't test because they don't use OOP principles?
&gt;Unit test by definition should *only* test one class at a time. Uh what? A unit test by definition is used to test the smallest piece of code possible. It is not defined at all as a single class.
&gt; If a function is pure, it makes no sense to make it a method on an object. That's broken semantics and it's the reason that OOP gets so much hate these days. Making everything an object is fitting square pegs into round holes. THANK YOU. You put my exact thoughts into words. The fact that this person thinks a unit test is for an entire class shows they don't understand anything outside of basic OOP principles.
you are right, I expressed that wrong
Absolutely. It's insane to me to think that there's people out there who care more about patterns and narrow minded OOP principles than actually writing readable functional code. If anything, static methods should be preferred in places where they are useful. They greatly simplify implementation and they aren't any less testable. You just need to understand how to work with pure functions.
They don't apply to PHP. There is no constructor overloading. So the whole thing is irrelevant, and you're still correct. 
Ok, I will explain once, why you was downvoted. You'll be unable tu understand it anyway, but that's not my problem. Any heavy computational work's optimization should a a result of *profiling*. An operation that will tell a developer what certain part of the work must be optimized. This is essential. Not some random part that someone imagined out of the blue but a certain part that takes most of time/resources. 
that's cool, thanks.
I didn't mean to say that a unit test should cover an entire class, what I tried to say was that one should be careful when unit testing cause done in the wrong way it can convert the tests in integration tests, depending in what your dependencies do
This is a good example of how the article's bad. It's mislead you. The benchmarks in it measured the difference in time introduced by instantiating some objects as 0.3 microseconds. The reasonable response to this is that it's such a short period of time that it'll make no difference at all. Pretty much anything else in the app could become a problem as the app scales before instantiating those objects does. The article, however, declares that it's 25% slower, which makes it sound like a big deal, when it's not. Worse than that is that if you're consciously trying not to "use too many layers or classes" when designing a system, you might make an architectural choice that makes something slower. Layers are not intrinsically bad.
I almost always prefer a free function to a static method unless it is semantically tied to the class in question, like a factory method or something. But I strongly prefer free functions or static methods to an instance method that doesn't actually depend on the state of the object. I can't stand when I see a method on a class that doesn't have $this anywhere in it!
I'm approaching troll level in this subreddit, so take this with a grain of salt. I only visit this subreddit because I've recently been thrown into a legacy PHP application. I hate it and I hate PHP. PHP is a crap language. And PHP developers are, on average, just now learning lessons that others have learned about a decade ago. PHP 7 is basically Java 7 except worse, slower, and lacking generics. Long story short, PHP developers are becoming OOP-obsessed the way that Java and C++ devs were 15 years or so ago. I'm not calling out GP in particular. It's just PHP culture right now. It's like legacy Java.
To be fair, you almost always should be using a namespaced free function rather than a static method. As far as I know, static methods are not often used in functional languages.
The update method here returns a boolean saying if the update went all the way or not. Obviously, there is an error, an exception will be thrown. Why would you need that boolean, then ? Because there is a no error path that aborts the update : eloquent comes with a series of event like 'saving', 'updating', 'saved', 'updated', ... and in the pre-database ones (those in 'ing') you can return false to abort. One could argue to use a ModelUpdateAbortedException instead, but some of those abort aren't actual errors, but wanted behavior instead (quite rare to abort thought I agree).
We have been looking to hire a PHP dev now in the North West of England for well over 12months but the applicants that have been coming through just haven't been cutting it in terms of where we would expect them to be with 3+ years of experience. The salary is above market average, no holiday limit, choice of kit etc. so the perks are good. We can't hire 100% remote, the applicant can work mostly remote (after a couple of months in the office during the introduction) but needs to visit the office usually around once a week due to meeting clients + internal planning meetings. So 100% remote is not an option at this time. What successful methods have you used to hire someone in a local catchment area? What are the best methods?
&gt; The salary is above market average, no holiday limit, choice of kit etc. so the perks are good. Well I'd have to say that the evidence doesn't agree with what you're saying. If everything is as good as you said then you would have hired someone months ago. Either that or when they come into the office they're getting scared away. Do you have difficult colleagues? Does your office smell? Is the project a nightmare? Where is your office based? If it's in the middle of nowhere then that's going to limit you. If you're in the city centre then that's not the problem. What is the salary?
What is the salary? Also, if you can't hire you have to grow your own. You could have spent the past year mentoring someone for the role....
"Above market average" is a pretty meaningless phrase for the north of England given how bad salaries can be up there. A good salary (&gt;£40k) should attract the right candidate(s), so either your salary isn't good enough _or_ you're not advertising your job to the right people. Even in the miserable hellscape of northern England there are competent developers looking for jobs, and your flexibility on remote work is an excellent benefit that should attract many candidates. Which job boards are you using? Have you tried Stack Overflow?
&gt;Which coding standard you use is not that important, using a coding standard is. This. I personally follow PSR in all my personal projects, I'm used to it and I like it. However it's really strange how people have a zealot like following towards it and all other methods/standards are 'wrong'. People forget that PSR was rejected as an official standard by PHP and is made up of self elected members, so by no means 'the right way'. As long as your company has a style guide it doesn't matter so much what it is.
&gt; (I bet the salary is in the £2xk range, in which case, hah, there's your problem!) This is a starting salary for fresh dev, however that is not what we are after. &gt; A good salary (&gt;£40k) should attract the right candidate(s) Well that would make it a good salary then. From our research the local market someone with 3 years of experience is roughly £28k average. The salary on offer is about an extra 50% on top of that, £35k upto £50k for the right candidate. &gt; Have you tried Stack Overflow? We haven't no, this is probably where we are heading next.
&gt;Well I'd have to say that the evidence doesn't agree with what you're saying. If everything is as good as you said then you would have hired someone months ago Possibly, we are certainly getting the numbers through the door just not the right types of people, I.E we constantly get 'Laravel developer', 'wordpress developer', there is nothing wrong with this per say but the level of code they produced outside of these frameworks was poor. Not all our code bases are using off the shelf frameworks like Laravel and candidates have struggled. &gt; Either that or when they come into the office they're getting scared away. Do you have difficult colleagues? Does your office smell? Not really, there is only one person full time in the office and they are very welcoming. The office is cleaned daily. &gt;Is the project a nightmare? It's a mix of projects, the newer ones are either using modern frameworks or PSR compliant code with modern techniques (routers, DI, ORM's, templating engines etc). There are also so very old (from the 90s) projects that are hard to work with used by the world's largest telco's but it's unlikely they will be touching this stuff. &gt; Where is your office based? It's based in a busy industrial park between 2 major cities with great motorway access in all directions. I think we are possibly just advertising in the wrong places to attract the right kinds of people.
This sounds too good to be true for someone with only 3+ years experience. In most cases it is. However the perks alone (aside from not being able to review properly) might steer them away because it sounds too good or the qualifications aren't transparent/clear enough. That's only my guess after hearing about it for the first time. Hiring people is usually a tedious process, especially if most people don't seem to fit properly.
You mentioned somewhere else in this thread that you were offering between "£35k upto £50k for the right candidate". That sounds between average and above average, I don't think your salary is the problem. As you mentioned, you may just not be advertising in the right places. Try going to some PHP meetups and see if they have job boards. Try Stack Overflow jobs. Who's conducting the interviews? Are they putting the candidates off? Is you advert written poorly? Do you not list the salary? These are all things that would turn me off. &gt; there is only one person full time in the office and they are very welcoming Verify this is true. You'd be amazed how many people are nice enough with the current colleagues but turn horrid when everyone's back is turned and they meet "the competition". 
That's good news then, it's almost certainly to do with where you're advertising. Good luck with SO!
&gt;Not all our code bases are using off the shelf frameworks like Laravel and candidates have struggled. I think your expectations might be too high for a person with 3 years experience. That's still junior-level. If they're able to produce competant code in a framework they're familiar with then they should be able to produce competant code in a framework they're unfamiliar with in a pretty short amount of time.
In Houston, Texas, we have been looking for a senior PHP dev going on 8 months and offering $100k+. 
You cannot really expect anything from 3 years experience, that is rookie level and needs to be shaped. If you want someone that doesn't need permanent hand holding ask for 6y+. 
I’m curious, can you send me your assessment test?
&gt;you always have the position of getting into position. whoah...woah...woah...slow down chief, we just met!
Find a qualified developer who isn't looking for a job, but would be amenable to taking a day or two to help you debug your hiring process. Pay that person for the time, of course. Then run that person through the interview process as you would for any other prospect. Be careful to keep as many people in the dark about this as possible until after it's over to avoid contaminating the process. Then, get feedback at the far end.
Static constructor creates the same source code depenedency as using `new` operator. If php had method overloading then these wouldn't be needed, but it's not hamful more than normal object instantiation.
we follow PSR-1 and 2 generally, its also easy since most static analyzers and IDEs have it built in as rulesets
looks like http-tests were introduce in 5.4 only
I only use the formatting spec, aside from that PSR makes very little sense if it's not actually part of stock PHP. 
Here is a really good first book that will bring you up to speed on modern techniques and make you aware of security things like SQL injection. https://www.amazon.com/PHP-MySQL-Novice-Ninja-Speed/dp/0994346980/ref=sr_1_1?ie=UTF8&amp;qid=1532543889&amp;sr=8-1&amp;keywords=php+novice+to+ninja