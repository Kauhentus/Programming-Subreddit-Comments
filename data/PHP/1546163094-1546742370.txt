So, no screenshots in the documentation. No set of features defined. Why would one invest time in trying this out when it is wholly unclear what this does?
Why wouldn't you add in whatever you felt was missing if you find the code useful?
Does it matter? It probably won't be faster than Java in synthetic benchmarks. Synthetic benchmarks are an extremely bad way of determining whether you want to use the language or not. For example: Java's benchmarks are great. Have you ever used a Java-based product that didn't have issues or that didn't come to a grinding halt? PHPStorm, I'm looking at you! Speed of execution is not AS relevant, because most businesses don't even need 1500 requests per second, something you can achieve with smaller instances at AWS. Does it really pay off to switch your stack from PHP to Go (for example) to squeeze out imaginary 2x speedup, if in real world you don't come close to even needing it? Support, readability, community, libraries, frameworks, examples, ecosystem - that accounts for WAY more than just raw speed. If raw speed were the deciding factor, we'd all be using C. Most high level languages are fast enough and it's the I/O that causes slowdowns, not poor CPU being overburdened. &amp;#x200B; Learning PHP doesn't mean you'll be stuck with crap products like Wordpress, Drupal or Typo3. There's quite a bit you can do with PHP that isn't just spitting some HTML around and producing cabbage code. PHP's feature list is large, you can even extend the language and all the BS that it doesn't compare to "modern" languages is just a blatant lie. 
If you read the code, you'll see it lacks quite a bit and the use scope is tiny. Why would anyone waste their time adding tests and fixes for code that's almost never going to be used? This code opens itself to race condition problems, there's no real world use scenario and if there were - people who know they need shared memory to communicate between processes probably already know how to use it and have their own libraries. There are better ways to "speak" between processes other than shared memory so this code is not really useful, therefore no one needs to waste time fixing it.
I agree that it doesn't matter that much, but that in some cases it might. I definitely agree with your gripes with PHPStorm! :) The way I figure is if you have more than 50 requests per second and you only have one server, the business value of those requests alone mean you should have a more scalable architecture, in which case getting the most out of each server isn't required. That said I totally agree that the ecosystem is more important. 
its depend where the queue be used, at some library/extension they had specicial method which we can use like `swoole_lock` in swoole https://github.com/swoole/swoole-src/blob/master/examples/lock/lock.php
communicate/share data between the processes
yes the library need more improved, for race condition read my comment above :)
Have tried Rector for such kind of automated function decoupling?
I open a new sub for KoolReport at [/r/koolreport](https://www.reddit.com/r/koolreport). I hope to receive your valuable feedbacks, questions, suggestions there. Thank you very much!
You could make an iterator class easily
I have wondered this very same thing as well
Perhaps to discourage people from submitting questions? 😂
I thought I'm such a noob and can't even create text post. I went to /r/help to ask and saw body field IS there, so this is /r/php specific
PHP is a murderer. 🤔
Not that this stops them, we just get title-only gems like: "How is I MVC?" "I want has architecture?" "What is diffrens betwen class and varbale?" 
Potato: hypertext preprocessor
Reddit should let users filter by type of post. This sub should be a place that encourages q&amp;a.
How do you handle issues with merge conflicts when crossing boundaries? Having multiple commits spread across multiple pull requests feeding into each other sounds like it would be tedious. For example if commit 1 adds a new feature, commit 2 refactors some code to use the feature, commit 3 fixes a bug in some of that refactored code, and then during the review on commit 1 it's discovered that it doesn't actually fulfill the business requirement or something that would cause merge conflicts or functionality breaks in 2 and 3.
What does this have to do with the title of the post?
I have subreddit styles disabled and using the old site design, I never noticed.
Just use https://old.reddit.com/ and disable custom CSS for subreddits
I like new design other than this
It’s a test to make sure only people who can use the web inspector to show it again can post. No non-developers allowed. 
Commits 2 and 3 would be rebased once commit 1 is approved and merged (even if it involves manually resolving some conflicts). It's not vastly different from dealing with the same issue in a single PR, it's just that each commit is worked on and reviewed in isolation (which is better for focusing on the purpose of each commit/PR). Ideally, commit 3 wouldn't exist anyway, because a refactor shouldn't cause any regressions (provided there's sufficient test coverage and commit 1 includes any relevant new tests).
If the thing you're checking is in a particular format and includes a timestamp as per the example, then it's near impossible to get a hash collision. The only thing I've ever seen is a contrived example, rather than general purpose. The same could be true for sha256, just a lot less likely. If you could craft a collision based on the example provided, then I'd be really interested in seeing that.
"I accidentally my PHP installation and now Cthulu won't stop spamming my server. What do?"
*hypertext prepotato
Yeah, that's not how this works. /r/PHP needs to offer decent UX to users of New Reddit as well as Old Reddit and TBH I can't believe I just had to type that.
Let's assume that commit 3 wasn't a regression from 1, but something _related_ which was exposed by the refactor in commit 2 (e.g. a foreach loop using the wrong data, but in the refactor it was turned into a callback map). In that scenario it could theoretically be based on the original branch point of commit 1, but doing so would mean a race condition to see which gets reviewed and accepted first which causes commit 2 to have a merge conflict at some arbitrary time later (or vice versa). If commit 2 gets reviewed before the now independent commit 3 in that scenario, then commit 2 needs re-reviewed after commit 3 is merged upstream. It's not uncommon for merge conflict resolutions to result in errors after the fact so splitting it up results in more touch points and back and forth. This sounds like a flow that only works for teams that are constantly around at the same time and can stop whatever they're doing to do code reviews and address feedback immediately. Splitting a pull request up into such tiny chunks sounds like frequent interruptions in order to keep things moving, which seems like it would prevent people from regularly getting 'into the zone' and wouldn't work for remote teams across multiple timezones. As a general rule of thumb I agree with the article, and you, that largely unrelated changes should be kept in separate PRs, but the moment they look slightly dependent I'm fine with them being in the same branch (_up to a point_, there is still such a thing as getting too large).
Hypertato prepotato! 
Can you please report a separate bug (or rather, feature request) for this? Not being able to specify a signal handler on Windows does seem like a legit issue.
Only on CLI scripts but it's not mandatory
potato has consistent function naming and argument order.
&gt; grokking another developer's perl (or your own six months later) took a great deal of skull sweat. PREACH. &gt; &gt; I write php day to day, but for me python has taken perl's place as the language I use for "get a lot done with a little code" projects. I did this for a while before swallowing the Go pill. Might sounds odd, but Go makes a better PHP micro/optimization companion. 
&gt; if you have more than 50 requests per second and you only have one server, the business value of those requests alone mean you should have a more scalable architecture Bingo!
PHP with a Go sidecar has been remarkable for my team.
&gt; and one for Oracle. I've already added this to the initial issue: Oracle support might be integrated by default as the current version of instantclient 18.3 does not require the user to accept a license anymore. Those packages are now freely available here: https://yum.oracle.com/repo/OracleLinux/OL7/oracle/instantclient/x86_64/ 
Reddit is so much better with subreddit styles disabled. 
I've found this as well. While I have probably 20 different projects that I may need to switch between, I find I only work on 3-4 at the same time. Closing projects I am not immediately working on keeps Netbeans happy, and the Open Recent Project feature makes it easy to re-orient my workspace as needed. It's not perfect by any means, but it works well for me.
&gt; It would be perfect if you could set a different PHP version for each projects without having to edit the .env and restart Docker :/ FYI: This topic will be tackled once I've released the stable v1.0.0 most likely in Q1. Discussion around this can be found here: https://github.com/cytopia/devilbox/issues/146
You use CTRL+C to interrupted and halt execution of a running command line script/executable. The signal SIGINT is sent to the interrupted process, PHP has a way to catch that signal so you can do some clean up tasks before the program ends. OP is pointing out that this does not work on Windows because it is not POSIX compliant. 
It's not just on r/php, I use other subreddits that also disable it, a rather silly move I believe that discourages intelligent interaction and discourse on whatever the topic of the subreddit is
Thanks for encouragement! Added [https://bugs.php.net/bug.php?id=77377](https://bugs.php.net/bug.php?id=77377)
That would be awesome ! Thank you !
A subreddit doesn't need to do anything.
Well written and easy to understand. I want to point out one topic that might be interesting to you for an upcoming blog entry of your series: Syncronizing file system permissions and ownership between host OS and Docker container directories. If you have mounted your projects from your host OS into the running container, any files created by the Container might have different ownerships if the services do not use the same uid/gid as you do on your local host OS. This part was very tough for me to tackle. Some more about it here: **[Syncronize permissions](https://github.com/devilbox/docker-php-fpm#unsynchronized-permissions)** I have no idea if this issue has already been addressed by Docker itself? Anyone knows more about this and what the current state here is?
If you want to do a quick comparison yourself without installing a bunch of different PHP versions, you could grab the [Devilbox](https://github.com/cytopia/devilbox) and start testing/benchmarking locally. It also includes a nightly built preview of PHP 7.4
Shortlist 3 or 4 languages you are interested in, then look at job boards to see what your career options are like. You should also ask yourself where your interests lie. If you love working on dynamic UI then PHP should be a secondary priority at best to learn. If you like working with databases and API’s then PHP is a fine choice. You should also rest assured that a lot of programming skills are transferable between languages so you rarely waste your time. If anything you broaden your knowledge learning multiple languages. For me I learned PHP 13 years ago for a hobby project. I have no regrets. Has paid the bills for the past decade. I periodically check job boards to ensure I am up to date. I have seen no shortage of opportunities working with PHP.
They hid the body field for New Reddit, there's your user experience. What more do you want?
Well, it's certainly an experience!
It is if you don’t wasn’t to call the file using `php`.
... and you're certainly a user!
I know how to use the web inspector but the one time I posted here I just thought this was normal or I was dumb (not used to post on Reddit). I'd say this is a bad UX but the reason behind this is legit in a way.
Old site design is so much better too, can't stand that new look.
I personally think it should not have been implemented in first place, I do comprehend that the PHP started as a way to embbed HTML code, but the whole thing should be PHP, let's say if you wanted to insert some non-php code you'd need to use some other tags like `#!/usr/bin/php &lt;-- optional shebang` `$myVar = 10;` `if($myVar == 10){` `&lt;?php &lt;span&gt;&lt;/span&gt; ?&gt;` `}` This is how I would have implemented the PHP tags thing.... &amp;#x200B;
Well it certainly murdered its competition considering it powers the vast majority of sites on the internet.
Lol wow those downvotes! Amazing haha. It's a joke. Because it hid the body. What's wrong with that? Lmao reddit.
You need a 15 years old StackOverflow account to be allowed to post. /s
Keep reading this as “hid the body in the field” 
It finds one or more of the preceding group of characters between the start and end of the line...I believe. Looks to be just about any character though, only missing a few specials. Bookmark this tool: [https://regexr.com/](https://regexr.com/)
You should have seen a post like this in /r/PHPhelp a few weeks ago. Person said they wanted a full login system, private CMS pages, etc. from scratch. When asked what work they had done/what their specific question was, their response was "why can't someone just do it for me." I can only imagine the ridiculous set of questions we'd be getting. 
From the beginning to the end of the string, the only accepted characters are alphanumeric, dashes, underscores, and periods. &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). A good rule of thumb is that if you're asking how to do something, instead of why something's done, or how to better do what you're already doing, you're probably asking for support.
It means the string must start with (denoted by the `^`) and end with (denoted by the `$`) all the characters (sets) within the `[]`. So it must be alpha-numeric including hyphen, underscore and full stops (escaped using `\`).
The string to check contains only one or more upper-/lowercase letter, digit, "-","_","." gut nothing else
Man, I wish I had this guy's outlook on life. Imagine how easy it must be for them, maybe born in a rich family, surrounded by maids and servants, that every whim and wish just happens with zero effort. Either that, or they're morons.
Oh sorry my bad I will deleted now 
I don't see how one PR per commit would be any more problematic in that scenario than having all three commits in one PR. If anything, with the latter, there's a higher risk of the regression not being caught (assuming a lack or complete absence of automated testing) before the whole set of commits get approved and merged. As for team feedback, I disagree. The smaller and more focused the scope of a PR is, the fewer people (in theory) who should be involved in reviewing it, and the sooner it can be accepted and merged. Conversely, a monolithic PR is more likely to tie the hands of more people at the same time (or at the very least take the same number of reviewers longer). You might be right about frequent interruptions depending on the project and team, but in my experience, when there are multiple related commits touching the same area of code (as in your example), they're more likely to be PRed at the same time regardless. To some extent, the problems solved by the "one commit per PR" rule can also be solved by reviewers reviewing each commit in isolation (by viewing its diff separately) before making an overall judgement, but at that point the PR might as well be split anyway. I think ultimately it's a good practice to adopt, even if it isn't beneficial 100% of the time.
At least it's there on mobile.
so there is a requirement of front end proficiency in order to post to a back end language. yeah, that makes a lot of sense.
Microsoft does provide for signalling using the SetConsoleCtrlHandler API. https://docs.microsoft.com/en-us/windows/console/setconsolectrlhandler The signal is sent on another thread as you'd expect, but I expect PHP already has something in its internals to queue interrupt-like callbacks for the Posix side. 
[https://editorconfig.org/](https://editorconfig.org/)
Hi can someone make me a Facebook but with better features and so I make more money than them just make a better one for me thanks also I can’t pay you but it’ll be great exposure and I will let you put it in your portfolio thanks also don’t forget it needs to be better than Facebook too thanks I need it by next Wednesday thanks 
But instead of blue we're going to make it green, because I read green attracts more visitors than blue. Also, I can only offer you 5% shares of the company because I came up with the idea and I chose the green color, so I have to make sure I make a profit off of this which is why I can't offer you any more. Also, I came up with a great name for it it's now going to be called GreenBook because green is the main accent color (it attracts people to the site.) Thanks ^Subscribed ^to ^/r/PHP ^five ^minutes ^ago
I don't mind the new style, but it's buggy AF so I've gone back to the old. 
This Microsoft API has nothing to do with posix. And it doesn't matter if PHP internally uses it, fact of the matter is you can't use it in user space
Perhaps I was not clear enough in my post. I was saying that the Windows API does provide means to handle signalling, and therefore it would not take a great deal to add. However, as it is dispatched on a new thread, it would need to work with PHPs own internal queue, which must already exist for ticks and the POSIX implementation of signal handling.
A bit on topic, I don't like serverless because it's expensive as f*ck, I am a coward but I am greed. https://www.youtube.com/watch?v=-71uqV0LHag 
WTF, why are they giving 58k to malware-infested FileZilla?
How good the progress of php is compared to nodejs in recent 2 to 3 years ?
Because it's used heavily I assume.
I strongly suggest not to use for a project. If you want to learn basics and such, yeah give it a look. Upgrading is gonna be a pain, because everything will break and you will have to wait for the developer to "upgrade it"
I'm building a library catalog for all of my books using HTML, CSS, PHP and MySQL. I would like to be able to add pictures of the covers when I display the book information. What is the best way to deal with this? Should I input the photos into a database or store them on the server? If the latter, is there a way to label the image so it is associated with the specific database entry when it is saved?
This is certainly a comment thread
The easiest way is copy image in with a hash for the file name (stop collisions/overwrites) then put the path to the file in the database entry. Then you can just pop that into the image tag for presentation.
That won't bog down the server? I will have over 100 hundred books in this database.
Not even close. Having them in files is easier on smaller servers, large numbers of files isn’t a problem.
Thank you, I've been scouring the internet for a proper answer for a week. I appreciate it. 
yep. there were 2 versions, as stated on php.net it was changed later but good try
you are right about something other than the topic. PHP did st
good try? what exactly do you think I was trying to do lol..
I really hate this mindset. Being a “back end developer” shouldn’t be an excuse for ignorance. Sure, specialise in a single field; but don’t call yourself an &lt;anything&gt; developer if you can’t be fucked learning anything outside your little walled garden I’m not trying to gatekeep here, but we’re in a field where you need to be constantly learning new and related info (which is primarily why front-end is a separate field now). Pretending that back-end developers shouldn’t need to know how to use dev tools is just silly 
How is it "trustless" to post straight to the Atomicpay API?
according to your logic the fact that you're a programmer is no excuse for you not having a working knowledge of how to perform heart surgery on a horse. that said you're whole rant was a bit off topic. were not talking about what defines a programmer (let alone your personal opinion on the matter). rather, the topic is about who can post on a public reddit. there are no rules that I'm aware of stating only programmers can post here.
Hello and welcome to Reddit, I see this is your first post and want to help you out, so have an upvote on me :)
You can strawman me all you like, but it doesn’t change the fact that no backend developer should have zero knowledge of frontend (especially considering we were all just webdevs 10-15 years ago) Both of our comments are off-topic: your complaints about the matter are no more relevant than my response to them Something being a “public reddit” doesn’t entitle you to do what you like on it. Rules and UI modifications don’t have to be mutually inclusive - that’s at the mods’ discretion. Nobody’s actually saying only programmers can post here (except the person you replied to, who was purely speculative) But the fact of the matter is that this is a discussion forum, not a support forum (as per the rules). If this sort of soft block reduces the amount of trash content on this sub, then so be it I just don’t understand who’s posting privileges you’re defending in all this (and it doesn’t help that you’ve moved the goalposts from front-end vs back-end to programmer vs non-programmer). I can’t imagine a case where a non-programmer would have enough interest in a specific programming language to contribute anything useful to this sub. Most of the beginners are just posting support questions (which, again, is against the rules). And most experienced people are either using dev tools or just putting the body in a comment
lol I've obviously struck a nerve
Not at all, I just don’t understand why you’re so determined to advocate for ignorance
I'm not. I'm sorry if you're having a hard time understanding the point.
I can’t really understand the point when you don’t have one to begin with
lol ok. thank God for the downvote button right. without it you might feel powerless. 
I’m not downvoting you. I pretty much only downvote spam, and I like it when subs disable the downvote button in CSS. Of course, if that happened in this sub, you’d then start whinging about how only front-end developers have the power to downvote, or some crap like that
haha you know me so well. 
Payment transaction and validation never happens in the API. It happens on blockchain. POST is only creating an invoice with minimum parameters and no sensitive data
So. How does I mvc my potatoes?
Can you point me at where in the codebase this happens? I've been reading through the source and I don't see much more than a curl() command.
That's because cryptocurrency payments are processed trustless via blockchain. From the very second A makes a payment, the TX is publicly available on the blockchain, the tx is picked up by miners in a decentralized model and confirmed on the the blockchain. That's trust less validation without requiring any third party intervention. The codebase for plugin does not include our proprietary payment back-end. It is open-source as a model for developers to explore how we build and integrate payments into third party platforms
Interesting. Though I am not planning a next blogpost on docker but would look at it for knowledge at least. I am more planning for K8s.
So to be clear, you're saying there's no code in this module that actually processes a payment on a blockchain?
This article is absolute trash
You’re like 20 years late.
There is no code that processes payments on blockchain because no external code can process payments on blockchain. Payment is processed by the chain itself and the chain codes are open sourced. Do you know how payments on blockchain works? Here is a read on blockchain process: [https://www.cnbc.com/2018/06/18/blockchain-what-is-it-and-how-does-it-work.html](https://www.cnbc.com/2018/06/18/blockchain-what-is-it-and-how-does-it-work.html) &amp;#x200B;
We seem to be talking about a blockchain as if it's magical. If someone is using Opencart or Magento or whatever, it absolutely does involve code in that application to get a payment onto a blockchain. It doesn't just appear there.
"Getting" popular... Mate, for real?
The payment is initiated by the customer who is paying the merchant. It does not require AtomicPay to be part of the process. Payments do not go through AtomicPay, neither does AtomicPay holds on to any funds of merchants. Indeed, blockchain is magically
I know it's a joke, but not having body doesn't prevent you to post
Conclusion: Nothing to read. This is just another self promoting blog post aiming at page view and impression. 🙄
What I use FileZilla, what malware??
IIRC, the installer has/had some malware injected because the site used to host it went shady
Also refuses to store credentials with encryption. All your saved connections are stored in plaintext on disk ready to be stolen.
Or turn off the subs style. It's a checkbox in the side bar. 
Well, let's hope that can be fixed,now.
Seems I was wrong. He finally gave in after someone forked FileZilla and implemented it himself. https://www.bleepingcomputer.com/news/software/filezilla-ftp-client-adds-support-for-master-password-that-encrypts-your-logins/
yeah, no.
I agree. No fun allowed.
Long Live PHP 5.
Learn Clojure/Datomic/Hyperfiddle Why? No N queries being a performance nightmare Query results as arrays with nesting No SQL injection (different APIs between read/insert) Reads Horizontally scalable No cache invalidation (infinite TTLs) System versioned attributes by default Attributes of entities are grouped at query time not insert time Easy recursive queries Immutable down to the database Data as graphs not trees in backend and frontend, with full querying ability at both ends Same language front &amp; back AWS native Paid more
How the fuck is their shit so poorly designed and untested that if you're looking at the "new design" without being logged in, and you log in to an account that has "old design by default" set, that the fucking login div just turns into a fucking frame that shows the old design, while the new design rests in the primary body?
Yes. PHP5 is dead in 11 years when Wordpress 59 finally drops it, and is renamed to Wordpress 70... :D ;)
&gt;Also refuses to store credentials with encryption. All your saved connections are stored in plaintext on disk ready to be stolen This is because the credentials are then sent over FTP which is insecure and anyone can read the network traffic making encrypting, to decrypt them and then send them over an insecure socket a pointless task.
&gt;The main point is you need to get yourself to a place where it does not really matter what tech is used in your field - you can switch pretty easy in a month and be properly productive. This is the key take away point here, the majority of other posts seem to have missed the biggest point. The language is mostly irrelevant it's the transferable skills in computer science that matter and your prospective job market. PHP and C# are the dominant languages in my local job market so it makes sense to learn them. To say 'should I learn language x' is a pointless question, it completely depends on the project and your local market. I love using Rust but there are 0 Rust related jobs in my area so it probably wasn't worth learning it for income reasons but at the same time it made me a better developer in other languages.
&gt;Quick nitpick: &gt; &gt;The general rule is to only validate your input, and only sanitize your output for the specific system that you're outputting to. &gt; &gt;Sanitizing input creates a false sense of security. Although this is a great general rule of thumb to follow when handling user inputted data being saved somewhere I think sanitizing is the correct thing to do when making alternations to the file system. There isn't really an 'output' stage he's simply using user input directly to make alterations on the file system, creation and deletion of folders. In this case, sanitizing on input is the only way to protect yourself.
I read a few tweets from Wordcamp US that they are actually planning to drop support for PHP &lt; 7.1 entirely, perhaps in 2019. Either that, or I'm dreaming. 
The more screaming we hear from mysql_*() people, the better. 
The immediate effect seems to be a lot of sites with calls to the deprecated mysql_connect aren't working.
Yeah but we all know how their plans go... how long was Gutenberg delayed?
They fucked up their entire session tracking system in fact. I'm constantly just randomly logged out. Especially on mobile using i.reddit.com
but... but... “I built my system using Stackoverflow posts from 2007.”
https://twitter.com/miss_jwo/status/1071540985702825991
Now I finally have arguments to convince my boss to rewrite that legacy system we still use... Or use a totally different one.
Ah good old SOOP (StackOverflow Oriented Programming). 
I you were using Laravel I'd recommend [Spatie's Media Library](https://github.com/spatie/laravel-medialibrary) package
Unfortunately, distro package managers will practice necromance on its corpse for years to come. Especially CentOS/RHEL, which STILL comes with 5.4. How is violation of graves on such magnitude even legal?
I believe they'll grandfather PHP 5 around the same time Gutenberg gets a stable release
Are they still a thing? At the very worst, my screams are usually "*How many* mysql_ calls do I have to rewrite?"
Nice, but Shopify is a SaaS platform, not self-hosted.
It means there's going to be a lot of officially unsupported versions of PHP running for the next 3 or 4 years. Also means someone is going to make a lot of money backporting fixes.
In case people don't read beyond the linked tweet: &gt;My bad as @TacoVerdo pointed out it's PHP7 rather than 7.0. &gt;Talked to the team and we could aim for PHP7.2. 
That's my next step after I get a little more practice in regular ol' PHP.
Debian will be supporting 5.6 until we have self-driving flying cars with enough battery life to take us to vacation on the moon.
Maybe we have different definitions of dead. Companies will still run it. Red Hat will still support it (CentOS 6). Other vendors will still support it. 
Good luck. It's only taken me 5 years to convince them to consider it. 
That's why I use Ubuntu. Haters gonna hate.
3 years for me to start rewrinting our cms 
Its also ruby, not PHP.
Exactly. And the answer is "none, because it will not make us money, you do bugfixes and features!"
Funny thing is stackoverflow admin thing post that old is still valid lol 
Debian ftw 
The idea was to run the exact same test on different hardware that I have, and compare with the hardware that I don't have, and see if it's worth the upgrade.
Just replace mysql_ with mysqli_, amirite?
Medium seems to be full of shitty articles..
Hey dude. That's my article. lol.
What's going to be really awkward for this post is when we release one last version on Thursday because that EOL date was more of a rough target than a hard line in the sand. ((Not speculating, there WILL be one last 5,6 release on Thursday))
The definitions I'm using for validation and sanitizing are: Sanitize: To change to a safe(r) format. Validate: To make sure that it is valid. The way I'm using the terms in this specific use case is, if the file to be deleted is not valid, then reject the request. I really don't see how there could be a "sanitize" option, unless you escape any directory traversal sequences (`../`), but I'd personally just reject anything that isn't a straightforward, explicit name of a file within the exact resource directory that the authenticated user is authorized to delete. (And yes, this last bit is me making note that the wiki software being examined in this thread does a terrible job at authentication and authorization, as well as validating and sanitizing...)
The door is *that* way. Please leave. :(
So my first words of 2019, PHP 5 is dead, are going to be a lie?
Not a lie, just premature.
rumours of my death are greatly exaggerated? :)
...and that's how systems get stuck on PHP 5.x -- until the inevitable breach happens and management starts screaming "WHY DIDN'T WE UPGRADE?"
Quick, travel to USA, say more things!
I was reading "humours of it's death..." and got confused and lost in translation.
My statement was based on https://secure.php.net/supported-versions.php not whether or not there'd be one final security release. It's just, unless the distro does a backport, the 0days that drop *after* that final security release are hella yolo.
Indeed. The *official* last day of support is today. Just wanted folks to not be surprised when the release drops on Thursday.
As a civil critique.. No mention to interactive debugging to bring some light to how the code works and flows. Just chasing files and read code without the help of a debugger. Seems odd to me
https://twitter.com/debcha/status/829623063666970625?lang=en
In 2019, just [delegate the rewrite](https://github.com/rectorphp/rector/blob/master/config/level/php/mysql_to_mysqli.yml).
Or, you can do it for free with [Rector](https://github.com/rectorphp/rector/) and sell it to your boss at convenient price ;)
I wrote this [a couple years ago](https://paragonie.com/blog/2016/04/go-php-7-our-commitment-maintaining-our-open-source-projects) about the open source projects my company maintains.
Does anyone know how reliable those patches provided by distro package managers to EOL PHP versions actually are? (I'm guessing it's just a best effort approach)
And my paid web host only offers PHP 7 as an *experimental* option. 
There must be 200 off the shelf CMS (maybe 12 that are PHP 7 ready) - why not leverage one of those instead of writing your own? Just curious?
The old battleship really will turn! (eventually)
Thanks for the link! I've never heard of Rector. I'm going to have to try it on some old PHP applications at work.
Not when I go back to work it’s not
&gt; Is there any reason to choose one over the other? libsodium is easier to use and harder to mess up with. With OpenSSL you can choose an out of date encryption algorithm and neglect to do authentication, etc. These are mistakes you can't make with libsodium. BUT... if you need to be inter operable with an existing protocol or format then OpenSSL may be the only option. libsodium doesn't do aes-128-ctr nor does it to RSA, for example. &gt; Which, if any, is more future proof (least likely to be deprecated/replaced)? Probably OpenSSL. OpenSSL was initially released in 1998. That's 20 years ago. NaCl was released 10 years ago. So OpenSSL has more inertia behind it. But more than that, because OpenSSL lets you pick and chose your encryption primitives that also means it's not locked into crypto primitives like libsodium is. Like `sodium_crypto_box`... that implements ECDH over Curve25519. But what happens if a newer better curve comes along? What happens if a vulnerability is found in Curve25519? With OpenSSL you just select a different algorithm / curve and bam, you're done. With libsodium... if they make `sodium_crypto_box` use a different curve they'll break backwards compatibility. &gt; Has anyone done any performance benchmarks? Both are super fast. But that said, performance benchmarks can be misleading. Sometimes, in the blind pursuit for speed, timing attacks can be introduced. Certainly the severity of timing attacks can be debated but the point remains that speed is probably not the only benchmark one should be looking at. I'd also expect both to be immune to timing attacks but my gut feeling is that libsodium probably does a better job at being timing attack resistant then OpenSSL.
Great! If you've got any troubles, just create an issue. Rector can provide great income for people working on legacy projects (and fun :)).
I can't believe it's been 3 hours since you of all people called something premature and no dick jokes were made. This is what keeps me worried the whole last day of the year &gt;&lt;
Thanks for the lengthy response. Exactly what I needed to know! :)
isn't Gutenberg stable as of WordPress 5.0?
Pretty much. I don't get what the big deal is. Just do a global find and replace and adjust one or two things and viola.
Tangential to the main article of this thread, but re: the `mysql_connect` problem, I've found this drop in replacement useful when poking at older projects that still use the `mysql_*` functions. https://github.com/e-sites/php-mysql-mysqli-wrapper
What's the better way, seriously asking.
I wish. 
PDO
It depends on how much use it gets and how many developers are capable of caring for it I guess. Both become less over time, but then again, it's not like the codebase needs expanding, only fixing. The patches are generally pretty high quality I'd say, but may take a while to be created. PHP &lt;7 is a pretty big dependency which is used in quite a few places still, so for now it's not that bad to still run it IMO. Just don't expect any type of 'real' support.
You can't just rename it. There is different parameter order. You must provide connection handler to eg. mysqli\_query() if using functional way. [http://php.net/manual/en/mysqli.query.php](http://php.net/manual/en/mysqli.query.php)
Thatsthejoke.jpg
tagged on the 8th, announced on 10th, delayed the schedule a week to make sure people are back from the holidays to upgrade.
But you can just let [Rector rename it](https://github.com/rectorphp/rector/blob/master/config/level/php/mysql_to_mysqli.yml) :)
This appears to be a favourite subject at Paragonie since they write about it a lot. [A recent guide](https://paragonie.com/blog/2017/12/2018-guide-building-secure-php-software#secure-php-cryptography) for building secure software says to use sodium and references [another guide](https://paragonie.com/blog/2015/11/choosing-right-cryptography-library-for-your-php-project-guide) specific to choosing a cryptography library. Compare https://github.com/paragonie/halite/ with the OpenSSL example at https://paragonie.com/blog/2015/05/if-you-re-typing-word-mcrypt-into-your-code-you-re-doing-it-wrong#title.2 - Sodium-based Halite lets you get the job done without a PhD in cryptography.
You can probably use Google's books API, let them worry about serving all those images.
Probably by finding serious vulnerabilities on 5.x until they don't get patched.
Prepared statements. But you really should be using something like Eloquent.
don't think its production ready yet.
I'm doing this for fun.
Agreed. Last I checked there was no debugger available.
I love to read Scott's posts, so I'll be checking these out later. Thanks!
I understand, but you might get some nice metadata for free as well. How are you going to get all those images? Doesn't sound like much fun.
I figured a google search lol maybe you can explain to me what you have in mind
Look at the numbers... it is far from dead. Alive but unsupported, soon. 
Long live PHP 4! He he.
It’s ok, 5 has been dead in my heart for years :)
That kind of speed doesn't matter for 80%+ of the php codebases out there (or other solutions exists), and the cons are not unsignificant, so... Some usage, sure, default stack, I don't think so
Hacking your webserver, that's what..
Sounds remarkably like a shill post.
I learned PHP basics back during the PHP 4 days, and I've been using it on and off to make simple projects for work and personal stuff. My workflow is chaotic and lacks organization. I've "learned" object oriented PHP like 4 times but never put it into practice. One of my new years goals is to get back into web development, mostly as a hobby but I do have some project ideas that I lack the skills for. Modern PHP might as well be a foreign language, and I would like to learn it properly. Since a lot of my problems arose from poor organization I was suggested a handful of libraries to learn (Laravel is the only one that comes to mind), but they all seem very daunting. &amp;#x200B; Where should I go from here? Should I just wipe the slate and start from the beginning? A friend of mine directed me to Laracasts, has anyone used this in the past? ([https://laracasts.com/skills/php](https://laracasts.com/skills/php))
Honestly, I'm of the belief that PHPMyAdmin has run its course and that there's no good reason to use it anymore. Change my mind.
The Tutorial List will be ready by the moment I can acquire a Gaming Headset with Mic; For the Live Feed. Once I acquire that by after January or before January ends; Don't forget to Subscribe to my YouTube Channel for Several PHP Extension Tutorials; Including a Login / Signup PHP MVC Framework Tutorial. I will ready myself for later assessments because the Delivery schedule for the Gaming Headset is still on going. Good Luck finding the Tutorials yourself if you find any of it quite intriguing. :) - Snowflakes, Peace Out.
Debugger and production ready are two different stories. 
Tip : use PHPcc to check what's preventing you from upgrading to 7. 
What the hell did I just read? Did you have a stroke as you typed this out? Too much new year's drinking?
The first crappy article of the 2019
You read that wrong. xD
...or you can [upgrade code instantly with Rector](https://github.com/rectorphp/rector) and make money that way :) 
You can upgrade `mysql` → `mysqli` with [this Rector set](https://github.com/rectorphp/rector/blob/master/config/level/php/mysql_to_mysqli.yml) in a matter of minutes.
There is nothing to enforce PHP 7+, except server providers dropping it and breaking the code :), but as a developer, you can spread the word: - [PHP instant upgrade in Rector](https://github.com/rectorphp/rector/tree/master/config/level/php) - [Go PHP 7.1 initiative](https://gophp71.org/) - [PHP versions stats by Composer](https://seld.be/notes/php-versions-stats-2018-1-edition) 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Their Docker support leaves to be desire. If they spend more time updating their docs or even provide an official Dicker image more people will try it
Just do this: [https://www.amazon.com/Neewer-Condenser-Microphone-Suspension-Mounting/dp/B0758DRMVQ](https://www.amazon.com/Neewer-Condenser-Microphone-Suspension-Mounting/dp/B0758DRMVQ)
&gt; You can also do multi threading Can't wait to see event based code mixed with threading in an application.
Dicker 😂
Maybe for you, but I do not share that opinion.
You should be careful releasing 0 days like that - [you'll be reported to the police](https://github.com/opencart/opencart/issues/3721#issuecomment-164263613)! /s
&gt; PHP's tmpfile() implementation doesn't remove file on SIGINT that part is a bug.
Quoting from 7.19.4.3 "The tmpfile function" of the C99 standard: &gt; If the program terminates abnormally, whether an open temporary file is removed is implementation-defined. PHP just exposes functionality of the underlying C library here and behaves however it behaves. The bug here is that PHP provides no way to terminate a program normally if Ctrl+C is used on Windows, not the behavior of tmpfile().
Thankfully the vulnerability only affects `&lt;a&gt;` link destinations but everyone should still update anyway. Thanks for spreading the word!
r/phphelp
Order by cannot be before your where clause.
I think Order by has to go after the where
`order by` before `where`
Also, deleting your question after getting your answer is a douche move...
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Thank you so much! 
&gt; I'd also expect both to be immune to timing attacks Nope! From 2016: [A Timing Attack on OpenSSL Constant Time RSA](https://eprint.iacr.org/2016/224.pdf). &gt; but my gut feeling is that libsodium probably does a better job at being timing attack resistant then OpenSSL Correct.
A buttload of PHP 5.2 projects never used composer and thus composer stats are hopelessly positively biased.
For something like this, you should render as much as possible on the client side. However, you should never, ever \*trust\* the client side. &amp;#x200B; That timer that lets you attack again? Anyone with a bit of knowledge could type a line of text into the address bar and instantly trigger it, so obviously you don't want to let that be the deciding factor. &amp;#x200B; Instead, when they send a command, you should verify it server side, and if something is amiss, send back an instruction in the response saying how long they still have to wait, and have the UI update itself to reflect that in case things have got out of sync (for example, if they double-submit something, a race condition occurs, or they have multiple browsers open). &amp;#x200B; PHP (at least in FastCGI mode) doesn't deal with threads as you would normally think of them. Instead the server just spins up however many PHP processes it needs and uses those completely independent of each other.
so if I understand this correctly, do everything client side, but also use the server as a soul point of truth?
Yes. Unless the calculation requires some kind of secret data, for example RNG or another players private stats, then do it server side.
[removed]
&gt; Awar Good news! PHP 5.2 is the least supported version - https://github.com/nikic/PHP-Parser#php-parser
Another thing, instead of pooling, better use a websocket if you need to process a lot of info fast 👍
Isn’t working with Magento lovely /s
[removed]
Can you elaborate more? What are you using Go for in your PHP apps?
Yes. You have to embrace the idea that "any client can LIE to the server" because that is what cheaters will do/try.
Ohh looks pretty nice :) I didn't know it. Thanks :)
It's not always that simple, you know that.
Check out "Server-Sent Events" &gt; One reason SSEs have been kept in the shadow is because later APIs like WebSockets provide a richer protocol to perform bi-directional, full-duplex communication. However, in some scenarios data doesn't need to be sent from the client. You simply need updates from some server action. [Source](https://www.html5rocks.com/en/tutorials/eventsource/basics/) Basic concept here: https://www.reddit.com/r/PHP/comments/9vwm0d/refactor_your_slow_form_using_php_generators_and/ 
It's never simple. This makes 80 % of repeated dumb work disappear and lets you focus on the important work.
That's entirely true!
 Slim a PHP micro framework, web application initial set up. 
Basically, anywhere the PHP app is taking a big performance hit (due most often to lack of concurrency), Sometimes its just a particular API endpoint that just gets a lot of big requests, and it's the "slow part." So rework the endpoint in Go, Haproxy it, and drop the PHP endpoint. Nice little optimization. 
This is more about crappy versions for a certain dependencies. Who tags dependency versions as `100.2.*` instead of `^100.2.3`. Composer packages shouldn't use semantic versioning anyway.
&gt; Who tags dependency versions as `100.2.*` instead of `^100.2.3` People with little grasp of how to effectively use dependencies with a package manager. &gt; Composer packages shouldn't use semantic versioning anyway. Why on earth not? When used correctly, SemVer is one of the most powerful ways to keep software up to date without any interruption. If Magento has genuinely made over 100 separate releases with breaking API changes, that's a problem with the software, not with the versioning scheme. And if they haven't, then they shouldn't be surprised when a semver-based dependency solver can't solve non-semantic version numbers. 
&gt; Why on earth not? Because my phone says so. It was an autocorrect. I'm very much pro semver.
I like the word hypertato
 function change\_img(linkHD, link){ var checkBox = document.getElementById("myCheck"); if (checkBox.checked == true){ document.getElementById('image').src = linkHD; } else { document.getElementById('image').src = link; } } I display 10 images on my page using smarty `for Each` How I can make work my above code so each checkbox trigers right image?
try /r/LearnJavascript . This is not PHP
This looks like JavaScript. Please post for help in /r/JavaScriptHelp for PHP support please post in /r/phphelp 
wo? you can have only 1 id in document :) document.getElementById() returns only 1 element, if you have multiple same ids, then the 1st is returned. Use HTML classes instead and then document.getElementsByClassName(), this will return HTML collection and you can loop over that.
&gt;Because of this Fusio has no model or entity system like many other frameworks, instead we recommend to write plain SQL in case you work with a relational database. We think that building API endpoints based on models/entities limits the way how you would design a response. Where does your business logic go? This seems like a hack where you bypass the application and just extract whatever you want from the raw db.
yeah. you can use swoole with laravel. &amp;#x200B; [https://laravel-news.com/laravel-swoole](https://laravel-news.com/laravel-swoole) &amp;#x200B;
You are correct. I made a mistake there, will cross it out. Still that fact that a ban was even considered makes me uneasy. I still feel there is something wrong/risky about having the Code of Conduct though, but (laying aside the points I've argued above) I can't form a good argument for why I think that.
Do it in the domain layer. Write services that do what you want with the data. 
I tried the multithreading part, didn't go so well... Ended up with bash exec
Well technically it didn't die, just retired. It will probably take some cruises around the world and visit all the places it couldn't when we relied on it everyday. 
It is used by many sites like Baidu Search and Baidu Maps, even alibaba uses that. It is not a shill. [https://discourse.zendframework.com/t/expressive-swoole-vs-node-js-express-js/439](https://discourse.zendframework.com/t/expressive-swoole-vs-node-js-express-js/439) &amp;#x200B; [https://github.com/swooletw/laravel-swoole/wiki/1.-Introduction](https://github.com/swooletw/laravel-swoole/wiki/1.-Introduction) &amp;#x200B; It officially supports Co routine based asynchronous programming &amp;#x200B; &amp;#x200B;
I find keeping your PHP code as simple and to the point as need be. To anyone here saying "so and so framework is secure", you can easily make them insecure as a coder as you can a single page script. Just keep testing, everything and every way you can. Good Luck !
Your reply isn't making it would less like a shill post...The problem isn't that Swoole is unheard of. It's that your post doesn't sound balanced or caused by normal exposure. To your credit, you don't appear to only post positively about it, so you're probably not a shill. 
" There is no other language getting close to PHP when it comes to the usage of words like “crap”, “fuck”, “hate” or “shit”: " -- And that is why I call it "Home" 
Then what's the point of the API? Why can't these services get their data from the database?
`final` in Java properties is not the same thing as `final` in PHP. The reason why Java uses the `final` keyword is because [const is a reserved keyword and is not available in Java](https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4211070). `final` properties in Java are almost synonymous with PHP, C#, and C++'s `const` keyword. When you declare an object property as `final` in Java, you must initialize it. There are some subtle differences, but for the most part if you want to use `final` properties, then you're looking for constants in PHP. Just remember that visibility modifiers for class constants [was only introduced in PHP 7.1](http://php.net/manual/en/language.oop5.constants.php#language.oop5.basic.class.this). Looking for `final` methods? That's a little trickier. If you don't want subclasses to modify your method(s), then either declare the method itself private or make the class final. I can't think of a good reason (at least in PHP) why you would want to mark a single property or method as `public`, but make only that specific property or method unmodifiable by subclasses. To me, that seems like an architectural flaw.
Pay someone else to make it for you.
Start with html and css. The Mozilla Developer Network (which is my go-to site for a lot of webdev info) has a [great getting started guide](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web). CodeCademy seems to be popular too.
If you're referring to how final properties work in Java, it's because PHP object properties cannot be made immutable (yet). There is an RFC to add this to the next version of PHP: https://wiki.php.net/rfc/immutability However, this will introduce a new keyword, `immutable`, instead of overloading the `final` keyword. If you're thinking about extension, where only the parent class is allowed to modify the property but all subclasses can read it, what would be the use case?
usually the api (or cli, or any interface to your business model) would use the domain layer. this, seemingly by design, lives next to your domain and does whatever it wants regardless of your domain.
Nice. I am a fan of this framework, and this is a nice step by step. I would however do something with docker too (next to vargrant) and perhaps do something on a plain localhost. Keep this up!
Just noting that Java's behavior, where you can initialize a variable but not change it once initialized, is being proposed for a future version of PHP: https://wiki.php.net/rfc/immutability However, this will introduce a new keyword, `immutable`, instead of overloading the `final` keyword.
Been trying to find that guy and keep getting scammed.
Thank you very much for the info. I am starting and lookign at this now. I realy need to find a good developer to help me.
Hey, Corrupt9930, just a quick heads-up: **realy** is actually spelled **really**. You can remember it by **two ls**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
hEy, CoRrUpT9930, jUsT A QuIcK HeAdS-Up: **ReAlY** Is aCtUaLlY SpElLeD **ReAlLy**. YoU CaN ReMeMbEr iT By **tWo lS**. hAvE A NiCe dAy! ^^^^tHe ^^^^pArEnT ^^^^CoMmEnTeR ^^^^CaN ^^^^RePlY ^^^^WiTh ^^^^'DeLeTe' ^^^^To ^^^^dElEtE ^^^^ThIs ^^^^cOmMeNt.
Building a custom e-commerce site is not for amateurs, there's so many considerations to make and pitfalls to avoid. For a basic custom setup you can expect to realistically be paying $10,000+ minimum from a reputable source. 
[Lynda.com](https://Lynda.com) is where I'm starting to learn its nice to see and do the work as well but if you aren't currently enlisted as a student in some university or a big city (for those in Highschool and younger) you can try to find a free course on udemy but Lynda has it a bit more "standard" to it. &amp;#x200B; But if you're balling and are into online courses to follow Pluralsight is by far the best that I've seen / been recommended to.
Yes I just paid $15,000 and the guy scammed me. He made me a site but couldn't finish. I am looking for a guy now or trying to learn.
How much is balling?
Thank you! I looked in the list of proposals, but missed this one. 
Bagisto is an Open Source eCommerce Framework built on Laravel. Unlike the traditional eCommerce Framework which is almost solved using plugins and extensions, Bagisto offers [Multi-Warehouse Inventory](https://bagisto.com/why-ecommerce-must-have-multiple-warehouse-inventory-system/) which forms its core feature. It enhances and builds complete trust with the customers by delivering goods with absolute reliability. We are moving toward building the Multi-Vendor Marketplace, going mobile with PWA, implementing microservices and support to REST &amp;GraphQL API. We will also be introducing Product Types like Booking and Subscription/Recurring, Dropshipping and Web-based POS. Bagisto has successfully caught the eyes of Laravel Community around the world and within a period of 1 month, we have gained more than 100+ stars on [Github](https://github.com/bagisto/bagisto). With the code-driven approach and tech stack comprising Laravel and Vue.js, developers can easily build their own code on top of it and can change/add anything they want bcoz of fully customizable structure and the mindset with which Bagisto was made. &amp;#x200B;
I would suggest you look into legal recourse if a contract wasn't fulfilled... you did have a contract... right? Regardless, based on your posting history, asking on here for help in setting up " The biggest and most trusted darknet market that has exsisted" is probably a bad idea... and I assume the FBI has already started monitoring your account :-)
Something seems fishy. &lt;&gt;&lt;
So it always depends on your case if a request modifies the state of your database you most likely want to create a service which contains the business logic to validate and trigger specific events. If you only want to select data for a certain view it is also possible to simply fire a query and return the response as API response, this is really fast and in some cases useful. If you have some more complicated aggregation logic you can also use your business logic layer to return the response. So basically your business logic goes into a separate class which you write by yourself and which is independent of the framework, so it could be reused also in another context.
I'm not worried about that. I am anonymous and on TOR. I have a proven track record and looking for help.
Before than spending the time and effort to write your own site, have you considered using something like [Shopify](https://lifehacker.com/how-to-launch-your-own-online-store-with-shopify-1821330162) to set up your online store? This way you can focus on your business instead of the technical stuff.
Yes but my project is on the darker side of things.
Great, good luck on your journey! You don't need a good developer to become one yourself, but one could help push you in the right direction. Have a look at /r/phphelp for help with PHP, as this sub is mostly for the general discussion and the 'I made a thing' posts.
Thanks a lot man any and all help is always appreciated.
&gt; When you declare an object property as final in Java, you must initialize it. This statement is absolutely false. The keyword ensures that the properties are initialize by the end of the constructor. Two instances can have different values in their final property, this is not the case with const. This is frequently used with dependency injection. &gt; If you don't want subclasses to modify your method(s), then either declare the method itself private. Totally different since the method is not callable then, also it won't work if the parent method is e.g. protected. &gt; I can't think of a good reason (at least in PHP) why you would want to mark a single property or method as public, but make only that specific property or method unmodifiable by subclasses. You forget about protected and package private methods here again. 
that made me 'lol'
Regarding final methods, those are not difficult: just mark the method as final as per the docs: http://php.net/manual/en/language.oop5.final.php
299$ year 35$ month
I kind of have figured that a year is what I would need to perfect it. Do you think it;s worth paying or it can be learned alone? I need to just be good enough to make a secure market. But honestly do not know where to start.
If you really want to be good at php because if you want to create an online market learn HTML CSS and use Stride for payment processing what else do you need?
\&gt; So you don't just spam click attack, thus sending 50 requests back to the server making the server have to lag trying to process all 50 requests at once. You want to use a websocket + any pub sub system. I recommend redis. I've used this configuration for gamification to gain XP and level up. Works perfectly. &amp;#x200B;
 HTML CSS seems to be the way to go to start to learn?
Yep 
Thanks =)
Awww no, a SJW "fixed" something by pressing downvote. Don't stop here my crusader friend, fix the whole internet. And remember - always include your comment about WHY you pressed the down arrow, your opinion is so important that if you don't voice it properly - Earth might stop revolving.
It doesn't matter if it's read or write, just make the biz rule that no-one should see anyone's birthday, for e.g. Now you have to maintain this rule in your api *AND* in your domain/service/whatever you want to call the place where your business rules protect your model. 
What is this?
From the readme. "tus is a HTTP based protocol for resumable file uploads. Resumable means you can carry on where you left off without re-uploading whole data again in case of any interruptions." 
University makes you a *software engineer*. You will probably be happy with being just a *software developer*. You can become a good software developer on your own, just using internet. You can become the developer of the next Facebook by being just a software developer.
This sounded like it was an interesting question, but for some reason it was removed. 
The question was mostly restating the post title: is there a good reason that PHP does not allow final class properties?
I'm currently in beta-testing phase with swoole. We have many services (servers) that deal with post-processing or timed execution (we don't use cron but event loop's timer function). &amp;#x200B; The sole reason we went with swoole is the fact that there's the event loop interface available, which means I don't have to use outdated eventloop extensions that I had to patch up myself (and I did a lousy job). The added benefit is that it's fast. VERY fast. What I liked a lot was coroutine and how it ties in nicely with what I had to do. We use ZeroMQ for transport and many of these services listen on 2-3 ports (one for heartbeat, one for receiving data and the third for publishing or pushing data furhter). Using the coroutine and event loop made it a breeze to create services which bind to multiple ports. Yes, I could have multiplexed over a single port but I like to have dedicated pipes in services instead of one big pipe that chugs everything. &amp;#x200B; So far so good, the performance is nothing short of amazing but as I mentioned before - it's just sugar on top. The ease of using swoole and the fact I simply dropped it in and without too many modifications - our stack works and works well. 
While I completely agree with the existence of the problem, I'm fairly sure the proposed solution is in no way sustainable. PHP is driven by volunteers on all sides. We can't expect the level of moderation you are proposing. I'm myself actively marking these posts, but there are so many of them and in all fairness, when using the mobile app, the rules aren't even promoted when creating a new post. Even if the desktop was used, those rules are linked in really small text, which is obviously overlooked by the people of the level of writing those posts in the first place. I've been wondering if we could use a separate subreddit for actual PHP content and let this one be more open to help posts. It is /r/PHP and if I were a wee dev, I'd probably look here for help, in all my enthusiasm overlooking the rules of the subreddit. Especially if over 30% of the first page was already filled by similar posts. We could always let the posts from the new subreddit be parroted (not cross posted, for obvious reasons) to this subreddit. I would not suggest the new subreddit be an elitist one, but simply only promoted in the same section where the rules are now linked, creating a safe haven for those that did read the rules. Overall, while people might be really fond of the name /r/PHP, I believe my proposal to be way more sustainable. Please let me hear your thoughts on this, fellow community members.
Tells you everything you need to know about PHP community
If you understand blockchain technology, it would sound normal.
Nice, cheers 🎉🎉🎉
I retract my proposal, as the chance would be too great it results in segregation of the community and we would miss out on too much quality pieces.
I'm hoping for lots of Swoole usage tbh. Frameworks are supporting it already and more is coming. I think it will be a good path for the future of PHP.
Let's you resume file uploads so if you're uploading a large file and your internet breaks you don't have to start from the beginning. Think massive files. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Awesome tutorial. For those interested Bref v0.3 will be the new version based on the official AWS runtime API. It should be released in a few months, in the meantime you can follow [the pull request in the project](https://github.com/mnapoli/bref/pull/113). This new version will bring: - much better performances - official support for PHP (no hacky stuff with NodeJS) - support for PHP-FPM - tools for local development using Docker (running AWS Lambda locally as well as API Gateway, DynamoDB, etc.) - a new deployment process that integrates better with all of AWS tools
From my point of view, there are 2 points I really look for :) **AST** becomes a common way to work - with for legacy code-base - with PHP frameworks to make major BC breaks with zero-upgrade slowdown - migration from one framework to another would be simpler than ever before **Embodied knowledge** - There will be less responsibility in the know-how of developer, it shifts into the code itself - Tools like coding standards and PHPStan are just the tip of the iceberg of that is possible - This eventually improve developer happiness, speedup hiring juniors and their learning curve become steeper (faster) 
\- There's only little rule at the side of the screen \- There's no pinned thread \- The page for posting a thread doesn't even imply why the text body is hidden
Magento starts the package (module) versions at 10x.x.x to distinguish them from the actual marketing version of Magento as a whole (2.x.x).
Thanks man! Bref is awesome!
&gt; This statement is absolutely false. The keyword ensures that the properties are initialize by the end of the constructor. Two instances can have different values in their final property, this is not the case with const. This is frequently used with dependency injection. https://www.geeksforgeeks.org/final-keyword-java/ How have you been, Dracony? You still paying for fake stars on your shill project so you can pretend to be a part of the FIG?
Should have checked the PHP docs a little better. I completely missed that you could mark a method as final.
Unless they are using a proxy $_SERVER['REMOTE_ADDR'] should do it, you just need to create a method of storing that.
[removed]
The year is 2019. Method for obtaining user's IP in web context has remained the same for 2 decades. If you can't find how to get the IP of user-agent that's visiting your server via HTTP, then you're doing something very, very wrong with your browser and keyboard. If we ignore the obvious language barrier (title starts with ` Some you need to get visited users IP address`), here's whats wrong with the function: 1. Function in question uses `esc_attr` function, which isn't defined. Anywhere. It's a Wordpress function. You can't copy and paste this function and use it from project of your choice. 2. The name of the function is `psnippet_get__user_ip`. Why? What's wrong with `get_user_ip`? Why 2x underscore in the name? What's the rationale behind it? 3. Blogs written for google should be avoided. There's nothing worthwile on that link. Hell, you'll just end up with something you can't use. 1/10, wouldn't use. Ever.
&gt; AST My brain is only coming up with "Abstract Syntax Tree". What's this acronym?
Can node backend do this also? 
Have you even read the page you linked? It specifically says you can initialize within a constructor.
I'm sure if there is a TUS compliant package or something, sure why not. The protocol was designed not to be vendor specific
Hoping for the possibility to write PHP core modules with a mix of PHP &amp; C. Saw a prototype of it on the mailing list. Could potentially help core maintenance.
`Security::init();` oh boy...
&gt; When a variable is declared with final keyword, its value can’t be modified, essentially, a constant. This also means that you must initialize a final variable. Did you even bother to read the page I just linked? This is why nobody takes you seriously. Sit down and be quiet.
I did. You still absolutely worded it wrong.
Yes, you got it right!
\*Mighty yawn\* The question was about final *properties*. I answered according to that distinction. Local final variables weren't mentioned anywhere either by me or OP. But keep trying little man; maybe one day you might have something useful to offer without having to lie about how much people love it. I believe in you.
I was talking about final properties and the fact that they are enturely different to const members in PHP and allow for mire flexibility since they can be initialized anyway you like as long as it happens until the cobstructor finishes. So you can do either inline i itialization, static block or constructor. And thus different instances of the same class frequently end uo with dufferent values in their final properties.
I know absolutely nothing about AWS and Lambda. Aside from the “granular” billing you mention, what is the advantage of this? Where would AverageJoe.php find value here? Cheers.
It's a protocol; a contract. You can implement it in any language you'd like.
Very nice!! I had to implement Tus from scratch last year and I pretty much enjoyed the experience. The protocol is so simple and elegant! The only bad thing I can think of is that it requires JS to work, but it's a small price to pay for such a feature :)
Serverless is merely a current fad. It engenders vendor lock-in, no matter what your architect says about portability. I know. They told me the same thing about Google Cloud Functions and so I said, "OK! Here's $10 budget. Port it to Amazon Lambdas, you have a day. GO!" and they found out real fast just how "portable" that JS code is. Serverless Functions serve NO POINT if you already are on a PaaS like GCE, GAE or AWS that can be easily scaled. They don't! The costs saved are **minuscule** in the medium- and long-terms, and easily offset by 1) having different languages in your codebase, 2) serverless are TESTING NIGHTMARES, and 3) they lock your dev team into unsavory practices such as developing all the way to pre-production pushes off of full-on mocks of the serverless architecture. There are also deployment headaches.
How can we build anything on top of it without tests? Or even use it?
Thanks a lot for the reply, I’m feeling some confirmation bias form on my end. Your comment about GAE and AWS vs DO and vultr is what I can relate to most. Granted, my applications are relatively simple and I’m a one-man crew, but I just can’t get behind the hype, and the whole serverless fad/trend has been lost on me.
And yet again, you try to split hairs with concepts that are irrelevant to the discussion. The question was about final properties and why PHP has no such concept, so we found the *closest analogy* from another language we could. Did I say "final properties in Java are Constants in PHP"? No. I didn't. And to pretend that I did is - per your usual history - intellectually dishonest. Read what I wrote. Split hairs all you like to make yourself feel better, but once you're done, read it again. &gt; final properties in Java are almost synonymous with PHP, C#, and C++'s const keyword. Notice the word "almost" in there? Of course you didn't. It's because you didn't bother reading what I wrote. &gt; When you declare an object property as final in Java, you must initialize it. Which is true. Both `final properties` and `const properties` must be initialized in Java and PHP respectively. However, static and constructor initialization are unique to Java and are not analogous to PHP, therefore it is irrelevant to the discussion. Again, if you bothered to read the original question by OP and what I wrote, you would have caught on to this. &gt; There are some subtle differences, but for the most part if you want to use final properties, then you're looking for constants in PHP Notice the "there are some subtle differences" disclaimer? Of course you didn't. It's because you didn't bother reading what I wrote. There *are* subtle differences between Java's final property implementation and PHP's const properties, but none that are part of the discussion since those differences aren't relevant to PHP. I'm not sure what you're trying to prove here, but you lost all credibility and respect years ago [when you tried to pass yourself off as something that you're not](https://www.reddit.com/r/PHP/comments/4iju97/95_of_phpixie_installs_on_packagist_are_fraudulent/). So I'll tell you again: You need to sit down and be quiet.
… ``` $defaults = array( 'mcrypt_algorithm' =&gt; MCRYPT_DES, // ...snip... 'mcrypt_key' =&gt; 'prodgiyviewkey', 'mcrypt_iv' =&gt; 'prodgiyviewiv', // ...snip... 'open_ssl_key' =&gt; 'OxF3qAylVd', ); ``` https://github.com/ProdigyView-Toolkit/prodigyview/blob/aa7e4adfbc70656c3ffb6f46b378b5dab3b5348a/src/system/Security.php#L112-L132
saved this post and came back to test Devilbox after the holidays. migrated from Vagrant. changed my whole environment. so much better - thank you!
Lumen which is a subset of Laravel, but yes.
It's mainly for enterprise-level systems that are designed in the Cloud. 
No, it depends on your use case
Oh nice and makes sense!
Hi everyone, The company I work for is building an API endpoint for a new service (number of requests will be in the dozens of thousands), and the team leader wants to use Laravel, I think it's not the best choice because: \- it's bulky and slow compared to other lightweight frameworks ([https://github.com/kenjis/php-framework-benchmark](https://github.com/kenjis/php-framework-benchmark)); \- we would have to strip out a lot of unnecessary stuff; \- overkill for API endpoint only; \- notoriously runs lots of queries (not a huge problem, but why not avoid the extra overhead?)
You need to ask yourself what the API is doing. Lumen was built to overcome the bloat of Laravel for API use, but Lumen is still bloat compared to the power of the dark side... i mean PHP.. My response time and memory use in a custom API is 10 times better than Luman/Laravel based and I can use json\_encode($response\_array) like a champ. (someone will respond with , you can cache this and do this to overcome the bloat.. my response back is, you shouldn't have to) 
There is a website ([phpbenchmarks.com](https://phpbenchmarks.com)) currently tracking "Hello World" speed: PHP 7.2 is coming it at 148,905 points Laravel Hello World is coming in at 25,571 points If you want to slow down your site 80% to output "Hello World" by all means, knock yourself out. 
I would avoid Phalcon (too much complexity), Lumen seems to be a good choice. If I were the owner of a company, I would avoid wasting time discussing about performance between frameworks/languages, I highly prefer people spending more money on servers, and, if you use Laravel components while developing, it's really easy to put behind an auto-scaling scheme. So, why bother? &amp;#x200B; Anyway, I'm pretty sure nobody in your company use Phalcon, so it would be a waste of time if you take into account that somebody has to learn how to develop/deploy it. I assume your people is already familiar with Laravel, so, Laravel/Lumen seems like a good choice. As you can scale, I wouldn't worry about performance. I prefer development speed over performance. Of course, everything depends on your use case, but, using the lack of information is what I can say :) I would use 2 variables: 1) the framework you know the most, 2) the framework who give you tools to make an API (and Laravel/Lumen does)
Dozens of thousands of requests per which unit of time? The answer depends on loads of things. If you have an existing app based on Laravel and you’re making an API to do the same things re-using the components, then Laravel’s the obvious choice. Same if you have a dev team that know it really well. If this is a greenfield project and the dev team is happy using a load of different tools, then the answer could be different. Also, don’t forget that the time doing the work your API does is going to be most of the time spent in a request, regardless of the framework, unless you’re actually making an API that just says Hello World. The difference between the frameworks in that benchmark is pretty misleading.
URL can just be [www.yoursite.com/random\_page.php](https://www.yoursite.com/random_page.php). The PHP script then creates a random URL and redirects the user there, using either a header() function or a meta refresh tag.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/phphelp] [If anyone here can steer me in the right direction here it would be greatly appreciated](https://www.reddit.com/r/PHPhelp/comments/abw06x/if_anyone_here_can_steer_me_in_the_right/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
&gt;(number of requests will be in the dozens of thousands) per second? per minute? per week?
Depends on how your API is being utilized. Expected number of connections, size of payloads at endpoints etc. Use Laravel, Lumen, or forget PHP all together and go with Loopback or similar.
Can you explain it?
The concept at its core isn’t bad at all. The implementation is just immature. When you can ship a “serverless” docker container or something similar, this will change the way we think of hosting, much in the same way virtualization did over shared hosting and shared hosting did over dedis.
&gt; Welcome to the ProdigyView Toolkit, a powerful PHP enhancement tool designed to make PHP coding faster, less mundane and highly extendable. It's definitely not mundane!
You could use a number and then divide that number by how many pages you have. The remainder of that sum is the page to take your user to. Good luck!
Awesome! Glad you're benefiting from it. Being the new year for improved workflows - if you know anyone doing WordPress stuff, my plugin handles security and performance in a very different way: [https://github.com/leonstafford/wp2static](https://github.com/leonstafford/wp2static)
&gt; currently tracking "Hello World" speed Very fucking useful... If you want to benchmark something, use real world scenarios not this shit. Better yet, measure how much time you save by using a framework, multiply it by your hourly rate and see what kind of infrastructure improvements you could do for the same amount. If it's still more expensive, then feel free use your homegrown solution as it's arguably the best choice. If not, then you actually saved some money by doing your research. Alternatively, if the performance is that important to you, why not switch to a compiled language? Please stop posting stupid shit. Someone might use your advice otherwise.
I still don't understand what you're trying to say here, honestly.
I'm sorry I upset you pointing out that Laravel adds bloat to PHP. It is a True statement, whether you like it or not. He asked " **Is Laravel the best choice for an API?** " The answer is "No", it is not. 
this is a fair point. Just to follow up on the question where to place the business logic, we have also a chapter about this in the manual. If you are interested you might want to take a look at it: [https://fusio.readthedocs.io/en/latest/development/business\_logic.html](https://fusio.readthedocs.io/en/latest/development/business_logic.html)
Why would I use this package instead of the ramsey version? I don’t really see the benefit of wrapping a static call in another static call.
Halite is the only acceptable answer for greenfield projects, imho.
If your worries are about performance, better focus on the database performance, not the framework. That's most likely where your bottleneck is.
Just turn off all the unnecessary stuff which is included in the default Laravel config and you got yourself a pretty fast backend. Yes, the default config and setup is bloated, but that does not mean it cannot be fast.
Untested: &lt;?php $sites = array(‘http://www.google.com/‘, ‘http://...’, ‘http://...’); header(‘Location: ‘ . $sites[array_rand($sites)]); die; 
&amp;#x200B; I just read an AST Wiki and find that is in line with how I wish to accomplish a code base this year. Looking to apply it to a http request life cycle. So hopefully that works out ! 
Well, that's just like your opinion, man.
It makes it a little easier as it provides a trait to handle using a UUID simpler.
HauntedMidget was upset with my lack of using a framework, that was for my own personal taste. I have saved 100 of hours with that because I can change data sets per request without too much of an issue. Client change requests are the ongoing struggle, not just the initial launching of a website. Also, I am not dependent on code changes in the framework itself or the many dependencies it has. They are irrelevant to me and don't affect my beer drinking. With that said, I never said don't use a framework. There are other frameworks with better performance and can handle an API. Not knowing the full scope of what the OP wants in this scenario, it is hard to answer. Laravel itself was not built to be just an API, that is why there is Lumen. So at lease recommend that as a base. &amp;#x200B;
Agreed. Useless repo/project.
Any idea if this would count `Foo&amp;string` as the name of a class that extends or implements `Foo` (so static methods could be invoked on the value)?
Would be great if the caches could be injected in the constructor instead of configured. So I can re-use my Redis connection. 
 public static function generate() { $uuid = RUUID::uuid4(); ... Wait, so you just wrap your trait around Ramsey/uuid? What's the point? It seems like a terrible idea to generate your ID in the constructor vs injecting it. 
/u/Tomas_Votruba is probably referring to the "parse source code to its corresponding AST, apply specific transformations, convert it back to source code" pattern. It's useful to speed up mechanical changes to a lot of code. See [`rectorphp/rector`](https://github.com/rectorphp/rector) for examples.
You need to link something then because we think you are delusional since every resource online contradicts what you are saying; even the original usenet and gopher posts about the announcement of PHP. You are extrapolating way too much off that first sentence. If you read the full paragraph, and any other resource ever documented by Rasmus, he attempted to write a tool in Perl, the tool had constant problems so he rewrote it in C. It is the C wrapper that is PHP. He wanted one of those stupid page counters at the bottom of his page, the web server was too congested to use the Perl based page counter, he wrote it in C. Every version of anything that could ever be called any form of PHP was always distributed as 
It won’t. In the [tool I created](https://getpsalm.org) you can use a docblock annotation `class-string&lt;Foo&gt;` to represent that: https://getpsalm.org/r/14752218d3, but that annotation isn’t yet supported by PhpStorm
Migration to php7 at last!
Spot on. I've only just started looking at this subreddit. I'm trying to figure out which framework (or even code/form designer) to use. I do the right thing and look at the FAQ posts in the Community Info, but what do I get? A locked thread from 7 YEARS AGO! I should think myself lucky as the other FAQ's are 9 years old! Decade old FAQ's are no help to anyone, especially as the reason for me having to come searching for answers is to rewrite an app that relies on register_globals which was deprecated then removed some years ago... Most subreddits are quite up to date, but this one lets the team down badly. 
Disclaimer: I haven't actually used this yet and I've only ever used cloudflare workers. If I built something serverless it would be because I have zero budget for hardware and my free time is pretty much worthless so longer dev time isn't a big deal. Also, I'd probably use this to help with the vendor lock in https://github.com/serverless/serverless
thanks. yeah I WP. I've used static site generators before for ticket launches etc. will watch your recent tutorial 
Slim Framework
I'm not getting the purpose of this approach. What are the advantages? 
Nothing's wrong with PHP. It's actually almost never the language that's bad. It's almost always the users.
Php is a great language, what is causing you doubts? 
&gt; I'm sorry I upset you pointing out that Laravel adds bloat to PHP. I'm not upset. More like annoyed at the tone and content of your statement. &gt; It is a True statement, whether you like it or not. It's also useless. By your definition any code is bloat, regardless of the value it adds. &gt; (oh look, I upset the Laravel faithful, you guys have your own reddit) I haven't used Laravel for at least a couple of years and it wouldn't be my first choice for *any* project (I hate RAD and Active Record), so the term "Laravel faithful" is very far from the truth, although amusing. Regardless, Laravel absolutely *can* be used for creating performant applications, including APIs. Claiming that it can't without any factual proof is stupid. "Hello world" is not proof, it's a cherry-picked example with zero relation to the real world. Using a framework will nearly always result in faster delivery for any mid-to-large size application. That's what matters to the shareholders. Once the product is launched, then you can check if you even needed those performance improvements.
What's wrong is people talking about php that hasn't saw anything since php5...😂😂😂
## In defense of PHP. Business speaking, If you want to build a startup then it is a no-brain to pick PHP: popular, it's easy to find libraries, it's easy to find hosting, hosting, dedicated, cloud that supports it and it's one of the cheaper (Java is for "free" but devs are more expensive). The main complaint against PHP it is because only a dozen functions are written in a different order, but that's it!. 
Please Advise me on how to respond to clients who think it's not secure enough and "late to the party"
 Didn't say the "Laravel Faithful" to you directly, I noticed I was getting down voted. I also didn't claim it "couldn't be used", I simply said it "shouldn't be used" Thank you explaining why you wouldn't and/or haven't used Laravel in years. 
I wrote an AWS Lambda function once so I am by definition an expert. ;) I would pretty much concur with /u/2012-09-04 here, it has its place but it's mostly useful if you want to do something in response to an SNS topic notification (that's basically just an AWS "event"). So I would not build an application with it but I would say it shines as an alerting tool or something in combination with CloudWatch (another AWS product). If this post seems to have a lot of "AWS" in it, refer to /u/2012-09-04's comment...
&gt;Please Advise me on how to respond to clients who think it's not secure enough and "late to the party" &amp;#x200B;
Usually, the bottleneck is not the programming layer but the database. For example, let's say that reading a table takes 0.01 seconds. Is it fast?. Well, if we expanded it to 1000 concurrent users, then it is slow. 
Mention php solutions from client sector of intetest. Preferably the big players.
They're probably thinking on PHP 5.x 
I completely agree with this. My personal philosophy has always been that if you are a good engineer, you can make anything work well (Facebook is a good example of this). I think a lot of php’s bad reputation comes from the security problems it had in its early versions and all of the programming hipsters who are snobby about languages. 
Thanks. Wasn't clear that's what he was referring to.
1. Ask them about previous experiences they’ve had with php or if their concerns are raised by word of mouth. 2. Find out what php version their previous projects used and if it was built without modern standards in mind. (OOP, MVC etc) 3. If any of there responses include Wordpress, Joomla or php 5, smack them. 4. Depending on what your project for them is, and if you’re using something like Laravel or Symphony give them the rundown on features out of the box. (CSRF, XSS and SQL injection attack prevention)
Great! Let me know if you need any help with diving into AST. I'm studying it last 2 years and it's pure joy :)
Thanks!
/u/DCoder1337 explains it nicely: https://www.reddit.com/r/PHP/comments/abserl/what_will_be_the_new_trends_in_2019_in_php_world/ed3kw3a
Thanks for your input!
This is a tricky position because the client already seems to have made up their mind that they don't want PHP. Fundamentally it's risky because the old adage: *"A person convinced against their will is of the same opinion still"* holds true. Even if you convince them that PHP is fine, the *instant* there is a snag, or a problem, or god forbid a small security snafu on your part (hey, mistakes happen, right?), they're going to say "I KNEW IT! PHP SUCKS!" and blame you for pushing PHP on them, and may even use it as an excuse to withhold payment. It may be prudent not to even take them on as a client. The trouble is when they say something like "It's not secure enough", that's too ambiguous to even respond to. You would have to qualify what they mean like "What specifically do you think is not secure about PHP?" and then you can correct whatever falsehoods or misconceptions they believe about that particular aspect of PHP. It's "late to the party" doesn't even make sense and cannot be responded to logically or rationally. The thing is, your client objects are fundamentally illogical and irrational, and you cannot reason someone out of a position they did not reason themselves into. So for me personally, I would not waste my time. I would just wish them luck in finding a solution to their problem, and leave my offer on the table in case they reconsider.
who are some people and what does optimal mean in this context? 
I'm a fan of PHP, but I don't think you can separate the two. The users define the language, and the language shapes its users. PHP grew out of being completely reactive to user demands, which resulted in it accumulating plenty of bloat and bizarrely permissive syntax, but also meant it has remained relevant for decades now. As a result, many people who aren't super strong programmers are able to skate by writing code of such low quality they'd be hard pressed to even compile in another language. 
I wish I knew about this stuff. I am trying to make a market.
Isn't this the best option to make an onion on the darknet? I been looking into PHP. I want to build a marketplace.
You should give more details, maybe PHP simply has no support for client's requirements (ex event support is weak, same for parallelism). As others said, php is great usually the devs are shit. 
Facebook currently runs on the HHVM due to issues associated with the original PHP. 
I wonder who developed the HHVM?
We use GAE for all of our heavy cron functions (we pull lots of data daily) so they’re not all running on the same machine. It’s nice for the machine to only be running as long as you need it to (since you’re only billed for uptime). Never have to worry about outages affecting a static node. 
&gt; Embodied Knowledge I really like this! All these things are mostly "team decisions" and there's always friction matching new people into them. Or something developers just don't feel like adjusting ... Anyway, totally correct that removing that restriction is a "productivity" thing. Less to think/care about!
Can't recommend using Lumen unless you've an idea what you're getting into. It's for the most minimal and most performant thing if you want something "Laravel-like" but it's nowhere in terms of Ecosystem where Laravel is and there's always this odd breakage with some packages or simply not supporting Lumen when you need. I'd say Laravel might by a good choice, why not. You can "throw out the window" everything you don't need but later added, if things might change. - don't send emails? Disable the providers - don't use session? No need to register the serviceprovider - same for CSFR, Cookies, etc. Yet you still can add all the things anytime back you need them 👍
I'd recommend you check out Knative or Kubeless. You can run "Serverless" and be cloud agnostic if you're on Kubernetes. But there are a few reasons it's a really powerful concept. One, because it can handle any number of cloud events, an S3 put, SNS topic, etc. Two, it means developers don't have to worry about infrastructure. Three, it scales from zero. If you don't have any requests you don't use any resources.
That's for sure not the main complaint against php. The problem of php is that's its way to easy to write shitty code and there are lots of developers doing that. And there are way more problems with the php api than some different orders of arguments. 
There are [official server implementations](https://tus.io) for [Go](https://github.com/tus/tusd) and [nodejs](https://github.com/tus/tus-node-server). 
Well it would hardly matter for something like OP's use-case, that's generally considered a bad habit because unless your random number generator happens to align exactly with the number of values you're trying to select from you'll get biased results. Ex: If my random generator outputs an integer from 0-9 inclusive and I have 3 things I want to choose between (let's call them 0, 1, 2) Here's a map of which of the number the generator chooses and which of the choices get made 0 -&gt; 0 1 -&gt; 1 2 -&gt; 2 3 -&gt; 0 4 -&gt; 1 5 -&gt; 2 6 -&gt; 0 7 -&gt; 1 8 -&gt; 2 9 -&gt; 0 Which shows that 4/10 times we'll choose 0, 3/10 times we'll choose 1, and 3/10 times we'll choose 2. Prefer generators that let you pick a range yourself and will handle the de-biasing for you like [mt_rand](https://secure.php.net/manual/en/function.mt-rand.php) or [random_int](https://secure.php.net/manual/en/function.random-int.php).
Does some "optimal solution" exists ?? please, share that secret, I need to know!
THAT'S WHAT BUGS ME! The premise of their statement presupposes the existence of an optimal solution, even worse, with no definition of it in the first place!
Serverless is another model for cloud deployment—arguably, the most "cloud native" one to date. The main benefit is that you generally don't have to worry about server-related issues (which is why it's called "serverless") like scaling, high availability, OS upgrades/patches, etc. From https://martinfowler.com/articles/serverless.html, which is well worth a read: *"Serverless architectures may benefit from significantly reduced operational cost, complexity, and engineering lead time, at a cost of increased reliance on vendor dependencies and comparatively immature supporting services."* See https://en.wikipedia.org/wiki/Serverless_computing for more advantages/disadvantages. AWS Lambda was introduced in 2014 and clearly left "fad" status in 2016. PHP has been mostly left behind in this shift to serverless so far, but recent development—like Lambda support for custom runtimes and [Zeit's support for PHP](https://zeit.co/examples/php-7/)—are promising.
**Serverless computing** Serverless computing is a cloud-computing execution model in which the cloud provider acts as the server, dynamically managing the allocation of machine resources. Pricing is based on the actual amount of resources consumed by an application, rather than on pre-purchased units of capacity. It is a form of utility computing. The name "serverless computing" is used because the server management and capacity planning decisions are completely hidden from the developer or operator. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
The 7.x version series is the best it has ever been. Runs circles around Java in development time. Scales better than Ruby. Built for web, unlike Python. Doesn't have that Bill Gates smell like ASP &amp; C#... Literally PHP was built to not be Perl. It is light weight, it runs quickly, that it is insecure is more of an implementation thing and your mileage may vary. I really like Python and admittedly the other languages have their strengths. But, I specifically prefer PHP for middle ware web work that serves up my AngularJS front end code and responds to HTTP webservice API requests.
My dumb friend who knows nothing is asking what GAE is. Could you help him/her out?
Why die?
I don't like PHP myself but the "it's easy to write shitty code" with doesn't hold with me. I prefer Python over just about everything and I've seen so much just terrible python that sometimes I cry myself to sleep.
I think we'll see lots more, at least written on, the use of serverless.
Show them Laravel to anyone who doubts about PHP. 
Equifax was using Apache Struts which is Java, the most widely accepted "enterprise" language and look what that got them. The language is as secure if not more secure than other languages at its core. Since every request is constructed and deconstructed at run time there is no heap stack to compromise and also allows for easier horizontal scaling. PHP dominates the web because it fits the need for the web incredibly well. While fads and paradigms get introduced, PHP evolves and adapts as necessary; if not Ruby on Rails would have gained much more market share than it did 10 years ago but PHP Frameworks adopted the relevant paradigms. Even the new buzz happening with Node is being adopted with Rachet, WorkerMan, and Swoole. Swoole even now allows for coroutines and channels like Golang.
It's also, you know, like, a correct opinion man. The long term costs far outweigh any benefits. Do not underestimate the "TESTING NIGHTMARES" part. &amp;#x200B; Web servers running PHP are just about the easiest thing there is to scale. It's trivial to install+configure PHP and a web server; it's trivial to put them behind a load balancer so you can scale as much as necessary; and on most cloud providers, it's trivial to auto-scale these as necessary. &amp;#x200B; One could argue lambda is a good cron replacement, but using lambda to replace your web server is one of the dumbest moves you could possibly make, IMHO.
what is php shitty code? i keep reading everywhere and i never see some examples (and i'm not being sarcastic).
In my experience: 1. People still think it's in Version 3 with SUPERGLOBALS enabled by default. 2. A lot of people struggle to sort information from their ego. If you are invested in some other language, naturally you'll want to shit on every other language that damages your fragile ego. That's not to say each language doesn't have it's pro's and con's. When people ask my why I still script in PHP I simply say because I haven't come across a problem I couldn't solve with relative ease in PHP and I go with what I know. When people tell me PHP is shit I ask them why, and they never have any valid reasons other than personal preference which is not an objective strike against PHP, it's a personal one. So I just let them have their opinion and move on with my day.
I started using PHP about 20 years ago. It was a great time and I'm not sad to have missed doing big upfront design with Java. Today - if you start a new project - there are much better options. For example, you could built a single-page application with JavaScript frontend and Go backend. It's faster. It's cleaner. It's scalable. However, there are still many PHP developers out there and existing projects can't be migrated over night.
You are thinking of the `register_globals` setting.
Ahh yes, THANK YOU! That was definitely a shit feature.
Programmers can write shitty code in any languages. It has nothing to do with the language but with the person coding it. 
Sure you can pick GO for backend. But how many developers write in it? Do they charge more because there are fewer of them? And where will the language be 5, 10, 15 years from now? PHP devs are easy to find. The language has stood the test of time. I'm not saying it's a better language, I'm just saying you should keep these things in consideration.
Anything is not secure enough if you really look hard enough. Let's take a hipster language, like node.js. I don't use node.js, I have many qualms about node.js. I think it is a horrendous abuse of javascript and what JS was originally intended to, suffers from (imo, even worse) problems of permissive syntax, but most importantly has an upstream component ecosystem (npm) that is entirely untrustworthy. PHP gets flack because it's old and dead, but the hip trendy things (like node.js), you're often called a troll if you point out similar flaws. My point being, I needed to make changes to Twitter Bootstrap "less" and re-compile the CSS. The toolstack to do this with, is JS based and requires npm. When I set this toolstack up, I was informed of several critical vulnerabilities in all of the dependencies that I have just installed, and npm asked if I wanted to 'audit' this... You should never, ever blindly trust other people to add random code into your project, and when the vast majority of people use tools like composer or npm to include libraries or dependencies, this is exactly what you do, blindly trust someone else's code and blindly trust that they (and future unknown parties) will maintain said code in good faith. Malicious code has wound up in popular websites due to a lack of vetting in the NPM ecosystem and I'm waiting for it to happen with composer as well. PHP is as secure as any other language if you configure it properly and use it properly. The fact that the language has dangerous features is not a fault of the language but user error for using them/configuring them incorrectly.
&gt; to make an onion please don't do this
I've never done serverless php, but I've done python with Django. The advantage is you don't pay to host a server 24/7 (only when it's used) and it automatically will scale. 
I'm sure there is anything inherent in the design of PHP that makes it "easy to write shitty code" that doesn't exist in more popular dynamic languages. Exactly how does PHP make it easier? 
There are many PHP developers. I just didn't want to call them cheap. Looking into the future, I'm sure this will change. PHP development has grown too complex and Go is extremely easy to learn in comparison.
have you also tried react php?
There isn't anything really wrong with it, PHP 7, Composer, Laravel/Symfony/Slim, etc is a perfectly decent ecosystem for building the backend for websites/apps. The problem is it isn't 2001 anymore, these days there are bunch of languages that have nice frameworks that make it relatively painless to build websites/apps, but unlike PHP they offer things beyond that, be it using the same language and the front end, performance, being the defacto language for machine learning / data science, having a huge pool of devs to draw from, etc. PHP sort of reminds of Ruby these days, it is perfectly decent for doing what is was designed for, but really unless you are tied to it in some way, there are other options that offer more, which makes them more attractive to a lot of companies.
Well wrote. Thank you for that.
Please... you know as well as I do that they're thinking like it's PHP 4.
And most of those issues are handled nicely in PHP 7.x. The language has moved on. 
[https://www.youtube.com/watch?v=BKorP55Aqvg](https://www.youtube.com/watch?v=BKorP55Aqvg)
It's the kind of thing that people come to /r/phphelp to ask about, usually some college project that teaches PHP like it's 1999, with gaping security holes, SQL injection flaws etc.
PHP makes it easy by being free, open source, available everywhere on even the cheapest hosting, allowing a Web page to be written using nothing more than a free editor. It's free too.
Its an old opinion that is no longer valid when applying the reasons to modern PHP Modern PHP is faster and has all the security features either via modules, native code, or libraries. Anyone who says that probably heard it from a trusted source or had a bad exp with it one time. 
Or Symfony if you don’t like magic
Just before Christmas I wrote a quick app to monitor UK parliament petitions at regular intervals. It took just two hours from start to end, and has over two million data points so far, and is still running well. I can't think how I could have written something so quickly in and other language without the fantastic community behind PHP.
&gt; late to the party What is that supposed to mean. I’ve been a pho developer for 20 years and built my whole career on it... doesn’t seem late to the party to me
You can for me?
Yep, true. \`setCache\` method used inside the constructor already accepts string or Cacheable interface, Few small changes is required in Server and Client class. PR would be great :)
&gt; The question was about final properties and why PHP has no such concept, so we found the closest analogy from another language we could. &gt; final properties in Java are almost synonymous with PHP, C#, and C++'s const keyword. They are different things. "Closest analogy" and "almost synanomus" are totally different levels of relationship. &gt; Notice the "there are some subtle differences" disclaimer? I did. These are not subtle at all.
PHPs “problem” is fashion. New kids on the block are dazzled by shiny new. Same old cycle since the dawn of time.
Honestly it’s not all that complex. “Serverless” is a pretty awful term. All it really means is that you don’t have to pay for idle resources. Essentially, a snapshot is taken of your application stack (read: lambda function) and stored in memory, readily available for compute instances. When a request is made to the lambda function, it quickly pulls that application’s state from memory, and begins processing it, then saving the state again. With a dedi, we had to pay for the whole box and run the full stack on bare metal. With shared hosting we were able to share the dedi with others, cutting costs and sharing idle resources. Unfortunately that came with a cost in terms of security and reliability. Then virtualization layers came along that solved these problems, for the most part. Then Amazon came along and created clusters on top of virtualization to give us a “cloud”, or PaaS. The next step in optimization of resources is the ability to have a ready to execute application sitting idle, but not using any compute resources. That’s “serverless”. Unfortunately right now, the tooling is crap and the restrictions are tight. It’s just not there yet.
The `header` doesn't have any effect on the browser if there is any body content. By passing the `header` and then immediately `die`ing, no body text passes and the browser redirects.
Stop listening to these morons. Do what gets you paid. I have been a PHP developer for a while - gets the job done, gets money in my bank account.
Here are some things that are lacking when compared to Python: * No magic methods for overloading operators like `*` (multiply) or `.` (concatenate) makes it impossible to build certain types of important abstractions like an ORM query builder. Fluent-style SQLAlchemy queries have substantially less syntax noise than the equivalent Doctrine queries because Python has implemented magic methods for all the operators. * No autoloading for functions means everyone uses heavy-weight classes for everything. If you've only used to clunky languages like Java then maybe you think this fine, but if you're used to whipping up useful little helper functions in python then having to invent a containing class for every single one of them in PHP really feels like needless beaurocracy. This also means you need to wait for the core devs to implement things like `array_key_first()` because you can't package up your own little helpers properly. * No keyword or keyword-only arguments for functions. Python's keyword args are often a huge help in making code easier to read and maintain. * No decorators. PHP desperately needs decorators. There is so much programming meta-data (routing, ORM relationships) that gets coded in PHP `/* comments */` and has to be parsed by 3rd-party libraries to ensure validity. In contract, python decorators are first-class citizens which means your IDE can check that all the names have been imported and spelled correctly and that the arguments are correct. * No async/await support for functions doing IO-bound tasks. * Limited support for type annotations compared to Python. Guido van Rossum (python's creator) is actively working on MyPy (the Python type-checking tool) and the project has the full support of the python core devs - the last 3 major python versions have included improvements to the type annotation system, making it reasonable to assume python will have a stable, full-featured type-checker with features similar to mature projects like TypeScript within the next couple of years. In contrast, the PHP core devs recently rejected the proposal to add Union types to the syntax (you can't do serious type checking without unions, among other things) which means static checkers like Phan have to continue relying on PHPDoc types (again, important programming meta-data going into `/* comments */`) and it seems like projects like Phan will remain 2nd-class citizens for the foreseeable future. Now this doesn't mean Python is better in every way, PHP has long held some advantages over python: * Predictable order for array items (Python dictionaries items were essentially random-order until very recently, and until 3.7 is the minimum-supported version everywhere, python devs will have to continue treating them as such) * Class attributes like `private`, `abstract`, `final` etc are very valuable for writing maintainable object-oriented code, and python has no equivalent. * String interpolation is quicker/easier in PHP via syntax features such as `"$var"` or `"{$object-&gt;method()}"`. Python has caught up a lot with the recent addition of f-strings, but it's still not quite as nice, and again python devs need to wait a few years for 3.6+ to be installed everywhere before they can use it. * IIRC the less-dynamic engine, combined with most core functions being implemented in C means that PHP code will actually execute faster than the equivalent Python. These lists are not exhaustive. There are many more important advantages/disadvantages when you compare what libraries and frameworks you're going to need for your project. If there's a library that does everything you need but is only implemented in C, then maybe you should just use C.
The fun fact is that it is easy to write shitty code in PHP, but in other languages you write really shitty complex code that makes it hard to distinguish if it is shit code or just to complex to understand. 
Your attempts at getting the last word in are not lost on me, and while I think it's hilarious, you're beginning to bore me. It was fun chatting with you.
This just looks like you have no more arguments though.
Yes, blame the tool, not the user.
It certainly appears that way, doesn't it? I mean, I can play chess against a pigeon, but all it will do is knock over a bunch of pieces and shit on the board and then strut around acting like it won the game. Sure, man. I have no more arguments. You win.
“Find another developer”
I’ve been working with PHP for 20 years. What party are they talking about. 
PHP7 is fine. absolutely nothing wrong with. there are still lots of very bad legacy PHP applications out in the wild though.
They probably sent the email from IE6
well in all fairness you can throw up a vps with ruby support and have a fully functioning site going in 2 hours. 
mhmmm.. Other than Python, I can't think of a faster language to mock up a project and have it run at production ready levels in under a day. And for the web, there's nothing faster than PHP, unless you are a master of JS and don't want to kill yourself writing prototype code in JS. 
I tried to read many languages to find most expressive or readable syntax, it seem Crystal and Ruby are less complex.
If GO is developed by Google, that language will be dead by the next update cycle. There has never been a Google product other than gmail that has been around longer than a few versions. Why risk investing an entire companies core product to be written in a language whose vendor is known specifically for dropping support for all of their products? ALL of their products. If you don't agree, you don't work with Google. 
This is normal behavior and you would understand why it's happening if you read the settings when setting up the XDebug integration.
You can write insecure code in any language, choose the one that works best for you and gets the job done. I fell like allot of these people complaining about what is a good / bad language probably have never written a production level app in their careers.
What do they want instead ? What are they wanting you to build? Talk to them about economics. 
Well, PHP is not the same language it was 15+ years ago. It is significantly better and more performant. On the other hand, PHP has been (until relatively recently) slow to discard the "sins" of its past, so not all criticism is without its merit, but it is often the case that those who criticize PHP are developers who: 1. Failed to keep up to speed with PHP's evolution 2. Graduated from PHP back in the day and are somewhat arrogant about it 3. Don't know what they are talking about and are simply parroting when they've read on some blog or reddit post somewhere 
PHP does not add new language features as fast as the big programming languages do. It's always on the cusp of being out innovated. On the other hand, I get everything done I need to get done. I love it.
It's good for a person to look and recognize what works well and what could work better. PHP isn't perfect, but it saddens me to see "Nothing is wrong with PHP" be the most upvoted answer. That's not how PHP got here, and its probably one of the biggest weaknesses of the current PHP community.
Jesus Christ good luck reading that shit. 
Again, I see the point. PHP became almost as complex as Java, so if Go doesn't kill it maybe something else. Even Java isn't dead yet. But also Go isn't a regular product. It's Google's replacement for C++. They can't drop it because they're using it for many products every day. Otherwise they are famous for dropping support. They try to change that according to a person I spoke to. Who knows.
Well, Bagisto is an Open Source eCommerce Framework. You can download the whole project and and set up your project using Composer. After that, since it's built using popular frameworks like Laravel and Vue.js, you can easily customise according to your way and even make plugins or themes as per your requirements. 
Laravel is one of the reasons to stay away from PHP.
What is this nonsense?
Holy shit that was written so badly.
I don’t know if Swoole, Ratchet, or WorkerMan are real languages and I’m afraid to find out.
I can always win the first part, I wrote a payment system in PHP back in 2012. To date it's handled more than a billion pounds in transactions, it's running on an aws micro instance and has never failed a penetration test, pci compliance audit and has only ever had 1 bug since go live 6 years ago which was only a performance issue and down to MySQL not PHP. 
The language/core library design for a particular example probably *could* encourage poor coding habits, but it's still mostly the dev's fault.
There is always a degree of blind trust in programming land. What matters is the general trustworthiness of the people/orgs you choise to trust. If you trust a random semi-anonymouse developer as much as a friend or member of a dev team *then* you have a problem.
By insecure code, it’s the code analysis tools that minimise risky code.
&gt; I have many qualms about node.js. I think it is a horrendous abuse of javascript I lol'd at this. You are my spirit animal. I'm an oldskool JavaScript programmer. This was not by choice, but I actually had a modicum of JavaScript experience and was hired (long ago) by American Express to work on one of their intranet projects. I subsequently became a HARDCORE^TM JavaScript programmer. This was in 1999. Since then, I became a Java programmer and did a lot in Actionscript frontend work when Flash was a thing, but PHP has always been my go-to backend and HTML/CSS/JavaScript for the frontend. Anyway, I'm drifting. I'm a competent JS programmer and the crazy shit that JS has spawned just blows my mind. Of all the things you could have asked me would happen to technology, the ridiculous shit that has sprung up around JS, I mean, you just can't predict this shit. I would never have imagined. And jQuery was bad enough. I've never used jQuery. I despise jQuery. I hate piling on overhead strictly to make shit easy. node.js and jQuery are bad, Electron truly makes me want to murder people. 
What is with this sub and literally every reply being an ad hominem? Why can't you guys argue against a statement and not just keep piling up snarkyness?
The first steps in learning php are really simple. With some tutorials, a text editor, a ftp program and cheap hosting (starting below 2 euros per month) you can write and publish some simple scripts with database access within hours without any programming experience. Most webhoster still offer old and unsupported versions of php, some even offer php 4. PHP started as a template language and it's still really simple to embed php in html pages like in this tutorial: https://www.tutorialspoint.com/mysql/mysql-insert-query.htm It's also a very forgiving language. Lots of problems with the code only throw notices, not exceptions or errors. Notices don't halt the execution, you can configure that they are not reported at all. It has dynamically typed variables and does a lot of type casting on usage, it allows numbers and strings to be used as booleans and so on. It allows to disable error reporting for functions calls if you prefix the call with an @. The official documentation is in parts really bad and suggests bad practices or has bad code examples: http://php.net/manual/en/security.database.sql-injection.php On the other side it is possible to write high quality code and applications with php. There are good frameworks (symfony, laravel,...) and a really extensive ecosystem with high quality libraries. PHP as language is getting better and faster with each version. 
Gotta be an add for the 6 months/6 Weeks course.
If you want to get a basic web project up, PHP is fine. However, a few things off the top of my head, I'm sure there's more. * Type system is weak (no generics, no decorators, no union types, no enums, no autoloaded non-classes, etc) * Abstractions in extension or libraries are often limited, incomplete, or missing options. * Database access is okay, but pretty limited for building SOLID domains or models. * Handling of timeouts throughout PHP is sometimes problematic, depending on the API. (try canceling a SQL query after 10 seconds). * Documentation is usually incomplete and/or has gaps. * There's a fairly large disconnect between the developers of PHP, and developers who use PHP. * Breaking changes are expected fairly frequently, relative to other languages (major ~10 years or less if the PHP8 talks are any indicator, plus several on minor: even Python 2/3 isn't that bad). * Integration with non-PHP code, outside of network requests, is complicated. For simpler web pages, this doesn't matter too much. In some cases, it matters more.
Nice critical-thinking there. Don’t invest too much time into trying to make this client think otherwise. When they hire a company that avoids using PHP, they’ll just pay for it in maintenance and be pigeon-holed into the agency’s services. PHP powers several of the most popular web softwares, thus it’s easy to find an agency who can support your IP.
&gt;The problem of php is that's its way to easy to write shitty code and there are lots of developers doing that. and how do languages like javascript with node make it harder to write shitty code?
If I'm not mistaken, the general idea is that you can offload email to another server via socket. I'm not certain, given all the extra steps, if that's actually saving anyone server resources, but that seems to be the angle of the article. I suppose the rest is just that if you're already breaking your application down into very self reliant modules you may as well do it with every piece so as to have full consistency.
Please don’t get me started on Electron and CEF based apps.
right, but also node is not a language, it is a framework for JavaScript utilizing a C library called Lib Unicorn Velociraptor to handle the event loop.
Email? IE6? Sir, I think you'll find "email" and "browser" are two entirely separate things, and this "web-mails" fad will never be a substitute for a *real* email client. &gt; Sent via LotusNotes ^^/s _____ OP: Honestly, I'd ask them what language they want. If you don't know their chosen language and/or have no interest in it, then just take phpdevtester's advice and wish them best of luck.
&gt; Send Emails Over Sockets I know SMTP strictly speaking isn't tied to any particular transport, but good luck using anything other than TCP sockets in practice. &gt; 4. Connecting with an email service (blocking I/O) &gt; 5. Receiving a response from the email service ( more blocking I/O) Why blocking I/O? Async sockets are basically the `Hello, World!` of async systems. Doubly ironic you tout this advantage when the `Socket` class in question you use to send the data to the microservice *is blocking I/O*. I guess the latency to your (presumably) LAN-based microservice will be better than to your SMTP server, but even still: you're paying basically all of the cost of blocking I/O even still. (In fact you're paying more since the microservice is paying the cost of blocking I/O even still.) 
I always say I've written php since before it was called php.
You can replace PHP with any technology that doesn't have the 'aura of brand-newness' and it'll be something you hear regularly. Any broadly used language will have bad applications, exposed and well-documented flaws, historical mistakes, etc. Only the ones that were invented yesterday seem perfect and cool. Then you try to look op some info that's not absolutely basic, and it turns out the parallax scrolling one-pager extolling its virtues *is* the documentation. 
I would love to hear this reasoning..
For me it was when the first P stood for “personal” and not recursively “php.”
&gt;go if err != nil { return fmt.Errorf("parsing json: %s %v", name, err) } 
PHP is a good language mate, Depends on the User Perspective if they want it too fast and too secure; But I doubt, The Language in itself a strong one. From what I heard PHP has been there for a lot of years since its early developments. PHP is a good language compared to Go Lang, Go Lang although has a lot of Features but desperately you need to code some of it though, PHP has been there for ages, Like Static Coding methodology. :) Afaik (PHP is Single Threaded but you need an External Library to make it go Multi Threaded)
Honest question here. What’s wrong with WordPress? Sometimes the use case for building something on it is quite compelling to customers. Obviously like any other CMS/platform, it has flaws and isn’t always the right tool for the job. All I know is we’ve built some stuff on it that just run and none of our clients seem to be complaining.
Wordpress is great for what it’s intended for, simple blogs. But it can get very messy very quickly when you’re trying to bend it to do things it’s not supposed to do. ie. E-commerce, members, subscriptions, APIs. The thing I personally don’t like is that once I started working with OOP and structuring my code to fit with an MVC architecture, Wordpress just felt sloppy and unorganised when I was building templates. Again to reiterate, good for what it’s intended for, very very bad when you’re trying to force a square through a circle hole. 😅
Async/await is still not in PHP. 
It sounds like they have been sold something like Java Enterprise or some other garbage that they heard from a vendor/competitor/etc. PHP is not really marketed on its own so you won't find some exec hearing about it through a conference or something. They might also be catching wiffs of NodeJS-- NodeJS is great honestly for some types of project but the learning curve, specific and less-documented tooling, and long-term support don't come close to PHP. It is secure because it is so popular and it has been around so long. As long as you have a good team managing the install, are on a good operating system and are running good software on it, it's great. You will not have a hard time finding talent to work on your projects, problems will be solved easily and there will be an upgrade path likely as long as the internet works the way it does currently. Facebook, one of the largest companies in the world still uses it in their web stack (I believe)
That's a big stretch... Care to elaborate?
True, but we have amphp and react, i.e. a decent Promises/A+ story. Even Node didn't have native async/await enabled by default until early 2017. If the [fiber](https://wiki.php.net/rfc/fiber) RFC makes it into the core, async/await is likely just a matter of time.
Ok, i see, PHP fan boys are good at down voting facts when they feel challenged. FYI: I use PHP. 
&gt; The first steps in learning php are really simple. That's a problem with the design of PHP? &gt; Most webhoster still offer old and unsupported versions of php, some even offer php 4. This has nothing to do with the design of PHP. &gt; PHP started as a template language and it's still really simple to embed php in html pages like in this tutorial: I recently came across a simple Python application that does this exact same thing. Turns out that's the easiest way to get started in almost any language. Sure, other languages can force that separation but it does make quick scripts more difficult. &gt; It's also a very forgiving language. Lots of problems with the code only throw notices, not exceptions or errors. This is a good point. Although the concept of a "warning" in programming languages is pretty pervasive. &gt; Notices don't halt the execution, you can configure that they are not reported at all. You can also configure them to halt execution; which is what I do. &gt; It has dynamically typed variables and does a lot of type casting on usage, it allows numbers and strings to be used as booleans and so on. Like literally dozens of other programming languages. Even strongly typed dynamic languages like Python allow numbers and strings to be used as booleans. &gt; It allows to disable error reporting for functions calls if you prefix the call with an @. You can ignore errors in almost any other programming language as well; it's just an empty catch {} away. Admittedly PHP does make this easier so I'll give you this one. &gt; http://php.net/manual/en/security.database.sql-injection.php I fail to see the problem with that page, it presents sound advice: * Never connect to the database as a superuser or as the database owner. Use always customized users with very limited privileges. * Use prepared statements with bound variables. They are provided by PDO, by MySQLi and by other libraries. * Check if the given input has the expected data type. PHP has a wide range of input validating functions, from the simplest ones found in Variable Functions and in Character Type Functions (e.g. is_numeric(), ctype_digit() respectively) and onwards to the Perl compatible Regular Expressions support. I take issue with the idea that PHP is really any easier to write shitty code than any other language. Have you seen JavaScript?!? How about C? It gets tossed around but really there isn't any substance to it when you really think about it. 
Serverless technology? mmmm. Sounds interesting..
It means that you have not migrated uptill yet.
hmmm nice. btw C is mother of all languages. so, it wouldn't be a greater surprise. 
Brogrammerpalooza, the one all the cool kids were invited to. You didn’t get the evite?
Thanks for sharing wisdom. 
Nice. 
Are you talking about Waseem? 
Legacy code doesnt work. Still trying
If you can, don't work with such clients. They "know" everything better it seems. Then why hire a professional if they know everything?
Would help if you described your API a bit, or give us hint on how much heavy lifting it'll do in behalf of another application. So it really depends on what API you're developing, but IMO, Laravel is overkill for most API cases. Personally, I rarely use any framework for API tbh, specially for simple API calls and responses. 
Not sure what’s up with all the down votes but you have raised very valid points. I use PHP at my day job and it does fine and it’s what puts money in my pocket so there are no doubts that it’s still relevant and a decent choice even for new projects but sometimes there are better tools for the job. We are staring to look at pulling in Go to our stack for scalability reasons. 
lol. its a derivative of php latest version basically. :)
Anyones has before tried this one with PHP and could share the experience with me?
Nothing is wrong with PHP or any other language. I personally would start a NEW project by investigating what they want/need, and then decide on the solution. But if they say: it must be ProductX, then I would always ask more about that particular choice, to gain more information. It never can be a decicion made on a golfcourse because his friend uses it too. And can that person really make a decicion like that? Does the person have good knowledge of the IT landscape and capable of making good decisions about it?
This is pretty simplistic thinking on Ruby. The most popular web languages are the ones which have the lowest barrier to entry, not the perfect paradigm. 
I think it's our flaw, if we don't know names of PHP community shinning guys. It only reflects that you are out of the ecosystem. 
lol. I don't agree with it. 
I someone shares interviews of PHP community persons that doesn't mean that the publisher is a spam or the submitter is a spammer. Don't look the world with Close eyes. God bless you buddy. 
It is not very pleasant to write PHP due to its standard library and type system. Its request-based architecture also may be not the optimal solution for for example API endpoints for an SPA due to the overhead of having to reboot the whole application on every request. Although people try to solve this / a first solution attempt exists (forgot the name). But "wrong with PHP" would be a hard statement that the facts just don't support.
Just a correction (and keep in mind, I love PHP and used it for probably almost 2k work hours): Like the user earlier said, the problem with PHP is the users. And by users, I mean the endless stream of sub-par "developers" (who I'd never even call that, let alone Software Engineers) who use PHP solely because it allows their godaweful logic to somehow work (until they try to tauch it 2 months later and it explodes), and allows them to "not worry" about variable types, etc. In part due to the above, and in part due to the popularity of garbage like Wordpress/Joomla/Etc, few of the better SWE's see through the river shit to find the golden bottom under it, and move to other languages. The thing is, while PHP is amazing, but if you want to find a proper SWE / Agency to maintain it, prepare to spend a few hundred hours rejecting candidates and potential agencies until you find a proper one. And that is **if** you got somwbody in-house who's able to evaluate them.
Facebook developed HHVM. 
I have read shiny mew and was was like dude, I wand a blue shiny mew as well! 
Ruby's breif moment of fame was thanks to successfully introducing the MVC paradigm to the web. Beyond that it has a cult following and most likely always will but even the tools I used to work with that utilized Ruby are fading away. Personally I am happy not having to work in Ruby anymore and am excited with all the work there is in Go and happy to see it's influences in Swoole. 
Nothing wrong with PHP, many JavaScript programmers I encountered including my colleagues who are not willing to learn a new language, They just believe a language can build everything from front end(mobile , web , desktop) to backend ..
Yes, I tried react and amp too (I used reactphp for ~12 months initially). They can't compare to swoole at all, it's like comparing a skateboard to Starship Enterprise.
Google App Engine.
But that is exactly what you do when you let composer, npm, etc handle your upstream reps automatically.
Because there's no perfect language, every language has its strengths and its weaknesses. I've been here before: I spent a decade of my life writing COBOL and taking shit from C programmers in just the same way. And yes, there's things wrong with PHP, and there's certainly edge cases which you can trot out to show those. But that's true of every programming language and these edge cases generally are either unlikely in the real world or well known to people who actually program in the language being criticised. Me, I've been programming with, and making a living from, PHP since PHP 3. It works just fine and it's the right tool, **for me**, for the jobs I have to do. So there's nothing wrong with it. If that's the same for you then just shrug and move on. That's what I do.
But isn’t the fact that the PHP tag is not closed sufficient for not sending any kind of body text?
I believe serverless will change a lot of things in how we run, but also how we build web applications. PHP has to follow in order not to fall behind.
It is today, but `die`ing helps out the new guy in 3 years who wraps an `if`clause around the header for some reason and the code doesn’t work.
Correct the path in php storm xdebug settings
The advantage, if the library and title weren't utter shit, would be to have a service to offload sending emails to so your web page doesn't "hang" while waiting for mailing service (SMTP) to do its job. However, it looks like it's just another "hey, look at me, I do cool stuff too" type of article. Ultimately, everything works over sockets. HTTP works over sockets, HTTPS works over sockets so the title is.. awful. You can solve the problem of "hanging" while waiting for SMTP to do its job in several ways: 1. Use Mailgun or a similar service. Set the wait time for curl to 0. Now you have fire-and-forget API 2. If you use php-fpm (which you should, since it's 2019), there's a function called `fastcgi_finish_request`. It flushes the output and sends it back to web server, but all the code after the function continues executing. You can stick your mailing code after that function. The worker will still be busy until the mail has been sent. 3. Create your own tiny REST API that you query, instead of using Mailgun, apply the same trick with curl. Voila, now you don't need to "send emails over sockets" and deal with "what happens when my service goes down".
I think the fact that it's easy to pick up also means it's easy to write bad and error-prone code. Of course it's also easy to write good code that e.g. can be statically analyzed for errors, but you actually have to make the decision to do it and not diverge from it out of convenience.
It’s lucky that everything is a “web server running php” then, dodged a bullet there.
There's no example in the article that shows how "other languages" do it and why using PHP would be superior. Note: other languages do it the same way, the method is trivial in any language, title is - again - misleading. What's happening lately with misleading, falsy titles in this subreddit?
hmmm. good
Click bait I guess 😅
okay
Please don't suggest people run composer update for adding or removing packages.
There’s nothing fundamentally insecure about PHP. There have been some things in the past but they were dealt with years ago. Any insecurity in the PHP ecosystem today is a consequence of the fact that it’s an easy language to get into and so there are a lot of inexperienced developers using it. This is no more an indictment of PHP than the fact that it’s easy to buy a circle saw and cut yourself with it means power tools are bad. 
In fact it is a hell of a lot easier to write shitty code in C. 
There’s nothing wrong with being late to the party. Waiting out the endless new programming fads until they’ve had a chance to prove themselves or die trying is a good thing, not a bad one. 
Awesome, I just DMed you on Twitter, My Twitter Account is found on my Reddit Page, I currently do not work with InfoSec as of the Moment, Just reply if you received my Message Request. Good Luck and Wish You Luck on that, PS: I'm not a current Information Security consultant but there's a Probability. I like your Concept to be honest. :)
Agreed, we know JavaScript libraries and web frameworks are enormous for us to solve tedious problem fast and if they are more on frontend and less on backend as what their jobs require? For a market size in China, India and USA where they need performant, Golang became popular alternative.
Agreed, but nowadays, if we could go languages offer typed system to ensure the data is correct types, it’s the better solution for long term.
Don't be afraid to use your own framework. Using common frameworks is like buying a SUV. They are trendy but heavier and with higher "consumption". If it works well, then why not?
Was that an automatic bot reply...? 
Well to be fair, this is called “for dummies” 😂
That doesn't answer his question. I, and many other developers, won't even look at an application that size without thorough test coverage because it's just too risky. A full e-commerce platform without tests is potentially a disaster waiting to happen, since there's no assurance whatsoever that future changes won't break the platform. Also, putting the packages in a dedicated \`packages\` folder like that is a really bad idea - that's what Composer is for. Put them in separate packages and require them in your \`composer.json\` so you can update them.
&gt; You can solve the problem of "hanging" while waiting for SMTP to do its job in several ways: You can also put the email on a queue (beanstalk, rabbitMQ, etc) and let the queue handler send it, unconnected from the front-end. Bonus points is that it makes failures easy to handle, as you can re-queue the job after incrementing the job's failure counter, and only kill a job if it's failed too many times.
What about everything else. Is it a solid introduction at least?
Second this. I'm using rabbitMQ to send emails in batches.
New to me. Why not? What's the right way?
`composer require` and `composer remove`. Update will update everything. All your libraries will get new versions depending on how your configures your composer.json. Imagine this, you have a server running your website. Would you upgrade all your packages on the server everytime you wanted to install or uninstall a piece of software? 
Other than being wrong on how to add and remove packages?
Thank you. Readme should have been placed on Github, that's why I asked.
not sure what you mean by "full api", but accessing WP data remotely requires usually setting up an ajax endpoint for every action, and that's just terrible in wordpress.
Wow, such empty. I’m going to try it.
https://github.com/Symplify/EasyCodingStandard It combines PHP CS Fixer with PHP_CodeSniffer in a single config file.
Butytho?
Related: https://www.reddit.com/r/PHP/comments/abtdx3/serverless_php_on_aws_lamda/
&gt; Didn't say the "Laravel Faithful" to you directly, I noticed I was getting down voted. Sorry, I just assumed it was meant for me since I was the 1st to respond to your comment and my tone was perhaps a bit too harsh. &gt; I also didn't claim it "couldn't be used", I simply said it "shouldn't be used" I still disagree that it "shouldn't be used". It's too absolute of a statement since it greatly depends on the situation IMO. If your **only** concern is reducing the response time as much as possible, I might agree (using something like php-pm would make this issue largely irrelevant though), but that wasn't really what OP was asking.
I got it working after days, posting here because this is one of the only few thread I found while researching it: [https://github.com/yyx990803/laravel-vue-cli-3/issues/11#issuecomment-451154428](https://github.com/yyx990803/laravel-vue-cli-3/issues/11#issuecomment-451154428)
Further to this: 1) always commit the composer.lock file 2) have the server run `composer install` on deploy to install the exact package versions defined in the lock file. If it's super critical that you get an exact version installed regardless of `composer update` being run, consider locking the version number down in your composer.json. We do this for deps we've not yet got the time to test updated versions for, and it helps when adding new packages. (If you go down this route, `composer why` and `composer why-not` are super helpful at telling you why a package is needed/can't be installed)
Per the article points: 1. Gathering the information (name, email, message, etc) 2. Generating a template to put the information in 3. Potential attaching files, calendar invites, etc 4. Connecting with an email service (blocking I/O) 5. Receiving a response from the email service ( more blocking I/O) 6. Logging that response Actually looking at, points 2, 3 and 6 have I/O and memory, but I'll digress. Lets say you are service like LinkedIn, and you get a message from one of those annoying recruiters *"I have an opportunity for you blah blah blah"* and LI sends you an email. Break the above components into milliseconds of execution: 1. **Gathering the information -** depending on requirements this can be 10ms to a few seconds. I use to work for a company that did mass emails based on people's current zipcodes and match them options local to them. Took about a 2 seconds per user with the amount of data we used. 2. **Generating a template to put the information in -** In PHP, this means likely using a templating system like Smarty or Blade to parse the data in. 10ms. 3. **Potential attaching files, calendar invites, etc -** If no files, no time. If files, they typically have to be downloaded first and then attached to the email. 0ms to 2 seconds, depending. 4. **Connecting with an email service (blocking I/O) -** If the service is in good standing, 10ms. If its down and you wait for a timeout and connection to another service. 200ms 5. **Receiving a response from the email service ( more blocking I/O)** \- Depends. Services like mailgun send an ID back, which takes about 300ms to generate. 6. **Logging that response (and more blocking I/O)** \- Depends on how its being logged. On file system, in a database. Elsewhere? 100ms All the steps involved, you are looking at anything between 150 ms to 4 seconds. If only step 1 is executed on a web server and everything else is executed on a microserver, and it takes about 15ms to transfer the data over and does not wait for a response, you will improve the performance of the web servers.
You can use Vue.js as an alternative to jQuery or plain JS in your PHP application for doing some lightweight operations or you can also use to create a separate SPA as you mentioned. 
Yeah, I think people dont realise how risky `composer update` can be depending on how you've configured composer.json and also the version scheme your dependencies use. I've even seen people suggest running `composer update` on your production server when you deploy a new version of your code which is frankly insane. By all means run an update when you want to get all your depencies updated in your development environment, but understand that there could be thousands of lines of code changes coming in and be prepared to test all your code thoroughly. 
&gt; but understand that there could be thousands of lines of code changes coming in and be prepared to test all your code thoroughly. This is why we lock shit down to hard version numbers. We deal with sensitive data and thus any package added or updated we have to audit. The last thing we want is a `composer update` pulling in hundreds of lines of unaudited code. While attacks that npm's packages have suffered are not as easy in composer's land, it's a clue that a deep threat could be lurking if someone managed to gain write access to a popular repo.
Your phpstan.neon needs to define where the autoload file is.
Shocking, Speckz the spammer duplicating posts after only reading the headline. 
Great article. (FWIW, the mantra I learned early in my career was "filter input, escape output.")
In regards to setting wait time to 0 and flushing is a great idea but the drawback is the loss of logging what happened. Mailgun does return an id of the transaction along with other meta data that should be stored in the application for potential future use by the microservice that is sending it.
great write up. still not sure the use case for serverless functions in general, but still great to know how to implement them if necessary
Oh you're 100% right, the methods I listed aren't bullet proof at all, they're more quick hacks to get it working. Creating one's own dedicated service with a queue, logging and retry mechanisms is the way to go. That's what the author of this article tried to present, but he ended up advertising his "prodigy" socket library instead of focusing on the bulletproof solution. Nowadays we've got swoole and zeromq which are universe apart compared to his hacky socket solution.
Think of something like an image processor (resize/add watermark). Your lambda has the code to do the image processing. You call the lambda and give it the image, it does the work and exits. Contrast that use case to having a server that runs 24/7 waiting for images to arrive, where you pay for all the excess computing. With lambda, you only pay for when a lambda runs. It can be cheaper depending on your use case.
&gt; Sanitize your inputs? I think not. Not because it's wrong. Because it's meaningless. Well... I mildly disagree. It is wrong. Decades of experience has proven that sanitation is fraught with edge-cases you didn't think of. The article does a pretty good job of explaining what to do instead, so I'll just defer there.
Thanks for the great example
To a certain extent, you're just being pedantic IMO. To me "sanitize" is an umbrella term and anyone that knows they should sanitize their inputs knows that sanitization one operation that applies to all scenarios. Sometimes it's filtering (changing the input to a valid format). Sometimes it's validation (rejecting invalid input). Sometimes it's using the input safely (prepared statements for DB operations, escaping for rendered output). Your coverage of those topics makes for a decent introduction to those that don't already understand them, but the part of your article that is just nitpicking on the phrase "sanitize your inputs" came across as just that: nitpicky.
To a certain extent, you're just being pedantic IMO. I would hope as a programmer you'd be able to grasp that the English language provides abstraction too :) IMO "sanitize" is an umbrella term that packs a lot of meaning. If one knows software development well enough to know they should sanitize their inputs, they should also be capable of understanding that sanitization isn't one operation that applies to all scenarios. THAT wouldn't make sense. But saying "sanitize your inputs" is a meaningless statement is like saying "design patterns are meaningless" but MVC, Active Record and Unit of Work are meaningful to talk about. Yes: you should sanitize your inputs. Then the question is "how do I sanitize my input in this particular case?" Sometimes sanitization is filtering (changing the input to a valid format). Sometimes it's validation (rejecting invalid input). Sometimes it's using the input safely (prepared statements for DB operations, escaping for rendered output). Your coverage of those topics makes for a decent introduction to those that don't already understand them. It answers the "how" question. But IMO you stepped on the positive part of your post by opening with paragraphs of nitpicking language that's actually pretty meaningful.
This IS what I do, validate on input. Why do I have to try to clean someone's first name? If it contains some unwanted stuff then it means it's already wrong in the first place. It is the user's responsibility to enter the correct data. My job is to make the whole entry process as smooth and easy as possible.
/r/PHPhelp is a better place to post this.
Thank goodness for this disclaimer because I am very amateur, mostly self-taught and I have a very specific question. I built a new Wordpress site for an organization. I have an FTP export of the old site, including a page of the site used to be an html plug-in type thing that helped users track legislation. I want this page on the new site, too. But someone who knows more than me says this type of thing is not compatible with Wordpress, but if the FTP export from the original site was used untouched (it is), then I likely need the hosting provider to configure HTML files to parse PHP, and modify the permissions on the files contained in the folder. What does it mean to "configure HTML files to parse PHP, and modify the permissions on the files contained in the folder"? Do I really need to get someone else to do this or can it be done by myself? Can someone explain in layman terms? Does this even make sense?
also thank mr skeltal for good bones and calcium[^*](https://www.reddit.com/r/tmsbmeta/)
&gt; an umbrella term that packs a lot of meaning That is exactly the problem the author attempts to address. Explicitness and specificity in technical language, especially via a shared vocabulary with well-understood meanings, are important for effective communication. And as a special bonus bit of humor: &gt; To a certain extent, you're just being pedantic IMO. I would hope as a programmer you'd be able to grasp that the English language provides abstraction too :) That's just a facade. ;-) 
You need to configure your autoload config `phpstan.neon` - https://github.com/phpstan/phpstan#autoloading If you still struggle, ask in PHPStan issues - https://github.com/phpstan/phpstan/issues, there might be more people who have the same problem. 
The "baseline"/cache feature is must-have, I'm glad you've added it! 
Oh, it's definitely wrong. I'm just trying to make the case for folks to stop using "sanitize" for all this stuff because it's become a security catch-all to the point where it's meaningless. But even if you take the narrow definition of "sanitize", it's still wrong. Ironically for a post about clarity of language, I should've been clearer here! lol Post has since been updated to *Not just because it's wrong.*
&gt; All the steps involved, you are looking at anything between 150 ms to 4 seconds. If only step 1 is executed on a web server and everything else is executed on a microserver, and it takes about 15ms to transfer the data over and does not wait for a response, you will improve the performance of the web servers. Yes, you've taken your blocking I/O down to some fraction of the original expected time, but whether we're talking about blocking for 150ms or 15ms you're still talking about an eternity in CPU time - that was my point when I said: "I guess the latency to your (presumably) LAN-based microservice will be better than to your SMTP server, but even still: you're paying basically all of the cost of blocking I/O". An actual async I/O approach would make all the time data is in transit the kernel's problem, and since you're presumably on a multicore system the kernel is also likely to use a different CPU than your work-laden email thread to handle sending it. While you'd still (hopefully) check up to make sure all your async sends eventually succeeded and that'll impose the same worst-case performance of a timeout you're now overlapping just about all of that waiting with each other. Ex: If your CPU can manage to generate one sendable request to the SMTP server (Not quite how SMTP works but let's ignore that for simplicity) each 1ms and you want to send 10k messages then you're looking at (10k * 1ms) + (worst performance possible for the last request, let's assume a 4s timeout) as your own worst case performance to get all email attempts through (So 10s + 4s). 14 seconds. Once that time up there should be a resolution for all of your async sends. Let's be generous and say you can move that request to another service in merely 1ms inside your own network and that service will never fail, and add the original 1ms for creating a request: that's 10k * (1ms to generate + 1ms to send synchronously) = 20 seconds. And that's with the generosity of a 1ms time being guaranteed to be enough to send it to your local machine, and with no generosity to the async case whatsoever. Now there's nothing particularly wrong with not caring if something like a big email send job takes a long time - treating it essentially as a background batch job means all the time spent waiting on I/O is a) usable for other threads and b) a way to prevent your email thread significantly worsening network performance for other threads, but if your goal is to save yourself the execution speed nothing will hold candle to an event loop in the general case.
Can't help but wonder what the point of these sorts of posts are. There is already a Symfony sub-reddit where links to the [original Symfony blog posts](https://symfony.com/blog/) are kept. The medium post linked in the title just seems to copy/paste the original Symfony post and then adds a bunch of advertisements. Where exactly is the value?
Sanitising means to clean. Validation me as to check, verify, or... Validate. Two different terms with different meanings. If you sanitise inputs you rarely let the user know. When you validate, it's usually for the sake of providing a method of feedback to the user informing them of the error and possibly how to remedy it. 
What do you think about trimming the input?
&gt; If the database server receives 5); DROP TABLE blog_posts;-- instead, it will respond, "Nice try, but this is clearly a value and additional instructions. Not gonna work. Rejected." I think you made this confusing by rejecting sql injection because it isn't an integer... a better example would be protecting: &gt; SELECT * FROM Users WHERE last_name like '?%' If I want to search a database for a last_name of 'smith"); DROP TABLE blog_posts;'... what is preventing that prepared SQL statement from executing any more than a direct sql statement using mysql_real_escape_string() on the parameter? That statement would be executed safely - not rejected. This seems to hinge on you not using a string and can instead ensure only integers are sent. Perhaps I'm wrong, but I thought prepared SQL statements simply provide a more reliable way to escape parameters and enforce types... they don't identify strings with sql injection and reject it the way you describe.
https://shinesolutions.com/2018/01/08/falsehoods-programmers-believe-about-names-with-examples/
\&gt; What is your vision for 2019 with psalm? Not much of a vision to be honest. Just the unsexy stuff - maintenance, improving docs, listening to community feedback and making it a tool that more people want to use. Three years ago none of these tools existed (at least not publicly). Now there are three tools (Psalm, PHPStan and Phan) with widespread adoption that all do a decent job of finding low-hanging-fruit bugs in code. There's not a ton more to discover there. Stepping back a little, the future of all our tools is intertwined with the future of PHP. We can and we must do a better job of evolving the language, improving how it's used, and evangelising it to other developers. I'm really excited, for example, by the steps the WordPress development team are taking to require PHP 7.0 by the end of the 2019.
&gt; there are cases where a number is part of someone’s legal name. Jennifer 8 Lee chose to give herself the middle name of 8 because 8 is associated with good fortune. (╯°□°）╯︵ uoᴉʇɐpᴉlɐʌ
\+1 for correcting yourself. I was just looking for a quick tutorial to get me started in the future in case I decide to start using it.
Not really a beginners tutorial but I linked to [this](https://blog.martinhujer.cz/17-tips-for-using-composer-efficiently/) blog post elsewhere. I'd definitely read that if you're interested in how to use composer. 
Yup, I've had a couple people mention that. I added a note about it at the bottom.
As in trimming the whitespace? Sure, why not?
Tyvm it seems great
You're right, I got too cute with my example and muddled the whole point of it. Thanks for the feedback! Updated: [https://kevinsmith.io/sanitize-your-inputs#send-query-and-parameters-separately-to-the-database](https://kevinsmith.io/sanitize-your-inputs#send-query-and-parameters-separately-to-the-database)
That was quick. Good stuff. :)
Not sure if this will help, but I'd give a try to [https://github.com/FriendsOfSymfony1/symfony1](https://github.com/FriendsOfSymfony1/symfony1) (a fork with PHP 7.2 support).
Which is a very clear reason why one shouldn't sanitize input. If you know that someone might say their name is &lt;script&gt;alert('foo');&lt;/script&gt;, and it's possible that this got into the database, you're going to be quite certain to escape the value for your output... (And "output" here might not be HTML intended for a browser; it might be an XML parser that poorly follows very strict DTD definitions and will crash when it sees an element that it doesn't expect, opening you up to an easily exploitable denial-of-service attack that doesn't need to be distributed to be effective.) By remembering that your data might include dangerous data (and let's be honest, nobody can sanitize all dangerous data for every possible format that your junior devs will touch in 5 years after you've left the company, you most definitely do have a database that might include dangerous data), you program your outputs more defensively; using prepared statements when the DB is your output; using HTML validators; using libraries that build XML documents from your data structures; using CSV functions rather than just slapping quotes, newlines, and commas everywhere...
I strip all vowels from input. Check and mate, Lttl Bbb Tbls.
Although I share the general sentiment, I reported this article as a blatant spam nevertheless. I would call it a leech publicity. A very popular kind of blogspam, when an obscure company tries to leech on a big name to promote itself. 
Just remember that every name is valid. Even the name &lt;script&gt;alert('foo');&lt;/script&gt;. Just make sure that you're sanitizing for the specific output that comes next (i.e., you're escaping the apostrophes -- or better, using prepared statements -- when your output is the database, wrapping it in escaped cdata tags when your output is XML, using html\_entities() when your target is HTML (and not the inside of an HTML tag or inside of an existing script tag; those are different beasts altogether and deserve a trip over to [OWASP.org](https://OWASP.org) for a more exhaustive list than is appropriate for Reddit or any other sufficiently nerdy forum, for that matter...)
Dude, I was ringing this bell for decades, but, being illiterate, had a little success. So now I'll just bookmark your article. 
Thank you!
Where would you go if you need an onion web developer?
Do you really need a library to assert whether an integer is positive? 
I agree it’s fantastic, but the II isn’t very intuitive. I guess that’s what happens when it’s so feature-rich. 
The baseline feature makes trying this out on our legacy codebase very attractive! Looking forward to testing this out.
That happens in all the languages, no?
I very much like your suggestion of using enums. One thing I always tell junior developers about input validation is "whitelist when possible" - in other words, if it's not a free form input, the input should be matched against expected values. 
&amp;#x200B; Been away for a while, as my ex-spouse decided it was a good idea to put me through personal hell. Not sure who's still here, and who if any remember me, but I've been working on a new software framework for a good while which I coined Apex. Just looking for some feedback, and links below. &amp;#x200B; Main Site: [http://apex.envrin.com/](http://apex.envrin.com/) Demo Admin: [http://apexdemo.envrin.com/admin/](http://apexdemo.envrin.com/admin/) Github: [https://github.com/envrin/apex/](https://github.com/envrin/apex/) &amp;#x200B; It's been so long, I can't quite remember all the modifications, but main ones are: &amp;#x200B; \* redis and RabbitMQ are now mandatory, and fully supports horizontal scaling. \* Supports both, one-way messages with acknowledgement only to RabbitMQ, and two-way RPC calls. \* New package that fully integrates with the DigitalOcean API. See [http://apex.envrin.com/docs/digitalocean](http://apex.envrin.com/docs/digitalocean) \* Rotating SMTP servers, database replication with in-house evenly distributed connections with only writes going to the master database, SMS via Nexmo, 2FA, etc. \* Documentation is more complete \* New administration panel theme. \* Loads of things I'm sure I can't remember. &amp;#x200B; &amp;#x200B; Apex is nearing completion, and is completely open source. Here's what's still on my todo list: &amp;#x200B; \* Two-way encryption. Need to either find a library that supports data being encrypted to multiple RSA public keys, or develop my own. Can't find anything decent that supports multiple keys yet. \* Caching library. Need to research existing open source libraries out there still. \* Unit tests via phpUnit. \* Strengthen messaging / RPC/WS with redundancy / error handling, and translate into either C/C++ or even Python \* Base packages (user management, transaction processing, etc). \* Customizable home page of admin panel allowing each administrator to select and place various widgets on their home page \* Default member's area. \* Finalize theme management, including integration with Envato / ThemeForest API. &amp;#x200B; I generally get hammered while putting out these updates, but I really don't care, as I have so much time and energy invested into Apex now, there's no way I'm turning back. This will meet out business needs perfectly, and besides, even through all the insults, I generally manage to garner some decent feedback. &amp;#x200B; Any feedback would be greatly appreciated. If you want to contact me directly, e-mail me at [envrin.group@gmail.com](mailto:envrin.group@gmail.com). &amp;#x200B; PS. Due to emotional distress of my ex-spouse being a total asshole, and Apex being larger than originally anticipated, in a bit of a financial pinch right now. Everythingg is open sourced and under the MIT license, so if anyone is by chance involved in bitcoin and willing to donate a bit, any little bit would help at the moment. Payment address: 12yLGWeNtjZCowJTZUmdXzBcZJNEvfzGL4 &amp;#x200B; &amp;#x200B; &amp;#x200B;
Why?
That particular library does a whole lot more and to untrained eye it appears unnecessary. 
What the fuck? Literally just asking a question as to whether it’s necessary to use it or not. I’m not an expert in OOP and wasn’t sure if this was SOP. Don’t be that internet guy who takes offense to every question, be wise and use this to calm the fuck down. 
This video gave me literal anxiety.
Each to their own I suppose, not a fan of Go's approach to limited features, type system, error handling and more. Lightweight threads and channels is cool but Go's not the 1st language to do it.
The limited features, type system, and error handling were all intentional decisions. The core of the language is simple enough to memorize while being extendable in first class libraries and packages. If error handling was more advanced then people would abuse it like current try/catch statements that trickle up multiple levels of code but if it was too strict then too much boilerplate would need to be included for simple operations. I am also one of the few that do not care for generics as you are replacing compile errors with run time errors in the name of writing faster code that can be harder to test or debug but like you said, each to their own.
Have you ever heard of the word "Irony"? I don't really know why I get into these situations with insecure newbies.. I guess this is the part where I apologize that I struck a nerve, I am so very sorry. Are you going to be ok? Have I ofendeded you too much? Please, forgive me. After your kind words, I have calmed the fuck down and the whole world is zen. I just wish you are able to get on my level, but there's no magic lamp around.. 
You sound super lonely.
I don't see why not
Agreed. I can't see why not.
I'm actually stupid for arguing with a definite moron.. I "sound" over textual medium.. and I argue with a person who takes offense instead of learning opportunity. Please, do us all a favor, click the logout button, make this a better place. Thank you and happy new year :)
Wait, what?
I'm impatiently waiting for php 7.4 with typed properties in class. I will be able to create "structure" without the repetitive and verbose getX() and setX().
Very productive comment :) Nice one
Well, \- the main site is full of errors, \- the demo admin doesn't work (unable to login and errors on the screen), \- the github has been recreated from your last post (what's the point to use git if you don't really commit stuff) \- and finally, there is no tests at all &amp;#x200B; This should be your priority #1 instead of your todo list! I've tried, but i can't take your project seriously if you don't fix the things i mentionned above. This is the basics... And please, leave you personnal life out of this, this make you look unprofessionnal.
Did you read your title? It’s rather incomprehensible 
I didn't figure out why I only had like 100 chars and only url+title, and no title+body. I had to somewhat shorten it. Luckily the link then reveals the full - and hopefully comprehensible - article then.
Sry, the title was indeed a bit short. It is about \`composer update --prefer-lowest\` in CI. I would like to mainly know what edge cases are important to consider, and what your experiences so far here are. Maybe you have also some valuable insights into this topic, or have ideas for future improvements.
This is an excellent article and I had a little knowing chuckle when you mentioned the first hit you get when you Google "sanitize form input." That's exactly how I came to learn of prepared statements when I started! A little addition I'd suggest would be an example of sanitization to better hammer in the point it really doesn't accomplish much. I'm a visual reader and while prior experience helped me understand your point straight away, other beginners may not be convinced. Thanks for a nice read.
Framework doesn't matter just as long as it is a new and well supported one (otherwise you might shoot yourself in the foot). &amp;#x200B; In PHP you can always throw more machines at a problem as long as you have decent database/cache timings AND you have properly set-up load-balancer. Everything else is a matter of cost. (read, ability to buy servers to do the job)
why would you ever think that &lt;script&gt;alert('foo');&lt;/script&gt; is a valid name?
Obvious troll is obvious.
Well after enabling this plugin just caught regressing again [https://travis-ci.org/jomweb/CakeImpersonate/jobs/475125593](https://travis-ci.org/jomweb/CakeImpersonate/jobs/475125593) the travis-ci build says load phpunit/phpunit:\^5.7.14|\^6.0 but composer loads phpunit:5.7.27.0
what could be the problem guys. please help me
It's not. Both languages are do nothing to help guide you into writing good code. JavaScript on Node.js is arguably even worse than PHP due to callbacks.
Compare PHP not to Python but to a statically typed language (e.g Java). Better yet, compare it to a statically typed, pure functional language (e.g. Elm). At my company we had been writing a ton of PHP and JavaScript for several years. Eventually we got fed up with our jQuery spaghetti and switched to Elm for our front end apps. We loved Elm so much that now we're using Haskell on the back end. Give Elm a serious try one weekend. It's a relatively easy functional language to learn and the compiler is one of the most helpful of any language ever, example: https://twitter.com/davetapley/status/1079604426589974528 I have no doubts that your opinion on why it's easy to write shit code in PHP will change after trying Elm.
Sorry about the demo admin panel login, and working now. Was just a smal typo on my end. &amp;#x200B; What errors are you getting on the main site? It seems to come up fine for me, but there's always a good chance I'm missing something due to being blind. Let me know what errors you're seeing, and I'll get them fixed up. &amp;#x200B; Yeah, just replace the entire Github repo each time for now, as it's still under heav. Will probably replace again one more time in the near future, then after that will begin using Github properly. &amp;#x200B; Thanks! development and I don't bother keeping track of which files were modified. &amp;#x200B;
I’m sorry that you were abused and feel the need to put strangers down on the internet. 
I'm going to charitably assume you aren't actually trolling. You probably are, but in the event that you aren't, I'm going to list out *some* of the issues in the hope that you have the good sense to take down that outdated travesty, so that in the event that some poor sucker stumbles across this thread, he or she will realise that they should skip this nonsense. &amp;#x200B; Briefly, this ain't 1998 anymore. You're illustrating some bad practices, without even noting their problems. We've had classes, and various frameworks since PHP 4, released in 2000. But there's no mention of these. * Firstly, this thing where you include a file using `file_get_contents()` then `str_replace` to inject variables? Yeah, that's literally what PHP was designed to do. You've literally re-implemented a core part of PHP, within PHP. If you want to separate the concerns of pulling data out from it's display, then you can do that using an `include()` statement, while still getting the benefit of PHP's opcache. * Also, there's twig, which does what you're trying to do, but ... turns everything into PHP files anyway so that you're not doing full text replace on every page load. * The formatting on that if statement makes me sad. Why is `$final_data` hard left? * You say "This function is going to accept an array" on `LOOP_FILE()` when you're in fact setting a *default* of an array. This is not the same thing. * Re-using variables (`$final_data` / `$file`). Don't do this. * Maybe I missed it, but there's no opening and closing `&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;` tags. * Connecting to your database as root. Just... no. * *$sql* is not SQL an SQL statement, it's a result. *$conf* is not configuration, it's a connection. Names mean things. I strongly recommend that you look into learning proper object orientated programming and SOLID principles, and use a heavily opinionated framework like Symfony for your next project. This will force you to learn modern programming techniques. Additionally, look at things like unit tests, and since you made no mention of it - git.
You are just a bastard attacking someone for a question. Quit being a fedora wearing asshole.
Because all of the individual characters can be in valid names. And even if someone is obviously probing for vulnerabilities, you can reject it outright, which runs the risk of rejecting valid customers; handle it gracefully and should you notice it later, be able to check your logs and see what else they were poking at; or not deal with it and leave gaping holes in your site's security.
At first thank you for providing us with the feedback. 1. Clearing all the bad air, I must tell that Bagisto is thoroughly manual tested. And we have a team of testers, business developers and developers which are only dedicated to Bagisto. TDD for Bagisto is for sure not upto par at this moment but this doesn't mean that it will create disaster for usage in production. Proprietorially, it is one hell of an attempt at disrupting the market. The level of effort that had been put in Bagisto was just to make sure that - Will we get positive response from community or not? Till now we are overwhelmed with amount of response that we have received from community as we have got 150+ stars on Github and people are asking us on daily basis about Bagisto. In near future we are going to use Blackfire and Travis CI for Bagisto so that these sought of doubts do not come again, in anyone's mind. We are continuously improving core of Bagisto for now. In next two major releases things will get more aligned and your concerns will get reduced to find trust in Bagisto. 2. For sure all core packages will be decoupled and will be separated in near future for independently updating them but currently some work is left in Bagisto's core. So, we are waiting for Bagisto's core to get fired up and all the core packages will be composerised. 3. Webkul is a world leader in extensions and plugin development for ecommerce. We are partners with major payment merchants including Omnipay also. We will be looking for some efficient solution to that too. 
Really appreciate the work y’all are doing. Keep it up!
On the possibility of Wordpress including sodium_compat... does Wordpress do any encryption as is or will they be doing any in the near future? I'm not sure why they would include a library if it's not going to be actually used in the code...
And the cost savings really are miniscule, if not nonexistent! It's like less than $5/mo difference on a $300 budget to run the same method via GAE in a scalable PHP docker image versus a JavaScript Cloud Function. I know, I've literally ran the experiments, both as actual test cases and on production.
&gt; I'm not sure why they would include a library if it's not going to be actually used in the code... It will eventually be used for [verifying Ed25519 digital signatures](https://core.trac.wordpress.org/ticket/39309) to prevent [a hacked update server from leading to an Internet-wide compromise](https://www.wordfence.com/blog/2016/11/hacking-27-web-via-wordpress-auto-update/). However, even if that conversation is stalled by bikeshedding, adding sodium_compat to WordPress immediately empowers WP Plugin developers to use the sodium API as soon as 5.1 is released, and plan their migration away from mcrypt if they still use it.
The way my CEO stated it was thus: &gt; CEO: I do not care that you proved to me that moving from Google App Engine to Digital Ocean docker droplets would be virtually the same and save the company $36,000 a year, and only take about an hour of maintenance to add new nodes manually every several months when user traffic increases... &gt; CEO: I just don't want to have to worry about. And I don't want you guys to worry about it. And besides, you're and [the other guy] are the only true devops in this company, and that makes us much more dependent on you. &gt; Me: But our GAE bills cost more than some people's entire yearly salaries... And you told me the other month that the startup project just wasn't pulling in enough revenue to give me a raise... I don't get it. And that's pretty much where the conversation ended. I actually quite dislike GAE and AWS for what they provide vs the $10/mo Digital Ocean docker droplets, which are basically the same stats and same thing. For what the company was spending $1,500+ a month per project on, I could set up two dedicated servers with far superior hardware and a load balancer for $200 tops. 
$10/node equivalent to GAE FE nodes that run more like $200/month. https://www.digitalocean.com/products/kubernetes/
But you are already paying to host the web app. So really you have to compare **CPU and Time costs to run the code on the web server infrastructure** vs **CPU and Time costs to run the code on a serverless platform**. And I'm telling you, the difference is miniscule at best. Not worth the headaches.
Because it breaks your "encode/filter on output, not input". I don't have fully formed opinion for one or the other side, but one thing I know is for sure - making trimming whitespaces on input ok creates precedens that it's ok to sanitize/malform input data, leading to saving different data than user specified and loss of information
Have you ever checked your website on mobile?
You are making a common mistake in your example. Only a data literal can be substituted with a placeholder, so '?%' just won't work. It should be just ? With % added to the original string.
Is my first time making videos and english is not my home language. It took me almost 5 hours to record that 21 minute video. But as time goes by, I belive I will improve.
What is this? I looked through the code and I’m like was this created in 1880?
I'd say rule of the thumb is to trim on input (and after trimming check length). It is kind of an exception, but it makes sense. If you notice whitespace(s) at the end of content, of course you could reject the content and display error to the user "The message can not contain whitespace at the end". But this is bad UX. I see it sort of like length checking (you don't let overlong input through and "fix it on output"). But with whitespaces it is easy to cut them off and do the fix for user automatically (of course if your format can contain trailing whitespaces etc. for some reason, the above won't apply).
There's a reason you use EasyPHP? Did you try Laragon ? That's the easiest option on windows.
Well i used WAMP before but now we migrated to NGINX and I find it easy to combine all the modules i need.
Technically require-dev dependencies are not relevant though.
Sry I really have to find a new layout there, i know. Will look into it.
You should look up PSR, especially the PSR-2 coding style guide, the code is not uniform to the current standards. Use dependency injection container and implement PSR interfaces for generic stuff for more modularity. This thing reminds me of one of my projects a long time ago, used tons of time to create a framework, just to notice that there are really great frameworks already. I suggest trying out a framework that already exist, instead of re-inventing the wheel, maybe extend some other framework with more functionality. 
Why not to post it as a link. Let alone why not just try it and see?
I need the best solution, not sure if devilbox is the best for me. So that's why I didn't post it as a link because it should not only go about devilbox.
&gt;upvoted because I want everyone giving replies like that. 
The best solution is to configure everything manually. Just install different PHP fpm daemons on different ports and connect them to virtual hosts
PHP 7 vs PHP 4 is almost apples and oranges in terms of good practice. PHP 7 can be used as a procedural interpreter but what you want is to learn good OO principles and practices. &amp;#x200B; Laracasts is good. I'd also say [https://phptherightway.com](https://phptherightway.com) is a good resource. &amp;#x200B; You could also consider a different language altogether, such as c#.net. It's got good resources from Microsoft and has none of the procedural baggage that some PHP tutorials have. My PHP is a LOT better having learned C#.
&gt; Listening to community feedback This is definitely a killer. Thanks to feedback and mainly actively requested "try it and tell me, what's annoying in it" pushes my open-source further then I could ever think of. &gt; There's not a ton more to discover there. Imagine that someone would say 5 years ago: "well, that's as much as we can get from PHP tokens, there will never be tools that will work for us". In 2019, there is AST and migrate from one framework to another is a matter of fraction of original time. &gt; Stepping back a little, the future of all our tools is intertwined with the future of PHP. Indeed. So do you plan to learn C and start to contribute or what could be done by PHP devs? 
Cool :) what exactly do you like about that reply?
how you portrayed that people often suggest their favorite, in a funny way then went on suggesting what could be better for his actual case, and also gave in informative link on it. no complication about the inner workings in your posts that the person in need may not understand at the time reading, and I just smiled reading your answer. that much that made me stalk your profile and follow you sir are great, I'm just a 28yo with my first actual tech job in a company, before that I was self -taught hacker (sysadmin/security/kali kind of stuff) for some years 5+ and then 5-6 focused on web dev from css frameworks to php to django but mostly I focused on laravel because I kinda liked it and did not seem that hard. but oh well that's me :P 
Wow, really nice stuff. Thank you guys! [CipherSweet](https://paragonie.com/blog/2019/01/our-php-security-roadmap-for-year-2019#ciphersweet-orm) sounds very useful (searchable encryption for ORMs) 
Yes but if we wrote test cases not using the lowest version then wouldn't the tests themselves fail?
a &lt; can be in a name? a (? show me one. 
Not sure this is the best solution, but it is certainly a solution I use. You can also use a bunch of docker images loaded up with the exact extensions you need per project.
There is no “best” solution, but we are running Vagrant boxes spun up with ansible playbooks so our dev environments are nice and separate You could also look at docker 
I see, you confirmed my assumption :) thanks. I had luck in my life to study social psychology, where terms like *confirmation bias* (I spread what I believe and everyone else should believe the same) slowly disrupted my ego thinking. I'm happy that now I'm able to separate my needs (bit better than in the past) from needs of others. Also as a consultant, I found it works better to help each specific case, than to spread my personal knowledge and specific experience everywhere. 
The issue we have with Vagrant is that it is not running nicely on Windows host machines. Mac and Linux just working fine.
Interesting, never heard of Mozart before. "Feels" like having unit tests right in your code almost, but probably because the library author used Assert. I like it, though, wouldn't you have to use a lot of catch statements to avoid returning error pages?
What does it mean when you type "it is not running nicely on Windows host machines"? What happens? I'm asking because I've been running Vagrant on Windows host machine(s) for ~5 years now, I've literally never had a single issue so I'm curious what you guys stumbled upon. 
Disclaimer: there are better solutions. OS: Windows (I use MacOS and various Linux distros too) Why: I like the UI compared to other operating systems. This is what I do: * Install [Virtualbox](https://www.virtualbox.org/) * Install [Vagrant](https://www.vagrantup.com/) * [Get Laravel Homestead Vagrant box](https://laravel.com/docs/5.7/homestead#installation-and-setup). Why? It comes with PHP 5.6, 7.0, 7.1, 7.2, 7.3, nginx, Redis, nodejs, npm, git etc. * I map a folder from Windows to Vagrant VM. Why? So I don't have to use Samba to share files between virtual machine and host machine. PHPStorm likes it too, it works without taking bajillion years to index everything. * I also map nginx's \`/etc/nginx/sites-available\` to my Windows machine. Why? So I can copypaste .conf files and create vhosts manually as I see fit. I could go with ansible, but I just find this faster for local development. * I install [prestissimo](https://github.com/hirak/prestissimo) because I don't want to wait more than 10 seconds for Composer to download all the libraries when I start a new project That's my flow on Windows. I now have access to nearly every php version. I can add vhosts. I can connect via ssh, create self-signed certificates, build and install php extensions like swoole / zmq per-php-version. I can tear the VM down but I get to keep the php files / nginx configs since their directories are mapped from the host machine. It's not the best, it's not the fastest, it's not dockerized (I hate when people dockerize everything) but it takes some 20 seconds to get a new vhost and project up on any PHP version I want.
That depends on how you do it. See the blog post. I inject phpunit after the prefer lowest command in travis before install, as such it will be current. And I use phpstan.phar file locally, for simplicity reasons in terms of dependencies pulled :)
Sometimes the connection with the mapped folder doesn't work anymore. Then we need to run the following command: net config server /autodisconnect:-1 
I'm familiar with Vagrant and using [https://puphpet.com/](https://puphpet.com/) to get all setup for development. But this doesn't allow multiply PHP versions by default. But I could always install muliple PHP versions once it is running and use them in the VHOST. You way of working is nearly the same I'm doing now.
So why not deploy this on Linux where it belongs? Why keep this on Windows if you’re deviating away from the native Windows stack (IIS, etc)?
Thank you! That might be the most reasonable solution.
It's not the length or quality of the video itself that people are objecting to, it's the quality of the code itself. Tutorials are fine and good, but the actual code that you're writing in the lessons is showcasing a number of very poor programming techniques. For experienced developers, it's like looking at code from 15-20 years ago, when not many people using PHP were aware of how to write clean, reliable software. The poster above was simply stating that for a "modern" programming tutorial, it's steering people away from writing reliable or professional code. Seeing as your tutorials have been posted to every sub that mentions "webdev", "programming" or "php", including /r/lolphp (a subreddit for mocking PHP), either you're misguidedly attempting to spam to get your tutorial series off the ground or you're attempting to troll.
Vagrant doesn't come with anything installed by default, that's why use a box that comes with pre-installed php versions. I used to build these by hand but then some nice people created this Homestead machine which has everything I need and more. I saw puphpet, but since I can just change the php version I want in nginx config, I see no need to use it for local development.
Unfortunately, just because you spend lots of time on something, doesn't mean the result will be any good. The problem isn't the video or your English. It's the code itself is bad. It's fine that you're a raw beginner, we all have to start somewhere. But, at this level, you have no business putting up tutorials. You are literally damaging the community by spreading bad practices.
Thanks for developing/releasing/supporting - I've been adding psalm to every project I come across and it's been a great help :)
Frameworks exist to solve a problem or a set of problems. I scouted the site, scouted the code and I can't see what problem your framework solves. We've all created frameworks at one point, I'm guilty of the same (though I never wanted to create a framework, it's just that in 1999 there weren't any PHP frameworks). Since it's 2019. right now, I've to ask - what's different about your framework compared to Symfony, Laravel, Lumen, Zend Framework, Phalcon, Slim, Silex, CodeIgniter? Your site doesn't work properly, I can't see any examples, I can't see what problem I'd solve with your framework. There's probably no one who will go through your code and find that interesting function or two and say "heh, nice implementation of X".
&gt; If I want to search a database for a last_name of 'smith"); DROP TABLE blog_posts;'... what is preventing that prepared SQL statement from executing any more than a direct sql statement using mysql_real_escape_string() on the parameter? FWIW, the mysqli_ (and the mysql_) drivers no longer execute multiple statements in one go for this very reason by default. You can execute multiple statements in one query by using mysqli's multi_query, but if you just use mysqli's query/real_query (mysql has some fun names!), then you only get one statement per call. [As noted in the documentation](http://php.net/manual/en/mysqli.quickstart.multiple-statement.php): &gt; The API functions mysqli_query() and mysqli_real_query() do not set a connection flag necessary for activating multi queries in the server. An extra API call is used for multiple statements to reduce the likeliness of accidental SQL injection attacks. An attacker may try to add statements such as ; DROP DATABASE mysql or ; SELECT SLEEP(999). If the attacker succeeds in adding SQL to the statement string but mysqli_multi_query is not used, the server will not execute the second, injected and malicious SQL statement. AFAIK this also doesn't apply to PDO.
its been a great progress keep growing in leaps and bounds!
Well the production IS running on Ubuntu server, but i need that for development purposes. I dont want to switch OS. Linux is great under the hood, but not the GUI.
You really should be using a local Ubuntu VM with a Nguni/php-fpm setup even if only to match your production environment as close as possible. Use a good text editor or IDE with sshfs support or a sshfs implementation for windows to talk to the dev VM? That’s what I do.
It doesn't matter at all. This is just an example of the *exploit* of the existing *injection*. And although some exploit may or may not work, the injection is still in place. For the demonstrational purpose it's more than enough. For PDO-mysql it does apply when emulation is turned off
&gt; It doesn't matter at all. I disagree. In general it stops the bobby tables. Users are unaware that it does though. I fully agree that properly using prepared statements is the right solution. Just throwing in a tidbit that the bobby tables injection hasn't worked for a long while by default. If you think I'm suggesting anything else, then you're misreading the reply.
I would just look at chroot. it's how most hosting providers do. (check out [ISPCONFIG](https://www.howtoforge.com/tutorial/perfect-server-ubuntu-18-04-nginx-bind-dovecot-and-ispconfig-3/))
I am just saying it doesn't matter at all that this particular exploit doesn't work in some circumstances. This article discuss injections, not exploits. People often take one for another so you better don't
&gt; People often take one for another so you better don't As I noted: &gt; If you think I'm suggesting anything else, then you're misreading the reply.
We'll take pride for the useless and irrelevant comment.
&gt; I generally get hammered while putting out these updates, but I really don't care, as I have so much time and energy invested into Apex now, there's no way I'm turning back. Your project is destined to fail with that attitude. &gt; http://apexdemo.envrin.com/admin/communicate/notify &gt; We're sorry, but no TPL file exists for the location communicate/notify within the panel admin, and no 404 template was found. The code still contains most problems basically everyone told you about in your last "updates". No one insulted you, many wrote very valid points you all ignored completely because of the above attitude. You should use Symfony or Laravel and re-write whatever "business application" you have there, it will take you...3-4 hours of work and it will be a lot faster, stable and more secure after that.
&gt; Well take pride for the useless and irrelevant comment. I came a long and pointed out a fact. That's all I did. You seem to disagree with the fact because you thought I was implying something with it. I was not. Take what you want from it, but don't accuse.
You seem to be unable to realize that your fact is irrelevant to the story. 
Just checked your SQL inection prevention article, I am afraid you are wrong on account of that notorious imaginary injection through weird encodings. It doesn't work with native prepared statements. All these scary tales are about manual escaping and emulated prepared statements. The injection just cannot happen if native statement is used, due to its very nature.
Right, but isn't the whole point of [the StackOverflow answer](https://stackoverflow.com/a/12202218) that such a scenario could be possible *if* PDO falls back to emulated prepared statements? Is that edge case not possible?
 Can I ask, what's wrong with the main site? Another guy mentioned it as well, but I can't seem to se any errors at least. Again, it's most likely because I went blind a couple years ago, so you're seeing something I can't. Any insight into what issues are on the main site would be greatly appreciated. It's just a temporary site anyway, and I'll get a designer to do something up nice later. As for your main question, it just suits our business needs perfectly. Multiple reasons. - Current software platform is out of date, and needs to be modernized. - I sell a suite of commercial software products, and each product contains very similar functionality (user management, mutliepl user groups, transaction and payment processing, support tickets, 2FA, phone verification, member's area, theme management, etc.). Then each product contains an extra package or two, providing additional functionality within the admin panel / member's area. This allows me to easily develop, deploy, and maintain the entire suite of products quite easily. - With my prior operations, training junior developers was always an issue for me, whereas with Apex is will be no problem at all. - Plus the standardization will allo me to easily pop developers in and out of projects as needed without much hassle. - Although I do use Composer and packagist as necessary, I don't like the "max &amp; match" via packagist methodology that many use. I just finished a larger project with that methodology, and it was horrendous. A bunch of the packages don't even work, especially ones that integrate with APIs as they're outdated, almost none of them have decent documentation, the structure and flow of some of them are just errible, etc. - Will allow me to easily setup and manage clients, monitor and maintain their DIgitalOcean clusters with ease, etc. - I just enjoy knowing how everything works inside and out, so it can be easily modified as necessary, plus I never have to tell a client during consultation, "I'm not really sure, will have to look into how we'd do that, and get back to you". Just things like that. Again, nothing against other frameworks, and I'm definitely not saying this is the best or even close to it. But it works beautifully for our business needs, and will allow us to overtake competition in targer markets. 
I don't understand what does it mean, "if pdo falls back". Besides, it will be not a native prepared statement anymore, so it makes such allegiation technically incorrect
I’m using docker/docker-compose for this, does the job perfectly
Ohhh, errors like that no TPL file found. Yeah, they will be all over the place, as their not developed yet. Upon initially creating the packages, I just added all the menus I thought I would need, and am filling them in as we speak. 
As noted in that SO answer: &gt;However, be aware that PDO will silently [fallback](https://github.com/php/php-src/blob/master/ext/pdo_mysql/mysql_driver.c#L210) to emulating statements that MySQL can't prepare natively: those that it can are [listed](http://dev.mysql.com/doc/en/sql-syntax-prepared-statements.html) in the manual, but beware to select the appropriate server version). So you're right when you say these attacks aren't possible with native prepared statements. The problem appears to be that sometimes PDO can't do native so it falls back to emulated even if you've disabled emulated prepared statements. Admittedly, it's an extreme edge case.
What? It's PSR2 compliant, isn't it? 4 spaces instead of tabs,,proper comments for php-documentator, function / class on the line directly below comments, first opening brace is line just after function / class, if / elseif / else statements on their own line, one space after the if / else, no spaces within the parenthesis in the condition, etc. Oh, do you mean the comments within the code, where it's just a bunch of one-line // comments/ No, they're fine, and I'm not changing them into actual code blocks like I use for functions. If I can read this code via screen reader without issue, then anyone with a working set of eyes who can see the computer screen should have no problem. 
Scott is a genius!
&gt;How come there's no official maxed-out docker image that has all of the most common extensions pre-installed Installing dependencies you (or anyone else potentially using the image) *might* not use is outright reckless from a system administration point of view. You are increasing your attack surface for *potentially* nothing in return. You are then also responsible for ensuring those extra extensions/packages are up to date and patched when a vulnerability is announced even if you're not using it. Starting with the bare minimum and adding just what you need is the very basics, 101 stuff when it comes to system administration so the way the Docker images handle security is correct and best practice. 
Every time you `init` a static class, god kills a puppy. There's nothing else to say.
Devin hits again with absolutely horrible article. I love when people write quality articles, but this one is such shit that it makes me cringe. 1. There are claims in the entire article about speed, but there's no reproduction scenario. The source is "dude, trust me". 2. Devin, wrongly, concludes that code that does not use `new` keyword is 10% - 20% faster. That's not true. Static methods undergo scope check more often. Network I/O, HDD I/O, context switch - those are factors that affect the *realistic* execution time. A person who's new to PHP will instantly conclude "hey, I won't use new at all anywhere, my code will be 20% faster, better write a blog about it" - and that's wrong. 3. Devin, again, shows how he basically has no clue what he's talking about with the following snippet: &amp;#8203; &lt;?php $file= '/path/to/file.txt'; $desination = '/new/path/to/file.txt'; for($i=0; $i&lt;1000000; $i++) { //Instance Version $filemanger = new FileManager(); $file-&gt;copy($file, $destination); //Static Version FileManager::copy($file, $destination); } He creates 1 million `$filemanager` objects. Instead of creating ONE. Then he concludes how the static version is faster - it really is, because there's no overhead of creating a million objects every.single.time. He also doesn't know what I/O is, wrongly concluding that CPU is his bottleneck. 4. &gt;Drawing from personal experience with this exact problem, on a 1GB of RAM Server I was only able to run 10 php processes simultaneously. After rewriting the script to share data using static, I was able to run 14 scripts simultaneously. In the right scenario, static can have memory improvements. &amp;#x200B; He uses an example where he "improved" something by spawning processes on a machine whose specs are defined by MEMORY (RAM) and not CPU. It appears Devin is completely oblivious to what a CPU core is, what context switch is, what PHP's execution model is and how process control affects... so much. Of course, there's no reproduction scenario provided so again, the source is "trust me dude". The more I read your / his content, the more I question who the hell lets this guy work for money? I hate to be the one who criticizes, but Devin is teaching people dangerously wrong practices, he himself doesn't understand jack shit about what he's talking about. You know when you use static methods or properties? When you need them. That's when. And when do you need them? When you learn OOP, PHP's execution model and when you're able to write shorter code to *do more*. You don't chuck in every single keyword, operator and what not the language has to offer just so you can feel proud about yourself. And yes, static methods are testable - IF YOU WRITE THEM TO BE TESTABLE! Just like any other method. Devin, please do us all a favor - stop writing about the things you clearly don't know about. Sincerely, a guy who really doesn't mean anything bad by this text but cringes when he sees your awful practices, terrible socket "framework" (dude, swoole and zmq annihilate anything you've done, just drop it) and incredibly bad method of testing performance and writing articles. 
&gt;How good the progress of php is compared to nodejs in recent 2 to 3 years ? Depends on how you define progress?
&gt; I dont want to switch OS You don't have to, that's exactly what things like Docker and Vagrant are for. It makes no sense to develop on a Windows stack and then deploy on a Linux one, you're just asking for problems.
Thanks for the suggestion :)
Because while it is similar to and based on PHP, it _is not_ PHP and isn't 100% compatible with the hundreds of thousands of systems, packages, and small scripts made in PHP. That's why. I'll gladly wait until PHP comes around to getting the features we've been asking for for years. It gets better every version.
To keep things testable (as in, injectable and mockable) you mostly want to keep things in instances and rarely use static methods and even less static properties (they behave somewhat unexpected when you start extending static classes). Some good cases for static classes: **Static Constructors/Static Factories** In case you have a long constructor parameter list or you want to have things chainable more easily (as in, having a `SomeThing::create()-&gt;method1()-&gt;method2()` API instead of `(new SomeThing())-&gt;method1()-&gt;method2()`, Doctrine's Collection Criteria and Expression are an example of this) class Something { private $name; private $active; public function __construct(string $name, bool $active) { $this-&gt;name = $name; $this-&gt;active = $active; } public static function createActive(string $name): self { return new self($name, true); } public static function createInactive(string $name): self { return new self($name, false); } } $something = Something::createInactive('test'); class Query { private $conditions = []; public function where($condition): self { //... return $this; } public static function create(): self { return (new self()); } public static function createWhere($condition): self { return self::create()-&gt;where($condition); } } $qry = Query::createWhere('test != :test'); final class Inflector { public function inflect(string $string, array $inflections): string { //Apply inflections return $string; } public static function singularize(string $string): string { return (new self())-&gt;inflect($string, ['singularize']); } } $duck = Inflector::singularize('ducks'); **Utility Classes** Some things are really short and simple to do and don't require a kind of state you would save in class properties, especially since PHP has a lot of global functions that combine really well and provide a lot of functionality, you keep those things in utility classes. class ArrayUtil { public static mergeSort(array &amp;$array, callable $comparator): void { //Sort $array using customg merge sort algorithm } } class StringUtil { public static startsWith(string $string, string $value): bool { return strpos($string, $value) === 0; } } **Facades** This is a thing coming from Laravel and it is quite useful in smaller PHP applications that don't require a lot of complex testing with many different dependencies. It's a static class that wraps around an existing instance (that is still testable as a single unit) and just forwards all calls on it to that instance. Personally I don't like them all that much, but they have their place abstract class AbstractFacade { private static $container; public static function setContainer(ContainerInterface $container): void { self::$container = $container; } public static function __callStatic($method, $arguments) { $instance = self::$container-&gt;get( static::getContainerClassName() ); return $instance-&gt;{$method}(...$arguments); } abstract public static function getContainerClassName(); } final class Database extends AbstractFacade { public static function getContainerClassName() { return PDO::class; } } final class TemplateEngine extends AbstractFacade { public static function getContainerClassName() { return MyTemplateEngine::class; } } //Somewhere in container initialization AbstractFacade::setContainer($yourDiContainer); //Somewhere in your constroller code $stmt = Database::prepare('SELECT * FROM test'); $stmt-&gt;execute(); TemplateEngine::render('your-template', [ 'title' =&gt; 'Hello!', 'data' =&gt; $stmt-&gt;fetchAll() ]);
Still, to overcome even this virtual vulnerability (nobody ever heard of the real exploit in the wild) all you need is to set the encoding in the DSN. And no, I don't find it an edge case. Saying that native prepared statement is prone to SQL injection is technically incorrect. You see, it's Ferrara's business to make this story as scary as possible, he made himself a name on it. But even he didn't go as far as making statements that are outright wrong.
1. It's not PHP 2. It's made by facebook. I don't want to depend on anything by facebook or google. Facebook is cancer of IT 3. HHVM segfaults more than it works 4. It's not compatible with majority packages that I use daily 5. Instead of contributing to PHP, it diverges from PHP creating[yet another standard](https://xkcd.com/927/) 6. The project itself looks like it was made to scratch the mental itch of a few engineers rather than to solve an actual problem. 7. I hate the name 8. PHP has all the features I need. I can always create an extension for what's missing or alter the logic to achieve my goal. PHP is not a magic bullet and it's neither meant for every possible task nor optimal for every possible task. Languages exist to solve a problem, I don't have to solve every possible problem that I've got with PHP. I'm quite content with falling back to C/Rust. Point 1 and 2 are sufficient for anyone not to use it. Point 3 hammers the nail into the coffin. Many will jump on Facebook hypewagon with the argument "well if FB uses it, it must be good" - that's why we got an ocean of terrible code floating around. Thank you facebook. Your contribution to shit code and coding practices has been noted. These are my reasons. I don't have to justify them. Many things that FB "creates" comes from stolen intellectual property (refer to history of HHVM for example), and it's mostly used for evil anyway. It's not even something I'm willing to debate, it's my opinion that's set in stone - backed up by years of following what FB did. If you like HackLang and crap facebook comes up with - great. I'm glad you found it useful.
You also misunderstood the Drupal case. It was not the emulation to blame, but a code that added array keys to the query. If you are fool enough to add a variable directly to the query, it is not a prepared statement to blame. This particular injection is just orthogonal to prepared statements.
Because a platform is more than a language, and a big part of the reason people chose a platform is things like third party libraries and frameworks, well trod paths for things like deployment/hosting/scaling, and some sort of reassurance that the rug won't be pulled out from under them. When PHP developers look at Hack and HHVM in that light, they find the platform lacking. 
&gt; HHVM segfaults more than it works A couple of years ago company that I worked with tried to use it for our new cloud product. The product itself was kinda slow-ish and we wanted to see if we can "fix" that + be cool. Apart from some functions not being implemented (don't remember the specifics) and everything working noticably faster, it was these random segfaults that pretty quickly made us quickly rebuild the app server to use PHP and simply forget about HHVM. Didn't know it's still the case... what a fail.
We have dozens of PHP microservices running in our current architecture that are versioned, tested, and deployed on both AWS and Google Cloud so if one service fails we can easily switch to the other. I think you just don't know the best practices yet. 
Glad that you understand it's just a suggestion :) I also develop on Windows. At least you'll learn the differences between environments during development before having to switch over during production. 
&gt;Can I ask, what's wrong with the main site? Another guy mentioned it as well, but I can't seem to se any errors at least. Again, it's most likely because I went blind a couple years ago, so you're seeing something I can't. Any insight into what issues are on the main site would be greatly appreciated. It's just a temporary site anyway, and I'll get a designer to do something up nice later. As for your main question, it just suits our business needs perfectly. Multiple reasons. &amp;#x200B; The site has certain elements like close buttons, red text on red button, some images don't load etc. - I'd need a better part of an hour to list everything. You said you're getting a designer so I guess that person will sort it out. It looks unfinished, that's the problem. For me, that's reason enough to hit ctrl + w. I get that you probably put a ton of effort into it, but I'm not here to lie to people that things are good when they're not. I don't know what you're after from this post, whether you want some recognition or actual input - whatever the case is, me personally - when I see something unfinished, I just close my browser tab. Your site is such site, that was enough for me. &amp;#x200B; What you did with Apex looks more like a project than a framework. A framework is something you mold to your own needs. You have a set of classes / utility processes that work in your particular case. I wouldn't call it a framework. It works for you and that's all that matters. Personally, I'd never use it. Not because it sucks, just because it looks unfinished and I see nothing that I gain by using it. To use something, I've to gain something. That's not the case here. Not that you care, but still - that's one of my core reasons for anything. &amp;#x200B; I wish you a lot of success in your business. I don't think that your code is particularly good or bad, it's not something I'll remember in a few hours definitely (this is not meant as an insult btw.). The main point is: it works for you and you can train new people without changing the training tools and method. That's what counts as a win in this framework, although you probably won't get too many people to use it, if any. P.S.: the reason I (my company) went with Laravel for our framework was exactly what you mentioned: training people. Using something that's widely adopted means that we can find people that have been trained to a point. We don't have to hold them by hand and show them how to connect to database, how to get the project running etc. and that's the initial and sole reason I'd ever opt in to use the framework (second reason being - many heads are smarter than one and they create a ton of valuable tools that save my time and help me do my business logic rather than develop tools all the time).
Ugh... again? Shouldn't posts like this be reported as spam? &amp;#x200B; All I see from crappy articles by Devin is attempt to get better google indexing. He was told multiple times where he was wrong, that his ProdigyView is abomination... yet he keeps spamming nonsense.
Fine but let's do the same (listing data) using some library: 1) installing the libraries. I use eftec\bladeone and eftec\DaoOne that everybody could download using composer 2) file list.php ```php &lt;?php include "../app_start/app.php"; $blade=new \eftec\bladeone\BladeOne(); $dao=new \eftec\DaoOne("127.0.0.1","root","abc.123","sakila"); $dao-&gt;connect(); $list=$dao-&gt;select('*')-&gt;from('actor')-&gt;toList(); echo $blade-&gt;run('list',['list'=&gt;$list]); 3) ``` file \views\list.blade.php ```html &lt;ul&gt; @foreach($list as $item) &lt;li&gt;{{$item['first_name']}} - {{$item['last_name']}}&lt;/li&gt; @endforeach &lt;/ul&gt; ``` 
Another solution instead of Easy PHP is to use WSL (Windows Subsystem for Linux) where you can basically install a Linux distribution on Windows and windows does the job of configuring most of it. That's what I use nowadays.
My choice would be Laravel. You can define everything you need the way you need it, it has it's own routes for API and you can apply a predefined scaffolding for a token system made for it by the laravel devs. Laravel has a lovely ORM, Syntax and even the core files are written in a nice and readable format with comments.
I use the setup from phpdocker.io and it works like a charm. To me it just feels easier than vagrant.
Good point, native prepared statements always prevent this. I've [updated the post](https://kevinsmith.io/protect-your-php-application-from-sql-injection) to reflect that and to de-emphasize the potential edge case raised by Ferrara.
 &gt;2. It's made by facebook. I don't want to depend on anything by facebook or google. Facebook is cancer of IT Sure hope you don't use a Linux kernel then, since Facebook developed features like BPF and cgroups.
I disagree, emulation allowed execution of statements that native prepared statements wouldn't have allowed. I agree that the code that led to such SQL was foolish, but the whole point of using native prepared statements for security is to prevent bad queries like this from being executed, regardless of how they were formed.
The problem with semantic versioning is human error. What happens if your dependency is declared as `^0.1.0`, but someone removes an API from 0.1.0 and publishes it as 0.1.1? This breaks semver, but an automated tool isn't aware of this, which has been the cause for a lot of problems for me recently, so I had to fork-and-vendor all dependencies in order to keep them from sliding the version number around. There are solutions (like Elm) that do automated semver by diffing the public APIs and use that instead, which I think is the "future" of package management. The only thing that should be allowed to be done manually is bumping the major version number (which always breaks semver, so it's fine for ^ tools), otherwise you'll be in for a lot of trouble with manual versioning.
Semver relies on discipline, and discipline only, thus, you can't rely on it. If you use wildcards for dependency versions, then the pain and suffering you incur from doing so is really on you.
Diffing the public apis isn’t necessarily enough (though it’s certainly a great starting point). Realistically, it happens (especially pre-1.0). When it does, it’s common to roll back the breaking change in another point release. It’s like any other bug fix, really. If they do it all the time, yeah, it’s a bad developer and you’re going to need to do something else. In any case what’s the alternative? For libraries, any other system is going to be worse. Ultimately you still need to be responsible when updating dependencies, which means stuff like testing your interactions with them. If you update and tests start failing due to a non-semantic BC break, notify the maintainer. 
Docker best way by far
What version of PHP were you comparing to at the time? All of the latest benchmarks show the latest PHP more or less equivalent to HHVM. So now even that’s not really a thing. 
Truth is you don't know much, but it doesn't mean you can't learn. Study, read tutorials, guides, courses, move to a bigger city if needed, apply to jobs you find interesting. Every great developer had to learn a lot and take chances someday.
Let me repeat, switching emulation off **wouldn't remove this vulnerability**. It will just make one particular exploit impossible, but it doesn't matter, as many other exploits would be still possible. Ilke I already said in the other comment thread, SQL injections aren't limited to just dropping databases. Through this vulnerability, **even with emulation turned off** an attacker would get the read access to the whole database, which in certain cases is much worse than just deleting a table. In your own words, "using native prepared statements for security prevents **only one kind of a bad query** from being executed" by this foolish code, letting many other kinds to thrive. Don't you understand? This stupid drop table case is just an example, the most simple one, but injections are not limited to it. And just making a native prepared statement wouldn't prevent them. They had to fix the code, not switch the emulation off to fix. It was the code, not the emulation.
You **really** failed at this post. VATSIM is apparently the Virtual Air Traffic Simulator... Why someone would want that, I don't know, maybe a site like FlightAware uses it? https://www.vatsim.net/ Apparently, another web app scours VATSIM's data and packages it up in an API: https://vatstats.net/ And then this project enables you to access that: https://github.com/lotfio/vstat Like I said, you really failed in your article submission. Besides that, I'm pretty sure less than 100 subscribers would even care about this.
What this stupid code does, is adding user input directly to the query **not via prepared statement**. This is a very important lesson actually, but it is not that emulation mode is evil, but that a prepared statement doesn't cover every possible case, and when it's inapplicable, one must be cautious, and never use an outside value but a value hardcoded in the script only. So did the patch that fixed the vulnerability.
Sorry for the passionate comments, I don't mean any harm, just trying to explain
wonderful
Look into Vagrant also
It was either 5.4 or 5.6, can't remember exactly. More likely it was 5.4.
Thanks, wonderful stranger!
[It's been a while since you last posted](https://www.reddit.com/r/PHP/comments/7bqvo5/a_really_tiny_flat_file_php_cms_that_i_started_in/). It's good to see you back. It looks like you've made a bit of progress, but there's still a lot about this that makes me steer pretty far away from even touching this: * You still don't have any tests * You're still relying heavily on a [God class](https://github.com/robiso/wondercms/blob/2.6.0/index.php) (this directly impacts maintainability) * All of your methods are still static * You're supporting a PHP version that hasn't been supported since 2016 Unfortunately, I am wholly unqualified to speak to your application's security, but something about this doesn't sit right with me either. I could very likely be wrong about that part, though. On a side note, your version definition in your index file doesn't match your current release (still set to 2.5.2). Best of luck man, but this needs a lot of work.
And why should I make that comparison? Comparing Java v PHP v Python in terms of oop is fair. Comparing PHP v Python in terms of being multiparadigm or their treatments of optional static types is fair. In terms of just straight up comparisons, PHP v Python is fair since they're both in the same league (along with JavaScript, Ruby and Perl). But comparing Haskell or Elm to PHP isn't really fair. There's not much to compare since Elm and Haskell are vastly different than PHP and Python. That's like me saying, you like Elm? Try Go one weekend.
Looks like someone already modified the first screen when you login to have: &amp;#x200B; &lt;meta http-equiv="refresh" content="5; url="[http://example.com](http://example.com)"&gt; &amp;#x200B; kind of annoying....
Why is no database a benefit? It seems like it would be more effort to work without one
love it! I code [all my webapps](https://github.com/HaschekSolutions/pictshare) to be used without databases but I never made a CMS. Will definitely use your awesome cms
It's been a long time. There's only so much a noob dev can do. :) I personally don't mind the god class, as this was never intended to be growing any further in terms of code. If the community or incoming contributors signaled a wanted change, I would not mind it being implemented better. The "updating" mechanism would also need to he improved in this case, as there would be more core files. Are you talking about the official website version mistmatch? I think there might be a caching issue by Cloudflare, please try a hard refresh (or post a link if possible). PHPv5.5 is just the minimum requirement. There are tests in place, granted not unit ones. Your opinion is appreciated. I'm hoping there will be a year when you give my post a pass, but some help is needed to get there. :)
For simple sites, it makes sense. In most cases database reads are going to be slower than file reads, so it really all hinges on how you plan on consuming the data that you're storing. I could see things getting pretty hairy if he were to try and implement a robust site search that matches multiple criteria, or trying to support multiple updates from multiple users concurrently, but that doesn't appear to be the goal here.
&gt; A bunch of the packages don't even work, especially ones that integrate with APIs as they're outdated, almost none of them have decent documentation, the structure and flow of some of them are just errible, etc. I find this hard to believe as the experience of most people is the complete opposite. To be honest, it seems like you're just picking the wrong tools (in this case libraries) and blaming the ecosystem instead of your choices, which results in you sticking with an outdated and frankly, inefficient development workflow. Unless the library is unpopular or dead (or both), such situations should be a small minority.
Yeah, but it just seems like a static site generator would be so much smoother than this
I spent quite a long time using Phalcon. The documentation is usually horrid. But I thought of it as more of a tool set than a Framework. You are basically adding more compiled features on top of your PHP you can use, or not use depending on your requirements. You can load one Phalcon library or 100 etc. With that said, I have since moved away from Phalcon. In my HTTP request, I am using composer libraries as needed (Siler for Routes, Twig for Views, etc). I pick and choose base on need. Every step of the way I compare to "raw php 7.x speeds" to see what I may be doing to slow down my request. This is not a shot at frameworks, I simply don't use things like ORMs the way they are intended, I prefer direct PDO calls and working with the smallest code in between for performance etc and managing. I also intend to continue this way because I have never enjoyed porting my code to the next major version of a framework. (Phalcon 2 to 3 was just as bad as Laravel 3,4 ,5) I simply just keep up with a small amount of composer packages and use PHP functionality that it provides. 
I always seem to rely on Twig, Siler, Carbon and Guzzle to get my information flowing. Are there any in particular you find "nails it" as package that should be included for everyone. Whatever the feature might be? 
When I'm writing a web application user interface, I am going to compare the various languages that I can use for the task—JavaScript and Elm are both suitable for the job. I have found that Elm is best for writing good front end code. When I am writing a web application back end, I am going to compare the various languages that I can use for the task—PHP, Python, Java, and Haskell, amongst many others, are all suitable for the job. I have found that Haskell is best for writing good back end code. I have found that writing PHP is very easy to write shitty back end code. How are these comparisons unfair? I'm comparing UI languages to other UI languages, and I am comparing general purpose languages to other general purpose languages. Elm is far easier to start using than Haskell, but they have a similar experience, so I suggest trying that one if you haven't done any statically typed functional programming.
Phpunit 
codeception 
Prestissimo
Laravel... I kid...
I have not actually seen that one, would you mind pointing out the benefits you like from it? 
I knew it would be mentioned, I was prepared mentally. 
I'm glad to have performed this critical service.
Install dependencies in parallel, reducing composer installation time
It’s been a while since I started from scratch outside a framework, but if I was I’d probably use Symfony HttpFoundation anyway. I’d want Request and Response classes anyway, so why write my own?
This does seem like something that would be a benefit in a larger stack for sure. I wonder if a set of 10 or less packages would give you much benefit. 
You may want to consider [EasyDB](https://github.com/paragonie/easydb) if you work with databases. It wraps PDO and makes a lot of stuff easier, while tricking neophytes into using better security (via non-emulated prepared statements). Also, [Psalm](https://github.com/vimeo/psalm) is a must-have for finding non-obvious bugs.
Doesn't need to be an large project. Dependencies depend on other dependencies.
phpunit and phpmailer
Their Foundation items are exceptional, well tested, and handle quite an array of procedures. However, I tend to build things with only having a method I am actually using in mind. When I need the next step, lets say "is this an ajax request?" I often do borrow from these files, but I poke around to see how different people are doing it and take that single method in. For some reason, and I could be off base in my thinking. They also built their code to response or react in a certain way that I want to do differently. So instead of having my interface touching theirs, I simply just make my interface the way I want. 
Carbon &amp; Guzzle 😍
Nice, I will try it out!
Set 7.1 as the minimum as that's the minimum supported version now. [http://php.net/supported-versions.php](http://php.net/supported-versions.php)
PHPStan. Since everybody already mentioned PHPUnit, I've actually found that [vfsStream](http://vfs.bovigo.org/) is also incredibly useful.
I am not sure how it is implemented here; but for static content, serving from the file system is way faster than retrieving it from a database. I personally think it is also easier to cache and re-seed from a file system than when using a database.
Use Apache Lounge https://windows.php.net
Do we really want dummies using php in general and composer in particular? Isn't that how php developed a bit of a bad rep to begin with? And can true dummies even read let alone follow directions?
This is very wrong. File blocking will become a major problem as soon as more than one concurrent user uses the site. Lack of indexing mechanics will tremendously slow down look ups. Why not, at the very least, use a small, well implemented database system like Sqlite?
&gt; File blocking will become a major problem as soon as more than one concurrent user uses the site. That's...... literally what I just said. &gt; I could see things getting pretty hairy if he were ... trying to support multiple updates from multiple users concurrently
It's awful. I'm sorry, but it is. Coded like it was 2005. No regards for standards. Bad practices and spaghetti, which is sad considering the small amount of code written. Security is horrendous. I want to cheer you on, but you have to get some real sense about this...
phpunit, infection, phpstan, phpcs, symfony Var dumper. Guzzle if there's a need to do http requests. 
Other than AWS, Google, Twilio and other SDKs, I have these... intervention/image, phpmailer, geoip2 ([free db](https://dev.maxmind.com/geoip/geoip2/geolite2/) version), lusitanian/oauth
- [Hidden Gems of PHP Packages: Symfony\Finder and SplFileInfo](https://www.tomasvotruba.cz/blog/2018/08/13/hidden-gems-of-php-packages-symfony-finder-and-spl-file-info/) - these 2 more than ever; recently I fell in love with the `mirror()` method
Several of my go-to packages: - Symfony CLI for any non-trivial CLI scripts/commands - PHPUnit or phpspec for testing - PHPCS to check code style - Guzzle for making HTTP requests - Monolog for logging - Swiftmailer for emailing - Chronos (or Carbon) for working with dates - Flysystem for file management - [lstrojny/functional-php](https://github.com/lstrojny/functional-php) for functional primitives (similar to lodash) - [roave/security-advisories](https://github.com/Roave/SecurityAdvisories) to ensure I'm not installing anything with known vulnerabilities - [colinodell/symfony-lts-or-current](https://github.com/colinodell/symfony-lts-or-current) to ensure I don't get stuck on any EOL versions or branches of Symfony components
symfony/var-dumper I can't ever go back to print\_r and var\_dump
No hard feelings at all. &gt;The security is horrendous Any shot you could reveal issues that you're aware of? (that's not already listed here: [https://github.com/robiso/wondercms/issues/57](https://github.com/robiso/wondercms/issues/57)) &amp;#x200B;
Thanks, will appreciate any feedback.
It doesn't support Windows. (23% of the servers are Windows Server). 
Var dumper and dotenv always handy 
Keep preaching the message. Especially among PHP developers, this "sanitize your inputs!" mantra is repeated ad nauseam. People seem to be of the opinion that user input are this poisonous, dirty thing that can somehow be piped though this magical "sanitize" function and is then safe. Even the PHP core devs seemed to have been of the opinion once (see addslashes and magic quotes). And I think WordPress recursively calls addslashes on every superglobal because they thought it would somehow help security. If you want to interact with any superglobal in a WordPress plugin, you always have to pass it through stripslashes(\_deep). Developers even save htmlspecialchar'd strings in the database, which usually ends in double-escaped values. Just great. No other language has this level of ignorant, dangerous paranoia.
Always: - [`friendsofphp/php-cs-fixer`](https://github.com/FriendsOfPHP/PHP-CS-Fixer) - [`fzaninotto/faker`](https://github.com/fzaninotto/Faker) - [`infection/infection`](https://github.com/infection/infection) - [`localheinz/composer-normalize`](https://github.com/localheinz/composer-normalize) -[`localheinz/phpstan-rules`](https://github.com/localheinz/phpstan-rules) - [`localheinz/test-util`](https://github.com/localheinz/test-util) - [`phpstan/phpstan`](https://github.com/phpstan/phpstan) - [`phpstan/phpstan-strict-rules`](https://github.com/phpstan/phpstan-strict-rules) - [`phpunit/phpunit`](https://github.com/sebastianbergmann/phpunit)
Oh, the holy war of Static vs Non-Static. In a nutshell, Static methods are OOP heresy, but we know how to blend the rules (and OOP is not a rule but a guideline). * When no-static: If we need to access a field, then, we shouldn't use static. Why?. A static method can only access static fields, and a static field is, in theory, not thread-safe (In reality, PHP doesn't have the concept of shared-heap-memory) * When static. When it doesn't need to access fields (a method that lacks states). A static method is thread-safe because it uses the stack memory. For example: * Non-static ´´´php $obj=new Class(); $obj-&gt;function('Hello'); // Testing $this-&gt;assertEquals('Hello',$obj-&gt;function('Hello'),"failed"); ´´´ * Static ´´´php Class::function('Hello'); // Testing $this-&gt;assertEquals('Hello',Class::function('Hello'),"failed"); ´´´php When we shouldn't use static (it is a recommendation, because, like I said, PHP doesn't have a problem of thread-safe) ´´´php class SomeClass { static $field; static function fnStatic() { // it must be non-static self::$field='some value'; } } ´´´ So, if we want to write a fluent class, then it usually must be non-static ´´´php class SomeClass { var $field; function fnStatic() { // it must be non-static $this-&gt;field='some value'; return $this; } } ´´´ ###What it is not cool: * Service locator or container. ´´´php $this-&gt;app-&gt;container('Class')-&gt;function('Hello'); ´´´php Why?. * Because it is a pain to debug. The container is a function that returns "something." * Because it bloats the system with a class (the container), reflections and other tricks. * In the Java World, exists the concept of @ejb, @autowired and @injection. It uses a real container that it is a pool of objects that live (and are maintenance) by the web server, so java containers are about optimization. PHP containers are not like this. 
beberlei/assert is almost always installed, along with cakephp/chronos. I like eloquent/phony for mocking.
Updated to 7.1. Cheers!
 He creates 1 million $filemanager objects. Instead of creating ONE. Then he concludes how the static version is faster - it really is, because there's no overhead of creating a million objects every.single.time. He also doesn't know what I/O is, wrongly concluding that CPU is his bottleneck. This test is somewhat right. He created 1 million instances because it is simulating to run multiple threads. For example, let's say that a website has 1 million visitors, so it will create 1 million of $filemanager. 
You could use SQLite as a alternative to DIY database. Probably nearly as fast, and is supported etc. I would bet it would become faster really quickly as you scale the db/file size.
Have you considered using SQLite database instead of your own file based? I bet you it benchmarks better as the file size grows.
I haven't seen such a constellation of horrible code since a long while.
Since it is a benchmark, I will test something more "generic". It is because we want to test static/vs non static instead of IO. ```php &lt;?php class Class1 { public static function ping($pong) { return $pong; } public function ping2($pong) { return $pong; } public static function f1($pong) {return $pong;} // I write this function 500 times, from f1 to f500. public static function f500($pong) {return $pong;} } $start = microtime(true); $object = new Class1(); // I instanced once!. for($i =0; $i&lt;30000000; $i++) { $object-&gt;ping('pong'); } echo 'use ' . (microtime(true) - $start) . ' s&lt;br&gt;'; $start = microtime(true); for($i =0; $i&lt;30000000; $i++) { Class1::ping('pong'); } echo 'use ' . (microtime(true) - $start) . ' s&lt;br&gt;'; ``` And it is the result * use 1.578469991683959960938 s (non static) * use 1.455726146697998046875 s (static) I ran a couple of times and the trend is the same. I even inverted the order with the same trend. (php 7.2 windows 64bits)
Hamcrest 
&gt;Hidden Gems of PHP Package Just read the post about Nette\\Utils, nice post. i also hate dealing with strpos! 
Point taken. You're right, of course, that user input should never be used in the statement template. While emulated prepared statements increased the number of viable exploits, it wasn't the cause of the trouble, and disabling them wouldn't fix the situation. I do appreciate your [followup comment](https://www.reddit.com/r/PHP/comments/ac65qt/sanitize_your_inputs/ed8v7sf/) as well. I know you mean well, and I'm already familiar with [your writing](https://phpdelusions.net) — which I've linked several times in my posts — so your... level of passion wasn't a surprise to me. It might be to newcomers though, so it's worth keeping that in mind. It can make your message hard to receive.
[rappasoft/laravel-helpers](https://packagist.org/packages/rappasoft/laravel-helpers) - snippet territory, extracts some of the Laravel helpers including shorthand multidimensional syntax `array_get($something, "foo.bar", "somedefault")`
REF for an amazing var\_dump. [https://packagist.org/packages/digitalnature/php-ref](https://packagist.org/packages/digitalnature/php-ref)
Carbon
Stuff I often use: * [myclabs/php-enum](https://packagist.org/packages/myclabs/php-enum) * [nesbot/carbon](https://packagist.org/packages/nesbot/carbon) * [filp/whoops](https://packagist.org/packages/filp/whoops) * [roave/security-advisories](https://packagist.org/packages/roave/security-advisories) * [symfony/var-dumper](https://packagist.org/packages/symfony/var-dumper) * [phpstan/phpstan](https://packagist.org/packages/phpstan/phpstan) + [phpstan/phpstan-strict-rules](https://packagist.org/packages/phpstan/phpstan-strict-rules) * [vimeo/psalm](https://packagist.org/packages/vimeo/psalm) * [fzaninotto/faker](https://packagist.org/packages/fzaninotto/faker) * [psy/psysh](https://packagist.org/packages/psy/psysh) (Globally)
\+1 to Carbon, Guzzle.
Damn nice list here! I might add codeception
By no means packages that I will pull in on every project, but very useful when needed: For image processing, [Intervention Image](http://image.intervention.io/), or `intervention/image` For making plurals from a string: `doctrine/inflector` I believe these are both used in Laravel but they have each saved my ass at different times
\+1 to Faker
It is increasingly possible to use Vim/Neovim as a competent PHP IDE. There is Phpactor (disclaimer, I'm the author) which provides many of the functionalities of Phpstorm (completion, renaming, refactorings) to varying degrees, and the growing popularity of Microsoft's Language Server Protocol (LSP). LSP is a protocol for a text editor (e.g. vim, vs code, atom, sublime) to talk to a language server (e.g. Felix Becker's PHP Language Server). VIM has a few Clients for this protocol, e.g. LanguageClient_Neovim and the COC (Conqueror of Completion) client (which looks very promising). There is Ale - which provides real-time diagnostics, e.g. via Phpstan/Psalm (static code analzyers), phpcs/php-cs-fixer (coding standard enforcers) and numerous other tools. Ale also supports LSP. For Git integration there is Tim Pope's Fugitive. I collected some links relating to setting up VIM (slightly biased to Phpactor) here: https://phpactor.github.io/phpactor/links.html I don't think any open source tool set can compete entirely with PHPStorm currently, but increasingly more is possible.
Thanks for your input during the project bringing sodium to Magento!
install it globally in your dev environment then fall in love with it and install it on your servers as well 😆
You can install x64 versions wherever you want. By default, it's in 'Program Files and not x86', but during the install process you can change the destination folder.
WAMP.NET can do this I think. (Not to be confused with the popular WAMP Server.
It's not better nor worse, it's just another WAMP.
A lot of the others I use have been named. But even out of frameworks I still include: * [fill/whoops](https://github.com/filp/whoops) 
Why no one mentioned [Ramsey/uuid](https://github.com/ramsey/uuid)? Is it bad? I have been using it in many projects that requires uuid4 and I find this little tool pretty neat ;)
Hey it's you! Phpactor is amazing! For the time being I'm actually back to using neovim. In fact, phpactor helped me track down a bug tonight in a library that is very loosey-goosey with types and uses too many traits. Right now, I'm pretty satisfied with my neovim setup to be honest. I also added Ale so I could fix coding standards on save. Thanks for your awesome work on phpactor and it's Vim plugin. I'm going to check out the links you provided right now.
* besides phpunit should have been specified ;)
I like [cakephp/collection](https://github.com/cakephp/collection) for map/reduce-y stuff.
&gt; It has all the features PHP developers are asking from PHP for years. That was more of a point before PHP7 came out. PHP7 really added a lot to PHP - check it out if you haven't. (Also, as others have pointed out, PHP7 performance basically matches it now.)
I think that a lot of languages can offer what we need. But the "thing" is, that we want it in our language, not in another. The other languages are not compatible, so this question (or discussion) is a waiste of time.
and with laragon you can install various php versions next to eachother. It's easy to install and can even be used for non-php projects, has apache and nginx support, multibple databases. I was using a XAMP before Laragon, but switched and never looked back.
Its not working for me. giving 500 error.
I am a big fan of Robo.li. 
Can you please let us know tt which point you are getting 500 error?
I've never been able to install Docker on my machine. Its really a pain in the ass, had to modify something in the BIOS but same result can't run it. Laragon : Install &gt; Next &gt; Next : Done. Ofc Laragon is for basic use but all my websites are on Laravel or Symfony so I don't need some fancy configuration or module.
No, Wamp, it's crap compared to Laragon. You can't say that.
Some notes after reading a bit of your source (master branch): * You *do* have a database. It is not MySQL nor SQLite, but you JSONify your datas and store them in a file named `database.js`. * I like the idea of a small CMS, we don't always need to have heavy CMS . * There is not enough configuration for me. For example the minimum length for passwords is 4 chars, it's hard-written in the source. What if I need a minimum of 8 chars? * You are using raw PHP, like `$_POST` or `$_SESSION` arrays. It has advantages and disadvantages for me. It's good because it allows any PHP developer to contribute even if it doesn't know a framework or a library. It's bad because these libraries are an abstraction and avoid to write all the basic routine. By avoiding to write the *basic routine*, it's a security too. * There are some HTML written in your main PHP class, `wCMS`. In short I like the idea of the CMS, a really tiny CMS may be useful, we don't always need to use a heavy WordPress for small websites. But the code seems to be *old* PHP code and it's like if your main class control everything. I'd don't feel comfortable enough to use it, but I like the idea!
I love it, using it all the time.
If you have a static content website that you want to give people easy access to edit then having no database makes it easier to diff the changes, put everything in version control as well as move it between environments and servers.
Thanks, Nette\Utils is also awesome for json operations.
Codeception.
Wamp? Wampserver you mean?
You are right, hack has all that features that PHP is missing. The problem; existing frameworks would not use that features.
How about you go fuck yourself, together with this little piece of shit you're defending, you absolute fucking retard?
Not until you can call me a retard AND construct a grammatically correct sentence.
It's not what you said. You said "file reads" and if I make an empty file I can assure you it'll be faster reading that compared to opening a database connection. So while it holds true a great deal of the time, it's not always true. Blocking occurs when a single thread locks the file and all reads, writes, and executions are prevented until the file is released by the locking thread/application. Blocking is therefore a more precise terminology. How can you ensure that multiple concurrent users do not target a site? What if robots/scripts start targeting the site? A single machine can initiate a DDoS attack due to the file blocking problem. Unless the CMS runs on a machine protected by a firewall or some form of authentication, it is very vulnerable and unreliable.
It's not. Not a single programmer who knows his job would do such a thing. You'd do this: ``` $file= '/path/to/file.txt'; $desination = '/new/path/to/file.txt'; $manager = new FileManager(); for($i = 0; $i &lt; 1000000; $i++) { $manager-&gt;copy($file, $destination); } ``` You can't create 1 million objects and then conclude that 1 million operations are slower than 1 operation. It's not a proper test, and programming isn't politics where you can use "alternative facts" to strengthen your point. PHP is already a slow language. Screwing up your code to shave off a millisecond, while applying every single wrong practice is dangerous. If you have the need to repeat something a million times, you wouldn't create a new object in the loop. You'd create one object, call it a million times. That's just common sense. Comparing 1 million *extra* operations compared to *one* operation - well yes, it'll be slower. There's no big surprise there, the less you do the faster the program is, we are all aware of that and don't need a degree in computer science to come to that conclusion.
Ok, you got "stung" by my facebook comments. Are you sure you want to go down this route? Comparing something that facebook made from 0% to 100% and comparing a contribution to an OS that's not theirs? A single person made the contribution to cgroups, Tejun Heo. Had we had this conversation a few years ago, then you'd say "Google made cgroups" or "RedHat made cgroups". I can understand you're bothered by what I wrote, but you made some odd assumption that I'm a perfectly logical being, morally dumb to the point I'll drop out using an OS like Linux because a company that sucks beyond words made a contribution by employing an extremely smart person? Even a blind chicken finds a kernel of corn. I've no clue where you want to go with this, but if I were you - I'd pick my internet warrioring with care. Have a great year! 
Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable. https://semver.org/#spec-item-4
I was looking for this. That's the first thing I install after composer itself. For the ones asking for benefits: - installing laravel without prestissimo: ~1 - 3 minutes - with prestissimo: 15-20 seconds Yes, there's composer cache and so on, many factors in the game but it downloads packages in parallel as mentioned and doesn't make you go nuts while waiting for installation to finish.
In the case of WonderCMS (which is intended for a single user/admin), this probably isn't an issue. Visitors and bots don't have any impact on the databse.js in any way, except for displaying the content
You're completely correct, it's not using a relational database (and this is also outlined in the WonderCMS about section). I always imagined WonderCMS fills the need for a special niche of users (who want a 1 file CMS, god class, tiny codebase) and I completely agree there are a lot of improvements and/or sacrifices to be made. There's a random password generator and a higher minimum password requirement coming with the release of the next version. Thanks for your input. \*Throws silver\*
It is possible to run multiple copies of Apache (if they use different ports) I write an article about it explaining how to. https://medium.com/cook-php/running-different-versions-of-php-under-windows-b16db9d864ee 
I agree, this does seem possible.
Aww, so full of hate and so little ammo that she resorts to grammar :) Have a great new year kiddo, as much as I'd love to do this - you're neither fun nor special so I bid you farewell. Remember, never stop defending idiots or your kind might get eaten up by evolution. Stay strong!
Don't let the door hit you on the ass on You're way out! Enjoy being lonely in life.
Yes, but it is for manual installation (I write an article about it and multiple versions of PHP). 
It's not using a relational database, but it's still a storage, a kind of database. So the *No database* written everywhere is not really right. But I understand why you say that. The little codebase is good, easy to understand because there is one main file. On an other hand, it's pretty hard to work together on only on file. When many developers work together, it's easier to have several files, it helps avoiding conflicts. But it's a choice, so why not. So the next version will improve some things! Great! Another detail, it's important for many developers and companies to have tests. Otherwise it's easy to have regression. I think (but I may be wrong) with test your project will have more confidence. I hope.
&gt; I'd pick my internet warrioring with care Watch out guys, we got a badass over here.
\- Siler for routing \- EasyPHP from paragonie for a PDO wrapper \- Twig for templating \- phpdotenv for configuration
No worries my internet adversary, none of that will happen. How about you don't become the next school shooter this year? Chill with the hate, it's bad for you. I don't give a fuck about your opinion so there's no way you can insult me, but hey - let's see how much time you're willing to waste. Consider it your own IQ test :)
Please.. include the meme with Neil, make it complete.
/r/edgyteen Have fun trolling and insulting people. 
Sure, FB doesn't have smarter things to do but to monitor random guy with opinion and broadband internet connection. &amp;#x200B; You are one of those tinfoil hats people, right? Moon landing is faked, 9/11 is staged, GMO is bad... I ask because when a person believes one nonsense, there is never just one.
I'm not sure where you got the impression that I think for a second that facebook is doing some big conspiracy or that they give a flying fuck about someone's opinion, especially mine. They do what they do - there are various reasons for their actions, and I have the freedom to choose whether I want to use their products or not. That's it. What I did here was share my *opinion* - I don't think that my opinion is 100% correct, without faults or that I have the obligation to go on an internet crusade and make people share my viewpoint. Had you read my post without skipping sentences, you'd conclude that on your own. You use their products and it saves your time + brings value? Awesome, I'm really glad for you and I don't think you're "bad" in any way for doing so. I don't like facebook and I am free not to like something or someone. I'm not remotely trying to convince anyone to share my feelings towards that company. The mere fact you went with ad hominem (paint me as an idiot who believes that crap you listed) just means you've got nothing to bring to the discussion except latent hate towards me. Which is normal for human kind, sadly. Let me have my opinion without hating me or painting me an absolute moron, there's nothing wrong with people who disagree with you. What you could have done is list why what I wrote is nonsense and provide *evidence* to back your statements up. But you didn't do that. That takes effort. It's easier to paint someone a moron and create a fantasy world where you're correct and the other guy (me) is a nonsensical idiot. Do yourself a big favor - grow up. 
Thank you for understanding. One little addition to your edited post. In the edge case section, you have one detail missed and have a sort of a shifted accent. From the way it is written, one could think that it's an extended utf charset that saves from SQL injection which is obviously not true. First of all, even if one of these peculiar encoding is used, it would be perfectly safe if the connection encoding is sen in the DSN (and the software used is at least not older than 10 years old). So I would rather emphasize on this: as long as charset is set in the DSN (as opposed to making an extra SET NAMES query call), everything would be safe (you can refer to the Ircmaxell's post on SO which says so). In a nutshell, it makes PDO:quote() internal calls to take the encoding into account and thus create a syntactically correct query with emulated prepares even if one of vulnerable encodings is used. And to make the proper accent, I would stress on using UTF-8 encoding and then proceed to explain that the only proper charset that supports this encoding in mysql is utf8mb4. Sorry for scrutinizing (hope it doesn't look like patronizing) your posts so much, but it is sort of a professional bias: I am a technical editor for PHP books and also frequent on codereview@SO, which makes me very strict with details. But please take my advise with a pinch of salt. I am not a native speaker and although I am sure I can get the accents right, I could be wrong as well. Either way, this section is indeed an edge case, and it doesn't really matter which particular measure is taken.
You are correct, maybe there should be some extra emphasis on not being a relational database in all places? It's been slowly improving over the past few years, here's the minor changelog if you're interested: [wondercms.com/whatsnew](https://wondercms.com/whatsnew). Regression tests are almost completely in place, will be also published in the future, hopefully bringing more confidence to the project.
Quit that project. They teach you bad things that noone is using today. This code is insecure, outdated and doesn't work anymore. (I kind of love these frequenters of politics and meme sections of Reddit turning to /r/php when in trouble with homework. If they spent less time debating politics on Reddit and more time in classes, they wouldn't be stuck with such trivial problems).
I think there should be a bit of explanation about the database yes. You are using a kind of database with the JSON file, so in what is it better than using an SQLite database? It avoid using the PHP extension. I read the changelog, note that I think it's important for a project to have regular releases and a changelog, it's a good point for you! Indeed the project progresses with the time, I wonder how it will be in some time. Regression tests would be great. Tests are important in a project, I hope you'll have more confidence then. A question, what kind of websites or users is this project targeting?
With time, hoping it'll be good enough for even "die hard PHP-ers". :) At some point you have to accept that not everyone is going to like or love it. Target sites: simple websites, landing pages, open source projects/product pages (such as WonderCMS).
Every project has pros and cons, not everyone likes Linux, nor Symfony or even WordPress. But they are great projects. You have and will have users and supporters :). On your landing site I haven't seen the target sites, is it written? I think this info is interesting.
Thanks to everyone for participating, always a great time here at r/PHP. &amp;#x200B; As a thank you (and as the yearly tradition goes) some of you have been awarded gold and almost all of you got silver. See you in a year's time, hopefully with even more noticable progress. :) &amp;#x200B; \*\*Wishing everyone a successful and healthy 2019!\*\*
Hey, robertisoski, just a quick heads-up: **noticable** is actually spelled **noticeable**. You can remember it by **remember the middle e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
delete
delete
I couldn't agree more :). If you check the about page (https://www.wondercms.com/about) and scroll to the bottom, you will see the "What can WonderCMS be used for". If you ever feel like joining in on a project like WonderCMS, don't hesitate, we would love to have any help. There is also a rewarding system in place and most of the contributors have received minor cash rewards (alongside other credits).
First, install prestissimo plugin for composer to speed up the downloads. It makes everything ridiculously faster and I have never experienced any downsides. 
Oh yes you're right, sorry I didn't see. The "Who, Why" part is interesting too! I might contribute to the project, I'll see if there is a need of my work, and if my ideas match to the project's ones.
That certainly does tighten up the post quite a bit! It allowed me to remove a whole section. Thanks for the note.
Even if that is the case, most won’t care if the name is not exactly correct. If your name contains some strange characters I’m sure you already are used to replacing them with something else that’s close enough.
Wondering about that last package. Symfony used to have a symfony/lts and a symfony/prefer-lowest package. Both are abandoned, in favor of a environment variable I believe. Does this package work similar as one of those?
true. I like to combine faker with “alice” for easy fixtures based on yaml files.
Don't you have error logs/monitors? :-)
&gt; Does this package work similar as one of those? Sort of, but the goal is slightly different. It basically prevents your other dependencies from locking you into a "newer" version of Symfony that no longer receives updates. Here's an example: Silex v1.3.6 requires `symfony/http-foundation: ~2.3|3.0.*`. You hear there's a security update available for this package so you `composer update` - as a result, Composer installs `symfony/http-foundation` version 3.0.9 because it's the "newest" version according to semver that fits Silex's constraint. The problem is that 3.0.9 doesn't have that fix and is no longer updated - 2.8.49 is the more-recent LTS version that has the fix! One possible solution would be adding a constraint of `symfony/http-foundation: ^2.8|^3.4|^4.2` to your package. You'd have to do this for all Symfony dependencies, including ones you may not directly rely on. You'd also have to keep those constraints up-to-date as supported/LTS versions change. Or you could install `colinodell/symfony-lts-or-current` instead and let that handle things for you :)
/u/Sentient_Blade I am currently trying to provide as many modules as possible with the option to enable/disable what you actually need during runtime. This matrix (anchor link) will show you what's currently available: https://github.com/cytopia/devilbox#available-php-modules These images also come stand-alone in different flavours (with/without env options and with/without pre-installed tools): https://github.com/devilbox/docker-php-fpm I guess it's fairly difficult for official images to integrate all that stuff right from the start as that would also mean much more maintenance and If something breaks in their CI which is due to a third-party tool then there's probably not much you can do, except to remove it again. Official PHP images should be as stable as it gets and that's where you have to compromise. There are probably lots of more projects out there that provide many different modules. If none of them work out for you why not build it yourself once and add more as you need more.
Came here to post this. Very simple (but robust) library to use.
Most of the time [tightenco/collect](https://github.com/tightenco/collect) - because it's the least sucking collection library that i know, and it's easy to extend and subtype unlike other ones.
[catfan/medoo](https://packagist.org/packages/catfan/medoo): database abstraction layer with clean syntax [php-di/php-di](https://packagist.org/packages/php-di/php-di): dependency injection [plasticbrain/php-flash-messages](https://packagist.org/packages/plasticbrain/php-flash-messages): store messages between pages
I’d lsof the PID because chances are it’s compromised.
Eli5
Get the process id of that process, use `top` or `ps aux | grep php`. When you got it, `lsof -p process_id_here`. It'll tell you which files it has open. You might see it's connected to botnets or what not.
These are your words in first post: &amp;#x200B; &gt;It's not even something I'm willing to debate, it's my opinion that's set in stone &amp;#x200B; But now you say: &amp;#x200B; &gt;What you could have done is list why what I wrote is nonsense and provide *evidence* to back your statements up &amp;#x200B; Don't you see the contradiction in your posts? What's the point in arguing with someone who clearly said that they will never do that. &gt;you've got nothing to bring to the discussion except latent hate towards me &amp;#x200B; Nah... just like trolling people who believe they are some experts in discovering true nature of big companies and their alien-lizard owners. I for one, welcome our alien overlords :) &amp;#x200B;
Probably testing frameworks ([phpspec](https://github.com/phpspec/phpspec), [Infection](https://github.com/infection/infection)), a coding style fixer ([PHP-CS-Fixer](https://github.com/friendsofphp/php-cs-fixer)) and [SecurityAdvisories](https://github.com/Roave/SecurityAdvisories) - a metapackage for checking known security vulnerabilities of installed packages.
Running a server is a big responsibility. Running a server facing the Internet is an even bigger one. These aren't Ron Popeil Set it and Forget it Rotisserie Servers. If you don't keep your shit up to date you will get hacked. If you followed a guide online, you will get hacked. If you do the how but don't ask why, you will get hacked. `lsof -p &lt;pid of rogue process&gt;` Look for anomalous files in the file descriptor table or a weird `cwd` or `txt` that isn't a PHP binary. That's your first hunch someone spoofed the process name and it's a shitcoin miner IRC process, etc. Also look for odd network connections, IPv4. Sometimes it's a bot hammering your site, that's bad - you need some brute-force deterrence because having a hacked server hack my servers is obnoxious. If you're running Apache, look into my [mod_evasive fork](https://github.com/apisnetworks/mod_evasive), which includes some rules for sieving requests to fail2ban. Now let's say that all checks out, you've got some crappy code that's burning CPU cycles. `strace` the process. `strace -s 1024 -f -p &lt;pid of rogue process&gt;` This will show you system activity, every syscall that's going on with the script. Maybe something's hung on a loop and creating temp file after temp file. What if none of this is happening and it's just an infinite loop of some really bad code? Then you need to set [max_execution_time](http://php.net/manual/en/info.configuration.php#ini.max-execution-time) as a PHP administrative value that cannot be overrode on the application level. Some really crappy coders think it's a good idea to set the mem limit to 999999999999 MB and disable execution time on scripts, because uhm... I don't know why. Anyway one of those should help you ferret out what's going on and put it out to pasture. 
Sounds like a crypto miner to me. It’s probably not actually a php process at all. Kill it and run anti-malware/virus checks
If it's malware he needs to flatten and reinstall because that's the tip of the iceberg. Attempting to surgically remove malware without knowing how it got there in the first place is grounds for a relapse.
Apache 2.4.37? It could be TLS client negotiation thats triggering a zombie process with 100% CPU. 
This is the kind of feedback that we have to search for hours nothing works and then it's the silver bullet right there.
Install htop. It will show which php script consumes the cpu. Then kill it and check the php file.
We made custom CMS because existing CMS doesn't have good UI/UX for novices. We started website in 2000/2003 before some well know CMS. 
So even after I type that I'm not some moron who believes in flat earth and conspiracy theories, you're still trying to pin that on me? Are you autistic or is your stupidity attained by severe training regimen? You suck at trolling and please - keep using facebook products. After all, you are the ideal target population, Dunning-Kruger in effect and zero capability of concluding on your own :) ta-ta
What have you built after attaining all that knowledge?
this learned != applied
I made things kind of blog
I made things like blog, microblog, snifer. As I think this stack of technologies is enough, but I need made projects, yeah?
When outside of a framework I usually prefer kintphp/kint
I think so.
This package - can't live without.
That'd be constrained to the apache process, not php process in a FPM pool. SSL gets terminated at Apache level then request passed through to PHP.
I just have to ask. Are you using an SSH key or just logging in with a password?
Just wanted to say you did a really good basic write up, which was super nice of you. Cheers.
I thought that too. Very well written.
Thanks! I've been active in the hosting industry for 16 years going back to the days of being 4chan's original host, whether or not that qualifies me for anything. Shifting towards VPS and Ubuntu has been an enormous concern that we're finally beginning to see come to light. These days I build [apnscp](https://apnscp.com), which is my opinionated take on hosting. Check it out if you like the idea of system integrity checks and automatic updates. 
I am two years older than your experience in the hosting industry lol, just finished my internship and was allowed to work there after in a summer vacation, but man sometimes I see people like you and it make me instantly think I have so much more to learn
I started at your age and had my fair share of kernel panics back when LILO was a thing. Learning is a life long process. Always keep yourself challenged and you'll do well.
[removed]
Thanks, thoughts for next steps? 
Refer to ELI5 follow up below. Beyond that I'd need to know the results of your findings to make any educated guess without groping at random ideas.
Can I assume its a missed update? Have been guilty, on Wordpress too. 
If you're not using [WP-CLI](https://wp-cli.org/) as a cron to periodically update your WordPress and its assets, then it's time to flatten and reinstall. You got hacked and deservedly so. You don't run Windows XP in a Windows 10 world and you shouldn't treat your website the same way.
Lots of good advice here so I won't add to it. But make sure you have backups of everything, to install on a new server if you have to flatten the old one. If you do suspect that the code has been compromised somewhere then you really need to reinstall WordPress from scratch rather than restoring from a backup. But you should be able to import your content database, so export it somewhere offline and keep it safe. &amp;#x200B; How current is your WordPress and PHP? If they're recent then it might just be a software issue rather than malware. Restart the server and keep an eye on it, and on your firewall logs. &amp;#x200B;
&gt; Warning: socket_connect(): unable to connect [111]: Connection refused in /usr/local/apnscp/lib/datastream.php on line 272 hmm..
Need to wipe that demo server and setup a new one. Give it a whirl now.
\&gt;zombie process \&gt;100% cpu Pick one
Find the PID of the process via `top` or `ps` and then see what it is doing with `strace -p &lt;pid&gt;` -- You can also check for abnormalities with the process using `lsof`, which will show you the files the process is holding onto. 
Paste some output from `strace`.
it WAS compatible, but then wasn't. Wikipedia was even using HHVM (the platform that runs hack)
hot damn i'll have to give it a shot when i have some extra time on my hands. i really like the demo interface. much better ux than cpanel or whm. i feel like i could accomplish whatever i'm trying to do without having to google for directions. well done! currently i'm using a sort of [roll-your-own setup](https://pamblam.github.io/iLoveLAMP/) to manage my linux/apache servers.
With regards to what you said at the beginning. If guides and other advice is generally bad where does a beginner/hobbiest go to learn how not to get his machine compromised from the get go? If you dont mind me asking
PHP may have a broken standard library, a minefield of unexpected behavior and be lacking as a templating engine, but at least it has an ecosystem full of all kinds of packages and an active community. Hacklang doesn't. If I want to use a language that has the features PHP lacks, I could as well just use any modern general purpose language. Those have those features, an ecosystem, active communities and usually better performance than either PHP or HHVM.
You start with the guides, but explore beyond that. Guides are an excellent starting point, but far from authoritative. Think about this too, these guides were mostly written by customers in exchange for hosting credits or SEO purposes. Producing such content isn't going to be nearly as profitable as gainful employment for most people that have requisite knowledge. Moreover, your audience is scattered; it's not people with technical proficiency... it's people with technical capability, it's designers migrating from EIG brands (they're a racket, but that's another topic for another time) and getting their clients on their own VMs, it's people following the herd off the cliff. Grab some books for things that interest you. [TLDP](https://www.tldp.org/) has a wealth of information and it's free. This space is about knowledge. It's about reading documentation from head to toe and connecting the dots. It's about getting caught in some squirrelly situations of which I've had many and getting yourself out of them with the know-how you picked up reading [man](https://linux.die.net/man/) pages. In order to properly manage a server and learn the job functions of system administration, be prepared to put in at least 10 hours a week. Look at your logfiles, interpret them, and find ways to work more efficiently. Setting up a blog because you read how easy it was and left it at that is a recipe for disaster in due time. We're governed by the physical world and in the physical world, shit breaks. Be prepared to stay on top of things. For example, here's what I put into a [provisioning a server](https://github.com/apisnetworks/apnscp-playbooks); it's far from complete at ~8,500 lines of Yaml. You can work through that and get some ideas about threat deterrence and configuring basic services. Just read and put time into understanding the software you use. Once you understand those concepts, learn about the protocols and how they work. Once you have a rough understanding of protocols, then look into how certain aspects overlap (e.g. TLS transport layer on HTTP). Everything is built upon something else in tech. You must know the fundamentals to avoid getting burned and that comes through lots of reading.
You get a mentor.
Thanks! It's free until 3.0 is released either this month or next once I'm satisfied with it. Until then licenses are good for 60 days and can be renewed in-place however often you need. All of the code is available on [GitLab](https://gitlab.com/apisnetworks/apnscp) save for the backend broker that also enforces license checks. If you're comfortable with CLI, there's also several [helper tools](https://hq.apnscp.com/working-with-cli-helpers/) that make panel interaction a breeze. Let me know if you break anything!
&gt; 4chan's original host If you were at all involved in figuring out how to effectively deal with their traffic levels: yes, yes - this does qualify you for something
I would have to guess Wordpress allowed this to happen, assuminh it turna out tobe malware. I lost track of how many Wordpress exploits have popped up over the years. Migrating from one Linux system to another, even if you need your .htaccess files and such (assuming you are keeping the same httpd) is fairly painless. Everything is files, files, files, even your virtual hosts. Dump your SQL database and other information, copy over crucial files and settings and the rest just might require a few hours of troubleshooting if everything does not just work ad previous before.
How did you get by those Windows statistics? I don't know anyone that uses that in a professional environment, besides call centers or tech companies that have some gaming aspect involved. It may be accurate, but it's really hard to imagine from where I stand.
I started back when Dinorasmus were still around and my editor of choice was a durable toggle switch and a 6v bulb.
Yeah [w3techs](https://w3techs.com/technologies/overview/web_server/all) shows 9%. However I do have clients that use Windows servers for some of their sites, that they host themselves in their office. I managed to get them to move one site to an external Linux box but no luck with the rest so far...
Yup. cryptominer installed via unpatched WP exploit. Seen this far too often. Best bet is to reinstall everything. 
PuPHPet is dead. I'm working on a Docker version. Will be announced soon.
To be honest I'm a pretty moderator.
The convention is to use suffixes, like NameableTrait or RepositoryInterface 
So the issue is content migration today as opposed to end user UI. There are a lot off good CMS with great end user UI. 
WOW ! Thank you, what a fantastic answer. I agree with your point of view and try to take it learning myself, its no good being able to copy code from a guide if you dont understand what config changes youre making and how they alter the services and server. Lots to brush up on their, and stuff id read only lightly I will have to dive deeper into. Thank you so much 
I don't think I've seen any standard like that, and I'm not a big fan of Hungarian notation. Traits, interfaces and classes should be UpperCamelCase (aka PascalCase)
Is the use of trait any good? Can someone explain why? 
Use whatever you'd like just as long as you keep it consistent and readable. 
PHP doesn’t support multiple inheritance. So in order to keep things DRY where multiple classes share a similar interface but shouldn’t share inheritance you can use a trait.
PSR bylaw says you should use suffixes: https://www.php-fig.org/bylaws/psr-naming-conventions/
They're for horizontal sharing of functionality. In php you can only extend from one class so traits becomes useful for when you want to share functionality across classes but don't want to get tangled in complex inheritance schemes.
https://www.php-fig.org/bylaws/psr-naming-conventions/
I highly discourage it because they’re often used like plug-in global functions most of the time. There are case-by-case exceptions, but it’s probably one of the last means. 
I agree. I’ve done it. It’s rough. Though, disabling wget and curl from anyone but sudoers will usually stop it once you trash the executable and the cronjobs
Patently poor advice. Any decent hacker worth his salt will modify a WP system file and add a backdoor or two. This doesn’t stop native commands either, which again if I know you’re deficient on security you’re taking the easy way out. I’ll add a payload up top and hit that file at a later date with more intensity because you’re persistently clueless.