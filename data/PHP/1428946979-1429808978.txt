Interesting read! I don't know too much about ORM hydration, but I now know a bit more!
A small project that might prove complementary to this: [composer-haydn](https://github.com/DHager/composer-haydn) lets you temporarily and safely "override" `composer.json` settings without changing the underlying file. That way you can substitute a custom repo / dependency-version, and you don't risk accidentally checking in the changes.
Hi there, i think i would help : https://docs.google.com/document/d/19cLLfEU_DGS40XzCKouBoIIrtrymJap5sMEoK_mDcSw/edit?usp=sharing
It's not a bad idea, but the configuration is heavy.
Jenkins CI with GIT hook + [mina](https://github.com/mina-deploy/mina)
Looks nice.
It's not really quite that simple. PHPSpec helps primarily by limiting your abilities to verify as opposed to describing behaviour (in my opinion anyway). It's actually quite frustrating at first - something I think I should be better documented to ease the transition from PHPUnit where anything is permissible. Other than this, PHPSpec is pretty good at what it does. It's opinionated and generally pushes you along the correct path. There's a reason why it's biting at PHPUnit's tail ;).
i prepfer to follow the existing 'standards'. something like __initStatic would be more php-like
I don't understand. Do you mean your `packages.json`?
We all have to do it all normally, though recently we got a design guy, but haven't worked on a project with him yet
`composer.json`*, yes. You have to rewrite the configuration and search for the repository URL.
Doesn't pagination throw a wrench into the multi step hydration examples? Are these something Doctrine already does, or is it like a POC, that might be implemented later?
Yes, but using public attributes break lazy loading.
Thanks for the tip!
Sounds pretty horrific, what are you trying to achieve?
These things are why I dislike doctrine. It abstracts too much and thus a regular developer will not know he is doing something that inneficient. You can argue it is his fault for writing such queries. But he mught assume you handle it in some syper magic way. 
we use stash with memcache in production; no issues
i think the support was dropped in php 7
Well, it allows this sort of operation: just imagine if the ORM was so strict that these optimizations weren't possible... Anyway, this is basic usage of the `UnitOfWork`, and most devs don't do more than one fetch-join at a time anyway.
Exactly this, I did it by checking to see if a salt existed (In the old pre-laravel system the salt and hash were in different columns), if it did then update the password to laravel's crypt() version and remove the old salt.
Well yes. Actually I think Doctrine does very well job at implementing unitOfWork, but its the pattern itself that is inherintly more resource hungry than simpler approaches. In the same way I consider its entity cache to be a great idea application wise, but it does require a lot of memory.
phpredis
wow, I've never seen it. Still cant see any use ;)
Is that new? I had just found [this](http://stackoverflow.com/questions/10123105/doctrine2-does-not-lazy-load-on-one-to-one-bidirectional) issue while searching earlier. Felt like a Baader-Meinhof thing getting here and seeing yall talking about public properties and stuff. Good thing it's working now, though. Thanks for the good job.
Not that I discourage anyone to build things on their own to see how they work, but this task is much easier to accomplish in practice (and much less prone to error) using composer and a few prebuilt packages (along with a little bit of glue / business logic code).
Very interesting article. Sometimes I wonder if NoSQL database wouldn't be a better fit, performance wise, to the DataMapper pattern than SQL is. When you speak of the hypotesis of "Generating hydrator code - solves constant overhead issues", are you referring to the overhead induced by using reflection ?
I'd suggest you to go here, http://www.php-fig.org/ and read from PSR-0 to PSR-4. Also here http://www.phptherightway.com/ No proper autoloading, files with .class.php, code style is just horrible, variables named $c, $ci, $ca etc.. Functions has way too much code, no namespacing, no http abstraction and these are just a few I've noticed while scrolling through it quickly. I'm not discouraging to build your own framework as well, but.. if you are teaching someone to write their own framework, you better do it damn good. 
Oh okay. That makes more sense now. Thanks!
I'm using it with redis 
Eh? Nowhere does the developer say the package is not production ready. The say you should review Minor changes. That means that minor changes may not be backwards compatible, it's not an indication of "production quality" whatever that is. For example, do PHPINFO on a PHP server running 5.4. You will see: Libzip version 0.10.1 Does that mean the Zip library embedded inside PHP itself is not production ready?! No. I can name a half-dozen open source packages that have been in 0.X version for years. It's an open source convention some projects use to indicate "never finished" and not a metric about quality; which is more about marketing IMHO.
I do write unit tests for the little business logic I have in this app. It seems unit testing can be easier than writing some of the functional tests. Thanks for the information alazyreader. 
It could be, but whar good is it for if you cannot join data? (Yes, I know that you can bomb them with simple fetch queries) I personally think that graphdbs are the perfect fit, but even there, the resultsets are denormalized. The codegen stuff would remove some reflection/looping, see https://github.com/Ocramius/GeneratedHydrator as an example
Keep up the good work, really like Silly. I often do very small applications with just a router and container grabbed here and there, always use Silly to add a small easy CLI on top.
Does anyone know how big of a performance hit Discriminator fields have on hydration? I read the Doctrine documentation but it wasn't that clear to me.
This doesn't answer your question, but will most likely solve your problem, run more efficiently, and be safer. Use prepared statements and PDO.
I made a lightweight function mocking tool a few weeks ago too: https://github.com/adamnicholson/fnmock
This is a good post. Thanks. I'm curious to understand more about this automatic object hydration. Is this optimization tied directly to immediately sequential calls? Does it rely on having the same $entityManager instance performed on? Are we limited to a certain number of result sets hydrated in this way? At what point would it/could it become a de-optimization, in that hydration becomes memory issues for concurrent queries? Curious about scalability in relation to reliability. Thanks. 
The performance overhead is not the discriminator field, but the fact that you cannot lazy-load an object when you don't know its type. If you don't reference the leaf node of an inheritance (in which case you can predict its type, as you don't have any other child classes), then the ORM has to do a DB query and select the discriminator in order to find out what kind of object you are referencing. It basically breaks the lazy loading mechanisms.
&gt; Is this optimization tied directly to immediately sequential calls? No, you can perform this operation in separate and unrelated contexts &gt; Does it rely on having the same $entityManager instance performed on? Correct - same `UnitOfWork`, to be more specific. &gt; At what point would it/could it become a de-optimization, in that hydration becomes memory issues for concurrent queries? I suggest that you to experiment with the repository that I linked at the end of the article: you can try different combinations of amounts of records and see the performance differences for yourself. The experiment includes: - lazy loading (lots of queries!) - fetch-join (slow hydration, but single query) - multi-step hydration 
Unless you're doing it for aesthetics or if you're insistent on getting an instance of Closure, the below is perfectly fine PHP: $peter = new Person("Peter"); $nameGetter = [$peter, 'getName']; echo $nameGetter(); Thus you could reduce your magic getter method to: public function __get($name) { return [$this, $name];
Stash doesn't seem superfluous, because it has a cache stampede protection, unlike simple in-house caches or even Doctrine Cache.
I'm afraid you're reinventing the wheel there, have a look at https://github.com/franzliedke/studio
Using NoSQL to solve a data mapping pattern problem would be like putting a different engine in your car because you're not tall enough to push the pedal all the way down. Relational databases, though now unfortunately perceived to be quite "boring," are almost always the right tool for the job (or the right tool for the job your project will become when it grows up to have object relations, which will happen in 99% of cases). If your project is one whose data is expressed best as individual (perhaps loose-schema) documents, you have a use case for a NoSQL database. People whose projects have eventually been burned by e.g. MongoDB are those who thought "schemaless is perfect for me" and then a year down the road realized that those documents have relationships to other things and either suffered MongoDB's performance issues in "joining," or took the joined portions of the data out into an RDBMS and now they have the operational overhead of two separate databases. Equally, ORMs turn simple tasks into absolutely trivial ones, but can tend to turn more complex tasks into horrendously complicated ones. You need to fully understand both the RDBMS' work and how to structure it to be efficient as well as the "magic" under the covers of the ORM, which is mostly the subject of OP's post here. I will say with certainty that these problems affect us all, regardless of whether you use an ORM, or which ORM you might use. We do not use an ORM at my job, and we semi-automated hydration through each model. The downside is that we didn't think through the right patterns for all of these scenarios. The upside is that we built a system that runs and makes billions of dollars (not an exaggeration) quickly and in a way everyone can understand. I'm a fan of "get it done" and formalize patterns and structures later as they emerge.
It really depends who else is on your team. If you're all PHP guys then yes you'd need to do the design/front-end stuff. If you have a designer they should be able to do the graphics along with HTML/CSS.
It's also backwards compatibility of sorts with the mysql extension (from PHP 3 or whenever). The procedural version of mysqli ext is almost identical so it's very easy to migrate to it.
Awesome!
Is the PHP 5.5 requirement absolutely necessary? I'm on RHEL and stuck with 5.4.
Thanks for your helpful reply! What I've done for the moment is change the character set of the form from this article: http://www.w3schools.com/tags/att_form_accept_charset.asp Is this an accepted solution? It works fine for us, that cheatsheet does seem a little long winded for what we want to achieve.
I just want to call out some special attention to dependency injection containers and service location, in that some people still think that dependency injection containers are service locators. This is false. Service location is not a *thing*, it's something you *do*. If you inject your entire container as a dependency and then resolve further dependencies out of the container, you are doing service location. This is bad. Avoid this if you can. At some point you do need to kick start your application through a call to one or more services in the container, but that's fine as long as you keep it isolated at your initiation script. Don't let your container leak all over the place. If you are just using the container as a factory and injecting precisely only what your classes need, and your classes have no knowledge of the container itself, that is proper dependency injection.
Although it's not clearly specified, you can have a package outside of application path, which is shared by several applications, you just have to tweak the path to the package in your 'studio.json' file : { "packages": { "vendor/package: "../shared-packages/package } } 
It might be more proper, but damn it makes it so much easier to develop applications. I haven't really come across real issues with this approach.
Are you looking for finished projects or ideas for new projects? Anyway I think that PHP stuff isn't usually really "flashy". Instead it's the JavaScript, HTML and CSS part because it's all graphical and interactive. Maybe look into animations, visualizations and games.
That's the same reason that the "ContainerAware" sub classes are kind of evil in Symfony 2, mandatory dependencies should be passed through constructor and optionnal ones through their individuals setters. Otherwise your business code could become coupled with your container which would be bad for long term maintenance
Definitely using fast-route instead of Symfony routing, as well as lazily instantiating a full HTTP request if, and only if, we need the full request. There are many other small things, such as forcing the developer to opt-in to Eloquent, sessions, etc. instead of enabling them by default in full-stack Laravel. The entire bootstrap process is also located basically in a single file, which is less configurable overall than full-stack Laravel, but for small micro-services and APIs that are mainly interested in speed it's a good trade-off.
Not sure exactly what you're looking for. Are you trying to find a project you can all work on? How about just a simple forum type of site you can all hang out on. When I was in high schools, some friends of mine started building a site that let you post messages, upload files, share pictures and stuff. Of course that was like 10 years ago (oh god, the age, it's terrifying), so those things were a lot more "flashy" back then. But still, it's something to try. If you wanted to make it flashier, make it just a site that hooks into other sites. Instead of logging in with credentials created just for that site, set it up to use Google account logins. Instead of storing files locally on your own system, see if you can have them passed through to Dropbox or a similar service through their API. Try Trello instead of messages, or YouTube instead of local videos.
Because they are un-transparent, and they are still de-normalized data. Logic does not reside in the DB, and to be honest, the NoSQL folks are doing it right. (Yes, DB constraints should still exist, but they are not logic)
I love the idea of a lighter Laravel for those smaller needs, thanks for all the work you put in. Would Lumen be well suited to processing queues from a Laravel install? Is there any advantage to doing it that way vs just using a Laravel Deamon?
I really like the idea of Lumen processing queues from a Laravel install, or vice-versa, pushing things onto a queue for a full-stack Laravel app to process. I think that's a really, really good use-case, especially if the jobs are being triggered by incoming HTTP requests and their a lot of those requests.
may I ask what logic are we talking about here? Honest question. Where's the logic when doing select statements like the one you showed in the article? Instead of going against the orm abstraction layer, why not just have a view and a related object to it?
That can't really be done in full-stack Laravel based on how Symfony Routing works, which requires a full HttpFoundation request. In Lumen we use fast-route which just needs a request method and path, which we can parse from $_SERVER directly quite a bit faster than creating an entire HttpFoundation request. I don't want to overblow the cost of making a HttpFoundation request though. It's not *huge* - it's just one piece of the puzzle to making Lumen very fast. Another interesting way the speed is increased is how the service providers and IoC bindings are even lazily registered, which wouldn't work for something like full-stack Laravel but saved some good time on Lumen.
I can't believe how bad this is... See [this file](https://github.com/laravel/lumen-framework/blob/5.0/src/Application.php) for example... I guess Mr. Otwell has never heard of [SRP](http://en.wikipedia.org/wiki/Single_responsibility_principle)...
I don't think putting all source in a single file makes it easier, and there's very clear drawback. I just haven't really seen very strong drawbacks when passing a DI container around, in the places where I've done this. I avoiding doing this for the libraries I write, but I have applied this pattern on a number of occasions for various projects for customers. You're right though, that the projects where I've done this tended to be on the smaller side. It makes the application pretty tightly coupled, but it's a trade-off that has been ok for these customers. I'd love to learn about some non-dogmatic reasons why this pattern, in general, is always a bad idea.
So, I have zero working knowledge of Laravel, yet I have to say the middleware using closures is one of those ideas that's just so simple and such a good idea for running it before/after. That's pretty neat, unfortunately I don't have any needs for another framework as of right now (using Symfony2, Django, and Dancer for some stuff) yet in the future it'll be a consideration.
If you just wanna a project to study PHP, I always recommend : write a blog or a site with an administrative area (where you can upload new banners, change the content of some areas, etc.). The idea is the learn the CRUD (Create, Replace, Update, Delete). It is the basic and frequently used in various projects. You can play with html, css, javascript while learning php or download some layout.
That kinda mirrors my experience with ORMs where unless you have somebody who can oversee the ORM implementation and has a lot of knowledge about it you end up just making the easy trivial but the difficult tasks incredibly confusing.
How are established industry practices elitism? I personally wouldn't want to maintain that file. But no doubt, there are better ways to mark the point than the given one ;)
*Of course, Lumen applications can queue jobs for your main Laravel application to process. Laravel and Lumen are designed to make a perfect team, and, when used together, allow you to build powerful, micro-service driven applications.* http://lumen.laravel.com/docs/introduction#when-should-i-use-lumen
So following SRP is elitism? Or how exactly did I hurt your feelings?
That tone is maybe a tad to agressive, still I'd love to see some numbers. (especially with modified production opcache settings).
It's the way you decided to approach the topic. I know programmers in general have issues talking to others, but there is really no reason to introduce yourself like this. You can point out things you don't agree with, you can even be 100% correct, but why go around calling things bad and just generally being a passive aggressive dick? The guy that built this has done colossal work to bring PHP app development out of the stone age (and this is coming from someone who has never developed under Laravel, 0% ass kising), does he really need to be a target? Just think before you post, it's not that hard. Take a step back from the machine and realize you're talking to people here.
Firstly, I think this is great. The more micro-frameworks the better. I can't wait to get the time to test this out. So, I'm running on slim 2 right now. I was interested to see the benchmarks. What benchmarking what done, on what hardware, what as the testing process. Any chance of a github so we can run our own exact benches? I don't want to take the graphs at face value. Thanks
It was not intended to be passive aggressive. What makes you think it was meant to be passive? As you can see for some reason people think he is an expert. And thus they listen to him and take his code as an example. And by writing such bad code (which it is, that's not even something worth arguing about) he sets a bad example and hurts the PHP community. And no he did not bring PHP out of the stone age. That credit goes to other people. All he did was create yet another rails clone that is also full of bad architecture (static "facades", active record etc etc). He should hold himself to a higher standard and deserves the criticism. Publishing something like that is a really bad idea.
&gt; (oh god, the age, it's terrifying) haha tell me about it! The forum thingy sounds like a lot of fun. utilizing APIs to create something is a good suggestion ty! 
The poster claims to know more about software development than the lead developer of a highly successful and popular open source project. Worse, they did so in a condescending manner. It's childish elitism and I'm so utterly fed up seeing it in this industry.
I like it, and frankly this lighter package seems more appropriate for most of my projects than full blown laravel. Thanks for doing this, hopefully I'll get off my ass and learn how to piece together a micro-framework on my own kind of like this. Now I see the value in the less is more, add more with composer mindset.
This is a bit disappointing, I was hoping for a sane font-end JS framework, not yet another PHP micro framework. 
It'll solve this specific problem, I'd probably do it by fixing the encoding of the entire page using a Content-Type header at the top of every page like this: header('Content-Type: text/html; charset=ISO-8859-1'); You may still need to go through your database and fix any UTF-8 pound sign references. However if you ever want to get away from the latin character set and allow users to use other things (Mandarin, Japanese, Cyrillic, hundreds of others) you should get used to using and dealing with UTF-8. In more than one project, I've seen the lack of UTF-8 support come back to bite people in the ass.
For starters, disk I/O is the bottleneck, not memory overhead or processing time required to build the classes. Secondly, a framework that is a hot mess of unstructured code is not going to be maintainable, so what's the point? Taylor still does have to maintain Lumen. A big god class is not ideal, but as he said, there's a balance that needs to be struck. Ultimately, this is the fundamental problem of interpreted languages - you don't have the luxury of compiling 298243234234 single-purpose files into one bytecode sequence, you do need to load files from disk as you need them. Technically could do that with PHP if you wanted, but then you'd have a higher memory footprint as the entire application needs to be compiled together even if you only use a part of it on any given request.
On what configuration? Opcache enabled (default configuration or "disabled" stat)? Did you also run benchmarks on hhvm (in repo auth. mode number of files shouldn't really matter).
All those micro-frameworks seem exactly the same to me. Their hello world examples are also nearly identical in syntax. One wonders why they exist, aside from PR reasons. This one says "use Laravel components you love". If I love Laravel components, I'm presumably a Laravel user, so I don't need a micro-framework. And if those components are truly *components*, I can use them without using the rest of the framework (or this micro-framework). So color me puzzled.
Coming to the end of my first year in uni and our first project using PHP was to create a social networking platform based around a topic of our choice. To do this we used PHP and MySQL databases. It aloud us to get the basics of PHP down and still have fun playing around with HTML CSS and JavaScript 
This is absolutely amazing!
Oh, didn't see. You may are right, but there are some differences with the process, for example, the "shared package plugin" automatically won't share a stable package (useful for production), etc. The idea seems to be the same, the way to achieve it is different, imo.
&gt; The poster claims to know more about software development than... I don't see any such claim.
If you are running a site that has enough traffic that your framework is slowing you down, you are definitely not on shared hosting.
&gt; $this in *static* context?
By having most of your codebase aware of the container you end up violating the **L** from the **SOLID** principle which is : &gt; Liskov substitution principle &gt; “objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.” If for example I have a mailer service in my application and I want to instantiate it with a mailer in production and a file writer in dev, all I have to do with non-container aware service: $mailer = new MyMailer(); // which implements Mailer Interface with method mail($to, $from, $subject, $message) $mailingMailerService = new MailerService($mailer); $fileMailer= new MailToFile(); // which also implements Mailer Interface $fileMailerService = new MailerService($fileMailer); In your container you would have to keys $container["mailer_service_prod"] = function () {} $container["mailer_service_dev"] = function () {} To achieve this flexibility using your container aware component you would have to : * Define your services in your container * Instantiate your class which will pull it's dependency from the container * Modify your container on runtime object to allow the same key to return an other object * Make your that your object instantiation return a new object which will then pull it's dependency from the container In your container you would have $container["mailer_service"] = function () {} // which has to return a new instance each time The service returned would then get its mailer from a string like "active_mailer" Before accessing your service mailer you would have to assign the active mailer with something like this for production: $container["active_mailer"] = $container["my_mailer"] $mailerService = $container["mailer_service"]; And something like this for dev: $container["active_mailer"] = $container["mail_to_file"] $mailerService = $container["mailer_service"]; Ideally you would not pass the container around, but when you do so, you must be aware of the drawback and pitfalls that can occur. Either go fast with limited extensibility or a bit slower with the more flexible approach. For a small project with a short livespan, there is not so much issues, but for bigger applications with longer expected lifespan, you might end up in trouble. A principle is a principle, not an absolute rule, you can do whatever you want as long as you are aware of the consequences 
&gt; If Lumen is so fast why can't Laravel just be made to run that fast? Lumen cuts corners that would slow down larger applications' development processes. &gt; Should it be used for building full websites or is it really only suitable for APIs? It could be definitely be used for full websites but it shouldn't be used with applications that have many different working parts. &gt; If it's supposed to run alongside of Laravel, how does this fit in with my current Laravel website? Would I install this on the same server, maybe responding to a different subdomain that's just used for APIs? Yes, exactly. &gt; Can I install it in the same folder as Laravel? Would it share code with my Laravel project (models, services, etc.)? No, if you want to share code between your projects you would want to make a library (separate project) instead that both your Lumen and Laravel project would import (use) from. &gt; But aside from that, why am I not using Lumen? Should I be? /u/utotwel gave some examples on the Lumen page such as a separate API. Another one I could give would be a small blogging platform ([example](http://taylorotwell.com/)). Basically this is a micro framework, anywhere that you were previously using Slim or Silex, you now have the option of using Lumen which is just as fast if not slightly faster. Previously using Laravel would simply be too much and a bit slower. And on the plus side since Lumen uses standard Illuminate (laravel framework) components, you can easily upgrade it to a full Laravel project by copying your files into a new Laravel installation.
I was more or less asking why should I use this over other micro-frameworks, but gave pretty crappy examples when it came to "making things faster". The only reason on that the Lumen home page of why I should use it is it's faster than Slim and Silex. A dragster is faster than my car, but it isn't as practical to drive to the supermarket.
I feel this blog post would work just as fine if we replace "controller" with "class" in general. This is why traits exist.
Well, a couple scenarios: 1. You care more about speed than other factors (such as features, familiarity with the API, etc) 2. You are familiar with Laravel and just want or need a faster, lower-profile version of it. 3. You haven't had a need for a micro framework before, but now you need one because of performance reasons, so see point #1. 4. You want the best combination of speed and features you can get your hands on (Lumen seems to trump both Slim and Silex in terms of features and speed, since it's faster AND is basically full stack Laravel). That said, I've not used Slim or Silex. I can only surmise they are not as feature-rich as Lumen is since they are not ~90% the same as Laravel. And from the totally unverified benchmark claims, Lumen is faster. Seems like the best of both worlds, but of course, that's yet to be seen in the wild.
The article says sarcastically: &gt; No, it's not "don't use an ORM", you muppet. Yet the described technique has been common sense for decades for those who write their SQL. If you don't let an ORM hide such "bad by default" decisions that generate tons of duplicate data, you get oriented quite quickly as to how to query the data you need more efficiently. So maybe the answer to smart SQL usage is, in fact, "don't use ORM"?
Those are good reasons, but like I said, that needs to be on the Lumen main page website. I don't use Slim either, but look at their main page: http://www.slimframework.com/ Right there I know that I'm getting: Router, caching, sessions, crypto, etc. For all I know from the Lumen page, it seems it only comes with a router (only because of the code blocks up top) and no support for controllers, views, sessions, etc. I'm saying it looks like its a branding/marketing page fail.
I'm not sure the word you want to use is "normalized" here. Normalization doesn't refer to duplicate data in a result set. That's one of a few reasons your article, which describes a very basic concept, is somewhat a hard read. Another reason is that most of the article is about how to battle Doctrine into complying with an obvious query refactoring.
sounds like fun :D 
Think of anything you would not use Slim or Silex with. Same applies here.
&gt; CRUD (Create, Read, Update, Delete) I always preferred Create, Read, Alter, Purge.
The negative opinion about a piece of source code is not in any way a statement of the poster's belief about their superiority as a programmer. The poster might be a dick (and looks to be from his posting history), but you're still making an assumption about his thoughts on his own programming talent. I can state I think the linked code looks like shit and simultaneously believe Taylor is a better programmer than me. The two have nothing to do with each other.
An easier entry point is definitely a huge advantage. I have some co-workers I could steer towards learning Lumen. That would set them up in the future to use Laravel if/when their needs expand. Some textual references would go along way to helping them. The Lumen documentation like Laravel assumes you already know pretty much what you want to do and how it should be done just saying here are the functions. Like laracasts but readable.
Luckily, input was coming from trusted sources... ie Employees. God knows there is a chance of a disgruntled employee sabotaging it, but considering it was also access restricted to management level of a small company, I didn't actually bother... Laravel, obviously, handles sql injection attacks &amp; CSRF. The chances of the people using that specific interface knowing about &amp; utilising html/javascript (or the damage that could be done) did not make it practicable to implement. But, as /u/padraicb points out, there are a wealth of repos/functions/methods of securing html input.
You're using "denormalized" as a synonym for "has duplicate data", but you're the first person I see talk about normalization (and denormalization) of *result sets*. Normalization refers to persistent table schemas and data, not result sets.
One service call: $svc-&gt;getBlogPosts($userId); You don't need to extrapolate that far into speculation just because I mentioned "microservices" once. I was seeking a word to facilitate understanding. There's also an increasing understanding in the industry that it's a bad idea to treat remote entities as if they're local objects, with built-in business logic and what not. Step one was the abandonment of ActiveRecord for DataMapper, and this was a lesson Doctrine learned from. Were you furiously defending ActiveRecord before? The next lesson is to abandon ORM as a concept.
You don't need to be "given" a semi-MVC abstraction, that comes from the way you organize your code: $router = function ($url) { ... return $controller; }; $controller = function ($input) { .... return $view; }; $view = function ($vars) { echo 'html with vars'; }; Here's your abstraction, sans framework. Go forth and code. 
Well if you insist so strongly to call it like that fine. But don't be surprised when people give you funny looks, or find your wording confusing or arbitrary. The entire classification of data normalization in RDBMS is based around difficulties in updating and inserting into a denormalized database (because you have to update/insert data in multiple locations). You would never "update or insert" into a result set, it's a read-only transient view of the given query. So it literally makes no sense to talk about normalization there. Especially because to talk about "denormalized result set" implies you can normalize it. And you can't "normalize" an 1:M or M:N outer join into a single set, as you note yourself. You can't say something is "denormalized" if it can't be "normalized". It's a non-sequitur.
Can I use Illuminate components to create my own microframework?
If they are so simple this is a great opportunity for you to learn.
You're hydrating it into objects, not normalizing it. The contortions you need to do in order to map results to objects are entirely not of concern to the result set. At this point it's out of the SQL domain and into the PHP domain. The resultset can't be "normalized" into a "normal resultset" so it's not a "denormalized resultset"... Come on, let's just use the right words, it's not that hard. 
There are tons of examples on the web, just google. I doubt your school intended for you to simply ask for 2 PHP sites online, unless the class is in social engineering.
I guess it fits different workflows. I don't see why I would require such a tool on a production server though ;)
This might help with your micro-framework: http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1 It's symfony component specific, but it puts the pieces together one-by-one.
For those interested. More Benchmarks here, source available. http://104.236.58.25/ plz be gentle on the downloading. All tests done on a $5 DO droplet CentOS 6.5 php 5.6.7 from webtactic. o7 tldr; Note: All tests were done with ab -t 60 -c 5 [579.61 req/s] Slim 2.6.2 Results [376.28 req/s] Slim 3.x - develop Results [627.89 req/s] Lumen Results 
I'm one of the devs of Bolt, and it sounds like it might be what you're looking for: https://bolt.cm / https://github.com/bolt/bolt It's based on Silex, and uses Symfony components and other composer packages. Bolt is free and open source. We have a steadily growing userbase, and our "github numbers" keep increasing. If you have any questions, feel free to ask, or drop in on our IRC channel: #boltcms on Freenode. 
Yes. I've used Illuminate/Database with Slim in the past, and on it's own.
Whoops my bad, updated the snippet. Thanks for pointing it out :)!
I ran Lumen out of the box using the same example that Taylor suggested. ab -t 10 -c 10. I ran slim using the documentation from the slim2/slimdev githubs. I'm running on Intel Dual E5-2620 V2, 2x4 Cores allocated, 16GB Ram. I'm always hitting http://www.some-domain.com and hitting the default index.php supplied with the framework.
A few typical small apps: * Todo list or notes page * Bookmarks/links page * A blog is the classic first php app
A lot of this just is not correct. PHP7 does not have a JIT compiler, and an AST implementation does not increase performance as it is another layer of (A)bstraction. It was added for other reasons. The async section also doesn't make much sense unless you're referring to generators, but you don't actually say as much and instead imply that PHP7 has async features like Hack which it does not.
Thanks for the reply, that did answer some of my questions, but I think what we really need is a low level nuts &amp; bolts description as to what the difference is between Laravel and Lumen, not just the generalities about it being somewhat less full featured and faster. For example, is Lumen basically an installation of Laravel, except with a different router? Certainly there's more to it than that, but beyond that it's all very unclear. Maybe it's that, but also the bootstrap process is tweaked so that it doesn't load or register components ahead of time. Is there more to it than that? And apparently it doesn't load config files, so configuration is different. We need a *complete* list of what Lumen can't do compared to Laravel so we know when we can and can't use it. As developers, I think it would make more sense to us if Taylor just said "here's what I did... I took Laravel and I removed XYZ, and swapped out foo with bar, and then made the bootstrap code no longer do such and such..." Right now there are some vague generalities, and only a few specifics as to what the heck Lumen actually is.
That's ok folks, no one is paying attention to PSR's except for 1 and 4 anyway. Why is any of the rest being standardized is beyond me. It's apparent even the standards writers aren't quite sure what they're doing (evident by PSR-7 being massively overhauled after almost making it in its old version).
This seems like the most sane way to do it. You could mess around with the v8js library, but you're going to be in mostly uncharted territory. If you only want to evaluate simple math statements, [this stack overflow answer might work for you instead](http://stackoverflow.com/a/27077376/138106).
wtf did I just read?
How does one use the Zend OpCache to cache PHP data structures? I didn't know this was possible, it sounds great.
The Liskov principle has nothing to do with dependency injection containers, it regards subclasses standing for their superclass, so that's a somewhat arbitrary argument.
For my company, ORMs work very well as the "Model" portion of our MVC, and allow us to create a database abstraction which can let us pivot poorly made databases/tables (such as legacy structures and non-normalized data) into a form that is consumable by our view and abstract from both the database and the frontend. Essentially it's a design choice (with some negligible sacrifice towards efficiency and size) that has led us to architecturally decouple critical layers of our (large and cumbersome) codebase and data. The goal for us is just to achieve low [coupling](http://en.wikipedia.org/wiki/Coupling_%28computer_programming%29) and high [cohesion](http://en.wikipedia.org/wiki/Cohesion_%28computer_science%29) in order to refactor huge projects which currently have exactly the opposite of those two things, which makes it extremely difficult to do things like add new features and reorder our database structure.
The main `downside` is that everything on the page has to be loaded over HTTPS or otherwise the browsers might consider it insecure (depends on the browser (version)). Another one is that it will require slightly more CPU then a normal HTTP request, depending on your hosting platform that won't matter at all or just a little bit. It how ever makes the page more secure in return.
It has no link with it, but having all your components aware of your container, limits your possibilities to substitute parts of your application because each component is pulling it's dependencies from the container, so the same class can't easily be instantiated twice with different components, so that part is a clear violation of the Liskov principle
I'll add the video I did on it: https://www.youtube.com/watch?v=IKD2-MAkXyQ
The real criticism for ORMs in my mind is that they are misused, and all of your arguments are instances of that misuse. People need to educate themselves in the technologies they're using before they implement them, that's not a reason to disparage the technology itself. 
If you want an intuitive, expressive API in javascript, give Ember a go. In many respects it's *philosophically* aligned with what Laravel does (Highly opinionated, developer productivity over right-for-rights-sake, batteries included etc). Sure there's a learning curve but learning any API comes with this baggage...
As someone who's always meant to learn Laravel but has only ever managed to learn bits and pieces, would I be better served by focusing on learning Lumen first and then assuming that knowledge will translate well to Laravel development, or learn Laravel first and assume that in the process I'll basically also be indirectly learning Lumem?
Again, the Liskov principle is about subclasses standing for their superclasses. It's about "Foo extends Bar" where "Foo" can be used where "Bar" is expected. About inheritance. Not about "the same class easily being instantiated twice with different components". You're reading SOLID like the devil reads the bible. Those rules have a specific meaning, you can't just read the abstract and claim this or that is a "clear violation" of SOLID.
I agree with the whole of your comment but I want to pick on a specific thing: service locator are the same thing as DI containers. You said it yourself: &gt; Service location is not a thing, it's something you do. You don't *do* a service locator, you do service location. Just like you don't do a DI container, you do dependency injection. I keep reading "X is not a DI container, it's a service locator" (replace X with Pimple or whatever). Again, it's the same thing: a DI container, like a service locator, **builds objects** (the injection of dependencies could be done automatically with autowiring, based on a config file, or done with PHP code, ...). Then *it's your responsibility*, as the user of that factory/container/service locator to *call it* at the right place (i.e. the root of your application) and not inject the factory/container/SL everywhere in your domain code.
My arguments are about the essence of what ORM is and not about misusing ORM. The whole point pushed forward by ORM proponents is "using OOP modeling for your domain". You can't build an OOP model using disconnected "snapshot" objects, where the actual entities reside in a remote service (the RDBMS). You need to interact directly with the remote service in order to know if your commands and queries make sense as to the current state of the system. This is the opposite of what every ORM encourages, thanks to misguided concepts like "unit of work", naive object caches etc. I have the feeling you didn't even read what I wrote.
Absolutely not. Wordpress is very antiquated, I anticipate having to do custom development, wordpress doesn't have a modern framework.
Asynchronous programming? Are we on the same page? Are you sure the author has been keeping up with what's going on in PHP RFC, at all? 
Except... Opcache.
Hello; I'm in the same boat as OP and just came across your comment. I don't (and haven't ever!) used any PHP frameworks / I've always written everything from the ground up. I'm working on a slightly larger project at the moment that could really benefit from some image manipulation help. Do you have any recommendations for image manipulation? I don't really want to incorporate a whole framework - just a plugin-type-setup that I can slot in and call when I need to..
Either way should do you fine. I would recommend https://laracasts.com for learning Laravel though, well worth the money.
Have you benchmarked it again Phalcon Micro?
As someone who has mainly worked with CMSes, coding plugins and building websites from them, it still doesn't make it clear to me which contexts are appropriate for ORM.
Hey Taylor, Congrats and Good work on the Lumen. I did tried and looks promising. After looking at Lumen, I have a feeling that Laravel itself may be fast if you removed some of the dependencies like [psysh](https://github.com/laravel/framework/blob/78f085ea057e54f5b77ecae2105d0a42899611a9/composer.json#L31), not sure in a production app you need a REPL. What are your thoughts on the same ?
This is a cool approach. How would you feel about creating a controller called AddressController that has a lookup method. You can then call this via ajax from your web interface. Thoughts?
Abstract factory injection is for when you don't know what kind of object you're going to need at run time, and it could vary depending on a given context, or you need many instances of one. If, however, the runtime dependency is fixed and unchanging and you only need one instance, injecting an abstract factory and resolving out of the factory is the same anti-pattern that service location is. In short, it's improper to use abstract factories when simple dependency injection is all that is needed. It's not proper to *always* inject factories and *always* resolve out of them. Abstract factories indeed have their place, but they are not a substitute for a container and they should not be used where they are not needed.
&gt;ad server I hope those are text based ads, you monster. Jokingly, of course.
How much does the use of Sessions slow down the speed of Lumen? Honestly, webapps need sessions more often than they don't, so I'd be interested to see the impact of opting into Sessions in Lumen.
Does this mean doing bindings in Lumen's service providers will require more care instead of slapping them in any old service provider knowing they'll get `register()'d` or `boot()'d` on all requests?
Yep, if your classes all know about the container, then it's just global variables with makeup on.
I like to phrase it as push-vs-pull... When FooWidget pulls in the Container for BarWidget, that's service-location. When the Container pushes BarWidget into FooWidget, that's dependency injection. Now that I write it out, I guess it's really just another way to phrase "tell, don't ask".
No job requires the use of an ORM, but certain jobs benefit from ORMs more so than others. For starters, ORMs do not add any new technical capability, they are *strictly* to save developers time. ORMs do this best when you have 100% control over the relational data structure and you can make the data structure follow whatever conventions the ORM prefers or requires. ORMs work poorly (if at all) when you have legacy data structure or require a structure that is totally out of alignment with the conventions and configurations afforded by the ORM. You can configure an ORM to some extent in case you have a database that isn't totally friendly to the ORM, but where an ORM *really* falls down is when you have an *inconsistently applied* data structure, and you need to configure your ORM on an entity by entity and relation by relation basis. At that point, you might as well just write queries and do your best to encapsulate and isolate them. ORMs also fall down when you have very complex queries to perform and you're not doing anything you couldn't really do with joins or simple relations. That said, in many cases, you can do a simple relational query, and then offload the complex / processing stuff to PHP using generators to save on memory overhead. But [consider this query](http://stackoverflow.com/a/17965336/945775); like fuck I'd want to try and accomplish that in an ORM. Maybe a lower level query builder (which most ORMs use as a foundation), but not in the ORM itself. The best use-case for an ORM is when you have a CRUD-heavy application, but you need a fairly robust relational structure that you just can't get out of a CMS like Wordstress or Drooplol. It should also be noted that the use of an ORM is not a binary thing. Just because you use an ORM, doesn't mean it's all or nothing. Consider Laravel's database layer, it actually has four sub-layers that work seamlessly together: 1. The Eloquent ORM (`User::find(34)-&gt;comments`) 2. The query builder (`DB::table('users')-&gt;select('name')-&gt;orderBy('id', 'ASC')-&gt;get()`) 3. The DB::raw() method (let's you do a raw query string, can be used anywhere) 4. The underlying PDO instance you can get from `DB::connection()-&gt;getPdo()` So depending on how much power and control you need, you can progressively fall back to whatever level is most appropriate for the specific query(ies) you need to do. Maybe you'll use Eloquent 80% of the time, maybe only 30%. But it never gets in your way the times you don't need it.
I'd love to see if it starts to come near the speed of Phalcon
I see that you've been stalking me O.o haha I actually thought about that. However, the Dota API in particular is a bit shady and the dev forums kinds sucks so that's why I came here to ask for help finding something else! Great stalking skills though :D
I use puppet for configuration management in production, and it's just that -- configuration management. Great if you need to predictably provision machines and keep them in line over and over again. You... you are using configuration management, right? Docker is "just" a container format -- you'll still need to do configuration management when building the containers. They're related but not competitors.
What happened to table prefixes? Config is set *only* in the .env file, I get that, that's okay. But all db prefixes default to an empty string and there appears to be no way to change that?
I'm afraid you're also trying to use buzzwords to justify what should be engineering choices. Just like "it's evil" is not an argument, "it's an anti-pattern" is not an argument. If the module of the object that takes the abstract factory defines the abstract factory (as an interface), it's absolutely harmless, because that factory is specific to the object that accepts it. It's not everything and the kitchen sink. It's not the app factory, it's narrow and specific, and has only the methods that this object needs. And in fact can be recommended, so you can lazy-create the dependencies as they're needed. Always needing *all* of them is only the case with very simple classes - say, SQL connection and cache: 1. If you hit the cache, you don't need the SQL connection; so that class doesn't "always need the SQL connection". 2. If you perform a non-cacheable operation, you don't need the cache; so that class doesn't "always need the cache". Lazy-loading is particularly sensitive topic for PHP which has to load its classes on every request. We don't encourage badly performing code that loads the whole codebase on every request, are we? Why on Earth would we? A factory can be a simple closure that returns the dependency. Is this an anti-pattern "as bad as service locators": class Repository { function __construct(\Closure $connectionProvider, \Closure $cacheProvider) { $this-&gt;connectionProvider = $connectionProvider; $this-&gt;cacheProvider = $cacheProvider; } function getUserById($id) { if (!$this-&gt;cache) $this-&gt;cache = $this-&gt;cacheProvider-&gt;__invoke(); if ($this-&gt;cache-&gt;has($id)) { return $this-&gt;cache-&gt;get($id); } else { if (!$this-&gt;connection) $this-&gt;connection = $this-&gt;connectionProvider-&gt;__invoke(); $user = $this-&gt;connection-&gt;query('SELECT * FROM Users WHERE id = ?', $id); $this-&gt;cache-&gt;set($id, $user); return $user; } } } If so, you'd have to give me a tangible problem you see, and not use fancy words that hold no meaning. Now let's refactor this just a little bit: interface RepositoryContext { function getCache(); function getConnection(); } class Repository { function __construct(RepositoryContext $context) { $this-&gt;context = $context; } function getUserById($id) { if (!$this-&gt;cache) $this-&gt;cache = $this-&gt;context-&gt;getCache(); if ($this-&gt;cache-&gt;has($id)) { return $this-&gt;cache-&gt;get($id); } else { if (!$this-&gt;connection) $this-&gt;connection = $this-&gt;context-&gt;getConnection(); $user = $this-&gt;connection-&gt;query('SELECT * FROM Users WHERE id = ?', $id); $this-&gt;cache-&gt;set($id, $user); return $user; } } } The only change here is that instead of two one-method factories, we have one two-method factory. Is this an anti-pattern as bad as service locators? Why? Avoid words like "evil", "bad", "anti-pattern". Let's discuss the actual specific issue you perceive.
Look at these two statements $res = mysql_fetch_row("SELECT balance WHERE customer..."); $money = $res['balance']; $money += 10; mysqli_query($conn, "UPDATE ...."); versus $customer = $entityManager-&gt;find('Customer', 1234); $customer-&gt;setBalance( $customer-&gt;getBalance+10 ); $entityManager-&gt;persist($customer); tell me what the overhead is.
First of all, I said "all customers who have been with the bank for over 5 years" and so both your examples are suspiciously missing the necessary "for" loop you'll need to do it this (poor) way: $customers = $entityManager-&gt;findAllWhere(...); foreach ($customers as $customer) { $customer-&gt;setBalance($customer-&gt;getBalance+10 ); $entityManager-&gt;persist($customer); } Another thing you're missing is chunking. If I have millions of qualifying customers, and fetch them and "hydrate" them in a single query, do you know what will happen? Your PHP will terminate with an out of memory error. Also, both your examples would result in "phantom" money loss or gain if two transactions occur at the same time, so they're in fact, both wrong. Do you know what an "atomic operation" means? In both your examples the update operation you have is split into a decidedly non-atomic read/write operations. The balance *can change* in-between the time you read it, and the time you set it back. This would, in fact, sometimes result in setting the balance to the *wrong amount*. No, doing it "really fast" doesn't count as atomic, either. It's either atomic or it's not. If it's not, you risk data corruption (i.e. lost or gained "phantom" money). This is why it's hard to argue with you ORM fans, because you folks don't even know the first thing about working with data. And actually, yes, not only are both your examples are wrong with regards to maintaining data consistency, they're also highly inefficient compared to the canonical, **atomic** way of doing the above: mysqli_exec("UPDATE accounts SET balance = balance + 10 WHERE dateCreated &lt;= NOW() - INTERVAL 5 YEAR"); Look, mom, no arrays, no objects, no chunking, no **out of memory errors**, no loops, no **data corruption**... Who would've thought? Also notice no ellipsis in mine. If we expand your examples to include chunking / streaming result sets and the full query for selecting the right users, it'll blow up to over 30-40 lines of code, and here's how you query would look like: $entityManager-&gt;findAllWhere(new LessThanOrEqual(new Field('dateCreated'), (new Carbon())-&gt;subYears(5))); So elegant, so readable.
&gt; As you can see for some reason people think he is an expert. Because his code is, on balance, pretty good. Perfect? no, but perfect is the enemy of good. &gt; And by writing such bad code (which it is, that's not even something worth arguing about) He's pretty much admitted it's a god object, and explained the reason why he did that way anyway. He's accepted the trade off for something HE has to maintain. Not you. Even if you depend on his code it is unlikely this decision will directly impact your work. &gt; And no he did not bring PHP out of the stone age. That credit goes to other people. As far as *userland* code goes, his stuff was at least a breath of fresh air. yes others were working on improving PHP, lobbying internals, building composer and getting a general ecosystem of things together...but Laravel's killer feature, it's expressiveness, was largely unseen prior to Laravel. &gt; All he did was create yet another rails clone that is also full of bad architecture Again, architectural choices he makes for the framework don't in anyway impact you using the framework. If you were to extend the framework, fork it, or work with it at a lowish level it might be an issue, but for the vast majority of people it's not something that they even bother looking at... how can it be hurting people who never even see it? &gt; static "facades" Oh boy, lets flog that dead horse. What's exactly wrong with it? the name? the pattern? the static? &gt; active record Nothing wrong with active record. It's not a solution for all things but there is nothing *in general* wrong with it when used appropriately &gt; etc etc so 2 dubious points about so called bad architecture. Ok great. &gt; He should hold himself to a higher standard and deserves the criticism. If you follow his stuff, he does hold himself to a fairly high standard. Deserves criticism? I dunno..show us your stuff and how much better you are and we'll decide if he is deserving of your criticism hey? &gt; Publishing something like that is a really bad idea. and yet people will use it to make piles of money. Terrible idea.. basically you are seeing everything in very black and white terms. It is bad because it violates SRP. It is bad because it uses AR, it is bad because of the use of static proxies.. the world simply *isn't* that black and white. The principles that you speak of, whilst valuable are not going to hold true in every single circumstance... **and they were never intended to**.
Building a thing that will include PHP configuration files with a higher-than-normal probability that they could contain syntax errors.
But you trust they aren't malicious, right? Because if you have any reason to suspect they're malicious... God help you, you're better off writing your own parser.
&gt; I'm sorry but you lost me. Everything that's not a pattern is an anti-pattern? &gt; Yes, that's kind of the point. A design pattern is a pattern commonly accepted as good practice when applied correctly. An anti-pattern is a misapplication of a design pattern, meaning by definition it's not the pattern it claims to be. I just wanted to clarify something to you. Your point is a very common misunderstanding of patterns. A "pattern" is in fact not a "commonly accepted good practice". It's just a pattern, upon which various forces have effect (negative and positive) depending on the rest of the code. In other words "having more patterns" does not equal "better code". Using a pattern is absolutely not a measure of "code goodness", and dropping the debate to such a primitive level is truly unfortunate. Go back and re-read the original GoF book, which lists only *some* of the patterns that *the authors have identified*. And notice they don't talk about patterns as "good practices", they just describe them, explain when they're suitable, when *they're not suitable*, what is their positive *and negative* effect on the codebase. It's not as black and white as you imagine. Engineering is about shades of gray. The list of popular patterns is neither automatically "good", nor is it exhaustive as to what constitutes a good practice. Unfortunately many folks try to simplify it and cast it into terms they'd understand: "patterns - always good; anti-patterns - always bad" and that's part of what makes our conversation here *more difficult* instead of easier. Instead of arguing techniques on **merit** you're arguing how close they align with popular patterns, i.e. your argument is dogmatic, and not on merit. Sure, patterns are part of our vocabulary it helps us communicate. But the thing about vocabulary is that it's always evolving. When you encounter something new which you have no word for, it doesn't mean *you ignore it* just because you have no word for it. Stop and think for a second what you're suggesting. So, no, something not being one of the dozen or two *popular* patterns **you** know about doesn't make it *an anti-pattern*. And again, dogmatic arguments like those may fly with a beginner, but it's utterly unconvincing to me. 
Perhaps [Couscous is good](http://couscous.io/).
How could it? Phalcon is a C based, pre-compiled PHP extension. You can't match its speed with pure php.
You forgot to select customers who have been with the bank for over 5 years.
So the issues I pointed out: - non-atomic updates - data corruption - pointless potentially massive transfer of data back and forth to the database (when it can be updated in-place) - potential out of memory errors - exploding a single update command into a giant *loop* of one-by-one update commands ...none of this matters. It only matters that your hand-picked example was intended to show ORM or no ORM is basically the same, ignoring **all of the above**. Ok, got it. Stay the course, never change. P.S.: "Smart minds did it so it's good" and "It's popular therefore it's good" are very poor arguments: - http://en.wikipedia.org/wiki/Argument_from_authority - http://en.wikipedia.org/wiki/Argumentum_ad_populum Every technology you don't like today was also yesterday's popular technology made by smart minds. Say, SQL was also created by smart minds, in fact much smarter minds than you'd find working on a PHP library, and is quite popular even today, yet you don't like to work with it, hiding it behind abstractions. How come? Try to think for yourself, and argue on merit, not using fallacies.
&gt; Now go back and re-re-read my example. I think you need to go back and re-read my assertion with the problems you're going to run into trying to inject a whole bunch of unrelated behavior via a single interface. Let's say you do need logging behavior in your Repository. With your example, you'll update the RepositoryContext interface to expose logging resolving behavior. That means that EVERY IMPLEMENTATION OF IT will need to implement logging resolving behavior else it will cause an error If you have a different Repository (for posts, or something) that DOESN'T need logging behavior, you have two choices: 1. Create a brand new interface that doesn't have logging behavior, and then either *duplicate* some implementations where connection and cache resolving are the same. 2. Just keep tacking on the needs of every repository onto one RepositoryContext interface, and force ALL of those implementations to keep changing whenever that RepositoryContext changes. Further, you need many more variations of your RepositoryContext to account for different implementations of just one dependency. It's like when inkjet printers used to combine all of their colors in the same cartridge. If one color runs out, you have to throw away the entire cartridge. In this case, if you want a different connection type, but your cache and logger remain the same, you need to create a new instance with duplicate cache and logger dependencies, but a different connection. And for EACH connection type you need. Neither of those two prospects are particularly appealing because you either add duplication, or your increase coupling. Your Repository object is simply not composable - you can't easily mix and match different implementations of its dependencies without creating a huge matrix of implementation variations. &gt; And I'm calling the Encapsulated Context an "Abstract Factory" firstly because it is one No it's not. Abstract factory is a totally different concept. This is not an "all squares are rectangles" thing. Abstract factory means something that creates variations of a class of objects, not something that service locates totally unrelated objects.
Oh boy, here we go again...
Good idea.
What I mean is that if someone is determined to sneak in malicious PHP, it'll probably happen. If that's a concern, you may want to step back and re-evaluate the whole project.
Ok for the fourth or fifth time (I lost count), the Repository defines the interface for RepositoryContext, so calling the methods on that interface can't possibly be qualified as "finding its dependencies". The repository writer most certainly knows the methods on the **interface they wrote themselves**. Do you even understand the words I'm writing here? You're claiming there's a fundamental difference between this: interface FooContext { function foo(); function bar(); } class Foo { function __construct(FooContext $ctx) {}} and this: class Foo { function __construct(Foo $foo, Bar $bar) {}} But the difference "in responsibility" is handwaved by you and not explained. Do you not comprehend it's basically a slightly different factoring of the very same concept?
&gt; Stay the course, never change. The funny part is you're the one who's entrenched, I'm open to new ideas, your argument is just not convincing at all. If you actually applied your ability to argue to the real world you might actually make a good difference.
You need to take the data from both queries and process it how you want it for your "view" (in this case the table). I created an example for you: http://pastebin.com/gmqmMDDS
You can't say "Factory" when you mean "Encapsulated Context". They are DIFFERENT patterns with DIFFERENT purposes applied to DIFFERENT problems. You yourself just said Car, CarPartsFactory, LeftSpeaker, RightSpeaker and Repository, RepositoryContext, Cache, Connection are fundamentally the same problem, yet you started off solving it with a misapplied factory pattern, and then switched to the encapsulated context. But the problem is the names you originally chose actually imply a different problem altogether. You're obviously not going to build a car with ONLY speakers. A Car is an implied large aggregate object, that will have many, MANY more than two dependencies. Further, given the original context of the discussion was abstract factories, the most obvious application of the abstract factory pattern is to create different kinds of cars, not to resolve totally different unrelated parts to make one type of car.... Meanwhile Repository really is not going to need more than Cache, Connection, and maybe Logger - a totally manageable number of dependencies which can be explicitly enumerated in the Repository's constructor signature. It's YOU who have confused this debate by flopping on your pattern names, and then flopping on the problem space you're trying to illustrate their application on...
For such a use case, I'd use plain php + some components, e.g. like fast route. 
I switched from "Car" to "Repository" precisely to avoid the kind of abstract bullshit arguments about what a Car class will have. You're still talking about Car though, because I suppose you find bullshit a more fertile ground for your argument. Once again, all I did was switch names from a "Car" to a more typical PHP problem: a Repository. You think this simple **name change** implies a different problem altogether, fine. It's your problem. You're sitting here arguing not about the *topology* and *merit* of the code, but about *names*. And arguments about names, while completely avoiding the substance of the conversation are completely pointless. You're also demonstrating inability to capture all concerns at once so I have to always remind you the same things over and over again. In this one I have to remind you, for example, that we want the dependencies to be created lazily. You forgot about that one. So no, constructor injection is not suitable again.
If you don't see how those two things are FUNDAMENTALLY different from one another, I don't know what to tell you :/ `class Foo { function __construct(Foo $foo, Bar $bar) {}}` $foo and $bar MUST ABSOLUTELY BE properly constructed $foo and $bar objects. There's no way they can be anything other than that, else PHP would fatal. `interface FooContext { function foo(); function bar(); } class Foo { function __construct(FooContext $ctx) {}}` The *only* thing that does is guarantee that Foo is going to be able to call `foo()` and `bar()` without throwing a fatal error, but what comes out of `foo()` and `bar()` is not at all guaranteed to be valid Foo and Bar objects. That will change when we have return type declarations in PHP 7, as you've said, but as *I'VE* said, FooContext still needs to know how make different kinds of foos() and bars(), which means more nested contexts, or more coupling. At any rate, I'm just going to be repeating the same arguments, because they all still apply.
There's nothing wrong with using SQL in an ORM, sure, except now your ORM cache is not aligned with your SQL database, so you're unknowingly working with stale data. Unless, of course you explicitly flush the cache, which means you need to be aware of three things: 1. The ORM layer and APIs. 2. The ORM caching layer inner workings and APIs. 3. You still need to know SQL for those "special cases". So now you still need to know SQL and the inner workings of two more layers of abstractions and juggle them together. Looks like using an ORM really made things simple, didn't it? I've seen codebases full of tens of thousands of lines of ORM code where every 50 lines account for one basic SQL operation. A witness to the resulting simplicity of using an ORM. 
Sigh. Would you at least have the courtesy to not **both** shut down the argument **and** misrepresent the code examples above? It's not "internal service location" when the context interface is designed for that specific class in mind, because there's nothing to locate. Just like you know the names of your **own constructor arguments**, you know the names of your **own context methods**. A context is in essence an alternative way of defining the constructor dependency arguments as a set of methods in an interface. *It's that stupid simple*. Get it? If you can't grasp the implications of this design and you're unable to see the difference between this and injecting a global locator, at least have the decency to not insult my intelligence and the intelligence of the other readers who'll stumble upon these comments.
Thanks! Will do!
Sounds about right. Pull in your favorite auth package. Edit: Lumen does pull in illuminate/auth, so personally I'll be seeing if I can roll with that.
...and will give you many more problems to keep you busy for many years to come. 
My advise would be to use generated JSON files instead, which can be syntax checked trivially on both the client and server, as well as being more globally useful than PHP files.
&gt; class JustONEWithDifferentBar extends XyzContext { &gt; /* override */ function bar() { ... } &gt; } Have fun testing that when you have 3 or 4 levels of inheritance to construct. Inheritance is by definition, tight coupling. That's why composable behavior is preferable to inheritable behavior most of the time (not always, but most of the time), and composition is best when you can independently inject different implementations of each behavior, DIRECTLY into the class that needs them. &gt; and makes code far more readable than a large list of positional constructor arguments would make it. If you have a large list of positional constructor arguments, that's a pretty clear sign your class is trying to do too much... it has too many responsibilities, and therefore too much coupling between its behaviors. In exceedingly rare cases should an object have so many dependencies that you need to inject a context object just to avoid a crazy constructor signature. And even then, I'd be perfectly happy with a crazy constructor signature as long as I used a factory or abstract factory to isolate that construction to one location.
Ok, genius, if I inject a mock context I don't *have* to follow the inheritance chain of the *real* context. I only implement the Context interface. That said the whole point of inheritance is I can override all the public and protected methods. So I'm having a lot of fun, even if in practice I rarely use inheritance for this (I use composition). I see all of this talk about interfaces and implementations is confusing you a lot, but trust me, it's very testable and all.
And you can't explain away the flaws of said tool as "misusing the tool". I have yet to see someone in a large project using "the tool properly". This is a sign that the problem is in the tool. The supposed magical balance of "proper ORM use" is always somewhere in the distance. 
I understand what u are saying but my tutorial is a CRASH COURSE at the BEGINNER LEVEL. I kept it simple intentionally. If you put everything about OOP in one tutorial you will lose the student.
I provide a downloadable zipfile if you want highlighting. You are right I could use constants for the DB connection. 
I think you greatly misunderstand the purpose of the FIG, and the PSR's in general. It is NOT intended to be some overarching elite standard that is imposed on the community - it is an agreement between *member* projects that they will communicate with each other according to specific contracts. The intention isn't to hand down a standard from on high. Sure, those standards may become useful outside of the scope of the FIG (PSR-0 and later 4, 1 and 2 clearly have) but thats not the intention. ~~The problem *is* well understood. Basically at the moment the de facto standard is guzzle. As I understand it PSR7 was born out of refining what guzzle did and codifying it so that options could be created. Clearly as soon as you start discussing something though, many voices come along and find problems that the original authors never saw coming. There is nothing particularly unique about this.~~ edit: er shit, my bad. For some reason I thought this was something I thought I'd heard about, codifying HTTP client interfaces..which makes my last paragraph basically wrong. The rest of the point still stands though I guess. 
&gt; And you can't explain away the flaws of said tool as "misusing the tool". Any 50-line ORM equivalent to a single SQL statement is either misuse or ignorance, neither of which would be a flaw of the tool. &gt; I have yet to see someone in a large project using "the tool properly". This is a sign that the problem is in the tool. Sorry to ding your ego here, but whether or not you've personally seen it used properly is not the litmus test for the worth of a tool.
Shame you're being downvoted, it's a fair question.
Strange, I've been looking at FastRoute recently and it's not as fast as it makes out. In fact their benchmark is a bit misleading - it only times the actual route matching, not the setup. You only match one route per request, not 100, so the setup ends up being 90% of the execution time.
There's an open [pull request](https://github.com/laravel/lumen-framework/pull/19) to fix this.
Because checking PHP for syntax by running the code is like using eval(), it may be evil ;-) PHP tokenizer will let you check your code syntax for errors, and without running its potentially dangerous payload. There was a function "php_check_syntax()", but it's been removed since PHP 5.0.4 (probably because it was evil). However, in the comments you can find [this code](http://php.net/manual/fr/function.php-check-syntax.php#87762) that uses the PHP tokenizer and scans for errors/warnings. 
Standards can sometimes stifle innovation, though without some agreement from the FIG member projects on at least a semi-formal level, it is unlikely that we'd get a fully baked middleware implementation that would work as expected. Having a standard interface to describe existing HTTP RFCs makes it possible for that implementation to emerge. The open questions here are almost entirely specific to PHP implementation errata and not drastic departures from the RFCs. Standards CAN change. Observe PSR-0 and PSR-4. 
The takeaway is that the PSR documents are meant to forge agreement between the FIG projects, but may also be generally useful. The autoloader standards turned out to be immensely useful to the community as a whole, and though my company uses a custom framework of our own design, we find it very useful to refer to these standards as road signs to guide our implementations, though we will never need to interoperate with other frameworks. If a fully baked middleware implementation does form from this, we could be in a position to use some of those modules if our framework implements the interface. 
A third one is that your browser won't cache ANYTHING, not even huge images. 
Lumen excites me, I couldn't get my head around Laravel so opted for Silex. Does Lumen use the Blade template system or will I continue to use Twig? I cannot locate this info in the docs.
Ah, turns out I didn't look too hard... http://lumen.laravel.com/docs/templates 
See it like this: You don't put Mac OSX on a microcontroller (i.e. Arduino) that is just used to read data from one sensor and nothing else. For certain tasks or micro-services, it's a waste of resources to use a full-stack framework. For this reason micro-frameworks like Silex, Slim (and now Lumen) exist. I'm not sure if it's Taylors job to explain why there are fullstack-frameworks and micro-frameworks. He does, however, [explain](https://laravel-news.com/2015/04/lumen/) how he needed to use Silex and Slim for Envoyer and how that gave him the idea to create Lumen. &gt; how does this fit in with my current Laravel website You could use it as a [fast caching layer](https://mattstauffer.co/blog/introducing-lumen-from-laravel), or to build an API for your Laravel app, by using you Laravel app [as a git submodule](http://blog.enge.me/post/building-an-api-for-your-laravel-application-with-lumen) in the Lumen API. 
You should escape the file name with [escapeshellarg](http://php.net/escapeshellarg).
I've began teaching some beginners (10-15 years old) a simple login/register system. They seem to be very impressed on how PHP sessions work and how MySQL can store data. May not be the most suitable to your friends it all depends on their age and interest.
&gt; Because checking PHP for syntax by running the code is like using eval(), it may be evil ;-) This isn't what is being done though - they're calling PHP's built in linter on the file (called with 'php -l $yourfile') via exec. As far as I can tell, other than /u/jworboys note about checking the exit code this looks pretty much solid to me.
Just found [this](https://github.com/composer/composer/pull/3904) PR for composer. It would be awesome to have this native in Composer!
It depends on the needs really, JSON or similar formats are not always the best tool for every job ([for example](http://php-di.org/news/06-php-di-4-0-new-definitions.html)).
Advantages of using an ORM: * It's agnostic. You map your entire model using PHP, and it'll work for MySQL, PostgreSQL or whatever other database vendor you choose (as long as PDO supports it). If you need to switch your database vendor later on, you don't have to rewrite your entire application fixing queries and whatnot. * If you use Doctrine Migrations, you'll centralize all your modelling to your application. No more changing things in the database and then correcting queries in your app. Just change the app and run a `orm:schema-tool:update` to sync your changes to your database. * If you do things right, there is a good chance you'll be able to refactor your data model without having to rewrite all the queries in your application. * It's just less code to write. $article-&gt;getComments() is far more readable then "SELECT comment.* FROM comment WHERE article_id = :articleId" , fetching the result into an array and then accessing the array keys. Suppose now you have comments in response to other comments. See the snippet below: $article = $em-&gt;getRepository("app:Article")-&gt;find(1); $comments = $article-&gt;getComments(); foreach ($comments as $comment) { $children = $comment-&gt;getChildComments(); ... } Rewrite this same snippet using PDO directly. You'll write multiple queries, and will iterate over and over. The previous snippet is far more readable. If performance is a non-issue and you'd like to focus on maintenability, an ORM is a great tool. It makes your code much more readable and easier to maintain. If you are still sensitive to performance, there are a lot of ways to optimize how things work in the ORM.
You don't think that crosses a boundary? My business logic is in my domain layer, should my domain layer be talking to classes that are essentially part of the presentation layer? I'd be interested to see how you would abstract the view logic out :)
Thanks for the insight, I guess I've read the gist too fast ;-)
Here are my results, OPcache enabled, new MBP 2.5ghz ab -n 10,000 -c 5 #Laravel 5: Hello, World. http://pastebin.com/qp4N8AZy (~140 r/sec) #Lumen: Hello, World. http://pastebin.com/Ji5dHA3j (~3100 r/sec) I ran each test several times to prime the cache Lumen is apparently rather fucking fast. I could probably get more performance out of Laravel 5 by tweaking my OPCache settings to store more data.
I love that you're being downvoted for this. The PSR standards are being popped out because, in PHP, people want to turn 1 hit wonders into enterprises. 
I have four containers that make up my appliance. Its nice cause i can version tag my images use my ci to build that utilizes sh scripts and go straight into testing. It also makes it super easy to deploy.
The way I do it is create your own model class: &lt;?php namespace App\Libraries; /** * ------------------------------------ * VENDOR CLASSES WE'LL BE USING * ------------------------------------ */ use Illuminate\Database\Eloquent\Model as BaseModel; /** * ILLUMINATE DB MODEL WRAPPER */ class Model extends BaseModel { /** * Disable timestamps by default because they're enabled by default */ public $timestamps = false; } Then you can import your own class in your project. class Article extends Model { public $timestamps = true; } $article = Article::where('id', 10)-&gt;first();
http://laravel.com/docs/5.0/eloquent
Why do you need a cms?
Sounds like you're sending stuff that should be a POST as a GET. You really shouldn't have 1,000+ character query strings.
We used [Slate](https://github.com/tripit/slate). But its written in ruby and we needed something for our PHP project in order to accommodate a more dynamically generated doc. So we switched to just using [ParseDown](http://parsedown.org/). We were able to replicate 100% the output of Slate using ParseDown*. Edit: Using the Markdown Extra extension.
idea #1: have your phone call you during an awkward situation :D best idea ever! idea #2: I think I might need to learn that myself XD never done C# tbh 
I agree, but there were some 3rd party packages for Laravel that really piqued my interest, but they had some ajax calls that were ~1500 characters long (and thus breaking).
Agree - and you can build updates to documentation into CI / build / deploy processes to automatically keep your documentation up-to-date with the latest codebase.
&gt; I just want to call out some special attention to dependency injection containers and service location, in that some people still think that dependency injection containers are service locators. This is false. Service location is not a thing, it's something you do. I agree. And for that reason I think we should try to stop using the term "dependency injection container", because just like service locator, "dependency injection" describes our *usage* of the container, rather than describing the container itself. So if the exact same implementation can be described as either a DI container or a SL depending on usage, then what describes the implementation itself, regardless of its usage? "Service Container" seems like a reasonable choice, and it's also an established term.
Thanks for the help, guys! I figured it eventually. Missing out some on the docs but still a great release. After 5 hours of work I'm soon finished with a prototype of a project of mine.
I had something like that happen. Most calls were very simple, maybe 20-30 characters, but then occasionally I would see a query string that was thousands. I had to re-write the package to use POST instead of GET and it solved all my problems, but it did take some time to track it down and write the code to get it done. If you do make the changes, make a pull request for the package. You are probably not the only one experiencing the issue and others will likely thank you in the future for fixing that issue.
Jekyll http://jekyllrb.com/ It uses a flatfile markdown based data set organized like posts, and uses Ruby's Liquid Template Engine (developed by Shopify) and lets you compile out a flat html site based on all the data. It's perfect for distributable documentation for any software and really simple blogs For everything else, there's DokuWiki (PHP) or Confluence (Java)
I'd assume it's because the built in server isn't intended for production, meaning it's not battle tested. It's not fully featured. It hasn't been audited for security, hasn't been performance tested. etc. Why not just use nginx instead of putting it in front of php-server? 
Oh of course, standard practice stuff. I'm jsut curious, as more and more technologies out there go that route (Ruby, Node, etc) PHP is just one of the very few that can be run directly via an Nginx server block or Apache VirtualServer. I'm just wondering if PHP might be going the same way down the road in terms of deployment possibilities 
It may be in certain FCGI installs, but it's not suitable if you get anything but very light traffic.
So something like apache will have multiple "php engines" waiting for a connection, and when it gets one it routes it to a "php engine" that will handle the request and then will go back to waiting. For example, apache could open 5 "php engines". If 2 requests come in at the same time engines 1 and 2 take care of them, then when they are done they go back to waiting. If 7 requests come in at the same time, the first 5 will be handled, but the last few will either wait until one of the first 5 are done, or apache will create some new "php engines" in order to handle the extra load.
I don't need to check it on the client. :)
&gt; PSR-7 being massively overhauled That's a bit of an overstatement.
&gt; It constantly feels like people don't pay attention to proposals until voting time. That's *exactly* what happens. Having said that, and given the history of more than half of the accepted PSRs, this is the normal course. (For good or ill.) 
Been reading up a bit on it and if you set caching headers properly browsers will cache assets you hand them over HTTPS.
&gt; I keep reading "X is not a DI container, it's a service locator" (replace X with Pimple or whatever). /me nods Even so, some implementations lend themselves more to being used as a Service Locator. If the overwhelming number of examples show something like `function () use ($x)` then it's a good bet the authors intend it for `$x` to be understood as and used as a Service Locator. c.f. [Quicker, Easier, More Seductive: Names, Usage, and Intent](http://paul-m-jones.com/archives/5853)
As a launch partner for some of these features, I'm looking forward to see how some of the SDKs have matured.
The first and fourth points resonate the most with me. I can see where this is ideal for large applications. I have used frameworks before, but we didn't come across the need to switch databases mid-development. However, an ORM library could help mediate the connections during a switch I would guess. Also, I don't see any need for a WordPress user to implement it, as it's made for the xAMP stack by design, but I did find this library: [WP-ORM](https://github.com/brandonwamboldt/wp-orm) It replaces the default WordPress model so you don't have to write all your queries in the native query language.
Integrating Doctrine (or Eloquent for that matter) with a ready-to-use CMS or even with WP would be a pain in the ass. I wouldn't advice for it. WP installs usually go for MySQL, as there is seldom a **need** for other vendors. I don't see why someone would use, for example, Oracle in a blogging system. In a full-stack application (not just a blog or a simple CMS), you would be underestimating the time-saving feature that are points 2 and 3. Not having to switch between code-context and database-context is a huge time saver. Just code, never model. Also, refactoring things are much easier with an ORM. Also, unit testing is easier if you can abstract your data model from queries to objects, which tend to give your project more stability. I feel like ORM's are more appropriate for applications rather than 'websites'. Things that need to be modular, that must scale in functionality, that are going to have teams working on, etc. It's much harder to scale things (in funcionality!) writing native queries and modelling by-hand.
&gt; I feel like ORM's are more appropriate for applications rather than 'websites'. Things that need to be modular, that must scale in functionality, that are going to have teams working on, etc. Ah, yep. You can't really get that in most mom-and-pop web design agencies. I wish agency work were more interesting :'(
/r/dailyprogrammer
&gt; because it's only useful to PHP, and encourages the bad practice of conflating code with configuration What about when you are configuring PHP code? ;)
Thank you!
Thank you . Feel free to reach out to me if you have any questions on the SDK
Yes, even when you're configuring PHP code. There are just no reasonable benefits in using PHP as a configuration format over alternatives like INI, JSON, etc.
It'd be different in efficiency and actual features. Some of the beneficial features that FPM provides are listed on the PHP manual: http://php.net/manual/en/install.fpm.php
Is it faster to include a PHP array than read a file's contents and deserialize? Sounds like it might be. Perhaps less so for JSON vs INI or YAML. I worry about phrases like "no reasonable benefits" though. I think it's better to judge for each situation what is and isn't a reasonable benefit. In terms of the thing I'm building - configuration files [in the the existing application] are a mixture of YAML and PHP. And horribly fragmented. So a reasonable benefit of using PHP configuration files is that the same developers use them (and understand them) and loading them is significantly faster. It makes no sense to add JSON as a third format, when what I am trying to do is simplify and make efficient a complex and inefficient system.
Is this video on a seriously slow server? 
I made some PHP coding challenges a while back: https://github.com/wearebase/base-php-challenges They're not great but might keep you entertained for a few minutes :-)
&gt; Is it faster to include a PHP array than read a file's contents and deserialize? Sounds like it might be. Perhaps less so for JSON vs INI or YAML. Nope. INI is faster than JSON, which is faster than PHP (YAML will depend on your chosen implementation). However, the numbers are so small in all cases, that consideration of them is a micro-optimization, so this should have no bearing on your decision. &gt; So a reasonable benefit of using PHP configuration files is that the same developers use them (and understand them) [...] There is no legitimate risk of those developers not understanding the same configuration expressed in JSON, as data-driven JSON and PHP configuration are virtually identical. &gt; [...] and loading them is significantly faster. Loading PHP is not significantly faster than JSON, if that's what you meant here. &gt; It makes no sense to add JSON as a third format, when what I am trying to do is simplify and make efficient a complex and inefficient system. I agree here, for the simple fact that consistency is king. If you don't intend on replacing your existing configuration formats, then it would indeed make the most sense to go with one of PHP or YAML instead, just to remain consistent.
The file you pass in could contain dangerous code, since you're using eval() it would run it without question.... DeleteAllFiles.php is valid.
www.codewars.com
I guess it depends on the complexity of the project. And I guess I don't build too complex of projects cause I usually just map it out in my head. :(
To avoid burying the lede, let me first emphasize this: **Do not use the built-in `php -s` server in production. Ever.** The reason is simple: the built-in server *does not support HTTP/1.1*. It MUST close the client's TCP connection after each and every response. Establishing the TCP connection is by far the slowest most costly part of an HTTP request. HTTP/1.0 is an extremely simple, non-performant way to process client requests if you're a server and supporting the full suite of HTTP/1.1 functionality is significantly more complicated. You cannot realistically put an HTTP/1.0 server into production. It would be like taking a bicycle out on the autobahn. &gt; But what if you hide 4-8 of those behind nginx as reverse proxy? How would it be different from php-fpm? This is totally unfeasible for the reason listed above: every time a request came in to your front-facing nginx server the load balancer would have to establish a new connection to one of your backend servers (because those servers close the connection after every request). It would be *monumentally* inefficient compared to using a real server. &gt; The built in server is single threaded which means it can only process one request at a time. This is not true. Node.js uses a single-threaded architecture. Thread availability has no bearing on how many client socket connections can be serviced concurrently in a server. &gt; single threaded works for node because it can do a lot of things async like database and httprequests etc. which frees the thread to process multiple requests. The same capabilities are available in any single-threaded language that exposes a method to poll sockets for readability/writability. PHP as a language has the same capabilities. The *PHP web SAPI* is a specific API that hooks into web servers and fires up a new thread/process to handle each individual HTTP request received by said server. It's entirely possible to write a massively concurrent single-threaded userland HTTP server using the same principles employed by node.js. 
I think that's exactly right. Use Laravel for your "more advanced" applications. I think Lumen is suited for small things like API's. If you require all of the things that Laravel serves up, like Eloquent, user authentication, events, etc, then the logical step is to use Laravel. If your application is going to be small and not process much but you want to expand at a later date, use Lumen. You can upgrade from Lumen to Laravel when and if you need to, then utilize all that Laravel has to offer. I'm interested to see the comparison of Lumen vs Laravel. Don't make your life difficult over shaving a couple of micro-seconds off of your load time if you know you're going to need Laravels features :D
When Amazon fails, hopefully Google comes to the rescue: https://www.youtube.com/watch?v=K0-Fx5l9nGc
newrelic, logentries and a local monit daemon to respawn services if needed.
My understanding was that the built in server is single threaded and can't handle more than one request simultaneously. It's designed for devel testing only. Putting it in production would cause all sorts of unknown errors.
Small detail, but why create a custom autoloader when you can either use composer's autoloader (which seems to already be configured in `composer.json`) or just `require_once` your 3 classes?
I don't have a good answer to your question, other than I didn't think that part through. (As far as the 3 classes go, I will probably have more as features are added.)
Isn't comparing Pharaohs (measured in symbolic ostrich feathers) actually Anubis's job? Well, perhaps not, if their "deaths" were actually a separate fast-track to godhood.
Thank you! How about posting them on youtube so people will still be able to enjoy them later on?
Short descriptions of the talks: https://fosdem.org/2015/schedule/track/php_and_friends/
I prefer a PHP solution
yes, i'm agree... I do not know why they are not...?
Nope sadly. But once they do i will be trying them out.
The marketing is strong with this one. Third post in 24 hours. http://www.reddit.com/r/PHP/comments/32kajb/lumen_php_microframework_by_laravel/ http://www.reddit.com/r/PHP/comments/32kbal/an_introduction_into_laravels_lumen_with_a_simple/
In the [first post you linked to](http://www.reddit.com/r/PHP/comments/32kajb/lumen_php_microframework_by_laravel/), a lot of people were confused about the differences between Lumen and Laravel, and when to use which. So I'd thought to write a post to clear things up.
Hey /u/Ikarasv, I'm sure you don't want to hear this, but why not just do exactly what your computer class tasked you with and write one? I'm sure it doesn't have to be perfect or secure. Just read up on PDO or mysqli on how to read and write stuff from mysql.
The website is down :/
I really like this, and gave me some ideas, thanks! One of my problems is I get all of these ideas that I might even write down but yet when it comes down to implementing them I do get overloaded and stressed about it. So incorporating a lot of this will help me in the long run.
If you want to write here a few ideas you have, maybe we can help you out with the first steps. I can't stress enough how awesome it is to work on side projects, you learn so much! For starters you would learn how to deal with "starting a new project with plenty of ideas" ;) So don't stop there.
Haha, well thanks. :) Guess this is more of a 2-in-1 solution (Android + PHP). But, with me going to the gym, I notice there's no real easy way to track my progress (or I just tell myself this because I want to program it hah). Basically I would like to track how many reps I do on a machine, how long I do the treadmill for (+ speed, incline, etc...). This is more or less PHP side. Android side would be to create a timer app that I set for how long my rest should be before I get going to something else. This wouldn't be horrible. Basically the PHP side would more or less be an API of sorts to take in and spit out data, while the Android app would be the meat of it all. There's other projects but I feel this would also keep me motivated to go to the gym as I'll need to do that to test most of the functionality of the app.
Seen this before but never really ventured through it, thanks for the link. :)
You are, of course, correct. In the future, this is going to be much more interactive. Listing the SHA256 and BLAKE2b hashes of every file, showing the ones that differ, then letting the user see the differences in files of interest. What I posted here is just a MVP.
Don't forget that the Phar file also contains an executable header. So it may be possible for an attacker to construct a malicious phar that extracts to the same as a normal phar would, but behaves differently when included/executed.
Anyone have any idea what information the "Secondary Skills Distribution" 'chart' is meant to be showing? I read it as zero node.js people know MySQL, but that looks to be a nonsensical interpretation.
We're verifying the integrity of the Phar in the face of APT attackers that intend to trojan the Phar and infect PHP developers. That is our threat model
They're comparing node.js (a runtime/platform) with PHP (a language) here. Seeing Javascript listed as a secondary skill for node.js devs is a bit confusing.
You make good points, but this part stuck out at me a little bit: &gt; PHP is literally hundreds of times slower than Java/C. Do you have a source for the "hundreds of times" claim? Java seems to average [28x faster](http://benchmarksgame.alioth.debian.org/u32/compare.php?lang=php&amp;lang2=java) (reaching as high as 42x). C seems to average [43x faster](http://benchmarksgame.alioth.debian.org/u32/compare.php?lang=php&amp;lang2=gcc) (reaching as high as 91x). Even when you start comparing non-blocking architectures, ReactPHP was only [60x](http://reviewsignal.com/blog/2013/11/13/benchmarking-asyncronous-php-vs-nodejs-properly/) slower compared to Node. 
I nearly said "There's a not real Phil" but then I read the post, I'm not sure how I missed that on here, whoops
https://projecteuler.net/
i've done a lot of personal side projects in the past, sold a couple and am working in an agile environment full-time, which helped me a lot drafting my own ideas. Basically everything starts in my notebook, pen (getting a good one is important) &amp; paper (moleskine), where i write down all of my ideas. when i'm quite confident that an idea is "the next big thing", i write down all the required functions (like login, logout, user management, etc) the project needs. as soon as i've all features needed i switch from pen &amp; paper to my personal gitlab, where i create a milestone &amp; associated issues which describe my function/feature. the next step is to break the features into smaller pieces/issues (a login-feature needs e.g. a login form, a login-controller, etc) and then start working on the smaller pieces until i've completed the whole feature/parent issue. i'm basically writing my own user-stories. gitlab has a nice milestone-gui where you have a "board" (if you know JIRA, you might know what i mean) with "Unstarted Issues (open and unassigned)", "Ongoing Issues (open and assigned)" and "Completed Issues (closed)". this works quite well for me, because i can stop working on a project for 1 or 2 weeks and when i come back, i know exactly where i left off. my personal rule is to only commit code which references only ONE issue, so i've a clean git-history and know exactly later which commit contains which feature. gitlab makes it quite easy to keep track of that, because if an issue number gets mentioned in a commit message, it'll automatically show this in the issue-ticket. if you're curious how it looks, here's an example from a project i'm currently working on: http://i.imgur.com/isz2ep4.png i'm sorry that i had to black out some stuff, but the name of the project and the issues are in a foreign language anyways, its just an example to get the idea of the structure. that might not be the best workflow, but it works for me and i'm curious too, how other people are doing it.
&gt; Use whichever you like more Hint: good crypto has nothing to do with personal preference.
The use of cryptography should not be predicated on personal preference. I don't "like" BLAKE2 more than MD5, it's significantly more secure (and also, faster) and a better choice when a hash function is appropriate. A hash function does not solve the problem I am attempting to solve with Pharaoh.
&gt; exactly, so checksum it. Checksums do nothing. You'd need to sign it with a public key. However, what if the attacker is the core developer? They sign the compromised package. Without a tool like this it would be pretty hard to detect. Instead, with this tool you can audit the source and build your own phar, then compare them (detecting underlying issues in the packaged code).
Yes, that's what it was *designed for*. And it was broken. Quite a while ago.
The framework stuff is almost irrelevant. It's all the plumbing on the actual API that will take time to do. I would recommend using [Apigility](https://apigility.org/) (which is built on top of Zend) to get stuff working _correctly_ and quickly. So long as you're careful to separate the actual data handling bits from being dependent on Zend, once you've got the API built you could then decide to move away to a lighter framework if you really wanted to. Recreating the plumbing that Apigility gives you for almost free is probably a couple of months work. 
I would strongly disagree with that (upvoted by the way). Sure, there's disagreement as to what REST is, but the basic framework for communication is there. Ruby on Rails, Angular JS, Backbone, Knockout, ASP.NET MVC and SailsJS are just a couple that implement REST. These all plug and play very easily, which would not be possible if they did not agree on the basic structure of REST.
I think it's what their users fill in as their skill set preference when looking to match for a job. 
So zero PHP devs know angular.js, and zero node.js devs know MySQL?
Here's a decent explanation. http://www.restapitutorial.com/lessons/httpmethods.html 
No, I think zero PHP devs set angular as their second skill set, and similar for node devs with mysql. And I think the distribution graph is sort of normalized-biased or something, it doesn't mean zero for any categories. Because CSS would contradict the Most Common pie diagram. Of course, all of this is only guesswork on my part, so I could be wrong. But that's what makes most sense to me
I'm a fan of [slim](http://www.slimframework.com).
http://www.phpgolf.org/
Actually I just took a look at the code. It also doesn't check for the executable header. In fact it relies on this to do the diffs: echo `git diff --no-index $argA $argB`;
https://github.com/paragonie/pharaoh/issues/1
This is even better than the first suggestion. Thanks a ton! 
Amen.
The more I think about it, maybe I should have posted this to r/mysql
I just built a REST API for my company and a book that really helped me along the way was [Build APIs You Won't Hate](https://leanpub.com/build-apis-you-wont-hate). 
I agree that Zend is probably overkill for your purposes. If you're just looking for REST support, Slim and Flight both work great. Alternatively, if you're building your front end with JS MVC and there's not much logic that needs to be performed on the back end, you may want to look into Firebase: it offers REST, user authentication and management, and WebSocket support out of the box. If you happen to be using Angular as your JS framework, it only takes three lines of code to sync a Firebase object with a scope object that will automatically reflect changes in real time (I assume support is also good for other major frameworks, but I can't say from experience). 
PHP7 has relatively minor BC breaks and not the kind where you'd have to choose "either PHP5.x or PHP7" in terms of code support. So the obvious choice is "support both" as soon as it's out, and for the next 1-2 years. I plan to start testing as soon as PHP7 betas hit the streets and I expect to have very little to change. I feel PHP7 will be adopted much more quickly than PHP5 because, again, unlike PHP5, which changed the fundamental nature of objects, PHP7 seems relatively minor as an upgrade (although it's packed with cool new features and improvements, particularly under the hood). P.S.: For reference, all my existing projects run on 5.4+ and new projects started in last 2 months are 5.6+, if that helps measure my PoV on support.
LOL! You've now read more of that article than I have. Here I am thinking you were actually wanting a simple definition like you asked for. Instead, you're just starting an argument. Later.
I used ~~Slim~~Silex in production work. Use Silex if Zend framework is your other choice, because Zend does have overhead and too much coupling. My issue with Silex is that although being a micro framework it's coupled too much to it's daddy Symfony to the point it does limit me too much. I currently use [AuraPHP](http://auraphp.com/), _it's not a framework_, instead it's a set of components that can be glued into one using a DI container (similar to what Silex does) and [ADR](https://github.com/pmjones/adr). I really like the way the configuration happens in this one with classes. Didn't use that my self, but like /u/SurgioClemente suggested, [Lumen](http://lumen.laravel.com/) looks nice too - fits into same kind of frameworks with small overhead and less decoupled architecture.
I was under the illusion you want to know what you're asking about :) I guess not, that's ok. P.S.: I implement HTTP services on PHP and Java for a living. If there was anything a REST framework could do for me I'd know.
Yes recommend a framework nobody has even tried in production yet. Fanboyism at its best...seriously guys. Why not e.g. Slim in this case or Silex or whatever? Hop on the bandwagon ? 
The creator is already using it in production for Forge.
It does seem rate limiting middleware would be a great feature to have out of the box.
Yeah that would be pretty nice
My stance is this: - With a specific project, you know which version it runs on. Forget about older versions of PHP and try your best to make it forward-compatible, so server upgrades are as pain-free as possible. - With a library or some project that other people install on server, like WP, support all released versions of PHP. As of right now, that means 5.4, 5.5, and 5.6. - It would also mean making sure that the project works against the PHP nightlies as best as you can, so the next version of PHP (7.0 in this case) is supported as soon as it becomes an official release. - For versions of PHP that have reached EOL, drop support. Maybe hang onto it for a grace period of up to a year after to help people migrate off, but I think anything longer than that is simply enabling them to stay on old versions of PHP, which in the end _decreases_ security.
You're the one who used the term "nobody".
I'm digging [Dream Factory](https://www.dreamfactory.com) for some recent projects.
&gt; with Slim is that although being a micro framework it's coupled too much to it's daddy Symfony to the point it does limit me too much. Are you talking about Silex?
Why not? It is built on top of Composer.
Yes, sorry. fixed it.
It may not work as OOTB as Laravel but you **must** be able to register your own services
This has been true with most of the apis I've built in the past, but its hard to judge as I never end up using 100% of a framework, and how long would it take to recreate the parts you need is speculative at best. I know Zend comes with a ton of stuff, but its also one of the slower options out there.
Its been awhile since I've been in PHP land. Composer is a package manager? Is this related to Symfony or is that just a coincidence?
I'm interested to see what happens once PHP 7 is released. If its speed is on par or better than HHVM, I wonder if adopters of HHVM will switch back.
Personally, I'm very excited to see what PHP 7 brings. I'd wait and see exactly what the differences and tradeoffs are once the product crystallizes a bit more before deciding to switch back to it, though. One of the big things that HHVM has that PHP 7 won't is support for the [Hack](http://hacklang.org/) language. Facebook has shown that they are committed to maintaining Hack with the community for the long haul, and I feel like it's an incredibly attractive alternative language for PHP developers who pine for a type checking system and a little bit more static analysis, as well as builtin async functionality. That said, I'm sure PHP 7 has some exciting features to offer that will be worth visiting. We'll just have to wait and see!
It's simple, small, works, doesn't intrude on the architecture of my applications, handles grouped routes and dependency injection well. I can't say how well it works with templating since I've just used it for APIs.
I'd recommend using [Proton]( https://github.com/alexbilbie/Proton) for just about anything, API or other web app.
ZendFramework is already building and testing against the PHP 7 nightly releases https://travis-ci.org/zendframework/zf2/jobs/56243871 Annoyingly it seems the current nightly build is segfaulting on Travis for their tests. The exact strategy you should take depends on how much stuff breaks in 7 for you. For a lot of projects that are already using 5.4+ code everywhere and have a small number of class names that are now disallowed (e.g. Object, Int, String, Resource), moving to 7 would be a few days work. For projects that have either more stuff to fix, or a more distributed ecosystem where there needs to be more time to allow plugins to be upgraded as well then it would be a bigger job. &gt; This assumes that the release happens on schedule in October. For posterity, my guess is the release is February. 
Here's the meta issue for what has been going on with Drupal 8 and PHP 7 - https://www.drupal.org/node/2454439. I haven't been actively following Drupal core development, but it looks like the goal was passing unit tests, renaming some typed classes so they don't conflict with reserved words in PHP 7.
&gt; I know Zend comes with a ton of stuff, but its also one of the slower options out there. Yes. But you can (and possibly should) use Apigility as a prototyping tool. It will allow you to build all of the api in a conformant way first, and then if you've got enough time at the end of the project to refactor stuff to make it faster you can. If you don't have time, then you're left with a slow but working API. This is far superior to having a fast, but incomplete/non-conformant API.
Why are you thinking 7 will get delayed until February?
One site = nobody.
I guess because they planned the upgrade to HHVM some time ago so they didn't bother with 5.5 to save effort. Big companies like that have inertia.
I have seen a talk of ~~a Box founder~~ (maybe it was a CTO) and the main thing they were interested in at the time was Hack's features, so it's probably not just the performances. Once tooling (PhpStorm) and OS X support will follow (hopefully this year), Hack will become more and more attractive.
I don't understand the down votes.
Because I'm a ~~cynical bastard~~ experienced developer? The core developers, have been working really quite hard since the start of the year. It's going to be hard to keep even the current pace of work up. There's been a large number of changed internally, not all of which have been merged/completed yet. Some of the bugs that have been found recently in the git master are typical of software that is solid on the surface, but doesn't have nearly enough unit tests in place. Although the issues are being fixed fast, I think the October deadline will slip, and that releasing software in December is not a good idea, as people are generally unavailable over Christmas, as if people need to fix critical bugs and they are not available. Oh, and another prediction; Zend the company will be putting out a huge amount of pressure to get it shipped no matter what, as they've already started their marketing spend. 
* Job's that don't require unit testing. * Job's that don't care that the testing is painful. * Job's that do test, but test against the database (i.e. slow, just ask the Rails folks).
Personal interaction with the team. There's a fairly active community of people contributing to the project now, and they keep themselves relatively available via IRC and other means. At Box (clarification: I'm OP from the blog post), we've engaged in conversations with them about Hack pretty extensively, and they've done everything they can to help us migrate over. Things like the hackificator, FBIDE (which should be released soon-ish and with full Hacklang support), and the fact that the community and something like ~2million lines of code are now invested in the language, I feel comfortable enough with it. I don't mean to give this as any hard and fast proof that they are committed, but I put my good faith in them for the amount of work they've done to get us on board and make sure we're clear on their roadmap with the language, as well as the reasons they are committed to maintaining the project
Thanks for the response! I imagine being up close and in contact with the team on a regular basis would give you a much better feel for the direction they're going and their dedication.
Lumen is not just a lighter version of Laravel, it is also less configurable, hence the reduction in flexibility. Even the website and the author have said it was designed for micro services and APIs. Of course you can build a website from it, but you'll end up reinventing the wheel recreating the features found in Laravel anyways. So yes you can, but you should use the right tools for the right job.
&gt; See it like this: You don't put Mac OSX on a microcontroller (i.e. Arduino) that is just used to read data from one sensor and nothing else. &gt; Isn't it just a wp template? 
It's less configurable because there's less to configure. It's not like Taylor made some decision in stone and said THOU SHALT NOT CONFIGURE THIS. If you added some Laravel component back in that isn't in the base microframework, you could configure it as much as you like. In any case, there's no real need to argue semantics! I'd choose a microframework over a full-stack framework every day of the week, because I don't want to have to unmake all the decisions that a huge framework made in the interest of rapid development, and I don't want the added weight of components that I'll never use.
They forgot a commit of mine that made it in, in the changelog. `json_decode(' true');` no longer errors.
We are, indeed, looking at Hack as a potential way forward for our PHP application, for the reasons you specified. Anyone who is considering Hack should know that it's definitely not meant to help boost performance further - if anything, you may actually take a very slight hit to performance - but rather, it gives you a much richer feature set to write code with. A much more expressive type syntax, type checker, and native asynchronous execution functionality are all HUGE draws to the HHVM/Hack platform. We are anxiously awaiting either the release of FBIDE from Facebook or PHPStorm 9 from JetBrains, which will include full Hack support! Unfortunately, last time I checked the EAP edition of IntelliJ/PHPStorm does not currently have Hack support, but we've already begun toying around with it internally to see how it feels. Also probably worth calling out - Hack may not be "forever" for us either. Our medium-term objective is to get the bulk of our application, which is in PHP, into a language that lends itself to greater developer agility and safety. I believe that Hack is the most feasible migration that we can do in the near-ish term, and long term we are trying to strip out parts of the application into smaller services and technologies that make sense for that domain. Hack seemingly provides an *excellent* way of making a gradual migration to a more type safe infrastructure without interrupting day-to-day operations too much. From there, we can consider moving some things to Scala, Go, etc.
Haha. Beautiful. 
As the OP pointed out already. It doesnt matter if PHP 7 has similar benchmarks. It's about CPU load, latency, hack and other things hack brings to the table. When you start to do huge complex projects, you start to experience a lot of things outside of a smallish project. You need other mechanisms to help you cope. Don't forget. HHVM will try to retain parity with PHP. PHP cannot vice-versa. See, there is a voting process and internal struggles. All of which HHVM/Hacklang is not hampered with. The big guys are starting to move over, etsy, wikipedia, baidu, etc. I very much doubt they will move over to 7. I've moved over to HHVM and I won't be going back. Next week will see HHVM at 3.7. By the time PHP 7 is out. You may very well see HHVM 4.0.
Elasticsearch sucks because Phil can't use it. =p
&gt; It also doesn't check for the executable header. This was fixed in version 0.2.0, which I released a short time ago. &gt; In fact it relies on this to do the diffs For now. I may keep it that way; I may roll my own implementation instead of relying on shell arguments. (I'll probably do the latter.)
Not a free solution, but check out OpsGenie and HeartBeats. Works similar to a watchdog timer if you're familar with that concept where something will reset the timer every so often. If the timer runs out, it will send out a page. I don't think if this is possible: Enable the heartbeat for your particular program via their API when the program starts, start a timer in the background in the backround which pings Opsgenie every 5 minutes, and disable the heartbeat when you're done. Otherwise, you'll have to fiddle around with find the right heartbeat period and how often the program should send the ping. https://www.opsgenie.com/heartbeatsplus
There are multiple solutions to this, depending on how intricate you need to go. First, it's helpful to be using something like supervisord to manage the jobs on your cron box. It will allow you to have keep alive parameters, max and min run time, and able to spawn and kill php processes as needed. Alternatively, you can run your own custom shell script that monitors the jobs, and will allow you to send in a PID and it will kill it if past X minutes running. Additionally, perhaps you want to look into job queuing. Something like RabbitMQ, Beanstalkd or one of the many other simple queuing/job managers. It will allow you to handle jobs an ordered manner, which may or may not help you with jobs running before they should. Also, in your command loops, you might want to check available memory and average execution time before/after large loops execute. When you are nearing memory limits that you define you can kill and respawn jobs (perhaps calling a system script). Furthermore, it's nice if your jobs are able to be build gracefully enough, that if you kill them mid-way, you have a way to "pick up" where you left off. Using a queuing system is good for this, as only the processed items will be removed from queue, so killing a job mid-way is safe. I also often write to log files on the server, with things like "last-id processed", so if a job is killed mid-way, and respawned, it will pick up at that last id.
Why wouldn't you update composer? There have been gigantic changes to composer in the last year.
&lt;3 Slim in combination with (slim-layout-view)[https://github.com/petebrowne/slim-layout-view]
Lumen is just some well tested components glued together. The glue being a light version of Laravels bootstrapping that you can easily check out. At least one big project (apart from Forge and Envoyer) apparently got the code early. They tweeted right after release that they're already using lumen in production.
Have JetBrains confirmed hack support in PHPStorm 9? Last I read they were still "experimenting" with support, which doesn't say much.
Yeah I run "csu &amp;&amp; cgu" everyday, first thing I do when I boot up the terminal
Was this related to APC? My former company has yet to upgrade past 5.4 due to reliance on some of the user cache features that have since been removed (ironically, those dependencies were added by none other than Rasmus Lerdorf himself)
Je m'appelle baguette.
Depends on what you want to do. Some framework are better than others for certain tasks. I have my own API framework called [Ionian](https://github.com/demonshalo/Ionian). I am still adding features to it and the documentation is a bit lacking but I made it incredibly easy to extend and migrate the code from it to any other popular framework. If you decide to play with it for the fun of it. Please let me know and I will help you get started :)
The current plan is for D8 to support 5.4, 5.5, 5.6 and 7, but since 5.4 will be unsupported by september, it will make sense to drop 5.4 and only support 5.5, 5.6 and 7.
will check it out ty!
Great job! This is super useful. Does it generate basic CRUD commands for the resource too?
Thank you! Yes, check out the repo, it creates a controller, all the views, the model, the migration, a seed, a Request etc. All the CRUD commands will be available out of the box! Im working on a parameter which lets you pass the CRUD commands you would like to have (for example: only index/show).
Actually a very good point, will have a look at it, thank you very much for your opinion and idea!
If you go to any of the cons php[tek] or Zendcon for example, the Facebook team behind HHVM is usually present. Not giving this as a basis for technological considerations, however, from past interactions with their team I have to admit I believe HHVM and it's specific functions, like HACK, (which solve problems for FB) are a long term commitment.
Agreed, it is a very poorly researched and written article. &gt; PHP is being widely used by an extensive range of users for the past 2 years The highlight of which is really that statement. 
&gt; There have been gigantic changes to composer in the last year. Sometimes they add new features. Sometimes they break old features. I don't update Composer constantly, because I like to be able to deploy projects without being worried about whether there have been changes in it since the last deploy that are going to break stuff.
Good points here. I had a similar reaction. I can of course talk about how my Symfony based REST implementation is great, but it is great for what I'm doing. It seems like we could all use a nice feature grid somewhere summarizing the various options because some may have convenience methods for things like keygeneration that may be vital for one person but unnecessary for another.
[Dead man's snitch](https://deadmanssnitch.com/) will probably solve this nice &amp; simply. All you need is something like this: php cron-runner.php &amp;&amp; curl https://nosnch.in/c2354d53d2 If Dead man's snitch doesn't get a curl request from you regularly then you get an alert.
I'd prefer the generation myself, I don't think inheritance is a good way to re-use code.
Interesting problem. I am working on an extendable PHP Error-handler. I might end up adding a feature where the ErrorHandler itself makes an external system report upon failure. If I add that feature I will let you know :)
CTO of Workshape.io here. It is a fair point of discussion and I understand the confusion. To clarify: When a user/developer uses our platform they are able to specify 5 skills/technologies that they would like to work with in their next job and no more. The data we present shows that Node.js engineers commonly also put Javascript as one of these 5 options. Evidently PHP developers do too. We debated taking it out, but at the end of the day there is a distinction, however small between Node.js and Javascript and the users of our platform have demonstrated that they distinguish between the two too. We don't know the exact reason why, but you could hypothesise that, as someone else mentioned, the skill Javascript may be meant to associate with client-side js. 
This has to be unintentional, right?
Seriously /u/philsturgeon manages to be entertaining and informative at the same time. I wish more technical books were like his.
I just remove the scripts from composer.json. They get ran as part of my build process (a simple shell script) and don't need to be intertwined with composer. I would recommend everyone to do the same, really.
What if later on a bug is found ? Regenerate all the controllers ? And if you already modified them?
You can make this the default behavior on a per-project basis by adding the following to your composer.json: "config": { "preferred-install": "dist" },
Given the simplicity of the generated code, bugs would not be a huge concern - really, those need to be caught at the package level since that's where they would originate. If the package is generating buggy controllers - don't use it. You can always run some integration or acceptance tests after you generate a controller and verify it works as it should. Ideally, this package should generate the tests for you as well.
Is there a similar flag for the --no-dev flag? I'v looked around but couldn't find the answer. Actually better question.. Where are all the config options defined as I can only find the cmd line options..
They could be deciding on whether to do it now or wait for 7 to come out.
OP, take a look at [DUnit](https://github.com/vectorface/dunit) to test against PHP7-nightly. Enjoy.
No one wants to, or *has to* hold off clients while they rebuild things from scratch. This is more a sign of a monolithic architecture, which seems the ok until a team gets stuck with a big old framework deeply embedded into their app, like in this case. As existing platforms go obsolete, and new ones come in, it makes it impossible to switch gradually to new ones, piece by piece. So such design is now a part of this codebase's tech debt. Jeff Bezos had this problem early in Amazon, so like a smart boss, he gave his employees this mandate: http://jesusgilhernandez.com/2012/10/18/jeff-bezos-mandate-amazon-and-web-services/
That's good idea. We create version 2.0 and is on github. That version still not accept multiple image upload but we will se in future to accept.
Use [hvvm](http://markvaneijk.com/use-hhvm-to-speed-up-composer) to speed up composer
[ftp_mdtm()](http://php.net/manual/en/function.ftp-mdtm.php) has an example right on the page. I'm not sure what else you could want. If it doesn't work with your server, start by reviewing the ftp server logs to see what PHP is transmitting, and how the server is responding. If for some reason it's not formatting the command or the response correctly, you can issue commands manually to the server with [ftp_raw()](http://php.net/manual/en/function.ftp-raw.php).
Yeah, I have no doubt they're committed to HHVM and Hack, it's the parts about being open and working with the community I don't yet have trust in. (Not to say I distrust them, just that it hasn't been built yet.)
From the docs: &gt; HHVM ships with a tool called the hackificator that attempts to move as many files as possible into Hack. It does not change the code in the file itself over to use any new features of Hack; it just changes the file headers from &lt;?php to &lt;?hh in places where such a conversion can happen cleanly. (With one exception: it marks as nullable typehinted function parameters with a null default value.)
I think you mean install HHVM, not Hack. HHVM is the runtime, Hack is a language built to run on HHVM. You would replace the PHP runtime with HHVM runtime. To the question, HHVM is fully compatible with PHP 5.5/5.6. Are the extensions you're using fully compatible, though? Who knows.
That's fair.
http://3v4l.org/hutIg
Thats actually a really good point. I think the proper way to do it is creating a Resource Controller and inherit it. Could also add a option which let's you decide how you want it. I really like the idea of generating test cases, will definitely look at it! Thanks for the discussions, i really them and all the ideas/suggestions which come out of it!
Oops, I made a typo in the thread. I meant MFMT not MDMT. How can I execute a MFMT command through PHP?
The --no-platform-reqs flag in conjunction with vagrant.
Read the requests' $_SERVER['HTTP_REFERER'], it should be set to the domain the request was set from.
I found this: &gt; $_SERVER['HTTP_REFERER'] Will do exactly what you need. &gt; if (strstr($_SERVER['HTTP_REFERER'], 'facebook.com') !== false) { &gt; // Facebook brought me to this page. &gt; } &gt; elseif (strstr($_SERVER['HTTP_REFERER'], 'google.com') !== false ) { &gt; // Google brought me to this page. But that looks like I would have to manually enter in each URL/domain. I want something that automatically carries over the name of the domain and displays it.
Spoofing shouldn't be an issue, as it's only text based make offer page (very low traffic) Anyone remember the Reddit post years ago: [Sears Caught Selling "Grills to Cook Babies](http://consumerist.com/2009/08/21/sears-caught-selling-grills-to-cook-babies-thanks-to-poorly-built-website/)
Yeah, its not 100% secure but a decent start for him to work with.
 composer update --lock Just because you updated something in composer.json (eg author) doesn't mean you always want to do a full composer update.
You'll have to do it with ftp_raw() like this (untested, use at own risk): function ftp_mfmt($ftp_stream, $path, $unix_timestamp = false) { if ($unix_timestamp === false) $unix_timestamp = time(); if (empty($path)) return false; $path = escapeshellarg($path); $datetime = date('YmdHis', $unix_timestamp); if ($datetime === false) return false; return ftp_raw($ftp_stream, "MFMT $datetime $path\r\n"); } This will return an array of strings which represent the response from the server. You'll have to parse this response in order to determine if the command succeeded or not.
I've seen that ticket + response. I just know that the EAP doesn't have support currently. Hopefully it comes soon, playing with hack at the moment is a bit of a pain.
[parse_url](http://php.net/parse_url) $host = parse_url($_SERVER['HTTP_REFERER'], PHP_URL_HOST); if ($host) { //do stuff }
Rather than relying on HTTP_REFERER can't you get your redirect script to include the domain as GET parameter in the URL. That avoids problems with people with referrer suppressors. 
Word. The best and the simplest.
I wouldn't have much control over the redirect, because that would be done through the domain registrar. I have the ability to change nameservers and host the domain, but I am trying to simplify the process, as a own a lot of domains
I bypass Composer's autoloader because of badly behaving libraries like React.PHP and especially SwiftMailer, which force expensive initialization scripts to load on PHP request startup, even if I never use SwiftMailer in that request. Instead, I always run Composer with option -o ("--optimize") which generates a full autoload hash map. Then I feed that as part of my map-based autoloader. As for the expensive initialization routines, I run them on-demand if I need, say SwiftMailer in that particular PHP request.
Is can be a trait. This way methods can be optionally hidden when they don't apply.
"Forgot"
&gt;For example, domain1.com would forward to MyDomains.com and when the user landed on MyDomains.com it would say: : "Make Offer to Buy Domain1.com" How about doing something that's actually constructive instead of fucking domain-squatting?
The scalar type hints will take most (not all) of the wind out of hack's sails.
&gt; It's about CPU load, latency, hack and other things hack brings to the table. Currently, hack code is not JIT'd any differently than non-hack code. Therefore, whether or not a code file is hack matters not to CPU load and latency. 
How would I make it so it works with files?
set $path to "/path/to/file.ext" This depends of course on how your server implements this operation. You'll have to look it up in your server's documentation.
That's exactly what I did. inserted in line before $path = escapeshellarg($path);, but it returned nothing. Also tried inserting above the function, same result. Also have a login function before the code with if/else so all is working fine until trying to execute the function. Tried both files and directories :|
Keep in mind the above script can also be manipulated by any referer coming from a different domain that has the string 'facebook.com' in the url. so if the referer is: http://scammer.co.sa?facebook.com-eat-my-shorts it will trigger a false positive. You should specifically search for anything after the http:// and before a / or ? 
So debug it. I've told you more than once now you're going to have to check the logs.
There is nothing in the logs.
I'm sorry you're having trouble creating valid JSON. It's very very difficult.
What makes you think I don't know how FTP works? I've used the MFMT function over FTP on my server which is why I'm puzzled it doesn't work through PHP.
&gt; What makes you think I don't know how FTP works? &gt;Or maybe FTP PHP does not support MFMT? \^ because you're saying things like that. PHP can send any arbitrary command to the FTP server using ftp_raw(), and will collect a response as long as the server understands the command.
Might be because FTP_RAW doesn't even support MFMT.. http://www.nsftools.com/tips/RawFTP.htm
Again, **as long as the server understands it and issues a response PHP can ask the server to do it**. The list you're linking to is just the more common command set. It's not an all inclusive "the server won't work with anything not on this list". The FTP protocol is designed to be extended, and different servers support different command sets. The server can implement any kind of arbitrary command it wants. *That does not change how you issue commands to execute them*. Literally all ftp_raw() does is sent arbitrary data to the server, and watch for a response. That's it. That's all. It doesn't need to "support" anything.
The server understands it perfectly via FTP. It doesn't understand it via PHP. You say it will issue a response even when using ftp_raw, but it does not. It issues a response perfectly for CHMOD when using ftp_raw but does not for MFMT. So what could be the reason? 
http://www.phpgolf.org/
Was that part of https://bugs.php.net/bug.php?id=64874 ? 
&gt; One request can be for say 100 urls and with Iron.io we can run one worker per url or using the Symfony Process library we can even use a worker to run a multi-threaded processes. I hope this is just for the sake of example, otherwise, please read about asynchronous I/O, because, damn... Guzzle even comes with an out of the box HTTP request batching (which uses async under the hood).
Interesting. Have an example gist of this process? Using swiftmailer myself and haven't profiled its initialization. 
How about a wireshark packet capture between the PHP server and the FTP server to see if the connection is made and the command sent?
Also keep in mind referers can be manipulated in general, so if you're looking to give away prizes or something it isn't the best method, granted OP didn't post about this but worth noting. Also don't just echo out referer as others have suggested because you'll have an XSS if it's on your main domain.
Good to hear about the plans to support PHP7
In php, use the $_SERVER['HTTP_REFERER'] to parse domain from the redirect?
Would it surprise you that to learn that Composer validates the JSON not just being valid JSON, but [against a particular schema](https://github.com/composer/composer/blob/master/src/Composer/Json/JsonFile.php#L143)? It surprised me when I upgraded to the latest version of Composer couldn't work with a composer.json file that had some extra information in it. The extra info was there for another tool to allow switching between local (aka dev) versions of packages and released versions. It wasn't a big change, but it meant that stuff that was previously working suddenly stopped working. It seems that they've actually changed the strictness of the validation to be lax again. I'm still not going to upgrade blindly though.
If you have no constraints by your environment: Go ahead and take some days to play with each framework (and include Symfony2 in your list, it may take its toll on you if you never worked with a somewhat enterprisy framework, but its worth a look). They all have their distinctive set of developers they try to appeal to. There is no one-fit-all solution ;). Btw. Yii and Laravel(Eloquent) both promote their own Dbal/Orm/ActiveRecord abstractions. You could also look into Doctrine/Propel if the given choices don't suite your requirements. 
this is really a clean solution dave1010; thx!!
hey headzoo, we use CloudWatch for this now too. I have just been wanting a simpler solution. Not sure why I keep associating "non-trivial" with CloudWatch but I do. Maybe I just need to lock down a better process to use CW. I checked out dave1010's suggestion of Dead Man's snitch and it looks great.
With regards to types, Hack's type system is statically enforced, meaning the typechecker can find errors without even running your code -- and thus find errors in cases that might not fail until your code has been in production. As important as scalar type annotations are for PHP, it's only a very small step towards the rich, static type system that Hack has. But Hack is about much more than just scalar type annotations. I gave a talk about Hack and a look at several of its features a while back: https://www.youtube.com/watch?v=jqXqdqUhxy8 Short version: it has an amazing syntax for asynchronous IO, which allows batching IO while still writing what largely looks like straight-line code. It has XHP, a templating engine more powerful to use at scale than anything I've seen elsewhere. It has nice collections APIs to separate the mess of a data structure that is the PHP "array". Etc etc.
There may also be some non-reflection tricks you can do with serialize/unserialize, although I suppose that would not be changing the *original* object. Slightly-related in the "sneaky things without actually using reflection" category, here's what Doctrine uses to instantiate an object without calling the constructor, for older PHP versions that don't have `ReflectionClass::newInstanceWithoutConstructor` ... unserialize(sprintf('O:%d:"%s":0:{}', strlen($name), $name)) 
What method do you use to accept input? Do you use Symfony forms or do you serialize the request straight into the entity you want?
I like lot's of features in Hack. The two I like most are: * Scalar type hinting (or enforcement) * Async IO Everything else I am less excited about. Generics (templates) are super awesome for languages like C#, Java, and C++. For PHP, it doesn't seem as compelling. :/ For the scalar type hinting, PHP7 will give me most of what I desire. This is huge for me. However, it is important that I say I believe Hack provided the pressure for PHP core to get the RFC passed. Thank you sooooooo much! :) I so want Async everything to be in PHP core. It's not. That sucks. :(
Yup. What questions do you have?
&gt; but its documentation feels unfinished and its array-in-an-array-in-an-array configuration is a bit messy. most of the arrays will produce an object using the 'class' keyword. For example 'db' =&gt; [ 'class' =&gt; 'yii\db\Connection', 'dsn' =&gt; 'mysql:host=localhost;dbname=arafel', 'username' =&gt; 'root', 'password' =&gt; '', 'charset' =&gt; 'utf8', ], Will create an object From the class yii\db\Connection and you can search that class documentation to understand what each of the parameters means. This behavior is used to be able to take full power of the autoloading in php, that way the 'db' component will be created if and when its used, not before. Besides symfony 2 (and by extension laravel) have the most painful configuration i have ever meet, there is less documentation and trouble shouting about it than there is on yii2. &gt; This would be a simple CRM like administrator panel for an other small company. For starters it will need a few entities (10-20), and it's job will be to send a few automated emails, process data and generate some fancy graphs. Performance is not an important factor, as it will have &lt;5 users. I have been doing CRM's this year using Yii2 and the development process is reduced to create the database, then make it pretty for the end user. If you know how to build normalized databases Yii2 will do 80% of your job for you. I made a simple CRM with 6 entities this weekend only on saturday and sunday without breaking a sweat.
&gt; For stable versions composer will use the dist by default. Right above it, so you shouldn't need to provided the flag.
Yes, ~~it~~ [the performance boost] will only benefit very specific projects where the bottleneck is the framework.
That's a misleading comment. Phalcon is actually a really nice framework even without the performance benefits, so it stands to benefit anyone at all.
Why are you using it over larval, symfony etc...? Genuinely curious.
I'm going to have to agree with /u/jvwatzman here. Scalar typehints are only part of the problem with PHP's native type insanity. Also, as indicated above, HHVM gets you type checking ahead of time, as opposed to at runtime (which is arguably too late to figure out about these kinds of things). For larger applications with a high volume of commits / committers, this kind of static analysis is a **huge** factor in keeping your code base safe, reliable, and coherent. PHP adding scalar typehints simply doesn't give enough here. Also, I disagree about the whole "generics are not compelling for PHP" bit. Why would PHP as a language make generics any less desirable? Why draw the comparison to C based languages? If you've ever tried to write frameworks in PHP (of which there are plenty), you've probably wished desperately for generics and sanely implemented collections (instead of just arrays on arrays on arrays....). Yes, frameworks can be well built without generics, but it doesn't make them any less nice to have. Shapes, function return types, and type aliases are even more features that help reel in PHP's natively crazy type system to make it easier to reason about. These contribute massively to the attractiveness of Hack. Addtiionally, asynchronous I/O is a fundamental and incredibly important feature to have in applications running at scale. To say that PHP 7 "takes the wind out of Hack's sails" simply by adding scalar typehinting and none of the features I've mentioned would be disingenuous at best. At the end of the day, PHP 7 (in its current form) doesn't have an answer to the eventual bottleneck of I/O (though CPU performance looks promising!). This makes Hack extremely attractive by comparison. Regardless, this is obviously a very exciting time for PHP what with all of this innovation. I'm as excited to see what PHP 7 brings as I am to see what the world of Hack and HHVM looks like moving forward. To some degree, we all get to win with a little bit of competition in this space - it gives us a chance to feel out these ideas that we have around how the language "should" progress. I doubt this will result in any irreparable divide in the community, and am grateful for all that there is to (finally) be excited about in PHP!
Give it a year and I think all the major players at scale who run PHP will have moved over to HHVM. Want Hacklang to be taught at universities, I don't think it will be much of a stretch. Once job postings from the big guys specifically mention Hacklang and not PHPlang. You'll then start to see courses readily available for it. You'll also probably see C++/C# to Hacklang side courses. Like majoring in one and minoring in another. I personally think, wait for HHVM 4.0. Once all the kinks like memory leaks have been resolved and the majority of extensions have been ported over and are available. The tide will really start to turn. I think it already has.
Go take a look at Etsy's implementation with Hack and their CPU usage. It's definitely inline with the issues I faced. It was a no brainer to go from PHP to HHVM for me.
A ZF1 app has nothing to do with technical debt. How do you know it's not a pristine application?
For my test case it was much faster, less bulky, and much more direct for what I needed to get done. It's an extension, not a framework, so there were no complicated integrations. I installed Phalcon as a PHP extension and off I went.
How does it compare speed wise to lumen, if you've tried that?
That's what migrations are for.
Yeah. It's just as incorrect to say that the type information does nothing as to say that it leads to big performance boots. It's somewhere in the middle, depending on the balance between the extra CPU in actually checking and enforcing the types, and in being able to easily JIT better code. The last experiments I recall seeing had the runtime types being slightly good for perf, but nothing earth-shattering. But OTOH, that was on Facebook's code, which tends to be pretty monomorphic anyways even when there aren't explicit type annotations, and HHVM is good at picking up on and optimizing that sort of thing. That's probably where big wins could come from, if there were to be big perf wins to be had in a Hack conversion -- not the types themselves, but in the code restructuring that makes code typeable. It turns out that trying to make it easy for programmers and static analysis tools to reason about your code also makes it easier for JITs to optimize it :) But of course, as I said in that post, the perf isn't really the point of Hack :)
Meh Rasmus and Sara Golemon are both at Facebook, plus a few other community members. I know Sara was actually working on HHVM for a long time, the commit is there to keep it free and open, the second that goes away you'll start seeing talent leave, and even with that said, there's enough critical mass now that you would just start seeing forks pop up.
I'm just talking about the overhead of loading the controller, view, dependency injection, request and session providers compared to loading the same services in Laravel. Our app is built using micro-services (there are over 30 of them), and we aim for an API response time under 50ms, so those 20ms that Laravel adds on top of whatever processing we need to do really matter. Plus it really helps save money on servers, since we can process at least twice as many requests per second with Phalcon. It's great to have a framework that barely adds overhead to your requests. Full MVC with a nice DI for almost no extra processing time.
Thank you, I will check it.
Symfony2 felt -as you said- too enterprisy. On paper it looks good, the examples and the doxumentation are excellent and make you want to start building something. But as soon as I really wanted to make something I just felt overwhelmed with it :)
Well, my original point isn't as clear as I thought that it was. Revised: &gt; It's an extension, not a traditional framework, so there were no complicated integrations.
Your last two paragraphs described the core of my problem pretty well. These are the exact same reasons why I can't make the decision easily :)
Is it not both?
AFAIK lumen is fast because it has no features. Won't you lose that speed benefit once you add back in all the shit you need? Why would you want to do that?
What are the benefits of Phalcon 2.0 over 1? From the description: &gt; Phalcon 2.0, offering compatible functionality (and more) as before Great...they spent a year getting us back to where we were. *Maybe* some new features, but they don't mention what? &gt; Zephir, allowing developers to write their own extensions easily without the need to know C. Some kind of new programming language that makes it easier to write PHP extensions...? Why would I want to learn Zephir over C? It might be a little higher level, easier to learn? But it has very limited applications. Do I *need* to write extensions to work with Phalcon? Is this really a big perk to developers? 
Given "MVC" takes 0ms as it's just a way of organizing your code, that statement feels like a big misunderstanding of the features you're using.
DI is also taking 0ms of processing time, it means "passing objects to constructor or setters". Of course I can second-guess the feature you're talking about (like expensive regex routing, DI reflection-based automagical container etc.), but let's use the right words. Because otherwise even Phalcon seems too slow for what you list as "features".
Phalcon goes too far in being all a PHP extension, and I feel in the name of shiny. There's a happy middle-ground between "heavy bloated PHP" and "everything in C". Those who have heavy loaded PHP apps in production quickly find it. You can achieve the same performance benefits by isolating only the hotspots in a framework to optional C extensions (or C/Java/Go etc. services), and leave the rest as PHP so it's easy to debug, evolve, patch, etc. but open source projects are more... idealistic I guess. If you have it all like C (or their PHP-like meta language) and only C, it's all unnecessarily opaque. This approach is the very definition of "premature optimization". And I consider it a risk for those who depend on a framework like that.
Rasmus is ***not*** a plus to any project.
It all depends on your perspective, I think. Most would say yes, I'm sure some would say no. It's really not a traditional framework, but sure, it's still a framework.
most of them are in the schema section of the docs on the composer website.
What do you mean by "not traditional"? It's got models, views, controllers, routing, an ORM, .... looks pretty "traditional" to me.
If you want to look at it like that, 2.0 doesnt not bring a ton of new stuff, but they have been saying since they announced Zephir that 2.0 would be a rewrite in Zephir. Zephir is essentially the big take away for this release for me. It is definitely a perk for PHP developers, because they do not need to learn something so low-level as C (and might be just plain out of scope for many PHP developers). The syntax and file and object structure is surprisingly similar to what developers are already familiar with for PHP. Also, PHP functions are all available in Zephir. Or C can be written for things that need additional optimization. I have ported a few things over to Zephir and most of the work was simply removing all of the $ characters. Zephir provides a very nice middle ground between PHP and C. It offers static (but also dynamic) typing, extension compilation and a path for writing more correct code.
Yea... That's not what I meant. If you think about every other framework you can possibly think of, you'll pretty much get the same thing. A group of files which you put in your web directory and include into your project. With phalcon, you add the extension (a single file) to your PHP installation and you're off. Not to mention that with a single PHP file, Phalcon will work with the built in PHP webserver. You can use it in a totally sanitary environment using only PHP. It's pretty great.
I was saying those 20ms may sound correct for tiny projects but for most projects it should be noticeably higher. The big problem with Phalcon though is its uncertain future. Their kickstarter only brought in $3k so far. On the other hand there are countless resources for Laravel.
I think this shows at most that the bootstrapping/routing of Laravel is slower. "Hello World" benchmarks dont represent real world usage. But anyway thank you for the benchmark.
It's fast because it has a lot less configuration options and things are disabled out of the box. It's for smaller sites and APIs where you don't need all the bells and whistles
Have you considered using CakePHP 3, it has similar features to those of Yii and Laravel, but with really good documentation. I would also say that Cake is very well suited for this kind of use case.
If you have several existing projects that you'd want to run on HHVM, I'd say if you have test-suites already built then you'll probably have an easy time with it. If your code is fairly up to date and simple, you may find you can just start up HHVM and everything will work okay. e.g. it's fixed now, but months ago I had issues where some KML my app was generating came out blank, and found it's because that level of HHVM didn't support the PHP output stream `php://output` I was using to save my DOMDocument of KML to, but everything else in my code, and the underlying CMS, worked flawlessly. Check out HHVM's parity page for more information on frameworks + libs they've tested against: http://hhvm.com/blog/category/parity An up to the minute status of HHVM's test results on many frameworks can be found here: http://hhvm.com/frameworks/ Keep in mind that while your code may be tested as working, and your framework may have 100% parity, that doesn't necessarily mean every extra lib you install (e.g. a WordPress plugin) will have 100% parity too.
I love Yii 2 and would absolutely recommend it. But I can't say anything about Laravel so I can't really argue to try Yii over something I don't know. Yii 2 is fairly new but from what I've seen there is tons of documentation available already as well as Q&amp;A. People using the framework are really enthusiastic about it and will be very helpful should you run into a question. Just make sure you use the basic template rather than the advanced template, it's way easier to get into and I feel it suits 90% of the projects. In regards to the "its array-in-an-array-in-an-array configuration is a bit messy"; I don't really think it's an issue and I kind of like the way it works, but I'm sure Laravel has a good system as well. Most if not all settings you set in the config will be configured as properties of a class that is made. At the top level (`id`, `basePath`, `bootstrap`) you're defining Application settings and in the `components` array you define subclasses that you can use where you provide which class Yii should instantiate (lazy-load, so it won't do anything until you use it) and what properties it should have by default. This might look messy, and perhaps it kind of is, but keep in mind it's more of an application config and not really supposed to be code. It makes Yii usable for various things. The way I set the config up nowadays is the following: in my config directory I make a new directory called "defaults" in which I place the original config files. These are committed into my repo. Then I make copies of these files in the actual config directory and here I require the defaults file and overwrite any settings I want changed. These files are gitignored so they can be different for each environment. Here's an example of my `web.tpl.php` file (this config-template is committed): &lt;?php /** * Template file for how the web.php file could look like. Make a copy of this file, name it (exactly) "web.php" and add the configuration options as needed. */ $config = require(__DIR__ . '/defaults/web.php'); { /** * For development - comment out for production */ defined('YII_DEBUG') or define('YII_DEBUG', true); defined('YII_ENV') or define('YII_ENV', 'dev'); $config['components']['log']['traceLevel'] = 3; // configuration adjustments for 'dev' environment $config['bootstrap'][] = 'debug'; $config['modules']['debug'] = 'yii\debug\Module'; $config['bootstrap'][] = 'gii'; $config['modules']['gii'] = 'yii\gii\Module'; } return $config; 
It says it's for APIs and yet doesn't have basic API features such as auth (basic auth, oauth, etc), or rate limiting.
 before_install: - composer self-update have you tried adding a line to do a composer self-update in the before_install section?
Take a look at [this bug report](https://bugs.php.net/bug.php?id=53976), which suggests it's a garbage collectionEdit issue, and disabling gc should let the tests run. Edit: if it's running fine in one environment, but not another, then make sure your versions match: php, phpunit, composer, and all other dependencies. There is nothing worse then everything working in development but not in production.
Looks a great language to write a template engine, like smarty or patTemplate
I know it's probably not possible. But if the code that develops plugins in Zephir for Phalcon2/php could be ported over to HHVM. So that in the cases where HHVM for whatever reason can't be optimised to run code as fast as native c++. That would be awesome. I have some heavy duty modules that can be externalised into extensions. Yes, yes. I know what HHVM does with the JIT compiler before anyone mentions it. But it would be nice to have in cases where you are comparing a C++ extension vs HHVM and then finding why the compiler doesnt give you as good as performance. Or in cases where you have a tight deadline and just want an extension and be done with it.
Accessing private anything is never a good idea from outside the class. Sometimes the stuff that ends up on reddit is just silly. 
I've tried disabling gc too, it didn't worked, has the same error. About the edit, TravisCI uses phpenv, I'm thinking about this being the cause. Thoughts ?
On travis, install valgrind, set `USE_ZEND_ALLOC=0` as an environment variable and prepend `valgrind` to your phpunit invocation. This should give you an idea where the issue is coming from. Likely this is related to the v8js extension, which too me sounds pretty unsafe ;)
Check this [http://raml.org/](http://raml.org/) RESTful API Modeling Language ([RAML](http://raml.org/)) is a simple and succinct way of describing practically-RESTful APIs. It encourages reuse, enables discovery and pattern-sharing, and aims for merit-based emergence of best practices. The goal is to help our current API ecosystem by solving immediate problems and then encourage ever-better API patterns. RAML is built on broadly-used standards such as YAML and JSON and is a non-proprietary, vendor-neutral open spec.
I would advice to you to try both. I chose Yii1 for a project year ago, my boss suggested it. It's CRUD generator (Gii) was supposed to make my life easier while it usually just drove me crazy. Consider that many many times you'll have to do things in your forms that are not just using a plain text input but maybe a Javascript plugin like Select2. 
[Bingo.](https://supercultshow.files.wordpress.com/2014/05/samurai-cop_web.jpg?w=500)
Check out [API Blueprint](https://apiblueprint.org/). Here's a couple blog posts on it and Dredd (for testing): - https://philsturgeon.uk/api/2015/01/28/dredd-api-testing-documentation/ - http://blog.apiary.io/2013/10/17/How-to-test-api-with-api-blueprint-and-dredd/
I was under the impression it didn't work with PHP? Doesn't have a "binding" listed on their site.
Thank you for your input. I've already started with the basic template, because it did seem easier. I had to borrow the authentication part from the advanced template tho, but it was pretty straightforward. Thank you for the configuration example, I will use it :)
Your output shows phpunit is segfaulting? Wow.
Yep, RAML is a good one to use. You can also use it to test and verify your endpoints. It's worth having a look at Mulesoft's Anypoint API Designer. It let's you design and then mock up API endpoints in RAML : http://api-portal.anypoint.mulesoft.com/raml/api-designer P.S. RAML was originally designed by Mulesoft, so they're fairly invested in providing tools for it, like the API designer and RAML parsers.
The "$something or die()" pattern is very common in Perl, which supports both prefix and postfix logical branching ($foo = $bar if $bar =~ /baz/). It's not strictly incorrect. What I'd be more worried about is calling die(), ever, in a web app. It's preferable to call `trigger_error` or throw an exception (depending on how the app is organized). In general, you want to fail gracefully so that users are presented with, at the very least, some reassuring message.
I'd suggest using exceptions everywhere and never touching trigger_error. Any modern PHP app should be using exceptions for everything (and converting errors to exceptions) 
Currently just manually creating the entity from data. Form's is probably a better way to go, but haven't used it yet.
It's a real gem until you try to generate clients with [swagger-codegen](https://github.com/swagger-api/swagger-codegen). That aspect of it is awful beyond reason. Everything up until that point is great. The spec is well defined and the [javascript client](https://github.com/swagger-api/swagger-ui) works well enough.
Yes. You should never do this.
It's not a poor coding standard, it's just an old coding practice from the times PHP was imitating Perl. PHP these days is more, well, imitating Java and has the corresponding features to support this sort of programming. Doing "foo() or die()" is perfectly clear, if a little morbid, but seeing it in PHP 5+ code it has some relative problems: 1. Ignores "or" is a legacy operator that's similar to || (except for precedence), so it should be avoided. It's in PHP only for back compat and it might go away at some point. 2. We have exceptions. Sudden death via die() means your users will see a blank screen or a page that stopped mid-rendering and we don't want that. You instead throw an exception, a layer upstream can log the exception and show a proper error page. So the modern approach would be your $db layer should be throwing exceptions which reduces the above example to just: $result = $db-&gt;query(...); Having "or die()" is concise, but not having "or die()" is even more concise ;) And somewhere upstream, say in your application bootstrap: try { // Somewhere several layers deep in the bowels of this app we run $db-&gt;query(); $app-&gt;run(); } catch (\Exception $e) { $log-&gt;exception($e); $errorPage-&gt;render(); } P.S. Oh and also you don't have to type "die()" you can just type "exit".
It's a little strange, but it's surprisingly readable. And it is efficient and concise. I don't use it myself, but I don't see any reason why it would be called poor practice if someone wants to use it.
Don't say that, some idiots will petition to have those functions changed or removed to enforce their "coding standards". That's how most changes to PHP happen nowadays.
This can be useful for writing unit tests. Generally you don't want to end up having to do this, but for writing differential tests of legacy code refactors, it can be crucial.
It does have auth but for some reason it isn't been included with the other documentation. There's some on github.
... because we have exceptions. die() quits your app immediately. An exception is catchable and therefore you can do something that happens when an error occures. May be, php should not have die() or exit() anymore these days. And if someone need those functions to enable an exit-button for php-gtk, then go add an gtk-exit-fn. 
But die() is so much more fun than exit. ;)
It's usually a bad idea, but I've seen it used before where it sort of makes sense. The CMS concrete5 does a `defined('C5_EXECUTE') or die('Access Denied')` at the top of nearly every PHP file. It's not meant to be a part of any logical branching or smart exception handling. c5 routes everything through its index.php, so if someone's being directly served a different PHP, it should just die immediately and not run anything. ie it's only intended to block someone typing in `http://yoursite.com/path/to/some_other.php`. There are definitely better ways about this, and it's not something I'd ever do in my personal projects. I have all my deployments under nginx w/ fastcgi, so all requests go through the index.php, making that check pointless. If you're bundling a CMS that you want non-developers to be able to install on cheap shared hosts and not have to worry about it, then it sort of makes sense. Even still, I'd rather just throw a RuntimeException
There's nothing wrong with the procedural API, and there are some cases where it's advantageous over the OOP equivalent. Granted, the chance you'll encounter those cases outside of a thought experiment are nearly zero, but that's beside the point. The real legacy that generates complaints are the inconsistently-named and ordered functions in the standard library, particularly those around string and array handling. To be fair, most of those were inherited straight from C, but it still reflects poorly on PHP for not having any sort of real vision for consistency. I expect those will live on nearly forever, but if we ever see object-based scalars^[1] (e.g. "$s = new String('foo');` instead of `$s = 'foo';`, the scalar objects will almost certainly have much more well-thought-out APIs. There's no shortage of implementations in user-space for these but for sheer syntactical simplicity, they'll need to be implemented natively. ^[1] In practice, the user side of things would probably look the same as it does today, except that `"foo"` would be a string object rather than a scalar primitive. This has massive implications beyond the additional APIs, since objects are always pass-by-reference rather than by-value. It would also directly conflict with the finally-passed Scalar Type Hints, so it's pretty unlikely.
Huuum, I don't know if I got it, how would I run phpunit manually in the build directory of Travis ? It's running correctly in my machine, also in two other virtual machines (one with Ubuntu and other set with Laravel Homestead, that I think it's Ubuntu too), but goes segfault when I run it in Travis.
The issue comes in where legacy apps may not be organized in such a fashion as to guarantee that all exceptions are caught, and uncaught exceptions are fatals that stop processing abruptly with no way to show a useful error to users or continue page processing. There is also the issue (being dealt with in PHP 7 as I understand it) that several inbuilt functions or extensions throw fatals instead of exceptions, so even if you only use exceptions, you still need to be set up to handle regular errors, too. I think the major frameworks now must handle that for you. 
My corporation did `$ /etc/init.d/php-fpm stop`in February, had a party, and it's been great since. The hhvm/HackLang guys are so much more polite and responsive than the Zend guys. It's unreal. I love PHP, I like HackLang even more, and Zend Corp. has, at best, rested on its laurels for 10+ years until HHVM started going full steam and php-internals were like, "WTF? OMFG!" and started moving for a change. But even then, the bickering and infighting is a disgrace to civilization.
Umm, no. Please read: Working Effectively with Legacy Code
Yes, you should have a try-catch block in your bootstrapper that catches all unhandled exceptions. One of the benefits of using exceptions over old-style PHP errors is that you can catch them further up in the stack if you want to. The handler in the bootstrap code is only for unhandled exceptions.
I only ever use die() for debugging as a way of ensuring a script got to a certain point, or exiting after a var_dump()
The worst part about die("Message") from my point of view is that it returns Success (ie, rc=0) when run at the command line. That's pretty surprising for people coming from a perl background. Then again, I've seen php die() used as the last step for returning successful html results to the browser. as in die($rendered_html)
Personally I quote like the way Zend Framework 2 does it. $request-&gt;fromQuery('pixie'); $request-&gt;fromPost('pixie'); Makes your second option slightly more intuitive in my opinion.
well fromPost is not entirely correct either when it comes to methods like PUT, and fromData() would sound very vague
Yup. It doesn't have any opinions on where you place anything. You glue everything together and choose your own folder skeleton. It doesn't try and use the vendor folder either, or make any assumptions about folder permissions on prod...
I haven't tested lumen, but there is no way to fairly compare it. One is written in C, and the other is written in PHP. It's not a fair comparison by any means.
would that imply merging $_GET and $_POST? If not which one of those is 'input' ?
Why, what's wrong with that?
Tony Marston, is that you?
&gt; *I just ask this because I'm partial to just regisering a custom error handler, and if the environment is set to 'PRODUCTION', then the behavior I described is triggered in any error.* Would you prefer to let some errors go unhandled? Personally, I'm in the "fail early" camp. I think that errors should be thrown in exactly the same way in production as in test, but their *display* should differ - on dev/test, errors can produce a more detailed failure message, on prod it should just issue a generic "oops, something went wrong" message. But the errors and exceptions should be thrown exactly the same way, including the same error_reporting level, otherwise your prod code can keep executing where your dev code would have bailed - do you have any tests to ensure that won't lead to *more disastrous* results?
I don't know what your project is or what your code looks like, but having a bunch of controller methods that do 90% of the same work as a bunch of other controller methods sounds like a code smell to me. I'd look into refactoring that duplicate logic out of the transport layer and into one or more service classes.
Thanks, I think you're right about this being a better option. Do you mind explaining how I could turn someone going to domainsales.com/?for=mygreatdomain.com into a variable that had the value of "mygreatdomain.com", that way I could use mygreatdomain.com in the title, on the page and in an email form. 
Mexico (I had to tech the service in the coffin.
Have you also tried adding `--verbose`to your phpunit command call
Try/catch blocks are good to acquire resources, when you know that some piece of code (eg. network connection) can fail and when you know how to proceed if it does. However, it is **not** a good practice to wrap a lot of business logic in them : - When an exception occurs, the catch part will often be too "far" from the logic to do much. This leads to catch blocks either almost empty, not doing anything significant, or redirecting to some generic error page--but then, why not use an error handler? - Try/catch blocks are not free performance-wise: the VM needs to keep a stack around in case an exception goes back there, and this also can prevent further optimizations. - Exceptions should only be used for exceptional events ie. system errors, not applicative ones. That's because the exception handling is hardly optimized in VM, since when an error occurs, well, you have bigger problems than performance. I have seen Java apps crawls with such ill-inspired business-logic exceptions, and PHP won't fare better. In contrast, a good error handler is pretty much like a cheap jmp, and from there you can conveniently log the error and display/redirect to some 5xx page if need be. 
&gt; Then it shouldn't be called "FormModel" for clarity. You mean *it should be called FormModel for clarity*? The Model class is not just used for form data input. For example, ActiveRecord class extends from it. &gt; The term "model" is the single most overloaded (and ambiguous) term in programming, and using it by itself provides no context. Well here is some context: http://www.yiiframework.com/doc-2.0/yii-base-model.html Do you have a better name which reflects the use case of the Model class in Yii? &gt; Then the docs should be changed to reflect that for semantic clarity Anyone who cares to actually read the docs knows what's going on. Before code sample it says: * Create a model to represent the data entered by a user through a form * Declare rules to validate the data entered * Build an HTML form in a view It's already clear from these lines what the EntryForm class in the code sample is being used for.
I am know on track with Yii2. It seems alright. The basics are pretty easy to work with, it's just needs a few hours to get used to. You are right, that customising the otherwise decent generators aren't always straightforward, and I wouldn't say that the docs are too helpful in certain scenarios. But I've luckily found some good examples via google and on the official wiki, so I think I can work with it. Maybee Yii2 is better in this regard than Yii1.
Why have two ways to archive the same goal? * For beginners it's harder to learn and more confusing. Nearly all professional devs use the OO-version of a lib (if not, it's not a professional to me, sorry). So you unnecessarily divide the community, make the language harder to master and you create a situation were some people need to rewrite a possible large part of their application if someone teaches them why there is also a oo-version. * It is not compatible with IoC. If you ever used the procedural style of talking to a database, you're not able to change connection details for example without changing the code inside the component that creates the connection (say you wan't to change the connection's charset and you didn't had a parameter for that). That also means, that you can't share a db-connection-obj with other components that could be themselves included in an already running transaction for example. You rarely (if ever) find a ready and useful component made by someone else, that uses the procedural style of talking to a db and enables IoC that way. * It's simply harder to maintain. Ask an IDE where an object is in use and you get results. Ask an IDE where an resource is in use, you better have some luck. 
-vvv to get composer extra extra extra verbose. I can't stand running composer without that option. 
So basically your question is about why should anyone use a framework -phalcon or any other one-. If you think that using a framework makes things simpler -something I believe most people will agree with-, and I need fast response times (any other solution adds -at least- 20ms of processing time in our EC2 instances), the only solution that meets that criteria is phalcon. If you can offer a framework that's as fast as phalcon in pure PHP, I'll be happy to evaluate it. 
To be perfectly honest I would love to choose this solution. Take only what you need and nothing else. Free yourself from the unnecessary bloat, understand your system and be in complete control. I have a few fundamental with this approach tho: * My lack of knowledge judging the chosen components. How should I know which one is better in the long run? * System cohesion: why would my randomly picked components would provide a better overall system, than a much more experienced expert's? Who by the way has the support and bugtracking skills of a community. * Documentation. These frameworks have a more or less complete and centralized documentation. Of course most of the standalone packages have excellent documentation too, but they are scattered all over the internet (github, readthedocs, rtfm, developer's website). * Support. It's the same kind of problem like with the documentation. A larger community means bugs should be found much quicker. Even if the original author jumps ship, the community might take up the project. This -I think- has a much less chance to happen with smaller projects. &amp;nbsp; Again, I would love this approach, but I feel that for now I'm much better if I choose an already existing framework, than try and roll my own from standalone components. I really appreciate your input as I'm interested in this topic, so I will definitely read that book. Thank you!
On production you can also set up a filter pass severe errors to a logging system that can alert the site admins, so problems can be caught early.
You provide it with a message *or* an integer return value (0 to 255). But not both, which is bizarre.
That practice tends to be pretty much frowned on these days. Either a PHP script contains definitions such as a class or functions, that don't execute on calling, or it is a legimate entry point to the application, or the scripts are out of direct reach of any virtual directory/webserver path. Of course, mistakes can happen, so auto-generated cached files sometimes add the conditional die() at the beginning.
Yes, it was poor wording on my part. All errors are handled, but only some are displayed. In practice, both approaches are equivalent. But I was just wondering what's the best practice/more common practice around here.
Just ask me if you have any questions. 
&gt;This removes any need for prefix/suffix conventions of any kind, which is simpler, and better. Why is this simpler ? You still need learn convention of pointing to method of class with '@' and call additional function only to register url which offen is controllerName/method. I would argue yii2 way is actually simpler and tells you what method can be called and what not.
Will do, thank you! :)
This needs a little paragraph at the start saying "It will help if you are familiar with nginx configuration, github, ssh[-keys], OAuth, DNS or /etc/hosts, composer (and possibly Jenkins)."
A weird thing just happened, the tests pass _only_ if I use valgrind. And yes, they really pass, I'm using the `--verbose` option of PHPUnit. Does it makes sense ?
Not every post here needs to be for beginners
Living in Venezuela, where Internet connections are less than 1 mbps, this comes pretty handy. 
There are some good suggestions in here, but it looks like nobody's addressed the PSR-7 way of doing things... In the PSR-7 world incoming requests should implement the ```Psr\Http\Message\ServerRequestInterface``` interface which provides methods named ```getQueryParams()``` and ```getParsedBody()```. This naming convention seems to address the problems you rightfully have with the methods being (often incorrectly) named after the GET/POST verbs. It also allows for automagic parsing of (eg) JSON bodys into appropriate associative arrays for easy consumption by dependant code.
I swear auth wasn't in the docs when lumen dropped.
&gt;Why be a close-minded twat that thinks their way is the only way? Pretty much every language ever has given you multiple ways to perform the same task. Yes, another great achievement could be, that certain users would start looking for another language. 
I agree, and I'm sure it's a good post, just saying it'd be useful.
*Exception.... Thanks!
It's not a real time investment. Both frameworks are easy to use. One framework forces ~20 MS of auto loading at the start of every request. Shaving that off seems like a no brainer in the end. Then combined with that you have lower memory requirements. That allows for more workers, processes, and slimmer nodes for better scaling. Our API clusters are incredibly fast as a result. This makes using SPAs even faster than they already are. Fire off 20+ async requests? No visible lag/loading on the client whatsoever.
I agree - it's really meant to prevent people who write shoddy code from shooting themselves in the foot. You won't see it as much for any model/controller logic, but when there's a mixed php/html template written by a designer who mostly just knows HTML and CSS, it's okay as a failsafe. I often go through removing the `or die`s from anything in my space when I do a concrete5 project. My point isn't that it's a good idea - it's not, it's just not always an awful idea.
I said APC out of years of using it. We are currently running PHP 5.6, of course OpCache is the new option. Both are pretty much the same in concept. You are the best in pointing out the latest naming conventions, I give you that. If you understood how OpCache works, you'd know that it stores a *compiled* bytecode of the code, the code still needs to be loaded. That cost is non-negligible (again, do your own tests) when you have to load all of files a framework usually requires. If your services are daemon-based PHP scripts, I imagine you are using React or something similar (otherwise your services would be able to handle only one request at a time). It's an interesting approach, when we started working with this codebase, React wasn't available, and I wouldn't trust it with production code (you know, the one that makes money) right now. If they are written in another language, then you are comparing apples with oranges. Also, your views might be quite simple for your project but they simply aren't for our case. Our controllers are just not that simple. You can keep up with PHP libraries all you want, just make sure you have good test coverage where they intersect. Anyway, this has become a very long thread and it's obviously not going anywhere since we obviously don't care about the same things (and you prefer to discuss in a pretty obnoxious and demeaning way). Good day to you.
They appear to be running. Before I added the return on laravel's default TestCase, if I miss out the Artisan::call('migrate') in setUp() then it kicked up a fuss about not finding the table. It seems to me that it's trying to truncate the tables before the setUp() function calls the migrations. Is it possible to disable this pre-delete functionality?
sometimes, when i literally can't even, i don't type out the commands entirely. composer sel #self-update composer ins #install composer u #update and so on
&gt; If you understood how OpCache works, you'd know that it stores a compiled bytecode of the code, the code still needs to be loaded. That cost is non-negligible (again, do your own tests) when you have to load all of files a framework usually requires. You're still trying to talk about some hypothetical heavy framework which this straw man you're arguing with uses. Fine. &gt;If your services are daemon-based PHP scripts, I imagine you are using React or something similar (otherwise your services would be able to handle only one request at a time). Yes, of course I can't do a basic event loop without a framework. It's 5 lines of code, but we must have a framework. No surprise here, you're at least consistent in your confusion. &gt; Also, your views might be quite simple for your project but they simply aren't for our case. Our controllers are just not that simple. Dare you say what is so "complex" in your views and controllers? Reusable parametric components &amp; layouts can be simple functions and classes. Sugaring them to "look like templates" is possible, but largely superfluous when the code is already succinct and you have the right pattern for use in a template. Or should we just leave it at that your app is vaguely more complex and mine's vaguely simpler in order to satisfy your pre-existing bias? Ok, stay the course. Never change. I think the simple truth hidden behind your "this needs framework" attitude is that you're vastly overestimating what they do under the hood. You can use frameworks, but you don't understand the implementation of the frameworks you're using. If you did, all that mystique you apply to them as black boxes that give you the magic you need for your apps would fall off and we would be able to speak as two engineers. Instead, I'm talking to a developer who's one level removed from a WordPress theme writer. Good day to you too.
When you want performances in php you need to use load balancing / caching / avoid ORM, etc etc
We have a 60+ machine cluster. Distributed in 3 datacenters around the world and don't touch a database within PHP.
thanks
Thanks, that works great. Do you know how I could have 2 pages. One that displays when there is no domain present in the URL and then one that shows what you posted if there is a domain in the URL? 
&gt; t kicked up a fuss about not finding the table. &gt; It seems to me that it's trying to truncate the tables before the setUp() function calls the migrations. Is it possible to disable this pre-delete functionality? I do not think the tables are truncated, but rather the database is dropped in the memory. A possible solution for this is to create a database on the disk, but those are considerably slower. What we do for unittesting is using a normal postgres database, and do everything in transactions (and roll them back after the test)
Oddly enough I was looking at doing exactly this last week at work, but haven't gotten to it yet. Thanks for the post!
I've been using Phalcon for about six months, and I'm really happy with it. Loose coupling + modern design are great. The devtools automatically creates your migrations, and can set up a multi-module site for you (multiple websites in one code base). The performance stuff is a bonus.
Huum, I didn't knew how to use and understand Valgrind's output, but I see it now. Gonna do something about it. Also, could you explain me how it doesn't pass without Valgrind but pass with it ? Thanks !
The crash will probably happen or not happen based on what value is the the uninitialized memory that is being accessed here. When running with valgrind a different value might end up in there, than when running without valgrind.
Does that mean that you stay with Drupal7 or do you plan start using OO soon? Really, I understand your argument. OO is made for human beings to enable them to build big application and maintain them later on. It's like using a Bike or a Car to get somewhere. Sure, in some way, it's just another form of moving. And if you only need short distances to take, then a Bike may be the better and cleaner alternative.
Just to experiment I've gone back to a mysql db and added an echo to the getDataSet() function and the following at the start of the test: echo "\n".(int)$this-&gt;getConnection()-&gt;getRowCount('a_table')."\n"; but the output doesn't look right. F 0 Loading dataset F 0 Loading dataset . 0 Loading dataset Seems to me that it fails the test, asserts that there are no rows in the table and then loads the dataset at the end. Or does phpunit cache outputs until after the tests are done?
Ah, you caught me! I do, just not proofreading enough. This is an incredibly important distinction to make :) 
Never heard of Brelin.
I have three honest questions. 1. How many Great PHP coders live in Germany? 2. How many great PHP coders are able and willing to relocate internationally to a place where people do not speak their language, just for a job, when we hear all the time that Europe pays less than America for coders? 3. What about the job, specifically, requires PHP developers to be present in the office? I work 3,000 miles away from my clients and it has never hurt productivity. [EDIT: It was much more of a critique on the need to source rare talent without allowing telecommuting, even when telecommuting isn't exactly a hard requirement for the profession. Sorry if my wording caused you to ignore the forest for the trees. If Germany is a bad example, substitute Kansas or Wyoming.]
Jenkins looks great, I wish there was a bitbucket alternative.
You may not even need PHP for this, check out [Apache SSI aka Server Side Includes](http://httpd.apache.org/docs/2.2/howto/ssi.html)
There isn't much to it. Basically you need two files: /vendor/composer/autoload_classmap.php &lt;-- returns an array map with $class =&gt; $location /vendor/composer/autoload_files.php &lt;-- returns an array list of files to preload You feed the first in your autoloader: spl_autoload_register(function ($class) use ($map) { if (isset($map[$class])) require $map[$class]; }); And for the second, the location of each preloaded file always begins with your "{root}/vendor" path followed by the exact offending package name. So if in a given request I need to use package "vendor/foo" and I know it has preloaded files, I can call my helper init_package("vendor/foo") for example, which has the preloaded file locations indexed by package and load the files for that package. Now... it's possible also to automate this in the preloader. I.e. if it detects a class from package "x/y" is being loaded, it also loads the files that package needs. I haven't done that, most libraries thankfully don't preload stuff willy nilly. So I explicitly preload files for a given package in my facades (like I do for SwiftMailer for example). But it's technically doable.
You haven't really asked a question about whats wrong, but I'm guessing you, like I did one day, found Facebook's documentation insufficient to those who are not familiar with oAuth APIs. Skip Facebook's documentation and take a look at the readme on [Github](https://github.com/facebook/facebook-php-sdk-v4). It provides a better usage example.
I go with what pays the bills. My employer and my clients all want drupal. In the past 11 years I have worked with bespoke OOP code, bespoke procedural code, Symfony, Zend Framework, Cake PHP, Drupal 6, Drupal 7 and Laravel. I don't care what I work with, as long as I'm putting food on the table for my family.
&gt; How many Great PHP coders live in Germany? That's a little bit racist and also wrong, as there's more than you would expect by population. Off the top of my head, NikiC (internals), Bweobi (internals), Sebastian Bergman (phpunit), schmittjoe (Scrutinzer), Seldaek (Composer (when he's not in London)), and multiple people called Markus. &gt; How many great PHP coders are able and willing to relocate internationally to a place where people do not speak their language, just for a job, when we hear all the time that Europe pays less than America for coders? Again, you're assuming that someone would need to relocate, but anyway Germany has good healthcare that doesn't bankrupt people if they need to use it, and the police tend not to shoot people all the time. Even if someone did need to relocate, Germany is a nice place to live. The job doesn't actually say that speaking German is a requirement. I doubt that my GCSE level German would be enough for me to live in the country, but for anyone who has slightly better German it probably wouldn't be a problem. &gt; I work 3,000 miles away from my clients and it has never hurt productivity. Well, good for you, but it sounds like it's not primarily a development role, it's a front line support / development as marketing role. Going to conferences, giving presentations, going to give onsite support all require a human to be there. 
Although Composer can autoload individual files for you which is half way there.
Any post about Jenkins and Docker? 
Ultimately I think this setups is best: $request-&gt;query(); // to get the query Data instance $request-&gt;data(); // to get the body Data instance $request-&gt;query()-&gt;get('id', null); //get field with default value Now I need to decide on the shortcut to get(), the ideas I have are: $request-&gt;query()-&gt;pixie; //using __get() $request-&gt;query('pixie', 5); //Make it so if the key is passed to query() method it is treated as -&gt;query()-&gt;get() $request-&gt;getQuery('pixie', 5); //Last minute contender, a blatant copy form Zend Framework: $request-&gt;fromQuery('pixie', 5); 
You're (one of) the reason my gf hates her own country so much.
Yeah... I'll edit that as soon as I'm at my computer.
I'm going to go ahead and answer your questions as honestly as I can: 1. I have no idea. 2. Contentful would be a great company to work for, and if I were at a different place in my life I would love to move to Germany. Adventure of a lifetime and all that. Don't assume everyone wants the same things out of life you do. 3. They told me they are a tight knit group and want to keep that going. They decided not to hire remotely for now.
if youre going to use symfony2 components later, it might be efficient to use the symfony2 framework for this project as well (though some other frameworks use symfony components) I read what you said about feeling overwhelmed and can relate, but also think that with persistence youd be fine, the symfony2 cookbook/documentation is really good. I only learned of PHP frameworks a couple years ago, and went from cake to symfony2. Can confirm symfony has what you need to handle the users(security component or FOSUSerBundle), entities (w/ doctrine), and email(SwiftMailer). Ive learned all of those through the docs/cookbooks. no experience with laravel or yii though, would assume either would work.
That way `get_class()` is a shortcut to `get_class($this)` (*edit: actually not see the answer below*), . But yeah it should be used carefully if you pass an object (i.e. check it's not null).
We only allow job ads that allow full telecommuting.
Next step is probably from this site http://jenkins-php.org/ just with more details/explanation added in
I might do a follow-up post soon about implementing Docker + Jenkins soon when I've finished implementing it in my stack
Yahoo Finance API is also part of my CurrencyConverter library. It allows you to add multiple providers. https://github.com/sprain/SprainCurrencyConverter
Well the problem with 'body' is that it is more synonymous with input stream. Even in PSR-7. ParsedBody is much nicer yes, but beginners might not find it intuitive at all
What are the advantages of using it over Silex, Slim or other well-established micro-frameworks?
How is this blindly preloading? { "autoload": { "files": ["src/MyLibrary/functions.php"] } } Or are you complaining that it doesn't offer enough fine grain control over what is loaded for each request? Then sure you'll want to roll your own autoloader.
I don't really want to have mixed return types in my functions. I like your idea with body-&gt;stream(), but if the fields are not present then the only accessible method with be the stream() one. 
None of the methods in my examples have "mixed" return results, what are you referring to?
$request-&gt;serverRequest doesn't make sense. Are you set on making this confusing or :)?
What you call alias() is typically called bind(). An implementation is not an "alias" of an interface by a long shot, it's the wrong word for this. You insist this is not a DI container, yet you implement one. Which.. why the contradiction? Full disclosure: I personally use a factory for recursively constructing dependencies on demand, and I haven't seen a need for a dedicated component to do that job for me. 
You have no examples that I see.
Really? why doesn't it? My Request class wraps around the PSR-7 ServerRequest. It seems logical to have a method to access it
If I have to use ServerRequest to use your request, why have a wrapper at all? Never mind...
I agree, and it would be even better if that opinionated routing scheme was exposed to templates through some route generation helper so that you could easily create links automatically.
No I mean I open your repo on github and I see not even the most basic code example anywhere about using your component. You have no directory "examples", you have no code examples in the README.
Testing. I know there are a lot of information out there regarding testing, but there's so much that I'm having a hard time grasping it. I'm starting a new Laravel project in a couple of weeks, which I want to write tests for, and I'm really not sure how/where to start. 
The difference between calling a method to pass two classname strings vs. defining a method that returns an instance of an interface are kind of trivial: $xyz = new Aurex(); $xyz-&gt;alias("Foo\Bar\BazInterface", "Foo\Bar\BazImplementation"); $xyz-&gt;alias("Foo\Bar\QuxInterface", "Foo\Bar\QuxImplementation"); ... $baz = $xyz-&gt;make('Foo\Bar\BazInterface'); class Factory { function getQuxInterface() { return new QuxImplementation(); } function getBazInterface() { return new BazImplementation($this-&gt;getQux()); } ... $baz = $xyz-&gt;getBazInterface(); Having a container is a valid choice, if you feel you need it, but looking at the above, I see not enough meat to warrant using one. Simple code is just as good (and faster). I don't understand your question about "implementing DI container in the controllers". When did I mention "in the controllers"? I'm only saying you're implementing a DI container. It's how it's called. Nothing bad in it, just call it what it is.
I just looked at the slim framework example below and I understand exactly what is needed... like an example of a route, a controller, the DI working and the template code and rendered. Maybe with pics... thanks for the feedback on this, sometimes it's hard to think of these things :-)
NP. Good luck.
The aliases are stored in a config file so you don't need to call those methods, you just add the two strings to the yaml file if you need them (I mean sure, that's effectively what it does in a `foreach()` loop, but still :P). On the flip-side, maybe you're not always using objects that require aliases; as a result, no factory needed, you just type hint for this object anywhere and *bam* - it's passed in for you. The aim is you can pull in libraries via composer and, assuming they don't have any scalar constructor parameters (that would require a factory, which you can then DI anyway with auryn) like GuzzleHTTP is the first thing that comes to mind, you can add the type hint and instantly have it.
OK so I don't see the difference with other containers, they all store the shared instances (in order to be able to always inject the same instance). Then a container can resolve dependencies using autowiring, annotations, YAML/XML/INI or PHP configuration but it's just an implementation detail. In the end it's always the same goal: create dependency graphs. And "service locator" is a way to use a container/injector/factory/whatever. [This part in your framework](https://github.com/J7mbo/Aurex/blob/e084b9165b61799a25a4da8a2dd5e8902226d828/lib/Framework/Module/ModuleLoader.php#L43) uses the injector as a service locator/factory: it's asking "get me an instance with all its dependencies initialized". The method can be named `get` or `make` or `provide`, the end result is the same: we want the instance to be able to use it. We agree that framework users should avoid using the container directly if they want to code using SOLID principles, but frameworks have to "locate objects" (or services, or any other name). They have to ask the injector/container directly (just like you do in the example I linked), and that's fine. This isn't black and white.
Well serverrequest lacks methods for retrieving a single value from queryparams etc. This is the functionality I am adding
Think OP meant ternary is pretty hard to read in factory methods.
Yeah, the OS community decided on a ContainerInterop which puts forward the registry idea... I'd like to stay away from that if poss
Scalar parameters are 'defined' with a `:` prefix: $injector = new Auryn\Injector; $injector-&gt;share('PDO'); $injector-&gt;define('PDO', [ ':dsn' =&gt; 'mysql:dbname=testdb;host=127.0.0.1', ':username' =&gt; 'dbuser', ':passwd' =&gt; 'dbpass' ]); $db = $injector-&gt;make('PDO'); ... from the Auryn docs. I would put these in a config file and have the definitions read from there and easily changegable, or do what you do and use a factory. If you don't like the YAML config (a lot of people don't like YAML, I LOVE it :P) But then I can DI the factory anywhere in the application with just a type hint.
Extending it is a bad idea, because the whole point of ServerRequest is that it is being provided externally by something else. Like in the middleware case the ServerRequest is what is being forwarder around. The wrapping is just for convenience
The hamburger does not work on mobile. I was clicking it furiously expecting links to important documentation and examples. The fact that it did not return anything led me to leave the site post haste. 
FYI: Updated the Repo, you're now able to supply commands with --c so you can generate only the commands you need (create, store, show, index, edit, update, destroy)
You can decorate it and still pass it around as-is (read up on decorators). But up to you. If it's just for convenience you might want to rethink your approach. For example: $fieldVal = RequestUtils::getField($request, 'foobar', 'default'); Or maybe: $rh = new RequestHelper($request); $fieldVal = $rh-&gt;field('foobar', 'default');
hamburgers are food, don't put it under your mouse!
&gt; How'd you auto-wire a boolean parameter? Or a string one? Or a number? Or an array? Just like all other auto-wiring works; give it a unique name. Currently this is implemented by the Injector::defineParam in Auryn, due to the lack of strong types e.g. function foo($tmpPath) { //whatever } $injector-&gt;defineParam('tmpPath', '/temp/subdir'); I am hopeful that for PHP 8 (or maybe 9) we would be able to have strong scalar types which would allow for something like: class TmpPath extends string {} function foo(TmpPath $tmpPath) { //whatever } There is no real difference between the two, but one is easier to reason about, which makes it easier to do static analysis on. 
I found it best to watch Jeffery Way on YouTube https://www.youtube.com/watch?v=ajoFwWwSHTI Really helped me a long to test.
I mean, say you create a `Factory` object. You're still going to need to DI that `Factory` object somewhere in your application. So you're going to have to use a container to DI this for you by registering it which takes a few lines of code. The alternative is creating the factory as you suggest, then type hinting for it and you are handed it in your object. You can also `define()` an object's requirement to use a specific object. I did this for a `Config` object, and using a configuration file defining which `Config` object would get a unique set of values, so I could do `class Object1 { public function __construct(Config $c) { } }` and `class Object2 { public function __construct(Config $c) {} }` and they would both have different objects with different values. The above does require you to give not insignificant thought to your architecture though.
Is the `$app` a god object that does more than it should do? It seems like it is, if it's the factory initialised as well. Let's say you're not creating this factory and passing it straight to your Application - because tbh that's not a common thing to do and move onto a more common use case if that's alright with you: You're a standard user and you're already at your controller layer. You want this factory. What do you do? - You can do `new Factory` in your controller. I am strongly against this as I believe an object's requirements should be visible from the constructor and method signatures *only*. - You can type hint for `Factory` in the controller constructor or method signature which makes it *clear* what the object needs to function as expected. - You can set up your container to inject this factory which, for every single factory in an application of moderate size would be a *huge* amount. I'm pulling for no. 2 tbh.
&gt; You're a standard user and you're already at your controller layer. You want this factory. What do you do? You don't want this factory and you have no access to it. Only the app has it (or is it, whatever I chose). Whatever you need is provided to you *by* the factory, via your constructor. You think I'm implementing service location. I'm not. Controllers only have access only to components that they should have access to, by requesting their "ControllerContext" object which only provides lazy access to controller dependencies (which includes basically controller helpers and domain services). Read about the "encapsulated context" pattern. In fact, the risk is much bigger with your container than a Controller might add something that it shouldn't have access to. My controllers can't just add "\PDO" to their constructor and get it, so architectural mess averted. With your container, it's very much possible to do so.
I understand composition root. What about how to instantiate and use the `Factory` in a typical dev's work-day, though? The ability to create their factory, type hint for it, then use it, imho significantly lowers implementation time.
You really shouldn't assume that a framework dev doesn't know about decorators))) The problem with using decorator for this is that ServerRequest already had a pretty extensive interface, with a lot of irrelevant methods which I don't need like e.g. withHeader. Yes, I am doing what you call a RequestHelper. I hope now you understand what nudged me to use data() for the method name then ?
As I said only the app has access to (or *is*) the biggest app factory. Controllers get injected their own context (a "subset of the app factory" if you will, although that's kind of inaccurate description) via their constructor. Controllers instantiate nothing. They use what's given to them.
Thanks for that example! I didn't understand the nuance there. 
I agree on the Controller front, which is why being able to typehint for a `Factory` in the controller's constructor or method and use it instantly without any other configuration is great If I decide I don't want to use that object any more, I remove the typehint and don't need touch any DiC or other configuration. Some people just don't like these sort of injectors and prefer others, that's fine.
No, ok let's start over. I use a pattern which is a superset of a "factory" called "encapsulated context". It's a plain PHP class with plain PHP methods. No arrays, no DiC. Now, I have one "app context", which holds methods for everything I'll need to construct. Every dependency has a method. When I have a layer of classes, like controllers, which all need access to the same dependencies, I wrap this in a "layer context", which is a smaller factory exposing only what I want controllers to have access to. The "app context" has getControllerContext() method. The actual app context is not accessible *anywhere except the app*. Controllers have constructors like that: __construct(ControllerContext $ctx) {} And then they can lazily fetch what they need out of it. I avoid "subcontexts" for specific components, opting to just inject in the app factory like anyone would. Sub-context are suitable for passing configuration / deps to large modules, app layers, and sub-apps. Then they can provide a Context interface for me to fulfill, and I fulfill it. Regarding being "instantaneous" there's hardly anything more instantaneous than a single line factory method with "new" in it. Why are we pretending as if typing "new" is such a burden all of a sudden. It's not.
It's not great to be able to just typehint Factory and get it, because it's simply an obfuscated service locator. In my case I explicitly decide that I will implement and pass ControllerContext to controllers, **and nothing else**. Otherwise if you work in a team, everyone starts adding **whatever** to their constructor and soon your architecture turns into a big ball of mud.
Sure, it requires some managing.. I do see your point about the ball of mud stuff. But then it'd be *very* easy to refactor these simple dependency requirements through additional abstraction, where as having to change a tonne of config strings in this container settings file would be a nightmare! So that ball of mud can be *controlled*, which is what this is about right? Factory wise though, unless your factory is creating all the things, I don't see it as a service locator - if it's building things from a common interface so both you and your IDE know exactly what you're getting back from it then it should be good.
Check out PHPixie, it was built to be lightweight and uses iterators a lot to save memory. Low end VPSes are the place where it really shines
Thanks for the info. :) I will definitely check it out.
&gt; It still hides dependencies and makes a liar of your API. I'm not about to go doing that with my objects. I'm sorry but I can't connect this to anything we're talking about. I'm sure you've read it in a blog somewhere (I think I have as well) and it sounded awesome but how does it make a "liar of my API". Which "API", and what is it "lying" about? 
&gt; I mean, you do if you're having to keep this massive file up-to-date that defines everything required (ala pimple and your DiC 'factories'), but you don't if you're just using concrete objects. They are what they are. Assuming they're tested it's fine, I don't see a problem there. &gt; Still, on the side of writing good code and stopping this ball of mud because of constructor and method parameters, that's what code review from good devs is for, right? Actually no. Code review is a good thing, but if you rely on your architecture being kept in check *only* by code review, with no visible boundaries whatsoever between dependencies used in each module, I consider this a failure of architecture, and an undue burden on whoever is tasked with overseeing every single line that enters your repository. Well designed code "adds friction" to things you don't want to happen and "removes friction" from things you want to happen. If you define that controllers won't, to continue my old example, fetch PDO directly and run random queries, and your container allows your controllers to just add \PDO to their constructors and do that *without friction*, this is in effect accelerating architectural erosion of an app. DI shines when a module needs an implementation of a commonly used interface and you configure and supply the implementation. The fact you inject specific classes is not a plus. It's a practical approach at the start, but if most of what you inject is specific classes, which take other specific classes ad infinitum... well... then in effect you're doing DI for the sake of doing DI, and little else. And using specific classes doesn't mean you don't need to keep code "in check" for going against architectural constraints. Especially with containers that allow "sinning" so easily and invisibly. I just use context and review one interface per module. From that point on, I know this module uses only what I gave it explicitly and nothing else. It saves a ton of work in teams.
Now I'm not sure what these modules are then. "Bundles" in Symfony, for example and from what I gather, are just individual projects with their own configurations. These configurations are in YAML format or similar. The configs are read, the application is run, the controllers are hit. How do we have "liar modules" now? What does a typical "module"'s object API look like, what does it do? It seems to me that they're not logical groupings of project-specific stuff as I initially thought.
I need to try the encapsulated context pattern for myself to see it's advantages (that's how I learn personally). Perhaps there's a way to have the best of both worlds? Assuming your architecture does not have any drawbacks, perhaps auto-wiring DI and contexts. Certainly something worth considering. Again, I need to try for myself as I can't argue against something I have no knowledge of about yet.
Thing is I already have the best of both world from my PoV, because I see only negatives in auto-wiring which I've described at length. You're doing sort of what I'm doing, except with less explicit boundaries between layers/modules, and through a custom syntax that's more verbose, slower at runtime, and has higher "implicitness" ("auto" and "magic" are two suspicious words in any library) which always tends to bite our behind in bigger projects where it's not uncommon to sit and wonder "WTF is this container resolving to?" a bit too frequently. There should be correspondence between "hard to understand, doesn't run properly" and "easy to understand, runs properly". Code which runs properly most of the time, but you don't know quite know why is hard to maintain and in my experience this is what container use results in when a project grows.
Doctrine is fine. 
ZF2 has an out-of-the-box `TableGateway` implementation, but I personally don't use it, as I usually go directly to the ORM for environments that aren't under too high load.
no because you can also add dynamic features like any framework. so, it is more powerfull than simply a static site generator.
First can I suggest something else I noticed. The reason you have those... curiously long setting strings is because your config is global and static. Here's how the same functionality looks in my apps: class App { function __construct(AppConfig $cfg) { echo $cfg-&gt;envId(); // One of: "live", "staging", "dev-joe", "dev-maria", etc. } } Now I implement and pass the Config instance to the application and every name there is short and my IDE autocompletes it for me. There's no name collision or anything, because it's not static and global, it's just for this app instance. Now, onto your example, I'd definitely go for the latter. Not only is it shorter. Not only is it more readable. It's also *faster for PHP to execute*, compared to running the same function twice. Local function variables are by far the fastest things to access in a function. Use them any time you can to cache the result of a function call, even if you use it just twice. BTW, this is not called "ternary". Ternary refers specifically to uses of the ternary operator "? :", like this: $booleanString = $boolean ? "true" : "false"; It's called "ternary" because most operators use one argument (like "not": !$foo) or two arguments (like $foo + $bar) and this one uses three (i.e. "ternary"). Also may I suggest if you type this code often, you simply have a method for it: function testOrLive() { return Mage::getStoreConfig('microsapisettings/basicmicrosapisettingsgroup/arewelive'); } function configureXyz() { $testOrLive = $this-&gt;testOrLive(); $url = Mage::getStoreConfig('microsapisettings/' . $testOrLive . 'microsapisettingsgroup/' . $testOrLive . 'apiurl'); $this-&gt;setMicrosURL($url); } Notice I added a second variable, $url, to aid readability. Don't be afraid to do that. Again, local vars cost you nothing. PHP optimizes them very well.
ha ha ha blind optimism?
It might be worth mentioning *why* `foo() or die $!;` is a common pattern in Perl, but not recommended in PHP. Namely, in Perl `die` is how you spell `throw`. PHP inherited the name, but not the semantics.
I'd probably refactor this a bit like so: $basicConfigRoot = 'microsapisettings/basicmicrosapisettingsgroup/'; $areWeLive = Mage::getStoreConfig($basicConfigRoot . 'arewelive'); $shippingMethod = Mage::getStoreConfig($basicConfigRoot . 'shippingmethodforpickup'); $currentConfigRoot = 'microsapisettings/' . $areWeLive . 'microsapisettingsgroup/'; $orderTypeConfigKey = $order-&gt;getShippingMethod() == $shippingMethod ? 'apipickupsku' : 'apideliverysku'; $orderType = (int) Mage::getStoreConfig($currentConfigRoot . $areWeLive . $orderTypeConfigKey); $this-&gt;setCheckOrderType($orderType); Might be buggy I wrote this quickly, but you get the idea. And I even kept the ternary ;) EDIT: Fixed two lines out of order. Oops.
Nice! Yeah, I'm looking over that entire project and pointing out to my coworker where I went wrong, and how it could be better. He has very little real world experience and I have no college experience. It's the perfect storm!
didnt it pass the RFC voting phase a long time ago? 
&gt; it's really two separate things: input validation, and form output I really like the *idea* of XForms, where you define your form and all its rules in one place. I once started a project that would validate the input based on the XForms markup, I think it's sort of a holy grail. HTML5 has some basic validation markup builtin. I wonder how useful a library that would used those definitions and apply it to the input, or generate an ruleset that could be passed to `filter_input_array()`. I just think it makes a lot of sense to define both sides in one place as much as possible.
Thanks /u/changetip $2
/u/philsturgeon, Fab1anFab1an wants to send you a Bitcoin tip for 8,891 bits ($2.00). Follow me to **[collect it](https://www.changetip.com/collect/728001).** -- [^^what ^^is ^^ChangeTip?](https://www.reddit.com/r/changetip/wiki/tipping-on-reddit)
Depends on what you're trying to do. If you're going to concentrate on front-end development, JavaScript is a must. For backend development, PHP, Java, C#, JavaScript, Ruby are all great languages. People like to bash on PHP because there are ton of people who use PHP so the standard bell curve applies.
I am looking for a back end to tie up to databases. I feel this will make me worth more in the short term. Ill get familure with javascript, but right now it makes no sense to me. I guess validating the users input before its even sent right?
Here's the thing, you validate input at your service layer (or model layer, or domain layer, however you prefer to call it) and that layer doesn't know, and shouldn't care how this data was produced. I.e. your service shouldn't care if a list of options was produced from a radio button group, a select box, or a custom graphical widget. I.e. we don't want to couple the *presentation* of our forms with its *structure*. We've had to learn that lesson over and over again in various different environments, yet the temptation to couple function and presentation remains. That said, sure, it might be handy to define both in one place, at least at some stage. So I propose the "builder" pattern. Where you define the form at the builder, both validation and presentation at once, then build *other* objects from it, which hold only aspects of the information you have entered (and which you can create independently as well). $builder = new FormBuilder(); $builder-&gt;addTextField('foo', 'Foo label')-&gt;trim()-&gt;hasLengthMin(8)-&gt;hasLengthMax(32)-&gt;isRegexMatch('/^\w+$/'); $builder-&gt;addSelectBox('bar', 'Bar label', '2' /* default */)-&gt;add('1', 'Option 1')-&gt;add('2', 'Option 2'); $builder-&gt;addCheckBox('baz', 'Baz label', true /* default, for ex. license agreement */)-&gt;isEqualTo(true); // $validator is a component in a separate library that validates the above form structure // without knowing anything about $builder or form presentation. $builder is only a helper. $validator = $builder-&gt;buildValidator(); // $viewWidget knows nothing about the intricate rules of validation, it just renders a // form and uses some simple validation checks that HTML5 supports. It also knows nothing // about $builder and is yet another independent library. $viewWidget = $builder-&gt;buildViewWidget(); // In the factory/container/whatever of the service taking this input: return new SomeService($validator); // Will use to validate its input. // In the controller, when returning a view: return new View($variablesArray + ['formWidget' =&gt; $viewWidget]); And then eventually the service calls $validator-&gt;validate() and the view calls $formWidget-&gt;render(). The difference is subtle here. We do *not* pass the builder around. And we can create both a validator and a view widget *independently without a form builder*. This way we have three components with one responsibility: 1. Building other objects. 2. Validating input. 3. Rendering form. Instead of one object with two responsibilities: 1. Validating input and rendering form. So when time comes for us to add a customization to the form we can't have in the builder, we can decouple those without major earthquakes in the codebase. But I honestly still find it of very little benefit for real projects, because presentations concerns and validation concerns overlap so little in practice. Sure, it's the same form field names, but aside from that... well... they're different beasts. I much prefer to define form presentation in one place and input validation in another, and have them shake hands though the input passed from one to the other.
I am learning php and MySQL over the summer. I just think that javascripting will be pretty easy to learn because I will just use premade functions and then edit them.
What is discussed today on internals is that they finished discussing the implementation details (this rfc worked backwards, they voted first, discussed after) and the author published a [pull request](https://github.com/php/php-src/pull/1221).
The PHP learning curve is so low that even very inexperienced developers can use it to create working software. The upside of course is PHP is easy to learn. The downside is the internet is flooded with bad sites/scripts written by inexperienced users. Those bad sites/scripts have given the language a bad name.
XForms took care of that by separating the model from the view (see examples at http://www.w3.org/TR/2003/REC-xforms-20031014/slice2.html). In an XHTML document, you could put an XForms `&lt;model&gt;` in the page `&lt;head&gt;` that defines the structure and rules of the data to be collected, and in the body, you have fields that reference parts of the model. My idea was that the model is basically the "builder" that you described, but defined declaratively in XML instead of procedurally in whatever language you happen to be using. I never finished that project (and this was over 10 years ago) and XForms never took off on the web (especially after XHTML died). But I still like that concept: define form rules in a way that the presentation and the validation can use them.
&gt; XForms took care of that by separating the model from the view (see examples at http://www.w3.org/TR/2003/REC-xforms-20031014/slice2.html). In an XHTML document, you could put an XForms &lt;model&gt; in the page &lt;head&gt; that defines the structure and rules of the data to be collected, and in the body, you have fields that reference parts of the model. That's neat. But you can't fully define a model declaratively on the client anyway (i.e. in XForms). I mean, how do you define in XForms, for example "when this user registers, their email should be unique in the database". Without full domain knowledge, the XForms model is not unlike the HTML5 validation attributes for forms. They're like a toy model, only translating the most basic of rules into the form for user convenience and nothing more. I believe this is one reason XForms didn't pick up. They had a nice idea, but were solving the problem of the form model at the wrong place (the client) as they didn't have access to solve it at the right place (the server). Would XHTML have been a local GUI platform for desktop apps, maybe it'd have better success, as with those the model and the presentation are in the same place physically (say when you enter data in Excel, Excel doesn't call Microsoft.com about validating it, it validates it locally and that's all). But with remote apps, i.e. web sites, the model is always at the server. HTML5 is an adequate presentation layer with just enough semantics thrown in here and there. Headings, articles, list, links, micro formats. But even with CSS it (if we're for real) remains focused on presentation, because that's really what we need. And this is why it has success. I treat views in PHP apps entirely presentationally. Sure, I think about semantical tags and SEO, but to me this is still presentation just with a slightly different audience (search engines and screen readers). I validate at the server, and send back errors to the client via JSON to display via JS (without reload). I see client-side validation purely as a performance optimization for overloaded servers, because AJAX-based validation is close enough to real time as it is, and anything else would be pointless in most cases.
Validation in JavaScript is purely a user experience thing, to give the user immediate feedback as to whether their input is correct or not. It's not a replacement for server-side validation. You either need to do both or just PHP.
If you want to be worth more, the more conservative choice is PHP. However, with that said, JS developers might be needed now as it is growing as a server side language. I'm sure it will stick around, but there is no doubt in my mind PHP is a more conservative choice. However, I work with both JS and PHP on a daily basis. I think JS, currently, is a lot more exciting. I'd recommend knowing both of them. Master one, but become familiar with the other.
It's not like what they say is complete rubbish, it was true at one point and there is still plenty to criticise about PHP (as there is with any language). Most of the arguments are stuck 5-10 years in the past though. As a language and as a community PHP has come along way in this time.
Javascript can be used server side. Just sayin'
Well the clear choice then is to learn php and be familiar with java then.
But is it up to par with the other options?
Yes, I know. Looking at the context of the comment it's pretty clear what I'm taking about.
Unstructured code in this context is referring to application design. Old php was very prodecural, so you would get html mixed in with database calls and file includes all over the place. A real mess. Modern php, regardless of framework, is much better at splitting functionality out into classes and the whole application is structured in such a way where it can be easily extended and enhanced without lots of rewriting. 
I'm introducing "Omega", which is based on OP's framework and specializes in providing a comprehensive view layer for JSON REST APIs. &lt;?php class Ω extends μ {function view($f,$d=[]){return json_encode($d);}} I'm also setting up a Kickstarter page where you can support its ongoing development.
I'm a PHP dev, but I'm gravitating towards JS. Basically, JS frameworks (Backbone, Angular, Node, Ember, etc.) are reducing the amount of PHP and other server-side programming that was previously necessary. Also, [just take a look at the average salary of a PHP dev vs. a JS dev](https://gooroo.io/GoorooTHINK/Article/16225/Programming-languages--salaries-and-demand-October-2014/17081#.VTV0OK3BzRY). Javascript is no longer just for client-side validation and flashy animation. The rise of single page architecture (via AJAX) has made JS more important than ever.
Oh I can read these. What language are you moving twords?
I knew there was a reason I installed a µ key on my keyboard
Regardless of which framework you choose, it may be helpful to [read this series of posts from Fabien Potencier about how to create a framework from the Symfony components](http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1). It will walk you through the thought process behind each part of a framework, from start to finish. It's very helpful for showing you why something is done a particular way.
JavaScript is ok, but not good for larger apps because it has very immature OOP &amp; non-existent static analysis enabling features, like type hinting, which makes the benefits of IDE integration for JS development underwhelming. This is remedied to a large degree by systems like Facebook's Flow or TypeScript (it's great, try it) and I have seen myself code more in TypeScript lately, even for components I'd previously do in PHP, or even Java. That said... the server-side platform for JavaScript (Node.JS) is still within a specific niche (high number of long-running HTTP processes with light CPU load) and not as well-rounded or mature as PHP for general purpose websites and apps. It's also more unstable (one blocking script and Node.JS goes poof; PHP is very resilient in that regard). PHP and JavaScript really go together. Either it'd be PHP and Node.JS on the server (complementary tasks). Or PHP on the server and JavaScript on the client. You can't pick one over the other. Study both, you'll need both. And ignore the naysayers. I've been a very vocal critic of PHP in the past (and I remain one to a degree) but I'm amazed at the speed it's making progress in the last two years. PHP7 will be amazing both under the hood and in terms of user-facing features. Good times ahead.
What do you mean "work" for PHP? It can document a specification for your API's, and (with Dredd) you can bounce off all your endpoints and check for compliance with the specification. I'm using it on a PHP project right now, but it never actually reads over any PHP code, just hits the API.
Yes. There is for example Coffeescript. However I haven't heard of anything compiling PHP into different language. What is it you like so much about its syntax?
I like the dollar signs before the variables. I also love how you echo the text instead of print or consol.writeline
So you go and validate through JavaScript but not php.... Someone goes and finds how to manipulate the data sent to the server, sends sql commands, server and data is fucked... Hope you have a recent backup, and I hope it's not mission critical. Validate At least using php on the server. is just nice to have for the end users. 
&gt; If composer's autoloader wouldn't have this feature, it wouldn't be abused, it's quite simple. Okay? Sorry, but it's beyond absurd to suggest that a feature shouldn't exist because people abuse it. &gt; Compared to patching and forking every individual package [...] This is hyperbole. Not every package abuses the autoloader initialization; in fact, hardly any of them do. You might have a wonky definition of what constitutes abuse, though. If they're actually initializing the autoloading, that's not abuse - even if it's loading things that you may not use on the request. If they're doing other initialization that has nothing to do with autoloading - that's abuse. &gt; Add a few of those "minimal" libraries and suddenly it's very maximal. This is why I said "it doesn't scale". Did you benchmark this? I'm curious to see your findings.
Very much so. Mine is just a simple explanation, but I'm sure there are other reasons lol
 Had some fun and made one that's CLI friendly. https://github.com/mrferos/lambda
Do you have some benchmarks to back up "20-30% performance loss"? I'd like to see the actual numbers.
No, sorry. I did those long ago, noted the results and adapted my code accordingly. Do your own benchmarks, and also act accordingly. For me it mattered. For you, it depends.
Cool, thanks.
A makeover.
This makes me want to write a framework that uses emoji for all the function names, for basically the same reasons.
&gt; What language are you moving twords? Most probably Python. (which is still pathetic... ) no interfaces/no (public.protected,private)/ has to pass 'self' to every methods/no typehinting/(no *real* threading)/slow (php7 is way faster that python)/ 
The options are not mutually exclusive. To me, the overuse of exceptions leads to similar bad programming practices found when using goto jump statements. It breaks program flow into situations where if you throw your exception, your cleanup operations may be interrupted before they complete (unsettling class variables, deleting form db). Take for example: to be able to see if the file exists before one attempts to read it. I'm more on the side of dealing with checking my input/parameters, even so, you still need to try/catch because there is a slight possibility that even if you check that the file exists, it may be deleted be the operating system by the time you get to read it (micro seconds later). I've heard that your doing exceptions wrong if your try and catch in the same function. Essentially, it is said that if you try it should be caught in the calling function. For there is little reason to 'throw' something that you can deal with inside the function. This is a hot debate and I'm sure people have points on the three sides (of this proverbial cylinder) which we can circle around. 
Took me a second to realize I wasn't in /r/lolphp
+1
Sounds like they just took all the "traditional" stuff and moved it into an extension. Not that that's bad, but the number of files in your project tree doesn't make a huge difference. Many frameworks live in the vendor/ folder, or can be packaged into a .phar without cluttering your userland code. Those extraneous folders are just to help keep you organized. Some frameworks are more opinionated than others; I guess it depends what you like. I don't mind a bit of consistency.
I already successfully funded my project called ß. It is based on Ω and adds a switch between json and yaml output. &lt;?php class ß extends Ω {function view($f,$d=[],$e=true){if($e){return parent::view($f,$d);}else{return yaml_emit($d);}}}
&gt; This project is a fully-functional Symfony application developed as a learning resource. The application deprecates the old AcmeDemoBundle and it can be considered the reference implementation of the Symfony Best Practices. Well, this is far from a reference implementation of best practices on Symfony. First of all, you see a basic example of bad code, where entities are being populated and saved directly in a controller (https://github.com/symfony/symfony-demo/blob/master/src/AppBundle/Controller/BlogController.php#L78). A good solution for that would be split these two different actions into Hydrators – to populate the entities – and Managers – to save them abstracting the persistence layer away (yeah, here you're coupled to Doctrine's entity manager). Another problem is forms being created on the fly, directly on the controllers (https://github.com/symfony/symfony-demo/blob/master/src/AppBundle/Controller/BlogController.php#L126). Symfony allows you to do that, and that's very, very good. But that doesn't mean you should be doing it. Keep your form implementations separate – really, really far – from your controllers. Each form can have it's own implementation and even each field for that matter. On a basic example like this, that might seem a bit of overhead, but trust me: most applications tend to grow fast and this is a very bad example to follow. One more example of weird practice would be the definition of an `AppBundle` that holds the entire application. Come on? We're passed that since a long time now. Bundles are supposes to integrate thirdy-party libraries into Symfony and add functionality on top of that. Let's not put our code into bundles, that doesn't make sense. Unless, of course, you want to be coupled Symfony's structure from the beginning. Well, at least the layout looks nice. The bottom line for me is: to find out about best practices with Symfony, try to follow successful projects on top of that framework, such as [Sylius](https://github.com/Sylius/Sylius) and so on. Even Sylius has its problems, but at least the community is aware of them and is trying to find solutions for those. 
There are a number of reasons, to name a few: * Failing silently is generally a bad thing. If you are passing a string into the sum($a, $b) function, you're not going to know that it failed unless you test for null, which you might not. If you throw an exception you're going to know immediately that you have supplied it with the incorrect argument type. Failing silently can lead to all sorts of bugs later on that can become very difficult to track down. * You can carry actual data with an exception, by this I mean you can use a different type of exception and add a custom error message to tell the developer what they did wrong. Simply returning null is far more confusing for someone trying to use the function than throwing an InvalidArgumentException with the message "Arguments passed to sum() must be of type integer" or something along those lines. And here we're dealing with a fairly simple function, you could be talking about large APIs that require much more complex usage, in which case returning null is practically useless. * You can handle exceptions. A try/catch block is much more expressive than checking for null after each function but you don't necessarily need to do either. You can essentially surround the entire application in a try/catch block and then implement custom handling of your exceptions (usually this would be some sort of logging but you could also send out alerts etc.), but you can also implement specific try/catch blocks where necessary. All of these features are designed for this purpose and work very well. Exceptions should be thrown when your function/method takes exception to something. This doesn't mean a function should never return null, sometimes it is appropriate and determining that is really on a case-by-case basis. In your example where you literally don't want to execute any code if the function hasn't been provided with two integers, an exception is clearly the proper thing to use. You wouldn't surround this in a try/catch block though, you'd make sure that you're only passing integers into the function. 
Just to make sure you're aware, we're discussing PHP and JavaScript here, Java is a completely separate and unrelated language to JavaScript.
Wordpress and many of these other CMS' have massive codebases, they aren't going to be rewritten in JavaScript anytime soon, no. They also support hundreds of plugins and extensions, it would be a ridiculous amount of work to make any massive changes to them. Will a new CMS written in node.js become popular? Probably. The sheer ubiquity of Wordpress means that it's going to be with us for a very long time still. As for the salary data, it always needs to be considered that there are plenty of people who fall under the banner of "PHP developer" when really they are just maintaining a Wordpress site or something similar. We don't have data showing salaries of PHP developers that are writing actual applications.
If you're just starting to learn web development now, you should decide for yourself if you want to bet on PHP or javascript, or something else. Perhaps they'll coexist in 20 years, or perhaps they'll both be obsolete. You'll still need a job. Javascript didn't become dominant because it's a good language. Heck, it's not even a decent language. Developers used it because it was the only option and browser vendors kept implementing and optimizing it because websites relied on it. The popularity of smartphones put the nail in flash's coffin (search engines built that coffin), making it clear that javascript is here to stay. Then some people figured that most web developers already know javascript (albeit poorly) so we could use it for server-side too, thus eliminating the need to learn another language. The introduction of the V8 engine made that viable.
how's that party-poopin? he tells you what it is on the github. i'm actually surprised how much he *isn't* trolling. i thought that was gonna be something like // lol, php already is a templating language // here let me // get you started &lt;?php
I use try/catch block and exceptions when doing SQL transactions, that's it.
A framework that's just 4 lines of code is as meaningful as the old "Gentoo is easy to compile it just takes 2 easily remembered commands these are 1) fdisk /dev/sda &amp;amp;&amp;amp; mkfs.xfs /dev/sda1 &amp;amp;&amp;amp; mkswap /dev/sda2 &amp;amp;&amp;amp; swapon /dev/sda2 &amp;amp;&amp;amp; mount /dev/sda1 /mnt/gentoo/ &amp;amp;&amp;amp; cd /mnt/gentoo/ &amp;amp;&amp;amp; links http://www.gentoo.org/main/en/mirrors.xml &amp;amp;&amp;amp; md5sum -c stage3-*.tar.bz2.DIGESTS &amp;amp;&amp;amp; tar xvjpf stage3-*.tar.bz2 &amp;amp;&amp;amp; links http://www.gentoo.org/main/en/mirrors.xml &amp;amp;&amp;amp; md5sum -c portage-latest.tar.bz2.md5sum &amp;amp;&amp;amp; tar xvjf /mnt/gentoo/portage-latest.tar.bz2 -C /mnt/gentoo/usr &amp;amp;&amp;amp; nano -w /mnt/gentoo/etc/make.conf &amp;amp;&amp;amp; mirrorselect -i -o &gt;&gt; /mnt/gentoo/etc/make.conf &amp;amp;&amp;amp; mount -t proc none /mnt/gentoo/proc &amp;amp;&amp;amp; mount -o bind /dev /mnt/gentoo/dev &amp;amp;&amp;amp; chroot /mnt/gentoo/ &amp;amp;&amp;amp; env-update &amp;amp;&amp;amp; source /etc/profile &amp;amp;&amp;amp; emerge --sync &amp;amp;&amp;amp; cd /etc &amp;amp;&amp;amp; rm /etc/make.profile &amp;amp;&amp;amp; ln -s ../usr/portage/profiles/default-linux/x86/desktop make.profile &amp;amp;&amp;amp; cp /usr/share/zoneinfo/US/Eastern /etc/localtime &amp;amp;&amp;amp; cd /usr/portage &amp;amp;&amp;amp; scripts/bootstrap.sh &amp;amp;&amp;amp; emerge -e system &amp;amp;&amp;amp; emerge vim &amp;amp;&amp;amp; emerge gentoo-sources &amp;amp;&amp;amp; cd /usr/src/linux &amp;amp;&amp;amp; make menuconfig &amp;amp;&amp;amp; make install modules_install &amp;amp;&amp;amp; vim /etc/fstab &amp;amp;&amp;amp; passwd &amp;amp;&amp;amp; emerge grub vixie-cron syslog-ng dhcpcd &amp;amp;&amp;amp; cp /boot/grub/grub.conf.sample /boot/grub/grub.conf &amp;amp;&amp;amp; vim /boot/grub/grub.conf &amp;amp;&amp;amp; grep -v rootfs /proc/mounts &gt; /etc/mtab &amp;amp;&amp;amp; grub-install --no-floppy /dev/sda &amp;amp;&amp;amp; init 6 &amp;amp;&amp;amp; emerge gnome mozilla-firefox openoffice &amp;amp;&amp;amp; emerge --sync &amp;amp;&amp;amp; emerge portage openssh 2) reboot See easy" ಠ_ಠ
Look at /u/ocramius presentation here on how to set up ZF2 with Doctrine, it's really quite useful - http://marco-pivetta.com/doctrine-orm-zf2-tutorial/ A few others and I call him our lord and saviour because of this presentation at work.
Update: Now extending the routes.php too, command is seperate so you could use it standalone aswell
Not sure if it's necessarily obfuscated. Minified seems more accurate.
Sure,, but with the title was expecting four lines of readable code. A lot can be crammed into one line...
When has a "just X lines of code" title ever turned out to be readable code?
I'm not talking about writing a whole new specification, I'm looking for something that analyses the app itself, i.e. the routes and the input parameters it accepts.
I love occasionally reading pieces like this just for the humour value, but it's still nothing more than an advertising piece with no actual content (and certainly nothing useful for the members of this subreddit).
When has lines of code been an accurate or meaningful measure of anything other than lines of code? 
I'd argue that a line of code is a single statement, not a line on the screen. In other words, `$x=2;$y=2;` is 2 lines.
Yeah, but no line is more than 120 chars
/r/learnprogramming is a good place to ask broad programming questions.
Or a vendor that is very good at locking you in :-P
Because the frontend has exploded in recent years with the death of flash. So that is where the demand is. Together with NodeJS, you can now learn one language for frontend and backend and be in hot demand. So if you are new and got to start on a language, I would start with Javascript. 
lol :) Gentoo user here. I hope people get the cynical nature of this. This guy declares not to use this in production. however I do hope it would give people ideas, I'm big fan of small PHP frameworks.
It's a reference implementation of **the** symfony best practices, where things like one big AppBundle are recommended.
&gt; I always hear that I should throw an exception if there is an error in one of my functions. Not always. It's slightly subjective what you consider an error, and what you consider normal operation. For example I throw exception when: - Input is invalid. - The operation requested can't be performed. But I don't throw exception when I: - Have an empty result set from a read operation. - I implement patterns like "chain of command" where "not handling a command" is part of normal app flow. For ex. getUserById('123') will indeed return null if there's no user with this id but '123' is a possible valid user id. But I'll throw an exception if I'm given getUserById(['oh', 'hi', 'there']) because an array is never a valid id and points to a problem with the caller. BTW returning "false" is a common (legacy) practice for failed PHP functions, but I'd suggest you avoid it. If the caller expects integer return result, feeding them boolean will really mess up their app if they don't explicitly check for it. An exception can't be ignored. It has to be caught, and handled, or the app ends. This is a much more tangible way of handling unexpected conditions. *Another* benefit is that you can handle it "upstream", i.e. at a higher level in the stack, where the entire module's operation may have a sensible fallback. For example you can catch an exception at your application root, and show an error page, without having to check "=== false" at every level in your stack and pass error information up. Exceptions bubble up to save you precisely this sort of error prone manual work. As for empty result sets, use the following logic: 1. If the result is a list (array) of items and there are no items, return an empty list. *Do not* return null or false. 2. If the result is one item, and there's no item to return, return NULL. *Do not* return false. Null is intended to be a stand-in for "no result". This is why functions that return nothing implicitly provide a null return result. Using "false" is arbitrary and causes bugs. Just think of all the times you used strpos() and forgot to use three "=" instead two "=" when comparing the result: strpos(...) == false.
Don't limit yourself. Both are most used languages on web applications. But keep in mind those two are totally different. php - server side (backend) javascript - client side (frontend) If you would like to work with databases. apis and learn more about linux, starting with php would be your choice. If you into ui and want create sexy looking dynamic web sites, start with javascript.
There are forks that don't require you to configure it with a hard coded password. You put in the username, password, and server name/ip every time you use it. It should always be used over SSL, and I prefer to put it behind authentication. Exposing my database (or any other administrative interface) server to the Internet is not an option.
Let me guess : you like abstractions.
So is it possible to validate data in the client with javascript and then validate it again on the server?
&gt; first release candidate appearing mid-June 2015 At the risk of giving off [negative waves](https://www.youtube.com/watch?v=KuStsFW4EmQ), it's important to set realistic expectations for people. There's is almost zero chance of the first RC candidate appearing in June. There are several major RFCs that still need to be merged, or otherwise finished off. * [Context Sensitive Lexer](https://wiki.php.net/rfc/context_sensitive_lexer) * [Anonymous classes](https://wiki.php.net/rfc/anonymous_classes) * The situation with the exception class hierarchy hasn't been resolved. * I think PHPs reflection functionality hasn't been fully updated to match the ability to specify return types. (Apologies to the people working on them if I'm incorrect on any of those things). Additionally, PHP is meant to go through Alpha and Beta releases before doing a RC candidate. Each of the alpha and beta releases is to give people a month to find issues, before moving onto the next release. A slightly more realistic, but still aggressive and assuming best-cases for everything timeline would be: * End of May all RFCs implemented, internal ABI locked down to allow extension writers to finalize ports. * Middle of June first Alpha release, assuming no major issues found in merged RFCs. * Middle of July first Beta release, assuming no major issues found in Alpha. * Middle of August first RC candidate. This would be an incredibly aggressive schedule even if people were working on PHP full time, but the majority of people who commit to PHPs core are not paid to do so, and they have real jobs / school to attend to. The PHP internals have been working hard since the start of the year, as there were so many things to discuss and test before the RFC cut-off. It would be unrealistic to expect a paid team of developers to maintain the current velocity of development. Expecting mostly volunteers to work themselves into burnout is even more unrealistic. 
What I want to be able to do is create database websites that use databases. I see most of the small businesses that I could do free lance work for require these sort of things. I wonder when another language will be able to do everything that both can and still be completely functional. 
Yeah, I guess you can figure out my opinion on that book by now...
HeidiSQL, connecting with a SSH Tunnel to a firewalled MySQL-Installation, works for me the best. If you keep an eye on your Webserver error.log you'll notice that a lot of different IPs try to reach /phpmyadmin, /myadmin, /dbadmin, db.domain.com, etc, specifically searching for phpMyAdmin-Installations. You should definitely avoid it completely or secure it in the best way possible.
I still don't get why the the word "dynamic" still has to be used, IMHO you just don't make static webpages anymore. Unless you have to be done super fast and it's a one time only website, otherwise you can just go ahead and shoot yourself in the foot.
That is not visualization, sorry ))))
Let me guess: you like Facades.
Found on [HN](https://news.ycombinator.com/item?id=9413170) earlier.
It's hard to profit from open source. Not that I excuse their tactics.
Here's my one: https://gist.github.com/AlexanderC/6901193 It has built in template engine =))
Magento is awful and anyone who says otherwise tends to be pretty ignorant of what good software looks like. I've worked with the software for almost 10 years and I've been disappointed by Varien at every turn.
&gt; Middle of August first RC candidate. Speaking from a point of view I consider optimistic, I'm pretty impressed if we see an RC before the end of the year.
I hate it when devs include completely unrelated code format changes in their commits.
For me, as part of a Jenkins-powered deploy, I compress + copy those assets into our CDN during the deploy process. It doesn't have to be a separate repo, as long as the folder structure is predictable.
There's no way to get an actual reference to a function, but you can just call it as a string instead: $func = 'greet'; $func("world."); http://us2.php.net/manual/en/functions.variable-functions.php
It is, but holding back security patches is the worst possible way of trying to do that.
Especially on security patches! People who can't upgrade immediately are going to be applying the patch into their version, and you're just making their lives needlessly more difficult.
Based on this, it sounds like that since one of the issues of migrating to PHP 7 is having to watch out for the new reserved keywords (e.g. \Zend\Log\Writer\Null would become invalid), but apparently in PHP 7.1 those keywords along with older ones won't be reserved anymore, it would be worth waiting for PHP 7.1 to be out before migrating any PHP 5 project to PHP 7.
The one thing I like about this list is that it showed me who was behind certain groups; e.g. PHPWomen. The one thing I didn't like about this list is that there are only 70 people. :P
Nothing free and native for linux works for me. I wasn't satisfied with dbeaver and neither squirrel. Navicat is great, it is pricey though. I'm fan of adminer until I find something better.
PHP is rather famous as THE language for Opensource web packages, wordpress, drupal, wikia etc etc. But that has taken a long time for all these packages to become dominant. Will there be a Javascript (say NodeJS) equivelant of a magento? Impossible to say but over the years I have seen companies migrate to NodeJS (and have a very hard time finding enough people). I am not saying PHP is dead or bad but if you are new and have to learn one language why not be capable in both frontend and backend? You can always add another language later.
That last part..There are so many good people that try and o make modern PHP a cool language to get 'shit' done. 
"Hey, free heroin (but you know, the good for you kind). Great, now that you are dependent on it, give us money or that guy over there will cut out your kidneys" - Magento Team
I evaluated it once as a possible solution and after about an hour in the docs I noped the fuck out of there.
I'll just leave this here. Result of running PHPStorm inspections on Magento's `app/code/core` folder (not counting libs or templates): https://imgur.com/RMxWEgR
phpdocumentor has worked okay enough for me in the past. http://phpdoc.org/
There are a lot of firsts for me here, as I've been lurking here a long time and I've revised my entire development workflow. * First time using GitHub * First time using Unit Testing * Just purchased PhpStorm I'm sure the examples directory could use some improvements in terms of content, and I'm toying with the idea of implementing error messages as constants within their respective Exception classes. The purpose of this is mainly so that I could shoehorn some of the Wordpress Shortcode syntax into other possible editors and CMSs like Bolt. I think first and foremost: Is this something that people would be interested in using? **EDIT**: Due to popular demand. [the GitHub link is now located here](https://github.com/maiorano84/shortcodes) and all WP prefixes have been purged.
To quote the sylius site: &gt; We are working hard on the architecture and the most basic e-commerce features required to run a succesful store. This phase will involve several Backwards Compatibility breaks, but we will do our best to provide upgrade instructions for the brave Early Adopters. Sounds like a production ready system to me! 
Thanks, i will definitely have a close look at the link. It seems to me like functions and autoloading do not work well together, and i would not want to blindly load some stuff on every request for my users. So maybe making all functions static on some interface class would be the way to go. I still could expose the shorter function syntax on a special file which could be required.
SQLyog is a godsend. I wish it was on OSX, but the rest of your points are spot on.
We are probably in a minority here, but I too like the shortcodes. It's a good alternative to creating custom WYSIWYG editor widgets that might just cause additional confusion... which also have to implemented in previews and such. Looks like great work so far and congrats on your first Github project and first time Unit Testing. I may be able to offer some specific feedback later when I have more time.
I don't think it's all that subjective, personally. I've not run across a scenario that wasn't blatantly obvious and not open to interpretation yet. Exceptions are for exceptional conditions - conditions that are both unexpected and fatal (can't possibly continue processing). Using them anywhere else is inappropriate.
If i do not get you wrong this actually is a distinction the formlets do as well, but i do not expose that in the actual user interface of my library. A formlet can produce a "builder", which is responsible for the rendering part, and a "collector", which handles the input. A form in my library is just a thin wrapper around that. There still is a huge difference between the model you presented and the formlets-model. As one needs to assign names to the fields in your model, you get a validator that could be usefull in other places than form-handling. In the formlets-model, you do not assign names to the formlets, which makes the collector less usefull somewhere else. This actually is a deliberate decision, as you gain a lot of composability in return.
I had debated about that, and it involved a lot of internal conflict. On the one hand, I totally get it. This is a package that's more inspired by the Wordpress Shortcode syntax, and is not directly affiliated with Wordpress itself. In addition, I also don't want people to think that they can take existing shortcodes written specifically for Wordpress and just plop it anywhere. But on the other, many of the naming conventions were derived from Wordpress, and the source code actually lifts some of the original Wordpress source code directly (mainly the regex parsing). Since the syntax itself is commonly associated with Wordpress, I had figured that the WP prefix was appropriate. Though, I'm not totally opposed to renaming the repository either. Seems like I have more to lose from keeping the name.
https://php.net/manual/en/function.rename-function.php
"Fatal" condition means the app aborts. It's certainly not the case with many exceptions which are used correctly. If exceptions were meant to always be fatal, there wouldn't be a fine-grained catch statement, set_exception_handler() alone would be enough. I have an application which can *continue to operate semi-normally* if the SQL server goes down. It'll move on and display stale cache data, and buffer commands in a local log until the SQL server is available again. The same behavior occurs with my mail send scripts, and when certain third party services go poof on me. My RDBMS layer throws exceptions when various SQL error conditions occur. Ranging from things like bad SQL syntax, query too big, server down, to for ex. when an index constraint is violated (say, non-unique primary key). It's fatal for the INSERT, but not fatal for the app. It's caught, transformed into a validation error and returned as a list of errors upstream. I transform warnings and notices to exceptions too. So when my autoloader gets an exception for an include that wasn't there (file not found), I can take action. For low-load servers the autoload map is re-generated on the fly, and if the file is found, the app continues normally. For heavy load servers the expectations is code is not monkey patched on production and regenerating the map on the fly is risky, so it's a fatal condition, error page is shown and the app aborts. Details, details.
...... shit. Good catch. I had thought Wordpress was licensed under MIT. Correcting.
Is it too late to ask a question? What should I use to convert an XML file to a PDF? I've seen xml2pdf but it doesn't look like it is around anymore.
Not sure why you're getting downvotes for this. Payment processors like Stripe that let you offload credit card numbers to a dedicated service are vastly preferable in most cases, particularly on the security/safety point.
Don't build a business on open source for critical apps IMO. You will fall behind when community patching and release cycles overlap with major needs. Yes this should be patched but the process for open source commits are a lot different and slower in some cases than the paid supported versions. 
I don't have a definite answer but I have several rules of thumb: 1. Be liberal in what you accept and conservative in what you return. That includes throwing exceptions - I consider exceptions to be extreme return values that change the global flow of the code. 2. Write robust code that doesn't collapse at the slightest inconvenience. If you can recover from an error in a smooth way, do it at the lowest level possible. 3. If you return different types (eg. an integer or null, or an integer or exception), you force your caller to type check the result anyway. 4. Returning a null object is preferred to returning null or false (as an extra type) is preferred to throwing an exception. It's not easy and I regularly agonize over what a method should return in order to be usable, robust but at the same time to indicate the error state properly.
It actually is a concept not unique to Wordpress, for example, many forum scripts, such as phpBB, call it "BBCode". But named options are a great addition.
Or even a goddamn WordPress setup with Woocommerce
I was focused on the theming documentation. Something like http://www.magentocommerce.com/wiki/4_-_themes_and_template_customization/0_-_theming_in_magento/package but I'm sure it was an earlier version at the time.
Magento being so god damn inefficient annoys me. To run a decent size ecom site you need to throw a shit ton of hardware at it. That along with a stupidly expensive licence for enterprise edition along with archaic policies on what the licence can be used for and on how many processors it can installed on, makes magneto one of the worst pieces of software out there, but they somehow have gained a massive market share, which I hope will diminish in time. Sylius looks promising but still unconvinced it's got what it takes to knock Magento off its high horse, but for the sake of all devs out there who have to work on ecom, I hope something comes long sooner rather than later to fix it. 
Ah, thanks for clearing that up
&gt; built some very large complicated stuff on it. i.e. mess.
There is nothing complex about a shopping cart. If you've got layer after layer of complexity on something that should be simple, it's probably costing you sales. Your job should be to remove that "accidental" complexity with elegance. Using a system like this, won't help with but instead will compound the problem.
Real business owners want to do CRAZY stuff all the time. Like price things in 1/1000th of a cent, or give discounts based on 15 different factors. Then you have to figure out which of the their 50 warehouses has stock available, and is closest to the customer. Then you have to send that order over EDI to SAP. Real life is complex, especially when you are dealing with large companies. TL;DR; It's not just a shopping cart.
&gt; TL;DR; It's not just a shopping cart. Wrong tool for those jobs certainly. Should have worked up something bespoke from the start, having not done that, you can now tell us how much of a nightmare Magento made the project....
Due to restraints I can't do this though. :/ Unless there's a real good business case for it can't just install things willy-nilly.
It's looking more and more like it.
The RabbitMQ clustering allows you to connect to any node within the cluster, and it'll pretty much work the same. It doesn't have anything built in to handle where clients should connect. So you either need to make the clients intelligent enough to connect to one at random (no ability to do round-robin/least connection balancing), and have it handle failures (hopefully it knows something is broken quickly, otherwise your publishers will be slow to startup) or you have an external service responsible for telling you what to connect to. However, if you do find something, please do share. We have HaProxy configured with only TCP checks for Rabbit.
All I have to say is "getUserParam"
It's entirely possible for that server side language to be Javascript too.
&gt; It boggles my mind why Magento would willingly distribute unsafe code this way, assuming users would just find out to download the patches separately Because Magento is such a pile of shit they probably don't have an easy way of applying those patches and releasing the thing as a new version with the patches applied. 
That would require most/all browsers to implement a PHP interpreter/engine. I don't see that happening.
I honestly think I might have been living under a rock, as I've never even heard of BBCode (though, I believe I've never used phpBB). Even still, the regular expressions that are used to parse the information was a direct ripoff of Wordpress' source code, so even though the concept might not necessarily be unique to Wordpress, the regex - as far as I can tell - is.
This wouldn't have completely solved the issue because of the way Magento lets you pass in request parameters through the URL in its module/controller/action format.
Does that mean I shouldn't run my code on Linux servers?
&gt; This is the first Aura library to use an external dependency. In fact, is uses two: one on the PSR-3 logger interface, and one on the proposed PSR-7 HTTP message interface. Awesome :) I had a look [at the documentation](http://auraphp.com/packages/Aura.Router/getting-started.html) and I love it! I had tried the 2.x version but there were a few things I didn't like (I can't remember it on the top of my head sorry). But this new implementation is so much simpler and natural. Here are a few suggestions: - drop `RouterContainer`? it just feels confusing, why would it contain routers - rename `Matcher` to `Router`: having a router component without a router class is confusing, as as user I want it plain simple - encapsulate the `RouteMap` into the `Router`: simpler usage by default, but let users provide their own map with `$router-&gt;setMap($myMap)` so that some frameworks can load routes in a YAML config (for example) and provide them all at once - drop the route names? I'm not sure why those are useful so I'm not too sure about this suggestion I want to be able to do: $router = new Router(); $router-&gt;get('/route/path', function () {}); $route = $router-&gt;match($request); // I can do my dispatch now! call_user_func($route-&gt;handler, $route-&gt;attributes); Or also with my own route reader that returns a RouteMap: $reader = new MyFramework\Router\YamlRouteReader(); $routes = $reader-&gt;read('routes.yml'); // This returns an instance of RouteMap $router = new Router($routes); $route = $router-&gt;match($request); Also not related, but all your example in the documentation start and end with PHP tags (`&lt;?php ... ?&gt;`) these could maybe be removed?
There is more enterprise based distros like RHEL which is huge for major applications and systems under paid support as opposed to the CentOS community alternative. 
I hope you don't build anything in PHP then. Or use Linux. Or SSL.
I'm confused. By definition, they're running an open source kernel. You said not to build a business on open source software. You're contradicting yourself.
Phil Sturgeon "Queen of the League"
Yeah, Magento is really over engineered. It's just...bad.
Realistically, JavaScript has a bigger marketshare than PHP. PHP is primarily used for website backends (though some people do write daemons in PHP this is uncommon). JavaScript is effectively the only language that a browser understands. So… we have a portion of website backends written in PHP… and practically every browser in the world that understand JavaScript. It's not bad advice to learn JavaScript at all if you look at it from this perspective. Secondly, there's a lot of PHP hate, warranted or not. Pretty much all the other messages here cover this just fine so I won't say anything else about it.
Put PhpMyAdmin behind SSL+BasicAuth and it's no longer a security issue. An SSL connection is established before the Basic Auth process occurs. So, it's completely safe no matter how bad the application that runs on top of it all is (and it's really bad, security-wise). 
That's why PSPs, like Stripe, have been doing client side encryption and/or direct PSP submission.
I honestly did not know that PHP was object oriented. So pretty much any book will be fine and I should not over think it. I guess I just would like something with working files.
Here's one I liked: https://www.goodreads.com/book/show/86353.Object_Oriented_PHP I also tend to like the O'Reilly series of books - with the animal drawings on the cover. They're very technically oriented and they often have too much info, which is better than not enough.
LTS version ↑
&gt; It's hard to profit from open source. It's not. Just look at the Drupal (and Drupal Commerce) Ecosystem.
It essentially grabs everything that should be written to the web server logs, and writes it out again, which is very redundant. The only "analytics" is the Python code that parses it. You should be able to achieve the same thing by parsing the webserver logs directly, without the performance hit. You'll also need to think about the fact that, under the given scheme, the file will grow indefinitely. I have webserver logs that grow a few GB each day, and it won't be long until that parser becomes a ten hour project to run. That or you fill your disk.
I guess I'm more referring to a community version versus the licensed supported version in this case where yes, both are open source, however the enterprise versions have a different update and code change cycle than the community counterpart. Open source vs Enterprise support is more my point, not just the code license. 
Did you clear the 32 chambers of the wu-tang cache?
I've just started delving into the php mysql fun and am curious what you're seeking. 
This would be great. I would definitely use this if it were an option.
Hi Mathieu, Thanks for these detailed and constructive remarks; I appreciate the time and attention it took, and I'll try to do them justice. First, an answer to a combined pair of questions; they relate to each other. &gt; drop RouterContainer? it just feels confusing, why would it contain routers &gt; &gt; ... &gt; &gt; I want to be able to do: &gt; &gt; $router = new Router(); &gt; $router-&gt;get('/route/path', function () {}); &gt; $route = $router-&gt;match($request); &gt; &gt; // I can do my dispatch now! &gt; call_user_func($route-&gt;handler, $route-&gt;attributes); The Map, Matcher, and Generator all have dependencies, and while they're not *difficult* to set up, they do require some work. TThat's the reason for the RouterContainer. It does not "contain routers" -- it is "a library-specific Container". The RouterContainer manages the object creation, wiring up the dependencies for you. If I may, using the RouterContainer to get the prepared objects does not seem egregious (at least not to me). It's two more lines total; they buy you a richer object set that you can't see right away: $container = new RouterContainer(); // 1st added line $router = $container-&gt;getRouter(); $router-&gt;get('/route/path', function () {}); $matcher = $container-&gt;getMatcher(); // 2nd added line $route = $matcher-&gt;match($request); call_user_func($route-&gt;handler, $route-&gt;attributes); The intended benfit of this is that you can address the RouterContainer instance in your own DI system, without the library package needing any special "provider" or other DI-system-specific knowledge. I don't know your [PHP-DI](http://php-di.org) work so well, but an [Aura.Di](https://github.com/auraphp/Aura.Di) variation might look like this: $di-&gt;set('aura/router:container', $di-&gt;lazyNew('Aura\Router\RouterContainer')); $di-&gt;set('aura/router:map', $di-&gt;lazy( [$di-&gt;lazyGet('aura/router:container'), 'getMap'] ); $di-&gt;set('aura/router:matcher', $di-&gt;lazy( [$di-&gt;lazyGet('aura/router:container'), 'getMatcher'] ); $di-&gt;set('aura/router:generator', $di-&gt;lazy( [$di-&gt;lazyGet('router:container'), 'getGenerator'] ); Those services can be injected wherever needed. The RouterContainer itself is configurable too, so your DI system can configure that as well. As a side note, I think it's unlikely that the same method (or include file) that sets up the routes will also try to match the routes. But that depends on the application. Another combined pair of questions: &gt; Or also with my own route reader that returns a RouteMap: &gt; &gt; $reader = new MyFramework\Router\YamlRouteReader(); &gt; $routes = $reader-&gt;read('routes.yml'); // This returns an instance of RouteMap &gt; &gt; $router = new Router($routes); &gt; &gt; ... &gt; &gt; let users provide their own map with $router-&gt;setMap($myMap) so that some &gt; frameworks can load routes in a YAML config (for example) and provide them all at once Something like that is available under Map::setRoutes(), which takes an array of Route objects. That's noted in the ["Caching" section](http://auraphp.com/packages/Aura.Router/advanced-topics.html#1.5.2), which admittedly does not seem like the place you'd look for that kind of thing. (On review, I realize that the RouterContainer cannot receive a prepared set of routes for injection into the Map; I'll remedy that shortly.) &gt; rename Matcher to Router: having a router component without a router class is confusing This is a fair point; let me play around with that a bit. &gt; encapsulate the RouteMap into the Router We actually did this in v1 and v2, but I realized that having the Matcher *and* Generator *and* Map code all in the same object busts separation of concerns. (I can see where an application encapsulating the library might want to combine them.) &gt; drop the route names? I'm not sure why those are useful so I'm not too sure about this suggestion Those are staying. ;-) They're for "generation" / "reverse routing" / "route lookup" (it goes by several names). Having a route name by default is super-useful when you want to generate links; having it be foremost makes the user consider (I hope) that aspect of things early on. &gt; Also not related, but all your example in the documentation start and end with PHP tags (&lt;?php ... ?&gt;) these could maybe be removed? I'll see what I can do. Again, my thanks for your attentive and considerate criticism. 
Let's not mistake complication for complexity.
The relevant code is here: diff --git lib/Varien/Db/Adapter/Pdo/Mysql.php lib/Varien/Db/Adapter/Pdo/Mysql.php index 7b903df..a688695 100644 --- lib/Varien/Db/Adapter/Pdo/Mysql.php +++ lib/Varien/Db/Adapter/Pdo/Mysql.php @@ -2651,10 +2651,6 @@ class Varien_Db_Adapter_Pdo_Mysql extends Zend_Db_Adapter_Pdo_Mysql implements V $query = ''; if (is_array($condition)) { - if (isset($condition['field_expr'])) { - $fieldName = str_replace('#?', $this-&gt;quoteIdentifier($fieldName), $condition['field_expr']); - unset($condition['field_expr']); - } $key = key(array_intersect_key($condition, $conditionKeyMap)); if (isset($condition['from']) || isset($condition['to'])) { Removing those 4 lines (the ones with the "-" in front) disables a method of querying the database using a user-generated field_expr. I'm not familiar with Magento's code, so it'd be out of line for me to describe the consequences of removing this feature, but the security implications of leaving it in are apparent now.
Me shoving words together. Hypothetically, two developers 'pair-up' to review each others code in peer-review format. Likely in the form of Pull Requests on GitHub or other Version Control. Both developers learn from each other, ask the important questions (Why did you do this?) and each develop slightly better quality control and personal skills.
Thanks for the answers! They make sense ;) &gt; Having a route name by default is super-useful when you want to generate links Damn it's so obvious I feed stupid for forgetting about that use case ;) Keep on the good work!
I wrote a bash cron-job to take my web server logs and process them every few hours. They were not intended for analytics so much as error reporting - I had to run Apache with error-reporting on in production - since I couldn't set-up a full staging environment for the dev team. The logs they processed were several GB, but after processing out the data I didn't want (grep) and boiling it down to what I did want (sed count sorts and things) my parser took a few seconds to run.
Its nearly identical to Enterprise Edition besides caching and I believe gift card codes. What else?
Man, I did things with Magento for very little money and a few free and paid modules that would have cost me 10's of thousands of dollars to have done custom from scratch. Something that a company like Channel Adviser charges 1% of your total monthly revenue for I've done for damn near free. This would have been simply impossible without Magento or on some other platform. Magento has enabled me to start a successful business, hire employees, and pay my bills and it has enabled countless others to do the same. FOR FREE! And they're releasing a much better version this year which fixes a lot of the things people find fault with, again FOR FREE. Talk shit all you want, Magento is a nightmare only for those that don't understand how it works.
First, I see a jQuery reference there which makes me believe that you may have included 3rd party modules in that inspection. Second, can you please run this for the latest Magento2 beta and also If possible on their latest github repo? 
&gt; Magento is a nightmare only for those that don't understand how it works. It was all going well up until you invalidated everything you've said with that one line.
Can you amend any commit or just the latest one?
Done and done. "require": { "maiorano84/shortcodes": "~1.0@beta" }
What's a good alternative to magento?
[A Beginner's Guide to MVC](http://blog.ircmaxell.com/2014/11/a-beginners-guide-to-mvc-for-web.html) Read the whole series of blogposts about the topic (reading the whole blog won't hurt either, it's great).
You can say that about anything you don't understand. That's my point. 
&gt; field_expr That name says it all really, should have seen it coming and not implemented that as a "solution". 
Well...now I know what I'm using for my next project.
There's no reason you can't scale with PHP. nginx, php-fpm, shared resources across servers (nfs, aws, cloud etc), and a load balancer. Use what you know and understand, otherwise you'll probably spend way more time and money. Caching mechanisms (memcache, redis, etc) will help take load off the database.
No, I ran the inspection on `app/code/core` only. Magento uses Prototype.js, which also uses `$` as its main symbol, like jQuery does - PHPStorm just got confused :) Here is one example of code that triggered this "jQuery usage efficiency" inspection: https://imgur.com/gPJNRBB . The inspection is complaining that the `$(\'options_' . $_option-&gt;getId() . '_' . $count . '\')` selector is being executed repetitively. ---- I will run the inspections you asked about later today and get back to you.
But how can you make sure the function you created, is a well written one?
Sylius is promising as a promising next generation platform, but it's still young
agree. 70 PHPeople should just be the beginning, i am currently looking to extend that to a bigger "PHP resources" project.
Not sure how well this will go down in this sub, but I launch a lot of wordpress+woocommerce stores. I'm talking around 5000 sales a month, £1m a year turnover websites. I don't see why it can't scale upwards of that, though. Woocommerce is richly featured, easy to modify, and has a relatively small footprint. We still have clients asking for magento, but I've never seen a decent argument for it. 
I used 1.5 was stable. Than switched later to woocommerce. But WordPress isn't looked here :) but it gets the job done and has plenty of plugins for free. While presta is for sure more professional.
I can't freaking wait for PHP 7. 
You know that you can compile it, right? :-P
Use the technology you know. It will soon be the least of your worries. (When it comes to ecommerce, the complexities of business make up 90% of the overall project complexity). Note that for Ruby people the platform of choice is Spree, not Shopify (which is a hosted solution). Good comment in a related r/Drupal thread: http://www.reddit.com/r/drupal/comments/33881v/can_you_create_an_airbnb_clone_using_drupal/cqiy0ap
I use 1.5 and it's fine. What bugs were you running into?
Same goes for SQLYog.
I'd be asking what he is going to be testing his code with. Sounds like this may turn into a support nightmare.
&gt; but it's going to (as you all know) turn into a nightmare pretty quickly once he's gone. That's the problem. He might be able to complete what's asked so that's fine, but if people in your company have to maintain it and are not OK with that, then I'd say you might need to talk about it with him. I can imagine it's maybe not an easy discussion. Just to be clear about your title: "Should I be concerned about this freelancer?" Not about the freelancer, but about the fact that you will have to maintain the code, so it should fit into what you consider "maintainable".
But not every software is trying to make it extra hard for you to understand it. When I last looked at magento (which is admittedly quite a while ago) it was as if someone said "Let's make this whole thing super flexible and also as opaque as we can".
do you really expect a descent answer from this kind of post? c'mon man, put some effort in it.
this
I've heard from a lot of people who were looking to hire, that they met with senior developers who were stuck on the methods they used for the past decades. If you are looking for a procedural programmer, he might be a very good choice. If all you do is OOPHP, he won't. I'd choose someone else If I were you. 
I do not force anybody to use it, but i share it with the community in case anybody needs something similar. This is how open source works dude...
Whoever the project lead is needs to set the requirements and work flow of the project, which includes what technologies are being used. All you need to do is inform the freelancer what these specifications are for developing the project and in turn they need to work within them. I'm not sure why your team would let a freelancer make these important decisions.
I think Magento is so widespread because it was best-of-breed a few years ago, and companies had to invest a tonne of time into it, and they are still recouping those investments. I'm suggesting WooCommerce because it's simple and fast (to install, configure, and in terms of performance). Also it doesn't tie our clients to us, they can up and leave to another agency and there will be no shocking learning curve for the next guys. (Oops that's part of the sales pitch again) Though you do have to accept wordpress as your platform, and that's probably a separate discussion. Possibly I'm coming at this with my Manager's hat on, and not my Developer's hat on.
&gt; which includes what technologies are being used. You need to inform the developers what the development environment will be. e.g. "We need to use X language and we'll be working with Y framework. We'll also need to use Zyx database, Abc message queue, Def code repository, etc". Unless you've hired the freelancer as an architecture consultant, your team needs to make these decisions. It's your company, your project, not the freelancer's.
tl;dr: https://github.com/mothership-ec/up
Doesn't Magento 2 use basically the same, (troublesome), database model?
Not every project needs OOP... You can let him make it procedurally without it being a complete nightmare. But at the very least require DRY code through includes/requires so that things like headers, menus, footers, and table data code only needs changed in one place. --Specifically point out things found in multiple places that need to live in one single chunk of code. This is effectively making it spaghetti code reminiscent of basic with goto commands, but it doesn't have to be a complete nightmare. I've made a few procedural things that I am not ashamed of to this day. Testing, make sure each page has more or less automated testing and whatever changes he makes, the working things have to stay working... (I'm a fan of the Cucumber/Groovy/Selenium/PhpUnit/Jasmine combination.) Granted, there is lots of shame in my past due to current day proficiencies, daily honing of my craft, and a sense of direction regarding where I am interested in going-- unavoidable. But, I've done some really cool things with the tools and understanding I had available. This guy may be capable of similar coolness with the tools and understanding he has. But, some form of DRY and testing that is a trivial task to run is a must. If he can't commit to those, then he may be the wrong guy.
I am not sure were else you could go with this. You could do a CDN, Varnish, switch to a newer version of PHP, swap MySQL for a faster replacement MariaDB, or other MySQL variants. However load time does not equal scaling and scaling takes a load time hit anyways. When talking to a business mind, money is always important and unless they are willing to do AB testing for proof then you won't get anywhere. You could say something like you can earn 3% more in revenue, but if that 3% is eaten away from the cost of hosting + time to implement then you won't get anywhere. 
Why did you give him PHP 5.5 when he asked for 5.6?
What do you mean by block scope?
Does it have PSR-4 support?
I've started by learning from PHP with MySQL in easy steps book, if that helps.
No, I... I once killed a man.
Still trying to decide how to display those special alert messages.
So this runs Composer under the web server user? Meaning that the web server user must have the permissions to overwrite the application files?
Is BBcode really shortcodes? It's more like a markup language.
I mean PHP 7 that's ready for production :P
I was thinking about security while reading that and I felt a chill on my back.
So will PHP7 finally have non half assed unicorn support without the need for external libraries? Edit: Obviously I meant unicode support, but autocorrect disagreed with me
Not mandatory, but not using it (especially on a huge project) does imply severe Not Invented Here syndrome.
Alternatives to Magento: + http://sylius.org/ + http://mothership.ec/ + https://shopplugin.net/ + http://www.shopify.ca/ + https://www.prestashop.com/ Or roll your own using composer packages. Drop these into Slim or Lumen: + https://github.com/moltin/cart + https://github.com/thephpleague/omnipay + ... 
&gt; Does wordpress use square brackets for shortcodes? Yes. I think you might be thinking of curly braces because they're often used in templating logic, which isn't really something that this is well-suited for. Though I think it would be cool if later on down the road I added more flexibility to allow for the manager to decide how to wrap shortcodes. I also agree that the readme examples could be a little clearer. I think as this is built out a little more, I can break it up into more meaningful parts that explains shortcodes a little better to people who might not be familiar with the (Wordpress) Shortcode syntax. I had debated about the `Shortcodes\Shortcode` namespace. I agree, it's a little redundant, but I do want a directory separating that logic from the root of the package. I'm also thinking of changing the `Shortcodes\Examples\` namespace to something a little more meaningful as well, and move the SimpleShortcode class into that namespace. Do you have different names in mind? Maybe `Maiorano\Shortcodes\Contracts` and `Maiorano\Shortcodes\Library`?
Actually Fedora -&gt; Red Hat -&gt; CentOS is how the tree goes. Fedora is the main project, and it’s a community-based, free distro focused on quick releases of new features and functionality. RHEL is the corporate version based on the progress of that project, and it has slower releases, comes with support, and isn’t free so more designed for stability of applications and not going to put in random community patches which makes sense for anyone who has worked in a major enterprise. CentOS is basically the community version of Redhat. So it's essentially identical, but it is free and support comes from the community as opposed to Redhat itself. Again, most major companies want better release cycles for patches and not just random community ones for mission critical apps.
So you better not use this to composer update Laravel even on minor version steps (SCNR, because there was a pretty breaking change http://laravel.com/docs/5.0/upgrade#upgrade-5.0.16 ). I see the topic it wants to serve but it can mess up your application pretty bad too if you are not setting it up correctly or the package developer messes up.
Yeah I saw when that happened. Maintaining BC can be hard and it's always possible for things to slip through the net, but I was surprised something as high profile as Laravel would make that change so flippantly. Unfortunately that's a risk that you take with Composer, I guess, you need to have faith in the package maintainers that they will respect semantic versioning
unicorn support - best support ! http://static.giantbomb.com/uploads/original/1/17172/1419618-unicorn2.jpg 
Any automatic self updating application needs to be able to update it's own code. Obviously there are security issues surrounding it's use but I think they can be managed. Any feedback surrounding this is appreciated and will be noted for when we integrate this into our platform. Up! isn't only intended for use by web apps. Our initial use of it is in a cli installer distributed as a .phar removing the dependency of having composer installed when running it. In cli tools like this, the ownership problem isn't an issue.
It was never that fast to begin with, comparatively speaking; neither was Symfony, components of which form its core. Even so, the absolute number of requests-per-second is usually what you need to look at when making a decision, not the finishing-place in this kind of comparison.
Test this: if (true) { $var = "foo"; } var_dump($var); // &lt;--- Undefined in a sensible language
That's fair. While I'm not positive, their development team has been paying a lot of attention to performance, good code, etc with Magento 2. It might have a lot to do with them being part of Ebay Enterprise now instead of just hacking on top of the old Varien codebase. I haven't run or seen any numbers, though.
Have you guys considered just releasing built zip files and using that instead? I looked into this for my work and for us it made more sense to just avoid running composer on the server. You don't have to worry about composer failures leaving the application half updated. We ran into a couple of issues. Github would rate limit pretty quick with a lot of dependencies so you need an auth.json with an oauth key. We also needed to setup and maintain a satis repository for proprietary packages + write those keys to auth.json. In the end it was not worth it to have our client servers reliant on packagist, github, and a satis repo when we could just put a bunch of zip files on s3.
We are still in the process of investigation for automatic updating. Our platform is split into a bunch of modules which each site may or may not have. It would make sense to update using composer as only the things that are included will be included, and any additional bespoke modules/modules not built by us would also be updated at the same time. A fully built .zip is quite rigid in what it may contain. We manually update client sites with composer in our deploy process and we've never had an issue with github rate limiting us, not to say this may not become an issue. Could you expand here?
Vote For Delete. 
Completely true, after this time fiddling with any part of Magento and the environment I found out there isn't a straight forward solution to get the performance you like. It's the combination off multiple solutions that will get you the best result. I've done the following: CDN, FPC, Minimize and combine resources, PHP Opcache (which helped a bunch together with FPC) and mysql tuning. On the other hand our HTML is server from a server near our offices while all the clients of this magento website are located in the US. Do you think moving to a US based data center would make a huge difference (it's mainly only the HTML being sent from our data center, the CDN does the rest)? We did not use Varnish because off SSL and me being noob in these things (I'm a dev but I'm interested in all the sysadmin/devops stuff). Idk if you know what I'm talking about but this Varnish + SSL is a headache that won't go away, varnish can't read your whole HTML page and can't exclude certain parts (like the search and user menu, etc...) from the cache. I know a simple solution (reverse proxy handling the SSL handshake before it reaches Varnish) but again it's wiped off the table like I'm not allowed to talk about modern stuff. It's not that they don't believe it's not proven, they just don't believe me that I know what I'm doing... I understand what you said about the business mind, which is a huge deal here. I'm only 25, this company exists for +35 years. So there are some, I call them dinosaurs, who are happy how it is and are waiting to retire. This is such a stupid mentality, as a young and ambitious developer I feel very limited in what I can do in means of resources and time. On the other hand, after 1 year complaining I'm finally allowed to create an API which doesn't hurt my eyes (we have a SOAP webservices which is hopeless to maintain) so there is some improvement but slow.
thanks for your advice guys. Looking at his code this afternoon it's littered with injection possibilities &amp; deprecated functions - looks like our internal team will have to fit this project in after all 
Yeah we were considering a crontab running under another user
[These benchmarks use 4.2](https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/PHP/php-laravel) without `artisan optimize`. [Their PHP setup](https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/config/php.ini) uses default opcache settings.
I've worked with WooCommerce and it is very developer friendly. There are WordPress hooks everywhere! Everything is documented. The backend workflow is very similar to Magento but without all the overhead. It really is polished and would have no issues suggesting to anyone.
I did a project for a small company that got sold Magento. They were working with some shop and invited them to some Magento conference and everybody convinced them they **needed** it. First, they hated how long it took us (we inherited the project) to develop it. They hated everything about it, really. They were a small little shop that still packaged things by hand and somebody f'n sold them Magento. I spent more time bypassing or removing features than adding or customizing.
Fair enough :) Thanks for sharing your code with the community.
Good question. Not by default but there is a Composer plug-in that supports it and that could be added to Studio. More info here:https://github.com/pulse00/Composer-Eclipse-Plugin/issues/91 We will add it by default in the next version thanks to your feedback.
I can tell your work revolves around web page crawling and scraping ;) Your tools seem to have evolved to address specific practical needs in your apps and this is probably the best can be said for a library - it's created because it's useful, and not just because someone had a big abstract framework idea. The code is straightforward and styled well. Thanks for sharing :)
No you don't. You need to add rule to urlManager. http://www.yiiframework.com/doc-2.0/guide-runtime-routing.html#using-pretty-urls Esencialy you add somethinkg like that to already defined rules in UrlManager in config file: &gt; 'custom-url' =&gt; 'controler/method' 
Do these comparisons take into consideration the functionality of HHVM that actually provides most of their optimizations? Or where does it fall on the spectrum between the base PHP of these opensource projects and actual conversions to optimize it for HHVM?
Ah right, because '// ...' is a super clear example. Also, love how basic route declarations are buried under a poorly documented nested array somewhere. 
All business logic in app/code. Not sure where to find something? Turn on template path hints. Need more help, read Alan Storms excellent blog. I'm not a developer and I understand how Magento works, it shouldn't be too difficult for someone that knows what they're doing.
This is not possible, but you can create a Macro and bind that to a new keyboard combination. For example, have a macro which does: - Cmd+V (paste) - Up (to move into the pasted block) - Cmd+- (to collapse) - Cmd+Right (to go to end of line) - Double enter (to go down two lines) This will paste a block, move into it and collapse it, and move out of it again. Bind this to something like `Ctrl + Cmd + V` and you're set. The shortcuts are OS X based, but you get the drift, just modify as per your own OS. This does mean some overhead when pasting folded blocks (remembering a new shortcut) and will work only if you're pasting one block at a time, but I assume it can be modified and made to work with several. Still, I agree it'd be nice to have a setting under "Code Folding" like "Keep fold state while pasting". Upvote the feature request [here](https://youtrack.jetbrains.com/issue/WI-27180).
Applications breaking in 3, 2, ... In a perfect world it wouldn't be too bad, but updating composer dependencies on deployed application will cause more issues than not. I've encountered packages that have broken backwards compatibility in a patch. Bundles might need to clear caches or install dependencies. You started running into a lot of problems. Leave it to the developers to maintain the dependencies in the development environment.
They're [experimenting](http://blog.jetbrains.com/phpstorm/2015/02/meet-phpstorm-9-development-roadmap/) with it. Hopefully we'll see it soon. 
&gt; He asked me for a server to use One more thing to learn from this is not to give someone "a server to use" If a dev can't work locally you have problem #0 to solve. In this case however it gave you insight on what he was doing ahead of when he'd commit code most likely
Like I said to /u/BringTheTanks, this is a tool, and like Composer, does not take responsibility for applications breaking through the use of this tool. I definitely see the issue and I think it's something that developers should consider when using it, but it's simply for the purpose of making things easier. For instance in the case of Mothership, we have an installer that uses Up as a way to hide the Composer dependency. Later on we will probably add a command that you can run in the command line that will update, again without Composer being necessary as Up is included within the application, so the developer never needs to worry about whether or not they have Composer, but a more savvy developer would still be able to use it. We are certainly aware of the risks that come with having a one-click update, so would need to consider things like rolling back, or having a staging version that can be viewed before confirming, but these are all things we need to plan out in the future. But the risk is still there with Composer if you're using dependencies that you can't trust to stick to semantic versioning, the difference being that you get a chance to spot check/run tests, but it's still possible that something could slip through the net.
Means variables are not "variables belonging to a function", but "variables belonging to a block", where a block is anything between { and }, including functions, but also loops, if statements and so on. It allows writing code where every block feels like it's own little inlined function. It's neat, it's conceptually better, but... it's also not that important.
Majestic and so, so webscale. 
Isn't hack still experimental?
I didn't get a popup. Probably because of Ghostery.
Thank you! It's a good idea to use a macro; I never would have thought of that. I'm gonna upvote the request on the forum.
There is a publicly disclosed security vulnerability on Composer where it doesn't enforce TLS verification over HTTPS. Translation: It should never be used on a live server if you remotely value security. It shouldn't be used on a development server, but we're stuck with everyone doing so until the Composer team adopt the fix already implemented in the Composer Installer. You can weigh the risks on the development side, but a live server is just a no-no-no.
Ahh alright. 
Is it "hate Magento" week :)? There's a flood of negative press about them.
That sounds awesome. Will it be easy to port PHP 5 code to PHP 7? Also any update when it's coming out?
Or disable the submit button after clicking it.
Ok. So not rejected just spam filtered. That's a whole different ball game. It's most likely the content. Does the email have much text? Try taking a few paragraphs of content from somewhere and append them to the end. See if that helps 
Are people confused about this? Well, it doesn't help if instead of calling things with their name, some prefer grandiose names like "Middleware" and "Kernel" for simple patterns that *already* have a name. What "StackPHP" has is *not* [middleware](http://en.wikipedia.org/wiki/Middleware), it's a simple [pipeline](http://en.wikipedia.org/wiki/Pipeline_%28software%29) of [filters](http://en.wikipedia.org/wiki/Filter_%28software%29). A pipeline is a set of filters where the output of one is fed as the input of the next one. A filter may also abort pipeline processing if the request is handled in full by that filter (see [chain of responsibility pattern](http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern)). // Encapsulate inputs in a local variable, no more reading globals. $input = [ 'query' =&gt; $_GET, 'body' =&gt; $_POST, 'cookies' =&gt; $_COOKIE, 'server' =&gt; $_SERVER, 'env' =&gt; $_ENV ]; // Our first filter. $filter = function ($input) { ...Process and modify input... return [$nextFilter, $possiblyModifiedInput]; }; // The filter chain. $thunk = [$filter, $input]; while ($thunk) { $thunk = $thunk[0]($thunk[1]); // I.e. $filter($input); } And that's it. The loop will keep going as long as the filter (the "middleware") keeps returning next filter and input to be called. If you return nothing, the pipeline ends. This specific approach from the code example above is also known as a [Trampoline](http://en.wikipedia.org/wiki/Trampoline_%28computing%29). As for decorators (those "concentric circles" of nested logic typically shown with StackPHP's "middlewares") a simple closure would do again: $decorator = function ($input) use ($decorated) { ... do something before... $thunk = $decorated($input); ... do something after... return $thunk; }; If you want to build filters as classes, implement method __invoke($input) in place of method handle(HttpRequest $request), to make the object callable. No interfaces, no Symfony components. Just good old programming patterns. Practical use of the above setup: $router = new Router(); // __invoke() returns a matched filter to process a page (i.e. the "controller"). $cache = new CacheFilter($router); // __invoke() tries to serve cache, else returns $router. $csrf = new CsrfChecker($cache); // __invoke() checks CSRF token on a POST form if any, on success returns $cache. When we run the above in the chain loop, the pipeline will become : 1. $csrf(): CSRF token present, next. 2. $cache(): cache not present, next. 3. $router(): controller found, next. 4. $controller(): view configured, next. 5. $view(): echoes template, returns nothing, end of chain. It doesn't look different from StackPHP's "middleware", except without the overhead of pointless abstractions.
&gt; Fixed That looks like a lot of code to fix an error message! I'm not a c developer by any stretch. Still looks like a lot of code though!
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Post/Redirect/Get**](https://en.wikipedia.org/wiki/Post/Redirect/Get): [](#sfw) --- &gt; &gt;__Post/Redirect/Get__ (__PRG__) is a [web development](https://en.wikipedia.org/wiki/Web_development) [design pattern](https://en.wikipedia.org/wiki/Design_pattern) that prevents some duplicate [form](https://en.wikipedia.org/wiki/Form_(web\)) submissions, creating a more intuitive interface for [user agents](https://en.wikipedia.org/wiki/User_agent) (users). __PRG__ supports [bookmarks](https://en.wikipedia.org/wiki/Internet_bookmark) and the refresh button in a predictable way that does not create duplicate form submissions. &gt;==== &gt;[**Image**](https://i.imgur.com/R9EZqVQ.png) [^(i)](https://commons.wikimedia.org/wiki/File:PostRedirectGet_DoubleSubmitProblem.png) - *Diagram of a double POST problem encountered in user agents.* --- ^Interesting: [^URL ^redirection](https://en.wikipedia.org/wiki/URL_redirection) ^| [^Apache ^Tapestry](https://en.wikipedia.org/wiki/Apache_Tapestry) ^| [^Java ^view ^technologies ^and ^frameworks](https://en.wikipedia.org/wiki/Java_view_technologies_and_frameworks) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cql6b1k) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cql6b1k)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Reading more than one paragraph usually helps. You have a lot of clear examples below. Obviously this is not laravel, your knowledge of laravel doesn't translate 1:1 to diffrent framework. You still need to read docs.
The article has nothing to do with Ruby.
What's an elvis operator?
Ah, so the Drupal of e-commerce?
[GetSimple](http://get-simple.info/)
Take a look at Bolt cms. It's modern, lightweight, and maturing nicely.
Why do I have to read more than one paragraph to see a straight-forward example of one of the most fundamentally basic parts of a front-controller framework? And Yii is the odd one out, favoring convention over "configuration" (if you can even call route declarations configuration). Other frameworks are straight forward, you bind a callback to a route in the same declaration.. Whether it's a controller or an anonymous function doesn't matter, it's insanely easy to bind a handler to a route in literally every other framework. Aside from minor differences like `::` in Silex vs `@` in Laravel vs `-&gt;` in Fat Free Framework, the basic concept is all the same. And Laravel's default example is a closure anyway, which is the same for every other framework. If you know how to do routing in Laravel, you know how to do it in Slim, Lumen, Silex, Fat Free Framework, Fastroute, PHPixie etc. But at least routing in Yii isn't anymore confusing than it is in Symfony....
Thanks I'll check it out. My main concern is been able to do a search results page. Looks promising. 
how so?
Can if be used in production?
Yes? All of Facebook runs on Hack.
&gt; you can't earn more money with PHP than with Magento Simply not true.
Had some fun with the same thing in Ruby: alias :"（╯°□°）╯︵" :fail （╯°□°）╯︵ "Flip it!" # =&gt; RuntimeError: Flip it!
I have 2kg of caca to sell and am looking to buy 2000g of shit ;-) edit time limit?!?!: Jokes aside.... An interesting business plan no doubt.... Kinda just amazed that a marketing company convinced people to recommend their product by being somewhat honest about what they were doing. Someone said "They'll eat it up and we'll have the best software because it's funded".... and it actually seemed to turn out that way, and people actually believed them and trusted them... Who would have thunk.
Not all businesses are sleazy, ya know
That code looks like a drunk PHP developer.
Not PHP, but I have nothing but love for this: alias fuck='sudo $(history -p \!\!)' Ex: ~$ service mysql start start: Unknown job: mysql ~$ fuck mysql start/running, process 8674 
All I want is for the EAP to not run like shit on OSX.
Ok, thanks for the insight! 
Anyone else peak in here thinking this might actually be a useful bit of code for transposing database tables or something?
Facebook
http://php.net/manual/en/function.move-uploaded-file.php http://php.net/manual/en/function.unlink.php You supply the effort, these will get you started. Check out /r/phphelp
I branched one of my apps to try and see how hard would be to replace Slim Framework with Phalcon 2. Things went smoothly until I noticed that Phalcon Incubator does not work with version 2 yet, and I have a lot of Twig views, either for displaying landing pages or composing fancy emails. I guess I could ditch Incubator and recycle the Twig adapter alone to work with v2, when I get some free time as I had this morning.
A bit of a tangent, but what would you guys recommend for an ecommerce platform? (self hosted, with a good amount of the same functionalities)
It depends at which level do you want to learn, but I can really recommend PHP: Objects, Patterns and Practice, at least for the PHP part. If you already know some basics of PHP, like creating a basic code with some functionality (validating a form, or something like that), I think you'll find this book incredibly helpful. It introduces the concept of objects, classes with clear code examples and descriptions, and later in the book grasps more advanced concepts, so it's not just an introductory one. Just for a note, I've read it twice, and both times it was worth it, the first one for understanding really what OOP means, and the second one for claeification. Saddly, I haven't read another PHP book (setting appart blog pages, which is not the same), so I can't assure you that it's the "best" book (if something like that even exists), but I think it will help a lot, at least it has done it in my case. By the way, I choose this book after looking for books in this sub (search for "book"), but I'm sure many others will be okay. About mysql, I've heard a lot of good things about Percona's book, but I think I remember it's not a beginners one, so I can't help you there. Pd: I'm sorry if some sentences doesn't make any sense, I'm not a native english speaker. Please ask me and I'll try to clarify.
I have one of those but its proprietary :(
&gt; think eBay has grounds for a lawsuit I can never tell if comments like this are meant to be a troll, or if the type of people that comment on security related blogs really think this sort of thing.
I don't have an answer to your question but this has nothing to do w/ php
I'm pretty sure he was exaggerating to make a point.
It can. I've tried both the file and http protocols. 
It's the shorthand version of `?:` - instead of writing `$foo ? $foo : 'fallback'`, you can write `$foo ?: 'fallback'`. Magento does not use this, they still support 5.2 and this operator is 5.3+ only.
I use this, its minimizing the code, by stripping comments and whitespace. To some extent it solves obfuscating by making it harder to read and copy. $ php -w #-w Output source with stripped comments and whitespace. 
Its more that I am paranoid... lol just want to make sure changes come back to me..
You can set up your own search results pages. Either use the default one, or tweak the settings to your needs: https://docs.bolt.cm/content-search
it is safe to protect php code, just safe. the apc have the method to apc_dump_bin and apc_load_bin
might want to check out syllius. I haven't used it, but I've read a few things on how it was developed and it looks like quality software (symfony2, phpspec, loads of separation - I think they even have a full rest bundle that could be used externally).
:( you sound like you care a lot, which in my mind is the best attribute beyond not being retarded, have you thought about looking around for a more fun workplace? btw It depends on exactly what you're serving, but a full pageload in the browser, 2s is really not bad, just checked reddit and it's 3s from here
It's dead easy to create search results page - it's set up by default in bolt. They're really helpful too, get on the [IRC channel](https://bolt.cm/page/irc) or StackOverflow with the tag `bolt-cms`if you have any problems.
There's several services/applications who'll obfuscate your code, Zend Guard, Sourcegardian, IonCube etc.. They come at a fee though. Besides that, good code is meant to be shared, openly. 
*Throw more resources at the problem* Why are we *recommending* Wordpress to someone...in the /r/php sub?
The development of APC is stopped since PHP 5.5 and OPCache, and you cannot use OPCache to do this. op-code cache is design for ... caching op-code. Try something like Zend Guard or ioncube, it's design for "code protection". You can look at bcompiler too : http://php.net/manual/en/book.bcompiler.php
Issue was just marked as fixed. Guess we can expect this to work as expected in the next minor update :)
Thank you for the kind words :)
Just curious, why is your company opting for CI?
Short answer: NO! Long answer: NEVER! CI3 is just an attempt to blow a new life into a dying project, fixing bugs, introducing new security tools and so on, but it doesn't fix the core problem - an "old PHP style" architecture. Using it also might lead to adapt some really bad behaviour ;) Just use something modern, like Symfony2? :) You shouldn't start any new projects on already outdated solution
Awesome! Thanks for helping. I'm glad that this will work as intended.
"Converting" to it? Do you mean to say you already have a CI application? If not, I wouldn't go with it if at all possible. It's an old app built in an old way, with a lot of weird BC code built into it. I'd got straight for straight up Framework like Symfony2, or, if you want some more sugar, Laravel.
Don't do this.
&gt; By utilizing XML, we are able stay away from introducing an extra layer of slowness and complexity associated with connecting to a mySQL database. oO
Throwing adequate resources at a problem makes things run well. Putting any app on a poor server will slow it down. There are a large number of reasons why WordPress is the most popular CMS ever created. In my opinion, OP would lose more than they would gain by switching to another CMS. My recommendation was to learn how to use it well, as the reasoning "it seems sluggish" is subjective.
PHP has changed dramatically in the last 2-3 years, for the better. CI 3.0 doesn't take advantage of any of that. It's enough to see what CodeIgniter supports: PHP 5.2+. It means it still doesn't see anything we've got in PHP 5.3 and since (namespaces, closures, late static binding, traits, generators...). We're on the verge of PHP7, an update that will offer massive speed improvements and cement PHP's new coding style even further with plenty of new features and inconsistency fixes. And CodeIgniter still isn't ready to embrace *PHP 5.3*. The cultural gap is even bigger. Heck, CodeIgniter could support PHP4 with a couple of minor patches here and there, if they wanted to. Their paradigm is *that* old. 
It's dead. Go for Symfony2.
You can make the above code safe by adding an instanceof check guard around the getLeaves() call: if ($fruit instanceof Apple) { return $fruit-&gt;getLeaves(); } else { return null; // Either this, or alternative "leaves getting" logic. } But this should be more of an edge case, not the norm. What's happening actually is that you either need to have interface FruitWithLeaves that Apple implements and type hint for that, or hint for Apple directly. Coding to interface is extremely valuable when used appropriately, but it's *not an absolute*. Coding to interfaces is not about "do it or else you're a bad programmer". It's "keep it mind so you know it when you need it". Don't force yourself to follow practices you don't see the value of. Side note. Many frameworks call their interfaces "SomethingInterface". I consider this a poor practice. Most interfaces start as a class. Yes, a class (not forcing interfaces, see?). You have one implementation then a few months later, you realize this has to be an interface, with many implementations. Let's say class SqlConnection. You'll rename the class to DefaultSqlConnection, then extract an interface from its methods with the old name: interface SqlConnection. Now all code asking for "SqlConnection" still works. No breaking changes, no code changes for users. As for those who extend or instantiate SqlConnection, they need to change to DefaultSqlConnection, which should be only in a couple isolated places in your code, if you favor DI &amp; composition over inheritance. If instead you had to rename SqlConnection to SqlConnectionInterface... now all SqlConnection using code throughout your project(s) has to change their hints. So in a nutshell: - Don't prefix and suffix your interface names. - Start with a concrete class, evolve to interface on a need by need basis. - Don't force yourself to follow good practices in a way that disturbs your workflow, the only way to do it right comes from true understanding of the underlying value. P.S.: It helps if you use specific examples in your code. It's hard to give proper advice on how to model fruits, apples, mangos, cats, dogs etc. Context matters.
&gt; It means it still doesn't see anything we've got in PHP 5.3 and since (namespaces, closures, late static binding, traits, generators...) I know what some of those are.. I'm a shitty web developer :(
Figured it out- Needed to add another parameter- simplexml_load_file($target_file, null, LIBXML_NOENT);
Your $Total variable is equal to 7 (because there are 7 items in your array). So your loop is counting from 0 to 7, it never gets to 8. Consider using a foreach loop, or if you're keen on printing "3 is empty, 8 is empty" etc figure out a way to get the last index of the array (8 in this case) and use that in your for loop. 
I highly recommend checking out ProcessWire. Specifically, watch their video (you'll know the one instantly, its the one where the guy's talking like a pirate). Stick the video out and watch what they produce, don't skip through it if you can help it.
It does: https://github.com/puphpet/puphpet/blob/master/archive/puphpet/puppet/Puppetfile
I would say it's better to hide a ping in there, that phones home. Since the "great mate" won't thinking is friend is paranoid. 
You probably never heard of Guzzle &amp; the Symfony DomCrawler.
This would work with no issues if instead of unsetting the array items, you simply set them to null.
I'd love to hear your thoughts on it. I set up a small CMS with a mysql backend that ran horribly slow on a raspi. I don't recall the CMS, but it wasn't Wordpress. GetSimple runs much better with limited resources. 
&gt; I'm looking for a way to run code inside my PHP application. Idea: write your code in PHP?
As a beginner, just choose one that is well-documented and easy for you to use. You don't really need a DIC if you are learning the basics, either. You can inject dependencies manually.
How complex do you need the code to be? If you need to provide some really basic stuff, like loops, variable sets, and basic output, perhaps letting people input Twig templates would suffice? At the far end of the spectrum, you could load the code into a file, run a docker container to execute the code, and grab the output -- just isolate the container from everything and make it ephemeral to secure it, ala docker run --net=none -t -v /path/to/user.php:/user.php php php /user.php You can also add some cpu/memory limits to the container as well. There may even be a way to stream the file to execute into the container instead of letting it hit the disk (/path/to/user.php)
If it's for in-application extensions, then try to look for a familiar language runtime. I've made myself a litte pseudo-JavaScript-to-PHP compiler back then. The use case quickly evaporated though. But there was another more thorough implementation quickly thereafter: [J4P5 (JavaScript for PHP5)](http://j4p5.sourceforge.net/). It's just an interpreter though, not a VM or code transformator. It's however perfectly sufficient for some output and control logic. (You probably don't want to do excessive data munging in a VM running in a VM either.)
I'm going to take a different stance here. It seems most people in this sub love to fall over 'the new' technologies (Which is ironic for a PHP sub). In my opinion and experience CodeIgniter is a good solid framework with excellent documentation, works well with Git, and can be used for team projects. Sure it isn't flashy, it gets the job done in a more organised and simple way than using raw PHP. Although what you really need to do is try out all of the frameworks and see which one works best with your company's workflow. All frameworks get the job done, just some do it differently to others.
I'd take a look at this site and see if you can figure out how they do it: http://3v4l.org
I think if you are doing this kind of tutorials, the first video probably should be how to set up a dev environment. E.g do you just run "php -s localhost:8000 test.php" or do you download mamp/xampp etc. 
What's the motivation for making a determPwGen class? It's a fair bit of extra baggage around the code (although potentially more portable). The entire class and the 3 lines in php-determ-pwgen.php to include/invoke it could be rewritten in just three inline lines of code: $hash = $salt . $site_label . $username; for ($i = 0; $i &lt;= $rounds; $i++) $hash = hash('sha256', $hash); (the $string variable was redundant, you can get away with out it) Also: function __construct($rounds = 1000, $salt, $site_label, $username) giving $rounds a default of 1000 has no utility in this case since you'd always need to send a value as the first parameter. edit: Oh and by having $i &lt;= $rounds, you're actually going to go through $rounds+1 rounds.
I see. Thanks for the warning. I am leaving the company, and the developer taking over the projects wants to port our ecommerce soltions to CI. (We've been using a self built MVC system up until now) He says the new CI has different maintainers and is now fully on track again after being a "dead" framework for a while. Anyway. Thanks for the input. I'll look deeper into this. 
I am leaving the company, and the developer taking over the projects wants to port our ecommerce soltions to CI. It seems this developer ONLY develops in CI.
"And CodeIgniter still isn't ready to embrace PHP 5.3." CI 3 recommends php 5.6.
not a senior coder, but these are my suggestions: * reorder parameters for determPwGen::__construct so that the optional parameter rounds comes last. or just get rid of the rounds parameter alltogether and implement setRounds * extract the 1000 rounds default as a constant * rename determPwGen to DeterministicPasswordGenerator, making the name obvious (otherwise people have to remember the exact way you used to abbreviate the name. minimize situations where developers have to think whenever you can). also it is common to start the name of classes with a capital letter. * why is it "generateHash" but "site_label"? yea one is a variable and the other a function, but keeping it consistent increases readability There is some more you could do, you might enjoy the book "clean code" by Robert C. Martin edit: reddit syntax ..
Don't obfuscate it... Stick it on a Gist or on Github, or somewhere else, with some good usage documentation. Be a good developer. Hiding code will lead to worse things happening.
Separated class = portability. I'm going to put a site also. Nice catch on the loop, I'll fix that :) Thanks for the read and suggestions!
Great suggestions! Thank you for going through it and sending your opinion my way, I'll go through it all to make the pertinent changes.
His PHP-powered app is probably going to be able to run third-party submitted snippets. Like an application where you can submit your own code. He has to run this third-party code sandboxed, and the best way to do this is to get a vm running.
Did you find Embedded Composer when you were working on this? If so, I'd love to know more about the decisions that led to not using it for your project. If there are things that need to be fixed or updated I'd love to know what issues you ran into so I can try to address them. https://github.com/dflydev/dflydev-embedded-composer
Check out [this stackoverflow answer](http://stackoverflow.com/questions/348109/is-double-hashing-a-password-less-secure-than-just-hashing-it-once/17396367#17396367) Basically, you want to feed back data into the hash on each iteration: $string = $this-&gt;salt . $this-&gt;site_label . $this-&gt;username; $hash = ''; for (...) { $hash = hash('sha512', $hash . $string); } Additionally, I'd suggest changing the for to a `do {} while()` so that you know for a fact that the hash will run at least once: $i = 0; do { $hash = hash('sha256', $hash . $string); } while ($i++ &lt; $this-&gt;rounds); In fact, if you're on 5.5+, I'd suggest changing to [hash_pbkdf2](http://php.net/hash_pbkdf2) as it's much more secure and is standard.: return hash_pbkdf2("sha256", $site_label . $username, $salt, $this-&gt;rounds); Finally, if you're not passing any parameters into `generateHash()`, there's no reason for it to exist. Instead, I'd suggest refactoring it to accept the site label and the username: class ... { public function __construct($salt, $rounds = 1000) { /.../ } public function generateHash($site_label, $username) { /.../ } }
&gt; Are people confused about this? Well, it doesn't help if instead of calling things with their name, some prefer grandiose names like "Middleware" and "Kernel" for simple patterns that already have a name. &gt; &gt; What "StackPHP" has is not middleware, it's a simple pipeline of filters. We followed the naming conventions used by those before us who implemented the patterns you mention in the context of HTTP applications. Two of which include: * https://docs.djangoproject.com/en/1.8/topics/http/middleware/ * https://github.com/rack/rack/wiki/List-of-Middleware &gt; No interfaces, no Symfony components. Just good old programming patterns. Frameworks, libraries, and applications are collections of programming patterns put together in a certain way. The same thing can be said about any library or framework out there. "This is just [x pattern] that could be done from scratch! No need for fancy interfaces or components!" In the case of Stack, we were not even claiming to be a library or a framework. We went out of our way to describe Stack as a set of *conventions* for writing HttpKernelInterface implementations that could be reused across the Symfony ecosystem to add behavior to any application that was based on HttpKernelInterface. Our long-term goal was to make something truly framework agnostic. This would be extremely hard to do and gain any traction. So in the short-term we intended to make it easier to make software portable between Symfony ecosystem projects. Could we have gone with `__invoke` instead of HttpKernelInterface's `handle`? Sure. We weren't looking for a general solution, though. We were specifically trying to make it possible to decorate HTTP Requests and HTTP Responses. Since we were Symfony ecosystem developers it made sense to start with decorating HttpKernelInterface instances.
I'm guilty of using Composer, Eloquent and Pimple with a CodeIgniter app. It works great.
&gt; Our long-term goal was to make something truly framework agnostic. This would be extremely hard to do and gain any traction. Why? &gt; Could we have gone with __invoke instead of HttpKernelInterface's handle? Sure. We weren't looking for a general solution, though. This seems to contradict your previously stated long-term goal. &gt; We were specifically trying to make it possible to decorate HTTP Requests and HTTP Responses. Since we were Symfony ecosystem developers it made sense to start with decorating HttpKernelInterface instances. What you did is simple &amp; low-friction for Symfony users, so if your goal is to set up a sub-ecosystem of components within the Symfony ecosystem - fine. Job well done. But there's a giant gap to go from this to a general solution. And you don't seem to advertise yourself as a Symfony solution, but as a general solution, hence why the frustration that you depend Symfony components which do almost nothing for someone who isn't already invested with Symfony. The HttpKernelInterface seems so simple on the surface, it has one method. But it takes Request instance and returns Response instance, which are massive (and heavy) components with something like 50+ methods and properties each, and drag a bunch of other classes along. Your "middleware" will tightly couple with those heavy components and so Symfony will be forever a prerequisite for using your components. I'd blink on this if we didn't have HTTP input/output in any form in PHP, but we already do. In my code example, I went from "superglobals" to a local variable holding request data in 5-6 lines of code. Not using superglobals is the only benefit you reap by using HttpKernelInterface. Everything else can be implemented in helpers and utility classes which are independent of the "middleware", instead of being shoved in the request and response god classes as a hard dependency. P.S.: Rack's filters are bombastically called "apps" to impress the easily impressed, and which is why they went and called their filter decorators "middleware", to keep the metaphor of "pretend platform" started with "Rack" and "app" consistent. It's silly, but they know why they did it. Why did *you* do it? Because Rack is trendy, and you wanted to be PHP's Rack, no? 1. Rack =&gt; Stack. (I see what you did there even your logos are conceptually similar) 2. Middleware =&gt; middleware. (There we go) 3. App =&gt; uhmm ...Kernel. And that's why people might be confused. It feels cobbled together in terms of naming and dependencies.
If you check the poll results, you can see that the people against composer/namespaces/etc are very vocal, but they not represent everybody. About my post, the topic creator should code with a modern framework, as I suggested.
http://zephir-lang.com/
personal opinion here but for portability purposes I'd be implementing this as a function instead of a class, since it only has one function and an instance is likely only to be used once. it's easier for me to call: detrmPassGen($rounds, $salt, $site_label, $username) than instantiate and then run a subroutine. 
No you didnt. You mention first about waiting for CI 4. When you get caught out with your fanboy-ish. Which you knew you would. You half-heartedly mention OR... suggesting other frameworks. You know deep down, CI3 is nada. Poor little php-newbie.
I thought it was obvious that CI would take at least 3 years to be released. Sorry for the confusion guys. And peter, i've been following PHP for 15 years, and if my discretion, empathy and engrish make me look like a newbie, I don't really care.
You might be in the same position in 10 years from now (if you are still a developer by then).
Ok, in case anybody cares, to make Incubator's Twig work with Phalcon 2 is really simple. Instead of &lt;?php namespace Phalcon\Mvc\View\Engine; use Phalcon\Mvc\View\Engine; use Phalcon\Mvc\View\EngineInterface; class Twig extends Engine implements EngineInterface { ... } It should be &lt;?php namespace Phalcon\Mvc\View\Engine; use Phalcon\Mvc\View\Engine; class Twig extends Engine { ... } The rest is left untouched and work flawlessly. 
Oh I meant like a checkbox before you download the zip that would use librarian puppet to get the modules instead of having them come with it. That's all! Btw, loving the new interface. 
Your next step would be to make it better. You have no tests, and everthing in one class. This is not good. Please read phptherightway and take a look at some general best practices for programming. Focus on quality, and you will get more "stars".
Disabling the submit button still allows people to submit by hitting enter in a form field. Handle the *submit event for the form* instead and call event.preventDefault(). Also, for critical forms, like payment forms, where submitting twice might cause a lot of trouble, use one-time tokens generated and verified at the server. This is the only 100% sure way.
Why can't you hear a pterodactyl go to the bathroom? The p is silent.
This is honestly my very first open-source project. And it's also my first project where I've included tests. So please keep that in mind if you notice my tests aren't quite that good according to your standards and my documentation still lacks a bit. (A)