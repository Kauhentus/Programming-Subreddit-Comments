Every linux machine already has gpg installed. There's nothing to install.
&gt; They're saying no to your implementation, aren't they? No, they're saying no to *solving the problem at all*, regardless of which implementation is chosen.
Why *shouldn't* it be used? It's crypto is more modern, as /u/sarciszewski has explained, the algorithms that GPG supports are both weak.
It's... not that simple. For example, go ask the RetroShare developers how often they've had to deal with oddball GPG installs that don't *quite* have the same API as they've built against... and that was using GPGME, which is *specifically designed for this purpose*! Seriously, "wrapping GPG" is *not* a trivial thing to do. It's absolutely not integration-friendly in the slightest. EDIT: Aside from that, no, not every Linux machine already has GPG installed.
Not so easy to do if your mcrypt-related code makes use of `MCRYPT_RIJNDAEL_*` :(
Yeah pretty much. "It's dead! Except for all the other browsers you have to support"
Attempted this today, I failed ._. they really bumped up the difficult on this one, But at least now I know what to read up on :D 
That would be awesome.
&gt; Cross-Site Request Forgery, also known as CSRF or XSRF, has been around basically forever. This sentence is basically terrible.
Always, with the secure hookups!
Plus you'll probably want to run it in Lax unless you want to have a crappy user experience, and then that reduces some of your protection if you aren't diligent about using POST for modifying actions. Or diligent about what your router accepts.
&gt; they should invest in an HSM and an infrastructure overhaul first This is where you and I *agree* (I believe?) which is - that is MASSIVE overkill. What is that going to get them, apart from a hideously expensive HSM? They'll still need to implement X509, or SOMETHING, to actually validate the trust chain. Your implementation, elegant and intriguing as it is, seems to suffer (to me) from a the same complexity, which is why I brought up the GPG idea, which bypasses all of that.
/u/NeoThermic was the one who pointed that out on IRC. I was simply relaying their finding. :)
Which IRC channel? I'm normally in ##php and didn't see anyone calling me an arse more than usual 8)
Gotcha, Maybe that should be broken out into a "resolver" that collects the request information and then passes everything over to the parser for the matching, and then sends the response via the handler based upon what it gets back? Thanks for taking the time to look at this, I appreciate it! 
It's not a very well known channel, due to literal Nazis polluting the other one we used to hang out in (#lizardhq).
These checks in your get/post/put/delete methods can cause issues, depending on your intended usage for this library. What happens when I want to register both a GET and a POST route? Or am I not supposed to? if ($this-&gt;method !== 'GET') { throw new WrongHttpMethodException('This is not a GET request.'); }
The way passwords are salted (correctly) hasn't changed, it's just done inside the PHP function automatically. password_hash() used to accept a parameter so you could pass it a custom salt but the PHP maintainers quickly released this lead to people creating their own, less secure salts for absolutely no reason so they removed hat option.
Thats a very good point, and one I hadn't honestly thought of. When I go to pull out the URI/Method from the router and put that in a "resolver" I'll look for a way to fix/add in that aspect of the router. I had initially just wanted to put together a basic implementation to grasp the inner workings fully hence why these issues are here. I really appreciate the feedback!
&gt; branches try this one https://secure.oneallcdn.com/extensions/phpbb/3.1.x-3.2.x/phpbb--3.1.x--3.2.x---oneall_social_login-2.7.zip
&gt; References are frowned upon What do you think about [this proposition](https://github.com/vimeo/psalm/issues/101)? Given they're a language feature, Psalm ought to be able to reason about them and prevent people from doing stupid things...
And a PHP5+ (probably PHP4 too) polyfill function: https://gist.github.com/bohwaz/f7c7cc08fa11399f485be3e65f19a4f4
https://github.com/ezyang/htmlpurifier
When in doubt, throw an exception. If nobody else catches it -- well you gave them the chance.
Have you considered differing the sending to Logstash using Filebeat for example? Writing the data to a file, and letting filebeat handle the sending, instead of a synchronous call in your requests?
thanks will give this a try Edit: Tried it, not what I'm looking for.
You're welcome.
Php Inspections (EA Extended) is a Static Code Analysis tool available as PhpStorm/IdeaUltimate plugin. The plugin adds a load of new customizable inspections to the IDEs. What makes this tool special: it boosts up your productivity without interrupting workflow: on-the-fly analysis and quick fixes are at your service. * Short introduction video: https://codereviewvideos.com/course/phpstorm-shortcuts/video/become-a-better-developer-with-php-inspections-ea-extended * Getting started: https://github.com/kalessil/phpinspectionsea/blob/master/docs/getting-started.md * Rules list: https://github.com/kalessil/phpinspectionsea/blob/master/RULES.md
&gt; Someone needs to replace Where is the bug report ? Where is the pull request ? No report, no bug, no fix.
Maybe the support is not perfect but the flag itself is good to know though. Another interesting one is httpOnly that can reduce the risk of session stealing via XSS.
Could you elaborate on why you think same-site cookies is a poor man's CSRF protection?
I wouldn't spend too much time on learning about multiple packages that do the same thing. But I would say it's very worth it to learn about new stuff that people generally use packages for like Redis, RabbitMQ etc. Another thing that in my opinion is very important is really having a deep understanding of the SOLI**D** principles, and especially the last one: Dependency Inversion. If you always have Dependency Inversion in mind when programming you're going to come up with much better and much more portable solutions then you otherwise would. Another very big one is learning more about functional programming, you can get the basics from other languages if you want (erlang, haskell, java.. it really doesn't matter) and then learn how to apply those principles in PHP. Check out: https://github.com/lstrojny/functional-php and https://github.com/schmittjoh/php-option they are my favorite two libraries to use in any project!
Is something like this available for sublime text?
I saw this posted once and missed the name. this time I've installed it immediately so I won't forget! I'm pretty excited to use it. thanks.
You're welcome.
This means nothing coming from a bot.
your [seo spam](http://matrixmarketers.com) article was a fascinating read, however i noticed your [onsite-seo](https://shady-seo-biz.org) is lacking, maybe you should get help from an [seo company](http://shady-seo-biz.oth) :) Get what I'm saying?
You are welcome (this time from a human) ;) 
indeed ;)
&gt; With this mechanism, on my computer and using Docker, large and complex responses are served in ~15ms instead of ~700ms without cache. Is this accurately "700 milliseconds"? Or is it "microseconds" or something? If it's milliseconds, that's... you get 1.5 requests per second? The elephant in the room is why are even your *cached* responses slower than the *uncached* responses of every decent PHP app I've seen and run. Also the problem of this solution is that locks you completely into Doctrine. When shortcomings of Doctrine are pointed out, people usually respond with "but you still can run SQL if you want" or "you can use it only for some state, not other state". Well all of this is out the window, because this cache requires you to use Doctrine for everything, and at all times, or else your cache will return invalid results. This type monolithic outcome is something I've become accustomed to seeing from API Platform and its userbase, I can't think of a worse way to shoot yourself in the foot than relying on such a tightly coupled ball of dependencies for your APIs, at least if your APIs are important to your business. Also I seriously doubt the cache invalidation works correctly in all cases. Say I have an API response counting users based on some criteria, so I run DQL like "SELECT COUNT(u.id) FROM User WHERE some condition". What will happen here, will the cache actually write down this response as being invalidated by potentially **millions** of unique user ids? I doubt it. 
I would argue that either: 1. This is the correct response to what OP's asking. 2. This is the wrong response to what OP's asking.
This sub states, exactly, "/r/PHP is not a support subreddit. Please visit /r/phphelp for help". 
Quite the fan of this as one additional thing because it's simple, given the proviso there is a two-tier cookie system as described in the article. On the subject of cookies... We need a mechanism for clients to have a setting (on by default in EU) to disallow cookies and non-GET requests from all sources unless a box is clicked to confirm cookies. Any Set-Cookie headers should not be honoured by the client, and no non-safe REQUEST (by method) honoured if this setting is enabled and the box for the site not clicked. That would IMO be a better effort saver as the client (theoretically unlimited clients exist) has the power to protect it's users rather than a server which is reachable by said clients needing to protect those clients. Why the tangent? The method in the article as far as I can tell requires the client to honour the header, so it's really not very secure when dealing with those that already spoof referer headers and other existing details. You'll still need a server component (and I'm guessing that'll be some form of CSRF).
&gt; &gt; [Clean Architecture] is a very near paraphrase of Action-Domain-Responder &gt; &gt; Which is a very near paraphrase of Hexagonal Architecture, Flux architecture, PAC architecture, about a thousand MVC architectures and so on. Tanks, I love you man, but you're misquoting me. :-)
awesome plugin, great work man :) thanks so much
&gt; we loose our ability Please re-read the definitions of loose and lose in a dictionary.
This is pretty much a copy of Dave Hollingworth's PHP-MVC framework as show on his Udemy course, you also should've included a copyright notice as stated in his [LICENSE](https://github.com/daveh/php-mvc/blob/master/LICENSE).
I like the idea of ADR but this is quickly turning into a circle-jerk.
No particular point, just showing it can be used in all circumstances, function name, class name, variable name, etc.
What am I misquoting.
Thats assumption rather than fact though.
Love the plugin. Not only does it help with refactoring but teaches good coding standards too. Great work!
Good idea, hadn't done anything like a bench mark or large scale test yet, thanks for the idea!
Yes, but that's not the subject of that particular quote. That particular quote describes the Silex route logic specifically, not Clean Architecture overall. To summarize accurately, it should read "[The implemented Silex route logic description]" not "[Clean Architecture]".
Still sounds like unnecessary over engineering to me. Why not just test if the object has the required methods? (This idea still makes me sick up in my mouth a little :-( ) "because I could" - worst implementation reasoning ever ;-)
&gt; I hope that PHP will change to become more of a static language than a dynamic one I hope the author ~~dies in a fire~~ wins the lottery and retires from computing instead. I like dynamic languages. A lot. Which is why I really like PHP. Its very dynamic. I can make it do amazing tricks that are impossible in static languages. That's a good thing. As to his library thingy - he just reinvented Objective C's 'conformsToProtocol:' - which is cool and all I guess.
It's probably only his third language: have some understanding.
I'm not a fan of such routing via pre-defined strings that are based on some made up syntax. For my own needs, I simply explode the path segments and the query string into arrays and pass them to a controller (for GET methods). It's then up to each controller how to interpret those. I wanted to keep it as transparent and close to the metal as possible.
Sure but the linked project (at least at the time) *had no tests*. I would be incredibly surprised if it is flawless because of that. I get your point but... I am very certain it does not apply to *this* piece of software...
Different experience levels of readers. :-)
Fully understand that, and thanks for the perspective! I mainly wrote this to learn more about how the inner workings of some of the other routers work. (my brain works better when I'm actually doing it instead of reading it)
What can you do in dynamic languages that you can't in static ones? Look at more modern languages like Swift or Scala. You can have safety and elegance.
Had to go to the linked repo to see what it had to do with WikiMedia, but yeah it's nice code, a slightly long-winded explanation
If you're creating anything more than just a few front end pages, you are best off learning a template framework like twig. Learning a template framework will better separate concerns (database logic, business logic, and template) and make some common functionality and ui elements easier to implement. Most PHP systems use some template framework, learning one will help you learn others. 
Router has been updated with the feedback from here and tagged as 2.0.0 due to the changes in the public api that came from it. Thanks again everyone for there feedback! I really appreciate it!
I don't disagree with you on the JavaScript MVVM/MVC aspect. But I wouldn't consider PHP a good template language on its own (maybe there are libraries out there that make it better). I only suggested something like twig as OP made it sound like he wanted something more basic for generating HTML and learning a JavaScript framework would be a lot of extra work for functionality that may never be used. 
Agreed on first basis. Then again: once he starts learning about Frameworks, each of them are coming with their own templating implementation. That's pretty much the first start. And afterwards learning about Plates, Twig, and whatnot is not a biggy anymore. &gt; As to the OPs question, a strong reason to not write your html in php strings is because editors wont help you out with syntax color and autocomplete. This though made me chuckle. Is this actually happening in the real world? I mean in what universe are editors touching code anyways? Either it's a company where content-people are juse using the frikkin CMS, or whenever they have specific needs they'll just pay you to do it. In the past 15 years I've never come across the need of just a single customer to touch templates of any sort.
The "best practice" you're describing with the second example is called "separating logic from presentation," and it really becomes evident when it comes time to edit what is displayed and your output is based on something more complex than just assigning a variable, then echoing it. Consider the following (very simplified, clunky, thrown-together)^0 example of reading from a database: &lt;?php echo "&lt;select name='my_dropdown'&gt;\n"; echo "&lt;option value='default'&gt;Default Option&lt;/option&gt;\n"; $stmt = $dbh-&gt;prepare("SELECT `value`,`desc` FROM `options`); $stmt-&gt;execute(); while ($data = $stmt-&gt;fetch()){ echo "&lt;option value='".$data['value']."'&gt;".$data['desc']."&lt;/option&gt;\n"; } echo "&lt;/select&gt;\n"; Compared to this: &lt;?php $stmt = $dbh-&gt;prepare("SELECT `value`,`desc` FROM `options`); $stmt-&gt;execute(); $options_data = $stmt-&gt;fetchAll(); ?&gt; &lt;html&gt; &lt;...&gt; &lt;select name='my_dropdown'&gt; &lt;option value='default'&gt;Default Option&lt;/option&gt; &lt;?php for ($i = 0; $i &lt; count($options_data) -1; ++$i){ ?&gt; &lt;option value='&lt;?={$options_data['i']}['value']?&gt;'&gt; &lt;?={$options_data['i']}['desc']?&gt;&lt;/option&gt; //note 1 &lt;?php } ?&gt; &lt;/select&gt; The loop code looks uglier right now (but even that can be cleaned up further - this is a quick punch-up) but you'll come to appreciate it down the line when, say, the demand comes down that a new field, 'help' is being added to the `options` table, and they want a list of each option along with it's "help" value to be displayed above the dropdown. The complexity of that change just got a lot larger than it needed to be. You'll still have to decouple the database code from its comfy little nest inside the html "select" element anyway, and rewrite the entire loop. Repeat that for dozens of elements just like that. In the second option, you only need to change the first line (plus, obviously, add the new code to output it), and don't have to mess with the code already in place. Don't worry. Repeating the &lt;?php... ?&gt; tags isn't going to be nearly as painful as you think, once you're doing it right, because the vast majority of the code (the "logic") is going to be separate from the HTML (the "presentation") anyway, so you're not opening and closing tags constantly. And if you're simply echoing a value, make good use of the &lt;?=$foo?&gt; construct instead of &lt;?php echo $foo; ?&gt; Notes: ^0: If that's not blatant enough: DISCLAIMER: This *isn't* good code, and is only intended for purpose of illustration. ^1: I don't think I got the curly braces quite right for the new PHP7 array associativity rules here
First, understand tech keeps moving, and the newest and most common use for PHP is a back-end API. This means your front-end will be html, css, javascript, jquery and/or maybe a framework like Angular/React (note some frameworks dont use/like to use jquery). In these apps you send messages in JSON format to the PHP back-end and the PHP back-end processes the messages, does some business logic (such as update the database, send data to a third party, make a payment etc.) and then sends status and payload data back (sometimes using HTTP codes for status) and JSON format for data. When the Javascript makes the call to the back-end to call a PHP program with an action and some data, it also defines the callback function that will process the response. Sounds complicated but it is actually very simple. Everything your back-end program outputs get sent back to the front-end, so you program could be as simple as this: &lt;?php $action = $_POST['action']; // sanitize and validate here // perform action using switch or router logic switch ($action) { case 'login': do_login_function();break; case 'getUsers': get_user_list(); break; default: outputError(); break; } die; ?&gt; So in this scenario you are not really using PHP any more to output HTML, just to output data that the front-end parses into a view. Of course, you dont have to code this new AJAX way. The old way still works fine where you output a complete page using PHP. There is no defacto standard for what you want, but I like to use heredoc format: &lt;?php echo &lt;&lt;&lt; EOS &lt;div class='myclass'&gt; {$myVar} &lt;/div&gt; EOS; ?&gt; I personally find this is the cleanest code - you output everything inside the PHP heredoc. 
Preach. I left C# and found PHP quite enjoyable because of its dynamism.
Yes you're right. I am aware that learning framework will be the best option here but I have this fear of diving into any situation without proper understanding of what is happening in that situation. like Route::get('/gohere',function(){echo "hello world";}); I understand that it will go to the gohere page and print hello world string but the impression I always got is "how did he do that? (with fascinated eyes)" or at least basic technical idea how to make like that so that I would understand better
got it boss! makes perfectly sense! how about speed? does it have an effect since if you put your html inside echo will it still go to the server or still ignore by the php?
I'm not really sure. How would you recommend I go about buffering them?
Yet we are all very happy that we can type-hint more and more things like scalar types, return types, callables, iterables and so on… PHP is in an interesting place where you can do dynamic typing *and* strict typing depending on what you want or need. Having more options to do static typing would be great (generics or typed properties for example) and wouldn't prevent from using dynamic typing whenever we want to.
A whole lot of magic. Swift isn't "more modern" - its a throwback to C++. Static &lt;-&gt; Dynamic is a continuum and what constitutes "modern" or "current" varies like skirt lengths in Milan. At the moment, static seems to be all the rage again. I cannot imagine why. But I've been there. Working in Swift feels like having my wings clipped. Consider the very common task of carving out a hunk of server database so a mobile user can carry it around with them. The Swift way of converting a json message into an object: override func mapping(map: Map) { super.mapping(map) id &lt;- map["id"] accountId &lt;- map["accountId"] username &lt;- map["username"] email &lt;- map["email"] emailVerified &lt;- map["emailVerified"] firstName &lt;- map["firstName"] lastName &lt;- map["lastName"] deviceId &lt;- map["deviceId"] deviceToken &lt;- map["deviceToken"] facebookToken &lt;- map["facebookToken"] profilePhotoOrigUrl &lt;- map["profilePhotoOrigUrl"] profilePhotoSmUrl &lt;- map["profilePhotoSmUrl"] profilePhotoLgUrl &lt;- map["profilePhotoLgUrl"] bannerPhotoUrl &lt;- map["bannerPhotoUrl"] lastUpdated &lt;- (map["lastUpdated"]) status &lt;- map["status"] caption &lt;- map["caption"] visibility &lt;- map["visibility"] receiveNotification &lt;- map["receiveNotification"] profilePrivacyType &lt;- map["profilePrivacyType"] updatesPrivacyType &lt;- map["updatesPrivacyType"] showAccountMetrics &lt;- map["showAccountMetrics"] showContentMetrics &lt;- map["showContentMetrics"] toAccountId &lt;- map["toAccountId"] fromAccountId &lt;- map["fromAccountId"] isPending &lt;- map["isPending"] verifiediAccount &lt;- map["verifiedAccount"] // Discover: 'Trending' Accounts support let JSON = map.JSONDictionary as NSDictionary if let contentsJSON = JSON["contents"] as? NSArray { trendingContent = Mapper&lt;TimelineContent&gt;().mapArray(contentsJSON) } } ugh so much typing for so little benefit. Here is kind of the same code in Objective C - note that this is in the superclass - I don't have to change it for subclasses. This code also fetches the appropriate object from the database and updates it if it exists - otherwise it will insert it. The Swift code doesn't work with databases. The database schema in the Objective C version, BTW, is completely generated by introspecting the class definition. +(instancetype)fromJsonDictionary:(NSDictionary*)items { NSArray* pkNames = [self primaryKeyColumnNames]; NSDictionary* keys = [items dictionaryWithValuesForKeys:pkNames]; id object = [self find:keys]; if(!object) { // object is not persistent - do not make it so object = [self new]; [object setValuesForKeysWithDictionary:items]; return object; } // if object was persistent - save update [object setValuesForKeysWithDictionary:items]; [object save]; return object; } This is the PHP side code for fetching an account from the server database as the json that this other code consumes. $id = ValueOrDie('id',$_GET); $ids = explode(',', $id); $accounts = Account::find($ids); Success(['accounts' =&gt; $accounts]); and updating it looks like this: if(IsPost()) { try { $account = Account::CurrentAccount(); $id = ValueOrDie('id',$_POST); if($id != $account-&gt;id) { throw new Exception('Not authorized to modify this account',403); } $values = DropEmptyKeys($_POST); $account-&gt;takeValues($values); $account-&gt;save(); Success(['account' =&gt; $account]); } catch(Exception $ex) { Fatal($ex); } } The account class is, again, virtually empty and its structure is completely determined by querying the database it sits on (poor man's active record implementation I wrote). So the model classes are mostly shells around hashes and use magic methods to synthesizes accessors. Basically I cloned KVC in PHP. These are them. public function __get($name) { $method_name = self::CamelCaseFromUnderscore($name); $field_name = self::UnderscoreFromCamelCase($name); $fetcher_name = 'get'.ucfirst($method_name); if(method_exists($this,$fetcher_name) &amp;&amp; !array_key_exists($field_name, $this-&gt;_data)) { $this-&gt;_data[$name] = $this-&gt;$fetcher_name(); } if(method_exists($this, ($method = $name))) { return $this-&gt;$method(); } if(array_key_exists($name, $this-&gt;_data)) { return $this-&gt;_data[$name]; } return null; } public function __set($name,$value) { if($value === false) { $value = 0; } $name = static::CamelCaseFromUnderscore($name); if(method_exists($this, ($method = 'set'.ucfirst($name)))) { return $this-&gt;$method($value); } if(is_null($value)) { unset($this-&gt;_data[$name]); } else { $this-&gt;_data[$name] = $value; } return $this; } Dynamic languages are kind of self aware. You can write code that reasons about the code itself because you have proper meta system to work with and that means you can take shortcuts. The Swift version is monkey work. Where is the value in writing: foo &lt;- map["foo"] For every single attribute? I don't have time for that. There's a lot more but I'm hoping this is illustrative. EDIT: Oh and thanks for the down vote. A question was asked, I put considerable effort into answering it...and I got down voted. ~~Fuck You~~ Thanks Again. 
And Scala has structural typing built in, so you can declare a parameter type as `{ def id: String }`. I'm not sure how widely it's used. There's also implicit conversions (not the scary ones PHP does), so if you declare a parameter as a String but you pass an Entity to it, that will work as long as there's some way to convert the entity to a String in scope. And of course, there's good ol' type overloading as well. Which is probably your best bet in this case. 
That's a good idea. Would you suggest still using a DB on the backend? Would you recommend going with an RDBMS or a NoSQL solution?
It's no different to any header AFAIK, but I'm not aware that anyone ever said just put HSTS and other header-based-solutions in-place and leave it at that. You can use server rules to upgrade insecure requests to https, not have the application available on port 80 (or any non TLS). These are all additive security measures. I'm not saying they are useless (they work for the 90%), but they fall apart for those that would do harm and are dedicated. They also stop most script kiddie dickhead attacks via JS AFAIK It's not that there is a silver bullet I have to offer either, it's more that it is hard work, and should be. We should all be doing our best, and if we do then good for us.
no. both times Ive started somewhere new, they had a license waiting for me. 
Nothing I can disclose as it's mostly client data, but typically brings down any given request by about 10/15 milliseconds on reads. Might not seem like much, but when you're trying to keep responses around the 25 ms mark or less for complex queries with loads of relations, it helps ginormously. I've seen some work being done on JSONAPI, very keen on that. It's a very robust system and I personally prefer it to JSON LD
/u/n0xie said it below - use Redis and flush to the database. Personally I'd use Beanstalkd but the principle is the same. Use a catchall to get all the inserts into one place, then batch them out into the database. You can run a PHP script as a daemon that watches the queue/store and then runs a batch insert when it has, say, more than 1000 records ready. Just have to watch your memory usage. edit - FWIW I had a system running on CI2 that handled about 2000+ connections per second, all writing to a single database, and didn't bother batching out anything. It still ran pretty well. We just had a lot of optimization in the queries and I think the database server was pretty beefy. The one time we managed to crash it, we got a burst of traffic up to 10k a second - but that was the application itself going splat long before the database.
Maybe ask the JetBrains guys on Twitter: https://mobile.twitter.com/phpstorm PhpStorm gets updated fairly often and has integrated many many tools from the get go, that will save quite some time. This argument might work for your boss ¯\\\_(ツ)_/¯
PHPStorm saved me at least 30 mins per day out of the box when I switched. What does it cost, $200 or something? It paid itself off in ... 3 days? Of course in my case I would have bought it myself if my client hadn't. 
Download, try it for 30 days, show said improvements in work and no doubt they will buy it.
Failing that, you could trial the software or use EAP. That will give you a chance to allows the devs to trial the software and feedback to management.
I tried to make that argument this morning and was met with a flat out no.
I have been trialing it for the past 29 days and really like it. Two other developers here have already purchased it for themselves. The 3 of us are in the process of putting some documentation together about the benefits of it. Hopefully this will work but I don't really have high hopes.
That makes a lot of sense. Thanks!
It's an incredible timesaver for me, I've used lots of different free tools and none of them compare. It saves me so much time that I even sprung for my own license to use on my home computer for side-hacking. It's a stupidly short-sighted decision for an employer to not buy the best tools for their people. To do some crappy math, if you even say a developer costs $50/hour (80k/year + benefits) you only need them to save 4 hours to pay for this thing, and I'll say I've saved easily that many in a month with this tool in particular. It's like if you worked for a clothing manufacturer and they wouldn't get you a sewing machine, since you could just do it by hand with a needle.
It's yet another social networking style website with a bunch of like/dislike buttons. I'm not sure exactly what kind of traffic it's going to see but the client wants to make sure it can handle heavy traffic (you have to admire their optimism :P). Anyway, since every like/dislike is basically one (or many, depending on how we store the data) write operations, that's why I'm asking about the best way to handle a high number of concurrent writes.
I told my boss it will save me about 10-20 minutes each hour because it has Git/Grunt/Composer/etc built in. He bought a license immediately. 
It's GIT integration is really helpful, I had forgotten about that.
Tldr; #2 nearly always is preferable.
That's sounding like the way to go. Thanks!
It's very simple. Your time costs more than the software. Just do the math and if it saves you X hours per week over the free IDE, it will pay for itself in Y weeks and then continue to save the company money in efficiency. It's a very cheap way to significantly increase your productivity.
Good read and great points!
I had to convince an employer I didn't need WebStorm (not PHPStorm) once. I don't have anything against the JetBrains stuff, it's just not my thing. I've tried them both and I prefer lean editors to the integrated environment. The break point is compiled languages for me I think. I think having to convince you're employer what tools you work best with is stupid either way. Whatever you're comfortable with should be an (almost) automatic purchase for the employer. When you're comfortable, you're productive. 
Interesting (although usual) tips. But what does this have to do specifically with PHP?
You can always run the EAP for free, just update every month to the latest build
Start looking elsewhere for a job. Seriously this kind of thought process seeps into everything and is just overall bad. 
For reference, we are currently at a 40% continuity discount on our annual licenses so we now pay £89 for each, we have a couple for our new developers which are at 20% so £119 per year.
^ This. Frame the purchase as a no-brainer investment which pays for itself.
There are free tools that do some of the same things, but not all, and not nearly as well.
Saves you 30 minutes a day compared to what? Every other product? I don't have anything against phpstorm but to blanket say it's 30 minutes better than any other product is a pretty lofty claim.
I'm sure that my employer would buy it if I asked, but I see it as an investment in myself, and purchase my own license. This way there is no question about conflict of interest or misuse of company resources if I choose to use it for side projects. 
Not really. At one job, everyone was able to use whatever they were comfortable with. I was the only one using PHPStorm and within a few months everyone else was too. The next job, they were already using PHPStorm.
I disagree that WebStorm wouldn't be incredibly useful for you but more importantly, I agree that you should be open to use whatever you are comfortable with using.
WAMP?
Whenever a non-tech person doesn't understand tech-stuff, just compare the situation to something your grandma would understand: So you're a carpenter that wants a professional hammer so you can do some professional carpenting. **Ofcourse** you can use a brick or a cheap hammer at the dyi store to hammer a nail into something. **But** you're a carpenter and __do not__ hammer nails in things. You're hired at the company you work for to be a carpenter. Not the neighbour that "has 2 hammers, so he knows what he's talking about". You are a professional. Use professional tools for getting things done. Not the cheap stuff for amateurs. If your employer wants you to work with IKEA crap, look for another employer ASAP. Working like that slows you down and is less enjoyable. This is not about phpstorm (or another IDE) or carpenting. As a programmer, you should also have a... * good monitor (the thing you're staring at 8 hours a day) * a good chair (the thing you're sitting in) * a good desk (the thing... you know the drill) * a keyboard + mouse you're familiar with (same as you have at home?) so you can type faster * A computer that isn't too slow for you to get things done (if you have to wait for things, it gets you out of your flow AND wastes time of actual work) I'm not a carpenter, but i guess most carpenters get a workbench and a big box full with tools. Most think that's normal because: "(s)he's a carpenter". So why should you hammer nails with a shoebox? Yes it's free and gets the job done.... eventually. But maybe it's waaaaaaay faster if you could just work with professional tools. 
"Luck oriented programming". Wow I think you just found a great synonym for duck typing. In luck oriented programming, small &amp; new projects have a very high degree of luck! They work just fine given the controlled set of scenarios and team members. As the team and source code grows in size, the luck is reduced. Questions also start to be raised: how did this ever work!? Luck, of course. 
"Using it over X, I work faster, more efficiently, and with a noticeable decline in errors. And that is before I start listing features that are new to us. You may say there are free alternatives but they do not compare to the increased performance PHPStorm allows me compared to its almost negligible cost." 
Using GET parameters is the correct way of doing that.
Just tell him work tools and equipment are tax-deductible. 😉
With dynamic language you write a lot less code. You don't need to do type juggling yourself. Almost everything you get from HTTP is a string, so why would you force it to other types? For example you expect integer ID from $_GET, but user submits string instead. What happens when you typehint it to integer? Yeah, your app is gonna CRASH, because now it complains that it's wrong type. So what do you do? You manually cast it to string. Now what happens when user submits string? It's gonna get converted to 0 and you and/or user are gonna get nonsensical error messages such as "user with id 0 not found". Why would you care so much if the value by which you are looking up a DB record is integer? Its gonna get converted to SQL string anyway and it's not gonna find the record either way!
Then start small, one new piece at a time, i.e., try just replacing some of your templates with [Twig](http://twig.sensiolabs.org/) to get a feel for the syntax.
No it cannot implement that interface if that code is not yours, but it's from some library
Get the trial, set it up to work with your project, get him to use it. They are no free tools that do everything it does. Just the quick inspections (automatic php doc generation is huge) and the refactoring (largely renaming) are massive time and headache savers. Those alone netted me tons of saved time even while I had to spend time learning the rest of what phpstorm does. Also its the only php editor I've used with autocomplete that is not complete junk. 
Where I work they even let me use a licence on my home PC. I actually find it harder to convince new employees to use it instead of sublime when they join the company. Eventually they have an epiphany and go phpstorm only. 
It's not about REST. REST is not just CRUD + HTTP codes. Is this article about an API? - Yes. Is this article about REST? - No. This is another one wrong "HTTP + URLs + Verbs = REST" text. What is REST-like? Why there are so many devs calling every HTTP URL based API as RESTful? It's like to call every *.txt - a hypertext. No, sir, it's not. Sorry being rude.
Thank you /r/mfurlend hope it helps to save some time :)
You are welcome /r/behunin :)
Ah, BTW feedback about the plugin page (https://plugins.jetbrains.com/phpstorm/plugin/7622-php-inspections-ea-extended-) is appreciated: perhaps we'll appear in the top rated plugins list with your votes.
I just did. Hundreds of lines of mapping code replaced with a dozen. Sure you could do something similar I guess with a good meta model. But in dynamic languages you get the meta model for free. NeXT used to send in example programs to magazines replacing thousand line C++ CORBA programs with ten lines of objective c
why not, phpBB is free and open source bbs software, its easy to establish a bbs board.
&gt; always write twice, once to mysql and once to redis I really like that idea. What's the best way to implement that solution? It seems like you would incur some noticeable overhead having to make twice as many outbound tcp connections. 
The idea that you have to constantly be mapping dynamic dictionaries to statically typed objects and back is a fallacy. You have dictionaries in every language under the sun, and you can operate on them directly. What I'm basically saying is that your issues are self-made, not caused by static typing. BTW, I'm not against dynamic features in languages, I like the balance that C# strikes, by having both. PHP also tries to strike such a balance, though mostly by accident (it started dynamic and is slowly gaining static features). 
&gt; Sure you could do something similar I guess with a good meta model. But in dynamic languages you get the meta model for free. Look at most JSON parsing libraries. You get the model free with them, as well. I can find long-winded ways to write something in all languages, but it's not intellectually honest to present it as an issue of the type system. It's an issue if how you chose to write it, either deliberately or due to lack of experience.
Ok. C++ is mature. Do that one.
Is that a policy of your workplace? Because JetBrains is [fine with it](https://sales.jetbrains.com/hc/en-gb/articles/207240855-Can-I-use-my-personal-license-at-work-and-at-home-).
What exactly do you want me to *do*? You're pasting some code, out of context, I know nothing about your project and what you're complaining about. If you feel your code up there was convincing... it was just noise. We don't have the context.
It was something I had read online regarding PHPStorm. Guess that was wrong. 
Do you know what kvc is? I posted an implementation of kvc for php. Do the same in any static language. You haven't posted a line of anything to back up your mouth. Admit defeat - you can't do it. Google responded chain in swift. More fuel. You can't just shoot your mouth off without counter evidence. 
It's about SEO
Well, in general Swift is much more elegant than PHP. Swift is also very young and I wouldn't deny that there are still rough edges. Swift doesn't support reflection properly yet. Once it will that problem goes away. And it's not like PHP is any better, have you seen the getter and setter boilerplate madness?
I guess I'm wondering why you don't just already own a license. And using the excuse of the Eula seems like a cop out of a cheap person who just doesn't want to pay for it, lol.
&gt; Do you know what kvc is? I posted an implementation of kvc for php. Do the same in any static language. I know what it is, but that's another distinctly Apple term. I have the feeling you want to be in /r/swift/ but you stumbled here by accident. &gt; You haven't posted a line of anything to back up your mouth. Admit defeat - you can't do it. Google responded chain in swift. More fuel. You can't just shoot your mouth off without counter evidence. Dude, you're hilarious. Is this cocaine, or acid? What are you on? Here's a popular JSON library for Java: http://wiki.fasterxml.com/JacksonInFiveMinutes The "meta model" which is key-value oriented is under the section "Tree Model": http://wiki.fasterxml.com/JacksonTreeModel The stream reader/writer is also practical if you just want to read some JSON and transform it into smaller JSON, or whatever it is you're trying to do. So, say, what in PHP would've been: $root['hello']['world'] = 'I am JSON'; In Jackson is: root.with("hello").put("world", "I am JSON"); Here's your "line of anything". You can read the links for more. 
It's about the SEO of your **JSON API**, huh. That totally makes sense.
This will introduce so many corner cases. One that comes to mind (untested): User starts a session in SFSafariViewController on iOS where a strict SameSite cookie is used to track the session ID. Seems OK because the session should only last 10 minutes or so as the user logs in or completes the check out or whatever. In the middle, the user clicks the Open in Safari button. Browser session cookies (those without an explicit expiration time) don't flow in this case, so I'd bet that same site ones, at least strict ones, don't either. With all these corner cases, the lack of broad support, and having to redo all our SSO cookie handling (to do like Amazon in the post) makes SameSite cookies a non-starter for us. 
&gt; KFC in swift. [No problem](http://i.imgur.com/khZEBsQ.jpg).
The entire framework contains git conflicts :(
Nice deflection. Just stop. Admit you got nothing. This is the php sub after all and php is a dynamic language which is why I like it.
You basically want to rant about Swift, I get it. Again, this is not the right subreddit for this. The Jackson tree model I linked you do doesn't depend on reflection, BTW. You can have the same exact (or even better) interface about JSON in Swift. In fact, in Swift you can just a [String: AnyObject] dictionary, which is basically like working with PHP arrays. You need reflection when you want to automatically convert objects to some serialized representation, like JSON. Which is a bad idea whether you have dynamic types or not. But I'm not going to argue about this with you until the coke effects fade away a little.
Dude, how is that an argument. Swift is one of the most praised languages lately. I don't know about you but I like predictable code. What's the point of not defining types when I then have to make sure in every damn method that the right type has been passed? Magic methods can be useful in *some* cases. But if you're overusing them you're probably doing something wrong. I'd rather have proper IDE autocompletion than getting rid of a few characters. You ~~have~~ haven't explained at all where this hatred towards Swift comes from. Have you worked with Swift before?
The input parameters you describe violates LSP. I it's poor design and should be be done in any case.
You can't learn to run, without learning to walk. But the first 1-2 years you get carried by your parents. The next year to crouch.. then you slowly start to walk and fall every step.. and with every next try, to fall less and less. Then you slowly optimize to walk without falling. Then when you get it, you can start to run (btw. I have no children, so some values could be to much :D). I think you won't succeed a lot with building Plugins with 3.party software without understanding the whole.
Could you please give a link to an article or a book about actual REST? I am not being a smartass, I am genuinely interested.
Whoops, I saved some edits before seeing your post. Probably unimportant changes though.
If we talk about the php nullable implementation you are correct, If we talk about the Scala options, you are not. The difference comes from the fact that nullable&lt;x&gt; is a supertype of x while option&lt;x&gt; is not. If nullable should be preferred over option because it allows a wider range of inheritance possibilities is an interesting perspective to discuss.
You can always just use the tidy executable. Wikimedia is working on a [pure-PHP Tidy replacement](https://github.com/wikimedia/mediawiki-libs-RemexHtml) but I'm not sure it's useful for third parties at this point.
Those "must see" / "must know" / "must follow" titles don't have the same effect on me anymore, as I keep seeing them everywhere, I've become desensitized. I need something stronger to open an article, like attacks on my manhood, or veiled death threats.
Also since the time saved and increased productivity will be benefiting my employer way more than it will be benefiting me they should be paying for it.
You are right. I misread the first comment to which I replied. To give you a more pertinent answer then, I think that type checking at compile time is a bit superior to a third (and optional) static type checker. The Scala solution has its drawbacks but it looks much better for the majority of cases imho.
Ask for: Right ide box that is 220px wide wide with 1px border, with a list of items from a db Get: Get GIF image that is random crap on the top.
yea there is - it's called [mail()](https://secure.php.net/manual/en/function.mail.php) 
Yes.. walked up to his desk with my laptop and PHPstorm already in the shopping cart on their website and I said: "I need this.. where's the company credit card?" PHPstorm saves you so much shit, you wouldn't believe.. it has saved me literally hundreds of hours sifting through code.. Good software that is constantly updates costs money; if he's paying or managing you.. he should give you the tools to do your work, or he's a shit manager.
Well it's not considered low either, but it's nowhere near the amount that you should be really worried. Yes it's a lot and yes your infrastructure should take into account the amount of writes, but with a bit of optimisation, this is very doable for any sort of widely used database store. If you are worried, there are some good alternative technologies that can help you out (Cassandra, Kafka) and a bunch of blogs (http://highscalability.com/), but before you go redesigning your entire infrastructure, it's much better to ask yourself some other questions as proposed https://www.reddit.com/r/PHP/comments/5vdkwz/data_layer_advice_for_high_write_volume/de24fse/ 
Have you tried http://www.reddit.com/r/phphelp ?
It's a standard part of PHP syntax. Often used for SQL queries. The strange template language is vanilla PHP. Take a read of the manual. I've been coding for over 20 years, used PHP since the 90s, oversee some very large projects and teams. Your opinion of being the worst of 2 languages is exactly that. An opinion. 
&gt; &gt;At the moment I am not having much luck as the excuse my manager uses is there are free tools that do what PHPStorm does. But not really though, unless you literally just means you can write other php in other programs. My advice to convince management it to explain the specific features and how they'll make you a better worker. &gt;Has anyone here had any luck convincing their employers to purchase this/have any advice? 
&gt; You can't just probe objects in the dark and say "oh it has a method id() which returns a string, this must be what I need". Yes you can in PHP &gt; You neither know how the method is truly called, nor what guarantees it makes for what it returns (i.e. sometimes identifiers are non-unique and then you're screwed). Bullshit. Architect of such design is aware what kind of objects might be passed to function like that and he knows they do what he wants them to do. Similarly like he would know that with interface type hint. It just provides type safety, but you must ensure that you are passing to it correct objects anyway, otherwise your app is gonna crash. And your point with uniqueness is moot when you realize that just attaching some interface doesn't make sure ID is unique neither. Interface in this case is just a label which says class has id method, it doesn't enforce behaviour such as uniqueness. Now, I don't really like solution article suggests either. I would never do this, because it gives users of such method false sense of security and they won't be careful what they are passing in. But I indeed do find usages for duck typing features.
Ah yes, you are one of those guys who are stuffing curly braces everywhere. Now, show me a loop using your "template".
Because have you actually stopped and read the code base? Its horrendous, looks like its a bunch of spaghetti code written in the early 2000's and not been changed since. No autoloading, no PSR, no composer, there own random architecture instead of following established patterns and that folder structure is insane, who even dreamt that up?
I think that PostgreSQL/PostGIS is an excellent candidate, I am not personnally using it, but the company I work for has a long history in GIS expertise, and it's the database they use the most.
I was using MongoDB for that kind of stuff.
To be fair on sites that had it, it sucked. Might as well have used "some search term site:stackoverflow.com" 
I've used PostgreSQL with PostGIS when writing plugins for [OpenJUMP](http://openjump.org/). It's great. On that note, from what i know, MySQL has a GIS extension starting from version 5.6 if i remember correctly, but from what i read it does not match PostGIS.
I was referring to *HTML templates* stuff, that, if you didn't notice, has been discussed here. On a side note, you should never write JSON string by hand. There is a dedicated function for this. So your last example should be actually $rtn = json_encode ([ "status" =&gt; "ERROR", "errorcode" =&gt; $errorCode, "reference" =&gt; $stack-&gt;reference, ]); as you can see, Heredoc has much less employment than you think. 
The object you usually need is hidden behind XY abstractions, you don't create it directly, so you are not gonna solve it with this simple wrapper.
Are you seperating your templating from your business logic? If not, you should. If you are, have a look at [Twig](http://twig.sensiolabs.org). It's a much more elegant way to handle rendering templates. What Twig does is you pass a few variables to a predefined template in which you can then use concise tags like {{ product.name }} to render variables. (Among other things)
Ohh yeah this would work. Apparently I didn't read it properly, thanks.
why is `resources/1` better than `resource/1`? Specially in english where pluralization is non-trivial and sometimes not even intuitive.
"PHP UK 2017 - click here or you'll die in 7 days"
This is very wrong because you need to access the filesystem, list the files, etc... It's a very slow operation, you should banish all file system operations that are not necessary. You should programatically include them using require_once without any further filesystem access, in that way it will be optimized by the opcode cache and you won't slow down your app. Note that this is also very wrong in a lot of other ways, it means that your code is dynamically included, if someone manage to get write file access on your filesystem, he can place all sort of PHP code file that may contain malicious code.
How good or good practice is it to go and dig in a framework like laravel/slim/etc right after point 4 ?
Thanks! I will remove this method promptly!
I've used Storm (required in one of my previous roles) and Netbeans over the past 8 years. I can safely say there is nothing in Storm that I can't do in Netbeans if anything not being able to have multiple projects open in Storm made me work slower when working with multiple micro services (storm now has this feature I believe but only recently). This doesn't make me a *moron* or an *amateur* as storm zealots often say raging at people who don't use it but for me there simply isn't anything in storms feature set that warrants a $200 price tag when Netbeans is free
Netbeans?
Literally everything you have listed is available in Netbeans, I'm really struggling to see how you could achieve a 30min saving not using Netbeans and using Storm
Netbeans has all those features so how would Storm save you 20mins an hour when comparing to Netbeans?
Isn't that essentially what it did?
I've been in the same boat, had to use Storm in a previous role. after 6months I was left thinking what the hell is everyone screaming about that makes Storm worth $200 a year. There was literally nothing in Storm that Netbeans couldn't do, everything you would need in a daily PHP workflow was in both products yet one was free and one was $200. I just can't get my head around the zelot like following on Storm. If you comparing Storm to say Sublime then yes I totally get the quoted time savings but comparing Storm to Netbeans? From mt expereince, I just don't see it
Yes but all the text was smaller and the preview wasn't as good imo
&gt; Plus PhpStorm has gazillion of shortcuts and features NetBeans doesn't Which ones? &gt; Been using Netbeans for like ~8 years before PhpStorm and it was SO SLOW This is true in the past although I haven't noticed it recently, I can't say if that's improvements with the Netbeans code or if my hardware is powerful enough to not notice. I did a side by side back in November with a month trial of Storm, I did half a day in storm and half a day in Netbeans for 30 days and noticed no difference in performance, both actually used almost identical amounts of memory and with them both being so similar always makes me think did they start from the same code base?
And is 10x worse feature wise to use. 
Netbeans comes close - at least when it comes to the basic feature set.
&gt; And is 10x worse feature wise to use. Which features are you referring to?
At a minimum, you could organize your functions into classes as static methods, store the files following PSR-4, and use PHP's autoloading to load them as necessary.
If you see it saving you time, buy it yourself, JetBrains allows personal licenses to be used in businesses as long as the programmer bought the license themselves and not purchased by a company. It's worth it for me because then I get to use it outside of my job and it's as low as a Netflix subscription. The only issue I see is if installing software on your computer at work would be an issue, then I'd talk to your manager first.
For the uneducated... what is the REST paper? 
It's this dissertation paper by Roy Fielding: https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm Chapter 5 is about "REST". He coined the term, he defined it, and basically 90% of what you hear about REST is in contradiction with this paper. Around 2008, which is 8 years after the paper was published (2000) some consultants picked on the term and ran with it as a platform where they can talk about CRUD, XML (later JSON) and pretty URLs. This created an unstoppable avalanche of **stupid**, which has completely drowned the original purpose of REST. Mind you the original paper also has some issues, but the theory is solid. But what you'll hear around the blogs about REST is mostly a cargo cult about style over substance.
At the end of the article I wrote that the videos will be available soon, in few weeks. So don't worry mate. This is just some kind of spoiler. 
I disagree. Having also worked with both there is a lot of stuff and configuration that NB lacks or must be downloaded as a 3rd party ad-on. And I can open multiple projects in storm just fine? Jetbrains software is optimised, quick, has many frameworks and compilers built-in and is heavily supported. The only place I had to work with NB was too cheap to buy anything which may have cost money. As well as being too cheap to upgrade their 2003 software.
I will be messaging you on [**2017-03-22 13:36:12 UTC**](http://www.wolframalpha.com/input/?i=2017-03-22 13:36:12 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/5vhiu6/7_php_uk_2017s_talks_you_must_see/de2bv7m) [**11 OTHERS CLICKED THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/5vhiu6/7_php_uk_2017s_talks_you_must_see/de2bv7m]%0A%0ARemindMe! 1 month) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! de2bvrl) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
It's not comparatively standards compliant out of the box, however, that is fairly trivial to enable. I wouldn't blame MySQL for the failure of others to RTFM. https://dev.mysql.com/doc/refman/5.7/en/sql-mode.html
if accessed from the internal method, I prefer direct access via ```$this-&gt;var```, if accessed from outside the object, I prefer ```$object-&gt;getVar()```
atoum has a very different approach than PHPUnit in general. I don't get what you mean. Can you elaborate please?
Both Redis and ElasticSearch have pretty decent geospatial functionality if your happy to break out into other services.
&gt; if someone manage to get write file access on your filesystem, he can place all sort of PHP code file that may contain malicious code. This has literally nothing to do with dynamic inclusion. If they have write access they'll just edit index.php to do whatever bad stuff they want. 
strictly speaking, using the getter would better. That's why it rimes. If, in the future, you want to add some logic (for instance, return a default value if the property is null, based on the value of some other property), then you want to pass by the getter to get this functionality. unless you want the real value without any other logic of course... so in the end, it all depends on the use case.
I'm not so sure about this: &gt; Storing test json files to test this class would work, but is not ideal because it leaves a dependency on the file system in your tests. As with any external resource, there might be intermittent problems with the file system and could result in some flaky tests. When has your file system ever been flaky enough that your tests might fail when reading a file? Using the filesystem is such a fundamental thing for software to do that I don't think it's worth worrying about. The best choice here is to abstract your file system operations away (using something like Flysystem) and get rid of the file_get_contents call, but loading stubs from disks for your tests doesn't strike me as a bad thing.
Makes sense but can you explain why they would need to be "static"?
They might have the right to upload files but not to overwrite the existing ones, case in which, it does open a door.
Sure is, but if your object is part of an API interface, I would still hide the internals behind methods, so I can modify it whenever it pleases me without breaking the API. In that specific case, I prefer maintainability over performances. But for an internal object that is not part of an API, using direct property access is good enough.
I had a really long and unpleasant argument with my employer before he finally bought it for me. Now the entire dev team is using it and he still somtimes complains about the high cost. I just don't understand how he can't see that PHPStorm pays for itself in a matter of days if not hours. It's quite honestly something I almost quit over, and if I ever have to argue about it again I'm just going to....
True that. I have a long history with PostgreSQL and MySQL, both are my day to day work, I'm quite convinced in what I'm saying after those long years. Still I'm curious to see how the next MySQL major will behave, it seems to be a *HUGE* release, maybe we could call it relational database this time.
maybe, but in the real world it makes no difference. It isn't something worth worrying about. Look at frameworks and all the overhead that happens ... maybe it slows it down a bit, but not enough that it is noticeable e.g. in laravel's Eloquent files: This code: $model = new Model(); var_dump($model-&gt;example); would run: Model.php: public function __get($key) { return $this-&gt;getAttribute($key); } which runs this code: public function getAttribute($key) { if (! $key) { return; } // If the attribute exists in the attribute array or has a "get" mutator we will // get the attribute's value. Otherwise, we will proceed as if the developers // are asking for a relationship's value. This covers both types of values. if (array_key_exists($key, $this-&gt;attributes) || $this-&gt;hasGetMutator($key)) { return $this-&gt;getAttributeValue($key); } // Here we will determine if the model base class itself contains this given key // since we do not want to treat any of those methods are relationships since // they are all intended as helper methods and none of these are relations. if (method_exists(self::class, $key)) { return; } return $this-&gt;getRelationValue($key); } which then will run more methods. Its really not a big deal. The advantage of doing it via a method (-&gt;getXXX()) is that you can run some logic on it (e.g. if it doesn't exist/isnt set yet etc)
Its really hard to dislike something until you know it well. I write in Swift every day. No, I don't much like it. I'd rather write in PHP. Which is, you know, why I'm in this forum. WTF you are doing here I have no idea.
The coke thing - 3 times. Time to put your clueless ass on mute.
I've used Swift literally since day 1. I know pretty much everything there is to know about the language. And as for PHP, I'm using it everyday at work and I like to be up to date with the tools we're using. I also like PHP. It has a phenomenal eco-system. But if Swift had the same eco-system for Web development I wouldn't hesitate ditching PHP for a second.
They're praising it because it has indeed gotten much better. And it's still the only option if you want to write client side code. If there were another option people would've abandoned JavaScript a long time ago. But things are not black and white, there are things we could learn from Node. Just as with about any other platform.
Another thing to consider about using a method over a public property is the fact you can create an interface for methods, but not properties.
/r/phphelp You should include what framework you are using in your post
https://github.com/tarantool/gis
Yes. Apache parsing http headers is crazy slow when compared to websockets. If i remember correctly it was 5x or even 10x slower. Maybe my benchmark wasnt correct but throughput skyrocketed after switching. However, ws can have some issues with certain proxy types. Read about possible issues before deciding
If a couple hundred is too much for a one-time purchase that might possibly relate to your productivity or just day-to-day happiness, you *know* you're not getting a raise or going to any conferences or anything else fun anytime soon. That doesn't make the job bad, but it's something to be aware of. Some jobs that give you those goodies might be awful in lots of other ways. "We'll buy you all the tools! We expect you to work 70 hour weeks." Netbeans is a fine IDE I enjoyed for years. That said, opening Storm on an old project and having it point out a million bugs that we never would've caught... high value feature.
There's a big problem with running your web server under an account that allows useful commands to be executed. Usually you want your web server to run under some useless system account that only has read only access. Otherwise, as soon as anything on your server allows some form of remote code execution, you're in trouble. (most of us use at least some third party frameworks or plugins, so you never know...) Other than that, hardcover anything so no one can execute arbitrary commands. 
&gt; That's why it rimes. It's... Cold? 
These aren't autoloaded, they're just... loaded. I don't like packages that "force-load" functions in Composer. They get loaded even if I never use the package in that request. It slows your app down.
let's just say all the cool kids do it
That relies on [https://github.com/nikic/FastRoute/blob/master/src/bootstrap.php#L5](https://github.com/nikic/FastRoute/blob/master/src/bootstrap.php#L5) to actually work. It wouldn't need to be wrapped in a function_exists() check if it was being (truly) autoloaded.
Then why post it if you recognize it's not fully usable?
Typically doesn't. I have a practice where it gets in the way though. I have multiple "start files" for the same body of code. Basically imagine a few clients that load the same domain services, but one is serving web requests, the other is running background processing jobs, third is sending emails etc. SwiftMailer also loads a bunch of functions, which only ever get used in my "mail" app, but because of how Composer works, they get loaded also in my other apps. One way to deal with this is separate the applications completely, but then I need to make sure they all access domain data through the same domain logic, so now I have to also move all domain APIs to their own services... it gets complicated for no reason other than SwiftMailer and co. saying "but muh functions" and Composer obliging. I personally got around this by using a custom autoloader which detects, say, a SwiftMailer class is loaded, and only then it loads its functions. But Composer doesn't do this out of the box.
+1000, useless
Since casting is about the same amount of expensive as calling magic accessors, it makes a lot more sense to enforce the value by setting the visibility to protected and using methods to access them. This way you'll get better IDE support and don't have to worry about another developer setting the value without the setter. Preferences are irrelevant when you leave room for easy bugs.
When I started using phpstorm, I dropped my db client, ftp client, git client, diff program, stopped having to check my bug tracker separately, stopped having to open terminal windows separately, stopped having to invoke vagrant separately etc. etc. the list goes on and on. Just having the IDE change contexts and open/close/switch file sets alone saved me an hour a day. EASY!
how about codeception? it has bdd features which sounds more like what you want.
piggybacking: any codeception implementation? 
Yeah, sure, if it is called an excessive amount of times. But for a normal web app (website) page load, it isn't going to make any real difference...
OP has already stated he and others already done the 30-day free trial and approached their manager based off their experience
There shouldn't be a general decision on which one is better. It always depends on the case. If you just want to transfer data, a class with public properties is totally sufficient. If you want to have type safe properties and don't want that the outside world can modify (or break) it, use getters and setters with type hints. But I think your question is just about a local variable in the same class, right? If you have access to $this-&gt;var anyway, it makes no sense to use the getter there IMO. Only if the getter contains logic (like loading the value from somewhere if it's not set), you should use the getter instead (but rename getVar() to loadVar() :)) Btw.. functional calls are always more expensive than direct access to properties, but that's just micro optimization.
Codekit is great for compiling sass. It's a very user friendly GUI and it's fully self contained. Mamp pro is user friendly and has a GUI for editing hosts. The github app is nice. Depending on their level of expertise with git it may be easier to just let them use Dropbox. You can setup Dropbox as a git remote. 
 $this -&gt;integer(150) -&gt;isGreaterThan(100) -&gt;isLowerThanOrEqualTo(200); One of these things is not like the other. Also, the sidebar changes when you go to "Documentations"
"It achieves this by using a Fractal tree index." That sounds like some powerful voodoo right there. Thanks for the pointer!
I am running it under www-data, as default. Is it safe? the only modification I made is granting it the permission to run smartctl without password to be able to retrieve S.M.A.R.T. data about my disks. I might give it access to user creation/modification and AFP settings, that might be dangerous, it wouldn't be facing the internet, only my home network.
so private properties and public functions?
Would have been a perfect time to drop PHP 5 support D: Edit: Since the down-votes, http://php.net/supported-versions.php, fuck me for trying to push php 7 though :)
I've been just opening a file with simplexml, casting it to array, then json encode/json_decode and it's then an array. Not sure how bad this method actually is, but works absolutely fine and is good enough for me.
Yes, homebrew is a must! For code editor, I prefer sublime than atom, as atom is based on electron and tend to be slower. Sourcetree is way to go for git gui, I find it more intuitive than github desktop, but if she is find with terminal, path-finder with git and terminal panel is quiet useful 
7 PHP UK 2017 must-see unironic meme image macros.
If you don't care about performance... I've had xml files with various xml attributes that I could not figure out how to access properly with simle xml so I used QueryPath instead. https://github.com/technosophos/querypath
There's a special circle of hell for people who do things like that.
Why is that? Some frameworks automatically map `$this-&gt;getVar()` to `$this-&gt;var`.
I'll be there! (And speaking about PHP 7.1) I'm looking forward to it, I'll see you there!
You can use [Sabre\XML](http://sabre.io/xml/reading/) to hook up the models "directly". I've used the writing component of this library for a few projects and it's great, but admit I haven't used the reader very much. YMMV
Great work! I can understand the naysayers, adding more opportunities for side-effects is not pretty. But useful, and fits well with existing references. This RFC does apparently not account for https://wiki.php.net/rfc/list_keys but the implementation does. So `['one' =&gt; &amp;$one, 'two' =&gt; $two]` will work as expected. 
&gt; i don't actually find that as relevant as you mention it. I think this argument has as much value as the 'its gnu/linux not linux' discussion. You think I'm pedantic, and you're pragmatic, and you probably really believe it's the case, but the only thing I see you argue is "look, I'm used to REST being CRUD+JSON over HTTP, you're telling me something new I don't understand, therefore I reject it". I can't quite tell if you're intellectually dishonest here, or simply not thinking through your argument: &gt; Its about the 95% problem. If 95% of the developers/frameworks/consumers expect REST to be POST, PATCH, PUT, GET requests to a resource which will return an http status and a body response using json schema (maybe xml). The 95% problem. Let's talk about it. - Is the 95% problem about using *all* HTTP methods? Or is the 95% problem solved by just using POST, and maybe GET if your business case makes use of caching. Make that argument for me, what exactly great benefits you gain by using PATCH instead of POST. - Is the 95% problem about CRUD? Or is the 95% problem about making a RPC call over HTTP, CRUD or not CRUD being completely irrelevant? Make that argument for me, why should everything be CRUD. - Is the 95% problem about "pretty" URLs with parameters stuffed in their path and "no verbs"? Or is the 95% problem just knowing what URL to call, doesn't matter how it's formatted. Make that argument for me, how does a web server care what letter combinations are in a URL. We're talking about a community that is ready to pick apart *most any API* that dares call itself "REST" because of irrelevant crap like "**it has a verb in the URL**" and you're telling me this culture is about the 95% problem? That's hilarious. If you remove the cruft and cargo cult aspects from what people today call REST, what's left is the the real provider of the 95% value: ad-hoc, free-form HTTP RPC, doesn't matter how it's done as long as it's simple, doesn't wreck the HTTP spec and has clear docs. &gt; Sure the paper you link has a lot of value and as developers we can use it to find the proper definitions for things such as 'stateless' or why cookies shouldn't be used on a rest request. And also as developers we must learn how the concept has evolved and how to implement it cleanly. I don't think you've read the paper carefully, or you wouldn't be calling something which **misses its point entirely** and **contradicts it** so extensively an "evolution of the concept". The idea behind REST is that it has specific constraints, and they produce specific technical benefits. Instead modern "CRUD JSON" REST is about a bunch of pompous bike-shedding over URL structure and HTTP verbs, which produce no technical benefits at all.
&gt; "look, I'm used to REST being CRUD+JSON over HTTP, you're telling me something new I don't understand, therefore I reject it". nope, not what i said. I assume for the rest of your comment you keep this pedantic premise so I won't even read anymore. Good day.
[removed]
but if ever actually do this... then: http://i.imgur.com/IppKJ.jpg
https://en.wikipedia.org/wiki/Immutable_object
the getter doesn't guarantee that there is no transformation of data going on behind the scenes. all it guarantees is that it will return the information in an agreed upon format. Also... what is a business method? That seems to me like a highly ambiguous term.
There are various shortcuts I didn't find in NetBeans, like: * Alt+Up/Down - jumping between methods of class * Ctrl+Shift+Backspace - jump to last edited location * Ctrl+Alt+T - surrounds selection with something * plenty of other shortcuts...basically everything in Navigate, Code and Refactor menu * integration with Composer or Grunt (and many more) * actually working terminal tab in Windows (no need for Cygwin etc.) Well I found PhpStorm better than NetBeans.
Thats not what an immutable object is. This might help: https://blog.joefallon.net/2015/08/immutable-objects-in-php/
I didn't know that's possible in PHP. Just in case someone really want's to express their annoyance over a users input https://3v4l.org/BdEDl
Multiple projects in one Window, if you have a number of microservices you can open them all in Netbeans in one go and have the file tree to the left. So when you're searching for file or functions etc it searches across all the different code bases. Jetbrains said they had it coming but at the time (4months ago) it wasn't even in Beta
Does the UI still look like it's from 1998?
PHP 7 support took em how long? 
Also does it still uses like 8gigs ram at idle ?
PhpStorm master race
If you're doing something like this, you're most likely doing it wrong already.
&gt; Alt+Up/Down - jumping between methods of class I found Netbeans handles this better ctrl+7 and then type the name of the method/function and it jumps to it anywhere in the file &gt; Ctrl+Shift+Backspace - jump to last edited location ctrl+q &gt; Ctrl+Alt+T - surrounds selection with something In Netbeans you simply just type what ever it is no shortcut needed, so highlight a method and type ( will put () around your selection &gt; plenty of other shortcuts...basically everything in Navigate, Code and Refactor menu I'm not sure which ones you're referring to, I know and use around 40 different shortcuts on a daily basis and I've only just scratched the surface &gt; integration with Composer or Grunt (and many more) Netbeans has: Grunt, Gulp, NPM, Bower, NodeJS, Docker, GIT, Mocha, Karma PHPUnit, SASS, LESS all built in out of the box. There are probably more but these are the things I've used. &gt; actually working terminal tab in Windows (no need for Cygwin etc.) Can't comment on this as I've only developed on Linux and briefly on Mac using Netbeans I'm glad you've found something that works for you and you're happy with it but I'm still yet to see anything that makes Storm *better* than Netbeans and certainly haven't seen anything that warrants the price tag and the way people rave about it. Every time someone says "oh Storm is better because it has feature x or feature y" I'm always sat thinking, Netbeans has that as well. I'm not saying Storm is bad, not at all, when I trailed it I liked using it I just couldn't see the benefit in paying $200 a year for no gain.
Why was this downvoted? I did the same also
"What's a loop?"
Did I say anything to the contrary? May I still criticize the criticism?
Probably still not as long as ES6 support.
Holy crap. Are you joking? The criticism is "it doesn't look too good" ... "it uses a lot of RAM" Nobody minds constructive criticism, but you're not entitled to any of this. This is just lazy and basically shitting on other peoples work, that they give you for free. So you guys can either change your tone, or get fucked in my opinion.
No it's not correct. You're missing the closing quote on the first line. And the variable you're returning has not been declared (you mistyped it).
great design =)
BTW - I'm not an author of this package. I want to share this package with the community, because experience of using it is just great and I would be happy to see it used in open source projects more :) . Using methods of a class to describe tests and scenarios feels just so cumbersome after using describe-it syntax.
So cumbersome? It looks like way more work than PHPSpec would make you do, while being slightly less clear to the reader.
Get the PhpStorm EAP if you can't afford it.
7.1 != 7.0
I was referring to the PHPUnit style as I've been working extensively only with these two. I've seen PHPSpec before when I was looking for alternatives to PHPUnit, but I didn't try it because the idea behind the library wasn't nearly as clear to me as that of the Kahlan. If to ignore the function() keyword there is almost no noise in the tests - someone who doesn't even know how to program can read it. PHPSpec seems to be going in the same direction, but building on the PHPUnit style (creating classes, then extending some, methods as tests, using `$this` etc. all noise). While Kahlan is just build from the ground up for being as readable as possible and that got me sold.
Stop trying to make NetBeans happen. It's not going to happen.
I don't and I don't. But I will still confront people who act like they're entitled to free stuff.
To be fair, it was happening before PHPStorm gained traction. I was using netbeans for 10 years before i switched. It was "ok" before, now it's just lacking behind. Also, competition is good, and netbeans offer a free platform, which i.e PHPStorm does not.
Assuming she actually is experienced, she'll probably already have her own preferred programs? Does this need to be decided by someone else? Or does she just know like basic HTML/CSS from uni or something and you'll be training her?
&gt; Basic code editor (a full blown IDE is likely overkill) &gt;&gt; Webstorm lol
&gt; Thousands per second isn't considered high write volume Depends on your context, for a blog then yeah its probably high, for an API that has multiple front ends sending queries from multiple users then no. MariaDB can easily handle over 1million inserts per minute without sharding or any special config. &gt; MongoDB (since it's supposed to have better write performance than a RDBMS). Nope this is not true, not if there is an Index anyway, they preform about the same in terms of speed but MongoDB will use **considerable** more memory and CPU cycles than MariaDB
This is actually an awkward variation of the "context" pattern, where the context methods are defined by subclassing, instead of injection. I feel the more straightforward approach for Symfony would be to simply implement contexts. The context is an interface with getters for every dependency, which interface is defined by the service needing said dependencies. Symfony's role would be to generate an implementation of the interface, which satisfied dependencies via its container: interface FooContext { function getBar(): Bar; function getBaz(): Baz; function getQux(): Qux; } class Foo { protected $ctx; function __construct(FooContext $ctx) { $this-&gt;ctx = $ctx; } function someMethod() { $baz = $this-&gt;ctx-&gt;getBaz(); } } This approach has all of the benefits of "getter injection" like laziness, immutability, optional dependencies and so on, without the drawbacks (i.e. like "can't work with final classes or constructors etc.").
TIL Netbeans is still a thing
This is one reason why I don't like Robert Martin's name for this principle, because "single responsibility principle" doesn't tell you the most important things about an object's "responsibility": it's subjective and contextual. The original name for this principle is "separation of concerns". It's saying the same thing with different words, but in my opinion has much more clarity in that you need two have two "concerns" before you decide to split an object in two, and not just do so arbitrarily. The way the author is splitting the InterviewManager class is perfectly valid, but what we never learn is why he had three separate concerns with this class. As an API user, I have one concern: working with interviews, so the separation there is not needed. The original class, in fact, would make a perfectly good facade for whatever separation you decide to do internally. Splitting an API class in three only makes features harder to discover and your API more difficult to learn and use. Validation can be a separate concern if you use validation elsewhere, or you have different types of interviews, each coming with their own validator (i.e. you may want to use polymorphism). Storage, likewise, only has to be separated, if you intend to have multiple places where an interview can be stored. If the public is not exposed to such *implementation* concerns, then it shouldn't see an arbitrarily fragmented API. Scheduler, likewise, if there's one schedule, and only one way to schedule, there's no need to have a separate "Scheduler" class. Internally you can have, but not in the API you give to users. So, nice article, but just like big classes that slap together unrelated concepts are bad, tiny classes that split a single concept (from the PoV of the user) are bad. Things have to be done for a reason. SRP should *not* be misunderstood as the "make more classes" principle.
Can it make a for loop for you too?
&gt; According to [this](https://netbeans.org/community/releases/roadmap.html) it's October 2nd, but still it's old news. 
I can imagine OP unrolling every single loop in their code, so they can use this "cool" feature. BTW, notice that in the time you need to type the right incantation for generating a "sequence", you could've just typed the numbers manually.
Have you tried PhpStorm? Then you'll know what I'm talking about. Otherwise: try it.
&gt; imagine editing an SQL backup and you need to change sequential ID's I'm trying to imagine, but I can't think of a reason why I'd corrupt my SQL backup.
Yep! I'll be giving a full day tutorial on Laravel, and speaking about composer &amp; release cycles
I was gonna say... they're just now supporting PHP7? I'll pass on using that...
We normally do a self signed certificate and then explain to every programmer they should never ever accept a self signed cert for any other case and why. I know that's not realistic for the homestead project. :-) We only have one project that needs an SSL cert and that's because it's talking to a third party program that requires an SSL cert.
At my day job we do similar. I just don't think it's the right way for Homestead. But wanted to ask here because I'm willing to be proven wrong / convinced otherwise.
&gt; cross domain requests Some corporate web application firewalls (WAF) and web application proxies do not allow cross-domain AJAX requests because of security reasons.
Open source PHP projects can also get a free copy for the developers. So if you contribute to one you could ask the owner to apply for some licenses.
niiice
It sounds like you did the right thing.
Sounds like you did the right thing. It boils down to: who controls that CA? Do you trust them not to spoof certs to *anywhere*? No? Then don't trust the CA.
And that has what to do with the article? Edit: The link is an article about *HTTPS.* The parent comment to this one is essentially *well great now if only we could get rid of WordPress!* What does WordPress, which has nothing to do with whether or not a site is going to be running over a secure connection, have to do with the article? Or is this just *downvote because not on hate WordPress bandwagon* day? Great contribution.
Frontend for life bro!!!!!!!
So I am missing something definitely :/. Tried it, got annoyed buy how slow it was to boot up, and there were like a zillion options. Tried it for couple of days, and got back to sublime. With a right plugins, sublime can do magic. And it is also very, very fast.
PostgreSQL/PostGIS is great for webGIS. You might want to check out [Geoserver](http://geoserver.org/) if you have to serve loads of data, it works like a charm in combination with PostgreSQL. It's an Open Source project for serving spatial data.
Well it may not be the most popular IDE for PHP, but as a free alternative for PHPStorm it will always have its place. Truth be told, not everyone believes its worth paying the price for PHPStorm, especially considering you have to pay again and again every year. PHPStorm is a more powerful IDE with more features, but then you have to ask yourself a question whether those additional features from PHPStorm is worth the price it asks. Of course, to many people the answer is yes, but to some other people like me the answer is no. 
I regret that I have but one upvote to give...
I created a letsencrypt certificate for our personal vagrant machines. We all use the same domains so every 3 months I update the certificates when they expire. We all run vagrant provision after that. To generate the certificate I add a server to our NS which listens all the domains. I turn the server down and remove from NS after generating the certificate.
This. I'm giving her a crash course and think she has the aptitude to run with it for the most part.
If you don't expect to make money with PHP, then of course good tools aren't worth the price. If you do expect to make money with PHP, there's no reason not to get the most productive tool for that. How much is a massive productivity boost worth? If you're just learning, then you might as well start using the best tool as soon as possible. It's not like the software fully locks you out at the end of the trial, you still get 30 minute chunks, perfect for time management. I don't understand the "it's not worth the price" argument when it comes to professional tools. If it will make you more money than it costs, then it's worth it. If it won't, then maybe you're in the wrong field. 
That's good to know. Thanks!
I've been able to throw a variety of valid and invalid xml and html at it with no problems. I've always been annoyed with trying to access certain types of xml attributes on xml tags using simplexml and with querypath it's almost as easy as using jquery.
&lt;loop&gt;
Netbeans has since last year a full dark theme, [Darcula](http://plugins.netbeans.org/plugin/62424/darcula-laf-for-netbeans)
What's wrong with WordPress?
you did the right thing. 
 npm install loop-js
You might also like CTRL + W it will expand the selection, say if you have your cursor in the middle of a word or in the parameter list, you press ctrl + w and it will expand to the whole word, then the everything inside the parent, then of that parent, very useful for selecting divs in HTML or a whole function in PHP. I recommend checking out these courses: - https://codereviewvideos.com/course/phpstorm-shortcuts - https://laracasts.com/series/how-to-be-awesome-in-phpstorm Also this is handy: https://resources.jetbrains.com/storage/products/phpstorm/docs/PhpStorm_ReferenceCard.pdf
Let’s encrypt is only viable for public domains, unfortunately
I use Apache on the host, and Apache on vagrant (I am sure you can use nginx), What you want to do is pass the request from the host to the vm via Proxy. I only develop in https at the moment. All http is redirected to https. On the host you want to use letsencrypt and have a standard SSL setup using a legit letsencrypt certificate. You will proxy the request to your VM using mod_proxy (ProxyPass). On your VM Apache config you want to disable all SSL checks and just use the normal snakeoil certificates. Does this make sense? I can update this post with the Host config and VM config when I get home tonight. *Edit: On your host apache something like ProxyPreserveHost On SSLProxyEngine On ProxyPass / https://app.local:2280/ ProxyPassReverse https://app.local:2280/ SSLEngine on SSLCertificateFile /etc/letsencrypt/live/some.domain.org/fullchain.pem SSLCertificateKeyFile /etc/letsencrypt/live/some.domain.org/privkey.pem SSLCACertificateFile /etc/letsencrypt/live/some.domain.org/fullchain.pem # proxy (do not use in production, dev only!) SSLProxyVerify none SSLProxyCheckPeerCN off SSLProxyCheckPeerName off SSLProxyCheckPeerExpire off and on your guest SSLEngine on SSLCertificateFile /etc/ssl/certs/ssl-cert-snakeoil.pem SSLCertificateKeyFile /etc/ssl/private/ssl-cert-snakeoil.key 
fair enough, I didn't consider using non-public domains/hosts. We use a dev sub-domain of our company domain name here.
In the past, I've instead used a local certificate that the environment (in my case containers) pick upon and use instead. They can be automatically generated too, and that way, you can trust them without worrying that someone else also has it, because only you will have it.
if it's a self-signed certificate, shouldn't the user be generating it themselves, so that it's limited in scope? Rather than trusting this third party certificate and hoping that they're not granting it unintended permission down the road?
What
Self-signed SSL isn't inherently bad, but the trust process is very problematic. Like others here, I feel you were right to reject something that would require it. Was the goal to make e.g. https://localhost work? Outside of a handful of things, this is generally a waste of time. That said, it's doable. If you want to make it work (or provide an alternative for someone's PR), a better approach would be creating a real domain that you can get a cert for and point it to `127.0.0.1` / `::1` (or whatever local address you require). This of course requires purchasing an actual domain. You can use LetsEncrypt to get proper certs for it without actually having anything publicly accessible if you use DNS ownership verification (I do this for several of my internal network resources), although I think their official client doesn't support it. I use [ManuaLE](https://github.com/veeti/manuale). Not sure if bundling the certs will be a problem though; that's inherently risky to varying degrees no matter what. I wouldn't consider it unless you have very high confidence that nobody can mess with the DNS records that you provide.
Can we please just take a moment to remember what a huge improvement Netbeans was over Eclipse back in the day :)
Come on guys, Netbeans isn't that bad as you make it. I now use VS Code (quicker, much superior git support), but Netbeans is still completely bearable.
What we need to teach people is that they need to trust the domain name *and* look for the padlock. This is the reason that browsers highlight the domain. It would be even better if everyone had an EV cert but I doubt that will happen.
Prototyping happens… Let's give OP a break he's just sharing a tip about PhpStorm.
Thanks, good points. I have encountered that problem when adding unrounded values for a total sum and then rounding the values and the total sum separately.
Yes. A public DNS challenge.
[removed]
Omg you should have used node
I let [hotel](https://github.com/typicode/hotel) handle it.
Should have encoded the code into json and stored into mongo because it's webscale
Why?
[removed]
I have very few clients right now since I'm spending the majority of my time on government work, but it seems all the small folks still want WordPress. I don't fault them for it, I just hate working with it :( Then again, the government job I'm doing is drupal 7....
I guess the keyword here to notice is "easily"? 
Any idea when the newer-ish features will be added to the documentation? Random forests, decision trees? Looks like model persistency made it to the docs.
Probably not a popular opinion, but I'd give her webstorm or even phpstorm even though she won't use most of the IDE features. Even just the simple nice stuff it has like being able to do file operations in the project panel etc make it just good to use in general. There's lots of useful editor stuff like doing a diff from clipboard text etc too. And it has GUI buttons for everything, so I don't see how Sublime or Atom are easier for a newcomer. I even use phpstorm as my note taking program now because everything just flows so well. &gt; GIT GUI or a code editor that can do GIT commands. &gt; Code editor that can handle composer updates (would be nice but not required) It'll handle both those requirements too. The git interface is better than any other version control GUI I've used, and much nicer than using commands (even though I'm a linux/unix sysadmin). Why use separate programs when it can all be in one place and have extra functionality that might be useful in the future too? Other bonuses: * inline color picker * refactoring... renaming classes etc * structure panels * database GUI in case she ever needs to do anything basic like look at some rows in the DB * good dealing with overwritten files/merging etc * plus more stuff relevant even only to a frontend dev You might as well just get phpstorm, as webstorm doesn't have anything extra. She'll probably end up editing your templates that have some PHP code in them, so it'll just work better with that. What do you use yourself? TV remotes have lots of buttons we don't use. That doesn't mean you shouldn't use them though. You're kind of asking for us to recommend a push-bike with 4 seats and interior air-conditioning. Why don't you just use a car.
If it's really not Internet facing its not an issue I think. 
Yeah this is how I would do it without a framework. But a JSON file or something could work too. Then you could load a specific JSON file for each language (assuming this is being used for localization)
Coming from a software engineering background, what would be a good resource for getting into machine learning? Specifically looking for readings that would explain the algorithms and their use cases/problems they solve.
i would say start with whats is a perceptron ( like here: https://appliedgo.net/perceptron/ ,but you can use look it in youtube too). After that the path is kinda clear, just move a higher level of difficulty at a time. Here is a guide too: https://page.mi.fu-berlin.de/rojas/neural/ when it starts to get too boring, try do something practical with "dataminer" (http://docs.rapidminer.com) 
I'm going to defiantly have fun with this, but I'm pretty sure if I'm going to make something for deployment I'm going to go with a persistent service instead. Will be watching with interest!
It's a joke, node sucks except in limited cases. It's a comment new and inexperienced developers say all the time. 
Find another platform that you don't hate. The admin view is the most important for clients. Then ask new clients why they want Wordpress and explain the benefits of your chosen platform.
I've used sublime too but made the switch this week. Since phpstorm automatically detects classes and such which speeds things up a lot for me.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Os melhores frameworks php para otimizar seus projetos. 
Yes, many. Amongst them, [Hoa](https://hoa-project.net/). [Travis](https://docs.travis-ci.com/user/languages/php/#Working-with-atoum) is also providing atoum. [Pickle](https://github.com/FriendsOfPHP/pickle/) and [Pomm](http://www.pomm-project.org/) are also using atoum. Non exhaustively, you also have [Orange Business Service](http://www.orange-business.com/en) (pro business), [BePark](http://bepark.eu/) (parking), [fruux](http://fruux.com/) (webdav, carddav, caldav), [PMSIPilot](https://pmsipilot.com/) (hospital), [Mozilla](https://mozilla.org/) (web), [VeryLastRoom](http://verylastroom.com/) (hotels), [M6 Web](http://www.6play.fr/m6) (TV), [Liip](https://www.liip.ch) (web agency), [Tea](http://tea-ebook.com/) (ebook) etc.
Actually, atoum has a very comprehensive asserter vocabulary, of the form: ``` $this-&gt;asserterGroup($data)-&gt;asserter(…); ``` for instance: ``` $this-&gt;integer($i)-&gt;isGreaterThan(42); ``` or: ``` $this-&gt;float(1 - 0.97)-&gt;isNearlyEqualTo(0.03); ``` You have asserter groups for: * array, * boolean, * castToString, * class, * dateInterval, * dateTime, * error, * exception, * extension, * float, * hash, * integer, * object, * output, * stream, * string, * utf8String, * variable, * resource, * etc. [The full list is here](http://docs.atoum.org/en/latest/asserters.html). About the mocks, you can mock class/object, function, and even constant, whatever they are user-defined or from the PHP standard library. See http://atoum.org/features.html#mocks. You should check [the features page](http://atoum.org/features.html). It lists all major features from atoum.
What I'm asking is I don't understand the utility of many of those asserters. Sometimes they cover more complicated functionality, then I understand. But then the authors get carried away and start reimplementing basic PHP operators and functions, which is pure fluff. The examples you gave: $this-&gt;integer($i)-&gt;isGreaterThan(42); assert($i &gt; 42); $this-&gt;float(1 - 0.97)-&gt;isNearlyEqualTo(0.03); assert(abs(1 - 0.97 - 0.03) &lt; 0.001); I can already write this in a shorter, more clear way using plain PHP. And when I say "more clear", it's spelled out exactly what the check does, while with "asserters" you need to learn a whole another library and study the implementation to understand what the heck "nearly equal" means.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
oh thanks, i didnt knew that. best lesson ive ever learned
If you have the time/resource to that I would do it. But I don't think you can integrate a framework middle of the project. Maybe you can use the symphony components but I dont see that as 'easy'
When you ignore the recently added autowiring and the now added getter injection, the way symfony does it is more explicit, and thus imo better. autowiring is kind of like what you describe laravel is doing, but it's just not explicit enough for my taste... you need to make developers think about what they are doing explicitly or they will just do stupid things most of the time...
I hope not.. I have a few accounts I don't remember the password for.
Probably as a learning experience
It's ok, just search google cache for them ;)
Symfony for both projects. Thank me later.
It sounds like learning a smaller framework would be a good idea for you. The more comfortable you are working with them, the easier time you'll have down the road. Some of the other comments here have listed the benefits of using frameworks, which I agree with, and won't bother to repeat. At my job, there's a lot of small and medium sized projects. Anyone who tried to start a new project without a framework would get yelled at by me and my boss. In my experience, the more you code, the lower your tolerance for reinventing the wheel. 
Thank you :) Can you give me some advice for the start and for the integration? :)
What's the point of HTTPS if you surrender your cert to a third party?
&gt; Which one method is better and why? Depends on what you want to do. I usually end up creating my own type of framework´specialized for the thing I want to do.
best: symfony worst: zend framework
I think laravels docs are good but I think can be better with examples. I know I can make Pr's so I might. I think Twilio has great docs for its apis. 
[removed]
This is a fully featured program that will download your IMAP mailboxes to a local SQL database. For anyone curious, `./libremail` will spawn 2 child processes, one to sync email and one web socket server for the administrative interface. It uses React's event loop, pcntl, Pimple, and zend-mail instead of ext-imap. ext-imap actually leaks memory like crazy which is why I had to use zend-mail, which communicates over a socket stream.
don't push you lack of knowledge onto others...
I disagree. I made that mistake twice, requirements and expectations change. "Change is the only constant in life." 
Read [this article](https://symfony.com/doc/current/create_framework/index.html) and decide for yourself. Do you really want to focus on "already solved" problems or you want to focus on your business use case.
It should be there anyway
^Pssst, ^don't ^tell ^people ^autowiring ^is ^bad. ^It's ^killing ^our ^competitive ^advantage.
Okay. Just saw that and got concerned. :P
While I don't have a use for this, it looks great. Nice one!
Thanks for the reply, I updated the OP with their response (wasn't expecting it so quickly), so I was able to get it work, but the price I have to pay is too great to make it worthwhile. Didn't realize iMessage had spoiled me.
Yes
The old Codeigniter documentation with that useful Index menu. 
This is a massive breach and Cloudflare is popular amongst all developers, including the PHP ones. 
I have talked to very few people who are using MSSQL on linux and the common complaint is it's terribly slow. Haven't tried for myself.
Gosh I've never seen anything like this. Ughh I'm confused on this.
By the way, in delete PHP, I am not done, I am just echoing $crs_ID to see if it is working.
What he means is that the line &lt;a href='delete.php?crs_ID=$crs_ID'&gt;Delete&lt;/a&gt; is actually part of the HTML and not PHP-Code. In order to show *$crs_ID* you have to echo it inside a *&lt;?php … ?&gt;* Tag, like you did for *$crs_code*, *$crs_title*, etc. So you should write &lt;a href='delete.php?crs_ID=&lt;?php echo $crs_ID; ?&gt;'&gt;Delete&lt;/a&gt; instead. The function *sprintf* is just a better way to display/echo a variable (see [Manual: sprintf](http://php.net/manual/en/function.sprintf.php)). &amp;nbsp; *EDIT: Formatting.*
Not sure I understand your intent. Https content was leaked but it wasn't en masse due to exposed certificates. Could you explain?
Thank you for that!!!!
Can you add: if (false === $addstmt-&gt;execute()) { echo $addstmt-&gt;errorInfo(); die(); }
&gt; if (false === $addstmt-&gt;execute()) { &gt; echo $addstmt-&gt;errorInfo(); &gt; die(); &gt; } had to change echo for print_r Array ( [0] =&gt; HY000 [1] =&gt; 14 [2] =&gt; unable to open database file ) I am running a SELECT statement after this statement that works as the file permissions are 777 ls -lia helpers/thisweek.sqlite 2626179 -rwxrwxrwx. 1 root root 13312 Feb 20 15:10 helpers/thisweek.sqlite 
the path is relative and it manages to opent the DB for a SELECT statement later on in my code; I also have SELinux set to permissive. This is my structure: /var/www/html/tv/admin.php /var/www/html/tv/helpers/thisweek.sqlite I've just never had such patchy support from SQLite before.
NVM I got it
The function I mentioned was wrong.. I meantt http_build_query see here for an example (untested) http://pastebin.com/J8Zsp1Py
then I really have no idea. You could try /r/phphelp , which is actually more for these kind of questions :)
Because people in this sub have been whining about anything possible since php 4 was released
It's a decade-old project that I haven't run since then, but I think I had a cronjob set to remove the lock files- what usually happened was the originating script died before it released the lock on the file. Very ugly hacky solution.
&gt; I am running a SELECT statement after this statement that works as the file permissions are 777 It would be worth checking the permissions of the "helpers" directory, too. By default, PHP and the web server will have a user like www-data. It may be worth resetting permissions along the sort of: chown -rf www-data:www-data /var/www/html find /var/www/html -type d -exec chmod 770 {} + find /var/www/html -type f -exec chmod 660 {} +
It's worth noting by default PDO does not throw exceptions. You have to set that with: $db-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION)
So this means we just need to log out of the affected sites right?
The purpose of HTTPS is to ensure a secure connection between your browser and the site you're connecting to. Cloudflare sits in between you and the site. This means they need to have a private key for an SSL cert to re-encrypt the data. Consequently, if Cloudflare were to be compromised, they could inject malicious content onto the page, and your browser will still say the connection is secure. If you allow a third party to terminate your SSL connection, you're placing your full trust into that company. I don't use Cloudflare for sites I'm using HTTPS on, so I know that there's no MITM happening between the client and my server. 
That makes sense, thanks for explaining this.
No, it means your passwords and other information may have leaked, logging out does nothing to solve that.
Sorry. I don't actually know anything about front end development, but I'm very very proud of my full stack "knowledge." Talking down to people makes me feel like my "skills" are more valuable. 
It would make sense if it was most optimized for asynchronous IO for which Linux has poor support.
I know you're from /r/java lmao and tbh it makes the whole thing far more enjoyable. 
It's pretty normal to let AWS terminate SSL for you through their load balancers, putting your web applications behind CloudFlare while letting them terminate SSL for you is fine too. Doesn't change the fact that CloudFlare is really going to eat shit for this though.
&gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). Actually... ^^
I'd be interested in having a look. Going to put it in a Github repo?
&gt; Not at all, or just none of their services? Not at all. I used to run my own DNS, but that became too much of a hassle so I just use the domain registrar's DNS servers now. I do use Cloudflare on one of my sites that encountered lots of abuse (bots constantly hitting pages on it). Their protection really helps in situations like that. However, that site doesn't take any sensitive information, so I'm okay proxying it through CloudFlare.
Good stuff. My general concern is that people don't realize that any DNS provider effectively has keys to the kingdom for any domain they service (since DNS can be used for proof of domain ownership for certificate issuance), regardless of any other services they may perform. The only way to mitigate such an attack is HPKP+DNSSEC, as far as I'm aware.
I believe you're talking about CloundFront, not CloudFlare here, although there is little difference in how they work.
It amounts to the same thing. Key substitution is one possible man-in-the-middle vector. If Cloudflare were compromised, you'd be no more secure than if you'd shared your key with them.
Laravel's docs are quite good.
Why would you need it in a local development environment? I can see having it in a staging/testing environment but why bother with a local environment?
If you're able to try this out I would love to hear your thoughts. As well as if it did what you were setting out to do.
Reddit used Cloudflare until recently (although I'm unsure how recent).
That's what I would say too.
I've just started programming, how do i fix it? Send me a link, point me in the right direction
Please read the OWASP [XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_\(Cross_Site_Scripting\)_Prevention_Cheat_Sheet). Google also has a good [intro to XSS](https://www.google.com/about/appsecurity/learning/xss/index.html) techniques and prevention. After you've read those and fixed your site, checkout Google's [XSS game](https://xss-game.appspot.com/)
I had to learn ZF1 from scratch when I was figuring out how my company's online system worked. I figured a month tops would be enough. Took me damn near half a year. ='(
I apologize for my question, but I don't think it warrants it's own thread, but when you mentioned susceptible to xss, what do you mean? Also what is PoC? Not in a situation where I can research myself, but still very interested!
Much better!
XSS stands for "Cross Site Scripting". It's a vulnerability that allows an attacker to inject script into your website. For example, say this Reddit comment was vulnerable. I could create what appears to be [a legit link](https://www.reddit.com). However, when clicked on, a browser would download a ransomware/malware package, send me your cookie, basically anything I want in Javascript. How far the attack can go can also depend your OS and browser (and what plugins you have installed). PoC means "Proof of Concept". My PoC was to demonstrate that his website was vulnerable (the Proof), but without any type of malicious payload (the Concept).
Thanks again :)
My favorite is selecting a dev with 90% success rates and 100 jobs completed on jobhiringsiteX.com who is a professional in PHP Framework Y then having to coach the dev through refactoring because core code was changed, or code was misplaced for Framework Y. Better yet realizing I did a horrible job explaining the task at hand so between that and language barrier 10, 15, 30 hours was consumed not making any progress towards the final goal. 
No problem. Happy to see that you took care of it so quickly!
[removed]
This kind of title could start the third world war 😅
Does this support IMAP IDLE?
And no problem to see Laravel first and Symfony third ? Funny...
I am not sure about ML specific usage as I am not an expert in that field. However, I have to say that I am really impressed with PHP7's speed when it comes to handling things that are NLP related. I do a lot of statistical NLP related stuff and PHP7 is really fast even when compared to Python. Also, the native PHP array data structure gets a lot of hate because of its "jack of all trades" properties but when when you can process hundreds of millions of lines in PHP within seconds, you start to realize that PHP might not be a bad language for such usage after all. With that said, I would be interested in seeing some benchmark comparison between php and python in regards to ML!
What you're asking is called "MVC". There are many resources out there on it, and it's not limited to Symfony. The general idea is that "model" deals with storage (db mostly), the "view" deals with what the user sees, and the "controller" is the "glue" between them. It takes the data from the **model**, makes it *presentable* and passes it to the **view**. It also makes sure the data is ok to write to the **model** etc etc...
Your problem is that you missed some very basic concepts of programmins (and you are not alone by the way) - decomposition. When you are take some big problem and split it to smaller problems. &gt; make namespaces http://php.net/manual/en/language.namespaces.php You should understand how to split system into modules. Learn about coupling and cohesion. Basicly namespace = module. It can contain other modules and so on. &gt; Make a model Symfony isn't MVC framework, so please don't read any of crappy articles about MVC in PHP. This just wont help you. The meaning of MVC on backend is lost many years ago. Instead of it, learn concepts like data abstraction, separation of concerns, models and so on. This is related to decomposition. How we can represent some real-life object and ignore some not important details about them. Typical misunderstanding when people are thinking about classes it that they usually start from describing object's state and after that they try to think about behaviour. Methods of objects are representation of what we can do with this object, it's behaviour. You have for example object `Door`. It can be opened and can be closed. So model of our door will be: class Door { public function open(); public function close(); } Of we can add some restrictions, like "you need to have a key from this door to open it": public function open(Key $key); Or you want something representing users in your system. Users usually should be authenticated, so you should have `authenticate` method in your user class. Or for example "User can make order" - then you probably will have "makeOrder" method in User model in order to create order and pass to it some information about user. In Symfony by default you would use Doctrine which allows you to do that, but there is also symfony/forms which want's to work with data directly. This adds some confusion since it forces you to break encapsulation of your models. In order to prevent this, you could just create additional data-models which can be used to fill the form and read data from it. Then other objects will take this data and do the work. Anyway forms are part of UI and pretty much often forms or just data required for operation is just different from data stored in your models. &gt; make a controller Controllers - is just specialized objects. Each action will represent some "action" in your application from UI point of view. For example you have some "action" - register user. But from application point of view this action can be splitted to separate operations. Firstly we should create new users. Then we should register it in our database checking that there is no other users using same identity (email for example). Then we probably need to send some notification to user's email about successful registration. And maybe we should inform admin user about new user. All this stuff is separate operations and different objects may be responsible for this. Controller will just summarize this operations in order to make single action. tl;dr; Don't try to learn symfony, just use it (this doesn't mean that you shouldn't read documentation, this only means that documentation may require some background knowledge, and you may google for it as you faced something new).
&gt; Model = the "blueprint" for your data two worlds - data abstraction. You shouldn't think in terms of data, instead you should think in terms of behaviour, what we can do with system of it's parts.
Yep, and i think that person should learn about this stuff before digging into some more high-level ideas like MVC. This is fundamentals, it doesn't changes from framework to framework of event from language to language. And this is something that most developers just missed.
Thank you for the answer. :) Can I ask help in a practical example, too? (I wil understand it more easily if I can view the working of the things on a project what I'm working on) I'm working on an inventory management software for my father's shop and this code is one of the pages where he can edit a product: http://pastebin.com/cVDSYa81 And the "script" what edits it: http://pastebin.com/Y38vtwbh How would you import into a symfony project?
Not everyone subscribes to every webdev sub. 
Well I would just write from scratch, but let's "refactor" this. *step 0. Composer* First of all I would add composer to my project to not write any new bicycles. *step 1. Move HTML to templates using TWIG.* So basicly we should split problem into two right now. First - we need to get data from database. Second - we need to render it. This is one of the most annoying step but this must to be done. In order to reduce amount of work, for example if we have to many templates, we could look for/write extension for twig which allows to include PHP templates. This would allow as to refactor application by parts. *step 2. Get rid of super global variables* You could use symfony/http-foundaton component to add Request and Response objects. You could use request object globally just as you use `$conn` variable just for now. Also you need to work with sessions thought session bag provided by this component. Then we should create `Response` object instead of manually echo output or manipulate with headers. There is `RedirectResponse` for example. *step 3. Move SQL stuff to separate data providers* Now we need to move all our work with database in separate object. Instead of allowing to execute SQL we just put SQL there. So we will have methods like `getInventory(string $barcode)` which will return all needed data. You could also move taxes calculation there for now as separate method which add result of calculation to resulting array of data. It would be great if tax calculation could be moved to separate object, but this just another level of decomposition. *step 4.* Add actions Right now you have action-per-file. So we can basically wrap remaining code into a function which takes `Request` as argument and returns `Response`. On this step we will have several global variables and bunch of pretty small functions we acts like controller's actions. *step 5. Dependency Injection and configuration management* At this step we could just add dependency injection component, but we probably are too lazy for doing this, instead we could just start to move code to our symfony project. First of all, we should get rid of all global variables. To do so stuff like our DataAccess objects should be registered as services so we can get them. Doctrine's DBAL and twig are already registered in symfony by default, so this reduces amount of work. After that we could start to create controllers. We already prepared actions, so we can just place them into separate classes. We also need to move our templates somewhere, so twig could find it (`app/Resources/views` for example of add our current template locations to symfony config). Then we should add routing for actions. We also can use urlGenerator instead of hardcoding paths. Basicly we are done now. We could also move to Doctrine but this is another story. I don't like to use Doctrine ORM with existing database schema, this makes process pretty complicated. But since we already moved our database interaction, we could also do that.
In MVC the model is not just a class, it's a layer. Good article about this topic: https://www.bennadel.com/blog/2379-a-better-understanding-of-mvc-model-view-controller-thanks-to-steven-neiland.htm
So when a framework is more popular than an other it is better too? Not at all.
&gt; Your templates What about URL generator? Isn't this all part of view? Redirect - isn't this view? HTTP headers are also part of view. Requests - is this part of view or it belongs to controllers? &gt; Calls services/repositories, pass these to views and done. entities should be never passed to view... only if we are lazy enough :) &gt; Authentication logic is done through symfony security component. But you need to write user provider. I personally don't like symfony/security for authentication by credentials. I use it for authorization only or for authentication from token stored in session for example. I don't like the idea of `getPassword` in my entity. &gt; For your change-password, you would check that in a service or controller if you are lazy I do this in my entities. This is perfect place to do this since it already have all needed data: public function changePassword(string $oldPassword, string $newPassword, PasswordEncoder $encoder) { if (!$encoder-&gt;isValid($this-&gt;password, $oldPassword)) { throw new PasswordMissmatch(); } $this-&gt;password = $encoder-&gt;encode($newPassword); } So if I for example want to add logic like "user can't use password if it already has been used" I could implement it there, and no new services/getters will be added. And all this logic is testable. 
Any good recommendations for learning Symfony? Also, should I explore Symfony 2 as well or just start and get on with 3? 
https://symfony.com/doc/current/create_framework/index.html Build it yourself using the components. 
By hillbilly logic, yes. This is why Transformers get the Hillbilly Oscars every year.
That's not true. If you want to update the translations, you just need to create another mo-File (like lang-1488039603.mo) and use "lang-1488039603" as the domain in [bindtextdomain()](http://php.net/manual/en/function.bindtextdomain.php). No PHP restart needed. 
I'm learning PHP alongside Laravel and I have to agree. The laravel docs are absolutely fantastic and coupled with the Laracast videos allow me to learn the language and framework from top to bottom, it's fantastic.
[Analogy](https://www.merriam-webster.com/dictionary/analogy) &gt; resemblance in some particulars between things otherwise unlike
There is no question about the fact that you are right. But in my mind, if performance is a concern to that extent, PHP can function as a wrapper for C libraries the same way Python does. It is just up to the community to create those tools, wrappers and well performing code. I don't think PHP itself is that awfully limiting as you make it sound. However, I want to make it clear that I do agree with you that there probably are better tools out there today to get the job done with!
I'll admit I do have a personal problem with that but the distilled hatred I feel toward CodeIgniter overwhelmed me. The inclusion of CodeIgniter anywhere on that list is more egregious in my eyes. 
I had a look at index.php to find that it was 515 lines long. Obviously not MVC, but whatever suits the use case. I might have a play to see if I can rewrite some of it to be a bit closer to what most people are used to..
It's nice someone would do this, But is PHP really the best language to do this... developers who are serious about machine learning would be using OpenCL or CUDA for their algorithms and since PHP doesn't have support for GPU integration....
frightening
Hey there, developer of UserFrosting here! We use [Twig](https://learn.userfrosting.com/building-pages/templating-with-twig) as our templating engine. Since others have mentioned Laravel, I might as well point out - we actually build on top of some of Laravel's best components, like Eloquent, its ORM. I'd suggest at least checking out our [demo site](https://demo.userfrosting.com), which will give you an idea of some of the features you get right out of the box. It should meet all of your requirements. For (3), you'll want to invert your statement - "my custom html website can be easily integrated into a UserFrosting application."
Man that's a well structured library. One thing I like to do is create an enum folder and have my form arguments in their, for example rather than having the constants on the 'Activity' class have them in an 'ActivityLevels' class in the enums folder with only the five activity levels. that way you can show in the docs using the class constants as arguments so people get type hinting on what options are available. eg $tdeeCalculator-&gt;calculate('male', 176, 6, 24, ActivityLevels::VERY_ACTIVE); Also, I like the idea of classes for height and weight given the potential ambiguity with metric and imperial, but is it really needed for age and gender? 
People don't live that long^/s But seriously, this is not correct. Why give an upper bound at all?
As cool as it is to make fun of things, it would be much better to be constructive about it, so other people don't make the same mistakes.
Upgrade to the latest PHP version? 
Non-Mobile link: https://en.wikipedia.org/wiki/Cache_stampede *** ^HelperBot ^v1.1 ^/r/HelperBot_ ^I ^am ^a ^bot. ^Please ^message ^/u/swim1929 ^with ^any ^feedback ^and/or ^hate. ^Counter: ^36597
Didn't think it would be necessary. Now on a second thought there's no need to an upper bound.
I found a gist that has IDLE implemented in PHP. I think this is a wonderful addition to libremail! I going to try and set this up over the next couple weeks.
If server response is 1s and time until page ready is 3.5s, then you have 2.5s of DOM/JS/CSS slowing you down. You could use Chrome DevTools to determine what the slowness is. If you want I could take a look, I enjoy doing performance analysis :)
Already got it
[removed]
Sorry but without any kind of info you arent going to get much help at all. 
It is somewhat funny that you ask in /r/php how to optimize the *client-side* rendering. Not that I say there are no pros to help you around but sometimes I wonder what is the logic behind the people's actions.
Phalcon documentation is really good. They went out their way to include example projects and tutorials in their documentation to help people learn how to use phalcon. Second to phalcon would be laravel.
he is not creating a resource but using imagecreate only to test the image. besides, throwing such pointless errors (like "can't save") is rather a bad practice. A real one, unlike your silly nitpicking on variable names. your answer (when you didn't manage to get what the initial code does) *is* the actual reason why PHP is called a Fractal of Bad Design.
&gt; your answer (when you didn't manage to get what the initial code does) is the actual reason why PHP is called a Fractal of Bad Design. Do you sometimes read old comments you posted and thought "ok, I kind of went overboard there, I should maybe start taking my pills again"?
Are there any free alternatives for personal open source projects?
Thanks, realised that after reading more into it. I thought only the session was compromised from the title. But data was compromised too so yeah..
I think the guys at blackfire.io will gladly help you with your open source project for free. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
[removed]
I guess using imagecreatefromstring(); is safe right ? this will make sure I only save images because I just can't trust the MIME TYPE sent with the base64 string
I wouldn't rely on it. JPG can have comments, so does PHP. IIRC someone posted a page that worked as an image AND an HTML page with a clever comment mix up. 
Ok then what about if I did something like this : $image_name .= '.png'; $path .= $image_name; $ob = file_put_contents($path , $image_data); making the extension fixed as "png" will that solve it ? anyway whether it's solved like or not is there a better way to validate a base64 file type ?
Thank you for the feedback. My main goal is to improve myself as a programmer, so I find those comments really helpful.
Besides very recent personal experience. Javascript script src tags will block (unless loaded with the async attribute, but that has its own caveats such as weird behavior when using document.ready()). You can Google for references, there are plenty. Of course if it's http/2 it won't matter. 
Sometimes increasing the RAM helps.
Do you have any source? I've read many claims saying that, but no proof. Nobody has ever provided empirical or technical proof of that. I think browsers changed and stopped working like that a long time ago.
website servers as well as database server and memcached server has lots of free CPU and RAM 
&gt; Before a browser can render a page to the user, it has to parse the page. If it encounters a non-async or blocking external script during parsing, it has to stop and download that resource. Per Google, [Avoid external blocking JavaScript](https://developers.google.com/speed/docs/insights/mobile) and CSS in above-the-fold content. And a more in depth article from Google advising that we should [Remove Render-Blocking JavaScript](https://developers.google.com/speed/docs/insights/BlockingJS) [Another](https://varvy.com/pagespeed/render-blocking.html) from Vary about render blocking javascript. &gt; However, JavaScript can also block DOM construction and delay when the page is rendered. The above quote is from an article written by [Ilya Grigorik](https://www.igvita.com) titled [Adding Interactivity with JavaScript](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript): Parser blocking versus asynchronous JavaScript.
In terms of proof, any 3rd party performance tool that generates a waterfall of your page load/rending will show it. You can also see it in the waterfall and the javascript profiling statistics using the chrome dev tools.
Thanks, that was a huge help! :)
If the web page has many css, javascript and images then the visitors may hit maximum parallel connection limit http://stackoverflow.com/a/985704/233286
I don't know wheter it will help or not but you can try HTTP/2. As far as I remember it you can push css and javascript files before the browser requests them. Also you may want to serve your non PHP files without loading PHP. If you use a normal Apache and the client request an image Apache loads PHP with the image and then serves it to client. So, serve static files without PHP http://serverfault.com/a/573527
When you say "lots of free CPU and RAM" do you mean 50% or more? Having that much free ram *could* indicate that you've not allocated enough resources to your webserver. Either that or you just don't have much traffic. See my post above regarding tuning for mpm if you're using Apache. If it's nginx, ensure you have worker_processes and worker_connections set appropriately for your load. General rule of thumb is worker_processes to number of cpus.
[removed]
We all got fooled by a bot
Maybe not exactly what you asked for, but still worth to have look at: [igbinary](https://github.com/igbinary/igbinary) can be used as a replacement for serialize/unserialize to serialize the data to a binary format instead of a string.
Not too long ago the twig C ext was a must, I actually can't remember if it's included in my site set up automatically now or.. maybe I can get a nice easy boost across the board tomorrow!
I just stumbled upon a case for duck typing. I have this long-running PHP script that receives a batch of records from an external process that I don't control. The important detail is that sometimes the daemon will send hundreds of thousands of records in a single JSON line, which I then must hand off to my *BatchRecordProcessor* interface. If I map all of the records from the *stdClass* that *json_decode($data, false)* gives me to instances of my *Record* class, I get stronger-typing and IDE-completion for the properties of the *Record* class, but I momentarily nearly double my memory usage because I'm holding a large array of *stdClass* objects and a large array of *Record* objects in memory simultaneously. With duck-typing, I can type hint in my *BatchRecordProcessor* interface that it must accept an array of *Record*s (*@param Record[] records*) and anyone who implementes that interface can get IDE completion without creating all these disposable objects that have no other value. That said, I'll stick with the annotation approach, and I won't even consider the duck-typing library for my batch-processing script.
gmp is faster than bcmath on every use case I ever had to implement, and now part of core in PHP7.
My answer is none, as soon as you use extension you aren't portable anymore, it becomes a deployment nightmare on some targets (I'm thinking about Red Hat/CentOS for example, even though it's much better now than it was 5 years ago). As soon as you *require* an extension, you make your app harder to deploy, so I don't use extension at all, except for very specific business use case; but most of our products are meant to be deployed on various OS targets.
There's a pull request to re-add it for Twig 2.0 - https://github.com/twigphp/Twig/pull/2310 But the way the benchmarks are looking, it's not really needed.
Leaps and bounds ahead of GD from what I've used. Still a bit wonky at times though.
But gmp have nothing to do with floating-point math.
That's the entire point of a garbage collector. If you always know when an object isn't needed abymore why don't you go ahead and free the memory yourself? Weak references have a very good use case: avoiding reference cycles. Example: in a tree you might have strong references from parent to child, but only weak references from child to parent. When you drop your last reference to the parent your reference-counting memory manager can free all the children immediately without having to involve an expensive mark-and-sweep phase. Used in this way weak references are helping the garbage collector, by providing better semantics. Kind of the opposite to your post! Careful use of weak references can even make it possible to [disable the circular garbage collector]( http://php.net/manual/en/info.configuration.php#ini.zend.enable-gc).
Actually you're right, I have used both for their arbitrary length integer (big numbers) API. bcmath indeed do more than just that.
And the point of weak references is to avoid circular references. Not, as you claim, to be lazy about object lifetimes.
because people can't tell it's a joke with so little context.
gd and imagemagick are pretty awesome
Hence the smiley :)
What's wrong with using integers and a decimal delta for final display? You could end up with precision problems in your storage engine too!
Still waiting for the videos from PHP UK! :-) There was a talk there where some of these tools were presented, by the guy behind this repo.
 &gt;Weak references have a very good use case: avoiding reference cycles. IMO "pre-optimizing to help the GC handle situations slightly faster" isn't really the best use-case. I mean, the GC ought to handle cycles anyway. The best use-case is when you truly don't want a strong reference, because you don't care if the object lives or dies, and you cannot trust the object to notify you that you need to let your reference go. A typical example would be listeners and observers. A long-lived object with strong references can easily keep a ton of unnecessary near-orphan objects alive.
docker solves all of that
&gt; is using the garbage collector to know if a value has been wiped out at runtime It's more about **allowing** the GC to wipe things out in the first place: "If that thing still matters then I'll use it but don't keep it around just for me." 
&gt; It's more about allowing the GC to wipe things out in the first place Yes of course, but it remains a use case where you don't control the lifecycle of your reference.
Hear! I never use floats ever when dealing with important stuff such as prices and currencies. Only integers and a simple division operation for display only. 
I once had to use PEAR on a Windows Server. It was not fun.
+1 for ImageMagick, though I've written a simple abstraction layer to do the most basic things (resize, scale, crop, conversion, etc) that will use GD or IMagick, though prefers iMagick if both are available. Just makes life easier. :-) 
I use igbinary in a wide range of projects where the data doesn't need to be human readable. It also has hooks to replace the serialize function in the built in session storage, and can be used with memcache/memcached.
Its easy to abstract some stuff. Many extensions available are faster than some features. For example, build a wrapper around libsodium and openssl. Chances are one will be available, and libsodium will be included in 7.2. I have a wrapper class around ImageMagick that will fall back to GD if IMagick is not available. Also have my own session handler that can use igbinary, json, or build in serialize/unserialize. It's not hard to build portable code in many cases. That said, there are quite a few very specialized extensions available, but in 99.99% of those cases where you need something highly specialized, a VPS or Docker instance is prefered anyway.
http://image.intervention.io/ I really like this library for image manipulation. Means I can use ImageMagick when I can 100% control the server but fallback to GD when I can't (and can't convince them to install IM).
I don't either. I chuckled. :)
Any of those come close to phpstorm inspections?
We have the same thing in Drupal. GD + iMagick compatible for the basic manipulations.
Not just docker, but any container system. 
Yep, that's definitely a good option. As of now I don't use VMs for dev but that's really only because there hasn't been a need to (my projects are small). With your setup - do you dev locally and then deploy up to the project-specific VMs, or just edit directly on the VMs?
Yea virtualbox and vagrant give you pretty easy ways of sharing your local filesystem with VM's in real-time. File permissions between local and VM can be a bit buggy, but it's a common issue with many solutions online. So I basically have my code living in my local user's home directory, shared with my VMs, (local: ~/user/Projects/client1 -&gt; VM: /var/www/client1) and worked on via PHPStorm on my local (with GitKraken source control on my local). You can also setup x-debug on the VMs to work with breakpoint debugging in your local IDE. I tend to have contracts spanning months involving many large projects, and the last thing I want is months of configs and files spread throughout my local machine when I change clients. Same could be said for lots of little projects, in which case you could have 1 Linux VM with all your opensource platforms, 1 Windows VM for all C#/ASP.NET projects, etc... Setting up new VMs can be a headache if your not very good at sysadmin (like me), but repetition and practise, and eventually you'll learn new skills and know why something isnt working. I myself have heavily modified my VagrantFile (script to start VM) to do as much as possible automatically on creation. The beauty of the whole thing is if you screw up the server setup on VM, just delete the VM and start again.
&gt; On a web server you *should* have lots of free RAM so that the OS can cache file content. Mmap is a thing yes, but it shouldn't use a ton of RAM on a webserver - and doesn't matter a whole lot if your serving mostly dynamic content. Of course if you just reboot the server you want plenty of free ram so the oom killer doesn't go nuts when Apache and FPM starts. And you want enough free ram to prevent the disk i/o of going to swap.
The mailparse extension is quite great if you need to handle/process emails.
"Scaling PHP7 Applications" by Steve Corona (https://leanpub.com/scalingphp) has a lot of good practices. Besides that, we use https://blackfire.io to profile and find the slowest parts and rewrite/optimize those parts in the code. It's really worth its money. You might also wanna start looking into Varnish if there are no obvious parts to optimize in the code. 
SSH2: https://gist.github.com/magnetikonline/48ce1d1dca53b44666ba9332bc41c698
Do you use an IDE? Does that IDE have the ability to auto-deploy upon save? I use phpstorm and you can setup deployment servers, in the delopyment options you can also tell it to automatically upload to the deployment server whenever you ctrl+s to save the file. It's just meant for development work right. I personally host everything server wise out of the users home directory. I used to do /var/www until I just got fed up of dicking around with permissions.
Awesome! Thanks for sharing
I started using that one cause of job, I honestly like it a lot!
Silex = example how to build your own framework using Symfony components. You may use it on very simple projects (small API usually) mostly to know how symfony works. But since Symfony 2.8 allows you to [use micro kernel](http://symfony.com/blog/new-in-symfony-2-8-symfony-as-a-microframework) I really don't see any case for silex anymore. Most of projects on Silex that I was working on became just "smaller symfony".
Imagine a meal. There's peas on the plate, some mashed potatoes, lettuce, and a steak. It's a nice 20-30 minute lunch. That's Symfony. Now imagine putting all that in a blender, adding a bit of water to make it drinkable, and downing it all at once. It's a one minute lunch, but takes a lot more time to clean up. That's Silex.
I don't know so I can't answer your question. I use Laravel which is built on a lot of Symfony components and it is pretty good. Do you have a use case in mind? People might be able to give you more information if you say what you want to use it for. If you want to check out Laravel then laracsts.com is good for learning. Maybe build something simple in symfony to see how it works. Then you will have more context to see if Silex offers any benefit. [this](http://stackoverflow.com/questions/11270016/the-difference-between-symfony-and-silex) makes me think symfony is better to start with.
You should really use a CDN for static assets. Page cache is usually the last thing you need to worry about unless the machine is swapping - which usually means you've allocated too much memory to apache/nginx/fpm/etc. A typical linux machine will start using the disk swap for paging when there's not enough free memory (the default for sysctl vm. swappiness is 60, which means it'll start use swap a little and more so when memory gets sorta low). If you're 100% certain you will always have enough ram, you can set vm.swappiness to 10 for a small performance boost due to less disk i/o. 
Silex is basically a light-weigh router and DI framework that makes use of symfony components. There's no ORM, and most of the things you take for granted in a larger project don't exist. It gives you the ability to use individual symfony components without having to use the full framework. However, as one of the other commenters pointed out, with the symfony microframework included in 2.8, this is less useful.
Indeed. This is not necessarily a hard problem to solve on case by case basis. I mean, that's essentially the quick workaround we went for too. Hence I'd say the main purpose of this library is to make it simply more convenient. Like, for example, you can just give it an iterator and it just works or if you're dealing with PSR-7 HTTP messages, you can easily just use the provided class that implements the StreamInterface.
Do you guys know a method to successfully install ImageMagick to Xampp PHP 7.x for Windows? I tried using every DLL to implement it as extension (after trying the correct one for my system, I tried the other ones too.. just to be sure). 
I got so many gold stars at school; congratulations 
How about: Silex is an engine on a chassis with a steering wheel, brakes and accelerator. Symfony is the full car with the air conditioning, the electric windows and that middle bit in the rear seat with the cup holders.
I would not use floats to represent, or BC math to do calculations on prices personally. Prices are an example of a measurement with a known precision. In most situations you know there are always two decimal places after the integer portion of the number. (unless you are dealing with an application that uses fractions of cents or some of the more unusual currencies). In this situation you can just multiply the "dollar" number by 100 and treat it as an integer. ie, you store it as the number of cents, and do all your calculations on the cent values, then convert to dollars for representation only at the final step. This will be around 100 times faster computationally than using bcmath. Other examples of this might include a temperature sensor that measures degrees farenheit, but only has a precision of +/- 0.1 degrees farenheight. In that situation it is meaningless to do complex math on a number like 57.9087635 degrees because you only really know the "real" value to be 57.9 +/-0.05 degrees. So what would be the point of using arbitrary precision math on something that you only know the value of to 1 decimal place. Worth looking at https://en.wikipedia.org/wiki/Propagation_of_uncertainty and actually deciding if you need to use BCmath before diving in.
A close-to-zero voting for this link is a shame on the community. This is a very useful and justified article. Many would benefit from it long before they'll be able to publish anything on github. 
This image of benchmarks might help: https://www.symfony.fi/files/2016-01/sf-microkernel-frameworks-graph1.png Basically, silex is lighter and faster than the full AppKernel of Symfony, but now that the MicroKernel is an option for Symfony the performance benefit of Silex goes away.
&gt; You have to accept floats as user input Nonsense. Users type stuff in boxes, so it's strings all around unless you let PHP type juggle them. If you have to accept floats and you don't want to, then someone did something wrong. Not saying it's you, but someone.
Laravel uses blade for templating. You can use the blade syntax or php. I think that blade syntax it's better in the long run. You will define something like '@include('header.blade.php')' '@include('footer.blade.php')' Main layouts are located: resources/views/layouts/ But when you extend from them to get views, they are located: resources/views/ Learn to use Blade, it's really powerfull. 
Laravel has a templating system called Blade which solves this sort of problem, https://laravel.com/docs/5.4/blade https://laracasts.com/series/laravel-5-fundamentals/episodes/5 You should look into that! Short answer is you don't add an `include 'foo.php'`, you use the templating system (`@include('view.php')`)
Stars are very important for open source repositories. Especially if you ever hope to have a career in F/OSS. **Quite** a bit different from a gold star for not shitting in your pants for a day during primary...
It's not just PHP, read the other ones too, like Perl. &gt; So you like dollar signs, but don't want to use PHP? That's cool, we all get tired of understanding code sometimes.
Ouch, sad prices are sad! Just out of curiosity, didn't you consider using integers with a very high decimal delta to prevent precision problems ? Such as 00000010000 =&gt; 0.00001 for example ?
could be done, but as said, we're getting them as strings from an external system, so either some calculations or some string manipulation must be done... to be fair, we do keep them as strings when we dont need them for calculations.
Thank you And if the head.php and footer.php are scripts for connecting to the database, include the css and so on what is the preffered method?
Those functions are not located in the view. Laravel uses it's own classes for connecting to the database, and you can specify those connection in the config and environment files. I would recommend you to watch the free series [Laravel from scratch](https://laracasts.com/series/laravel-from-scratch-2017) at Laracasts.
I second this. But first, OP, you need to learn MVC! [Here is an introduction to the concept](http://php-html.net/tutorials/model-view-controller-in-php/).
&gt; PHP Stan - Focuses on finding errors in code **without actually running it.** This is just plain incorrect.
File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Deployment -&gt; Options -&gt; Upload changed files automatically to the default server
To be fair, the title does scream 'CLICKBAIT'. (For the record, I upvoted it)
&gt; I didn't read the rest of your comment because I doubt it would be with anyone's time... The rest of my comment said **3 out of your 4 examples are not profitable FOSS-based companies**, Mr. Open Minded Genius, who can't be bothered to read.
You connect to the database through the models, the data you need you get from the model and you hand them over to the controller, at last you parse them to the template (thats the structure of the Model-View-Controller Pattern: https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller).
Password for the database will usually be stored in the environment file. The only difference between the .env file and other a config file is that the .env file will (by default) not be included in a git repository. So if you need to edit it you'll need to have access to the file either through ftp/ssh/local filesystem or similar. I agree with /u/emilvikstrom though, you should get a good understanding about MVC principles first.
Is it possible to get part time/summer jobs as a developer, and if so what types of projects are you to expect from such a position? 
There's a 57.94% chance that you're reading this comment in Google Chrome if you're on a desktop because of Google--who has arguably contributed more to Open Source than many of the other top contributors __combined__. But sure, who thinks of FOSS when they think of Google, right? And Oracle, who pioneered OpenStack. Who thinks of FOSS when then think of OpenStack? Or hell, even MySQL--which we as PHP developers most likely use regularly. Right? Because to be a FOSS-centric company you _absolutely cannot_ sell a commercial product, right? You know, like RH__E__L... You have __serious__ misconceptions about what FOSS is. &gt; 3 out of your 4 examples are not profitable FOSS-based companies Which was never the issue until now--because you're making it one because you believe that it somehow makes you "right." You specifically said; &gt; What's the average salary in F/OSS? How are their offices, health benefits? You don't think Oracle has an average salary? Or offices? Or health benefits? But no, now that the status quo isn't in your favor you're changing your argument. These companies don't need to make outstanding profit to pay well, or have good benefit packages. Oh, and all of which hire developers who have contributed to OSS before as a _priority_. Do you think it's a huge stretch that they'd look at a developer with a GitHub profile with a repository with a high number of Github stars favorably? But that doesn't fit into your view of OSS, so I guess you'd say no, right? Is that too much of a "grasp" for you, somehow? It's really not my job to teach you what OSS, or why its important. So I'm washing my hands of this before it becomes more fucking stupid than it already is.
&gt; Amazing how people can say so little with so many words. I think you're completely missing the point here. He could have a career in politics. If only he can get enough gold in /r/politics/ first, of course.
It's pathetic, what you're trying to do. It really, honestly and truly is. You can go back and see exactly what I said, and anyone who can read can plainly see that's not at all what I said or was implying. I've been a hiring project manager for almost 20 years, who works almost exclusively with FOSS. When I hire a developer I look for preexisting works that serve as evidence that they can contribute positively to a development project which sees a lot of traffic. Github stars are a way to express interest in a project. Stars aren't meant to imply the quality of a project, but you can bet that the most quality projects have the most stars. It's like seeing an applicant who graduated with honors. I'm not going to sit there and say "big fucking deal, he graduated just like this other guy who didn't graduate with honors. They're basically the same!" A high occurrence of stars 99/100 indicates a project which is well received and indicates a project which that I should pay extra close attention to as a representation of their skills as developers. That's not some insane fucking idea. It's something that I've been using very effectively (and many, many, many others in my field) for a great number of years. Say what you want, but your developer CV __is__ your involvement in past projects. That's why 90% of the development jobs you apply for will specifically ask for your GitHub username...
Weird, since all of my more-than-a-dozen (ex-)employers up to thus far only asked me to show what I've actually built within time and budget constraints, instead of my GitHub username. Something I achieved along the way whilst being employed, and not through some petty open source side-projects with rough plannings and loose scopes. Also, you seem bitter. Everything alright over there?
Just curious, what's the benefit verses using JSON? Does it take less space?
&gt; since all of my more-than-a-dozen (ex-)employers up to thus far only asked me &gt; That's why __90%__ of the development jobs you apply for http://i.imgur.com/ot8tNk4.jpg Do you honestly believe that the 10 positions that you've applied for __literally__ encompass 90% of all development jobs that exist? Because if you don't, then I just can't possibly fathom why you would take the time to reply because I specifically included that 10% for leeway for a very real purpose... 
I agree. That's why I upvoted it. Very useful information in that article. But I can understand why people would downvote it with a title like that. The author implies putting emphasis on the importance on GitHub stars.
The other.
Why are you [asking the same question again](https://www.reddit.com/r/PHP/comments/5vwu0u/flat_php_or_framework/)? Did you not like the answers you got last time?
Seems someone didn't read one sentence about laravel before coming here. Such a shame. The creators went to great lengths to make an awesome documentation and intro
Take it as a [quite rough] measure of the overall project's usefulness. 
Why use a "prebuild" car? Why not to travel from East to West coast on foot?
The questions are good, I only collecting from several approaches
Good metaphore :) Which framework do you advise?
Plus 1 for freelancer.com I get all my clients from there, I am based in the UK and alot of my clients are from Germany / Italy
&gt; The raised funding will be spent on automatic fixes, documentation and translation: exactly in this order. What are automatic fixes and why does it need funds? I've never heard this term before
That might be for the same reason I downvoted it (and do so for any other similar articles): it has nothing to do with PHP. The fact that the case study project in question was targeting PHP is orthogonal to the actual topic of the article, which is completely language agnostic. This belongs in a more generic subreddit, where I would happily upvote it for being quality content. I just don't particularly like my special interest subs watered down.
We decide to start a project. I say come back when you have a Router, DB class, templating, form handling and a DI container. I come back in 5 minutes because I just installed Symfony and I have all that. You come back in a few weeks. I also have something with tons of documentation that I can hire thousands of developers that basically know my codebase before they even start. You're going to be onboarding them for weeks. My code is also fully tested, has every feature they will ever need and stress tested. Unless you really know what you are doing and have special use cases, you use a framework.
Boo. Where the hell would someone 'look up what "having a career" means in the English language.' He's not wrong. It's a line item on a resume. You're being petty. 
Just start over, you haven't done that much. ( I realize this is not what you want to hear)
Looks really cool. I was actually looking for "trello like email interfaces" yesterday, this looks kinda related.
huh?
* https://gtmetrix.com/ * http://yslow.org/ * https://developers.google.com/speed/pagespeed/ * http://alternativeto.net/software/gtmetrix/ 
https://github.com/sensiolabs/security-checker
Thank you
No, usually serialize takes more space if you don't use igbinary. With json_decode(), you just get plain arrays or objects of stdClass. The benefit of using serialize/unserialize is that you can serialize complete objects including private members for example. You also don't loose the connection to the class. So if you serialize an object of class Foo, unserialize() also returns you an object of Foo. But you also have to keep one thing in mind: When you serialize an object of Foo and then delete the Foo-class, unserialize() will fail, because it can not create an object of a not existing class.
Dear Reddit community, thank you so much for your contributions into the campaign!!!
Shameless plug: I've been building out a mid-large sized API with Silex at work and I've discovered a few tricks that can really help with bigger projects. Check out my starter project for Silex and Doctrine ORM: https://github.com/pstephenson02/silex-doctrine-orm-starter
React Native, build a PHP API and connect the 2.
Wondering the same thing.
Which is the best?
I'd love to hear your reasons why you can't build a complete infrastructure with it. 
You've been submitting a lot of questions to /r/PHP You would probably have better results in one of the following: /r/PHPHelp /r/AskProgramming
&gt; Rather than blacklisting refresh tokens, could you not just blacklist access tokens? Why maintain a long-term blacklist of expired short-term access tokens? ---- Also, these are basically required reading for anyone working with JWT: * http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/ * http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/
I didn't say "can't" I said "difficult" and it's actually is. There's a lot of points where Docker puts barriers and make things much more difficult, but I will not discuss them right now; it's just a tool, with pros and cons, and I trust lots of admin sys that tried and failed (and they are numbers!). There are succesful stories, and some that are not, there's nothing trivial with building an infrastructure, no matter the tool you use, they all have constraints, and Docker isn't an exception. It's just a container system, like many others (and yes, please come back on earth, it's not the only one).
interesting, I didnt know that. thanks!
Ah, I'm on the opposite. I love the ORM. I've started posting on their forum to try boost the community and new people. I hope they do well with Phalcon3 and PHP7 support, hopefully a boost in regular releases and community.
I hear over and over from users of Silex that they inevitably bolt on so many features, in retrospect they might as well have used Symfony framework in the first place. I think Silex is a good demonstration of how one can use the Symfony components to build a framework, but maybe you should heed the advice of those people. It seems to be repeated a lot.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Latitude looks great thanks!
In general, use MySQL or whatever your database layer is for as much as you can. That software exists for a reason - utilize it for heavy lifting. Avoid doing any querying in a loop, as you'll likely take a performance hit due to the [N+1 problem](https://secure.phabricator.com/book/phabcontrib/article/n_plus_one/).
Suggest posting to /r/Laravel in the future, since this is specific to Laravel.
I doubt those companies are going to give a shit about the number of stars you have on GitHub. They probably care more about technical ability and previous workplace performance. 
Because you can't revoke an access token. When they ask for a new one using a refresh token you just decline it. This way you don't have to recheck the authentication on every single request, just whenever they ask for a new access token.
Stockholm Syndrome 
I just want to remind you, that Andrews expose didn't even concern the dates when I was approved for FIG. When I got it the project had around 400 stars on github and only a few daily installs. So nobody claimed there was anything wrong about it at the time. It's this reddit spial that made things waaaay more dramatic and out of any kind of proportion.
OSS - Open Source Software Finding projects on GitHub is a good start, fork them and issue pull requests to improve the project would be my best suggestion.
HOW ARE YOU SUPPOSED TO KNOW WHAT'S GOING ON WITHOUT A DOLLAR SIGN????
Non-Indian blogspam.
Yea I wasn't trying to link the two events(sockpuppets/installs/stars and fig membership.) I was hoping that the "And then the" would indicate that they were separate things. FIG had several sources of drama around that time IIRC.
&gt; I doubt those companies are going to give a shit about the number of stars you have on GitHub. I do. Specifically to find high quality content to gauge the applicant on your second sentence. People are knee-jerking to what I said, and their first impression is me saying "Stars are going to get you a job" when I said more "potential employers are going to look for high stared projects that you have to assess your skills as a developer." Which is entirely true. I do it myself. So do most of my acquaintances that I've met over the past 6-8 years (since Github became popular/released). Why do __I__ need to work hard to find good examples of your technical prowess? Instead I just outsource that to other developers who star your project to indicate the ones I should be looking at. It's not that crazy of an idea and I'm actually blown away that so many people think it is. But it's something I'm going to continue to do because it's done me very well for almost a decade.
####ＦＵＬＬＷＩＤＴＨ
Glad to see someone copying the [Aura.SqlQuery](https://github.com/auraphp/Aura.SqlQuery) approach and following its lead. Given this, though: &lt;https://github.com/shadowhand/latitude#aurasqlquery&gt; -- was it really easier to write an entire new system, than to submit a PR for the things you wanted patched? (E.g., a pull request for point 2 was recently received and accepted.)
I stumbled across these articles when researching about SPA authentication with a REST API. Does this mean I shouldn't use JWT afterall and make my API stateful with sessions? That just seemed counter to everything else I read so I ignored it for now.
I prefer the separation of statements for conditions, which is fundamentally different than Aura.SqlQuery. 
Forgot to say thanks!
&gt;Also, is your implementation of JWT really not stateful? Really? How are you making that work? Well, what I meant is that JWT switches the session state from server to client so that I don't have to break with one of the formal REST constraints by making my API stateful. &gt;... do you have an answer for this, or have you decided it doesn't matter? I don't have an answer and I think he makes valid points, hence why I'm posting here. I'm kinda asking if he really advocates breaking that REST constraint or if I misunderstand something entirely.
&gt; You realise that people use bots to get loads of stars on projects right? I fail to see how this somehow breaks the process? I use the stars to sort projects so I'm not looking through obscure projects with no meaning or thought behind them. Even if they use bots I'm still evaluating them as developers--so if they're no good it doesn't affect me in the slightest. I don't think you understand what I've been saying and I can't quite understand how that can be... It's like me evaluating someone as a person based on their Reddit post history and using their all-time up-voted posts to help me do that. Even if those posts are embellished I can still read. I'm just using up-votes to sort the posts... You people are seriously making this into something crazy complicated when it's....not.
Wait you're saying make the api state full and use sessions? Why in the world would you do that on purpose?
&gt; Because you can't revoke an access token. Why not? This is basically what I don't get about the process. A refresh token with long expiration grants you the ability to create many short term auth tokens. Until I blacklist the refresh token (or it expires on its own) that user has the ability create new access tokens. Why could you not just have a single token that acts as both the means to rewnew itself and access the resource. Should you need to prevent that device from requesting a renewal it would be blacklisted just like the refresh token. In either case I have a token with a signed expiration that allows me to skip rechecking authentication and I can blacklist either the token from preventing renewals. The only advantage I see is that if I'm worried about traffic (which I'm not for a few hundred users) a separate auth server could be used to offload the process of renewals.
&gt; They're short lived because if intercepted their short lifespan limits damage inherently, as a property of its expiration. I don't understand how a refresh token couldnt be intercepted as well. If someone can theoretically get one, they can get the other, no? &gt; The refresh token provides for a level of convenience so that a user need not go through the authentication process all over again if they have a still-valid refresh token. But why couldnt you have the access token be used for `/renew_token` if you didn't care about separation of concerns? To me, its the same concern: replacement for a traditional session. And I don't see how the refresh couldnt be stolen in same manner as the access could be.
Because it's considerably less complex, and you can revoke sessions. And really, an "API" for an SPA isn't an API in the traditional sense. "Statelessness" isn't a desirable property for stuff like this, no matter how much hype there is around it. It essentially translates to "distributed systems", and distributed systems are *really hard* to get right (and really easy to make them *seem* right when they're really not). Generally, you want to absolutely avoid distributed or stateless systems unless you have no other choice from a technical perspective. (The same applies to "horizontal scaling" and "microservices" - these aren't actually desirable things unless you literally *can't* scale vertically anymore, for all the same reasons. More about the issues with microservices can be found [here](https://blog.komand.com/microservices-please-dont).)
I also found those articles /u/sarciszewski posted, but then found other discussions about them https://news.ycombinator.com/item?id=11895440 https://news.ycombinator.com/item?id=11929267 And it left me back and square one where I'm not sure who to believe :) The company auth0 is based on JWTs... I dunno. This whole refresh tokens and separate auth server made me rethink if its really worth the effort
Well, what's the alternative? A truly stateless JWT implementation works extremely poorly, for all the obvious reasons. If it's not stateless then you may as well just go for sessions. &gt; Why in the world would you do that on purpose? Probably because there's no viable alternative? Don't forget, this entire discussion is taking place in the context of a debate on when to check a token against your blacklist; that blacklist represents external, centralized state.
&gt; I don't have to break with one of the formal REST constraints by making my API stateful. 1. REST is not a religion; if you can't adhere to REST *and* have a good authentication story, you should sacrifice being 100% RESTful. 2. REST prohibits session data on the server, but does not prohibit authentication. A standard session cookie that's just used for authentication is fine and RESTful in my view ([and the views of many](http://stackoverflow.com/questions/6068113/do-sessions-really-violate-restfulness)), and you're free to use a JWT for the actual non-auth session state. 3. JWTs violate those constraints when used for authentication in a practical manner (eg, revocation blacklists, refresh tokens, etc.) &gt; I'm kinda asking if he really advocates breaking that REST constraint He's advocating for not using JWTs for sessions, yes. Depending on who you ask that either does not break any REST constraints, or is a reasonable compromise. (I take the former view, personally.) (Note that the [section talking about cookies](http://www.ics.uci.edu/~fielding/pubs/dissertation/evaluation.htm#sec_6_3_4_2) in Fielding's dissertation is written in a very sweeping style, but the example given are all talking about retrieving application state based on the cookie, and make no sense if interpreted to be talking about all cookies. In his words, "[t]he same functionality should have been accomplished via anonymous authentication and true client-side state." Sure, so put the state in your JWT, and accomplish authentication via a cookie, or failing that, basic auth. Both are RESTful, and avoid the pain of trying to use JWTs for that purpose.)
Yes, but at this point, why not just use plain vanilla session auth? How is what you're describing functionally different/better?
Can you program in other languages? Review the default themes that come with WordPress. These are a good place to start. You probably won't have too much trouble if you have a good basic understanding of programming languages. If you don't, you can fake it until you make it by copying existing themes. You'll most likely have difficulty with custom functions if that's the case, but the basic structures and styles aren't beyond anyone willing to put some hours into learning it. 
I don't have a dollar sign on my keyboard :( I have this £, I have to copy and paste the dollar sign when I want to use a variable.
Don't skip anything? Php is the fundamental core of Wordpress, it's how you work with it. You can use the languages entire feature set and then some in Wordpress plugins. It's not worth "skipping" anything, and only empowers you further to take on anything as you go. Not to say you need to college course to do so, but knowing what problem to solve, and being open minded to the solutions will get you very far. 
To create themes only you have to know variables, cycles and [htmlspecialchars()](http://php.net/manual/en/function.htmlspecialchars.php). Also you have to know WP methods to do things required to create themes. But you must know html, js and css. And that is not a simple task.
Thank you for a good point /u/SaltTM , I'm working on it.
Nice design
I feel like Laravel becomes a way to make money off programmers. 
"Using JWT purely as an identifier in a stateless api is ideal and not too difficult." I sincerely don't understand how that works. Wouldn't the identifier be just a link to data or state? Wouldn't you need some way to revoke the auth meaning at the very least need enough state to know the "state" of the auth? Edit: really??? Down votes for a sincere question? Come on guys if we can't ask each other questions how can I learn?
Really? What sort of weird keyboard is that??
I've used Silex for some years and then I switched to Symfony Framework eventually. I still love Silex but I think the DI+Config component in SF makes all the difference. The Service Providers in Silex are nice but they usually contain way more code than some yml files while not being able to do as much as the corresponding Bundle in SF. Also it is easier to structure SF apps even though I created a very similar structure in Silex. If you are very new to frameworks in general Silex might be a good start to get familiar with the various components that are used in many frameworks and move to SF later on (just like I did). If you have some more experience I would recommend SF straight away.
Good job! But I think we have very different impressions of minimalistic. :D
&gt; What are the obvious reasons? They've been brought up repeatedly in this thread, including in the links posted by /u/sarciszewski in one of the direct ancestors of your comment. I would direct your attention, in particular, at the [second] (http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/) of his links. But, very briefly: The promise of JWT is pushing state from a centralised server to the client to allow for better scalability, partition tolerance, higher performance, etc., etc. Which is great, but then you cannot forcibly expire or invalidate a token. :) (Yes, having a centralised token blacklist lets you easily invalidate tokens. But then you've got a bunch of state living on your central server. Which is actually not that bad, but if you don't mind making every API call dependent on accessing a centralised consistent data store, then uh...why did you want JWT?)
Phalcon
/u/SaltTM first changes (working on expertise and background chapters) has been published: https://www.indiegogo.com/projects/php-inspections-ea-extended-a-code-analyzer-security/x/16148880#/ I updated 'Short Summary' and 'What We Need &amp; What You Get' chapters to give more transparency for people who are not in the plugin community or joined recently. Does it look better?
Im just using my own phpstorm license in work. You can do it if you don't know yet.
Ah I didn't know about PHPPixie, I don't follow the reddit that closely and tend to skip past anything framework related 
Laravel services like these help you make more money by giving you the tools you need to quickly &amp; efficiently help your own customers. Laravel Shift is completely separate from Laravel &amp; Taylor; it is something Jason McCreary saw as a way to provide a time- &amp; money- efficient service to people for whom that is important. I do something similar with http://mahana-designs.com - I'm sure all of you can create your own API, but I offer to have it working for the front-end team with less time &amp; resources than an in-house IT team would be able to put together while also dealing with all their other weekly tasks. It is nothing more that DRY scaled up, but it needs to be supported and that costs money - my kids can't eat "passion for programming".
&gt; with a **nice** content editor I would get my throat slit by my customers, if I gave them something as *nice* as [this editor](http://imgur.com/a/DLMfB) :/
It's not like I'm fond of that trend either, but my hands are tied. I'm just trying to make the best decision on the implementation. If sacrificing a stateless API is preferable I go with that.
Having a detailed enough plan is the way to go. The act of software development is more than often a long and tedious process, months if not years. As a developer, having a clear and consistent idea of the features the software has will allow you architect and design the software you're trying to build. No feature stands alone. It's all interconnected. Having said that, that doesn't mean you can't make changes. But if you have a plan or design with a good enough level of detail then you can hold those changes up to that design and see what impact that has on scope and based on that decide whether or not to make the change. Nothing worse than some client or product guy rocking up every other week saying; Hey guys, I had a great idea on the weekend! Now lets all run this way! If you allow for that you will have never ending scope creep and certain fail. That agile manifesto you point out? It's "feel good" marketing bullshit. 
Thanks! :)
Generally speaking, I would not prefer a product by the design you've chosen. Mostly because of refactoring issues, but also due to the fact that nothing seems to be enforced or guaranteed. There are some design mistakes here and there but overall it looks decent enough. A good example is; You're running 1+n queries for every post you display on the index page, instead of a single query. You should have a repository class which manages retrieval of posts for you, and in turn should be able to retrieve post's in a single procedure, instead of 11 queries (which is your default value). This will also make it easier for you to refactor your schema in the future. https://github.com/Nerdmind/Blog/blob/master/index.php#L11-L18 You generally do a good documentation basis but i however tend to favor real docblocks instead of custom ones. This is to maintain readability across projects and also make it easier for other developers that may contribute to your project. This will also enable IDE support.
This is a very interresting article.
There are some really good points here which if not properly explained can result to issues. &gt; The way the author is splitting the InterviewManager class is perfectly valid, but what we never learn is why he had three separate concerns with this class. Because developers constantly breach SRP with Manager classes, it's not how I added three separate concerns, it's how I spot that there are three separate concerns in a class during code review. &gt; As an API user, I have one concern: working with interviews, so the separation there is not needed. The original class, in fact, would make a perfectly good facade for whatever separation you decide to do internally. Splitting an API class in three only makes features harder to discover and your API more difficult to learn and use. Here you point out that as a facade for an API it would be a good design. However, I have a couple of issues with this: 1. A facade, for the most part, shouldn't leak out the validation method, in doing so it's not properly encapsulating the logic of the API/SDK within the facade. Again the same could be said about the automatic scheduling. 2. An API is pretty much an application in itself, therefore, has to be reviewed differently. Instead of worrying about having too many things grouped it's more about the extendability of the methods and how stable the UI is. How decoupled things are and overall flexibility. It's a massive post all in itself. &gt; So, nice article, but just like big classes that slap together unrelated concepts are bad, tiny classes that split a single concept (from the PoV of the user) are bad. This touches on an aspect of SRP I avoided mentioning on purpose - I wanted to keep the post reasonably small and not a massive wall of text - all things that change for the same reason grouped should be grouped together. However, in the Manager class, we clearly have three different things that would change and would not involve the others changing. If the people using your API are in-house developers then it's not really an API it's internal code and shouldn't be treated as an API. I think the differences of how to code review an API and how to code internal code is something that should be explained further. As well as the spotting when a responsibility has been too finely separated.
If he would really appreciate this input, he could read it here, right? :-)
looking good, wish you guys luck :)
The fact that getRouteCollection forces a cache reload also bit me. The name would not indicate it works that way.
A few things that just pop up in my head: - **NEVER** trust ANY input coming from the outside, always validate, check, revalidate - treat ANY input coming from outside as a potential attack - make sure input is the type you expect, i.e. integers should be actual numbers (PHPs loose typing can cause a lot security issues) - always properly escape any input you use for performing further actions (like filesystem access, text tp be output to the user again, SQL queries and the likes) - use prepared statements for your SQL queries Last but not least, take a few good reads here: https://www.owasp.org/
Great progress by the peachpie team. It will be interesting to see whether this software catches on with JIT tentatively coming to PHP 8.0 ( At least I think I read that on here) though it will certainly be handy for porting your php application to .NET if you ever have to do that. 
what do you mean with prepared statements for sql queries ?
allright seems clear to me thanks for the help bud.
&gt; I'm sorry I didn't realise you or anyone else was disputing it. Since you wrote, "The way the author is splitting the InterviewManager class is perfectly valid". Therefore I thought this was an agreed upon point. The way you've split the class is perfectly valid, yes. There are infinite number of valid ways to split a class. But what I also clearly said is that there's no reason given why this particular split was chosen, and so the bottom line is we have extra complexity and no extra value to show for it. &gt; I was trying to explain how you can't code review an API the same way you would internal code. Since should be considered an entire standalone application. Which is why if you're creating a class/sdk you would create larger classes which did multiple things. However, when you're dealing with internal code, you're going to want to replace stuff, change feature sets without having to touch other features and decouple correctly. Yes, but this is honestly not supported by anything. You're talking about a balance between flexibility/configurability and simplicity. Maybe your external API users need flexibility/configurability. Or maybe your internal API users, your colleagues, want just a simple object that Just Works ^TM without having to become intimately familiar with your implementation. You can't simply declare that if it's internal people want flexibility, and if it's external they don't. It's just another massive assumption that comes out of nowhere. The most important principle of engineering is "it depends". It depends on who needs what. Without knowing this contextual information, generalizing with broad strokes leads people to creating poor products based on **guessing** rather than **facts**. &gt; &gt; Either there's a lot of backstory to this class and the way it was split, which backstory isn't in the article, or it's simply splitting things because of fuzzy feelings, which is not a good reason. &gt; Not really, this is an example of multiple classes I've seen in multiple projects. These projects would, for the most part, be considered poorly developed applications, high error rates, slow performance and high amount of technically debt. Having 12 cohesive methods in one class vs. 4 methods in each of 3 classes wouldn't lead to "high error rates", "slow performance" and "technical debt". I understand that this is how you feel about it, but there isn't anything tangible in what you're telling us that supports those feelings. Your before/after doesn't demonstrate any performance improvements, reduction of technical debt, or less errors. It's just conjecture. &gt; This is about correctly identifying what should be grouped together and what shouldn't be, it's more about avoiding domain god classes which are constantly needing to be worked on because every time you do something then something within the god class needs to be changed. Or your entire domain becomes coupled to this manager class. God classes can be problematic in many places of the app, but my point is you've not demonstrated why InterviewManager would be a "god class". Mechanically counting methods, or separating validation, storage and scheduling doesn't demonstrate any improvement, it's just another way to factor things. Without context it's neither better nor worse. Regarding coupling, if the entities that will be creating/deleting interviews are likely also to also schedule them (and honestly if you think about it, that kind of is likely), then everything that was coupled to the Manager, will now be coupled to both the Storage and Scheduler. How is this an improvement is a complete mystery to me. If you ask me, what would be an improvement is not splitting the class in three, but removing all actions which are not related to use cases. For example why should I be able to "create an interview" that's *not scheduled*, then have to separately schedule it as a separate step? This is not typical for any kind of interview schedule workflow I've seen. So I'd directly create the interview in the schedule action. And unscheduling it would also delete the interview. That's better. Internally you can have a repository, but this becomes now an implementation detail, which it obviously isn't in either you "before" or "after". **EDIT:** Here's my factoring. I've also simplified method names as appropriate: class InterviewManager { function schedule(Person $person = null): Interview {} function unschedule(Interview $interview) {} function postpone(Interview[] $interviewList) {} function findAllForPerson(Person $person): Interview[] {} } I have to walk in the dark a little, as the "automaticallyAssignInterview" method wasn't explained well, and the name makes no sense to me, but it's reportedly scheduling an interview not assigned to a person, so that would be simply making "$person" optional in "schedule". All things equal, I see no reason to have "postpone for person" action, when I can have a generic "postpone ($interviews)" and we already have "findAllForPerson", so I eliminated that method. Of course, it's very vague what "postpone" means with specifying for how long to postpone and so on, but that's the trouble with poorly explained context in example scenarios. Say, I also could see use cases for more methods like "findAllInTimeRange($from, $to)" but I lack context, so I can't guess. So, now that we removed the noise, does it still look like a God class to you? I doubt that.
As it may not be totally clear from the article, this is an issue that affects *shared hosting*, if opcache is used and if different sites are served from the same master process. It does not affect non-shared hosting and it does not affect environments that serve different sites from different processes. Of course, PHP does not recommend deploying in this manner, which is why these the new options are disabled by default. They carry additional overhead and unless you are in this specific situation (i.e., you are a shared hosting provider that uses this particular setup) you should not enable them.
Nice work! Getting WordPress to run is a really big milestone. Do you already have any preliminary performance numbers for WP? Application performance is often very different from micro-benchmarks, so it would be interesting to see how Peachpie performs here.
Follow up question: Was Wordpress chosen for the benchmark bexause of popularity or because it's codebase is based on an older version of PHP (5.2 I believe)
Thanks! We will benchmark wp in some upcoming article, from development experience it is somewhat comparable to PHP7 now. Still we would like to not target the performance while Peachpie is in version 0.5.0-preview and serious optimizations will be implemented in future.
Questions like this were *precisely* the reason we created our Quick Answers page. https://paragonie.com/quick-answers
&gt; So, now that we removed the noise, does it still look like a God class to you? I doubt that. That's because it's only got one responsibility, scheduling. The saving responsibility isn't within the contract nor is validation. Simply put we've seemed to have put a lot of effort into proving you agree with me. You would just design the scheduler class differently. Edit: While also going into things that are clearly not within the scope of the blog post. Such as naming, implementation details - data storage is always an implementation detail.
Only if one of the tracked resources has changed and only in dev... Unless you alter that ofc. In prod it will only do that if no cache is present, which should already be done during your deployment anyway.
Don't really have the funds to back you up due to my financial situation, but spreading the word! This plugin deserves it!
&gt; That's because it's only got one responsibility, scheduling. The saving responsibility isn't within the contract nor is validation. I removed validation, because **you** said in an earlier comment that exposing it is "breaking encapsulation". Regarding the saving "responsibility", look closer: `schedule()` takes a person and returns a new interview. That's persisted in the schedule, so it's not as if you have to go elsewhere to "save" your interview. I removed the create/delete methods, because it was pointless to have them in the first place, as I said. &gt; Simply put we've seemed to have put a lot of effort into proving you agree with me. You would just design the scheduler class differently. You're missing the larger point: my factoring keeps the original number of classes... **one**. Also, the effort on my side is to understand the assumptions you've made in the process of writing your post, and the resulting reasoning to come out of them. But instead, honestly what I see is that the supposed project is a constantly moving target, whose goals keep changing in every comment you make, at least from my PoV. For example: should validation be exposed or not, in the end? You've said both, so... &gt; Edit: While also going into things that are clearly not within the scope of the blog post. Such as naming, implementation details I didn't want to touch naming, but naming is important in order to understand what the method does. So if I'll be removing/adding/splitting/merging methods, I have to use clear, short names that communicate their meaning. I don't think you've managed to clearly communicate meaning in your methods. I.e. I already mentioned that it's unclear why scheduling an interview is split into two steps: `create` and `schedule`. But also what's unclear is the method signature of the `create` method: public function createInterview(Interview $interview) {} So the create function *takes an interview as an input*, and it's not specified if it *returns anything*. What does it actually "create" if the interview supposedly already exists, so it can be passed as an object? Quite puzzling, and bad naming is a big part of the problem.
Be cautious with "trying to publish 1 composer library every week". You'll have to maintain all of them and don't try to invent the wheel over an over. It's useless to have 10 libraries that do the same but half of them no longer maintained. Besides of that, good luck!
Try tools like new relic and backfire.io to measure performance and find bottlenecks.
No need for /s - this is a "problem".
Ah this makes more sense then. My red alert alarm can be turned off. TLDR; DO NOT USE SHARED HOSTING
&gt; One of the issues with this is that it’s checking to see if the value is null; however, in weakly-typed languages, it’s possible for the return value to be a range of values, which aren’t null, but not the correct value we’re wanting. This occurs, especially in PHP, where developers have a habit of returning false in error cases. OP should work on explaining their point clearly, as this paragraph crashed and burned, and it's not the only one :P Also some of the code examples demonstrate branching conditions that are unnecessarily verbose: // Is: if (is_numeric($people) == false) // Should be: if (!is_numeric($people)) // Is: if (($logger instanceof Logger) == false) // Should be: if (!$logger instanceof Logger) Lastly, there's a difference between debug assertions, and data validation, which I don't think is clearly described in the article. Both typically check data, however: - Assertions are there purely to catch bugs, and can be disabled on production, as assertions aren't false on stable code. Best way to do assertions is through `assert()` as it can be eliminated from code via an INI setting. - Validation should run all the time, and it's expected to fail from time to time in stable code, as it receives invalid input, which is directly or indirectly derived from external untrusted sources.
 function doesSomething($user_id) { $user = $this-&gt;getUser($user_id); // returns User|false if (is_null($user)) { // checked for null...rather than false throw Exception("User not found"); } // do something } The above code example is what I believe the author is getting at. My take a way was that you should verify the User is an instance of User rather than checking one of the infinite set of invalid values.
Technically the only valid "no result" value is `null`, which is further encouraged by the PHP 7.2 "nullable" syntax. The fact some built-in APIs return `Something|false`, is just unfortunate legacy, which shouldn't be emulated or tolerated in userland. The correct approach is to see and know what the API returns and make sure you checks are valid in that context. If the advice is to defensively expect a bunch of different of different failure values and make your code pointlessly specific for *that reason alone*... I don't think that's a good idea. Know the API contract and then follow it. In the above example you're citing, most of my code would use this check: if (!$user) { throw Exception("User not found"); } Not because it works with both null and false, but simply because it's short and clear enough, there's no need to get more verbose, unless `getUser()` has a very awkward combination of return types.
The information in this "article" is obsolete at best.
&gt; This is a blog about treating the symptom and not the disease. Yea it's defensive programming, it's to minimise the risks. &gt; The solution is to fix the low quality code and avoid using sloppily written 3rd party libraries. Sadly it's not always third party libraries, also sometimes you don't have a choice. The way I would choose is to have proper test coverage that results in code breaking if a method returns an incorrect data type. However, the fact the code is fragile still remains.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
By definition, that function returns 'User|false' I should be able to safely check for ($user === false) or (!$user) without issue. If the function returns anything other than 'User|false' then that is a bug in the function and should be corrected.
I'm having trouble understanding your question. &gt; harder to mock [...] (too much access) vs just a Repo Normally I'd have my application define its *own* interfaces for repositories, and then inject implementations of those self-defined interfaces that just happen to use Doctrine. (Then when unit testing, supply different ones.) &gt; pass around the EM all the time to methods changing persisting Entities. Then don't: All the stuff you do builds up a set of changes to be committed in a transaction at some single point, rather than constantly making lots of tiny saves. **Edit:**: So you talked about an `AccountManagement` service, here's a quick sketch: public class AccountManagement{ public function __construct(AccountRepository $acctRepo){...} public function doStuff() {...} } public interface AccountRepository{ public function getById($accountId); public function save(Account $account); } public class SomeOrmAccountRepository implements AccountRepository { // Could also be private and use a static "named constructor" public function __construct($someOrmThings){...} public function getById($accountId){...} public function save(Account $account){...} } // Assuming $someOrmThings might be entity managers or whatever. $accountRepo = new SomeOrmAccountRepository($someOrmThings); $am = new AccountManagement($accountRepo); $am-&gt;doStuff();
&gt; OP should work on explaining their point clearly, as this paragraph crashed and burned, and it's not the only one :P Thanks for the feedback I'll work on that. &gt; Lastly, there's a difference between debug assertions, and data validation, which I don't think is clearly described in the article. Both typically check data, however: And then there is a difference between debug assertions, data validation and sanity checks. This blog post was in reference to sanity checks. &gt; Assertions are there purely to catch bugs, and can be disabled on production, as assertions aren't false on stable code. Best way to do assertions is through assert() as it can be eliminated from code via an INI setting. Sorry but you're wrong. The best way to do assertions is in an unit test suite. Doing assert within production code.
&gt; Can you give an example of where you would not have a choice? The company has spent half million on moving to an e-commerce platform. &gt; If there is a bug in your code, you should fix the bug rather than validate around it. In theory, there are two bugs, one where you failed to check sanity correctly and the one where someone changed BC. But changing BC isn't a bug in itself, it just causes bugs. &gt; In any case you should re-evaluate the quality and reliability of that library to determine if you should even be using it in the first place. Sadly I've learnt this sort of defensive programming is required even on internal products. When you have a team of 50 or so developers knowing what everyone is doing and what everyone has done is near impossible. Especially when code coverage is low, these bugs make it to production and then you're spending time bug fixing instead of features. Everytime I've seen these bugs fixed, it's in fixing the sanity check because the sanity check was wrong. The sanity check said everything will work if this check is ok, the check was invalid so. That's the bug.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
W3schools is a terrible website, especially for security. /u/memethug69 here's a good in-depth tutorial that uses PDO: https://phpdelusions.net/pdo Section 4 covers what you're asking about. 
&gt; I'm not "wrong", unit tests are entirely complementary to inline assertions: http://wiki.c2.com/?DesignByContractAssertionsVsUnitTestsVsTypes tl;dr Both are useful. Inline assertions are a symptom of poor code design and bad development practices. Putting debug code into production, sorry but no.
I believe this is a wrong take on defensive programming. Using proper exceptions can fix most of the problems. To prevent checking for all possible return values, simply force a return type. If the user is found, return a User object. Throw a UserNotFound exception otherwise. Catch the User not found exception, and deal with it if possible. Let it bubble up otherwise (in case of a database error, etc). If you try to return any other object type, PHP will slap you with a type error. You will have way fewer useless tests that way. 
I wonder if this isn't a really good move at a really good time. Laravel is becoming more API-friendly with every release, and Lumen offers only "okay" speed gains. I feel like it's only extra workload for the maintainers, without enough gain to warrant so much effort. Plus, I asked around and failed to find a single person who deployed it in production - they all said they had to "laravelize" it a little even in development, else it was too featureless for them. I wonder if /u/utotwel can shed some light on Lumen's future, and possible plans to make it LTS at 5.5, too?
Whats your comment related to? Certainly not agile nor lean... 
Excellent post ! Very useful php tools !
What he said. Ideally, you would stablish a single boundary for external dependencies within your code, defined by interfaces which are easily mocked. Your code would then depend upon those interfaces and be internally consistent. The boundary would be the implementation itself of the interface using these external dependencies. Repositories are an example of such a concept. 
Well, I was "hit" by getRouteCollection problem as well, back in, 2.4/2.5 era I guess. Maybe something changed in recent versions? I had opcache enabled with `opcache.validate_timestamps` etc and it was still parsing all these yamls ;) Luckly it led me to rewrite that part of the code to use ParamConverters and it is working like a charm.
You should specify that you're encoding *integers*. I recently wrote a crockford32 encoder but for *binary*. The algorithm is quite different. Also, you should `array_flip` your ALPHABET and cache it to speed up those `decodeCharacter` calls -- I'm pretty sure that's an `O(n)` operation that you're doing repeatedly. (Where `n` here is only 36, but still)
The part the irks me is that it sounds like he's creating a tool similar to [jscodeshift](https://github.com/facebook/jscodeshift) but for PHP and instead of sharing it with the community, he's kept it to himself as a way to make money off Laravel developers. I don't mind so much if he sells the specific Laravel-shifts, but I feel like he should open-source the underlying tool he's using to make these shifts, particularly if I took the idea from another open-source tool, and is using NikiC's parser under the hood.
You don't revoke the auth. You let it expire and don't renew it if they lost permission. I thought that was the entire point of short-lived tokens?
I always recommend this laracasts.com videos to learn the basics: [The PHP Practitioner ](https://laracasts.com/series/php-for-beginners), the beginner lessons are free and will teach you good practices from the beginning The change from PHP5 to PHP7 will not make much difference when it comes to learn just the basics, so you will be fine, and there is also a laracasts tutorial on the subject [PHP 7 Up and Running ](https://laracasts.com/series/php7-up-and-running) edit:typos
&gt; To exploit the vulnerability, attackers would have to create a feature found in the PHP programming language known as the $container_ids string. I appreciate that they're trying to cover computer code issues in more detail, rather than as a black box, but what is this sentence even.
Ouch. Can't you remap a key?
I highly advise learning all your PHP with PHP7 as it is the current release of the language. That being said, be familiar with what changes from 5.x to 7 in case you end up employed working with PHP. There's a lot of legacy code out there and not a lot of clear paths to PHP 7.
mbstring and curl.
The names are very relevant. The information in that article is not. The link for Symfony, for example, leads to the v1.2 docs.
Oh hai 24. Yes, I was able to infer from the text that this was a GET or POST variable. I think my bemusement with the sentence was firstly with the erroneous information about PHP, and secondly that it was written with such earnest incomprehension that the resultant use of English teetered on the brink of incoherence. "Create a feature found" struck me as an especially precarious construction. (*I admit that I was not being very nice and I hereby apologize to Dan Goodin, whom I'm sure was trying is best and who will do better in the future.*)
Any recommendation on library to do IMAP? Basically: listing emails, reading emails, "archiving" emails Would you use http://php.net/manual/en/book.imap.php? Or perhaps cURL imaps://?
[removed]
Stay away from any and all guides, tutorials, books, forum threads, FAQs, Q&amp;As, tips, lessons, recipes, blogs, vlogs, flogs, reflogs, tweets, messages from deities, whispers in the shadows, epiphanies, and backs of cereal boxes that were written about PHP before 2012.
I'm primarily a JS dev and so I have strong opinions on Crockford and know well his annoying history of terseness. I'm not certain that this is an issue in your implementation, but I know that c-32 implementors often ask for advice on handling negatives -- and it is worth mentioning that some users may also need to encode negative-float-zero. I know for sure he's been asked on this in the past, so if that's all he wrote, then you just got crocked. He has a history of etching his specs in stone and then pissily dismissing people when they have questions or complaints. For example, years of JSLint inflexibility lead to inarguably better forks and his original JSON deliberately had no version number because Crockford thought it could not possibly need one -- because it could not possibly be imperfect. I don't mean to completely disparage him -- his contributions to JS are undeniable -- but, come on Doug, throw us a fricking bone here.
Hey, I work for an ecommerce company that uses Magento and is currently interviewing for a junior. Maybe I can give useful answers. It sounds like you have the basics. As long as you can understand basic code structures and organization, and have at least SOME knowledge of oop, you should be good. Be able to do a fizzbuzz and demonstrate that you can at least stumble through somebody else's code. But what we're really looking for are soft skills. How do you do with people? How do you handle a problem that you can't solve yourself? At what point do you ask for help? What do you do if you disagree with a manager's decision? What's your willingness to learn new skills? How's your organization? Time management? Stress management? Sense of humor? How well do you jive with the rest of the team? How do you balance work and life? The idea behind hiring a junior is that you can get a dev who has the basics down, that you can train to program the 'right' way, whatever that means to your company. Code can be taught. Culture fit can't. Demonstrate that you're a killer dude who will play well with the team, and show them that you have the basics down. Find some code you're proud of and show them that. It doesn't have to be spectacular, but should show what you know. They're looking for somebody willing to put the effort into learning. Show them you're not afraid to admit what you don't know, and that you're willing and able to learn. Edit: it's also worth mentioning again. Demonstrate an eagerness to learn. Storytime. Last year we were interviewing for a mid level position. We had a few promising candidates. The way we do our interviews is that we do 30 minutes or so, then take a 10 minute break to discuss, then we come back and finish the interview. Well, during the first part, we asked a question that he didn't know the answer to. He admitted such and we moved on. After we came back from the break, he told us that he looked it up, and gave us the answer we were looking for, and was able to answer more questions about the same subject. During the break, he had looked it up and done research to fill a gap in his knowledge. We hired him over other candidates that had more skills. He's still with us and is a rocking dev now. That research he did during the break was what got him hired. If you don't know an answer, admit it and try to find out more. Don't try to bullshit your way through it. They'll smell bullshit a mile away. Bon chance ! J'espère que tout aller bien pour vous a demain. Yes, I creeped your profile ;)
Cool story, bro. But doesn't explain why don't you use placeholders for your data. Something [like we do it in PDO](https://phpdelusions.net/pdo#in) if ($tags &amp;&amp; is_array($tags) &amp;&amp; !in_array('all', array_map('strtolower', $tags))) { $container_ids = str_repeat('%s,', count($tags) - 1) . '%s'; } else { $tags = array(); } // Construct query $query = "SELECT {$wpdb-&gt;term_taxonomy}.term_id FROM {$wpdb-&gt;term_taxonomy} INNER JOIN {$wpdb-&gt;terms} ON {$wpdb-&gt;term_taxonomy}.term_id = {$wpdb-&gt;terms}.term_id WHERE {$wpdb-&gt;term_taxonomy}.term_id = {$wpdb-&gt;terms}.term_id AND {$wpdb-&gt;term_taxonomy}.taxonomy = %s"; if (!empty($container_ids)) { $query .= " AND ({$wpdb-&gt;terms}.slug IN ({$container_ids}) OR {$wpdb-&gt;terms}.name IN ({$container_ids}))"; } $query .= " ORDER BY {$wpdb-&gt;terms}.term_id"; $query = $wpdb-&gt;prepare($query, array_merge(['ngg_tag'], $tags,$tags)); See, here `$container_ids` contains only `%s` placeholders while actual values are sent into prepare just like it should be
I personally just manage my servers myself without Forge.
Your code is fucking terrible. Don't worry about it. Don't take it personal. When people bash your code, own it, learn from it, ask questions.
It does need some refactoring. I will work on it today, I might add some unit tests too. Thanks for the feedback 
Hear hear!
&gt; Using proper exceptions can fix most of the problems. To prevent checking for all possible return values, simply force a return type. If the user is found, return a User object. Throw a UserNotFound exception otherwise. Catch the User not found exception, and deal with it if possible. Let it bubble up otherwise (in case of a database error, etc). If you try to return any other object type, PHP will slap you with a type error. One of the things I said in the post is if you have strict types and are properly validating it this isn't necessary. Also, your method doesn't defend against bc changes that co-workers may make. So isn't really defensive programming, it's just better code design. 
Here's the relevant code. You can do it in a 1-liner via string manipulation of decbin too; can't remember where I put that code. I believe this is more efficient. const CROCKFORD32 = '0123456789abcdefghjkmnpqrstvwxyz'; private static function _regroupBits($buf, $nbits, $keep_left_over) { $mask = (1 &lt;&lt; $nbits) - 1; $nworkbits = 0; $workbuf = 0; $buflen = strlen($buf); $reslen = $buflen*8/$nbits; $reslen = $keep_left_over ? ceil($reslen) : floor($reslen); $result = array_fill(0, $reslen, 0); $b = 0; $r = 0; while(true) { while($nworkbits &lt; $nbits) { if($b &gt;= $buflen) break 2; $workbuf &lt;&lt;= 8; $workbuf |= ord($buf[$b++]); $nworkbits += 8; } $offset = $nworkbits - $nbits; $result[$r++] = ($workbuf &gt;&gt; $offset) &amp; $mask; $nworkbits -= $nbits; } if($nworkbits &amp;&amp; $keep_left_over) { $workbuf &lt;&lt;= $nbits - $nworkbits; $result[$r] = $workbuf &amp; $mask; } return $result; } private static function _crockford($str) { $bits = self::_regroupBits($str, 5, false); return implode('', array_map(function ($x) { return self::CROCKFORD32[$x]; }, $bits)); } I also wrote some algos for converting any base to any other base, including crockford32: /** * Converts a base 10 number to any other base. * * @param int $val Decimal number * @param int $base Base to convert to. If null, will use strlen($chars) as base. * @param string $chars Characters used in base, arranged lowest to highest. Must be at least $base characters long. * * @return string Number converted to specified base */ public static function decToAnyBase($val, $base, $chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') { if($base === null) $base = strlen($chars); $str = ''; do { $m = bcmod($val, $base); $str = $chars[$m] . $str; $val = bcdiv(bcsub($val, $m), $base); } while(bccomp($val, 0) &gt; 0); return $str; } /** * Convert a number from any base to base 10 * * @param string $str Number * @param int $base Base of number. If null, will use strlen($chars) as base. * @param string $chars Characters use in base, arranged lowest to highest. Must be at least $base characters long. * * @return int|string Number converted to base 10 */ public static function anyBaseToDec($str, $base, $chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') { if($base === null) $base = strlen($chars); $len = strlen($str); $val = 0; $arr = array_flip(str_split($chars)); for($i = 0; $i &lt; $len; ++$i) { $val = bcadd($val, bcmul($arr[$str[$i]], bcpow($base, $len - $i - 1))); } return $val; } /** * Converts from one base to another. * * @param string $num * @param int $fromBase * @param int $toBase * @param string $chars * @return string */ public static function changeBase($num, $fromBase, $toBase, $chars = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') { return self::decToAnyBase($fromBase != 10 ? self::anyBaseToDec($num, $fromBase, $chars) : $num, $toBase, $chars); } I haven't performance-tested these, but they shouldn't be too awful.
I invite you to further spread that education [at SitePoint](https://www.sitepoint.com/write-for-us/). Let's talk? It'd be interesting to find out what you learned along the way, as well as why you've made some choices you've made - for example, Bower is effectively dead in the JS community, and while I like the tool (especially its [PHP version](https://www.sitepoint.com/bower-vs-bowerphp/) so you can [completely avoid the cancer of NodeJS](https://www.sitepoint.com/look-ma-no-nodejs-a-php-front-end-workflow-without-node/)), I don't generally include it in my projects any more in favor of just downloading assets with Yarn. 
Ah. Fair enough
There's a bit of a difference between my SaaS app and a library. My SaaS costs money to operate (the servers) and to market and support. I produce a lot of open-source software while developing said product which I give away freely under MIT. I by no means think everyone should give away *everything* for free, but I do think you should open-source as many libraries as you can if you can afford to do so, as a way of giving back to the community that gave so much to you.
It's not a library. It's a full service and requires a fair bit of hands-on work from the Laravel Shift team. Perhaps you are just misunderstanding what the whole thing is?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
[PR got merged](https://github.com/symfony/symfony/pull/21755#event-980752914) for Symfony 3.3 Nice.
I think the top comment's first statement is also a good TL;DR: "Awesome! You replaced REST with REST. How revolutionary"
*Checks calendar. Is March 1, not April 1.*
&gt; Well, that's exactly what I've done, and it's been successful so far. I give my users a JWT which authorizes them to download a file within the next 5 minutes. File server verifies the token and lets them download. Ooh, very nice. I was thinking of a general purpose/REST API; stuff like that is exactly what JWTs are great at I think.
So what is the big lie the headline promised to show me?
&gt; but why are you writing a ticket system from scratch? Surely it would be more effective to use / modify one of the existing ones none of the existing ones really fits my needs
Something like "We thought REST is a magic wand that will make things go by themselves. It turned to be a lie, we still have to think, design and program"
JSON-RPC is great if caching isn't a concern. It's exactly what you expect it to be. If only there were a stateless version.
&gt; So, what were you saying? "Falsehoods", huh. Yes. You stated assert was "a feature and practice that the entire industry relies on". Which you proved yourself not to be true, since two of small subset of languages don't support it. Therefore the entire industry doesn't rely on it. So instead of proving your point, you proved mines. &gt; Things you commit to your repository, which you don't need or "run" in production: I'm sorry it seems you don't understand what production is. &gt; You're funny. Thanks, I wish I could say something nice about you. But sadly I can't.
So you do REST via an JSON API? Thats great, it's like doing [JSON via XML](http://ramblingcookiemonster.github.io/images/formats/jsonx.png).
Fuck SOAP and fuck whomever tries to taint the simplicity of JSON with anything resembling. There, I said it.
Oh finally! Currently we have to shell out to 7za to make proper AES-encrypted password zip files. Gets even more confusing when [ZipArchive::setPassword()](http://php.net/manual/en/ziparchive.setpassword.php) is only for opening archives, not writing them. What's the chance of, assuming it's finished and tested, getting this back into core?
We are node.js now bois!
This is what I expect: - composer - how to write a function - know what a class is - know how to create a basic class - know the difference between public / protected / private - know what namespaces are - know what PSR-4 / PSR-0 is 
You don't in all cases as refresh tokens need to be stored serverside to be secure this is not an option in most SPA. You will need to hit the db though to retrieve the access, but really in most cases you still need hit it anyway if you are changing permissions for example.
Sweet, 7.2 and encryption are going to look mighty fine indeed. 
Scalar object by Nikita popov, I use it in my own website and framework. https://github.com/nikic/scalar_objects
Inb4 everyone complains that a userland package is advertised as a "new enumerable type for PHP".
sorry, removed. will replace with more intentional title. thought that will be clear from url.
Where can I submit pull requests to this? Would love to dedicate some time into making this look and work better.
Thank you, I think it could use some more animated GIFs and blinking text.
Must be cold on that server, the web page is shivering.
you should point out that all the final methods are considered enum members.
It's a good idea and I do hope that support for this makes it into the core language at some point, but IMO the ability for enums to gracefully degrade to their primitive types is important for their overall usability. In this library I can see this problem manifest in the serialization and awkward comparison issues (and probably in other ways).
&gt; I want them to understand frameworks yes. But if "Im a developer" means "I can only use the defaults in X framework" , then you are not much use to me. The thing is it's "I'm a junior developer'. If you're bringing people in who you're not looking to invest in training and teaching them things such as how to work with other frameworks or applications then I think you are looking for "I'm a developer". Which isn't a bad thing, it's just a bit unfair to say we want a junior while wanting/needing a middleweight or senior developer.
&gt; $ticket-&gt;getType() === TicketType::Priority() I know `Priority()` is a method because PHP doesn't support objects as class-constants... but alas, it still *feels* wrong to write.
What happens if you have an admin with a valid short-lived access_token for 15 minutes and that admin gets banned? That admin now has 15 minutes to do whatever he wants on your system, even though you already banned him. The only way to prevent this would be to check against a blacklist. Using a blacklist is the only logical thing for me. 
if/else statements? Something along the lines of: if($date == date('Y-m-d')) { echo "Today"; } else { echo $date; }
i don't find that usable because some enum values are determined at execution time. example const OK_TEXT = Yii::t('app', 'Well done'); or based on a configuration const SERVICE_ROUTE = $prefix . '/service/';
Ideally I'd love to see `if($typeObject === TicketType::PRIORITY)` (not a function call, but a const) however that would require a change in PHP so that you have something like Java's "static initializing" phase for classes, and the ability to go: class TicketType extends EnumLibraryThing { const PRIORITY = TicketType::Create(1); const NORMAL = TicketType::Create(2); const CLOSED = TicketType::Create(3); private $num; private static function Create($num){ $this-&gt;num = $num; } } Now, PHP arguably has the equivalent of Java's "static initializer blocks" blocks already, because you can put arbitrary code in the source file before the `class {}` block... however the hangup is you can't put objects into `const`s. And even then, you have to be careful because you can get into a bizarre situation where your static class constants aren't actually defined until you've already made a few instances of your class... 
Even I can't agree, that this article is about REST, I agree about the rest. :D Is there at least one RESTful API in the Internet?
No, you have more security. If a third party is controlling your SSL, database password and a few little other things, then yes, you have less security.
I finally got around to work on this now. Got some questions, though. Are you referring to calculating a CRC for each row of the CSV, then getting hash of it for comparison? Isn't the CRC part pointless then? I think I'm misunderstanding.
Wrong subreddit
If you aren't acquainted yet, know that [Alpine Linux](https://alpinelinux.org/) is amazing. TL;DR: Take a GNU/Linux OS, make it smaller and lightweight (via musl libc), and apply the [grsecurity](https://grsecurity.net/) kernel patches. My current servers use Debian, but "migrate to Alpine so I don't have to grsec-harden everything manually" has been on my TODO list for a while. Suggestion/request: add php7.0-libsodium and php7.1-libsodium. (I'll also second the xdebug request, as I know many people that use it extensively.)
I somewhat agree. i often regret using enums. lets take your examples: TicketStatus, AccountStatus, DeliveryStatus, etc: Ok, when? Timestamp? Blocked because of a late invoice? What if it has to be marked as blocked for another reason at the same time as when it has a late invoice, such as abuse? I want to remove one blocked status and still keep the other. Meta data? Blocked because of which invoice? Blocked by who? And when i need something simpler i find bitmasks way more useful, since you dont need type safety here also. Not saying enums are useless, but i cant deny that i rarely use them. Btw, refrain from using titles as "Announcement:" for personal libraries -.- The amount of reflection usages in your lib also raises questions whether we should be doing this
How this lib compares to other Maybe/Option implementation for PHP? What's minimal PHP supported? Is there bind or similar method? Overloaded __call?
No love for nginx?
We all dream of servers that need no maintenance at all. But unfortunately in reality this is not the case. Disks can get full, processes can crash, the server can run out of memory... I've made a package that keeps an eye on the health of all your servers. There are a few checks that come out of the box. Adding new checks is a breeze. When something goes wrong it can notify you via Slack or mail. Full documentation: https://docs.spatie.be/laravel-server-monitor/v1/introduction Repo on GitHub: https://github.com/spatie/laravel-server-monitor
It's possible I'm confused but I thought an enumerable type was something like a list. Where as this library provides enumerated types. It is early in the morning here though so maybe my brain isn't up to speed yet.
Symfony Routing, i have learned a lot of new things. Great article
&gt; there really aren't any good, well-supported alternatives That's part of the gripe I have with the node ecosystem. What's there is so ubiquitous and at the same time badly designed, confusing, and error prone, that it's plan surprising so few people are working on actually DX-friendly alternatives. That said, thank you, your points resonate with me and I understand where you're coming from - which is exactly why I'd like you to talk about this reasoning in a post / interview / tutorial, so others can learn on someone else's experience.
I was exposed to Alpine Linux early on due to my host offering it as an image. Never heard of it before so I looked into it and since then I've not used anything else server side. It's great to see Alpine Linux popularity boom with all the hipsters using it for Docker containers, its really pushed it into the main stream.
PHP is an open system. It interacts with lots of other out-of-process systems, which requires serialization, and it also implements domain logic, typically persistent, which requires serialization. So saying "except for serialization" is problematic. It's a big deal whether you can easily serialize and deserialize data containing your types. The way I deal with this in my code is having a different serialization interface, which my various components recognize, where the "deserialize" method is static, which allows it to return the precise instance it has to (hence the issue you talk about is resolved). interface Serializable { static function deserialize(mixed $state): static; function serialize(): mixed; } Either, way, you need to have a story for serialization, IMHO. Without it, things just become clunky.
Hi, Yes, reality is more complicated and only usage of enum can't be used to solve all problems. But for most cases it's fine to have finite set of available options. (E.g. UnitsDisplayType::Metric(), UnitsDisplayType::Imperial(), UnitsDisplayType::Both() or XXXType::Yes() XXXType::No(), XXXType::Unknown() where XXX is logic name of business domain). Personally I think bit masks is too low level for business domain and better to split bits into separate attributes/variables of object, but it depends of context what's the objectives and so on. 
Enumerable type is just a type of variable with finite set of possible options. It's more a set than a list. Example let us define a type X which can contain values: Unknown, Yes, No. Then define a function doSomething(X $option) { .. } By doing this you are 100% sure that you'll get only one of three defined options nothing more. And by that you can write your code in a way that you'll handle all scenarios more easily and throw error if not handled. If in future your client says: you know, we have more options for type X, let it by Unknown, Yes, No and DefinitelyYes. You can just add that type to your definition and Find all usages where type X is hinted and handle new logic for "DefinitelyYes". Without proper enum type this type of changes is hard to handle, especially if you are using string/integers instead of enum.
There are things I like about this line of logic, like transport agnostic APIs, but I still think RESTful APIs are just as easy to set up. I haven't ever really had issues building or debugging one. But I work with a very small team so we can communicate what we would like to see on the frontend and backend and work on it together. Obviously it's not 100% REST, but it gets the job done quickly and efficiently. And like others have said, this is just a modified SOAP with JSON instead of XML. Unlike most here, I don't have any issues with SOAP, which is why I would at least consider this type of API. I use SOAP nearly ever day for one project and it works fine, but I am not writing XML by hand, just using a package to do it.
Followup: applied in master: http://git.php.net/?p=php-src.git;a=commitdiff;h=402eeb85988be91d90a92eff94635b6e9ef6160e 
Yes/no/unknown screams to be a nullable boolean, not an enumerated type. Metric/imperial/both screams to be two separate booleans, one for each of Metric and Imperial. Any time you have an enumeration similar to "both" or "all" or "multiple", that's an indicator that you actually have more than one datum hidden in your enum.
&gt; The primary reasons would be implementation of an access/refresh token model, on demand expiration of sessions/tokens implemented via JWT, and of course overall security. We covered this in one of our first blog posts, [*The Fast Track to Safe and Secure PHP Sessions*](https://paragonie.com/blog/2015/04/fast-track-safe-and-secure-php-sessions). I probably haven't done a good enough job of exposing people to it. TL;DR: The built-in session storage mechanism PHP provides is good, with some minor caveats: 1. Use HTTPS everywhere. And HSTS. 2. Make sure your session cookies are httpOnly=1 and secure=1. 3. Make sure your session IDs are generated by a CSPRNG. This might not be the default (depending on PHP version and OS). Need to expire a session? Delete `/tmp/php/session_file_goes_here`.
Not phpdbg?
http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/ Whats wrong with native sessions? They are secure and they do the job a lot better that JWT's which are not even designed for this. 'JSON Web Tokens are an open, industry standard RFC 7519 method for representing claims securely between two parties.' i.e. app-&gt;server, server-&gt;server 
1) `Action::VIEW() == Action::VIEW()` and you're good to go 2) with PHP 7.1 you can write `private const` to make sure the constant is not used outside the class 3) PhpStorm supports that quite well with `@method`, I've never seen a problem with that 4) This library is about 4 years old and has been installed 700k times, it's pretty mature by now so yes it has more methods, but these are methods that have been proved to be useful 5) That's a good point, in an enum the most important value is usually the value (not the key), but I can understand that it's not always obvious. 6) Keys don't matter, you should store the value in the database. And the value can be integer so there should be no issue
&gt; Yes, all of that is stored in the $_SESSION superglobal. Regenerating the session just rotates the identifier, it doesn't nuke the server-side contents. Are you updating the server side identifier with the new user session id or just letting that do it's thing and only looking at the app side identifier? &gt; The motivation for the timeout is to eliminate race conditions that accidentally log the user out (which is a situation you'll run into if you regenerate the session ID on each request). Oh I'm all too familiar with this problem. The flipside is that sometimes my sessions dump anyway and the user loses their shopping cart and gets logged out. I haven't been able to nail down exactly why. What about authorization? How are you validating the individual actions the user is performing? Do you have some level of RBAC implementation or ACLs? I was reading an example about how to implement Zend ACL into Slim Framework but it was all hard coded routes, which is not scalable of course.
[This is the only enumeration library](https://github.com/eloquent/enumeration) that [correctly enforces invariant enumerations](https://github.com/eloquent/enumeration#enumerations-and-class-inheritance) by preventing inheritance.
I see. I didn't catch that you were passing them both in for each call. Thanks for clarifying.
Okay, but the hash ids in place of db ids are still publicly seen in either the HTML or url. Or am I missing something?
Yes there are displayed. But if they change them they get just an error because nothing was found for that value.
eloquent/enumeration is interesting, but hey why there are so many interfaces, abstract classes, inheritances and so on, was it really necessary? Multiton for object is nice solution with initializeMembers, but in my library it can also be easily achieved, adding something like `final public static function Earth() { return static::getObject(new static('',''..'); }` and there is no need to add annotations for IDE autocomplete (no need to write Earth twice) 
It's a nice library, but hey who still uses inheritance today?
That's really informative. Thanks for that. It also verified a few things for me. I was hesitant about encoding the urls or ids, like it described. Thinking that there would be a way to reverse engineer it if the hash was related to the subject matter. But if the hash id has no relation at all, I figure, that's an extra difficultly. Glad to see something explain it that idea and verify it. I'm going to add in their time-attack solution to my solution (unless a better idea comes up). This article was super useful and did make me feel a bit better about my approaches. Thanks.
CRC only makes sense if you're doing the comparison with a SQL query and the data set is huge, like millions of records. If thats the case CRC outputs an integer, which is faster for indexes when compared to a string. You just need the full hash to weed out any collisions. If the data set is not huge or this is not a frequently run operation, then don't worry. If you are super worried about the possibility of md5 collissions then you can use sha1, but the chances of a crc + md5 collision is probably very low. Edit: if your query condition is WHERE crc_value = 123 AND hash = 'abc' Then SQL will of course first use its indexes to find all crc_values of 123. This will be performed very fast. Then say 6 records are returned due to hash collisions. Then the DB only needs to do a string comparison on 6 records, which will also be very fast. https://www.percona.com/blog/2012/08/16/mysql-indexing-best-practices-webinar-questions-followup/ or just google around for "mysql crc index" or something. Pretty nifty trick when necessary.
sounds like a configuration issue, or a firewall issue in the infrastructure.
it fails on 3 diferent servers
wouldn't a firewall issue affect all your local infrastructure :) to be more specific, are you getting any useful debug/error messages either from phpstorm, or the server logs you're trying to connect to. it sounds like your blaming the hammer -- when it's _likely_ something else.
I know, but clients keep buying these cpanel based websites
Yes, just like how writing your own cryptography is much better than relying on some "third party" crypto library.
Not at all. If someone has your bloody private keys, then they have direct access to all sensitive user data being transferred. This should be common sense. It's stupid that people are downvoting me when they aren't seeing such basic shit as this. They could at least look into how SSL works to get a basic understanding of this stuff. The problem with things like Forge is that people assume it just works. If a security issue comes up in Forge then gl;hf with the SSL certs that now become useless.
[removed]
thats an abomination. why? json is supposed to be human readable and having small footprint. this jsonx completely shits on that.
This. It sounds like he's trying to do security through obscurity, which really isn't security at all. Everything should just be verified once it reaches the server. Do you think in Starcraft if you just send the server "I created 100 Zealots", it would just agree or it would verify you had enough minerals/resources, etc?
JWTs allow you to share / authenticate information between parties that know a shared secret. Think about a distributed system where the authorization server is not the same as the resource servers. If you have a blacklist of refresh tokens, only the authorization server needs to hold / connect to that blacklist because it is the only one that is issuing access tokens. If you had a black list of access tokens, every resource server would need to either have a direct line to the blacklist or they would each need their own copy and maintain synchronization. The overall argument for use of JWTs is similar. If you have JWT bearer tokens that are signed by a shared secret (or some form of public / private key crypto), the resource servers can validate access tokens without connecting the the authorization server. If you have a lot of resource servers that are all operating on the same authorization scheme, this can preserve a lot of resources for the auth server.
It's much harder to contribute and you're much more coupled to PHP internals, which are more likely to change as they don't follow the same BC policy as the user-land code. I'm not a big fan so I'm not using it, but I still find the project quite interesting.
Neat, I didn't know about the --after flag
How is it any different than say, laravel requiring the Mbstring extension? Do you deploy new builds of mbstring everytime you deploy a laravel app? it's not hard to build an extension if you have to either basically four commands phpize ./configure make make install
Would $_SESSION variables be able to handle what you're trying to do? My thinking is: linking a session id to the player database entry and adding available targets through that keeps everything on your side, safe from the user. I would probably try something like that if I were in your shoes, but there may be another way.
Anytime you have to pass user data (yes, parameters in the url are considered user data), you have to ask yourself if someone else copies and pastes the url into their browser, will they also see the same data and will it matter?
Are there any posts in this subreddit in which you *won't* find an excuse to plug your book?
like for everything else in programming the answer is "it depends". one should use the right tool for the right job. MVC is not dead, because it's just a pattern... it's been around since the 1970's.
Do it, the learning curve is high but it's a very rewarding language.
Just started working on a legacy codebase using Yii. Had never heard of it before. What are your thoughts on it?
What do you actually use?
 Ok I will be honest, the last time I worked fulltime on PHP was when composer was not around. CI, Cake, Fuel, PHP on Trax were the only MVC frameworks. CI is the only framework I have worked on with a really large scale project, later around 2015 I did some modifications to codebase in Laravel and instantly fell in love with it. I have to admit it, PHP has come a long way (I used it in 3.3 days, writing shoutboxes). Laravel is one of the cleanest code bases when compared to other frameworks I have seen (upto point of obsession). I was quickly able to browse around, code is well commented, composable, and community is really welcoming. 
Not sure why you are getting downvoted here, this makes complete sense. I personally use mainly Serverpilot (I also manage some servers directly) - because the risk vs cost is worth it, however, without a single doubt, it does introduce another security vector. I compared a few services, including Forge, Serverpilot and Cloudways, and Serverpilot, for my purposes, was the most secure while leaving me with ample control. If Forge ran each app as a seperate user (like Serverpilot and Cloudways) and still supported &lt;php7 (I know, I know, but I have a few situations where I need to run 5.6 for the time being) I would probably go with Forge. 
Is Action know something about HTTP?
Yeah I get this but I've just always seen them referred to as enumeratED rather than enumerABLE. As an enumerable is something that can enumerated rather than something that is. One example would be the usage in c#: IEnumerable (https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx) is used for things that can be iterated over. 
xdebug wil come soon. about libsodium, it's gonna be core on php 7.2 right? the suggestion for making them available is really awesome, thanks
My preferred framework for personal projects is Laravel hands down but my current role its all CI. CI is just a huge mess and doesn't follow any modern development techniques and is the only framework I know of that actively promotes going against any PSR standards (madness?). That being said, I was asked to evaluate possible frameworks to switch to that had the following points: * Must be stable and supported (with security updates and the alike) for at least 4/5 years, we can't be rewriting code or upgrading the framework every 6months to a year (not viable on 450+ projects) * Must be easy enough for someone fresh out of college to get up and running and be productive with it * Must be mature with a good ecosystem and support network around it The only thing I could come up with was CI. Has anyone else been in this boat? What did you's go with? My other thought was symfony but when showing it to junior devs they were completely lost with it and the amount of time it would take to train the individuals far out weighed any benefits of using it.
Altering use statements would result in the fewest insertion/deletion counts in git commits.
Yes you can. That framework was a bitch to get up and running. 
Not necessarily? We have a project, which makes use of values that are defined by a remote service (not at our side). So, we have a lot of key =&gt; value pairs which are stored in database. We get the values from a web service (CRON job). E.g.: We don't know which id that TYPE_X will have. But they are actually "constants". It's used in multiple places. And it will probably be the same, once defined. But still, it's possible those values change overnight. Also, we don't use those values each time any page is loaded. But some parts do require them. (so, they are lazy-loaded when we actually need them).
Constants are not enums. You can use constants in place of enums, but using enums in place of constants doesn't make sense. 
Wow. I learned php on my own, no school or structured courses... My learning path was basically make our product work (think procedural mess), then I started to upgrade with a simple autoloader(copied from stackoverflow of course) and some controllers and views. After interviewing for a junior php development position and learning that they use Symfony I spent 2-3 nights reading (fast) through the excellent documtation... After looking at all (most) other framework I just love symfony more and more, great documtation, decoupled components, education, forward planning and community 😁 
I'm likely being downvoted because people don't like hearing bad things about what they spent money on.
/u/sarciszewski support for libsodium jus added. :) package name: php7-libsodium
Clearly you do not know. The issue is not with naive deployments such as your example. The issue is with dependency management, i.e. deploying new versions and rolling back to old versions.
Over the years I have moved from vanilla PHP, to custom micro frameworks, to Zend, to Symfony, to CakePHP, and most recently, Laravel. Laravel is like a breath of fresh air; a joy to use, and although I'm doing less PHP nowadays, it's what I turn to for almost any PHP project.
Looks like your library is naïve and immature.
Less is more. Why to augment enum with a useless helper methods which adds just confusion among team members? Append many empty Interfaces, AbstractClasses and so on, looks like eloquent/enumeration main purpose was to use every bit of OOP - abstracts, inheritance, interfaces (empty?) and do idealistic reusable/extendible OO component. And actually "enum" type in a language just needs to be treated, felt and looked just like a regular primitive type: integer , string or array, just a type not a OO reusable component. `membersByPredicate()` where this is usable? 
Hi, can't you define enum in your end which has a finite set of definition? ` ContactType := Phone | Mail | Post | DontContact ` And then add additional service like `resolveContactTypeToServerAction(ContactType $type): string {}` and use that then you need to submit it to server. First step is to resolve your internal enum into whatever you need. Also this works in reverse. So the code stays stable inside system and "resolvers" will handle volatility. And mapping from enum to some dynamic "id" should be handled separately not using another enum, but my array and custom binding logic.
https://github.com/php/web-pres2
Out of the box, fresh composer install and the clip tools failed immediately. That was honestly enough to make me go back to laravel which always works for me. 
Dude, I'm working for years with Yii and I can't agree with you at all. Yii v1 nowadays is not worth any consideration, bu Yii2 is a different piece of software. Gigantic methods? (Have you had a look at base Eloquent model class?? 3k+ lines of code ...). It has great Dependency Injection container, cool code generator Gii, a nice console app (where is it worst than artisan?), great objective-forms and form-models with ajax validators, best grids I've seen on the market. I consider myself a quite experienced developer and this is a good piece of software, very flexible if you know how it works and ideal for RAD if you did the homework. The cons: Yii core team is absolutely not under the influence of any hype (sometimes I think they will not catch-up with the industry moving towards new design patterns - look for the discussion in GH issues about supporting ValueObjects within ActiveRecord), small community. Guess Yii is never going to be very popular, but for me it is a strong player in the league of "fat" frameworks (personally no. 2 or 3).
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
it's more of a dump of anything and everything as opposed to being "curated"...
As would be said on Stack Overflow: don't point to an off-site resource without mentioning explicit examples
No. Your repository should only provide you with methods for finding entities. I would implement either a factory or use symfony's form component and keep all logic in the controller depending on where your data is coming from. 
Good point, thanks
you forgot to mention that type hints are not giving you any idea anymore of what you'll get back... Something we've waited very long for, and this just replaces with something essentially the same as `@return mixed`
https://github.com/auth0/auth0-PHP best
It's entirely possible that I don't completely understand it as I am self-taught and work for a startup where I am one of two developers. What I know of MVC is what I learned playing around with the code school ASP.NET MVC, and what we do is most certainly not that.
I did it, but it didn't help me at all. http://imgur.com/a/pBQ44
Sure: the posts that don't relate to "legacy" or "refactoring." (/me shrugs)
What's the difference between delightful and non-delightful packages? Laravel people love marketing words.
Think of MVC as a way to make a communication between end-user and the software you wrote. The probability that you don't understand MVC is in it's initials. Lets say you are end user of Google. 1. **V** You visit https://google.com, and you get the HTML with a form to input what you want to search. That is a **View**. Something shown to you. 2. **C** Once you press "Search", you are sending your request to a **Controller**. The controller will take your request and continue with the operation to store your search to a *model*. This is a controller and it take user input. 3. **M** The controller passed the data to model, for example: model can now be the keywords you've searched for. It also could represent the results for the search you've made. That is a **Model** and it hold logic. *Lets continue...* 4. Model is returned to controller (search results) in a form of response. 5. Controller makes a response (response = model + view). 6. View show you the response in a way (e.g. HTML), consisting of a response. This is the ELI5 that I could make in two minutes, maybe someone else could explain you better. As an example, the MVC can of course be procedural without any framework. How, you may ask? Simply, because your controller can be just a phpfile that takes `$_GET` parameters. Your model can be the PDO execution. Your view is the response of the data from the PDO. It all depends how clean is that MVC made and does it follow architecture design pattern rules. Frameworks help us to not deal with this rules, but have "Controllers", "Models" and "Views" out of the box.
/me nods Quoting the article: "Symfony2 is an HTTP framework; it is a Request/Response framework." The question then becomes, "What do you call the part that reads the request, and the part that builds the response?" Leaving aside the fact that MVC isn't really for the server-side, the MVC answer is is "the Controller" for the former, and "both the Controller and the View" for the latter. (See [The Template Is Not The View](http://paul-m-jones.com/archives/5993) for more on that.) The ADR answer is the Action and the Responder, respectively.
MVC is a design pattern. "Model/View/Controller". There are a lot of different versions of it but the main idea is separation of concerns. The Model layer is about accessing, structuring, and persisting data. The View layer is about presenting that data to the end-user and passing user interactions back to the controller. The controller is about controlling access to the Model and validating/sanitizing user input. In most web frameworks the MVC pattern is implemented kinda like this: * Model layer = some kind of datastore (typically an RDBMS like PostgreSQL) and some tools to make interacting with that datastore more convenient (often some type of ORM or other database abstraction system). * View layer = templating library for rendering HTML, and probably also your entire frontend stack (particularly the CSS and JS) counts as the View layer * Controller layer = some kind of system for handling HTTP request routing so your webserver (nginx, apache, etc.) and your application code are integrated. usually also includes a bunch of modules for handling typical web app stuff like auth, sessions, form validation, and some classes or functions to generate dynamic responses to HTTP requests. 
I felt dirty when I read "Packagist - Official directory of Laravel."
Ah, that makes sense. I was under the impression that it was necessary to write literal models, views, and controllers to qualify as MVC. Essentially, you are saying that the general idea of capturing user input and doing something with it is what MVC is describing, correct?
http://uproxx.files.wordpress.com/2013/05/stefon-humanpinata-3.gif?w=650
That's the main ***notable*** selling point. But not the only reason to use it. I've been very happy with my decision to use it a couple of years back now because: * Regardless of the performance stuff, it's a good modern "out of your way" framework. * For me, it's the right balance between having a framework for all the basic stuff, without being so opinionated that you're locked into their way of doing things. Although I know that can be said about many frameworks. * Breaking changes are extremely rare, and as a rule only exist between major versions. Even the v1 to v2 total rewrite (in a different language) barely changed anything from the framework user's perspective. I think I had to modify 2 lines of code when I upgraded. From memory, don't think I needed to change any of my code for the v2 to v3 upgrade. I'm not gunna diss Laravel, but it's [crazy seeing how often it changes, even between minor versions](https://laravel.com/docs/5.3/upgrade), that seems like a huge amount of maintenance to deal with to me. This is an area where the "locked in" nature of a compiled module actually kind of enforces consistency, and the structural decisions they made early on all seem to have stood the test of time so far. I haven't come across anything where I've thought they need to change how a class is structured because it's too limiting. * On the performance stuff, it's not just about response times and CPU usage, to me the biggest difference is memory usage. Cheaper VPSes, and more RAM left over for database caching, search engine etc. I'm not sure what other frameworks are typically like, but on a large site I just built for a client, memory_get_usage() reports under 1MB at the end of almost all requests. * As there's a performance focus, they put a lot of thought into memory usage, like the ORM. Things like cursors on large resultsets automatically etc. e.g. you can SELECT millions of rows in a single query, and it'll just grab them in chunks as needed when you loop through. No need to worry about memory. Although I don't know much about this area and how other frameworks deal with it. Looks like Laravel can do it, but not by default. * I found Phalcon easier to learn than Laravel and Yii. I have no idea why though. As PHP itself gets better with performance, the benefit gap will become more narrow of course. But to me, I'm happy with Phalcon as a framework regardless of the performance stuff, so it's just an extra bonus. If we get to a point where the performance between Phalcon and any other framework were exactly the same, I'd still stick with Phalcon anyway for the stability factor. i.e. The rare-breaking-changes stuff I was talking about above. There are legitimate reasons not to use Phalcon. But having a feature (better performance) you "don't need" isn't a reason itself.
&gt; Clearly you do not know. That's a good point actually. None of us really know the situation, abilities, use cases etc of the other users in the thread. Including you. Phalcon isn't for everyone. Including yourself obviously. But by saying it shouldn't exist at all, you're proving to us that you're not going to give a very balanced point of view. I've been loving it for the last couple of years. But I've got plenty of Linux/Unix sysadmin experience, to the point where I don't see its downsides as outweighing the benefits for me. I wouldn't recommend it for most people, who are in a different situation and with different abilities. In my opinion the added areas of difficulty you're talking about have actually encouraged its conservative stability. Thereby greatly reducing the need to deal with things like rollbacks to begin with. Use what's best for your situation.
1. Where would you put the code for creating the entity then? A service? 2. Would I create a service class that uses the entity and the repository? 3. Would the repository only persist, or flush aswell?
Are there any downsides to using the entity manager in the Repository as well? This sounds like something I could implement in my system. 
Glad you got it. I *refactored* my answer a bit so it might show you better insight. Your way of thinking is correct but I'd clear that up: MVC is pattern of designing the web-application to transform user input at **controller**, execute **model** on given input, and respond the model to **view**. Just write software and follow best practice. The MVC will *click* in your head while the time passes. 
Ah fairs. Yeah I plan on only using it there, and using the entity in the service 
I'm not using symfony or any components etc in this project. Other than Doctrine, PHP-Di and League/Route, this is completely custom 
That's a very good point, thanks.
&gt;It's not useful to me therefore it's not useful to anyone This is how retarded you're being.
The DI container is very new, and in fact, Sam Dark (one of the core contributors) apologised to me that it wasn't in sooner when I sent him a message. He also created the first DI aspect of the Readme.MD after I asked him to, so that other Yii developers can learn how to do it. Yii 2 has many lingering bad practices... I like GridView. I'll say that! Lol. Gii, I do not need at all. I am just much more productive in Laravel.
I understand how inline JS works? I just prefer to use NPM/Gulp/Webpack/Rollup/etc to package my JS, however, the team I've joined is so far gone that we have a bunch of old-Yii2 bad practices stuck in the system. JS is included SO many ways in our app... $this-&gt;registerJs('script)' in a controller, or inline $script = &lt;&lt;&lt;&lt; 'blahblah script' EOS; in a view, or sometimes, god bless, the team actually used the AssetManager depends structure correctly. A lot of my issues stem that Laravel encourages best practices, and Yii2's code seems to be... sloppy. And the front end pages look AWFUL compared to using Blade... I wish Yii2 would have defaulted to Twig or another templating language, so 90% of the projects would use it, but of course my lead didn't pull one in early... and now it's way too late. I'm used to a really nice, smooth process with gulp/webpack etc... and I understand we can turn the assetmanager off, but we are so far gone in to it with a 300,000 LOC code base... And I got the AssetManager to compile SCSS, on page load! It doesn't even compile it before hand! And it uses that awful Composer-asset-manager plugin, which has been broken for days if you require yii2-fullcalendar, because the fullcalendar package itself uses a new "2 - 3" require syntax that the asset-manager hasn't updated to, unless you re-pull dev-master, so we have to manually wipe the vendor folder, which will be fun on my 15 production sites... There just seem to be so many "gotchas" with the Yii2 ecosystem. I estimate I was ~50% more productive in Laravel 5 than I am in Yii 2. What do you mean it's a bit too general? I mentioned a couple things off the top of my head in a reddit post, it's not an essay. I upgraded all our Yii2 sites to PHP7 as well. Unfortunately a bunch of the packages broke when I went to 7.1. This includes the attachments uploader, yii2-mpdf, and yii2-fullcalendar, but there were others as well. Notice I said packages, not Yii2 - it's the ecosystem that I miss from Laravel. I'm back to PHP7.0, which is frustrating, due to lack of multiple return type declarations... I did talk to Sam Dark via Reddit back and forth, and he apologized to me that my app is covered in Yii::$app-&gt;shit, and doesn't use DI, because they added the DI container so late. He also added a Dependency Injection section to the readme for me, so I could explain to my team how important it is. So the developers are quite nice. I also miss a lot of small things. Collections, for instance, vs arrays. Eloquent is also so much richer in features - I really have to composer require a package to linkAll on many-to-many relations in Yii2? Really? I do like that it comes with a Vagrant box now. edit: And 100% the thing I miss the most is the artisan command line REPL. I need to set one up, but I haven't found the time...
Cool, I live in Norway but i'll check it out. Thanks :) 
 https://medium.com/@taylorotwell/measuring-code-complexity-64356da605f9#.b5ccgmmwu Laravel Longest method: 13 lines of code Average method complexity: 1.62 Maximum method complexity: 17 Eloquent is a big class. Methods are short and descriptive. I didn't say classes were too big in Yii2 - I said methods were. 
&gt; shouldn't the UserRepository be the only class that knows about my Entities? No, the UserRepository should be the only class that knows about the details behind *storing* and *retrieving* those entities (one such detail would be the use of the entity manager). Other classes can use the repository to get and store entities as needed, without burdening themselves with the actual mechanism behind that storage and retrieval. That said, if you wanted more "pure" architecture, those entities should be defined by one more interfaces (contracts) which describe their behavior, and then the rest of your application should only know about those interfaces and not the concrete entities themselves. This lets you implement polymorphism without inheritance, and makes your app more flexible.
I did the math: `document.querySelectorAll('#readme li').length = 785` I'm pretty sure searching packagist is easier at this point.
Right, but I think this type is also could be viewed as enumerABLE as you could enumerate on that type if needed, but not necessary to do that. And enumeratED is also valid, but I prefer focus to say that this type can be enumerated instead of that this type has been enumerated. Hm, actually I don't think that EnumeratedType would make sense as it shows the end result of enumeration process (counted, listed), the declaration of type would look more like FixedSet which is enumerable. Is that sounds logical to you?
The reason why one might want enums as types in PHP is to get static checks (eliminate some classes of bugs), and to let the IDE offer autocomplete assistance and refactoring for you. If you define enums at runtime, obviously none of those benefits can happen, so at this point, sure, you can wrap the available runtime options in some class, which validates them, keeps them as state and so on, but we're no longer talking about enums as *types*, really. As types are analyzable before runtime. This is why I'm saying using enums defined at runtime don't make sense. I'm not saying there aren't scenarios where picking one from a set of options is defined at runtime, but when it is, it's not something enums as types are beneficial with. Enums, like all type-based solutions, are just a static contract.
&gt; [E]ach representation requires different data ... Is this data loaded in responder or we should make 2 actions which loads needed data and passes it to responder? My intuition is that if the *format* being requested by the user, requires that different *data* be sent back to the user, then you have two different domain calls to make with the user input. That implies to me two different actions. EDIT: I can think of alternatives to that, e.g. having a domain call signature that allows you to pick-and-choose which subsets of data to return; instead of expounding along that line, maybe give a fuller example and I can give a fuller response.
&gt; Well you have to make a decision, are you going to be using Doctrine ORM in your project? If yes, then inject it into your UserRepository and make full use of it. Well, you don't really have to actually do anything. If your `UserRepository` is extending `EntityRepository`, as it should, the entity manager is already available. &gt; Also my colleagues have banned it Your colleagues sound retarded.
So in summary: You never contested that Docker (or any containerization technology) solves all of the problems you originally mentioned. You merely said that it has some cons When asked to enumerate those cons, you refused to list anything other than your ops have had issues implementing it I'd be happy to consult for your company and help you in your understanding and implementation. Feel free to DM me.
IMHO a template shouldn't represent any functional implementation, but should act as metadata for rendering some "thing" (page, user, product, etc etc). Ideally the implementation of that thing is an encapsulated object with loose external couplings, making your "thing" (along with the template metadata of how to render it) portable to other implementations. In other words, (again, IMHO) if you're logging something from your template, the issue isn't how hard or easy it is to log something from your template code, it's that you're adding coupled functionality to what should in theory be purely encapsulated metadata.
Im using symfony and phalcon in work, and in future if possible i will use phalcon most likely cuz i really like it even community is really small but helpful.
The title was misleading, there was no mention of D&amp;D what so ever! :) 
&gt; As I understand, I could implement a UserRegistrationService which would deal with registering the user and inserting it to the database. However, as far as I know, shouldn't the UserRepository be the only class that knows about my Entities? Application Services are responsible for both handling object orchestration and encapsulating the Domain. The Domain itself would include things like Entities, Value Objects and Repository interfaces so it's perfectly fine if they're aware of your entities. If it helps, you can think of each Repository as an in memory collection of Entities which expose basic CRUD operations. Since the actual persistence of data is considered a technical concern of the repository layer; you should also consider placing a layer of abstraction between them and your Application Services. One of the benefits of this approach is that it will allow you to test each service in complete isolation by injecting mock repositories which simply add/remove entities to an array without effecting the behavior of your services. You could also "stack" additional caching layers on top of each Repository via Decorator Pattern. ----------- Additional Reading: http://www.ben-morris.com/why-the-generic-repository-is-just-a-lazy-anti-pattern/ https://hunterskrasek.com/programming/meetup/talks/2015/02/21/repositories-and-decorators-laravel/
Note: this comment assumes you're a newcomer to development / deployment / php, apologies if these assumptions are wrong. Probably the easiest way for you to access the code on the server as a newcomer is to connect to your digital ocean box via ftp using an ftp client like filezilla (or equivalent). That way you can pull the code down and work on it locally. If you google ftp digital ocean there will be an official guide within their support somewhere / countless tutorials. Once you have the code on your computer: I would suggest setting up a local environment, this can be done in many ways, but probably the quickest and simplest way for a newcomer would be to download a program like MAMP, xampp or wamp, this will allow you to easily run apache, MySQL and php on your computer, 'mirroring' a basic web server with your projects requirements locally. Once set up locally you can version your code using git, I'd recommend looking for some YouTube tutorials to cover for basics, what it is, why you should use it etc. But in a nutshell it will save you countless hours and help protect your work from cock ups that inevitably come. Whilst on the subject of git, check out bitbucket / GitHub / gitlab for hosting your git repositories remotely. They act, at a minimum, as a great backup to your code. After making changes to your code locally, you'll be ready to deploy your code again, as you pulled the code down via ftp you can push your code up the same way. Note: there's many other / better ways to deploy your code, but for the sake of learning / assignments, ftp is fine. Again, apologies if this was aimed at the wrong level of entry, if you have any questions let me know. Edit: a good subreddit specifically for help with php problems is: /r/phphelp, they may be able to help too.
dunno why I'm on an Alex Jones kick today
I'm no troll and not trying to be negative. My statement was based on your opening comments. I have read some statements you have made since then and I concede you may have some good comparison (Yii2 vs Laravel) information. I would like you to clean it up a bit; (I don't actually believe anyone puts $this-&gt;registerJs('script') in a controller, and breaking packages don't have anything to do with a framework) and give us some solid comparison information. I would appreciate that, thanks.
For what I can gather from the script your code is in the folder /var/www/html/myproject/public There you should be able to see some files which should be the same as this https://github.com/panique/mini/tree/master/public I don't know if you are connecting via SSH, FTP or whatnot depends on the method how you can edit files, or how much you know about linux.
Oh dear, do you perhaps remember what the error was? If you don't, would you mind trying again and letting me know? Can you share your environment with me? I'm one of the core CakePHP developers, and something not working out the box is obviously something that we need to fix ASAP!
Pure PHP background, but that's what I've read somewhere. But then others we're telling me to use services, so I couldn't see how they would fit in. 
Laracasts are great for any developer. 
Shit, the contamination is spreading. 
&gt; Given my spiel on them being bad for testing, why would I use them in my views? It makes code easier, and decouples the views from the renderer. I feel like this has to be explained, because it makes no sense dropped like this without context. For the log, if it's a single request-wide **debug** log, then it makes sense. I have one that's static as well. But if it's application/service logs, I wouldn't do it. And views and renderers... I can't picture the improvement.
&gt; Since it's well known that shoving logic into your templates is an anti-pattern It's so well known, that people don't even think about it. Because if they would, they'd remember that actually in the separation of M, V, C, the goal of V wasn't to "eliminate logic, period" but simply to isolate "presentation logic" in its own component... Model = business logic, Controller = interaction logic, View = presentation logic. You can't eliminate the logic from a component that only exists in the form of code, which describes logic. It's like saying the healthiest diet is eating no food, because this way you stay pure. Even if the code is declarative, it still encodes logic, just in a less procedural way. And the reason we have templates is not to eliminate logic, but to describe a problem in a DSL that's better fit to the problem at hand. Having logic, or even islands of PHP in there doesn't make the DSL less effective at that job, as long as those islands are in service of the presentation and not trying to replace the other components of the system, in terms of responsibilities.
&gt; Generally speaking, however, we’re definitely seeing a shift towards a container-based architecture, where MVC plays a much lesser role. It’s all about microservices, orchestration and building apps as “functions” Well, the article did warn us about "random thoughts", and delivered. You can have a MVC microservice in a container... so saying "MVC plays a lesser role because of a shift to containers" makes as much sense as saying "fast food consumption plays a lesser role due to a shift to consumption of online news media".
Yeah. At least he calls them what they are ("proxies").
One thing to be careful of is that using https://github.com/vlucas/phpdotenv or even https://github.com/symfony/DotEnv for that matter, is that it may cause an unnecessary disk access. Using `getenv` and setting the environment variables in the vhost are usually a better way to go.
Do `flush` only when your business transaction ends. Perfect place - controllers. Repositories should store ready entity. So your `register` method should receive `User` entity. You could learn about entities and repositories from DDD books.
Both will get your job done but probably your first projects will be faster in Laravel since the learning curve is a bit more steep for Symfony Framework. I would recommend Symfony Framework though personally if you like to actually learn coding as Laravel seems to put most stuff in static proxies/facades which doesn't teach you the "proper" way of doing it.
Basic programming functions is maybe using raw sockets. curl is a library. Either way this comment makes no sense.
If you cache them you loose the ability to change them without busting the cache, which is what this article was about.
&gt; ~~storing and~~ retrieving 
The only issues with guzzle is that it's versions have breaking changes and issues with dependencies. If you plan on creating a composer package yourself, PLEASE don't use guzzle... if you do I feel bad for anyone trying to implement it in an older code base 🤓
Just because it's organized doesn't mean it's "curated".
"If the code deserves to be written, it deserves to have tests." \- [The Way of Testivus](http://paul-m-jones.com/archives/251) "If it doesn't deserve tests, then why did you write it in the first place?" \- I don't remember where that came from. Did I make it up? idk You want to ensure that future changes to your code don't break your application in an unexpected way. If you coded an error handling routine, test it to make sure each input case is covered. edit: escaped hyphens
I wouldn't call Doctrine "bulky" at all. Getting started with it is very easy and the concept of your entity being a plain old PHP class is a lot simpeler to me than extending an entire library with your entity to give it the possibility to save itself.
The problem is that smooth scroll is expected on mobile touch devices, not desktops. The solution is easy though: use CSS to replace the cursor with a photo of a finger.
"PHP - Official language of Laravel"
My first thought would be make sure that the expected behavior continues to work prior to deploying code to production. You to do list is supposed to accept input on one page, and then display it on a different page? Your test should do that. You need to insure that your form prompts the user for all the needed information before letting them proceed? Test for that. You can't really test for unknown behavior, because if you can write a test for it, you can write something to gracefully catch that event (I think). Mostly, I would concentrate on writing tests to insure that the code continues to work they way you intended it to. Say you're writing your own blogging software - have a test that insures that when a visitor clicks "read more" on the story on the home page, that it actually shows the rest of the story. And test this before updating the live code. :)
Lmfao
Might be but I'm not sure. I've only read Code Refactoring from his written papers 📚. But I like him. He's cool.
What's the general consensus on storing structured config? For example, you could have credentials to multiple databases (maybe a nearby read-only slave, or a caching DB), and the natural config could be; { "db_creds": { "cache": { "uri: "memcached://localhost:11211", "user": "db_cacheuser", "pass": "db_cachepass" }, "persistent": { "uri": "postgres://pg_cluster.example.com:5432", "user": "db_persistuser", "pass": "db_persistpass" } } } That *could* be expressed as a bunch of flattened key/value envvars , like `DB_CACHE_URI`, `DB_PERSIST_URI`, etc - but then you need to write some ugly and inflexible code to flatten and unflatten it. Or, you could store it the envvars as serialised strings (eg, JSON strings), but then you'd need to decode it before and after use (perhaps your DBAL expects a JSON fragment), and it makes debugging much more painful. Or, you could store it naturally as flattened keys, but then your config becomes unwieldy. None of those options seem ideal.
one explanation is here: https://12factor.net/config
I don't totally understand what you are asking, so I made up my own related questions and answered those. Question 1: Do I need to test everything, or should I only do a balanced amount of testing? This is something I have spent many years thinking about and experimenting with different approaches, and here is the inescapable, but controversial conclusion I have come to: Test everything. By test everything, I mean test everything you actually want to work correctly, which is everything. Many programmers are promoting the idea that we don't need to test everything, but we only need to do a balanced amount of testing where we test what is likely to break. But that doesn't make sense. I will concede there is a small nugget of truth in there, it is true it would not be practical to try to test every conceivable input to every function, or every conceivable combination of paths your program might take. So in that sense, and in that sense only, yes we do need to exercise balance. But when you take this concept of balance farther, it doesn't make sense. The argument for this is very simple, and boils down to these 2 main points: 1) If it isn't tested, you should assume it doesn't work. 2) Manual testing is a waste of time. Argument 1, if it isn't tested, you should assume it doesn't work. Programming is complicated. Every professional programmer knows the code they write needs to be tested on some way. Any time you think it is safe to not test a section of code, there is a decent chance it has a bugs you don't know about. We would like to believe we can write "simple" code that doesn't have bugs, but in practice, this just isn't the case. Any time I start thinking that way I pretend that is someone else thinking that way, and I challenge them in my mind. I tell them "Show me an untested section of code that is bug free, and I will prove you wrong by writing thorough tests that find bugs in it." Then I think about whose side I agree with. That is usually enough to remind me of all the times I thought my code was solid, but it actually had bugs. Sometimes, depending on the language you are writing in, there are small pieces of code you can be sure are bug free. This is the case if the compiler / linter / build tools would have caught the bugs for you. But even in that case there should be tests somewhere that touch these lines of code, because there is some other piece of code that is using it that needs to be tested. If there is nothing using it, then it doesn't need to exist, and you can delete it. If it only needs to exist to satisfy an interface or something like that, and it really won't be used, you should consider redesigning your code to not need extra stuff like that. If you still want to do it that way, you should make that code throw an exception if it does get called by accident, so you know it will come to your attention if it actually did get used. In that situation, you still want to see 100% code coverage in your CI server, because otherwise every time you run the tests you will find yourself manually looking at and verifying that the parts not 100% covered were parts you decided not to cover, and that will take up more time and be more work in the long run than just getting it covered. If that code really is not used, it is alright to cheat a little and place some kind of comment in that code telling your code coverage metrics to automatically ignore that part of the code, thus allowing you to see 100% coverage. Requiring 100% coverage will often reveal unexpectedly uncovered lines. Having 100% coverage does not prove your tests are great, but having less than 100% coverage does prove parts of your code are fully untested. Argument 2, manual testing is a waste of time. Manual testing is testing the way the code used to be, not how it will be in 5 minutes. Lets say you are doing some manual testing before doing a release. You test several features thoroughly, and then find a bug. You fix the bug. You test the fix. Now you have to go back and manually retest everything you manually tested before because you may have broken something that seemed unrelated, but actually was not. Don't you wish you had automated tests that did that for you? You will save time in the long run by doing automated testing for all your testing. There are two exceptions to this that prove the rule. It is alright to do manual testing as a way of testing your tests. Sometimes you just don't trust your automated tests are catching what they should, and you feel the need to see what would happen if you test it manually to compare the results. This is fine, but if you find yourself needing to do this a lot, something is wrong. You either have good reason to question your tests so much or you don't. If you are actually having issues with your tests not testing things properly, you need to address those issues somehow instead of pretending that manual testing the answer. The other exception is to test what it is like to use the software. You might be testing whether the workflow works well, or how user friendly or intuitive it is. Question 2: Ok, so I agree I need to test "everything", but how do i do that? What types of tests should I write? I am less dogmatic about my answer to this question, but here is what I have been doing when trying to test "everything" that seems to work fairly well. Write unit tests, integration tests, and acceptance tests. Unit tests test relatively small pieces of code, mostly in isolation to other code. I try not to be too dogmatic about exactly how isolated a unit test needs to be. I don't always mock everything used by an object when testing it with unit tests. But I do mock things so that it does not actually make changes to files, folders, databases, and stuff like that. I might also mock other things at my own discretion just to get the code more isolated and easier to test, but I try to only do that when that technique is working for me rather than me working for the technique. There are 2 main points of unit tests. First, when you find something is not working right, it is easier to fix it when you can isolate the problem. Second, you want a suite of tests you can run quickly enough that you will feel like running it very frequently while developing to give you some level of reassurance you didn't just break something. The most important element of unit tests is you should be able to run all of them quickly. You will need to write some unit tests that test the performance of isolated pieces of code. I normally don't worry about this until something has proven to be a problem. You only need to do this in unit tests if you suspect the problem is not coming from the parts being mocked by your tests. Make sure your performance unit tests fail if the performance is not what it needs to be. Integration tests are closer to a real world test in that they do as little mocking as possible. Because they are more real than your unit tests and more isolated and faster to run than your acceptance tests, they are still important tests to write and run. But they should still run fast enough that you will want to run all of them before doing a new release and after you finish a new feature / change. Once again, I find it is typically acceptable to not worry about performance tests until something shows itself to be a problem, but you may need to be a little more proactive about this with your integration tests. Doing performance testing in your integration tests is extremely effective for addressing performance problems as most of these problems will come from actually using the database, file system, or network. Acceptance tests can be defined in different ways. What I mean by acceptance testing is real world testing via automated tests. Think driving a real web browser through your website and testing that everything works as expected. It is important to write acceptance tests because they are more real world than the integration tests, and they test things from the perspective of the users. You should write an acceptance test for every feature. The acceptance tests provide the official documentation for what features your project has, and how they should all work. if there is no acceptance test for it, consider it as the feature does not exist or the behavior is undefined. This will give the programmer a good reference when discussing with the project owner what features to add or change. I prefer something more programmer focused, like Codeception, because I find the code easier to maintain and debug than something project owner focused, like Cucumber. Acceptance tests are where you should do most of your proactive performance testing. Every acceptance test should have a performance requirement. Write extra thorough tests for the security features with all three types of tests. End of questions / start of conclusion: The main resistance to actually doing all this is it takes a lot of time and effort. But it will take even more time and effort in the long run if you don't do this to get the level of quality your customers will demand. Testing everything makes it much more practical to do constant, aggressive refactoring and code reviews. You will not want to do a code review until you consider the code ready to release. But you won't want to do a code review and have the reviewer suggest changes if you had to manually test it to get it ready to release because then you would have to do all that testing over again after you make the changes they suggest. Constant, aggressive refactoring is the only way to prevent you from having to do the dreaded rewrite, which is a much worse idea than it sounds. Constant, aggressive refactoring is only practical, and will only be tolerated by your customers, if it does not cause you to frequently release buggy code. But without that refactoring, you can't adapt to unexpected design problems that don't show themselves until later, and this will happen regularly. 
That's a fantastic talk. I've watched it multiple times 
Maybe you're right, there are a lot of girls constantly talking about "saving the environment" and how it important it is. I've never thought that they were talking about programming... Gonna try it next time thanks!
I really don't get why it's popular now. IMHO it's slower, less secure, and more complicated to use than simple php config file. Just WHY?
I don't think any of the frameworks have 5 year lifecycles. PHP doesn't even have 5 year lifecycles. It seems like you'd better go with Symfony or Laravel and write tests so you can iterate faster.
I think it goes into enough detail to say why. It's fine if you disagree with the reasoning though.
Not even near. The *real* common thing about PHP is still that ugly spaghetti made from mysql_query calls intermixed with HTML. I fancy the share of this PHP is like 70-80%. This *is* what most people take PHP for and being taught as PHP. So you can tell that basic procedural PHP and some basic MySQL and HTML are the things that indeed common among wast PHP folks. I guess that composer is familiar to like 5% of PHP users overall. Wordpress is somewhat like a dialect - people speaking it know very little of the rest of PHP. Laravel is much praised, but people who can read and write Laravel are much scarcer than you think. MVC is a buzzword that everyone understands differently. Edit. I just wondered, what would have been a list of tools and concepts every PHP programmer *should be* familiar with - **error reporting**. How to log and report errors. How it should be done in a local and production environment - **exceptions**. when to catch them. how to extend them. how to catch them - **debugging**. what to do when your code doesn't work - **google**. how to look up solutions on the Net - **basic security concepts**. Knowing how to deal with passwords correctly, proper use of sessions and cookies, prepared SQL statements, permissioning users, etc. (suggested by /u/andrewsnell). Though all this stuff should be handled by your *framework* - **framework**. Any modern one will do, just to understand the concept. Micro-framework is ok - **templates**. Even raw PHP templates will do but really, learn Twig. - **ORM**. Making your code to write SQL queries for you - **git**. how to collaborate with other developers. how to share your code - **composer**. How to make your program/tool easily available for everyone and how to easily use other's code - **open source**. How to realize that most of your tasks are already solved. Just find the right tool that has been already made and actively supported by people who know a lot more than you Additions and corrections are welcome. 
It might be worth looking into JSON schema. It will allow you to to some really complex validation: http://json-schema.org/ http://json-guard.thephpleague.com/ 
thats not the job of the repository
Fuck people that want to learn, right?
Guzzle is fairly new to me, is there any plain english documents I can read up on it from? I am only working with a few basic php files as of current.
Why would I pick this over something like this: https://github.com/justinrainbow/json-schema json-schema is a defined standard and some apis even already offer json-schemas you can use.
&gt;Have we all tinkered with WordPress? No. And not everyone uses Composer, either.
&gt; Your last paragraph says it all. Laravel is great and all That disgusting framework wasn't mentioned anywhere in the entire post. What is *wrong* with you cultists?
Oh boy, here we go again.
Thanks for bringing this up. I know what composer is, but I don't understand how or why you would need it, yet so many libraries just go with the composer installation instructions and I can't use it
There's also https://github.com/webmozart/json
Does this mean they know their way around the wp gui? 
I learned codeigniter so I am not familiar with composer. I've just started getting into WordPress plugins and themes and think it's pretty neat. The tooling around laravel is pretty cool too. I want to learn laravel at some point, but I am also looking at node as a possible diversion away from php development. 
Here's an example from the old way of doing things. I'll use MagpieRSS as an example. Magpie has a 3rd party dependency on the Snoopy library. I have a project which needs to consume some RSS feeds so I include MagpieRSS into my project. Just assume I miss the fact Snoopy.inc.php is in the /libs folder. Everything works fine. I work on the project some more and determine I need to use the Snoopy library for other functionality. I download it and add it to the project. First problem is I have 2 copies of Snoopy. Second problem is hard to catch because there's only 1 specific page where MagpieRSS and my Snoopy dependent functions are loaded on the same page. This page always errors out due to repeated code. Eventually this situation is discovered and it leads to problem 3. MagpieRSS is using version 1.2.2 while I'm using version 2.0.3 (those are made up version numbers). Using composer MagpieRSS would have listed Snoopy as a dependency and it would have made it available via autoloading. When I went to add Snoopy, composer would know it was ~~around~~ already installed and the problem was avoided. The version conflict would have also been raised by composer. When the libraries are small this seems trivial. With larger code bases with multiple dependencies it grows in size as an issue. It also provides a standard location for dependencies. In the old school example, MagpieRSS put it's libraries in /libs/ . A different code base might use /lib/ or /system/ or whatever the developer felt like naming it. With composer it all gets put into /vendor/. Also helps to separate your project code from 3rd party code. 
It's because it's easier for companies that are selling you php-as-a-service... And EVERYTHING is moving to *-as-a-service model... EVERYTHING So they control your mysql database and you don't really even have access to phpmyadmin a lot of times in this model... You also don't have access to the filesystem to store a config file above the root directory! So how you get your dbname and passwords? And where do you store it that your app(everything is called an app now!) can use it?? The company serving the site just throws it in an env variable for you of course! Look isn't this so much simpler! You don't have to even know the credentials, or store them anywhere, all you have to know is which variables hold what info. In this as-a-service model, it actually works pretty well, but it's pretty stupid if you are setting up your own shit in a more traditional way.
You didn't make it to his last point, did you? 
In this json validator library, "123" would never match type integer, but string. In this case, it is strict by default and no way to change this. The strict mode is only used for objects, see https://github.com/rethinkphp/json-validator#strict-mode
/r/PHP is not a support subreddit. Please visit /r/phphelp for help
Besides all the libraries we use, we've also got our code broken down into modules. We've got our CMS, Blog, Gallery, MLS, etc. all in gitlab projects. When we added RSS functionality to our blog, we updated the gitlab project, then used composer to update the Blog module across all of the sites we've built. We can email everyone periodically and let them know what features we've added to their site at no cost to them. Or let them know we've got a new feature that costs $x. When a client calls and requests that we add a blog to their site, we simply add that project to their composer.json and update the site.
Thank you.
Installing plugins requires mad wp skills. 
recaptcha
It looks like recaptcha we have to use an API to a Google service. I would rather have it in my site instead of using another system.
Sure as hell was mentioned. What is wrong with *you*?
Look around on Packagist for a one then. But honestly, Google's Recaptcha is about the best and most reliable system there is for it.
Is your code fully test covered, stress tested, peer reviewed and fully documented? Is anyone that is going to start working with you instantly going to be familiar with the router, db abstraction, view rendering, dependency injection container, service registration, session integration and form handler? I'm guessing no, and that's reason enough to use a framework. Especially in a team setting.
I think learning Node is a good idea as well. While I think the learning curve is a lot harder and I feel there are as many gotchas as PHP, it's another great skill to have. Besides that, it will get you familiar with Javascript, which means you can do your front end with React or Angular as well as the mobile app with React Native. All in the same language.
For a JS helper, I'm currently learning VueJS for the frontend. It's kind of a mix of features in angular, react and polymer. Check it out if you have never heard of it. 
This library uses justinrainbow/json-schema under the hood. I found that json-guard is far more handy.
RAML 1.0 is much better right now as for defining data structures.
How about unsigned int64?
Breaking packages have nothing to do with a framework. I assume you have heard of PHP FIG; Do you know what the "I" stands for? In recent times, all major PHP frameworks are - at least - somewhat interoperable. Choosing bad packages is your fault and yours alone. Just so you know, I have used many frameworks for many different languages, from Java to C# to PHP. Try as I might, I do not understand this PHP framework religion thing. Your assessments hold no technical merit whatsoever. All of the most popular frameworks are so very similar no accomplished engineer will choose on the basis of anything but some extremely specific point of taste. I find no truth in your statements.
Wordpress, all day every day :P
Hi, I'm an SQL terminology nazi. Relation = one table; Join = a table formed by combining multiple tables; A colloquial term for joins can be "a relationship between tables", but if you call it "table relations" you're saying "relation relations", which is nonsense, I mean strictly speaking. Nazi out.
Most people host on servers that don't allow you to SSH into the box and run composer commands or Laravel artisan commands or git commands or set up git deploy scripts. And even if they are hosted on a box that allows such things most don't know how to use the command line to begin with. Most people use Windows. Most brand new aspiring developers only know Windows. Most Windows using new developers will look for Windows focused learning material first, possibly for years, before moving to Mac or Linux.
I see twig coming up every once in a while, but never saw the need to look too deeply into it. What are its benefits, compared to Smarty for example? I've only ever seen some benchmark comparisons between them, and none greatly favour one or the other. 
Are you saying you can provide custom deploy scripts to be run on Forge? Do this scripts get executed remotely or run via SSH on the target machine?
There shouldn't be much difference as both compiled into native PHP code. But to my liking, Twig is a more lightweight and versatile than Smarty. Though it's entirely subjective opinion. I'd say if you're already using Smarty, there is no benefit from switching to Twig
Yes. Forge provides a webhook that when hit triggers a build script that you can customize. It's run as the Forge user via SSHing into the host server. A typical script might pull the latest from your git repository, run a composer install, and run migrations.
I would hang myself in the garage with a note saying "WordPress did this to me" if I had to work with it. 
I get what you're saying but the thing is, I don't care about tables I only care about entities "Classes" 
I wrote a system many years ago like this (before I knew better). They have been asking for extensions recently, which I've done, but after years of using frameworks now it just feels so slow to do it like that anymore. I did try a rewrite in a framework, got started and decided that it really isn't worth the effort. It works, and as long as I'm the only one who has to maintain it, I don't feel to bad for anyone else.
I currently working on the same (allow to describe json schema like in RAML and allow to define custom reusable types).
I was learning php 2.0 fi for some months when my cto said: "Cool! Look! php3 is comming in the next months - We will do that! I mean... you! Here, I got you a book for that. Get going!" - And I did. I have seen a variety of coding styles and learned design patterns and anti patterns and the movement of the language for almost two decades now. Because php is extremly easy to get into and available everywhere it is really widely spread. Each developer has a different background and different experience and skillset. So... is there a common knowledge? I think it comes down to theese two characters: &lt;?
testing, linux basics, php cli, sql Can relate to security, mvc basics and git. The other points do not make sense. Someone who can use an ORM but not raw mysql is just bad.
There are literally thousands of webhosters. One that offers ssh and git and other command line tools is definitely out there. But like you, I also run my own DO vps's. I like it. Gives me a chance to learn Linux and allows me to completely customize everything and use tools like wkhtmltopdf. 
[removed]
You should be reading tutorials, not posting them.
Step 1: Don't.
Expose proper public api (via interfaces) for usage in other libraries.
There isn't a script to automatically bring in money. You need to give solutions to real problems and charge for it. From there, you can build some money and start making software and telling people they need it because of x, y, z. But you're a software developer, not a marketing person. Just create software that fixes a problem for people.
So, OP states English is not their native tongue so let's be less like Stack Overflow and reread the question with that knowledge; &gt; My first goal is $150 a month, what frameworks/libraries should I focus on with that goal in mind? And now we'll provide a constructive answer; Wordpress, learn Wordpress. Yes Wordpress is PHPs bastard child; but it's ubiquitous and, for someone with a half-decent grounding in software engineering, really simple to master
&gt; the amount of simply factual incorrect statements and bad advice here is stunning, i wanted to take a moment and start commenting on all of it but a big sigh ended that aim prematurely ;) &gt; That's a bold statement you make there. Especially when you don't provide any evidence nor point out exactly what you feel is 'factually' wrong. I know the hype these days is just sprouting out nonsense without any facts to back them up, but claiming others are doing it "wrong" without providing any guidance just rubs me the wrong way. &gt; 90% of everything you learn on how to write good code is just for 2 simple reasons, refactoring and testing. Speaking of wrong, just "refactoring and testing" is _not_ good advice. Most people get (unit-) testing wrong to begin with, nor have the background to decide when refactoring is actually needed. There are a lot of good books about the subjects. I'd recommend those. I would like to close with you seem to have a very narrow(?) and specific meaning of the repository pattern. Luckily there are _actual_ resources that tell us what we mean when we talk about repositories. They seem to disagree with your view. I would urge you to re-read Fowlers meaning [Fowler on the Repository Pattern](https://martinfowler.com/eaaCatalog/repository.html)
I have developed many scripts I can translate it into English content management systems Scripts But how can i tell people about it without a marketing budget Do you have any ideas? thanks a lot 
They are pretty similar template syntax wise, only twig is a much more modern implementation. Smarty's development seems to have slowed down significantly over the years with only 2 releases (3.1.30 &amp; 3.1.29) in the last year. Twig had around 20 or so, which shows that the project is more than active.
You forgot to mention that for the ready made PHP scripts **there is no market at all.**
What do you mean by ready made PHP scripts? Sure customising a code base for a clients need brings more money, but if a code base solves a users problem (ie: automates some of their daily tasks to save time, ergo saves them money in the long run) and a ready made script is something that they need, there's a market for it, albeit small, there's a market. 
Did *you* sell any?
So you didn't sell any. So I thought.
Sure, ok. I don't care if you think that. You're really vague in your typing and hard to deal with. Do as your SO profile and use Your Common Sense and actually engage in conversation instead of cherrypicking and being a narcissist.
You need either a way for your application to register the other packages, or a way for them to register themselves with your application. Usually there is a specific folder structure in every modular application that allows for one file to proxy the plugin, i.e "/mods/vendor/Module.php" where `class Module implements ModuleInterface {}` lives and is automatically executed by your application (or it may also be that you want to play it a bit more safe and require the developer to actually register the module manually). Please note that usually it's not "your application" that reads and decides to executes module code, rather it's the module that "listens" for notifications by the application and execute it's own code depending on what action that is made.
Exec `money.php`.
Well indeed I was overconfident and blind but anyway. There is no market for PHP scripts, even if you're a native speaker. You don't get paid for the forum posts nor tweets. Which makes your rant of little value for the poor guy.
Do you really think an answer that hides behind a paywall is a useful answer, or are you painfully aware it isn't, and simply do not care if there is a slim chance it brings in some money?
This is too advanced for me to understand. The scene is when my package is executed it shows some stats report in the usual key value pair. (For eg. Let's consider it shows server stats like "PHP version: 7.0.0"). Now I want other package developers while they create their PHP packages or if I myself create another package, I want certain stats of my new package to be appended in the report stats that my first package gives. In short make it felxible that a user can add his own stats in key value pair or another package developer can too add his own stats at the end of the report generated by my first package. So how do I achieve this? While the report is being built up, how do I check and add if more stats are registered by the user or any other package and append them? 
What do you mean? Packagist has received the Laravel Seal of Approval. That is a great honour.
&gt; business logic ... put it in your controller Please stop. 
&gt; Exec No way!
Great point about that junior role and learning on the job. *+1*
job gives me money + Experience And adds more to my CV But, unfortunately, in my Country we need a few programmers to have and almost impossible to find a job for programmers thanks for replay
Actually it is. My teams (multiple at once) are usually of 5 to 15 members. Never encountered any big fails. Also, most of developers have experience with these big frameworks
I would think the main benefit is that Twig is really common. Being a Symfony thing, I would assume if anyone knew a templating language then Twig would be it. There is also integration into other platforms. I've seen people use it with Laravel and WP pretty easily.
Why aren't you using composer? Including a bunch of libraries by default is not a good idea. With composer it takes a few seconds to download a new package if you need it. You are manually loading classes. It's 2017, use composers autoloader. Where are the tests? Making changes and then refreshing the web browser is manual testing and wastes so much time. If you don't follow TDD at least write some integration tests once you have completed some module of functionality. There are so many if/else statements it is painful to follow. For a start your framework needs to be layered to separate the concerns. That would help reduce all the if/else. Even in places you have if (condition) { return value; } else { return value; } The "else" is pointless and only clutters the code as a "return" will automatically stop the execution of any further code in the method. There is so much more which could be improved. Take a look at Symfony. It follows modern PHP standards. You cannot create a framework these days and expect people to use it if it doesn't even follow the modern standards of the language it's implemented in.
&gt; I want to initially achieve the $ 150 a month Have you considered an internship somewhere? Regardless if that suits you, create a website for yourself, create or contribute to some open source projects and put that on your site. Learn something specific about PHP/Web Development really well (for example, caching, elastic search, performance scaling), write a [medium](https://medium.com) and get your name out there. &gt; sell licenses to it more than once Thats tough to do with a language such as PHP that already has a plethora of open source libraries. You also have to concern yourself with piracy, so you would need to use something like [IonCube](http://www.ioncube.com) to protect it. Consider a [SaaS](https://en.wikipedia.org/wiki/Software_as_a_service) platform. &gt; what is the script, which could bring me this? Look at what's available first. Find the gaps- what is missing that people need that you could provide? What solutions are out there that do a mediocre job, that you would be able to make into something great? (Don't copy, but reinvent as a better/more effective/efficient/easier to use solution). Good luck! 
Congratulations on implementing the API. Perhaps you might be interested in implementing it as a [Porter](https://github.com/ScriptFUSION/Porter) [Provider](https://github.com/Provider/) for better separation of concerns and other [benefits](https://github.com/ScriptFUSION/Porter#benefits)?
http://www.planet-php.net aggregates a few sources. 
/r/PHP
Cause composer does it pretty welll already 
Are we talking about doctrine repositories or the DDD repository pattern, its 2 completely different things. And judging from the title, we are talking doctrine
* Current work project uses too much home-grown stuff. * When a significant PR with unit tests and everything is ignored for two years I give up.
I [do](https://github.com/ipunkt/laravel-analytics/graphs/contributors) contribute [to](https://github.com/thomaswelton/laravel-gravatar/graphs/contributors) open source. Not as much as I'd like, but it's something. ¯\\\_(ツ)\_/¯ Do you, however?