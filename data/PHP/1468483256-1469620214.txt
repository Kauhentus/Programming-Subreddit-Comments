Pretty sure I'm having the same problem - will have to check if it's still happening with this update. I hadn't put 2 and 2 together and realized it was PHPStorm instead of thinking it was just an issue with running an external display (24" 4k in scaled mode).
First world programmer problems. :)
Use the EAP version.
&gt; What is the purpose of this article? Read the last paragraph :)
`Host` is in the HTTP/1.1 request header. And no, cookies aren't enough. It need's `X-Drupal-Ajax-Token: 1` in the response header. There's even an open bug report: https://www.drupal.org/node/2580191 Problem: The kind of customers who use this corporate firewall aren't very easy to work with. It's nearly impossible to convince them to let through more headers just because you have a piece of software for one department.
I wish! I was actually referring to their monthly subscription fee of $20. Sorry, I should have specified.
Yea
It's not random. They remove everything that isn't in RFC 2616. That's why these customers don't see the Google fonts you use on your site because of the missing CORS headers. It's very frustrating. And you search for bugs for a very long time before you remember to check if the firewall is the reason for bugs. JIRA was behaving strangely. In the end it was missing headers.
Unfortunately this looks quite bad on my machine - seems like antialiasing or cleartype isn't working for some reason.
&gt; If you're just rounding the bits of the colours, and not adding any new information Short version - there is more information in the image. Longer version - PNG images can encode the information in slightly different ways, but commonly the data will be stored as a difference to the previous pixel. Imagine you have a section of a PNG file where the color is getting brighter. And so the pixel intensities go from 100 to 102 over 6 pixels. Column1|Column2|Column3|Column4|Column 5|Column6 --:|--:|--:|--:|--:|--: 100|101|101|101|102|102 Ignoring the first pixel, the delta between the current pixel, and the previous pixel would be: Column1|Column2|Column3|Column4|Column 5|Column6 --:|--:|--:|--:|--:|--: __|1|0|0|1|0 There is not very much information in there. Imagine this 'pixel rounding was done, and now the pixel intensities are now: Column1|Column2|Column3|Column4|Column 5|Column6 --:|--:|--:|--:|--:|--: 101|100|102|100|103|102 Although the image wouldn't look that different, the delta between the current pixel, and the previous pixel would be: Column1|Column2|Column3|Column4|Column 5|Column6 --:|--:|--:|--:|--:|--: __|-1|2|-2|3|-1 There is 'obviously' more information in there. Well it's kind of obvious. Trust me, I'm a doctor - long series of smaller numbers are easier to compress then more 'random' larger numbers. 
Oh, the fonts thing is something a client of ours ran into too. They got Impact instead of the nice custom font the website was designed with. Didn't know firewall admins blocked CORS headers too, that's plain retarded.
Right. We should be stricter when accepting changes and we should write it down in the versioning policy...
Oh snap. I thought I was missing out on some elite PHP freelancing thing I wasn't aware of. Ninja edit: I see they have a $90 version now (yearly) or $9 monthly.
It's in the default rules of the WatchGuard firewall. If it isn't in RFC 2616 you are out of luck. Anything new in this century isn't usable together with large corporate customers. :-(
The first PNG is compressed, after injecting the data I have to render it without any quality loss which results in the huge difference in size. Also pleases keep in mind that the images on the page are rerenderd for the blog. 
This talk from Blackhat 2014 might interest you: https://www.youtube.com/watch?v=BQPkRlbVFEs
While you're right that Drupal is highly modular, your comment doesn't seem consistent with what I've seen working with Drupal for a decade. The third party code you mention is subject to review by the Drupal security team, and while they're not perfect, they have a solid reputation for finding security issues before the rest of the world, which is the best I can really ask from a ecosystems. edit: just to clarify - this was a bit more broad a statement than it should have been. Security team doesn't review all releases, but they are responsible for securing Drupal.org itself, so any modules powering the site itself are reviewed by the team - that covers many of the most frequently used modules. They also review your code the first time you submit a module for full release, meaning devs with full release code on drupal.org have made it passed a basic security competency check. /edit Beyond that, it's very easy to lock down permissions so an admin can't install modules if they're not qualified to do that well. Even more so, two of these three modules are for site building and do very little for a site admin on their own. I've lost count of how many sites I've build, I reviewed all of them yesterday and the only one implicated was a sandbox where I was writing a custom rest integration. 
So... Do you use any third party code? Do you use your own code? Any code has bugs. The best you can ask is that it's found and responsibly handled before the rest of the world finds it. In the entire lifecycle of Drupal 7 there have been two issues of this scale, and this issue impacted less than 5% of Drupal sites. 
&gt; The third party code you mention is subject to review by the Drupal security team That is not the case. Incidents reported for third party code are handled, and many team members do sometimes review modules (or are payed to do so), but it is not part of the team mission.
&gt; Just use the EAP versions, they are free to use and you help them by finding bugs and making the whole thing better. This needs more upvotes. No need to seek out illegal copies, if you can't afford it help them find bugs by using EAP
I can't say for sure but it seems it only filters incoming headers. So request headers are OK, response headers time travel to 1999. 
Since the PHP built-in server is single-threaded, it's a really bad idea to use it in production (or rather: just don't do it, never!) But it's a great way to have a complete PHP development stack without installing any webserver on your local machine.
You don't need to start with a top notch framework, but it would _help_ a lot if you start with ANY framework that at least abides by modern practices. *THAT* knowledge is transferable to other frameworks. If you learn CodeIgniter, you just have to unlearn everything again.
There may be a brand perception issue, here, but can you provide an example of an open-source system with a large eco-system that's been around for 5+ years with a better record? People in this sub seem to like symfony - check out cve-2015-2308 - also a remote code injection vulnerability.
Do you come from a CodeIgniter background by any chance? I do, I never forgot how CodeIgniter does its things, yet I'm using PhalconPHP without any issue and following modern standards as well from PSR to best practices. You don't need to unlearn anything, the CONCEPTS, as I said, are the same. The CODING on the other hand, shouldn't matter at all. If you're aiming to be a good developer the toolbox doesn't matter at all. If you need a hammer you can use a small one or a big one, with pros and cons and you'll adapt. /r/PHP seems to aim to have Laravel programmers, not PHP programmers, and that's what annoys the crap out of me (and luckily to a lot other people as well) Tell me what good there is in starting, AS A BEGINNER, to learn Services, Middlewares, httpfoundation support, request/response abstraction, lack of namespaces¹, awful global class loading, not using composer, and no psr support² There isn't. When you start to draw you learn to do a circle first. The same goes for programming, you learn the basics even if they're behind standards. ¹ Ok, there's use in that and I'd recommend to learn the concept, but not for a complete beginner, yet. ² This is just a standard, guidelines, nothing else. You either enforce it yourself, or not. Doesn't have anything to do with a framework itself if there's no interoperability or module support.
Which generally is a good thing, because it encourages good coding practices. You either learn from it or you go crying in a corner and won't be a good PHP developer anyways. You can look below, he learned from it. Nice, isn't it? If his comment wouldn't exist, he wouldn't know today and maybe not in a few months or years. Also, you need to realize that most people commenting about mistakes and errors just comment because they made the same mistakes in the past and at some point learned, that it's wrong. Hell, probably even someone on reddit told them in a discouraging comment full of insults. Why not share the same knowledge? Going into a world full or programmers you should be prepared for them not being the most social thing you ever encountered.
&gt;Is that really that great? I feel like I do much more rarely character-wise (or grapheme or grapheme cluster) processing than byte wise operations on strings. But that probably much depends on what you do (like working with protocols over network). The operations you manually perform aren't the real advantage, it's that by choosing UTF-8 default strings you're complying with what is the de-facto standard in a way that makes very reasonable defaults that tend to just work in almost any case, but still makes it easy to opt to use other encodings in some circumstances. Right now in PHP if you want to use some UTF-8 strings, but also need some UTF-16 input from some system that only does UTF-16 or whatever then it's up to you in PHP to make sure you only use constructs that'll treat a string as UTF-8, except where you're dealing with the UTF-16 sequences. You have to juggle which is which all the way through the program. In a language that stores the meta-information in the string type you don't have to juggle, the language always knows and string library things can choose the right way to deal with any special cases as-needed without you as the caller having to think about it. In a language that does UTF-8 as the default you're getting all the behaviour available, and making it really, really easy to do what's generally the right thing to do. You're unlikely to notice if you only tend to use ASCII characters anyway, but as soon as you want to include Mr Nguyễn in things it can get a bit more difficult. Noting prevents you still having byte-strings for representing arbitrary binary data - in fact it's a great idea to have a separate string type that has no encoding, it's just a raw byte sequence. It's also great to make sure the language knows which is which. &gt;What are these warts which are so large that it's needs break similar to the py2 -&gt; py3 break? As already stated: Buff string types to store their encoding information. (Or lackthereof). Default to UTF-8 encoding. Fix the stdlib. Use all the features PHP now has to just about build a new one is what I'd say, and make a shim between the new and old for legacy code that preferably can be turned off for entirely new PHP code or any PHP that's already mostly not using stdlib stuff. This is honestly the biggest one to me: it seems pretty bad to me to have to nearly write C to do some fairly simple things in what's sold as a modern high-level language. (Things like the globally name-spaced constants just to switch the behaviour of one function like `JSON_PRETTY_PRINT`, having both `foo()` and `get_foo_errors()`, etc.) Drop the `&lt;?php` tag and perhaps allow it also as an opt-in feature. It's not nearly as used as it once was, and for generally good reasons. I could take or leave this one personally, but I still think it'd be a good idea. Drop the statcache or *at the very least* make it opt-in. Trying to do anything with files gets a lot more interesting in a way nearly nobody mentions in documentation, and makes what looks like trivially correct code 'fail'. Drop php.ini as much as possible. Massive amounts of global config affecting what PHP code actually does or even attempts from one machine to the next is basically bad. Just forcing each project to either accept default configuration or have a project-specific config.ini or something to determine config would help prevent this server-wide state that alters all PHP. Add a proper module system. Connect with the composer people to create a more hygienic module system for PHP and have composer work with it from launch time as much as possible. Even getting some of these would make PHP a much better language in some big ways. &gt;Do you sometimes read newbies code (which isn't using &lt;?php ?&gt; in template files?) … well… that code is instead using tons of echo statements. Which is far worse because lacking highlighting and prone to bad escaping. It is hard to spot there the places where escaping is missing. Using PHP context opening/closing, you at least see that. Well if you use a distinct templating system you need neither of `&lt;?php` or `echo`, and allows for far more automatic auto-escaping and things of that kind. Back in the day when a dynamic webpage was a lot of static HTML and maybe a generated table or two inlining all code in there made sense enough. Much less so now. Plenty of the PHP world, and most of the people pushing the 'best practices' line, are already using a distinct templating system for templating in their PHP projects. There's a lot rejection of PHP as a suitable templating language out there, and rightfully so given PHP's templating features are well behind those of dedicated templating systems now. &gt;In my experience newcomers code rarely uses template engines and tend to make it hard to spot the places where the XSS vulnerabilities are. That's why you need company/project policy and code reviews. People will always do things in dodgy ways no matter how nice a system you make. That's exactly why I'm seeling templating engines and disabling PHP's ability to act as one with `&lt;?php`, because a decently setup templating engine makes it far more automatic to do the right thing. Incidentally why I'm also really hoping PHP can get itself a real module system, the `include` statement and friends have caused so many issues because it's really easy to make something that works with it, but also opens a gaping security hole. &gt;File inclusion is just a problem if you pass unvalidated external variables to include. It isn't caused by echo-by-default though, but really by the fact that it allows easy inclusion at all. True, but the fact that PHP asks you to include using strings to represent paths and that PHP will echo-by-default has been responsible for an innumerable number of breaches in the past. For the longest time even the system of include '/some/top/level' . $_GET['filename'] . '.php'; was still a vulnerability because of the poison NULL byte, and because of echo-by-default you could read most any files on the system (within the context of the server's permissions) using it. Disable echo-by-default and suddenly `include '/etc/passwd';` just crashes the current PHP worker because /etc/passwd isn't valid PHP and can't be parsed. Disable echo-by-default and attacks like embedding `&lt;?php malicious_things(); ?&gt;` in seemingly innocent files goes away. (Yes, that has happened in the wild plenty.) These are issues fairly unique to PHP because of its lack of module system. &gt;Much code written by inexperienced programmers reads like include "includes/" . $_GET["action"] . ".php"; to route GET parameters to different files (with logic, not templates). And much code written by inexperienced programmers in language with real module systems never tries dynamic including/importing of that kind. In Python for example the import system is obviously geared toward hardcoded imports like `import json`. You can import by string name, but even then the Python module system has a defined way of attempting to resolve imports that doesn't allow for arbitrary files to be echoed out to the caller on the other side of a web server. It's not perfect or foolproof, sure, but it's made in such a way that it's much harder to accidentally open massive holes in your system. The fact that Python hides the ability to import a library dynamically from string variable behind a library tends to keep it out of beginner hands because it's not something almost anybody should be doing, and even if someone does misuse it the lack of echo-by-default means most any Python include vulnerability can only do something particularly bad if it's coupled with arbitrary file upload to become a code-execution exploit, and that's harder to do because you can't simply embed some valid bytes in a raw binary that happen to be parsed by the Python interpreter as a `&lt;?python code_execution() ?&gt;` 
You will only know the benefit of Vim when you will actually *learn* it. I recommend Shawn Biddle's videos on YouTube.
The problem is tone. I think it's possible to give constructive criticism and be encouraging at the same time. This clearly wasn't. Your comment is a good example of disagreeing in a way that's respectful and makes me feel good about replying, so more of that please ;)
Any reason to not do this directly in Gmail? 
You'll have to install Node.js remote Interpreter plugin and configure it. After that just add a job the same way you add a local job in `Run/Debug Configurations` window. Same goes for remote PHP Interpreter.
Hopefully, it's because they realised I was being sarcastic. I can't think of a reason why Joomla support is still a thing. Haven't they got a better use of their time/skills?
Nope, it's just for practice. I just learnt basic PHP stuff and wanted to create something that I needed and would use daily. If I'm unable to do this, I'll end up using Gmail one. 
Thanks! Receiving looks pretty easy after looking at the documentation. I'll report back if I'm unable to send an email. 
By using a cron job and https://github.com/PHPMailer/PHPMailer/blob/master/README.md and a PHP script.
I'll check CakePHP out too -- thanks for the suggestion
Sending is actually incredibly easy as well, have a look at SwiftMailer.
Well after a little digging to confirm I'm not crazy, I found a couple of resources that may get you started and explain what I mean. So with IntelliJ based editors (which is what PHPStorm is), you can set up custom command line tools [See here](https://blog.jetbrains.com/phpstorm/2013/07/command-line-tools-in-phpstorm/). These tools can be run manually or linked to other application events (such as pulling/pushing from git) [See here](https://www.jetbrains.com/help/phpstorm/10.0/running-command-line-tool-commands.html). You can also chain them together (I think). PHPStorm also ships with more Vagrant features than just up,reboot,halt, and init. [See here](https://confluence.jetbrains.com/display/PhpStorm/Working+with+Advanced+Vagrant+features+in+PhpStorm). Note #8 in that list. You can set up the PHP interpreter living in your Vagrant machine as a "Remote" (because it's accessed via SSH) interpreter, which behaves just like a local interpreter. That means you get things like direct XDebug access to it! Now, when you set up your Vagrant box to be integrated into PHPStorm it also sets up an SSH connection profile that you can use to set up Remote SSH External Tools. [See Here](https://www.jetbrains.com/help/idea/2016.1/remote-ssh-external-tools.html). These also behave like custom command line tools and can be bound to keyboard shortcuts, editor events, etc. So say for example you have a Gulp build system in your Vagrant file and you want to have a run/debug configuration for post-build files. You could set up a run configuration that would first run your Gulp build commands before starting your remote debug session. I haven't used it *that* extensively because my primary PHPStorm environment is at work and the project is stuck in a time warp back in 2007, so if I'm wrong someone feel free to correct me. I *have* used external tools in that way with PyCharm, PHPStorm's sister Python IDE (which is also amazing). It saves a lot of time for when I want to, say, connect my debugger to the remote Python interpreter on my Digital Ocean account, but before I do that I want to kill gunicorn and nginx, and run Flask in dev mode so I can access the debug features. Then after it's done, it restarts nginx and gunicorn and my site is back up like nothing ever happened.
The question is wether he really needs to convert everything - writing the information (title, sender, content) should be enough for his purposes.
eh, will find that plugin. but sometimes it's not just node packages, kinds like composer, testing. usually, i need to vagrant ssh first, then do composer / npm install
So, is the distinction between the two that the former has the line break evaluated to the actual like break character before the the decoding, while the latter has the two characters "\n" passed to the decode function?
Go straight to 7
Don't let anything but fear and a weak prostate stop you, go for the glory.
It doesn’t really make sense to go up the ladder because valid 5.3+ code is—except from very few corner cases—also valid PHP 7 code. There isn’t really a hard break anywhere. Newer versions mostly add more features, but they don’t break existing code. See “Migrating from…” for details: http://php.net/manual/en/appendices.php
As the other says, just go straight for PHP 7(.0.8). At my company we did that when 7.0 was first released, we have a relatively large codebase and only encountered a few problems. Don't remember exactly what now but I know we had one class named 'String' which is a reserved word in PHP7, that and a few other problems which were resolved within like 1 hour. We saw a +100% performance boost by upgrading which made it totally worth it. :)
XAMPP would be a nice app to start with. https://www.apachefriends.org/index.html
Good to know. 
Best way would be to teach him to install a VM with Linux (preferably Debian because it's a server and Debian has proven itself being more or less the most stable and best server OS) so he does not only learn how to code PHP but also learns something about client-server architecture, open source software in general, Linux and the GNU tools in particular, and how to set up web servers using Debian. Btw. if he is interested in PHP only maybe simply install it on his computer and tell him how to use the simple testing web server [that comes with PHP](http://php.net/manual/en/features.commandline.webserver.php) ([RU](http://php.net/manual/ru/features.commandline.webserver.php)). I use this thing for development, it's great and does all you usually need for testing your PHP applications.
I would entirely rewrite it in PHP 7 without copying over anything except the raw data and the general concept of the application (no code, no concepts). Since 5.3 there were some huuuuge changes in compatibility general functionality.
He's only 13 or 14. I think a Debian VM is a little too much to ask for him right now. Baby steps. :) Didn't know PHP had a built-in Webserver these days. I think I will start him off there. Thanks!
&gt; Baby steps. :) Nah, throw him in the ice cold water :) But yes, you're right. Setting it up entirely by himself wouldn't be the best idea. But maybe assist him doing that? There are plenty of remote assistance tools available for Windows (there is even an integrated tool for Windows-to-Windows remote support). &gt; Didn't know PHP had a built-in Webserver these days. Yeah ... I know it for only around a year or so. It completely changed my testing environment since then. It is a part of PHP since version 5.4.0.
Why? PHP 5.3 had namespaces, and there is a very good chance the code OP currently has is of decently quality (for 5.3). Most of my apps were completely compatible with 7, and the ones with problems were easy fixed. A rewrite would be a total overkill. 
Store as integers using the currency's "base" unit. This means that the conversion varies by currency - USD is by 100 (cents to the dollar), JPY is by 1 (native), BTC is a million I think, etc. I recommend using the 3-character ISO code in a char(3) column in the same table to indicate the currency. Avoid converting to floats until rendering, which includes representing the data as JSON (or other formats). Your call if data is going into CSV reports; I've handled files from dozens of payment processors and banks, and it's a mix (I prefer consuming integers otherwise I have to convert the float into one for storage, and doing it wrong can create precision loss issues) There are a few different money libraries that handle most of this stuff automatically. It's worth noting that this isn't a PHP-specific problem at all, every language is potentially affected since that's just how floating point math works. There are ways to avoid it, but this is easiest and most portable, and has the fewest ways to screw it up. 
Very good advice
I love how now everyone is apparently me)) Actually, where did you get the "only posts about PHPixie" part, I mean the history has like 1 post. **Also, just in case you didn't notice the article is about the old version of PHPixie (like 2 years old), so if anything this article is just misinforming.** Why would I ever have a fake account to promote an obsolete version ? But I guess the pitchfork crowd has become to dumb to actually read the article before bitching.
A VM is definitely better in the long run, but for a beginner I'm afraid it could be a little overwhelming.
I would love to hear the case that throwing everything away and starting from scratch is going to be quicker than just refactoring the existing code.
Just apply for all of the dev jobs you think you could do (most probably junior roles?), whats the worst that could happen and you might even get a job out of it!
To be fair, the fact that `Zend` is in the name has been nothing but trouble so far, since anything the company does is directly associated with the framework :-\
Best answer is don't do it in php. Use python and its decimal module instead. Yes it's completely worth learning a new language if you have to.
Well, not "always". Sometimes it is useful to use a smaller unit, for example petrol is often sold in tenths of a cent.
As opposed to using the methods already outlined above? Fanboy much?
No I've been using PHP for 12 years and python for 8, I've also work extensively with Golang and Node.js. There are lots of great answers here, and I'm sure they'll work in the short run. But the best answer and long term solution is don't do it in PHP, use Python's decimal module or Go's strict typing. Money shouldn't be handled by loosely typed system. I know because I've made this mistake years ago, I had to handle money before and I made the mistake of using PHP. There's a reason why no financial service will ever use PHP to manage their money. But of course I'd get down voted by not automatically assuming PHP is the perfect tool for every job out there. This happens in r/python as well. I get it.
Stocks and oil are decimilized down to pennies. You may sometimes see your average price per share contain numbers smaller than a penny but that's an artifact of the averaging, not the pricing.
is it just me who thinks oAuth is just a terribly bloated idea and to avoid it like the plague? Everyone seems to be using it and I just can't understand why
&gt; No-one said it would be quicker to rewrite than to refactor. So you said you'd rewrite it......because it would take _longer_?
Ive never had an issue dealing with money calcs in php, ever. Interestingly some of the best shop software is written in php: Magento, Prestashop, Etsy, ZenCart, WuCommerce, etc. Followed by Ruby with sites like Shopify and such. Though ultimately the language doesnt matter. Money has been handled in about every serious language effectively well, as well as used poorly by those using the tools provided to them by that language. source: Ive built at least 15 store fronts and shopping carts with varying payment gates, international interest, transactions, and receipting syatem; all in php (4 through 5.6) 
Using BCMath it's possible to handle floats without actually using the native floats in the system. Even Magento has rounding issues because misuse of the float type. But there was some effort to change it: https://github.com/magento-hackathon/Implement-BCMath
Go straight for 7. But first, how will you know if it works right? Get as much of it covered by automated tests as possible, then run the tests on 7 to see if they pass.
hey, didn't know about /r/laravel (should've searched first =). Yeah, I did it using query builder, I already had it working in sql. Thank you!
&gt; So you said you'd rewrite it......because it would take longer? Because to have a clean and modern codebase that is maintainable and optimized for PHP 7.x instead of being legacy PHP 5.3 code that is not optimized for modern days PHP. PHP 5.3 is more than 6 years old and in EOL since nearly 2 years. If it were 5.5 or 5.6 code ... okay, make it work with PHP 7.x and refactor piece by piece. But finding someone who knows heavily outdated PHP to maintain it? 
It actually gives a set of generic solutions for secure 3-tiers communications between a service provider (some web application), a consumer (some other web application) and a an owner (the 3rd tier, the living person) which may use the consumer application via its identity in the server application, without the need of an SSO nor identity synchronization. The main problem is that it's overly complex, not in the way it's working (it's actually rather easy to understand) but because security matters a lot, and missing a single validity check, in any of the server or consumer code, might cause serious security issues. That's why using a good and mature API for doing this is very important. But the idea is rather good, it's like 3-D Secure (bank securization mean for internet paiement) - in order to validate a authorization or any other operation, all 3 tiers must be able to share a secret with the 2 others, but without the 2 others knowing the secret which is not for them, and each authorization requires all tiers to exchange validation with everyother one, it's the Graal of security, when correctly implemented.
Watch out for that potential SQL injection.
This is the correct answer. Fowler did it right.
Just want to point out that PHP is the most used language in web development, ie. There are more pho based Web sites than anything else, and since many of those handle money, php is being used quite a bit to handle money, by simple deduction. Also, all languages have the same problem with floating point arithmetic, but not with dynamic typing. So the point is, you can learn to use php to handle currency without rounding issues, I myself and many others have been doing it for a long time. Python and Java are great for what they do well, but suggesting a project should be re-written in another language because it has a payment system is fatuous.
&gt; legacy application 5.3 Chances of it having code coverage on tests... -&gt; 0.1%
The exchange rate is not a float value but a decimal value. You can use the [BCMath library](http://php.net/manual/en/book.bc.php) for doing currency conversions. This never converts the values to floats, but can do accurate calculations with decimals. You can specify the number of significant digits to use.
We have a machine with 5.5.36 where we can consistently reproduce the first case in the post, but perhaps something else in our environment is acting up. Either way it sounds like PHP7 handles this properly, because of course that a line with an actual line break shouldn't parse, so it's all good.
Pennies. Store everything as an integer of the number of pennies. Only convert to float when you absolutely have to (which is hopefully just for display formatting). I can't even count how many rounding discrepancies come up at my day job due to garbage code throwing around floats and strings.
now is a good time to start. 
I don't disagree, but you said use the smallest unit available in the currency, and I'm saying something you want a unit smaller than what's available in the currency.
&gt; Store amounts as strings (for some cases you can use integers; strings are better) I would recommend against that one. The moment you go down that road you remove the ability to the DB engine to handle calculations for you. This can be a huge deal if you need to do basic aggregate math like sum() or avg() on a column. With strings, you'd be forced to potentially bring in a large set of data to be calculated at the PHP layer. Personally, I just default all my monetary fields to numeric(15, 6) so I have enough decimal places to run conversions in the SQL without losing precision or going into rounding errors.
You mean Superman 3. It will probably end up more like Office Space though :-)
I didn't mean that you hate on PDO, you hate on colshrapnel senselessly and insulting. I'll show you my _assumptions_: &gt; and shows just how immature you are as a developer. Calling someone immature because he doesn't agree with you. Now that's mature. &gt; Let me know if you actually have anything useful to say. Implying you said something useful and he didn't. Sounds pretty arrogant. &gt; A mentality commonly found among children. Calling others children because they want to sort out old technologies. Very mature. So, in contrast to your stupid insults, let's look at your _arguments_, shall we? &gt; And unless you actually need to interact with multiple types of databases, PDO is kinda overkill and not necessarily the best choice. PDO has little to no overhead to MySQLi. Look it up. It's like ~2.5% of a few microseconds for the most queries you run. I wouldn't know where PDO would be _overkill_ for anything. The API is less verbose than MySQLi's. &gt; PDO being a general interface to interact with many types of databases, won't be able to support every feature in all of them. Wrong. PDO uses no own QL, every feature of every platform is accesible via native queries. &gt; So stating "Yes, it's different from the old garbage, but it's the only usable interface." is simply false Not "simply false", saying something like this tries to encourage people to go for the right solution directly. If someone comes and says "Yeeah, but MySQLi has it's use cases at X, Y and Z", which is _wrong_ because there is no use-case, that PDO can't handle just as well as MySQLi, then people might choose MySQLi. That's actually pretty bad, because we're striving to unify the interfaces and APIs we all use in PHP on a daily base and PDO is one core part of that, unifying database access of every developer using PHP. &gt; I like how you completely missed the point of my post. So enlighten us with all your superiority! &gt; I don't have a problem with PDO being promoted and suggested, but it should be for the right reasons. The right reason is that it's simply the better API, which has many reasons, some personal ones, many facts. It's just obvious to most developers that know PHP well, not to you as it seems. &gt; but you could easily get rid of those inconveniences by using a wrapper. Like...PDO? Why write a wrapper when you already have one that works natively and nearly at the same speed? &gt; Exactly what he's suggesting to use for PDO, a wrapper he built himself no less. Honestly, I don't agree with wrapping PDO like he did, but it's pretty common to do something like class DbConnection extends PDO { public function execute($query, ...$params = []) { $stmt = $this-&gt;prepare($query); $stmt-&gt;execute($params); return $stmt; } } That's 10 lines of code for some syntactic sugar and it comes down to personal preference. The wrapper you'd need for MySQLi that gives the same feature would require three times that code. &gt; PDO supports most of the functionality found in MySQL, but not all while mysqli do. Wrong. See above and below. &gt; Could be the same for other databases as well, but I don't know. Highlight that _I don't know_. Exactly, you don't. It's wrong. How about you learn about PDO before you go insulting people in forums? &gt; What I do know is that you need to read up on this and get your facts straight, because you're clearly misguided in your beliefs. Read this comment and tell me that again. The only one not knowing his technologies here is you, brah. The only one misguided here, by arrogance and stubbornness, is you. &gt; You do know that mysqli is object-oriented as well, right? It just provides a procedural interface as well. Having "class" and "new" in your code doesn't make your code OOP. MySQLi feels like you're using `mysql_*`-functions with a static wrapper. Renaming `mysqli_` to `mysqli::` doesn't make your code OOP. What you don't get is the fact that PDO is PSR-2 compatible while MySQLi is not, that's why MySQLi feels like an alien API inside most PHP projects while PDO feels native. What you also don't get is the fact that PDO doesn't use an own QL. You're just plain wrong if you're saying MySQLi supports features that PDO doesn't. That's not the case. There's _no_ single feature that MySQLi has that PDO lacks, since you can run native queries for everything and on every RDBMS. Also, the way you bind parameters to MySQLi is verbose, in PDO you don't have to specify types for your arguments and you can used named parameters, which MySQLi lacks completely. So, we have one API that fits into most frameworks, has little to no overhead and supports all features and we have one older API that's based on old naming conventions and lacks some common features like named parameter binding. And you're going around insulting people for realizing this because you didn't. I'm currently running some benchmarks, I got some first results already, but I want _clear_ results that's while running it will take a while, but when I look at my smaller test results, your arguments all seem pretty invalid. PDO indeed takes like ~2% (of 0.0002s) time more to connect to the database, but e.g. most prepared statements I run are faster than MySQLi's and in general, they don't make a great difference, it's almost the same speed for both. As soon as I got the results I'll update this and prove you wrong completely. PDO is superior to MySQLi. Face it, accept it, live with it. Or go on insulting people here because they don't agree with your beliefs, your choice, who cares. 
Can MySQL handle 98,473,736,374,848 USD in Cent?
No worries.
&gt; This can be a huge deal if you need to do basic aggregate math like sum() or avg() on a column. Depending on what you're doing, that can go both ways. Example: One of our older projects has a large table of transactions in many different currencies. One row has an amount of €800; another ¥600. Someone made a fancy dashboard that summed them. The dashboard looks great, but it's probably best not to ask what currency *exactly* it's denominated in. :) Of course, that doesn't mean you can't usefully do some form of `SELECT sum(amoun) ... GROUP BY currency`, and we do that all the time. So yeah, you're quite right, and I've edited my original post to make that clear. On the most recent project I worked on, I opted for a DECIMAL column and a FK to a currency table, and it's working great. Edit: Wrote some nonsense, then fixed it. Sorry, sleepy. :)
If you're using bigint columns, yes. 
Considering that 1) the way various currencies work is very fixed and stable and 2) it's probably the most critical thing to not get wrong why wouldn't you go for structured data stored in a system specifically designed to hold data well and correctly? JSON is for moving info from A to B, not keeping data in-place in the long term. Maybe you haven't had issues yet, but here's a better question: What's the recourse if things do go wrong? In a good ACID compliant database with transactions and various options for backups you have many ways to clean up or restore mistakes. In a JSON string? Good luck with that. Best you can hope to do is create your own backup / transaction / changelog implementation that no doubt pales next to a mature RDBMS's.
weird. My PhpStorm is not getting any notification update. Still working as good as before with 2016.1.2
Hell of a story. Good detective work.
Read [this](http://verraes.net/2016/02/type-safety-and-money/) post by Mathias Verraes which shows the specific example of an Exchange.
Thank you! It was quite the journey. Learned a lot, personally. Have the chance to share the findings with others now, which I think is even nicer.
Time for a name change :)
In addition to other alternatives, I am also using https://styleci.io. Great tool and it can FIX your code with a single PR. 
Out of curiosity, how would you convert "1.99" submitted through a form to Money, without going through a float. 
When you do full updates on a data-set it's really the way to go. A new index can fully build up while the other is still in use. This is also very handy in case of index corruption, instead of fixing an existing index, you just create a new one and throw the old one away. More about it here: https://www.elastic.co/guide/en/elasticsearch/reference/2.3/indices-aliases.html
These days it's Symfony 2.x-3.x (latest is 3.0), Yii 2 and Laravel 5.x and really depends on your needs. If it's a big project - go for Symfony or, optionally and you have a flood discipline code wise and need a fast start, Yii 2. Laravel is more for medium or small projects - long term maintenence is a big bitch and community packages are sorelly lacking in quality department. I yet to find an administrator panel generator that does not need to put a month or two worth of effort to get it at least up to decent level compared to Symfony's Sonata or Yii's Gii code generation (stock is good, but the meat is in community add-ons). I just spent 2 days reviewing Laravel packages and every god damn administration package had instalation issues - dependencies broken, packages being very basic (essentially just a copy-paste of a class name and a constructor method in to correct directories), or the front-end part just not working due to package dependencies being wrong and any attempts at fixing it just broke it even more and Google having nothing on it. So my advice on Laravel is going to be to take the marketing with a spoon of salt - it is good for some things, but as soon as you start to have really custom stuff - maintenence goes through the roof, testability with static helpers and stuff goes to shit and you end up actually maintaining a few packages on Github because otherwise you can't do your tasks (Postgres GIS data handling and various data types - we had to rewrite the existing stuff because using it in production was a suicide - it took months and cost the client a lot of money). So choose carefully. Despite it's advertising, it's usage is pretty narrow and docs are not good, for community packages there are rarely any or they are useless - had to read the code a lot. Zend framework, at least in my part of the world, became irrelevant. If you see it, it's in heavy corporate environment and at that point you probably could end up writing in Java - makes almost no difference at this point. New projects on any Zend Framework version - haven't seen that in 3-4 years now. Also there are micro frameworks like Silex, Lumen, Fuel and others - they are quite a lot, but those are for small projects usually (you can use one to build big, but you have to be damn sure you are a good software architect before you go that route - it's easy to screw up, PHP does not hold you hand,it chops it off ).
It now uses PSR-4 autoloading, and Composer now installs the dependencies (`/vendor` dir and `composer.lock` are now `.gitignore`d. PSR-2 is now also adhered to. SQLite branch is underway, and as for an MVC, the company I work for disagrees with this point (I personally would have used Laravel from the get-go, but whatever the boss says)... And thanks for your comprehensive feedback!!!
Good point! Pimple, the Laravel container, and PHP DI (the containers I use) only allow closures so that's what I stuck with for the tutorial. Pimple [explains why they don't allow any callable](https://github.com/silexphp/Pimple/blob/1.1/lib/Pimple.php#L54); makes sense if you allow setting parameters I guess.
That seems like a problem that is fairly easy to solve though - just don't store parameters and services in the same array. This should be happening anyway. Why would you use one generic array to store several different types of things?
Are you guy's on aws? Do you host your own e.s. cluster? or do you use aws hosted solution? just curious.
Mmmmm.... Maybe that's why my test failed.
Your history as a shitlord is well documented by this point.
The nikic knows all.
We did a trial on AWS, but they run a very low version of ES (1.5 iirc), which was not acceptable.
The Money library accepts strings, so the obvious answer would be an arbitrary precision math library such as GMP or BC Math, which is what the Money library uses internally. Something like `gmp_strval(gmp_mul($input_val, '100'))` should work, or `bcmul($input_val, '100')`. (If you don't have an arbitrary precision math library available...well, you should install one, because otherwise you're going to really struggle. Although I think BC Math at least is bundled by default. Still, I guess you could always just do `str_replace(".", "", $input_val);`, which would work for your given example at least. :)
That's amazing! I could never get phpcomplete to work for me, but this just worked straight off. Thanks for posting.
While I would absolutely love for this to be true, clever I was not. Typo is fixed, thank you :)
FYI PHP-DI allows any callable (not just a closure): http://php-di.org/doc/php-definitions.html#factories
I'd take the question the other way: why separate values and objects? I've never seen any gain from that, only confusion. The problem of allowing any callable is easily solved using some sort of wrapper or marker. Here is how it works in PHP-DI: $container-&gt;set(factory([FooFactory::class, 'create'])); // No need to use factory() for closures (shortcut): $container-&gt;set('Foo', function () { return new Foo(); });
I'm 20 and what is this ?
That problem is solved by not using ArrayAccess, which is a horrible horrible hack that only results in more confusing code.
BTW, thanks for Flysystem. It's made keeping up with my company's constantly changing file-storage needs waaaay easier. 
Guess the link title is a bit misleading? PHP Integrator is a lib for static analysis (in form of an Atom package), not an editor or an IDE in itself? (FWIW/OT: A free and somewhat viable alternative to PhpStorm would be NetBeans.)
This is awesome. I just started using PhpStorm and haven't been liking it coming from vim. Im going to give this a try. 
&gt; You are only seeing the problem through your point of view of a very simple use case. All my apps are modular... so it's not *my* point of view. It's the PoV of the article. Show me a "complex" example with modules, I'll show you a simpler solution with basic classes. In fact, modularity and reuse is why I stick to basic classes for containers, because I didn't want my app modules to be tied to a *stringly* typed pseudo-object, I wanted simplicity, clarity, performance and type safety. As your app grows, the value of using "magic" shortcuts for basics like object instantiation decreases significantly, and you prefer your IDE to point out errors for you as you type, before you have to run the app.
I misunderstood what you were saying in your previous post, so you can ignore this. But if you are interested... 150.25 * 100 = 15025 15025 / 100 = 150.25 This allows you to remain the cents portion of currency without having to use strings or decimal DB engine types and instead use bigints. No need to separate cents from dollars, decimal from whole numbers, etc. Using floats and integers are completely OK. I work for a silicon valley company and this is the approach we use.
Take a look at "Flight". It's a microframework and there are some examples on their site showing you how to send JSON data. (on my phone right now, can't give u the direct link to the docu, just google 'flight php')
I think Equip is great. We have several APIs deployed using it. Full disclosure: I'm a founder and contributing member.
You don't necessarily need a framework. Just depends on how you want to go about building the server side. Personally, I would use something like Zend or similar. I say you don't need one though because your app can just hit a URL and that URL will take the request and process whatever you want. Then return a Json encoded array in PHP. Example: json_encode(array('success'=&gt;true, 'error'=&gt;0, 'data'=&gt;array('stuff'))); Your URL might look something like appsite.com/login/index.php?action=forgotpassword
I'm a PHP dev, and I'm just starting to get into mobile development now as well. I'm writing my API with Laravel 5. You'll be well on your way after working through this course: https://laracasts.com/series/laravel-5-fundamentals If that seems like overkill (I don't know how complex your app is), you can try [Lumen](https://lumen.laravel.com/).
It is a pitty that there is no example project (AFAIK) that has a default setup so we can just open up some files and play with it / figure stuff out.. i dont want to follow 400 lines of text to get something up and running!
Wordpress?
Laravel and check out APIs that don't uuck, Google it. The book will write the API with you.
Huge fan of bolt
Grav CMS just released v1.1 which is nice to use if you know html.
I realize this is a PHP subreddit, but since you are a swift dev, why not use swift on the server? http://perfect.org/
Lumen did a great job as my API backend but I ended up migrating it to Laravel just to avoid some extension compatibility issues (stuff not fully ported to Lumen or required workarounds that seemed a little iffy). That said, [Dingo](https://github.com/dingo/api) and this [JWT-Auth](https://github.com/tymondesigns/jwt-auth/) extension helped tremendously. As well as documenting the API in [Swagger](http://swagger.io/) and applying [this nice responsive theme](https://github.com/jensoleg/swagger-ui) to the generated docs. Some things I had to learn on the way were proper response codes (do you use 200 or 201 for creation of an item, etc.). Also having a nice app for testing like [Paw](https://luckymarmot.com/paw) proved to be useful. The API is now working nicely with iOS/Android apps as well as some web-based items. JWT makes it really simple to have permissions set in the API token itsself (vs. using token to look-up a user then figure out their permissions, etc.). This is my first "real" production API so I'm not an expert by any means, but hoping some of the things I listed can help you along your way. Good luck!
Actually, now I try it I do get that behaviour if I try to complete a partially typed method name. So this works: $session-&gt;&lt;C-x&gt;&lt;C-o&gt; And produces an omnicomplete menu. However the following doesn't work, despite `start()` being a valid method: $session-&gt;star&lt;C-x&gt;&lt;C-o&gt; And produces the error you're getting. Also, have you run `:set omnifunc=phpcd#CompletePHP`, or put the documented autocmd in your .vimrc prior to loading the php script? 
[October CMS](http://octobercms.com) is nice for the developer, requires some set up to make nice for the client.
SilverStripe CMS is really nice for the developer, full-fledged-ORM and admin interface extending. 
When I first started using Laravel, I thought so too, but the more I develop with it, the better I find the documentation. It's almost always got an answer to exactly what I'm trying to find out, rather than trying to cover every concept.
Slim3 is super easy to get up and running 
I would likely use it at some point if it was easy to install. This seems much easier than having to make my own api to interface, or to use techs like protocol buffers, apache thrift etc..
Same here. However, one huge problem for me was.. 1. The docs were quite different two years ago. 2. My understanding of PHP, OOP, and standards were, though I thought awesome, minimal. There seems to be a direct correlation between my PHP skill level (and experience with the built-in tools) and my understanding of the Laravel docs.
Very nice to see people following the [container-interop](https://github.com/container-interop/container-interop) approach of getting people on board independently of the FIG.
See equip/project for a starter.
Good question! First, I would never dream of competing with google head-on when it comes to broad search. Their scale is unattainable except for the largest players. Though DuckDuckGo is making good efforts there. I see an opportunity to compete in narrowly-focused domains. In this case, PHP. 1. There is a lot of crap in the google index. Lots of SEO players (I'm looking at you, w3school) 2. Pages and domains searched are not human curated, but rather up to a magical algorithm. The PHP search engine would have human-curated domains, urls, and RSS feeds. 3. You don't have specific facets to search with google. it is always the same (news, images, videos, etc). I would like to see PHP-specific ones (Code, Open-source, Jobs, etc) In short, I think one strength of a Search engine dedicated to PHP would be the following: - human curation (keep noise and spam out of the index with moderation) - small index size makes it easy to manage / backup / syndicate - highly customized facets to make searching much better / faster (news, blogs, code, open-source, jobs, etc) Thoughts?
Start pulling too much and google will shut you off or make it expensive. To that end I've already written a generic cralwer to index domains and push it into solr.
Laracasts does a much better job of simplifying stuff and making it understandable for me but the docs helped me go a lot deeper. I'd say they work together so maybe Taylor is relying on Laracasts a bit so he doesn't have to make the docs so thorough and change them every update. I think laracasts is pretty crucial to learning it so I consider it part of the docs.
You are onto something with your conspiracy theory. (Even with the name confusion) 
I've put the `set` command in my .vimrc. Neither partial or empty command works for me.
Jeffrey (Laracasts) and Taylor (Laravel) are friends but they are no way in it to rip off the community. Taylor doesn't get any kickbacks as far as we know, unless you count the number of people who purchase things like Laravel Spark thanks to Jeffrey making such a great tutorial on how to use it. The Laracasts videos reference the docs when needed, so implying that they are extra documentation is bogus. If that was the case, Laravel.com would be plastered with links back to Laracasts (it's not) to maximize referral revenue. Jeffrey definitely frequents Reddit, so hopefully he'll chime in.
Why capitalize app tho
I've never had any problems finding PHP related info on existing search engines...and I don't think there is a php "universe". There's info scattered around all over the place as well as info that's neatly organized in some places. If you wanted to do something helpful, maybe find the useful info that is scattered around in random places (usenet, blog posts, forum discussions, php comments on php.net, etc) and create an organized website as a resource.
Nice for developer? BoltCMS and CraftCMS! Pretty for the client? Drupal and WordPress! Bolt and Craft are the shit. Just finishing an administrative app for a 501c3 built on Bolt.
I'm curious what the issue with a framework creator spending their time on a paid training site vs. writing free documentation would be anyway?
There are definitely holes in the documentation and I found that the best learning documentation you will get is by checking out the source. As bad as it sounds you will find many hidden features or functions that don't exists in the documentation, so take a look around :)
Drupal is on my list. Only CMS I've found that is actually customizable. You can modify the admin panel and even turn it into a sort of online-databasing GUI if you want to.
The docs do a good job of explaining the concept of how something is suppose to work. The just need better explanations of how they're suppose to work.
I agree. The Laravel codebase was very approachable.
Third that. 
Bolt is so good. 
Well, you could also disregard visibility constraints with reflection. The more flexibility a language gives you, the more you have to rely on self discipline to not shoot yourself in the foot.
[removed]
Visibility says more about what one should be doing with a property / method than what one can be doing with it. Always has. If I make something public it's because there's intention to use it publicly or set it publicly. If it's protected, the class foresees extension and promotes extending it in those areas. If it's private, it basically means, don't mess with this. With respect to testing, what's documented, what's interfaced (necessarily public), this all makes a lot more sense.
Thanks for the feedback. I always want the docs to be better and have been pouring a lot of time into them lately. As others have said, I don't own Laracasts nor have I ever received a single penny of Laracasts profits from Jeffrey Way who is the owner.
By setting visibility you declare how you want a class member to be interpreted (implementation vs. interface). "Meta-APIs" poke holes in the restrictions, but it doesn't change the intent of the author. It's basically like the legal system. You can poke someone's eyes out with a pencil, but then you can't say "hey, blame whoever made this pencil." To be fair, I can't quite figure out a good use case for re-binding closures. I've used the feature a couple of times, but mostly out of my own desire to be fancy and obscure in experimental projects.
It'd be nice if reflection only worked when a global DEBUG flag is set on. The original scope of reflection was: - static code analysis - documentation generation - testing/debugging All dev-time use cases. Then probably this proliferation of reflection-abusing APIs wouldn't exist, where the entire underpinnings of your app, right from the bootstrap is "let's reflect everything".
But some of the introductory docs are embarrassingly short. How does one contribute to documentation? I may be down to add some relevant content.
* https://github.com/amphp * https://github.com/icicleio * https://github.com/reactphp
Oh man, I *wish* I had the time to plan and execute a migration to ZF3, or even any other well-supported enterprise framework. As it stands, my overhauling of the current ZF1 system is already a year overdue compared to my previous timeline, and I have my hands full normalizing the database and writing a new DB conversion app from scratch (because *of course* my company's data comes from a legacy system that uses dBase DBF files as the backend).
Drupal 8. 
This is ridiculous. If you want strong adoption of a product you contribute to, putting it behind a paywall will not help that. It will fill up your pocket and only those of the "haves" will use it, and the "have-not"s will use something else because they leave from frustration. Also videos take more time to watch than scanning through docks with useful information. Ultimately docks need to be written by people with technical know-how but the ability to write concisely, but they have to walk through all the steps on their own along with access to the people who wrote the software so it can be usefully documented. Generally good docks require a multi-phase / multi-pass approach until they reach a certain maturity. 
Craft CMS
Silex or Lumen might be good choices, I prefer slim, but it does not have any db or orm out of the box which might not be the best for someone who wants a framework that does most of the work out of the box.
Completely agree. I'd have zero issue with it - the tool and it's docs are free and open source, which is generous enough. Further learning for us professionals? That takes even more time and money, so I would view that as fair. Take Spark for example too - the people bitching that should be free too are entitled little brats.
Yes, the subclass needs to at least implement the parent's public methods. The subclass can add additional public methods or implement additional interfaces as needed. 
&gt; `AutomaticallyDriveIntoThings` That's a little bit on the nose and probably more pragmatic to say that the `Tesla` class implements its own `drive()` method.
&gt; Can the child class implement a new public method that the parent doesn't have without breaking this principle? Depends. Did you modify your client code to use the public method found only on the child class? Then no. If you didn't, then it's fine. Except that begs the question, why *did* you add a new public method to the child class? Does some place else in your code use it? If so, what happens when you substitute that class for a different sibling class that doesn't have that method? It will blow up. So just add that method to the other sibling class? What if it's not relevant to that class? How is it supposed to even implement it if it's not relevant? This is where you start getting into interface segregation principle, but typically if you find yourself with sibling classes with different public methods, you have the wrong abstractions and something is wrong with the design of your code. Also, Im not sure why LSP is limited only to parent/child relationship compatibility. Surely sibling compatibility is just important.
Ditto, and you also get a wonderfull opportunity to update the documentation about what you just learned reading the source
Drupal would be the last thing I'd consider as "pretty" or good UX for a client.
Aren't the parent's public methods already available to the child just by extending it? What other work is there to do?
Being able to substitute a child (derived class) for the parent makes sense to me, but unless I'm misunderstanding the video, it is says you must be able to substitute the parent for the child. So if I have code that makes use of a function only available on the child, I could not substitute the parent because it is missing that method. If that is a violation of LSP, then I guess I don't understand the point. 
To stick with the Telsa theme, say I want to have a class for an SP90DL which extends the SP90D, essentially adding an enableLudicrous method. I have client code that engages that method. I could not swap in the SP90D class because it doesn't have ludicrous mode. Is this an LSP violation?
Look up the apache documentation on mod_rewrite. You'll need to be comfortable with regular expressions. Why would you want to redirect in that direction, though? The standard for some time now has been to get away from query params in the URL.
It's a noble idea but I don't see it taking off. For very code specific questions you can always search directly in StackOverflow if you must, and for just about anything else most decent software engineers have already developed a pretty strong Google-fu to find what they want quickly and precisely. For it to be competitive it would have to *dramatically* (x10) better than Google at its game, and even then you'd find a lot of resistance (devs have been googling shit for decades). Plus, all the strengths you mention are implemented to some degree in DuckDuckGo (e.g. custom bangs). If you are building it for fun, go ahead, but don't pursue it as a startup opportunity.
That's very subjective of course: How about http://jarves.io/ ?
Well, just a suggestion, I would probably make it something like site.com/users/username or something, because site.com/username could be literally anything (file.php, some-blog-post-slug, etc). 
Ah, great! At any rate - this isn't too hard. Just look at mod_rewrite docs and it's fairly clear. Again, you'll need to be comfortable with regular expressions, but the docs are pretty straight forward.
I don't think a rewrite is going to do what I need. The way my site is structured causes issues when using a rewrite. I need to redirect it instead. 
Rewrite can redirect. Like I said, read the docs!
LSP is where any class extending T must do so in such a way that anything consuming a T must be able to accept any of those extended classes. So you can add additional methods, but you can't modify the signature of methods that exist on the parent (including making them inaccessible) On your example, assuming your consuming class has requested a P90DL, it can't safely accept a P90D at all. However if it requested a P90D, got a P90DL (fine so far) and enabled ludicrous mode, you've Done It Wrong because the method doing so doesn't exist on the class you've requested, only on the one you happened to receive. That's not really violating LSP because that's more specific to class definition, but related and still likely to cause problems for you eventually. 
There is an extension called [laravel-ide-helper](https://github.com/barryvdh/laravel-ide-helper) which generates a single file containing typehints for your whole project, I use it with PHPStorm to bring typehinting to the Facades and it also worked when I used sublime text.
OK thank you. Then I think the video is explaining it wrong, as it seems to say: you must be able to swap in the parent, in place of the child. [slide](https://i.imgur.com/bz8rU63.png) 
You are confusing Stack Overflow with /r/phphelp. It is not about skill levels. Questions asking for a code rewrite are simply forbidden by the rules. While this one were disguised (not intentionally) as a particular problem with particular function.
Drupal's flexibility is its strength and its weakness. You can do ANYTHING with it. But what comes out of the box is impossible for probably 75% of users to do anything with.
&gt; for revealing a crappy PHP question. What does that even mean? For those interested, the list of edits to said question: https://stackoverflow.com/posts/38408938/revisions What you did is turn the ("crappy") question into some sort of a joke, then when people reverted your edits you reverted those back… This is not "revealing" anything, this is just childish…
Why do you think it's a joke? 
When you create a child class, you can have extra methods in it. You can then use these extra methods elsewhere in your project. This is fine. Substitution in LSP: - You can have a class referencing Child Class 1 - Method A. - For whatever reason, you feel you need to get rid of Child Class 1 and replace it with Child Class 2. - You need to make sure Child Class 2, has a method name Method A, and that Child Class 2 - Method A, returns the exact data type as Child Class 2 - Method A. Other methods do not matter if they are not called elsewhere. If they are called elsewhere, you will have to make sure Child Class 2 has them. A good way of making sure mistakes like this does not happen is to make sure you code to an interface.
I might revise this [slide](https://i.imgur.com/bz8rU63.png) then because it is saying that the World class, which initially uses the Child class, should be able to swap in the Parent class without modifying any code, which was my whole point of confusion.
Yeah, that's backwards. [Wikipedia](https://en.wikipedia.org/wiki/Liskov_substitution_principle#Principle) sums it up nicely: &gt;... if S is a subtype of T, then objects of type T in a program may be replaced with objects of type S without altering any of the desirable properties of that program (e.g. correctness). However the inverse is not true, as a child class MAY add additional functionality that the parent class IS NOT required to also implement; there's no requirement that a parent must work anywhere that its child works. But if you're depending on that child-specific functionality, you'd better not be requesting an instance of the parent (this is getting into Interface Segregation Principle territory) The video (slide) isn't wrong *per se*, but it's leaving out a critical detail: it would have received an instance of the child class when it had asked for (typehinted) the parent. However the code example that immediately follows it is still somewhat nonsense. Given this: class Road { function __construct(Car $car) { echo $car-&gt;drive(); } } class Autobahn { function __construct(Tesla $car) { echo $car-&gt;overdrive(); } } class Car { protected $speed; function drive(): string { $this-&gt;speed = 45; return "Driving slowly"; } } class Tesla extends Car { function drive(): string { $this-&gt;speed = 80; return "Driving quickly"; } function overdrive(): string { $this-&gt;speed = 9001; return "Driving so fast!"; } } LSP lets you do this: if (rand(1,100) &gt; 50) { $car = new Tesla(); } else { $car = new Car(); } new Road($car); // parent or child works where parent is asked for but **not** this: if (rand(1,100) &gt; 50) { $car = new Tesla(); } else { $car = new Car(); } new Autobahn($car); // requires child, parent will not work Contrary to the video, it has basically nothing to do with changing the parent of the class itself. There's a bunch of other little details regarding how you can loosen or tighten scopes of parameters and return types across the parent and its children (tl;dr: accept more generally, return more specifically), but those are all basically specifications of how to adhere to the main principle.
Thank you for writing out such a detailed example. It is very clear now.
Happy to help!
Good point, I will consider doing that. Thanks for your feedback. I hope my video helped you in some way.
SPIP: http://www.spip.net/en_rubrique25.html
Just a small fix: - You need to make sure Child Class 2, has a method name Method A, and that Child Class 2 - Method A, returns the exact data type as Child Class 1 - Method A.
What happens when you need to divide it or do any operation that might result in a non-whole number? For example, getting the monetary deduction of an employee's tardiness requires his tardy hours (not an integer) times his hourly rate (monthly rate divided by hours per payroll period).
I disagree. Money math should always be done in decimals converted to strings and have their arithmetic done by bcmath.
Multiplying and dividing still requires rounding to the nearest cent. Most money libraries handle this correctly and automatically, including one linked in a comment below.
Different strokes for different folks, but storing in the base unit and converting from there is far less error prone imo. Not to mention that PHP's only "decimal" type is float, which is where these errors can become an issue.
You do this a lot: `$driver = self::$driver ?: self::get();` Can you not just assign this to a class level constant and then that was you always have a driver instead of having to dertmine, do we get or do we have ?
I second Modern PHP. It's been a great resource, and I learned a lot from it. 
how about to automatically create object? with all its dependencies? like one in DIC?
What is wrong with inline if statements? PSR 2 seems to say inline if statements are bad. Why? When short they are extremely useful and clear. Also, then why are ternary statements not frowned upon? They usually look a lot worse. 
I helped create a dependency injection tool that is mostly based on reflection, so keep that in mind when I ask this: why can't that be done ahead-of-time during development and then not done in production?
This is meant for child class overriding one of its parent's method.
By creating objects automatically like this, you lose control of the one thing that matters in a larger software project - architecture. Architecture is defined not just by interfaces, but also how their implementations flow through your project modules, who has access to what and when. Automatically creating objects the way many DIC libraries do is simply automated chaos. And it's not clear what the big win is supposed to be. Creating an object "manually" is quick and easy. Reflection in this case is a detriment, not an aid. It makes your bootstrap logic slow and semi-arbitrary. 
According the PSR2: &gt;The body of each structure MUST be enclosed by braces. This standardizes how the structures look, and reduces the likelihood of introducing errors as new lines get added to the body. So the reasoning seems to be it keeps the code more readable by being consistent and reduces the chance of bugs.
You don't love hamfisted analogies about composition and cars?
Well if I can give you one piece of advise it's to slow down. You seem to be jumping in to everything at a million miles an hour. Stop and think for a bit (mind you, you already identify this as being the problem). Try not to get tunnel vision when you're writing a piece of code. You should always be thinking multiple steps ahead. Have a clear, cohesive vision of what you're trying to do, as every piece of code you write should be moving towards that vision. Your codebase is one large ecosystem, so you shouldn't be introducing new, ill-thought out code haphazardly. In fact, I'll often reject merge requests from programmers who submit messy code. A lot of this comes down to experience. As you get more experience writing code, you'll find yourself doing the correct things more quickly. Until you get that experience, I'd suggest you try to slow down and perhaps reduce the speed and quantity of code you produce and focus on the quality and its architecture instead. Go back and refactor regularly if you feel like you've made mistakes. Once you've finished a piece of code/module, either conduct a code review yourself or ask somebody else to review it. We conduct peer reviews quite regularly at work, and assuming you're not prickly when receiving constructive criticism, having a 2nd objective set of eyes go over your work often yields good results.
What is the difference between an inline if and the conditional/ternary operator? E: To the user who downvoted my reply: &gt; In computer programming, ?: is a ternary operator that is part of the syntax for a basic conditional expression in several programming languages. It is commonly referred to as the conditional operator, **inline if (iif)**, or ternary if. –[Wikipedia](https://en.wikipedia.org/wiki/%3F:), emphasis mine My question for clarification was perfectly valid. (What c00yt825 means is not actually an inline if.)
When would you assign it? Note that there's the factory mechanism.
As part of a team we use trello all the time, it's really useful to track what people are working in, add attachments such as assets and have a to-do list for each feature all in one place. I would definitely recommendsryting up trello to keep track of what you need to do
Bit late to the party, but that's the most unused but useful function PHP?
You can learn about PHP @ phptherightway.com but more important than that, you must learn about software development. These dont get outdated so fast because they are about principles usable with any language: Clean Code: A Handbook of Agile Software Craftsmanship 2008 – Robert C. Martin Implementing Domain-Driven Design 2013 – Vaughn Vernon Lean Architecture: for Agile Software Development 2010 – James O. Coplien, Gertrud Bjørnvig Agile Software Development, Principles, Patterns, and Practices 2002 – Robert C.Martin I have listed a lot more resources here: https://herbertograca.com/dev-theory-articles-listing/
Try trello or kanbanflow (I prefer kanbanflow as it has pomodoro timers built in, and it really helped me to get more accurate with estimations; I actually use both, my client adds general tasks on trello, I add technical tasks on kanbanflow). I also try to stick to this branching model: http://nvie.com/posts/a-successful-git-branching-model/ Third thing that helped me, was switching to distraction free mode in phpstorm, I rarely use project view now (file tree), this seems like a limitation but keeps me from wandering away from the task I should be working on at the moment. Last thing from me, at the end of the day it helps to write down specific task (or tasks) for the next day. I'd say you should read all comments, pick one or two things that look like they may help, and simply try to stick with them for a month.
I found [hexdec](https://secure.php.net/manual/en/function.hexdec.php) the other day. Its purposes are limited, but useful...
If I need to do complicated stuff, step one is turn off my phone and lock my door. I can't be interrupted while elbow deep in code. Then I prepare everything. I need two monitors, one with the IDE, Browser, console. Other with the todo list and file explorer. If you have a say in it, make sure you have a good project structure. This helps. Having said that, during dev time, I hardly ever use the structure. PHP Storm has this double shift function (roughly ctrl+p in sublime) that lets you open any file in the project by just typing some part of its name (or even an function name inside of it). That's how I usually switch files. Navigating through the call stack, using ctrl+click to go to a function/class definition and ctrl+alt+left to go back to where I was earlier. Whenever I complete something (bugfix, added feature), doesn't matter how small, close all tabs (unless the next issue in the same call stack), commit changes. Commit message should reflect what you just did. I often use git's history to check what code used to be. I instantly delete commented out code (either mine or that of another developer) unless it's directly related to what I'm doing (at the beginning of a refactor I'll comment out code, and delete it when all is refactored). New projects: Who needs a name? First steps are always `git init`, `git add *`, `git commit -m "initial"`. Then go to town. As long as your classes are following PSR standards, there's not a lot you can mess up at first.
Only the free videos though. :)
damn, looks good.
We're currently entirely independent of the FIG. We're not even sure async has a place in the FIG currently.
Good to know! 
My first thought was [pack](http://php.net/manual/en/function.pack.php) and [unpack](http://php.net/manual/en/function.unpack.php) because they are often used for things that are complicated to achieve by other means. But I guess that most people who need the functionality know about them. There probably are some [array functions](http://php.net/manual/en/ref.array.php) that could be used more, but they tend to be rather situational. They might also be considered a bit fancy when a foreach loop could do the trick. On the other hand, using array functions is arguably more expressive, as a function’s name (e. g. array_filter) helps to document the intent of the code. Honorary mentions for functions that don’t get used enough: [htmlspecialchars](http://php.net/manual/en/function.htmlspecialchars.php), [http_build_query](http://php.net/manual/en/function.http-build-query.php), [parse_url](http://php.net/manual/en/function.parse-url.php), [flock](http://php.net/manual/en/function.flock.php) ;) If I had to pick a single one as an answer to the question, I’d actually say http_build_query.
Cool! I love feedback all of kinds. Hope my videos are helping you. I am most likely going to move on to patterns after this. Subscribe to my channel to stay in touch and keep updated bro. 
Yeah, it's more "The client wants it because his friend got a 120€ website from a family friend and it's also a Drupal/WordPress" - "Oh, and it won't cost more than 400€, will it? My family friend could do it for 120€!"
Are you working for SilverStripe?
Hi, do you know if Zend Eclipse PDT will get an update ? The last release is from june 2014, quite old now.
If you are working with Linux, I've set up a [standalone server](https://github.com/belgattitude/pjbserver-tools) that you can install with composer. Also I'm currently making a quick install guide : [http://docs.soluble.io/soluble-japha/manual/quick_install.html](http://docs.soluble.io/soluble-japha/manual/quick_install.html). I still need to document the J2EE/Tomcat guide, mostly explaining how to create and deploy a war (some notes about pom.xml too). In comparison to the standalone server version, the J2EE version offers a lot of advantages (start, stability, scalability...). Of course the standalone version is valid too, really depend on the use case. Open issues if you feel blocked, I'll try to improve install process as much as possible. 
&gt; PSR 2 seems to say inline if statements are bad. That's because they are - there should be only one statement per line. I'm going to disregard PSR-2 for now since reasons behind it are independent of any coding standard. One reason why you should never put 2 statements in a single line is readability. Code is meant to be read by other people - the compiler or interpreter doesn't care how you organize your code and name your variables / methods / classes as long as the code can be run without errors. While glossing over completely unfamiliar code, it's very easy to miss inline expressions, especially if they aren't used for returning some value. This gives a false impression about control flow of your code. Besides, if some action was important enough to be written, it should also be expressed well enough. Using multiple statements inline also hides the complexity of your code - simple actions should look simple, and complex actions should look complex. In this case you're making a fragment of code to look more simple than it actually is and that's bad. Second reason is the ease of debugging. For example, you have this inline `if` statement which is used to call a method on other class /** * @param ActivateUserCommand $activateUser * @return Status */ public function activateUser(ActivateUserCommand $activateUser): Status { // Some code here... if (!$this-&gt;isActivationCodeValid($activateUser-&gt;getActivationCode()) $status = Status::error('Could not activate user ' . $activateUser-&gt;getUser()-&gt;getName()); // Some other code here... } While in reality you'd probably wouldn't use inline statements when they are this long, it's still a valid example. Let's say you want to debug the entire method and put a breakpoint right after the validation check. As it is written above, you can't - the status creation is on the same line. Even worse scenario - the code written by someone else stops working in production which you don't have access to (works fine in development environment). The only thing to go by is a vague error message that the problem is caused by the line above. Can you reliably tell which of these statements is broken (perhaps both) without looking at the content of each method? Putting each statement on it's own line would solve this problem at it's core. Have you read _Code Complete_? The chapter about code readability explains the best decisions in similar situations really well.
For the "code" part of the search engine, there is already Packanalyst: http://packanalyst.com/ It lets you search through the classes/interfaces of any package available on Packagist. I mostly use it to find all classes implementing a given interface. *Disclaimer: I'm the main author*
Out of interest what is a list of things you think are missing from the docs? Firstly because everything I've ever needed has been in the docs and secondly if there is something you feel is missing I would have a stab at writing it and submitting a PR to the repo.
&gt; If you don't want to/cannot include certain functionalities, you'll have to throw an Exception in the unsupported functions (i.e. the UnsupportedFeatureException). Though you should only throw exceptions for `onSignal`. All other operations MUST succeed IIRC. &gt; don't disagree that storeState() and fetchState() could warrant their own interface, but it's really just use Loop\Registry; (trait import), thus we deemed that unnecessary. I still think `abstract class` might be better than `interface` + `trait`.
It seemed useful on the surface but its such a mess when implemented its just not worth it
The exception message does explicitly say 'magic methods' so that would suggest they did it on purpose, but I dont know for sure.
Huh, that's exactly what I mean, never knew that was there, but looks like it may be handy sometimes! Thanks!
Yes - the verification output looks very useful ( http://eloquent-software.com/phony/latest/#understanding-verification-output ) 
HHVM had yield before Zend Engine, maybe this restriction is there from the beginning
 &gt; I like the format very much Yes, that's just me and my personal "anti-yaml-crusade" (for example, see https://twitter.com/Ocramius/status/753118310510780416). &gt; In this case I don't think that is the issue. Php is just using a library (libYAML) which hasn't been upgraded to 1.2 but as far as I know python has more than one library that are 1.2, so I had some hope the php people would look into using something newer. I was more interested in how they'd modify existing data in a `1.1 -&gt; 1.2` bump. I know they don't follow SemVer in the spec, but this might break a lot of existing software if somebody decides to not bump major version in a Yaml parser.
Yes but that does not explain why the restriction exists
A few weeks ago, my team discovered a security vulnerability in PHP applications that make outgoing HTTP requests. The vulnerability allows a remote attacker to control where requests are sent. The problem boils down to two things: * RFC 3875 (CGI) puts the HTTP Proxy header from a request into the environment variables as HTTP_PROXY (so getenv('HTTP_PROXY') cannot be trusted) * HTTP_PROXY is a popular environment variable used to configure an outgoing proxy (and is trusted, e.g. in Guzzle 4+, or Artax) We've prepared a public disclosure site at https://httpoxy.org that explains the issue in detail, and provides fast and easy methods of mitigating the danger (basically: block the Proxy header upstream of your application). We expect the PHP team to have an official response available shortly - including a patch for 5.5 (it took a lot of effort to sit on my hands when I saw you all posting about 5.5 being end-of-lifed a week ago, haha). But don't wait for a patched version of PHP or Guzzle, just block the Proxy header; it's undefined by IETF and not assigned on the IANA registry of message headers - nobody is using it, except attackers, soon.
For PHPStorm, if possible. I checked a couple of mainstream solutions but they all have a reasonably complicated configuration process.
**This is big** - an attacker could use this vulnerability to send outbound Guzzle requests via their own proxy server. This gives them the ability to read outbound requests and read and influence the response. Quick explanation: PHP receives request state through CGI environment variables and HTTP headers are mapped to environment variables by prefixing with `HTTP_`. For example, `Host: example.com` becomes `HTTP_HOST=example.com`. The consequence of this is that any environment variable that is prefixed with `HTTP_` cannot be trusted. Guzzle trusts/trusted the `HTTP_PROXY` environment variable as a method for sending requests via a proxy. [Here is the commit](https://github.com/guzzle/guzzle/commit/9d521b23146cb6cedd772770a2617fd6cbdb1596) that fixes this vulnerability in Guzzle. The latest version (6.2.1) will now only trust this variable in a command line environment (where CGI environment variables are not present). **Edit** This will also affect people using AWS PHP SDK (e.g. flysystem/aws-s3-v3) and a bunch of other packages. If you're using third party software to make web requests, check to see if they use guzzle under the hood.
atom and a console. I use Laravel as my framework and React JS for the dashboard. 
or simply block http_proxy on webserver level 
We've had discussions about why we went with a static API: https://github.com/async-interop/event-loop/issues/14 Feel free to read up, but the TL;DR is to prevent people subtly shooting in their own feet [without realizing it] and the event-loop being _actually global_.
Yeah, absolutely. Our recommended mitigation is just to block the `Proxy` header, and call it a day. You can always update libraries much later. (I should mention that `putenv('HTTP_PROXY=')` and similar is NOT a mitigation though - you have to block the header before it hits PHP).
What about: if ($correct) { echo 'Correct'; }
[natsort\(\)](https://secure.php.net/manual/en/function.natsort.php) — Sort an array using a "natural order" algorithm This function implements a sort algorithm that orders alphanumeric strings in the way a human being would while maintaining key/value associations. This is described as a "natural ordering"
&gt; I don't think that would be a major issue. A BC break is a massive issue at almost all times ;-)
Related release from RedHat: https://access.redhat.com/security/vulnerabilities/httpoxy
That's not what I said. I said a new module for a version 1.2 the old module for version 1.1. That's what I think wouldn't be a major issue.
sorry about the typos. was typing on phone.
That's not a particularly good example - in this case ternary is perfectly acceptable although badly written. Does this still look unreadable to you? `$temp_array1['DISCONNECT_REASON'] = $disconnect_reason ?: null;` P.S. Who the hell names their variables `$temp_array1`?
There's quite a few other bugs in HHVM regarding generators, e.g. you have to call `next()` once on it to produce the `current()` value, while in normal PHP you can directly call `current()` and get first element (See https://3v4l.org/79eNo)
You can use PHP for it, given enough underlying performance it can also handle 10.000 clients, but you have one major problem: PHP is ~~single-threaded~~ synchronous and can only do one thing at the same time. That's what makes Node.js better for this, since Node.js can handle multiple clients at the same time _through asynchronous calls_, PHP can not. PHP can actually be quite a bit faster than Node.js for synchronous stuff and is the right choice for most stuff, but going async, you better stick to Node.js. With `pcntl` you can also bring in some async-feeling in PHP (See https://github.com/ratchetphp/Ratchet/issues/214), but it probably will be slower than Node.js. I think Node.js is _just the right_ technology for Websockets.
NodeJs is better in this case. Php is pretty linear and although you can get around it using some extnsions, most webservers will still launch a php process for each connection (or re-use ones that's done with the previous request) Node, however, runs as a server, and accepts connections into the current process. This makes it less memory intensive and therefore better suited for thousands of simultaneous connections. Although I really wonder what you need all those connections for, sounds more like a bad setup from my perspective.
When using the [curl/curl](https://github.com/php-mod/curl) extension, this becomes pretty simple. Note the `@` at the `torrentFile` key, which indicates a file link. Just make sure it exists and is readable. &lt;?php $curl = new Curl\Curl(); $curl-&gt;setHeader('Content-Type', 'multipart/form-data'); $curl-&gt;post('https://kat.cr/torrents/upload/', array( 'name' =&gt; 'Trial Torrent', 'category_name' =&gt; 'highres-movies' 'desc' =&gt; 'This is a description', 'torrentFile' =&gt; '@C:\Users\User Name\Desktop\Test Torrent.torrent', 'userhash' =&gt; 'My_User_Hash' )); Please don't use this for sharing illegal content. The code has not been tested. **edit** Looking at the upload page, they mention a "upload API", which requires uploader verification. You're probably better off using that (in combination with cURL), since they probably use CSRF tokens to prevent spammy and/or fraudulent upload attempts. 
For the record, the latest versions of Artax (1.0.4 for the old 1.x series and 2.0.4 for master branch) were updated to not fetch the environment variables in web SAPIs. Relevant commit: https://github.com/amphp/artax/commit/81254742812a5a9adf4b085f543f3f21daedcd97 (in 1.x; cherry-picked version of that commit in master) People will now have to `composer update` and should be fine...
Oh wow! Where has this been all my life!
Read Guzzle ;)
I actually [started](https://github.com/robmorgan/phinx/pull/905).
i thought node js was single threaded and php multi threaded. the hesitation with node is that i have not yet found a PaaS for node which is easy to setup and self manage security of server.
the 10000 connections limit is from future perspective. i want to invest in the right tech from the beginning so asked the question. as far as i know i can run php socket server as a daemon also so would this still mean that php will launch a seperate process for each web socket connection?
&gt; most webservers will still launch a php process for each connection Hmm, I thought a socket server ran as its own process and listened on its own port separate from the web server.
For instance, my project supports several databases and several environments. I could not find a convenient way to teach Phinx there can be more than on db per env. I agree with your point on timestamps, thank you.
Thanks for sharing, Paul. Feedback appreciated ;)
Very nice design, congrats!
Yes, use PSR-2 because it's what everyone else is doing. Hopefully adoption will continue and everyone's code will look the same.
use PHPstorm it will help with many of these issues. other suggestion is to write your initial project notes in a completely different application then your editor. something simple where you can write and sketch out ideas, but that is different then your main editors so it forces you to stay just at the general planning level. you can also use to write out sample names for fields/methods etc - do some other work - then return to it, look at the names and see if they still make sense. the other advantage with using an editor like phpstorm, as you refine the project and come up with better naming - refactoring is much easier so you won't have that 'have i missed a method?' fears about renaming. 
That's not very readable - but I'm pretty sure that according to PSR-1 or PSR-2 there must be new lines after opening and closing braces of if statements.
Looks pretty good, but I think you're *really* overselling it in the performance section. You're recommending a bare metal SSD server to really get the best speed despite the fact that almost definitely 100% of the time they'll have trivial effects on actual performance for anybody looking to use Grav. If someone really cared to try and outdo the hyper-optimized virtualization solutions used by, say, AWS and was trying to even optimize to level of making new hardware purchases Grav wouldn't be the best solution for such a speed-critical system anyway, a more custom solution would almost certainly be warranted. Some of the recommendations are sort of dodgy for people hyper-concerned with performance anyway. Who cares if I can parse YAML in 1/4 the time? How much YAML is Grav parsing? Does it have an effect &gt;1ms on the average or 99th percentile request in anything resembling production use? If not much is going on, isn't Grav most working with the same files all the time? Because with enough RAM I can reasonably trust the file will get cached in RAM and the SSD would only affect performance on the first time a file is read. If I really cared to make sure that's true I could fairly easily guarantee all files are loaded and read from RAM rather than the drive and just add a small delay from a cold start rather than buy new hardware so that the occasional file reads are sped up a bit. In what conditions do you start measuring a meaningful difference in average or 99th percentile response time between, say, 2.666GHz RAM and 3GHz RAM? Given the vagaries of the public internet I doubt you're getting a gain larger than the variance merely due to routing.
&gt; I understand how it works Having own framework is fine, but not until you have learned and understood at least a couple of other popular frameworks. I'll make it even easier: there are actually just two frameworks *worth* learning today: Symfony and Laravel.
I very much agree with the above. You might want to check out these posts which explains the process of creating a framework with Symfony components: http://symfony.com/doc/current/create_framework/index.html 
In what way is Codeigniter actively bad? I assume you are talking about CI3 - the newest version?
That's readable I suppose. I haven't seen ?: a lot do that throws me off. But it's short and sweet enough. Yeah, the guy who wrote this has some serious issues naming things. I don't want to know what his kids are called. 
I would amend by saying the only framework worth learning is PHP. It's incredible the number of developers who don't know anything about PHP and only know how to use one framework. Any framework can be learnt in a few days/weeks, but it seems that HR people don't understand that fact.
Smart
Really looking forward to the full Admin plugin. That will get me to switch - primarily for the client experience. Keep up the good work!
you can use react php with web sockets, react php is asyncronous php and its high performance, Well tuned, comes close to the speed of node.js you can also use nginx with php. nginx can run processes in parallel by opening up a new socket for each process and nginx does perform at a high speed. node.js does not handle multiple clients at the same time. it handles them one by one very fast. You just have to make sure that each connection that node.js recieves does not take long for node to process. The connections have to last a small number of computer cycles because if not, you lock its only thread and your application looses service. node.js can handle two connections at the same time on a linux system, by telling linux to spawn a new process. 
Don't forget `strnatcasecmp`
My 0.02 - Maintaining your own closed source framework is likely bad because if you are doing something wrong you wont know about it - Using your own custom framework sends up red flags for a few reasons. One it could mean you cannot use other frameworks because you lack the understanding... or ... you think you know better than everyone else or ... etc - A well balanced developer would understand each frameworks pro's and con's... Example: Would I just full Laravel for a REST API that outputs only JSON? No... Would I use it for something like a CRUD app? Yes. Where does your framework fall in line... is it like Slim or is it like Laravel? - Chances are if you required feature X,Y,Z it's already built under say Laravel, Symfony or Zend... But in your framework you will have to write both the core framework components AND the actual implementation, so for some features it can be double the work. - If your framework is developed solo, the chances of someone else being able to use it are pretty low... This is why open-source is a great thing... we have many experienced developers working together to ensure the product is usable by everyone.
Sorry, but i didn't understand the last part. The edit part, can you please explain a little? and the code is showing a syntax error. `syntax error, unexpected ''desc'' (T_CONSTANT_ENCAPSED_STRING), expecting ')' ` According to [this](http://stackoverflow.com/questions/13565768/php-syntax-error-unexpected-t-constant-encapsed-string), there is an error with the " or ', but to me everything seems fine on line 8.
[Oooh, PHP 7.0 support](http://i.imgur.com/IUeYEqv.gif)
This is the path I was thinking of going down is the whole API Backend with a JS Front end. This way you can remove the front end and not have to worry about: Ok is it tied to x ... 
[removed]
&gt; If you want to build a simple web based game, you'd be better off using javascript You do realize that the data from said game have to be stored some where right? And while PHP would be used for API and events and such and JS used for the front end, the display, the dialogue boxes and so on ... Like you can't just USE pure JS, i mean technically you could but I personally would not recommend it for back end stuff, until its a bit more mature, ya know? Just my opinions though.
I just registered on Reddit so I can comment on this post. I've been lurking about for about a year on Reddit. I, too, have developed my own framework I've developed over the past 15+ years. When PHP 5.6 came out I did some refactoring to take advantage of some of the new features. I haven't moved to PHP7, as it is not very widespread (yet). My framework, as I suspect most people's personal frameworks are, is incredibly lightweight. Basically a simple URI-&gt;\Namespace\Class mapper, some autoloading class magic, and a dozen or so simplified libraries for the basics (database, configuration, image manipulation, filesystem manipulation, encryption, input/output, etc). Really nothing advanced, but it does all I need. There are some projects I've built some pretty complex libraries that integrate into my framework to make the project work. Unfortunately it's closed source at this time. It's not so much that I don't want anyone to see it, it's that I don't see there being an enormous benefit spending the time to document and put it on the web. I feel that developing in PHP shouldn't be about the frameworks, as it's a very simple but really powerful language. I've met many developers that only stick to a single framework because it's all they know or understand. If they were pressed to write a basic web app with plain jane PHP they would be completely lost. [Edit: fixed some formatting]
I think this might be better off simply writing a boilerplate "functions.inc.php" if this is what you want. Simply defining the function aliases and using call_user_func_array('realfunctionname', func_get_args()) to pass the arguments. For example, bin2hex: function binary_to_hexadecimal(){ return call_user_func_array('bin2hex', func_get_args()); } Just my two cents.
I agree, or even typeof like javascript for that matter, considering "mystring" technically isn't an instance. 
&gt; If members of the team can't understand that simple function then the team probably has bigger problems on their hands.. As an outsider, I have precisely zero fucking clue what `rev` means: $job-&gt;rev = $j-&gt;time * $job-&gt;euro; I can't even guess what it's data type might be, or how it's meant to be used. It offers absolutely no context. Additionally, why the hell is this work being done imperatively in the loop? $job-&gt;rev = $j-&gt;time * $job-&gt;euro; Surely that's an implementation detail that should be encapsulated by `Job`? It's a classic information expert violation: the Job is the expert since it contains all of that information, but the loop is expected to do something that is clearly the responsibility of Job. As a side note, the code examples given in that article are garbage. Extremely inconsistent. The first example has this: $j = new Job(/* $data['...'] */); $j-&gt;rev = $j-&gt;time * $job-&gt;euro; $ret[] = $j; You have `$j` and `$job`.... Then the second example tries to then introduce the `$job` refactoring: $job = new Job(/* $row['...'] */); $job-&gt;rev = $j-&gt;time * $job-&gt;euro; $jobs[] = $j; Still have `$j-&gt;time` and `= $j`, and since `$job-&gt;euro` was already there, that means the author of this article literally only updated `$j-&gt;rev` to `$job-rev` and didn't touch anything else... At any rate, here's what the function SHOULD look like: public function getJobs($timestamp) { $statement = $this-&gt;db-&gt;query('SELECT * FROM jobs WHERE year=' . date('Y', $timestamp) . ' AND month='. date('m', $timestamp)); return array_map(function ($job) { return new Job($job); }, $statement-&gt;fetchAll()); } I might argue that the function name and the `$date` argument aren't the greatest, but it totally depends on context. If you have a URL like `/jobs/2015/05` and that's primarily how you end up filtering by jobs, then the signature should probably take separate year and month arguments, and then do a bit of work to normalize or validate the arguments. But I would definitely not just name the argument `$date` when what it actually wants is a timestamp. The one caveat here is that `array_map` doesn't support generators (WHY!?), so this might have to be rewritten as: public function getJobs($timestamp) { $statement = $this-&gt;db-&gt;query('SELECT * FROM jobs WHERE year=' . date('Y', $timestamp) . ' AND month='. date('m', $timestamp)); $jobs = []; foreach($statement-&gt;fetchAll() as $job) { $jobs[] = new Job($job); } return $jobs; } It's a lot cleaner, and a lot more point-free. Point-free is *usually* better, but not always. Sometimes you do need intermediate variables just to help indicate what something is, but that's not the case above. There's no need to hand off `$statement-&gt;fetchAll()` to an intermediate variable, nor is there a need to store `new Job` in an intermediate variable.
I don't disagree, but it's probably still faster than the hoops this library is jumping through to provide this kind of functionality. My point was it's a quick, relatively dynamic way, to create aliased functions vs defining functions via eval(), which if used incorrectly could be a security issue. That is all.
Operators in programming languages can be classified by arity, which is the number of operands. There are * unary operators (`!$f`, `$i++`, …), * binary operators (`$x + $y`, `$a % $b`, `$s . $t`, …), * and ternary operators (`$cond ? $trueValue : $falseValue`). The `?:` operator is actually just one of the ternary operators. It is *a* ternary operator. The reason why it is commonly called *the* ternary operator is because, in many languages, there is only one operator with three operands. A more exact name for `?:` would arguably be *conditional operator*. In syntax, operators form expressions as opposed to statements. Although there might not be a definite distinction between expressions and statements (expressions can often be used as statements and can therefore considered to be statements), one might say that expressions can always be evaluated and always return a value. In that regard, `?:` is just like `+` or `%`. E: Honestly, what is wrong with you guys and your downvotes. :-\ The purpose of `?:` is *not* (primarily) assignment. It’s an operator like any other. It’s beneficial to think about these things on a more abstract level if the goal is understanding. From the top of my head, here’s a somewhat realistic example that does not use `?:` for assignment: $sum += $entry['value'] * ($entry['type'] === 'gain' ? 1 : -1);
&gt; As an outsider, I have precisely zero fucking clue what rev means: Then you probably shouldn't be working on the code. Isn't it customary to understand the data layer before diving into the code? A quick 2 minute conversation will get you up to speed, and then you can confidently go forth and edit thy code. &gt; I can't even guess what it's data type might be Look at the database schema? Or var_dump()? The code samples you provided look great, but honestly, I'd be equally happy with either approach (your's or the ones from the article). This type of function should literally only take a minute or two out of your day. It doesn't need to be any harder than that.
If the application is using straight cURL, would it similarly be affected? Based on the linked fix for Guzzle, it looks like you'd have to manually copy the value across from the environment variable; the description page doesn't make it obvious if PHP does that automatically or just the noted libraries.
Nodejs is Alain single threaded. Your comment is shit
[removed]
I worked with many php developper in the last 10 years. Most of the guy that develop their own framework usally understand pretty well every part of the core php concept and limitation. Framework guy were very good at copy-pasting other people code. With a popular framework, it's easy to be attack by an known exploit.
Sorry to bear bad news, but this is a bad/incomplete mitigation, and shouldn't be used. The reason? `apache_request_headers()` does NOT normalize case, yet `array_key_exists()` is a case-sensitive comparison. So, if you apply this, you'll still be vulnerable to `proxy` headers, `pRoxy` headers, etc. RFC 3875 *does* normalize case. So `getenv('HTTP_PROXY')` will still be the user-supplied header.
&gt; if its considered bad practice to use your own frameworks Let's see downside of "your framework". Please note that this downsides are about "using" your framework in commercial projects. In your pet-projects you are free to choose whatever you want. - You have to maintain it. I don't know about you but I just don't have that much free time. Your clients shouldn't pay you for maintenance of your dev stuff. - Development speed. If you write everything from scratch (i.e. some components like data validation, or wrappers around third-party services, or other stuff that probably already published in packagist), you wil lose tone of time on this. Instead of solving real problems of your customer's business. Facebook loogin for example. It is very simple to implement on your own but why I need to spend my time on this? I would just install package with ready-to-use implementation. Facebook login is not so interesting feature from dev perspective and it is better to spend 1 hour setting up some third-party implementation and move to the next more interesting tasks. - Security: Are you sure that you are handling CSRF, XSS, SQL Injections, Timing attacks correctly? 100%? - team work: it will be hard to find experienced developers who will like to work with YOUR framework. Just because it just yours and only you like it. Also most of pet-frameworks that i've seen had high coupling, easy to break and you are highly tied on this. Cool if some of "framework guys" know something about Inversion of Control or SOLID/GRASP but... usually it is just mix of OO + procedures via static methods, global state and so on. Now from learning perspective: - Tests: your framework should be covered with tests. If not - throw it away after you get bored enough. - MVC: most of devs that I interviewed just don't understand it. They think that "view" is HTML, but view is HTTP itself. And MVC is a way to separate concerns about who handle one presentation and another. Instead of bulding frameworks it is better to just read some books/papers on this topic. For example: [paper from author of MVC](https://heim.ifi.uio.no/~trygver/2003/javazone-jaoo/MVC_pattern.pdf). Also time of good old web with forms is coming to it's end. Now we will se more and more SPA + rest api (+ Backend as a service stuff like firebase). 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
It's an awful framework in 2016, it was good pre 2010 but has no place in todays market, you wouldn't get away with using it on any commercial contract due to no testing and absolutely no PSR support. They are making huge strides to change this for V4 but they are about 5 years too late to the party now frameworks like Symfony, Laravel, Yii and CakePHP now have the market tied up.
I believe Bolt CMS is the closest thing you're going to get to a Symfony CMS: https://bolt.cm/ I've not used it myself yet, but I've heard a lot of good things about it.
Could you elaborate on Laravel architecture problems? There are issues with pretty much every framework (Laravel is no exception), but I'd like to hear your perspective on what makes it a disaster instead of simply flawed.
Quick observation: Yii 2.0.5 was a security release for which the CVE 2015-5467 was reserved. Even over 1 year later, the status of this CVE is still reserved, and not been updated. What we know about the issue is the following: &gt; We are releasing Yii 2.0.5 to fix a security issue found in the yii\web\ViewAction class. We urge all users of the class to upgrade their Yii installation to this latest release. Upgrading from 2.0.4 to this release is very safe as the release does only contain the bugfix for the vulnerability and will not break your existing code. &gt; The vulnerability is in the ViewAction action. It is possible to execute any PHP file (a file ending with .php) on the disk by passing a relative path via view parameter. Since the issue was posted on the public issue tracker and is already known, we've fixed it and decided to make this release immediately. &gt; We have reserved a CVE number (CVE-2015-5467) for this issue, which you can use to refer to it. but this information has not been added to the CVE database. This makes me worry about their handling of security issues.
the best thing is its very simple framework, has comprehensive documentation . so what you more required for testing and support.i agreed its market is now down due to the ownership , but a community of expert is handling it. i didn't use Cakephp and laravel yet .may b they are good.
If you don't know whether you should have your framework, the only way to know would be to allow people to understand and critique your framework. Unfortunately putting it out there on GitHub without extensive tutorials and documentation would likely just attract troll opinions. The nature of how things go. "Should I build my own" is like the case of "all geniuses are crazy, but not all crazies are geniuses". Many people build their own toolkits, the majority of them are bad, some are good, and some of the good ones have become popular enough like Symfony, Cake and so on. If we could give a generic advice like "don't make your own" it'd be to reject the idea of Symfony's creators making their own as well. *Someone* should be making their own framework in order to keep the ecosystem moving forward...
For security purposes I'd rather trust a big, well-tested framework like Laravel which is used in thousands of projects than a framework someone hacks together in his own time which most likely has never been looked at by anybody else.
There are few things. - the largest issue, that comes to mind, are the (what Laravel calls) "**facades**". These are collections of globally scoped functions (also known as static classes), which are used everywhere. They are basically hidden dependencies. Some people keep repeating "they are bad because they are not real facades", but that's just BS. Call them "trigglypuffs" for all I care, because that doesn't change the architectural implications. - next culprit is the **eloquent**. It is an [active record](http://www.martinfowler.com/eaaCatalog/activeRecord.html) based ORM, which is part of the framework (which is not in itself a bad thing). And since it's almost always used, this has major impact on your DB architecture, because your ability to normalize the tables is extremely limited (anything requiring beyond 2 joins is a performance disaster). It also means that you are tightly coupling (at least part of) the business logic and the persistence logic. And of course Eloquent's "entities" are accessed globally (using static class) and this create additional pressure in form of hidden dependencies. - mixing the **routing and dispatching**. Since each URL patterns is manually wired to a specific controller, this makes Laravel hard to use (if not - impossible) in large projects, because the routing file becomes extremely large. It also create a strange type of tight coupling to a specific class-method pair (thought, due to it's restricted location, it's not a major problem). 
Yup, the right lesson is you should not use HTTP_PROXY, but the most general lesson is NEVER TRUST A HTTP HEADER.
Thanks for the answer. You pretty much confirmed my main concerns, especially about facades and Eloquent. Routing has also been an issue in most of my recent projects. There's also the fact that at least some of the framework components are tightly coupled to each other and hard to extend. I understand that the target auditory is mostly RAD focused (similarly to Rails) and in many cases that's absolutely fine, but it seems that recent framework versions have created more new problems than they've fixed. Dependencies are hidden behind function calls (`app('ClassToResolve')` immediately comes to mind) and service injection into templates almost makes me throw up in my mouth.
&gt; CSRF: tokens How are you generating those CSRF tokens? (not you personally, but just in general) If your answer involves `rand()` or `mt_rand()`, then you have a security vulnerability. Are you using timing-safe `hash_equals` for string comparison in security-sensitive contexts? Does the framework offer an abstraction around encryption to make it easier to use? Do you know what defaults to use (e.g. differences between CBC and EBC modes)? There's quite a bit that's relatively easy to fuck up if you're not careful.
&gt; Then you probably shouldn't be working on the code So the company never hires new developers? Else I fail to see why you should make it harder for new developers to grok the codebase. That costs money, and leads to mistakes &amp; bugs. &gt; This type of function should literally only take a minute or two out of your day. It doesn't need to be any harder than that No single drop of rain believes it is to blame for the flood. All of these "shortcuts" that disguise and obfuscate the intent behind code add up. Why make a new developer `var_dump` data if they don't have to? 
oh nvm i was looking at the namespaces, seems they can lc, thats weird.
Ah, that CPU usage makes my small laptop cry. I really wanted to read the article, but my CPU got to excited when he saw the [confetti](http://imgur.com/zbvPaEu).
This is not a bug per se ... generators where present in HHVM prior to PHP and they follow the usage in other languages for instance in JavaScript you have to call `next()` too if you want to access the generator result (see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator) . So in this case there is a **reason** for the HHVM behaviour.
I don't see any redflag with using Doctrine for RESTful API development, I have no experience with it but I do have some coworkers that do, and use it with Symfony2 and the FoSRestBundle, and they say it's blazzing fast.
I am curious why you think yii is actively harmful? At my current work, Yii2 become a standard framework, so I have to actively use it. I personally don't like a lot. I would like to use Slim a lot more, but I am not the one who is deciding upon which framework will be used.
Doctrine might be slow, especially if you have a lot of managed entities at the same time. But it doesn't matter if you're building a RESTful API, what matters is what your application is going to do.
This is all nice in theory and I completely agree with you, but it doesn't contribute to the current situation. HHVM's target was and should always be to be completely compatible to PHP. When you have to start using things like $gen = gen(); if (defined('HHVM_VERSION')) $gen-&gt;next(); $element = $gen-&gt;current(); things can only become worse when nothing is changed. It's PHP that is the largest web programming language out there, not Hack, so I think HHVM should adapt. Most PHP developers just add `hhvm` to their `.travis.yml` since they want to _support it, too_, not because they need or have to. It's sad that as soon as you use some higher level constructs like generators, compatibility breaks completely. Also, if you imagine a generator in a for-loop $gen = gen(); for (; $gen-&gt;valid(); $gen-&gt;next()) { $key = $gen-&gt;key(); $value = $gen-&gt;current(); } notice that even here `next()` will be called _after_ `current()`, not before. This code will [fail in HHVM](https://3v4l.org/rIBul), in PHP it works. For HHVM, you have to call `rewind()` first, which appearently magically calls `next()`. (Which is the valid first part of a for loop and what a foreach loop does, anyways), but it lets me think that a HHVM generator is not reset in its initial state, it's in a state somewhere between `reset` and `next`... So what's the great design decision behind it? Having only one point at which you call `next()`? I get that, but then again, `rewind` seems to call it, so it's not even consistent. It's not a bug and there is a reason, I agree. But HHVM still has to change it, regardless of those facts. 
I think you should call it PStreams. It has a nice flow to it. 
I don't think it's true. As far as I know, most large websites use something Java-based (the VM, not necessarily the language) while Facebook seems to use a custom PHP engine (HVVM or something, I think).
I don't have anything, that could be described as "a toolkit". In latest few projects I just used twig, symfony/http-foundation and symfony/dependency-injection, because nothing else was actually needed, with directory structure that resembles [this](http://i.stack.imgur.com/YGVI9.png) .. though, it tends to have some alterations on project-by-project basis (especially, when it come to lower-case VS camelCase ... I cant decide). 
The largest problem is the global `Yii::$app` god-object. But if you want other issues, I will try to list some of them in the evening, because ATM I have to write some code :P
Both sides in these debates are almost always wrong on this because there is no catch-all use-case. Doctrine, Drupal, Magento are all open-source, they all suffer from vulnerabilities, some of which go undiagnosed for years (drupalgeddon). It's the nature of the world whilst it keeps spinning that changes will happen, code that was "secure" will be found to be insecure, patches or upgrades will be needed. By writing-your-own using entirely in-house you have the most control. It's a spectrum, I've never seen anything entirely invented in-house because at some level you need outside assistance because you are human, have a limited number of hours in the day and brain-cells to dedicate. The more you go-it-alone, you give up speed, to a degree innovation (because all internal projects get tunnel vision at some point, and the limited brain-cells and time), and you miss out on collaboration and wider-market input. It's not just security you need to think about, in-fact I'd bet a specialist in-house framework would be easier to secure, as it will typically be easier to implement within a reduced-complexity operating environment. (i.e. we only use linux OS, mariadb-X, php-{ver}-{sapi}). This should not be an excuse for not writing interfaces and adaptors should underlying assumptions change, but it's easier to secure something that is limited because there are less moving parts. The other side I disagree with is &gt; It's not like Wordpress - you don't have some public advert telling everyone what framework you're using, so there should be no way of people finding out. ***Perceived Security*** through obscurity is not in reality security at all. It doesn't work, it's only perception, not reality. &gt; Most of the guy that develop their own framework usally understand pretty well every part of the core php concept and limitation This is nonsense. Maybe it's true for popular frameworks, but I've seen some real horrors using PHP where people have become isolated and tangential. It's much easier to write components than a cohesive framework, even if you were only using components I'd imagine to do it well will always be a case of doing it well for scenario X given Y and Z inputs.
no valid reason to worry about
If you have the time that would be great :)
I've just had my first look at it personally. They are definitely making good improvements to the framework, but even just glancing through the code for 1 minute it is obvious it still needs a ton of work. If you are recommending a framework to someone that is still learning, why not recommend one that at least follows standards set out such as PSR2 so that the learnings from that experience can carry over into other frameworks as well.
you can read an older rant of mine about Yii1.x http://stackoverflow.com/a/10960679/727208, while you wait :D
If you are looking for battle-tested solution for collection handling, take a look at these: - https://dusankasan.github.io/Knapsack/ - http://book.cakephp.org/3.0/en/core-libraries/collections.html - https://laravel.com/docs/5.2/collections (only if you are already on Laravel) 
Should you start your own framework? Software design and used car salesmen
Well to be fair. You could also use those analogies too. The same logic applies to almost every field.
That's the thing with bad analogies. You can apply them poorly everywhere.
If you want a Symfony CMS that does most of it things the Symfony way you should try http://jarves.io. I believe it's the Symfony CMS that is closest to Symfony Framework as Jarves doesn't have an own architecture (of routing, initialization, loading bundles, etc) but it is just a Symfony Bundle which means you mainly only need a Symfony-Standard knowhow and can start working with it. Disclaimer: I'm the author of it.
&gt; most of devs that I interviewed just don't understand it. They think that "view" is HTML, but view is HTTP itself. Views generate presentation data, it's a division of data description through intended purpose, not a specific transport protocol, output format. It sounds like your interviewees when asked about the sky are talking about clouds, and you are talking about sight. Really a view exists in a different place to either individual objects in the sky or the transport medium to a singular sense...
very helpful !
Yes, that's a fine way to put it. You could either adopt PSR-2 or continue the habits of Classic PHP&amp;trade;
Analogies are supposed to make your premise, logic and conclusions clearer - rather than more obtuse.
You say all these frameworks are bad BUT you must have spent a lot of time learning them to come to this conclusion... so, your logic doesn't add up.
Woa, so much hate for any type of framework :D.
Thank you sir! :)
I've gotta be honest, I haven't used Drupal 8 yet and I am skeptical about it. I suspect you hit the nail on the head at "nice mess". Will certainly look deeper into it though, it does seem like the logical way forward. Thanks
I've built a restful APIs on doctrine, haven't had any performance issues. Doctrine allowed us to write better queries than your standard AR ORM. The server never took a huge amount of traffic, but not small amounts either. Occasionally we'd see issues when our features would be embedded on Huffington Post articles, this was solved with caching. And I think that's really going to be the key right there, caching.
I'm not really sure what I was supposed to take away from it. Frameworks are OK, unless you want to make something really cool?
How would a framework stop (or in any way hinder) you from making something really cool?
I work on a "code craft" team doing Angular dev. Our process involves a multi-team code review on every pull request for the express purpose of catching ambiguous code like this. It's horribly disruptive to interrupt the last developer to have touched a piece of code to ask them something that could have been self-explanatory. Multi-team code review offers an awesome opportunity for "outside" perspective on every line of code. If it's not clear what's going on to the people doing a code review, it lets them explain that in a comment directly, allowing the author to improve the clarity of the code they wrote.
Tbh, I don't really disagree with you and I'd say all those upvotes are in the same vein. &gt; cake, yii and codeigniter as so bad, that they are actively harmful 100% agree. &gt; laravel (while following some more primitive best-practices) is a disaster at the architectural level I wouldn't say a disaster but its really only viable for small projects that are 100% web-based. (i.e. Most contract web work would fit in this category, its really only when you get into 5+ people sized projects that I'd say the project really exceeds the scope of Laravel.) &gt; zend is kinda forgotten Yeah it is and its kinda unfortunate. I think its the least-bad option among the various PHP frameworks. :/
&gt; I've always wondered if its considered bad practice to use your own frameworks. I'm currently using my own framework ( MVC Hybrid with a Restless ( AJAX Friendly ) controller with lots of cool nifty features ) that I've built up over the last year, for almost every project. As long as you are confident in your ability to implement security best practices and are able to architect it in a sane way for your use case...its perfectly fine. The reason re-inventing the wheel is considered bad is its a time consuming process with a non-zero risk of failure (worse than existing solutions) and from a productivity standpoint that can be quite bad. If your goal is personal growth, its a great track for you. However, integrating 3rd party components into it reduce the scope and on a case-by-case basis should seriously be considered. 
My point was that you shouldn't use Laravel's collections, because they use arrays under the hood (as opposed to iterable lazy objects), not because they come bundled in Illuminate/Support.
&gt; so there should be no way of people finding out TYL about [builtwith.com](http://builtwith.com/)
&gt;&gt;&gt; ... Frameworks are OK, unless you want to make something really cool? &gt;&gt; exactly) &gt; How would a framework stop (or in any way hinder) you from making something really cool? Not sure how any of what you've said relates to my objection. Symfony doesn't stop or hinder you you from creating forms however you like. It just provides help for doing it in a certain way - if you choose to use it.
No reason you can't, there's nothing stopping you having an ORM managing your data. If you're concerned about speed and speed is a major factor then I wouldn't even be considering PHP
As the others have said bolt is a good choice but theres also Grav that could be useful. 
yep avery51 is talking out of his arse
Too much sarcasm makes the whole thing very off-putting. Have you reported that issue to the Magento project? If so, what were there response? And to get an idea, where is this encryption library used *in* Magento? (i.e. what is at risk directly inside Magento?)
oh hmm, thanks. knapsack looks solid
I really wouldn't worry too much about the architecture of Laravel if you're writing standard CRUD based web apps or basic APIs. If you ever have to refactor around Laravel's architecture for a project it probably means your project is getting really huge or you shouldn't have used PHP to begin with. There are countless opinions about how to properly architect a framework just as there are about the nuances of MVC, etc. Laravel is basically already glue for "individual composer packages". I read an estimate from a developer who's composer package is used in Laravel that the framework uses something like 30 outside composer packages.
&gt; It's horribly disruptive to interrupt the last developer to have touched a piece of code to ask them something that could have been self-explanatory. Just curious, do you still work in an office with cubicles or private workspaces? The last two environments I've worked in are the open bullpen style where collaboration is encouraged. No one on the teams I've worked on recently has minded being asked a quick question or two. We also have daily stand-ups which provide good opportunities to ask peers for some context/insights on what you're working on. I guess every developer/team is different. What works for me and mine might not work for everyone. Our code reviews are pretty relaxed, and I personally think I'd turn into a nervous wreck and my productivity would suffer if I thought every few-liner function was going to get nitpicked to death...
oh fun
&gt; If it were an RCE bug Remote code execution, for anyone else not insta-familiar with all the acronyms.
thanks :)
&gt; I thought that was toned down. Is it possible that something is coming across as sarcastic when it wasn't intended that way? Leading off with a poem about your (totally valid) hatred of mcrypt doesn't exactly set the tone of "I've found a serious problem that you should not ignore"
&gt; With cryptography vulnerabilities, rather than e.g. remote code execution vulnerabilities, the best course of action is immediate full disclosure to the public. I've never seen anyone share that opinion - it seems to really amount to nothing more than public shaming. You're putting exploit instructions into the public disclosure notice, knowing full well that remediation will take time to code and significantly longer to deploy. This seems extremely irresponsible (and makes me strongly question how your professional services are run)
Interesting. What framework are you using? I know it catches Laravel and WordPress (but WP is pretty easy to tell to the naked eye, too). 
I would really like to know, so I hope this doesn't come off as a sarcastic question or something like that: What advantage does public disclosure have over giving a small period in which they may fix it? All I can see are negatives, as the likelyhood of the security issue being taken advantage of is far greater if attackers know exactly what to do and that it will take several days until fixes are deployed everywhere.
I don't think this can really solve the issue im running into, but I really like it! It makes stubbing functions really damn easy. Problem is, this is a legacy project without namespaces. I tried to override the constructor for DateTime which is obviously not going to work, and then replacing time() and date() to see if i could force DateTime to return some different stuff but no go. I haven't found a good solution other than re-doing the class, because most of the other options involve some extensions on PHP. I could namespace one, and then override DateTime locally and return a false date on every DateTime('now', $timezone) call, and have phpunit compare results of the class but that won't really "clean it up" in the long run. Either way, though, I'll definitely be using this in the future for how intuitive it is. 
I'm very familiar with Schneier and his work; he too seems to favor responsible disclosure: &gt; So a bunch of software companies, and some security researchers, banded together and invented "responsible disclosure" (See "The Chilling Effect"). The basic idea was that the threat of publishing the vulnerability is almost as good as actually publishing it. A responsible researcher would quietly give the software vendor a head start on patching its software, before releasing the vulnerability to the public. &gt; This was a good idea -- and these days it's normal procedure -- but one that was possible only because full disclosure was the norm. And it remains a good idea only as long as full disclosure is the threat. Perhaps I'm misinterpreting him (and if so, it's entirely possible his opinion has changed in the nine years since he posted that), but to me this is saying "full disclosure is the correct course of action when responsible disclosure fails", which is somewhat redundant given that's the entire premise of RD. &gt; The world benefits from more security/crypto experts. Even if they're motivated by spite. Do it for the greater good. Also, it's a fun and exciting research field. Right there with you. I wish I had more time to spend doing the same, but unfortunately it's not my day job so it's only something I can really do when reviewing a third-party library that I'm considering using. Just know that I very much appreciate your contributions to making the PHP ecosystem more secure, even if I occasionally disagree with your approach to doing so :)
While I agree that the crypto presented here is terrible, what you just did is possibly worse. Without any notice to Magento nor to its users, you exposed a quite widespread vulnerability (most ECommerce websites run this stuff, including some of my clients). You just assumed malicious intent by the company behind the tool, without ever simply shooting a mail to someone, or asking around. The technical analysis may be good, but from a management/people PoV, this is just security horror.
Not sure how it's attempting to deduce that a given site / app uses Laravel, but it didn't catch mine.
You seem to be suffering from delusions of grandeur...
&gt; Cryptography is its own beast. For one thing, secure crypto is not backwards compatible with insecure crypto. (Otherwise, a downgrade attack renders it insecure again!) &gt; Knowing that a cryptography feature is insecure allows the user to elect to rely on something more robust. i.e. defuse/php-encryption is great for symmetric-key encryption. What does that have to do with my question? If you use Magento, you can't just change your encryption. You have to wait for an update to be released. &gt; What good does leaving the public in the dark do, even for a short period of time? So the devs have time to prepare an update, deploy it (which can take several days even if they work high-pressure) and then users can download it, instead of having to wait while being vulnerable? &gt; Especially given how obvious these flaws were, and how easy a criminal could have been secretly exploiting it all the while? Of course they **could** have. But you can't seriously argue that every possible criminal knew about it beforehands - but they do now. &gt; When it comes to cryptography flaws, the sooner you're aware of the problem, the less harm is caused by trusting weak cryptography. The software developers should be made aware asap. The customers can't do anything with that information.
TIL When someone's fly is down, it is best to tell the whole room.
I was wondering if you could explain how you would improve or implement a better router?
&gt; I exposed cryptography flaws that, to the best of my knowledge, are not remotely exploitable. What makes you think that you, as a researcher, know and understand the entire system better than the developers ? Maybe the problem you found can't do much damage alone, but together with something else which you maybe don't know that exists in that system, can make a big damage. (_I speak in a general sense, not about this issue in particular_) &amp;nbsp; About a year ago, you were complaining about some entities (_mainly in SO context_) which are not very friendly with security researchers and I really tried to help you with some advice, but using this approach is a good method to be hated by everyone. &amp;nbsp; As a developer I like security researchers, but not when they are not adopting a responsible disclosure model which is a win-win situation from my perspective. Give me a notice about the issue, allow me to fix it or even enforce an amount of time until I can fix it and then you are free to disclose it publicly and promote yourself. &amp;nbsp; I have many more things to reproach you but it's getting late and I had a very long day; as someone who tried to help you in the past, let me say that you disappointed me with this one, because I am sure that you can do better than this.
When disclosing vulnerabilities humor comes off as being mocking and condescending to the affected projects. Personally, I'd keep my full disclosures as dry and humorless and as to the point as possible. There's a time and place for humor and this isn't it imho.
&gt; I have many more things to reproach you but it's getting late and I had a very long day; as someone who tried to help you in the past, let me say that you disappointed me with this one, because I am sure that you can do better than this. This behavior is fairly typical of sarciszewski: https://www.reddit.com/r/PHP/comments/41dnct/full_disclosure_it_essentially_wins_crypto/ I'd step in and defend Magento as I did that other project but Magento is a big project. They're not some underdog that needs help defending themselves - they're big enough to do it themselves.
&gt; If anyone can make a solid logical argument in favor of keeping cryptography vulnerabilities secret, and I'll concede this point and not opt for full disclosure going forward. Less people are at risk. Boom. That's a fact.
You're creating a false dichotomy here: tell or don't tell. Nobody here is suggesting you don't tell. Just that you respect the developers enough to give them a head start at fixing to problem.
&gt; What does that have to do with my question? If you use Magento, you can't just change your encryption. You have to wait for an update to be released. The point is, fixing the crypto would require a major release as it will break compatibility. In most cases projects will refuse to do this immediately as they may have had a major release planned already and can't do it prematurely. But this negatively affects other users if not informed. It's really a suck kind of exploit/problem.
So you seriously think that giving the developers a week would result in the same amount of possible criminals knowing and actively exploiting this security flaw? Is that what you are trying to say?
Missed R. Kelly opportunity.
You're expecting a response from project maintainers here. In the same thread where you throw project maintainers under the bus without so much as posting a github issue beforehand? Good luck with that, Scott.
That *might* be the case (although it's a very, very bald and most likely wrong claim). But what about the population of criminals that wasn't interested in exploiting Magento, but now is? What if this somehow leads to an RCE? After reading the whole thread, you are acting very irresponsible for a security expert.
Who is going to trust you to make any deal after your track-record of this stuff? You're doing security researchers more harm than good with this approach. At least that's how some people see it.
&gt;People who want secure code without compromises or sugar-coating. People who are perceptive enough to see that I've never leaked a client's vulnerability. People who don't settle for mere compliance. Lofty goals from someone who would rather throw people under the bus then open an issue and offer help.
It's good for updating/inserting a few entities at once. In my experience, Doctrine is good for getting your app up and running quickly, but I usually start replacing it in some areas soon after. For mass-updates, you'll probably want to use a lighter Model. This is where Doctrine gets very heavy. For pulling lists, it does a lot of extra queries. This can be avoided by using proper SQL Joins, and a lighter Model. Also, when pulling lists, returning foreign key values is a bit of a pain eg `['foreign_id' =&gt; $this-&gt;getParent()-&gt;getId()]` , rather than `['foreign_id' =&gt; $this-&gt;getForeignId()]`
Depends on what exactly you intend to improve :) If by "improve" you mean "prevent the coupling", then one of the ways is to separate the routing from dispatching. You create a separate router, which populates a `Request` instance based on matched patter and then have separate part of code actually executing class/methods based on data in the `Request` instance.
&gt; I thought that was toned down. Is it possible that something is coming across as sarcastic when it wasn't intended that way? /u/kemmeta summed it up quite well, cheers for taking up the criticism! &gt; &gt; Have you reported that issue to the Magento project? &gt; No. I'm curious why? Isn't there a "responsible disclosure" process when you should contact the project first? Or is it because Magento in the past didn't react as hoped to security issues? (I am not familiar at all with this so this is an honest question)
I watched this in a RES embed and it showed video about SRP. I have a question about that video. Why `resize()` and `validate()` are in a same class? Those are different responsibilities as well.
Yeah I get what you guys are saying, and what I sort of alluded to is we usually try to reserve those types of questions for our daily stand-ups anyway, so there aren't _too_ many disruptions. I just thought "horribly disruptive" was a bit dramatic. It's not like we're performing surgery or anything :P And come on, if we're coding in PHP, how complex are the problems we're working on? On the scale of DB CRUD to Mars Rover, we're probably rolling in the CRUD a majority of the time...
As always it depends :) If you take a look at api-platform.com, you'll see that out of the box it uses Doctrine. This might a bit slow in some cases, so you have to optimize a few parts, but otherwise with a good HTTP caching layer (with Varnish for e.g.), you'll be fine (we have some apps handling millions of requests per day and we don't even have to use any applicative cache ;) )
Yeah, i guess i should have named it differently. People keep mentioning that :) You also probably searched for stream libraries, where collections is what you had in mind - i.e. more generalized datasets. Glad you like Knapsack. If you have questions/ideas/etc just message me or create an issue/PR.
When you're knee-deep in framework, the problems can be pretty complex to solve well. I just spent a bunch of time (with significant amount of help from JavaScript) making a Solr search result click through the the relevant page, expand the relevant accordion, and scroll to the text within it that was matched by the search terms originally used. When the framework obscures a lot of the default behaviour, any bit of clarity (created by fellow developers) helps...
&gt; Maintaining your own closed source framework is likely bad because if you are doing something wrong you wont know about it This is true but the same time may also be an advantage in doing it. Maintaining a closed source framework versus using an open source one has the advantage that any vulnerabilities are being kept secret instead of been released to the public. Sure, with a popular open source framework as soon as a vulnerability gets discovered it gets patched almost immediately, but until you update your version of the framework your whole web application will be vulnerable. Also, will you have the ability to go back to every single web application that you've built using that framework in the past years and update it in time, in case a huge vulnerability gets discovered? Also, another advantage is that since the code is secret there is no actual way for a potential hacker to study it, find vulnerabilities and use them to exploit your application. Finding vulnerabilities in a popular and mature open source project by simply studying the code is going to be incredibly hard but not impossible. It may not be a framework but do you remember what happened with Heartbleed? God only knows if there were actual people who had discovered the vulnerability well before the OpenSSL maintainers and just kept it secret for their own benefit and for how long they were aware of its existence. To summarize, open source is much more secure by default because you have thousand of eyes looking at the code, spotting weak places and fixing them, there is absolutely no doubt about that. Of course that only applies if the project is a popular one and under active development. But having the code open apart from advantage might also be a disadvantage, as among the others it will also be available to malicious persons to study it. In my opinion, it all depends on how many people are going to be working on the project. If you are a single developer probably closed source is not the way to go, you may get the advantage of obscurity but the actual security may not be that good. No matter how much experience you have eventually you'll make a mistake and until you realize it, it may be too late. On the other hand, if you have a team of 4 or 5 experienced developers, developing and maintaining a closed source framework may actually make sense.
Also incredibly annoying, at least in my opinion.
&gt; But if you position yourself as a premium wedding cake baker you can’t just bring a regular strawberry cheesecake to a party. So you're saying if you're an experienced "premium" developer you shouldn't use frameworks? Sorry but this analogy just falls flat. You're comparing apples and oranges.
php-ds offers similar syntax and code comprehension benefits over arrays and array functions, so I don't agree with "all about performance". Lazy evaluation and streams will undoubtedly be implemented in later versions. 
 I went into this really wanting to like it but apparently I know too much about baking for it to actually make sense. Little things like &gt; But if you position yourself as a premium wedding cake baker you can’t just bring a regular strawberry cheesecake to a party. Made me cringe because everyone knows that cheesecake isn't a cake it is a pie. Sorry :-/
[removed]
&gt; I just spent a bunch of time (with significant amount of help from JavaScript) making a Solr search result click through the the relevant page, expand the relevant accordion, and scroll to the text within it that was matched by the search terms originally used. That sounds pretty bad ass man, nice work :)
&gt; I wouldn't say a disaster but its really only viable for small projects that are 100% web-based. (i.e. Most contract web work would fit in this category, its really only when you get into 5+ people sized projects that I'd say the project really exceeds the scope of Laravel.) Another disagreement I have is with this statement. I have worked on large applications and I have worked on tiny applications with laravel, and by large I mean many hundreds of device tracking based web related software that scaled to many companies and organizations using our software including private PI and even local law enforcement. Laravel, if done right and you don't get "silly" and wrap things with added complexity can be a fantastic framework to work with. Its when people start adding complexity like wrapping models in repository based systems and trying to build their own framework on top of it that it falls over, but thats generally their own fault and not the frameworks.
&gt; the largest issue, that comes to mind, are the (what Laravel calls) "facades". These are collections of globally scoped functions (also known as static classes), which are used everywhere. They are basically hidden dependencies. Some people keep repeating "they are bad because they are not real facades", but that's just BS. Call them "trigglypuffs" for all I care, because that doesn't change the architectural implications. You still haven't elaborated on why these are bad. I have written a few facades in laravel and they don't really hide the complexity all that much. They do allow you to "wrap" the complexity in something simpler and easier to use, but at the same time laravel doesn't force you to use them, there are way around them, some of those ways , yes are a bit dramatic and cause breaking points, others are not. &gt; next culprit is the eloquent. It is an active record based ORM, which is part of the framework (which is not in itself a bad thing). And since it's almost always used, this has major impact on your DB architecture, because your ability to normalize the tables is extremely limited (anything requiring beyond 2 joins is a performance disaster). It also means that you are tightly coupling (at least part of) the business logic and the persistence logic. And of course Eloquent's "entities" are accessed globally (using static class) and this create additional pressure in form of hidden dependencies. This one I wrap in entities, laravel calls them models but I create entity classes that extend the models to then allow me some seperation from the database. How ever it is in my opinion that if you are doing complicated 50 table joins you should re-think your approach. Are there SAP and such applications that use 50 plus joins, sure. But they usually have their own in house built software and frameworks. This is where I see developers fail to grasp the "modern MVC" as my old mentor would coin it, a concept that states dont make it more complicated then it has to be. People try and wrap things and abstract away and "don't let your tests hit your database, thats bad practice" like this is all BS. You don't need crazy abstractions and crazy wrappers. Use the framework as is, and only then start to abstract away. Let your tests hit the database, let your code be simple and easy to read. I don't want to chase down 50 classes just to find that one bug your "senior" developer made 4 years ago because you guys thought it was cool to have 75 abstractions over "models." &gt; mixing the routing and dispatching. Since each URL patterns is manually wired to a specific controller, this makes Laravel hard to use (if not - impossible) in large projects, because the routing file becomes extremely large. It also create a strange type of tight coupling to a specific class-method pair (thought, due to it's restricted location, it's not a major problem). This I will agree on partially. Only because the financial application team I am on is running into this and we haven't found a way to solve it yet. We have started running into 60+ routes and its growing to be a mess ... 
Depends on the project. Some people can architect around these "issues" that people seem to see.
I say do it. But do not release it to the world unless you have it go through a security test and have 95+% test coverage. Use it for small tiny non deployable sites. If you want to be the next laravel, zend or symfony, you will have to ask your self, what problem can I solve that these 500+ other frameworks can't or haven't solved in an eloquent and clean, secure way. By now you see why people hate x, y or z, some of their points are valid, others are stupid and laughable at best. Your framework should solve a very specific use case or problem that you cannot see being solved in other frameworks. With that said I would use symfony as the base, pull in some components, write some others ones. I would pull in the security based components though to cover your ass.
&gt;Got you covered That's what he said.
That title is very unfortunate...
POO?
Thanks for your feedback. I haven't used custom scrolling anywhere. Would be great if you can mention where exactly you felt so. I will try to fix if it's a CSS thing. The real inspiration is not Reddit, but sites like EchoJS, DesignerNews, etc. are. They are all well received even though there is a sub for all these topics. PHPToday is not just for PHP, but it's for PHP developers. We encourage links about related topics that is generally interesting to PHP devs (MySQL, Web sec, etc. for example). The job board is something that we have in the website, but not in r/PHP. I also have a few more interesting features in my pipeline :) 
Right now, my `/vendor` directory has 8,964 files in 1682 folders. I simply do not have the time to inspect them all manually looking for vulnerabilities all while I develop my actual application. Even if I could have a look at every single file, the real problem is that I know that my finding nothing blatantly insecure is in no way a proof that all this code is actually secure. Although I always code defensively and try to keep reasonably up to date, I'm certainly no expert and I would surely miss many subtle bugs. So what's the incentive for me as a dev? I certainly do agree with your first point: always `composer update`. But for regular devs without a specific security expertise, simply "looking into /vendor" is neither inherently useful nor scalable. Plus it can give a false sense of security, precisely because it might makes them/us go from a "*conscious incompetence*" situation to an "*unconscious incompetence*" situation: "*I have looked at it and found nothing so it's secure*". Frankly, I feel the only way to move forward is to get a composer-like (free, very simple to use, reasonably ubiquitous) static analysis suite.
The purpose isn't to be able to say "I've looked at it, therefore its secure" the purpose is to *look at it at all*. Maybe you only *really* know one type of security vulnerability, at least you can look at a lib or two and see if it has one of that type. Maybe you don't find anything, or maybe you hear about some other type of vulnerability, and start learning that pattern, which then, in turn, ensures at the very least that you don't make those mistakes in your own code. I think the point is that a little security consciousness goes a long way in improving security for everybody (maybe the one thing you know is bad is in being done in a popular lib?). 
It's not that easy to use though, I come from Django and it was a struggle. I'd say it's pretty complicated actually if you need to customize part of it even just a little bit. OOP with dependency injection everywhere, lack of config (hardcoded storage and env paths apparently alterable by some undocumented methods???), coupled with mediocre documentation (a tutorial really) and you're up for a bad time. It's really difficult to go past a simple CRUD app without a really good understanding of the internals and "modern practices". Blade is good though.
If they will introduce all the standard operations (map, filter, reduce, ...) and lazy evaluation it will be probably better than userland (as in PHP) solutions. However, your code will depend on an extension that's not shipped by default which can be troublesome. Also, i can't find good docs or roadmap. Can you point me to some?
There is also a tool that checks your composer.lock: https://security.sensiolabs.org/check
And yet it is important to write and run functional tests automatically/often (ideally using CI) in order to make sure everything is always fine on the application. Good luck on trying to fight against your company to improve that ;)
Of course you should, if somebody orders a plain cake. Here is another analogy: Let's say you ordered an inventory system developed, and the developers did it with Wordpress/Drupal using Custom Types (WP plugin) or Fields Drupal extension. Their though process was "why should we reinvent the wheel and come up with our own database structure etc, if WP/Drupal can manage all of it for us" It might even work for you for a while but since neither Custom Types nor Fields are proper ORM engines it will be slow as hell after a while, and really hard to manage. From a framework dev perspective you'd say they made a bad decision not doing it in a framework from the ground up. Now shift your paradigm up: Experienced developers working on high-scale projects will look the same at you if you suggest doing it in some general purpose framework framework just because it filts some requirements out of the box
Or add https://github.com/sensiolabs/security-checker and do it from command line (or even use grumphp to do a check with every commit ;)).
&gt; mixing the routing and dispatching What are the alternatives to this method? 
In this thread: a security researcher points out that software y'all use is insecure as fuck, and you shoot the messenger. I get that it's upsetting to learn that your trust in this software was misplaced, but please don't transfer those emotions to Scott. He has done you all a huge favour by telling you this. For those saying this disclosure was irresponsible, I disagree, and here's why: These flaws were utterly _trivial_ to find. A cursory reading of this code by anyone who has taken a crypto 101 class would reveal them. The main thing preventing anyone exploiting them is not that they are hard to find, but that the exploitation would not be trivial. *Anyone who could not find this vulnerability on their own could not exploit it* – so revealing this vulnerability does not put you at greater risk. Conversely, anyone capable of exploiting this vulnerability would have been able to discover it within seconds, if they turned their attention to the Magento codebase. (Seconds? Yes, `git grep -i ECB`.) It is extremely likely that attackers focused on Magento already _have_ found it, given how utterly basic the flaws here are. This is the crypto equivalent of missing out a semi-colon, or having an off-by-one error in a for loop. So be mad at the developers who wrote crypto code containing flaws that I learned about in week 2 of Crypto 101, and not the researcher doing you all a favour by telling you about it. A favour? Yes, because now you can at least make an informed choice about whether or not to run this software. Thank you Scott for your tireless devotion to security, even in the face of ingratitude and attacks.
I'm currently working on the php.net documentation for it, which can be found [here](https://github.com/php-ds/docs). Once it's done, we'll release a beta on PECL, and from there determine what's next. Agreed that a third-party extension is not ideal. It's possible that it'll become a default extension later on, but in the meantime the [polyfill](https://github.com/php-ds/polyfill) aims to cover those who run code without the extension installed (hopefully temporarily).
&gt; It's really difficult to go past a simple CRUD app without a really good understanding of the internals and "modern practices". That's what I meant about it easy to use... if you only use 5% of the framework that is designed for making simple CRUD apps, it is easy. To make the other 95% easy it would require better architecture and better documentation.
Or, you know, rely on the fact that the community builds tools to check `vendor/`. * https://github.com/Roave/SecurityAdvisories (simply prevents `composer update` from installing vulns) * https://security.sensiolabs.org/ (checks for currently installed vulns in `composer.lock`) Not everyone spends all their day reading all the code they get put under our nose. Heck, I'm running on a Linux machine and will likely never ever get to read more than 1% of the kernel anyway.
In keeping with the spirit of the thread title.... **rekt**
Whoever says CodeIgniter is bad and actively harmful.. you can all go screw yourselves. [It's no /r/php Laravel but it's still the bees knees, rite? :(](https://www.reddit.com/r/PHP/comments/25mdqi/10_things_i_learned_from_rphp/) I'll live in my legacy corner and start my own hipster php frameworks group when it becomes cool again to use outdated stuff that works :P
After yesterday, it was the final straw for some of us. He posted a security flaw he found in Magento without even contacting the developers and saying "here is what I found". When a lot of us called him on it, he continued to thumb his nose at us instead of us listening. Don't get me wrong, he is very smart and knows a lot about security. But he will frequently go on rants on twitter and irc about how he is doing this and not getting paid and blah blah blah. But he is also a one trick pony. While other developers in here can just hold conversations and talk and be enjoyable, /u/sarciszewski is always security. He will frequently post his CMS he wrote, which is insanely secure, yet looks like shit and doesn't like it when people tell him that no one will want to use it in the enterprise area cause of how bad it looks. Just my two cents. 
It relates directly to what I was saying about mopping the parking lot while it's raining.. you have hundreds of people trying to exploit it, and people constantly releasing security fixes to libraries. You're fighting a losing battle and it isn't a good way to spend your time.. If you're going to learn about security vulnerabilities and things that you can find in the code it's better spent on something that you know has security issues and you have to find it... That way if you can't find it, you know you're missing something for sure vs. not knowing for sure.. and you use it as a stepping stone to improve your knowledge.. blindly attacking something isn't an efficient use of time. Someone who already has all the knowledge can go after security holes in their code if they really want too.. but again it's not a very efficient use of their time - you're competing with huge numbers of others that are doing the same thing. Your free time is valuable, use it on something that will gain you something whether it's personal happiness, new knowledge or many other things.. you're effectively wasting your time doing what was suggested. Once someone has the proper knowledge they can make their own informed decision on whether they want to spend their time on it.. 
useless.
As a more specific question, how would you wired up the routes without using a routes file? Would you recommend automatic route resolution based where the route matches the class name, i.e /blogs uses the BlogController? &gt;If by "improve" you mean "prevent the coupling", then one of the ways is to separate the routing from dispatching. You create a separate router, which populates a Request instance based on matched patter and then have separate part of code actually executing class/methods based on data in the Request instance. Laravel's router doesn't actually dispatch the request, it dispatches the dispatcher. The Router object, Illuminate\Routing\Router requires a dispatcher in it's constructor. Basically, the router matches the pattern and then passes the individual route to the dispatcher in order to get the response. I suppose you could move the dispatcher up to the kernel class and have the kernel get the route from the router and then hand it to the dispatcher, but does that actually improve the code? Would you mind going into more detail about your thoughts on this? Thanks.
It's basically "check dependency of your project" for security reasons. Say, I am including: - packagea-2/some-cool-library: ~1.1 - packageb-2/others-cool-library: 1.1 etc etc then, check per package dependency (again) to see what library they use and do research what is security issue on each package. wow!
...uh ssd storage vps's are way faster than traditional storage solutions... 
Oh yeah, like fucking Facebook, right? You clearly don't know that much, do you? On the other hand, why would you know? If you say paypal, uber, linkedin, netflix, etc. are ALL using nodejs for everything, you clearly don't know jack. Those companies will use whatever tool is best for the job they need. NodeJS is good for some things, PHP, for others, Go for others, etc.
If you don't think, that removing tight coupling is an improvement, then I'm not sure what else to say.
Well there's also the impact of the vulnerabilities found. Consider this: echo substr($_GET['var'], 0, 2); Sure, it's XSS, but since you're only able to insert two HTML characters into the text it's impact is minimal. A lot of the issues sarciszewski finds are, I'd say, conditionally impactful. Using ECB is a bad idea, sure, but how impactful that is depends on if the DB can be compromised. He's also found timing attacks of dubious impact. See http://crypto.stackexchange.com/a/27315/-999 for more info. Not all vulnerabilities are equal and some just don't merit inclusion into Roave/SecurityAdvisories.
Yah. Well I don't like reddit's self-moderation system anyway. I like slashdot's a lot better. A post can be downvoted to -1 at most and can only be upvoted to +5. But I suppose that's a topic unto itself lol
I'm not saying removing tight coupling isn't a good thing. I'm asking you to explain why you think it's tightly coupled and how you would go about improving it. 
&gt; I sure as fucking hell audit everything myself at a minimum before I dare to call something "secure". I am convinced.
You can check Symfony CMF http://cmf.symfony.com/. It is a Content Management Framework. I've built a website few years ago using it and it didn't feel mature enough, but maybe a lot has changed since.
My QA team writes acceptance criteria and developers then implements steps for it. So QA tells how to test and devs actually do test automation. One single note, tests before implementation.
&gt; I think highly of Roave, but "inclusion into Roave/SecurityAdvisories" has literally never crossed my mind as any sort of goal until I read your comment. Oh lol. TIL. Sorry for implying that!
[removed]
[removed]
[removed]
First, kudos for the click bait title. Good one. Secondly, I totally agree with your point. The more eyes, the better. Most popular libraries we use on daily basis are often overlooked. You install it, use it, but people hardly take a look at the actual code. I figured out the very first security issue I was credited about 6 years ago, and it was nothing but a "this looks weird" thought. It wouldn't work if you have a tight deadline and have started to like a particular library. Sure you do need to learn about security. Overflows and such vulnerabilities hardly occur in PHP user land code, but the ones we do make are quite silly ones. Even the elite can forget to sanitize a variable before printing, or have a router that is CSRF vulnerable. All these security issues I have found out always happened because I was looking for something else. Thirdly, a keen eye in security can help yourself as well. The more you keep your mind charged with security, the more natural you will be. In a rushing back athin,f or example, an extra CSRF token or form implementation can slow you down. But there are libraries to help you get things done quickly, and when you are used to them, you can easily notice other people's code issues. Lastly, finding out a security issue gives you credit, mentions in CVEs, and can help you land a better job as well. This is in reply to the other person who said "what's in there for me". 
getbootstrap.com foundation.zurb.com materializecss.com purecss.com these are meant for developers so we can get by without a designer.
Studlycaps? Huh. Never heard that one before. The ones I've heard are: - camelCase - TitleCase - snake_case - kebob-case
The UI looks nice but my biggest issue would be it only seems to allow the editing of one row at a time. Ain't nobody got time for that... Any plans to allow for bulk editing in the future?
Man... c'mon. "Appeals to people who care more about pretty/shiny than security/usability"? That's not fair and you know it. Like it or not, the front end is a major part of web development, and it's possible to care about it and security at the same time in appropriate amounts. The criticism of Airship's front end is warranted. Let go your sarcasm for a second and just accept it, and you'll approach the solution with a better, or at least a less defensive, mindset.
Hi, thanks. :) Bulk Editing is on the list but hasn't a big priority: https://github.com/philiplb/CRUDlex/issues/37
Found a typo: *returnreturn['name', 'email'];* Also you can view more complete documentation from their docs: https://github.com/yiisoft/yii2-elasticsearch/blob/master/docs/guide/README.md
Nice. How well does it handle foreign keys?
They're still separated by the driver with emulated queries. A broken driver probably isn't much more likely than.... well, nvm, you're right. The driver or object instance can be misconfigured, whereas MySQL can't be because it knows the current charset and weirdass NO_BACKSLASH_ESCAPE settings at all times.
It states to not forget to set them in your DB. :) Currently, only one-to-many relationships are supported. But at least, many-to-many has a higher priority than bulk editing. ;) https://github.com/philiplb/CRUDlex/issues/20 Currently, you actually can do many-to-many via a separate entity.
there is already a well known library called Stash: https://github.com/tedious/stash, you might consider renaming yours
You should check out phpci
Yes it's a typo. Done by mistake. Return will only one time.
Your page seems broken, it only shows the Apache2 Debian Default Page.
When I saw this I did a double take. Seriously should be renamed. 
I don't know the specifics of tribalwars but if it's anything like OGame you would be better off using NodeJS (i personally don't like it but it's made for asynch stuff, and a game like that is just that).
I see, so this means feature freeze for PHP 7.1? 
Effectively, yes. I'd like to see if the argon2 ext/password stuff might could get in (still researching on my end about it). And there is the session hashing RFC that needs to be revoted on.
Your concerns are all silly. Don't like facades? Don't use them. I don't. I interface what I need, and dependency inject everything. Can't normalize with eloquent? Nonsense. I have fully normalized data on complex projects. For situations where an ORM is not appropriate, don't use it. No ORM is 100% appropriate all of the time, AR or DM. It's your job as the developer to know when it is and isn't appropriate for which queries. Laravel offers two lower level abstractions around the DB to gain more direct control over your queries if you need, and you can seamlessly switch between them as needed. You're not locked into Eloquent for literally every query. Coupling of business logic and persistence logic? [That's on you as the developer, not Eloquent](https://medium.com/laravel-news/separation-of-concerns-with-laravel-s-eloquent-part-1-an-introduction-c9a6dc6b4a65#.52dqx2qdt). Eloquent doesn't prevent you from wrapping it in your own abstractions to keep infrastructure out of your domain. And btw, leaking doctrine em flush everywhere in your domain is just as bad. It's YOUR job to keep your domain insulated from infrastructure, as you see fit. Not even sure what your argument about routing is. There are several ways to organize routes for large, complex applications. If you're just putting everything in one routes file, you don't know Laravel well enough at all. I work on an app with over 600 routes by my last count. Tight coupling between a route and its handler? Yes... That's sort of how you define routes. Not sure what your complaint is... All of your criticisms are based on a lack of understanding and experience using Laravel.
I want to use SemVer as soon as the 1.0 is hit.
thanks! fixed
That's such hogwash. I work on a project with 250 tables. Legacy tables that I had to wrap eloquent around - I didn't even have the luxury of defining those tables according to Eloquent's conventions, and the app is perfectly maintainable.
Customize what. Give us an example.
Recommendations? Out software should support 5.3. Possibly this (from php.net): $xml = simplexml_load_string($xmlstring); $json = json_encode($xml); $array = json_decode($json,TRUE);
`app()-&gt;useStoragePath(...);` `app()-&gt;useEnvironmentPath(...);` Lines 389 and 414 of src/Illuminate/Foundation/Application.php Call these in `bootstrap/app.php` What else are you having issues with?
Great idea! Could use it right away. However, I have proposed you some changes (because I love refactoring): https://github.com/wsdookadr/fieldtop/pull/5 Introduced: Symfony Console/Table, PSR-1/2, Namespaces/PSR-4, Composer and some new features. 
&gt; As a web developer, you should know client and server [...] True... to a certain point. Yes, you should understand the role client-side languages have on the application and even be able to write code to some extent, but I don't believe one can truly master both sides. Client-side development went through a huge evolution from the 90's to where we stand now and nowadays the three languages (HTML, CSS and JS obviously, but who knows what's coming in the future) have complexities that rival the server-side. That's the main reason I really dislike the full stack term: It misleads recruiters and non-tech people in general to think you're a "one-man web app factory".
Sorry, but it needs to be said: What a terrible, terrible name for a feature in a website like StackOverGlow. PHP, as any language that can call itself a language has one and only one *Documentation*: The official PHP manual: https://secure.php.net/docs.php Calling any other web resource "Documentation" is misleading to say the least, borderline unethical. "There's a request for handling files, paths", etc... Sorry, but it's absolutely impossible not to chuckle on such an idiocy. There's no such a thing as a need for something like that, since it's easily found on the PHP Docs: https://secure.php.net/manual/en/refs.fileprocess.file.php Dumb idea, horrible name.
Wasn't it that PHP-internals has a bunch of regressive coding standards that'd scare anyone trying to write modern code? (Everything in a global namespace, etc.)
I dont think node JS is what I want. But thanks for that.
People still use them. Just the other day a guy from Colombia was on the chat channel, using 5.2. But sure, maybe it's time to reconsider.
Bolt developer for almost 3 years now, the community is amazing!
StudlyCase seems to be any casing where letters are capitalized throughout a word/phrase according to a ruleset of some kind. For instance, all the following are studlycase: - StUdLyCaSe - StudlycasE - StudlyCase - STuDLyCaSe
I'm not really a fan of mailing list ads. Shouldn't this have some sort of alpha / demo build before it gets submitted?
I just don't get this product? What the hell is a stream?
I really like this one: http://www.sonarlint.org/intellij/ 
I still don't really understand the constant downvotes you're getting, but I have to say, this is a bit of a value-free post. Sorry.
I just introduced the RFC for discussion on Monday (wiki.php.net/rfc/argon2_password_hash) with a working patch, so we'd be looking at August 1st before a vote can be called - assuming there isn't anything that needs to be addressed. I'd love to get it in 7.1, but I didn't get the implementation done fast enough. 7.2 is more likely.
&gt; Calling any other web resource "Documentation" is misleading to say the least, borderline unethical. Don't be so ridiculous. The site clearly says "Stack Overflow" on it.
thanks
I don't do anything with the client. I make everything work. I don't make it look pretty.
It's an interesting idea. Certainly makes static analysis more convenient. But, at the same time... once you get a "build failing" due to a false positive (which happens all too often with static code analyzers) you're liable to dismiss all subsequent "build failing" messages. It'd be cool if you could flag a "flag" as a false positive and have it remember. eg. $mysql-&gt;query("SELECT * FROM companies WHERE company_name = '$_GET[name]'") That certainly looks bad. But what if before it there was this?: switch ($_GET['name']) { case 'Honda': case 'Toyota': break; default: exit('bad company'); } It may not be best practice to do it that way instead of using prepared statements but it's not a vulnerability and yet a lot of static analyzers would identify it as such.
Okay that sounds interesting, so a stream is actually just a data set? If so why would you use/pay for a 3rd party 'SaaS' when you can access the Facebook API directly? Or am I missing the point?
Assume each "new text" is one line from a file full of lines (your list of texts). Write a function that reads line N of the file. Now use the rand() function to generate a number between 1 and the number of lines in the file, and pass that to your readLine(N) function.
This is really simple to do. &lt;?php $texts = [ "This is an interesting sentence!", "This is even more interesting", "Unbelievable how interesting these can get!", ]; echo $texts[rand(0, count($texts) - 1)]; The code should be pretty self-explanatory.
You're welcome :)
In sorry but doesn't the lack of consistency bother anyone else? I've only just recently dived into laravel and i had problems reading the documentation until I realised that i was reading the wrong version. But their website selected v4 by default. It seems they change their directories and file placements every version they make. It has significantly lowered my opinion of laravel, that and about of other things to. 
16.04 is LTS, it will not change versions for its lifetime. 7.1 PPAs will be available, so it won't be hard to get 7.1 running on 16.04 though.
Is it legal to use [ and ] for arrays in php? I've never seen anyone use it apart from in javascript. Is it a shorthand? 
&gt; But their website selected v4 by default. Weird, mine goes to the latest version. I've noticed sometimes google indexes 5.1 or 5.0. As to inconsistency in Laravel, this has troubled me. I, like a lot of the php community, adopted the command bus pattern a couple years back. I think it was still Laravel 4 and I was using Jeffrey Way's package. I was thrilled when Laravel shipped with command bus pattern(5.0) and used that in my next project. 6 months later, at the time of the next release(5.1), it was gone from the documentation. 5.2 rolled around and laravel's command bus was completely altered. This delayed our update to 5.2 for quite some time as there wasn't a compelling reason to upgrade to 5.2, or at least not a reason compelling enough to invest the time to port our commands. That all being said, the changing of the directory structure is a good thing. By removing the mostly unneeded directories, Taylor has simplified the code base. This will make it easier for newer programmers to adopt laravel and php. This change benefits the php community at large, as it lowers the learning curve. There is little if any downside to the change. Having the folders in the code base by default, created some amount of consistency between laravel installations. We may now lose this consistency, with developers choosing different folders, but I don't see this is as a bad thing. It encourages developers to make decisions that correct for their project. The directory structure change is different than the command bus changes since the relationship between commands and their handlers was based on naming conventions. The events, jobs, and listeners are all resolved using PSR-4. Their location as dictated by Taylor is not relevant, you're free to move them where ever you want. This change aligns Laravel with my ideas of what it is as a framework. A framework that is simple enough for most junior level developers to come in and understand, but free enough to allow more advanced engineers to modify it to their desire. That all being said, I am skeptical of new features added to Laravel. I was burned by the command bus implementation and never adopted Laravel 5.2's api token authentication for fear of the same. I believe Taylor introduces these ideas and lets them evolve for the better, but if you invested in these ideas it can be harder to update to the latest version. I really enjoy how Taylor released [socialite](https://github.com/laravel/socialite). It's a separate package that you can opt to include in your code base if you want. It plays nicely with laravel and is easy to use out of the box. I wish he'd release more features like this. If the command bus had been a separate library, maybe I wouldn't have had to spend the time upgrading it. As these experimental features mature, they can be moved into laravel core. Though maybe keeping them separate will help to reduce cruft in the framework.
I didn't know about this library before. However, looking into it it's not quite the same functionality I was looking for.
Well, I've changed the way functions are generated. Now they're saved in a separated file and include it (or create it if it doesn't exist). This results in a highly performance boost and security (no more `eval`), it also provides a short documentation of the function with a link to PHP's manual entry.
Maybe try a Lorem Ipsum generator.
The hero PHP needs and wants.
By value-free do you mean like moral value-free? eg. opinion-free? Otherwise I'm not sure what you mean lol
A majority of developers using laravel did not use them anyway. I never used them in any of the apps I created on laravel.
I am an avid Laravel user now, after some time with Code Igniter; and I have to say recently upgraded an application to 5.0 from 4.2 (I had no experience with 4.2) and the fact that filters got completely removed for middlewares and the way namespaces got forced and such made the upgrade slow and painful with so many errors. now I am stuck in 5.0 limbo where the application needs more updating before is ready for 5.1 but the customer doesn't have the budget for it anymore.
What is the best way to do that? (I'm new to those things)
I am the only one who is on 5.1 LTS?
Events and listeners even? Maybe it's because i have a WordPress background but i find them invaluable. Also jobs are basically how you handle queues in laravel, so I'm surprised you haven't used them much either.
I think they were groping for "worthless", as in not valuable enough for the few seconds they expended looking at it. Which is fine, that's their opinion. I was giving this a whirl earlier this week. Chris Cornutt shared it on Twitter and I thought it would be useful to share here. (I'm not affiliated with this project in any way beyond getting the opportunity to look at it before he tweeted about it.)
Well, yeah thats an e-commerce background. I've never had to work on an e-commerce, I do stuff with server control panels for games and account management. 
Damn, and here i was using $x = array() like a fool. There must be some list of all the shorthands somewhere, or am i expected to read every changelog? 
Just curious. How did you end up learning it? Can you also explain what "pure" oop is and how it is better than "usual" oop? Is there some code that you have written that demonstrates these advantages? I mean, is there some pattern that is only possible or easier to do in pure oop?
If you want it to be fast, use Phalcon Micro it will response 10X faster then other frameworks mentioned here and using less resources and memory. 
Well pure OOP means truly everything is an object, and that every operation is a method call(or message sending in smalltalk's concept) between objects. In Smalltalk, an operation 1 + 2 is actually calling method 'plus' on '1' with parameter '2', which is fundamentally different in most languages such as Java and PHP. Consider another example, the typical if...else condition is a procedural language construct, you write an if statement to control the flow of the program: if(statementA == true){ // do operation A } else{ // do operation B } In smalltalk however, there is no procedural construct for if...else, instead you think in terms of a boolean object. You use method chaining on this boolean object, to carry out ifTrue and ifFalse operations, like this: booleanObject ifTrue: [Operation A] ifFalse: [Operation B] In fact, in this case Operation A and Operation B are closures attached to ifTrue and ifFalse method(or more precisely, ifFalse in this case is a named second parameter for method ifTrue, but discussing this is beyond the scope of this topic). With scalar objects in PHP(check Nikic's scalar objects extension for reference), you can implement something similar in PHP: $bool-&gt;ifTrue(function(){ //Operation A })-&gt;ifFalse(function(){ //Operation B }); Although PHP's implementation has many limitations and feel a bit unnatural, the above code should give you an idea of how smalltalk's pure OOP is about. The idea is to think in objects, instead of thinking about an if...else statement, think about boolean object and what a boolean object can do(its behaviors/methods). This process helps me a lot understanding OOP, and with this I was able to do true object oriented programming (OOP), rather than just object based programming (OBP). In the former object is the core building block of everything, while in the latter you just use objects to do procedural programming. Of course, there are more to what I've described thus far, but its a good starting point. 
It'd be great if you could push for this patch in PHP :) Thanks.
They're generally really handy for webservices where you don't necessarily need the response right now, like updating external systems. I also use it for sending emails.
Yeah, I find it really strange to to map my domain objects in that way, too. 
Aw, I wasn't really groping. I just think posting a link to a page that lets you sign up for something but doesn't have any information about what that thing is, doesn't have any value.
If you found the results using Google, then Google defaults to V4 due to higher rankings. If you go direct to the site then it will always default to the latest version.
The article is a bit unclear about where the optimization lies. It makes it sound like replacing `hash + (hash &lt;&lt; 5)` with `hash * 33` is the optimization -- which is not the case. In fact, any modern compiler will automatically convert the latter into the former (though from a quick test, the manual transformation for some reason ends up being faster due to different instruction scheduling, which is odd). The actual optimization is the part where multiplicative distributivity is used to eliminate data-dependencies, i.e. the part where h = 33 * 33 * 33 * 33 * h + 33 * 33 * 33 * str[i] + 33 * 33 * str[i + 1] + 33 * str[i + 2] + str[i + 3]; is used instead of a simple sequence of the primitive operations. --- As a semi-related anecdote: While optimizing some code recently, I've found that uint64_t x; // contains 4 13-bit integers uint64_t a = x &gt;&gt; 48; uint64_t b = (x &gt;&gt; 32) &amp; 0xffff; uint64_t c = (x &gt;&gt; 16) &amp; 0xffff; uint64_t d = x &amp; 0xffff; // Use a, b, c, d for other purposes here uint64_t s = a + b + c + d; was significantly slower than computing that last sum using uint64_t s = (x * 0x0001000100010001) &gt;&gt; 48; even though the variables a, b, c, d were already extracted for other purposes. I found it somewhat surprising how much of a difference this made.
~~Worth noting that in the context of password, slower is usually better :)~~ Comment retracted, please see below.
Yes but.. if you slow down your implementation of a defined hashing algorithm, it isn't. An attacker will use the most efficient implementation possible, putting them at an advantage.
True, I suppose the correct point would be that in the context of password hashing, an algorithm which is _inherently_ slow is preferable, which actually debunks my original point because if you choose a slow implementation of a potentially-faster algorithm then you open yourself up for attack.
Already replied to this same question at https://www.reddit.com/r/PHP/comments/4teo55/yaml_12_in_php_does_anyone_know_whether_this_is/d5i0g2d
Said it before: mappings are cached anyway, so no runtime difference.
We already did research on closures for mapping purposes: it won't work unless we have a proper code-inliner (and again, caching for the inlined code, via opcache). The performance impact of using closures for field mapping is a disaster, as it stands.
Like I said, it's not best practice, but if you start lumping possible future vulnerabilities together with actual real vulnerabilities you're just creating white noise and making it less useful as a whole. It's like... putting a 19yo who had consensual sex with his 17yo girlfriend on a sex offender list dilutes the list and makes it less valuable. If you want to look for places where your code isn't following best practices you should use a best practices scanner - not a vulnerability scanner.
Yes, and benchmarks are done with proper calibration too (with https://github.com/phpbench/phpbench )
And ties you to a domain name 
It's amazing to see breaking changes on each Laravel release and still see people blindly praise it. Oh devs, pls never change. edit: so many triggered people hahaha &lt;3
This isn't a breaking change. Anyone in this thread saying it is has obviously never used Laravel nor do they understand at all how Laravel works. These directories were empty by default. So now we just create them when you run the "make" Artisan commands. 
It's. not. a breaking. change.
Except this change is backwards compatible.
I use a cronjob for stuff like that.
Gonna check this out tonight. Thanks you so much!
I namespace mine under the domain concept that they represent. If I wrote a Twitter clone in Laravel for example, I'd have something along the lines of: app/User/User.php app/User/UserRepository.php app/User/Validators/CreateValidator.php app/Tweet/Tweet.php app/Tweet/TweetRepository.php app/Tweet/Validators/UpdateValidator.php etc. IMO this is a much better way to structure anything but the most simple app. Regardless, you can choose where to put the generated models when you use `php artisan make:model` with a flag.
ITT: Major framework changes cause backwards compatability issues.
Except the change is backwards compatible. ITT: Devs who have never used Laravel talking about things they don't understand.
It certainly is of you are rewriting the entire directory structure on each major update. It makes it a huge pain to migrate. 
There is.
That's the point!
Gee, i *really* want to use it now! The support is so welcoming! 
Support? This is Reddit, not Zendesk.
Last word. 
&gt; an algorithm which is inherently slow is preferable Should also be qualified as an algorithm that requires just as much work to attack as to generate. [You'd be surprised at how many steps you can, as an attacker, skip, when trying to brute force hashes](https://hashcat.net/events/p13/js-ocohaaaa.pdf).
NetBeans and Eclipse PDT are $0/month, even :)
&gt; So what does PHP use as a hash function? It uses fundamentally the Java hash function, a simple polynomial hash with a prime multiplier… 33 is not prime...
&gt; The actual optimization is the part where multiplicative distributivity is used to eliminate data-dependencies I thought that was clear, but maybe they updated the article?
Nope, I much prefer: &gt; Domain/User/Model &gt; Domain/User/Validation I don't use an IDE, I use atom, But none the less, I prefer this
Oh, I get you now. That's clever, I might start doing that :)
Thanks =) To me, it resembles the hierarchy of a package that I import, so I figured I'd do the same. the only difference is that the models aren't stored in a CoolName/src/ folder and the CoolName/ folder is in /app instead of /vendor
Does anyone know if there is something like this for [kahlan](http://kahlan.readthedocs.io/)?
This is the [djb2 hash](http://www.cse.yorku.ca/~oz/hash.html), or Bernstein hash. It always uses 33, and it works well for reasons no one really understands. It's used all over the place, not just in PHP. The author of the article has made the error, not [Daniel J Bernstein](https://en.wikipedia.org/wiki/Daniel_J._Bernstein).
I don't know about a specific list, however you've clearly not been paying any attention to PHP release versions and other people's code. I'd suggest you immerse yourself a little bit more into learning about PHP's versions, what's in them, how those features benefit you, etc. Maybe read the code in third party libraries more often. You can learn a ton just by seeing what other people wrote.
Domain in this case likely referred to the core application code, where your business logic is. Not a dot com or similar web address domain.
I do not use repositories as I personally think making too many abstractions on top of a framework is detrimental to the main purpose of said framework. With that in mind I do use Entities, but not in the way people are accustomed. Entities are just extensions of models with logic you would not put in a model but are tied (in some aspect) to the database. So I place those in `App/Domain/DomainName/Entities/ModelNameEntity.php` Our company doesn't make a lot of abstractions on top of laravel, which is nice because it makes it easier for new people to get up to speed quickly. Our app is also quite large with a large customer base :D
I dont really understand what you mean with that.. Can you give me a more practical example? (with your directory structure for example)
What is the best way to learn php?
vim can work with phpdocs, auto-complete, and debug with a couple of packages. I can also switch out of PHP and do my ruby/python/C++ work without any real changes. IDE are also awesome because they come out of the box with a lot of tools without all that much customization. I personally use vim because (almost) every server works with it and I am constantly fighting IDE's for customization. 
I would consider vim to be an IDE. I was more so referring to editors like Notepad++ with no code completion, debugging, etc. 
Everything about what you said makes no sense. The directories are in the same place as they have always been. They are just generated as you need them (in the same place they have always been).
People who creat a model file manually are probably able to create a folder as well.
....
Correct, it is the organization of it that should be somewhat consistent. I understand that removal of "empty" folders makes for cleaner install, but not understanding why other people like those empty folders in place is odd to me. If I have a model that I am going to reuse for another project, Artisan does not create that for me. I can just put a \Models directory in the app and it will auto load but why not get programmers of a community to just have some basic standardization. On install I know where to look for controllers out of the gate. Models are an item most people use unlike events and jobs. 
I work with teams of developers. They are at different levels of ability. I have to specifically tell the newest users of Laravel where to create a directory and how to keep consistent with future development. I understand your point, and understand how a "solo developer" can easily control his environment as needed. Unfortunately I do not have that luxury. As of now, 9 times out of 10, we as a whole look in app/Models 
I have plenty of sites running several version of Laravel, from 4.2-5.2 and I've never seen the need to upgrade the 4.2 to 5, let alone from 5 on up. I'm sure there are cases where it's important for certain new features, but I don't really understand the need to keep every Laravel site upgraded to the latest version. There are not any security issues to worry about and even if there were a security problem that pops up in 4.2, a security fix will for sure be provided by T Otwell or by the larger community. In any case, this service might be helpful if you need to do lots of upgrades: laravelshift.com I've never used it but the prices seem reasonable and I've heard from others that it works.
Which wasn't a default folder to begin with ...
Thanks, i will! 
I've been working with PHP for the past 5 years have experience with frameworks such as Laravel. I love back-end development and want to keep learning. I want to learn a new language to help me understand why I do things when I code. I've played around with Python but trying to decide if I want to learn Java, C++ or another language? As a web application developer, what languages do you use? 
If you already know the basics, check out [PHP: The Right Way](http://www.phptherightway.com/)
Correct, events and the folders removed were. Models just was placed there to follow convention of where are things for the App/* They were initially put there for a reason for organization, now removed for a reason of not used very often. Again it is nice to know the organization by structure not amount of use -- FOR SOME OF US. 
But... there is no question where to place them? Laravel literally generates the location for you when you run `php artisan make:job` for example.
models directory gives direction to where things are located, app/User.php doesnt make sense to my brain, where as app/models/User.php does as we are conditioned to give "relationships" to things. User.php that is a model belongs in a models directory. The above is my opinion, you are open to your own. Don't get offended.
This is just how the companies I have worked with and how coming from rails things have been done, you are open to doing what ever you want i what ever way you want. Good Day to you
WE REUSE quite a bit of code, so artisan make commands are not always used. I am just giving you examples of scenarios that happen when using frameworks in a team environment. When you ask a developer, who is new to a project, to look at xyz to fix a bug. It is REALLY nice and SAVES US time if that person knows a structure that 9 times out of 10 are consistent. (Applies to every framework) They can look in Controllers/Models/Jobs/Events folders etc to see what code is there If the job folder is empty: Then there isn't a job there to look at and move on. If it is non existence: It may be somewhere else (which this flexibility causes) If the initial programmer made a folder called /ThingsILike/ ... (after firing him :)) ... we wouldn't know what that is, what types are supposed to be in there etc. Just letting you know on a day to day on projects that aren't "new", over the course of laravel we have to ask our selves which version is it on and what is different because of that. Sorry if my explanations are not making sense, it just has some business logic behind it. 
Parsing HTML with regex is WRONG. 
TIL about simple polynomial hash with prime and it's just great. I "knew" how md5 and sha works but it's a voodoo shit for people who are not much intro cryptograpchy like me. Than low prime * hash + ch was amazing.
Lol these negative comments. Sounds like the Windows 8 complaints cause people can't find their thingy. One aspect no one has touched on is pre-documention before you even touch code. No one uses a scope doc anymore? Before I open my code editor I always have my scope docs, wireframes, db schema, site flow chart, namespace conventions, required plugins, CSS framework (if needed) etc. up and ready. That should determine your folder structure and patterns used. Not the framework. Hence why I love Laravel. Small apps one way and as requirements grow another way. How is a model folder with other folders nested ten deep help at all? Laravel, even though it utilizes a lot of other frameworks pieces, isn't ridged with mandatory conventions for a reason to make the framework work for you. Not make your code work for the framework. The old saying "square peg in a round hole issue. Make the hole square or the peg round, which ever is easier stupid!!!!"
Calling it html_decode isn't very logical when what you are actually doing is parsing it into an array.
Neat tool, but I can't get behind this fad of *testing* tests. What's next? Testing the tests that test the tests…
~~The closest thing that I know of is `\SplStack` http://php.net/manual/en/class.splstack.php~~ TIL `\SplQueue` - http://php.net/manual/en/class.splqueue.php 
Just placed one that failed out so should help test a bit. It's a repo with code ranging from 10+ years to this year (thankfully already re-writing it). 
Yes, the words &gt;The reason this might help might be that it breaks the data dependency: instead of having to wait for the previous multiplication to finish before another one can be issued, you can issue one new multiplication per cycle for up to four cycles in a row. from the original blog post seem relevant. Also the part where he says &gt;It is true that a shift followed by an addition might be slightly cheaper than a multiplication, but modern compilers are quite good at working this out on their own. 
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
No, PHP arrays are not better performance wise than specialized data structures, their advantage is their universalilty. Implementing a queue *in PHP* is not efficient because in the end you will have to use PHP arrays. But there is an extension (i.e written in C) that brings efficient data structures to PHP 7, including a Queue: https://github.com/php-ds/extension (they also perform better than the Spl data structures and have a much nicer interface)
Agreed, the ST3 xdebug plugin is a dog, imo. It's possible to get it to work, but the UI is funky with the extra panes that sometimes close if I hit the wrong key, or go blank and won't close. A guy I work with uses ST3's xdebug plugin on a regular basis, but he runs into the bugginess too...he just lives with it because ST is so laser-fast. I've used PhpStorm's xdebug UI on a few occasions, and found it rock solid and far more intuitive than ST3's plugin. I still feel more comfortable editing within ST3, though. the speed. I can't quit you, sublime.
PHP arrays are not arrays. [Per the documentation](https://secure.php.net/manual/en/language.types.array.php) they are actually ordered maps. That is, a map which is also a linked list. Pushing and popping elements are O(1) operations. Shifting and unshifting aren't, because they recreate the numeric keys each time.
There are so many ways it could break. Here is a simple example: $html = '&lt;!-- this is &lt;b&gt;comment&lt;/b&gt; --&gt;'; var_dump(html_decode($html, 'b')); This incorrectly spits out a &lt;b&gt; element when no such element exists. 
&gt;Why is there no true implementation of a queue or stack in PHP like there is in C++? PHP's target uses doesn't really require a special stack structure, the fankenstein-type of `array` tends to be just fine whether you want an array, queue, stack, hashmap or other things. It's perfect at nothing but often serviceable almost everywhere. &gt; Is it because you aren't allocating/deallocating any memory in PHP like you are in C++? That's unrelated - all the memory allocations and de-allocations are just handled by the PHP interpreter. &gt;For pointers to front and backends of queues, I would just use some arbitrary literal and increment / decrement as things were dequeued and enqueued. Whether that makes sense or not depends on how you layout the memory at the lower level. In PHP, though, you shouldn't really have to care, you just look at the docs for `array` or whatever and see how it advertises you can interface with it. &gt; After searching online for awhile, no one has really implemented a raw php implementation of a queue, rather just using the arrays(list) data structure. Is this better than a queue in some performance or size? The majority of people writing PHP don't really care about having a strict, optimized queue. PHP's target uses and the need for such a thing coincide very little. PHP's facilities for doing it aren't entirely optimal, but they're famous (and infamous) for being flexible to the extent that you can probably use the `array` type for whatever you want in most cases and the difference in performance with a theoretically perfect implementation of what you want wouldn't be worth worrying about. In the world of scientific computing or other areas where more strict, performant data types and structures make all the difference you'll find them. 
With the exception of doing a quick commit that will take under 5 minutes to implement I agree with you. I don't have my IDE running all of the time and those quick fixes almost never require loading an IDE, in which case I use BBEdit. 
Yeah I can think of tiny exceptions like that too. I more meant preferring it as your main tool. A Leatherman is handy at times, but it will never replace a proper shop when you work on cars for a living. Same principle here.
[removed]
Totally agree and am just as flabbergasted when developers adamantly say they don't need an IDE. I have a 2015 MBP and the boot time difference between atom and php storm is trivial, ST3 is like a few seconds faster. I work between at least 3 projects at any one time so I just leave up several instances of php storm or web storm depending on the project, usually with many more docker containers running as well, and my machine doesn't blink an eye. I can understand ST3 if you're a broke college student or freelancer just starting out but for rather minimal investment you can do your job so much more efficiently it's silly. If performance is an issue, it's likely an issue everywhere else too and you should upgrade your system.
I don't think the issue is your bluntness, as I am a very blunt person myself sometimes, but rather your condescending tone. I would hardly say that anyone who uses Sublime Text is automatically not a "real programmer". I am a "real programmer" and I definitely prefer Sublime Text. And so does half the company here, including our CTO. It's just simple, doesn't get in your way, and helps in all the ways I want; and if I wanted something even remotely in the IDE arena (like SQL beautifers), then I can install those extensions. All of them have worked wonderfully, with the only exception so far being XDebug. To use an analogy like yours, I would compare it to an auto-mechanic that just has tools for working on cars. He doesn't have all the tools to work on a plane or a train, but he doesn't need them since he doesn't use them. He works on cars, and has everything he needs to get his work done. I'm not arguing that Sublime Text 3 can do everything that PHPStorm can do, as that would be absurd; I'm simply saying that Sublime Text can do everything I need it to do in order to do my job as a "real programmer".
I'll do that. Thank you for recommending!
This. I'm practically starting to hate people who _brag_ how much they can customize Atom, sublime or whatever text editor they use. IDEs had Emmet support for years, and people think they are cool using them in Sublime. On the other hand, most of these people are those who don't need a terminal, version control, test suits for their work. 
Unless I have horribly misunderstood your question then you are just now getting into debugging. Have you been using var_dump() up until now? The first place I worked our CTO equivalent preferred Dreamweaver. And make no mistake there are things Dreamweaver does better than any other editor. These were part of his argument for it. He had convinced many in the shop to use it. But ultimately the real reason it was his preference was because it's what he was comfortable with, and he never committed to learning something more powerful. The whole argument that you can install extensions I find lacking. To do regular day to day work, which would include refactoring, debugging, VCS management and so on will require a load of extensions. And you will absolutely find code hints helpful if this is your job. To have all these features you will need an IDE, or so many extensions that your text editor has literally become an IDE. But even if you go the extension route it will be less stable and integrated/quick than the thing you're trying to build (a real IDE). Edit: a word.
"Real programmers" this guy is a douchebag
From the manual http://php.net/ceil : &gt; Returns value rounded up to the next highest integer. **The return value of ceil() is still of type float** as the value range of float is usually bigger than that of integer. I agree, it doesn't make a lot of sense and all of this could be avoided if [bigint](https://wiki.php.net/rfc/bigint) support hadn't been declined. But oh well, for now you'll have to cast `(int)ceil($replyCount / $perpage)`! 
Years ago I saw little reason to switch as well. People kept telling me varied tiny reasons why it was better. But I was comfortable with my editor. Finally I gave it a proper chance on a very large backend project, about 80 hours of work. I forced myself to keep an open mind and take the time to stop and learn, to try and find the right tool out of my new kit. By the end of that project I was sold that it was slightly better. After a year or two I was getting so much more efficient with my IDE the productivity difference became truly profound. I actually have interviewed/hired people who preferred Sublime Text. But, we usually viewed it as an indication of skill level/willingness to keep up with the industry. And while I have personally only helped hiring ~15 people to date that has proved one of the indicators that was pretty bang on. My intent was not to insult, and I am truly sad that I have. Personally I find bluntness motivating and so I posted a comment that would have helped motivate me. When I look back on when I used to prefer text editors, I view myself as having been in a rut, needing motivation to commit myself to an IDE and give it the chance it deserved. Obviously I relate that experience onto others, but maybe that's wrong? Maybe it does not apply to everyone?
Sounds good. I did setting similar with Notepad++, and Console2 with grunt, git, composer, etc managed to get running. I still use terminal fr git, but there is nothing much of an alternative to an IDE when you want to set breakpoints, realtime code sniffers, remote interpreters, etc. 
~~Yeah, casting just produces the result I want which I did but why I even need to do it is what confused me when even the docs says ceil(4.3) returns 5 which is an integer.~~ NEVER MIND. It's Laravel's dd() helper function that adds the floating part. PHP's var_dump returns float(5) and when you just echo it, it returns 5. My bad. 
Chrome is a big hog. Probably the plugins I am using (a bunch for stuff like headers, injecting scripts, screenshots, ad blocker, etc). The other thing is gaming (depending on the game) wouldn't use that much RAM. Below are my top 50 processes, and like I mentioned before I will sometimes have Tableau open which can eat up a lot of RAM. I think the WindowServer is because of Bartender + Dropbox + Little Snitch. I could also just use the gmail web interface, but I like Mail a lot more. Process | RAM ---|--- WindowServer | 1.08 GB kernel_task | 1,017.5 MB **Spotify Helper** | 615.2 MB **Photoshop** | 458.9 MB Google Chrome | 404.1 MB Finder | 377.7 MB Google Chrome Helper | 343.9 MB **Skype** | 340.7 MB Google Chrome Helper | 252.2 MB **Bootstrap Studio** | 210.4 MB **Dropbox** | 192.9 MB **Messages** | 185.6 MB Google Chrome Helper | 172.7 MB Google Chrome Helper | 164.3 MB **Microsoft Word** | 160.1 MB Google Chrome Helper | 147.6 MB Google Chrome Helper | 139.9 MB **Mail** | 139.1 MB **Mail Web Content** | 120.8 MB Google Chrome Helper | 110.7 MB Google Chrome Helper | 110.1 MB Google Chrome Helper | 108.6 MB **CrashPlanService** | 101.5 MB Google Chrome Helper | 100.9 MB Google Chrome Helper | 87.4 MB **Preview** | 84.7 MB **BBEdit** | 83.1 MB **Transmit** | 79.6 MB **Spotify** | 78.2 MB mds_stores | 69.2 MB Activity Monitor | 63.5 MB Google Chrome Helper | 61.9 MB Google Chrome Helper | 58.3 MB Dock | 56.7 MB **Quiver** | 56.6 MB Google Chrome Helper | 56.4 MB iconservicesagent | 54.9 MB **Bootstrap Studio Helper** | 54.3 MB Dashboard | 47.2 MB Calendar | 46.9 MB Google Chrome Helper | 46.5 MB **Bootstrap Studio** | 41.9 MB **Mail Web Content** | 39.7 MB **Dropbox Finder Integration** | 37.4 MB suggestd | 35.6 MB mds | 33.9 MB Google Chrome Helper | 33.7 MB Spotlight | 32.2 MB SystemUIServer | 31.6 MB **Terminal** | 29.3 MB EDIT: I could use more swap which would be fast, but that would just destroy the SSD. I am fine just keeping Tableau or my IDE open when I am using them, since when I use either it tends to be for a decent chunk of time. 
classic...Tony the Pony
I went other way around. I was using PHPStorm for 2 years (netbeans even longer) and I've switched to Vim. I like PHPStorm and Sublime but I love Vim. I dont need one tool to rule them all, I need best tool I can get for task I need to be done. I can work for hours without touching the mouse, I've been never so productive with any IDE.
I like this, don't really use any of these features in my every day applications anyways. Not like it would matter much to me to just remove 4 folders after cloning the repo.
I recently upgraded most of my projects to 5.2 - Does anyone know if the next LTS version coming up is already known?
[removed]
[removed]
[removed]
Thanks! I know it's a bit rough, but an idea I had to share. If you have any suggestions, please let me know :)
Then the concept of stack and queue doesn't make much sense
I though so to (the opposite of htmlspecialchars(). I think though the OP wanted to follow the json_decode pattern. 
I'm at about 40 routes in my latest project and it already looks so stupid
I agree with it being made hard to find the actual implementation of a resolved class, but exactly that's one of the powers of the framework. If I don't like the way it's made by default, I extend it and tell it to always use my version. With a decent IDE you should be able to find the service provider which resolves this class pretty quickly, though mostly I don't even need to.
Thats very possible; it might not apply to everyone. Like the guy who also responded to your post, I prefer to use the tool that I find the most effective rather than one tool that can do most of what I want. You make reference to a "very large backend project" that is 80 hours. Is that how most of your work goes? I'm making an assumption that you typically work on different projects, like in an agency setting with multiple clients? To me, an 80 hour project is simply a sprint cycle. We primarily have one codebase for our product, and while we are just starting to move to a microservice framework, very little is actually moved over. I have one codebase to learn/maintain, and a team of 70 to get support from (as well as provide support myself). I imagine that an IDE might be better if you have a lot of projects/products to work on? I've only worked in environments where we primarily support one product. I understand that your intent was not to insult, but I'm sure you can understand why I find it insulting when someone says that I am not a "real programmer" just because I prefer another tool. I'm not angry, primarily because I don't really care if someone I don't know doesn't think I'm competent at my job. I will admit that I have a different viewpoint now than I did five years ago in a lot of ways, and being candid, I actually preferred Dreamweaver back then. It's definitely a joke with people who know, but - for what I was doing - it was legitimately the tool that worked the best. I just had a bunch of servers running copies of the same code, and I was making code changes live in customer environments (we had one set of code we installed multiple times on a server so our customers had independent codebases). They didn't really use any VCS or testing environments, and I didn't have the authority to start doing any of that. After a few years I left for much better opportunities, and about a year after that, they closed their doors. While some tools I used are the same, there are a number that are wildly different, and I can't say whether I'll be using an IDE in another five years. I might download PHPStorm just to use for debugging and see if I can get used to it. I really prefer Sublime Text now, but I'm not opposed to using a tool that works better for me. For me, that just isn't PHPStorm; at least right now. Ultimately, I want to learn Vim. Vim to me is just fascinating if you really learn how to use it, and even more out of your way than Sublime Text. Hopefully one day I get time to learn it!
I know that both suck at profiling. WebGrind is much easier to use for that.
It's very possible that I may have converted to an IDE five years from now; five years ago I used a different set of tools than I do now. Ultimately I'm hoping to really learn how to navigate our codebase with Vim, but I don't know if that will ever happen. Looking for a great way to learn!
cool.
No official announcement yet. But as laravel depends on symfony components. It's likely that next LTS release will coincide with symfony's next LTS (v3.4) release in 2017.
Same thing, it's still an ordered map, performance is the same. Note that performance discussion refers to the array_push/pop/shift/unshift operations. If you set a k=&gt;v directly (like $foo['bar'] = 'baz') it's always O(1) (cause it's a push, and the indices aren't updated). 
Any particular reason why you made 5.5 the minimum requirement even though it's EOL'ed?
I use ST3 with the xdebug plugin. I can help you get it setup if you want. It sounds like you might have a bad config or the UI is just being weird. I've experienced some quirkiness that others have mentioned, but I am at a point now that if I do experience any quirks, i right away know what to do to 'fix it'. 
Faster, maybe. Use more memory, definitely. 
Having to pass default values most often means your param order is wrong.
Yep, but it's not the optimal technology. From what i've heared it started as a hobby project of a programmer and is still carrying technical debt to this day (if it even exists).
&gt; Having an interface independent of HTTP for controllers will be more important! How do you add CLI or MQ interfaces for this "controllers"? You will have some kind of front-controller which will convert requests from CLI/MQ to just some abstract request. And controller now became a model, and we still have some controllers with different views. There is an MVA - Model-View-Adapter pattern (or mediating controller MVC) - this is what we really use on backend. Instead of controller we can have chain of adapters between model and view (http, mq, cli, etc) &gt; perhaps because of an inference that there can be no other application-level components outside of MVC. From the UI point of view - all this application-level components are just implementation detail of model (or controllers, if we are talking about routers and template engines). So from controller point of view model is just an entry point for application, and this "model" can use whatever you want. You could use CQRS, or hexagonal architecture... this is just an implementation detail. &gt; Models should not know about their data-store Again, this is implementation detail of model. It can use repositories or just DAO to isolate persistence layer. This is basicly multilayer architecture and that's it. &gt; controllers and views should also not know about the data-store, transport About data store - yes, since this is model's implementation detail. But not about transport. This could be handled via your framework but this is just means that controller is already implemented by this framework. Also if we replace single controller to chain of adapters (middlewares, event listeners) the we will get a lot more possible ways to handle all this easier. Well... right now I thing that all this just doesn't matter. It's more important to understand concepts like coupling and cohesion. 
You know. most cars are made by someone who said "hey, I should make a self-propelled vehicle". The difference is, that some of them are doing it for decades now, others just started. You can start right now and learn everything you need. Or you can learn from those who already did and save a whole lot of time. I'm not saying it's bad to make a framework. I say it's bad to do it, because you do not want to learn someone elses. Once you know what the use-cases are and what the benefits and disadvantages of indiviudal frameworks are, you can try to make it better. Just trying to make the best framework without looking at the others first, will most definitely end in chaos. 
[removed]
Here is another example: $html = '&lt;div&gt;&lt;script&gt; alert("&lt;/div&gt;"); &lt;/script&gt;&lt;img src="a.jpg"&gt;&lt;/div&gt;'; var_dump(html_decode($html, 'div|img')); In this case I want to extract the image element but cannot do so. I've kept the example short but it's not hard to see how this could apply to live pages where javascript/jquery is used to manipulate the HTML. Why don't you rewrite your code without using regex?
great tool thank you. . but bro finally I decided to hire one API developer so i hired him
I'd urge you to just consider it a joke given he recently retweeted @philsturgeon. Don't take it seriously. Edit: And his own company has PHP on their Github. 
Thats what makes it even more terrible, also to disagree with it being a joke https://twitter.com/keranm/status/756775749189644288 
Saw Chris post this on Twitter and I'm excited to give it a try.
I was thinking leave it out of the constructor and use 'allocate' secondarily. 
The very reason the OP posted this thread here is a problem using ST + xDebug plugin isn't it?
I'm not arguing C isn't most efficient, but you **can** implement an efficient queue in PHP by utilizing an array as a circular buffer. 
Symfony without a doubt has completely changed the PHP landscape. I know it's kept me using PHP, and has really changed how my applications are built.
The only thing ive learned about development tools in this thread is that you sir, are one. 
Same here, never even used Symfony until starting an internship, I've just kinda fallen in love with it and use it for nearly all my hobby-built web applications.
I like to use the PR Shift opens to discuss issues. That way we have context.
In contrast to what that guy says: You are doing unbelievable work and make my job as well as my own projects soooooo much more fun and exciting. Thank you so incredibly much for all the incredible work you are doing!
[removed]
If you use regex there will always be a case that breaks it. The more you work on the regex the fewer edge cases there will be (and you may decide that it's reached an acceptable level) but to remove edge cases completely you would need to use something other than regex. I'd recommend using DOMDocument or some other HTML parser and then transform the data from that (assuming you want to maintain the same data format as you have now). 
I've started using it, that's it. Well, I've read some articles and I decided to try it. It was a pain for some time, I was using Vim where there was no time pressure and Sublime when I had to do something ASAP. What I can recommend is starting with NeoVim (better defaults, and works better in general) and map &lt;space&gt; as a map leader. Good luck.
It's really sad many PHP devs don't know about the SPL data structures. The fixed array one is nice as well.
I'd strongly recommend not doing this with PHP at that scale, despite some people saying otherwise. PHP is not designed for this. Just because you/some people can, does not mean you should. Go would really excel at this problem, even more so than Node.
&gt; You should never use user input on unserialize. Assuming that using an up-to-date PHP version is enough to protect unserialize in such scenarios is a bad idea. Avoid it or use less complex serialization methods like JSON. Reminds me of a post that mocked how [Php 7 "improves" security of unserialize function](https://www.reddit.com/r/PHP/comments/3j88v4/something_about_php_7_i_just_saw_in_rlolphp_why/) and people here defending it....
A friend wrote the article. But yea, you are right. He is German and used the German currency format. I will tell him to fix it :)
14k+ requests happened. Mirror: http://web.archive.org/web/20160723130827/https://www.evonide.com/how-we-broke-php-hacked-pornhub-and-earned-20000-dollar/
14k? How in the world? 21 upvotes
Dude has a tumblr, guess what language tumblr runs on...
From looking at the votes, doesn't seem many were defending it.
What are you talking about?
Yup, I've built whole CLI only applications using the Console component and a few other ones. Very well designed.
Sorry for delay. I had a vacation. 1. "really badly named in my opinion, it always lets me think I'm connecting to some server or something alike" - partly I agree with you. But in the real world "connect" relates not only to some web specific terminology. 2. "So to create an event and listen to it, you need at least 1 class, 2 methods and a static helper that connects both." - in your example you also used one class and two methods (on, off). What was your argument about? 3. "I can write an Event-class that has three methods, addListener(callable $handler), removeListener(callable $handler) and emit(array|EventArgs $args = null) and have the exact same functionality" - no, not the exact same functionality. In this case object will have only one type of event. The same functionality is possible only with trait that provides some on, off, emit methods as you said. 4. "Can you point me to any obvious advantages of the signal/slot-pattern I'm missing?" - I can show difference. Your example - modified observer pattern. All listeners are saved inside of subject object. That is the point. In my case subject and observer know nothing about each other. That is the difference between observer and signal&amp;slots in my point of view. Advantages? It just handy to use signals and slots.
Ok so you meant something other than "fragile". There's one plugin with a bad UI. There are plenty of things in PHPStorm that have a bad UI too. Someone else could surely make a better plugin for Sublime.
I would think so too, but nevertheless it is helpful to point it out `:-)`. 
Thanks! 
&gt;Are there any way to track the total number of websites are running PHP? Reliably? No. Any number you ever see is a statistic based on on some formula or another, hence variations in the numbers. Also a lot of people might define things differently to get different numbers. Things like excluding websites below a certain traffic rate, measuring 'the web' by requests rather than sites (which would make Facebook, Google and some others most of the web) or something else. Unless you have a pretty particular reason to want a particular statistics odds are good it's not really that useful to you. 
I comfortably ignore the negativity - on Reddit there is a great deal of spite, and my guess is a good proportion of DVs are motivated by it. Developers need to learn to respond gracefully to feedback - as the OP did very well. Caring about i18n shouldn't be a big deal - developers generally do! 
PSRs are not law. They point out common sense recommendations, they're neither perfect or guaranteed to be complete and exhaustive. But they are a great starting point. In my projects I allow inline if statements as long as the statement sits on a single line, which avoids bugs from accidental line duplication or adding statements to the body of an if that has no braces. 
Sometime using your mouse forces you to step back, and even if you don't realize it, it gives your brain a few seconds to process what you've just done; it may save your life not being productive, it helps you think instead of acting, and may avoid you lots of errors. I hate most peope that use this VIM-productivity argument because most of the time, they write so much code so fast that they don't realize when they make mistakes, or oftenly found themselves over-engenering. It's good to lost some time by taking your mouse and closing a window, it's the only way, on a computer, to give your brain a chance to think by itself about what you're doing without you even realizing. A good software engineer is not someone that write lots of code, it's someone that write less but more productive code than the others. Being productive in IT is not about you doing a lot, it's about your code doing a lot.
Chrome is the new internet explorer 6, but just worst. I don't use, never did, never will (except when I need to need testing).
Where are *your* numbers coming from, if you're the one asking for where to get them? [W3techs](https://w3techs.com/technologies/details/pl-php/all/all) is the most well known source of data on this. They check billions of websites so it's pretty reliable. But knowing raw figures isn't all that useful on its own, the trends in usage are more interesting.
Yet we failed to have a website that can be easily read from a phone.
I've enjoyed your videos, but it would be great if you could make the code a LOT bigger, as it's impossible to read on a small screen. Good stuff anyways. 
&gt; its certainly a mistake *it's (not possessive)
&gt; its bad practice *it's (not possessive) &gt; PHP was 'broke'. *broken
&gt; its not *it's (not possessive)
Don't you have better things to do with your time?
Only if you're doing it wrong.
Looking at the download stats, it looks like it's being used a lot: http://symfony.com/stats/downloads
User input in unserialize is always critical, even if you do not consider low level problems like this. It allows you to create [arbitrary objects](https://www.owasp.org/index.php/PHP_Object_Injection) and thus to inject malicious content in class attributes that would be already filtered otherwise. It is quite fun to exploit this, because in many cases you can chain together different objects and jump through the code base until you find a vulnerable method. Most languages have this problem btw. If you can unpickle malicious code in [Python](https://blog.nelhage.com/2011/03/exploiting-pickle/) you have command execution. [Java](https://www.youtube.com/watch?v=VviY3O-euVQ) apps also had some bad bugs recently because of unserialize.
If you want quality, you should not be looking in anything Php...
This information is extremely questionable, firstly they call the languages 'frameworks' the fact they don't know the difference between a language and a framework is worrying. 'The entire internet' says .net is 38% and PHP is 37% I would lick your ball sack if that is anyway near correct, there is simply no chance there aren't enough microsoft servers to justify these numbers
It's worth clarifying that OP appears to be talking about Magento 1, not Magento 2. Magento 2 is completely different to Magento 1. There is no upgrade path, the codebase is completely different and development is completely different. Magento 1 is quite dated these days. It was built ten years ago now, and it's held up quite well. Unfortunately, the community has had to step up quite a bit to help modernise Magento in ways that the owners of Magento should have done themselves. Projects like the [Magento Composer Installer](https://github.com/Cotya/magento-composer-installer) have been essential in making it easier to distribute extensions using Composer. For using non-Magento packages with Composer in a Magento installation, I'd highly recommend using the [Fontis Composer Autoloader](https://github.com/fontis/composer-autoloader) extension (disclaimer: I work for Fontis). On the original point made by OP: We find that yes, the average quality of Magento extensions (especially by some of the more well-known vendors) is quite poor. A lot of the time there is a complete lack of code style standards. Some of them utilise rather grubby practices, such as trying to charge Enterprise Edition customers extra for the exact same code, and implementing code to try and prevent people from running the so-called Community Edition version on Enterprise Edition. Sometimes, you come across a real gem, such as the [Aijko Widget Image Chooser](https://github.com/aijko/aijko-widgetimagechooser), but it's honestly quite rare. Be prepared to spend time implementing stuff you reckon you should already be able to get elsewhere, and also be prepared to spend a lot of time optimising Magento itself. It's a big beast that is difficult to scale. Good luck.
Also, if you're starting from scratch there's every reason to go wit the latest Magento 2 release, 2.1.0 as of this time. It's a much nicer codebase to work with for the reasons you mentioned (and many others). If you've got an existing Magento 1.x install, especially an even slightly complex one, I'd probably wait around for the time being. I'm going through a migration right now and despite what Magento sales people will tell you, there are lots of areas that are simply not ready yet.
&gt; plenty of quality PHP projects and code May be. But the my comment only implies that Php has a significantly higher percent of successful but shitty, widely used projects..
You seem mad. Illuminate/validation is part of a much larger piece of work, which has a lot of interdependent parts. You could try looking for something else. As for the overhead - exactly what overhead? Bit of memory? I'd hardly call it "enormous"
No your comment implied all not just a higher percentage. 
There are many validation libraries on Packagist including `respect/validation` which have few - if any - dependencies themselves. That said, your rant reads more as a knee jerk rather than a view backed by reason. Are you seeing measurable impact from these dependencies or you just believe them to be unnecessary? Code sharing allows the various packages to focus on their specific area rather than needing to solve problems outside of that scope. This makes it easier to create new packages and validate their correctness. Further, composer makes it easy to keep up to date with bug fixes automatically - a major benefit from copying code from the Internet somewhere.
Start contributing to open source projects. 
Honest Question: What did you do for a living past ten years? 
seeing a lot of threads pop up regarding magento suddenly. Im so confused, what happened?
Yeah, but the problem is order of magnitude (or even 2) larger in JS. For example creating even simple project in node requires about 500 dependencies! Whereas in PHP I have not seen any project with more than 30 dependencies overall.
I'd rather eat paint chips than use a class consisting of 100% static methods.
U said it bro! DAE &lt;3 Php.
I was a bike mechanic for five years before I became a full time developer. I did freelance projects on the side occasionally, like building websites for bike shops or people I met through work. I also wrote two simple apps for myself. When I interviewed for my first programming job I was able to put freelancing on my resume and explain all of the skills I had learned. I was also able to pull up an app I had written and show it to the interviewer. You just need something to prove you can actually write code.
Since you are ranting this much, I'm sure you can present data on how big the impact is?
If you are worried about dependencies, I probably wouldn't use Illuminate packages outside of Laravel :D You might like beberlei/assert, it's very straight forward with zero dependencies.
Any good developer would immediately look at said dependencies in order to determine how they work. If you create an app and have no idea how your own dependencies work then you should try breathing out of your nose.
Good thing I don't use laravel then. Any framework consisting of classes whose methods depend upon other class methods which aren't inherited is a sinking ship and I'm not about to board it.
[removed]
Its because devs use it for a while, hate it, and try to move on, and people are left needing devs for it.
It's definitely worth looking into a program called "modman", on my phone atm so can't link it easily, just Google it. It allows you to keep your module files all in one folder (good for git) and then tell it where you need each file/folder symlinking to.
I liked this answer: "Languages and tools aren't inherently insecure, bad code and security practices are. Since php has a low barrier to entry, people that don't understand network security and secure coding can create security issues with uninformed decisions. It's not the tool, it's the monkey using it ;-) Code written in any language can be insecure."
Your biggest issue with paid extensions is support. It will cost you more time than anything. Web projects like this get freelancers writing custom plugins for a customer need, then they think "hey i could sell this..." unaware of what supporting plugins means. This is why you see so many abandoned ones for Joomla and WP as well. You can try if you like, people need features. Just be fair warned: plugin support sucks, and its worse on ecommerce software.
I don't know how complicated validation can become, but when I read "simple validation (class) for a string or integer", I wouldn't even search for a package, but write my own simple class using [`ctype_*`](http://php.net/ctype) and/or `is_*` functions and type casting, if a distinct class is even necessary.
I liked these.. &gt;PHP is designed to appeal to the lowest denominator of programmers with the least motivation to get good at their craft. And thus the most likely to write insecure software. and &gt;The PHP team has a history of profoundly flawed attempts at fixing common security problems. Look for example at SQL injection protection, which betrays repeated flawed attempts at fixing the problem: real_escape_string (because the original escape_string was broken, but they didn't remove it until later) vs. addslashes vs. mysql_escape_string/pg_escape_string and so on. Whereas pretty much every other language just went with prepared statements and query parameters and got a design extensible to all databases right on the first try. And from the top voted answer.. &gt;Pretty much yes. Better advice might be along the lines of "don't drive an old car with no airbags" [Php] 
I can add nothing that the SO answers havebt already said That said, I built a fairly complex symfony3 app and got a team of pen testers to slam it for security issues. They found exactly two, and both were MY fault 1. I used a straight redirect in the address bar for the post-login form. It is just a redirect however as a place to go if the login was successful, and transfers no data anywhere. 2. I wanted to use some html in my h1 title tag (&lt;em&gt;), and instead of whitelisting the one tag, I just told Twig to |raw the variable. I eventually ditched the idea altogether but forgot to remove the raw filter. Then in a particular non-coffee day I made the mistake of feeding a GET value through the controller and into the twig template, into the h1 tag. This allowed the pen testing team to implant a Me Gusta image in my H1 tag. Why this is aweful considering the only thing that could happen is some innocent html injection that wont stick for anyone else but the user that did it, would be easy forgery, making it look like we published something bad and taking incriminating screenshots and spreadibg that around the interwebs. One of the advantages of using twig is by default it prevents this crap, but I told it to look the other way and I paid for it lol But that was it. I watch my error logs all day long on my deployed symfony apps and see people everywhere trying to do some interesting attacks both in URLs and POST payloads,none have been more successful than simply causing one of the more modest servers to run out of fpm threads for a moment. There is a reason I use HttpFoundation and Twig for all my projects, they've always had my back 
You can run into the same issue in any language. For example, while researching SAML handling for our Python app, I encountered a package that requires WebOb (which is a low level toolkit for web apps to communicate with wsgi servers), zope.interfaces (which is a horrible implementation of Java style interfaces in Python), paste (a wsgi server) and other stuff. On top of that, it's "pure python" with pure python dependencies like gcc, libxml, and libffi. And you dynamically link libxmlsec in your python code but that detail is buried deep in the docs as essentially a footnote. Keep in mind this was a package designed to create and read SAML tokens but includes everything to run a SAML identity provider as well. However, there are other packages that handle the creation and reading of SAML tokens, so only that, and require minimal dependencies. 
You can run a phishing scam quite easily if you can create a URL that inserts your HTML content into a page someone else is viewing. The viewer thinks that they're looking at a secure website that they trust - it even has the certificates and everything - but the content they're looking at was actually passed in via the URL that they were sent. That could include an iframe to the attacker's site, or even just a form that submitted data to another host. I don't necessarily know the context, so I don't know how likely your site would be hit with that sort of problem, but it's a valid flaw that someone could make use of if they were determined enough - but then that's why pen testers exist! :P
version 2 has made some progressive improvements towards a modern development platform. but honestly, there's not many viable alternatives on the market on the higher end of the ecommerce self hosted space. We're moving from a custom laravel cart to magento 2 and it has some pains, but it will be a positive in the long run.
The SO post says that the host uses cPanel. Well, cPanel has a low barrier to entry, too, and people who understand secure coding aren't going to be using cPanel lol
yup very true. That was indeed my interpreted reason as to what was awesome about it. Vut ya ediing the page is chrome tools is just as capable of this lol
that is an excellent point, thank you :)
Ive used Prestashop once and loved the heck out of it. One of the better self hosted solutions ive found, uness there are a bunch of glaring flaws I just havent seen or been made aware of yet Though ive never hated magento, my clients have. Always comaining that its just.. way way more than they want or need (though lets be real, theyre gonna want those features eventually, they just dont know it right up front) 
PHP, Python, Node. Way more python than node, way more php than python. 
I dunno about "most" but ive looked under the hood of hundreds of projects, and none of them used `filter_var()`, they mostly used user input raw :/
[removed]
"Interdependent parts". Also, what is more efficient - renting a pickup truck to move a couch, or a transport truck which requires additional trailers that will contain absolutely no tools which help you move your couch?
Yes I'm sure 95% of PHP developers have never looked at the source code of the packages they require. /s
Server.
&gt; The PHP team has a history of profoundly flawed attempts at fixing common security problems. Look for example at SQL injection protection, which betrays repeated flawed attempts at fixing the problem: real_escape_string (because the original escape_string was broken, but they didn't remove it until later) vs. addslashes vs. mysql_escape_string/pg_escape_string and so on. Whereas pretty much every other language just went with prepared statements and query parameters and got a design extensible to all databases right on the first try. This one annoys me the most because it's just so ignorant of where the mysql_* functions came from. mysql_escape_string and mysql_real_escape_string are just functions of the C API by MySQL themselves: https://dev.mysql.com/doc/refman/5.7/en/mysql-real-escape-string.html It's also not like you can't use prepared statements in mysqli/PDO either. I mean, it's not like _PDO has existed in PHP for the last 10 years_... oh wait...
I definitely need to, its the one thing i could immediately think of. I think I'm going to switch my repository to public just so I have something out there. I have tried freelance work, but Its so damn hard to get a contract on those sites because everyone is having a race to the bottom and I have profiles with next to zero experience. 
I'm pretty sure that 95% don't look through each single package and every version, yes. Or do you really think that more than a few developers have looked at all Symfony components they require?
&gt; "Interdependent parts" Where's that in SOLID? &gt; Also, what is more efficient - renting a pickup truck to move a couch, or a transport truck which requires additional trailers that will contain absolutely no tools which help you move your couch? Not everything that's bad is a car analogy.
I'll make sure I close the door. Wouldn't want people to see you guys jacking each other off.
Alright, I'll bite. I would really love to be able to pull this in as a composer package. Any plans?
Currently I am just using a few composer includes like firephp, phpUnit, and phpDoc. I will give those another look on github, thanks for the advice!
Be careful not to piss off the laravel hipsters. They will form a posse and then spam your inbox with wordy ad hominem attacks whenever you raise valid concerns about their shitty framework.
Youre right. The fact that your original reply got down voted shows how shitty this sub actually is. Dependencies should always be injected directly into the class which requires them. All of these services containers are nothing more than glorified singletons.
It basically comes up any time someone wants to justify picking *X language* over PHP (though you could reasonably pick apart any other language; they're all flawed in some way). Which to me reads as "*X* is pissing me off, but I want to feel good about it anyway". Nearly every language can stand on its own in certain contexts; arguments where you just shit all over the competition means you have nothing good to say about your own choice.
Gotta love a framework that changes its folder structure on a subversion to subversion basis. Because fuck upgrades and consistency.
Well, not only that, but the mysql extension was designed back before prepared statements were even a thing. Quoting http://ftp.nchu.edu.tw/MySQL/doc/refman/4.1/en/sql-syntax-prepared-statements.html, "*support for server-side prepared statements was added in MySQL 4.1*". phpBB 2.0 was a big PHP 4 app (PHP 4 being relevant since PHP 5 introduced PDO and mysqli) and guess what version of MySQL phpBB 2.0 required? MySQL 3.22: https://github.com/phpbb/phpbb/blob/2.0.x/phpBB/docs/INSTALL.html So if Java got prepared statements right from the get go then they either haven't had MySQL support for as long as PHP has had it or else they were emulating it. Well that or else the poster of that SO comment is misinformed lol
just go to phpclasses then, and copy paste some code from SO
Libraries are written so you don't have to understand how they work. They tell you how to interact with them in order to do a certain job and you don't worry about the specifics of how they do it. If I'm debugging or want to take an approach that's not compatible with how a certain library I'm using does things, then I'm trying to understand how that library works and how I can extend it. But otherwise, I don't need to know every single detail, that'd cost way too much time.
&gt; there are way too many fucking dependencies for everything As others have mentioned, this is more an issue with the package authors, than with Packagist. If you want packages without dependencies, you should look at [Aura](http://auraphp.com). Each library package is completely independent and fully decoupled, not just from a framework but from all other Aura packages. (I am the lead on the project.) Regarding validation specifically, [Aura.Filter](https://github.com/auraphp/Aura.Filter) might suit your needs.
Write one yourself maybe?
cpanel... security... "recommendations"...
I have no idea what cPanel is, and at this point in too afraid to ask. But seriously, I have never used it, what is it, what does it do, and should I be using it?
&gt; phpBB 2.0 was a big PHP 4 app As an aside, up until 2.0.13 (IIRC) phpBB ran fine under PHP3. When 2.0 was released, PHP4.1 had just been released, so it supported both 3.0 and 4.x &gt; Well that or else the poster of that SO comment is misinformed I'm not a betting person, but I know where I'd put my money. 
How is number one a security issue?
I have seen many freelancers, myself included not wanting to work in a traditional office environment anymore. Of course it doesn't fit everyone, but I for example, really like the freedom and flexibility freelancing gives me. Just do not get burnt out. Having open source projects, github stars, Stack Exchange rep, etc matters more in freelancing; Degrees matter less. If you would like to get more into freelancing, be more committed when applying for a project. Read the job post well, and write a cover letter that actually addresses the client in particular. Address the point, and only list relevant experiences. There are lots of freelancing tips out there, but applying for projects that genuinely interest you, and writing a cover letter to the point often gives me the job (with over a success rate of 90% for me). 
It's because Magento 2 came out and everybody asks for the new version to be installed, but nobody is experienced enough to work with the new code. I had several people asking specific for experts in Magento 2. I am working with Magento since version 1.3.1, but I have to learn a lot of new stuff with the new version.
i dont beleive the way im using it is intrinsicly insecure (the only person your going to inconvenience is yourself if you redirect to, say, bing lol) but I think the idea here is that either a Referral value could expose something of value if you redirect to your own script to process it, or theres a cha ce that some data (like in headers) could be accidentally exposed where its not supposed to 
&gt;It's probably the most popular control panel used in commercial web hosting. And as much as I don't like it, it gives people the ability to have a small personal/company website for little money. Sure, it asks for root permissions when installing and then proceeds to poo all over the system with it's scripts and whatnot... but it works, and it secures the server. Usually.
&gt; the only thing that could happen is some innocent html injection that wont stick for anyone else but the user that did it For all "the user that did it," and by extension, the pentesting company, knows, you might be caching the HTML output along with whatever you allow in the H1 tag. Whether you intend to or not. It's not a minor thing just because it's not supposed to affect other users.
Or sending a logged in user a link that includes js in a get variable. Not escaping html usually also means you can inject js in there. Once JS is in there you can do any action the user can do, like sending records to a remote server, deleting records, ... But your point still stands, with modern frameworks you have to go out of your way to make things not secure.
&gt; and it secures the server. Usually. Not really. All someone has to do is get one password and they can take over the entire box.
wondering that myself
This needs some major refactoring. Looks like I'll be forking it
&gt; "easy" Assuming you can even find what you're looking for in that 747 cockpit interface of theirs (been a while since I've used cPanel, but I remember it being a complete headache trying to find settings).
To be fair, many hosts that do offer SSH initially set you up with password &amp; root SSH access. If you fail to change it, it's the same problem. But at least if you know Linux, you can correct the issue easily. Much harder to do in the black box of juju that is cPanel.
If they're using includes for header/footer then I wouldn't trust them to write an email form. 
I would offer your services to family and friends for free. Once you've got a couple of websites out there in the wild, hopefully interviewers will see that you're able to meet client demands and this distinguishes you from a PHP hobbyist. The fact that your client happens to be your Dad's mate and lives down the road is irrelevant.
~~is that 20$ or 20,000$ written as 20.000?~~ Edit: nvm, I read the article
I would much prefer being a bike mechanic than being a programmer :-D
It's built on top of Go's baked-in HTTP/2 server implementation. It's not like the developer of Caddy had to hand-roll the entire web server.
Hey guys so I'm new to this sub. So this php vulnerability that was discovered in the recent news regarding the serialize function and pornhub.com. I'm curious how this is affecting your faith in your projects that utilize this function. Also what do you think if anything can be done to fix the problem?
Only when they're injected as a dependency and not constructed within the methods.
That point of view (tools are not bad, it is always the users fault) is and similar others (like the silly ones like "Haters gonna hate duh!") are brainwashed into the heads of people here (impressionable novices), so they keep on chanting them ad nauseam. It seems to work like any other belief system that is perpetuated by blind compliance, rather than by following reason. Ultimately, that all the more reason to consider this language as a bad joke. So I say, let it be.
XSS is harder nowadays, even if you have direct access to html(or even the script tag). &lt;html&gt; &lt;script&gt; &lt;?=$_GET['injectMe']?&gt; &lt;/script&gt; &lt;?=$_GET['orMe']?&gt; &lt;/html&gt; then requesting injectMe=alert(5);&amp;orMe=&lt;script&gt;alert(5);&lt;/script&gt; chrome/blink will plain disable it: http://i.imgbox.com/srEwFHDn.png internet explorer will do the same, and I think firefox does the same except for localhost. There was a way to bypass this but it required you to control 2 or more get variables and I think it doesn't even work anymore.
Forgive me. I thought your point was that having these dependencies added some sort of overhead? If you are using a fraction of them then what overhead exactly? And do you really care if a bunch of 3rd party code is just sitting there doing nothing? I mean it's not hurting you if it's not being executed.
We are talking about how nodejs dependency trees are so much bigger than PHP dependency trees. So I'm totally aware of that, even more so, it is my point.
Generally I always dislike automatic serialization in any project and I try to keep away from it. I had a look at all the packages which I use, and none use unserialization in my current projects, so I am good.
I like how there's always an obligatory link to "PHP, a fractal of bad design" every time PHP is mentioned on a generalist forum.
The only code your app should contain is logic that is actually used by your app. If you disagree then I'm afraid no amount of reasoning will convince you otherwise.
It feels like one command to add Letsencrypt as a cron job is easier than learning a whole now (unproven) Web server. I'm all for standard encryption on everything, and on new deployments I could consider it, but switching existing stuff out is definitely not going to happen. (especially because LE is already setup for all my sites) 
Then I'm sorry you exclude the use of packages everywhere, in every language. And no package or package management system is ever going to make you happy. It is inevitable that if you use someone else's code that some of it will not make sense for your project and will go unused. Sure you can limit the unused part by making appropriate package choices, which you didn't do in this case, but it is inevitable.
Made my day.
Then node would definitely be your best bet.
Just...what the fuck. So your principle is that no method should call a method from another class? How do you write software at all? Globals all the way? Go back to BASIC please. It seems you lack any experience in programming. Read up on Dependency Injection and learn a thing or two before you go rant against dependency managers that is working really well for the whole ecosystem, for years now. The alternative you propose is googling, copy-pasting code from random sites and pasting them inside your project. That sounds like a really good dependency management alternative. I wish you great luck updating all your dependencies. I can do that with `composer update`.
So you've never written an application that contained more than 10.000 lines of third party code. Good to know. What is this like, can you even use Apache or Linux at all? Since you'd need to check the whole code, any sane developer does that. If you didn't, you can't use it. Try breathing out of your nose. Look at how no one here is taking you seriously because you sound like a little child ranting about not understanding all the stuff that he's reading. It's not _our_ fault that _you_ are too dumb to get the really basic principle of Composer.
Then you should also write your own OS, since it's basically third-party code running your code. Do you trust that one? Did you ever write an enterprise-scale application in your life? In any way? Or just little contact forms and guestbooks? I assume the later.
It's had a bit of an update with someone finally sorting out the shite design. But it's still not great. It's very evident that it was designed by a developer. The UX is still terrible and things are still placed in illogical places, making them hard to find.
`var_dump(html_decode('&lt;a b="c &gt; d"&gt;&lt;i class="fa fa-fw"&gt;&lt;/i&gt;&lt;/a&gt;', 'a|i', 'b'));` Can't get the `b`-attribute of `a`. `var_dump(html_decode('&lt;input type="text"/&gt;&lt;select id=12&gt;&lt;/select&gt;', 'input|select', 'type|id'));` `var_dump(html_decode('&lt;input type="text"&gt;&lt;select id=12&gt;&lt;/select&gt;', 'input|select', 'type|id'));` Neither gives me `input` or the `type` attribute
Active record ORM with static calls that make dependency injection harder than it needs to be. Additionally, I can see the examples actively encourage mixing database logic, business logic and presentation logic together in the same class. Can't say I'm thrilled.
PHP does come with a few built-in footguns which are not part of other languages. So yeah - generally, this issue is with the programmer, but wherever possible, the language should be helping users to write secure code, not make it easier for them to screw up. Stuff I have personally been bitten by in security context: * implicit conversion of numeric looking strings to numbers * above convention being used for equality comparisons of strings. * `in_array()` using above convention by default * tendency to silently "fixing" invalid data and forcing the user to check for errors using the various `xxx_last_error` functions. * tendency to report errors in-band using a value that can also be produces by valid input (I'm looking at you, `json_decode()` * no high-level encryption library built-in * until very recently: No way to produce secure random numbers. And only very convoluted ways to securely hash a password (plus: Reporting errors in-band, tempting newbies into accidentally writing extremely weakly hashed passwords). * as a language that's mostly optimized for producing output to be interpreted by a web browser, doing no HTML escaping by default (even though the default `content-type` is `text/html`) and escaping being done by a very inconveniently named function. This motivates newbies to do the wrong thing by default. The list goes on and on. PHP's friendliness to newcomers has the advantage of, well, being friendly to newcomers, but it also encourages them to produce very bad code and it helps them getting away with that instead of being helpful and supporting them in getting better programmers or at least avoiding the glaring issues. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You could try an ad like this on Craigslist. Junior PHP programmer job wanted. I have a years experience programming with PHP and am looking for my first real developer job. Willing to work for minimum wage or free for 3 months to prove my ability. I am very keen to learn, very enthusiastic, will produce quality work and be loyal and give my best effort to any company that will give me a chance. Then wait for the calls. And follow through on the effort. If you have no access to Craigslist put this on whatever jobsite you can find, linkedin, local papers etc. Believe it or not, some software companies will take you on and train you up.... 
&gt; before performing a SELECT query, it saves rows whose pending changes could affect the result. So, in case I will need a JOIN, for which I will have to fall back to raw SQL, there could be an inconsistency?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Magento 2 is a very odd beast indeed. It combines components from ZF1, ZF2 and Symfony, and also includes a lot of other framework code of its own. Bizzarely, none of it appears to be easily usable outside of Magento.
To add to the concerns raised by others: define website? Most client facing 'sites' might use PHP, but the larger the stack, the more the non client facing parts will have a wide variety of languages. 
Well, hope I got it this time. To conclude, you better avoid mentioning of this feature. It doesn't improve performance in any way, which makes it essentially useless yet it distracts a reader from some other potentially important things. Besides, given you consider this feature as a "cool" one, it arises serious doubts for the other project's features. 
They mean avoid WordPress
Exactly.
I can't work out if this is genuine or a troll? Why are you using MysqlI and not PDO?
Because mysqli is similar to old mysql ext shit, and all the noobs having hard time with recent mysql ext removal are thinking mysqli would be an easy replacement. And yes, it's genuine.
Two questions. 1. Do you really think that learning a handful of API functions is *that* hard? 2. What is wrong with storing DB passwords as plain text? Do you store it in any different form?
If you add your db credentials in a plain text source file it is visible to other people which means you show other people how to access your database. 
Thank you for your effort. As you volunteered to intervene, I've got two questions for you too: 1. What do you mean under switching databases: switching a database backend for the current project with existing codebase, or starting a new project using a new database type? 2. How would you store your password then?
Not selecting Author in that instance is a nonzero performance gain. OP is correct. It's likely a trivial performance gain and should be handled by the caller, not the ORM, but they are not incorrect about the miniscule performance gain for not selecting the column. That gain will increase with number of rows and might even be meaningful when the number of rows approaches a number you would never request on one call, but could be meaningful over the wire at scale. Though, again, I doubt it.
Everyone keeps on going on about how this is an unproven piece of software. How do you think software becomes proven, people use it. Some one has to start. And considering it's built upon Golang's HTTP server, I think we can stop saying it's unproven, since that stuff already works at massive scale. I wouldn't be surprised if soon more HTTP requests are served by go lang's http server code than Apache's.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
2.The way I do it and I think it's pretty standard, you store your database credentials locally at your computer and on source control you just have a default file with the example. So locally you store your let's say is called database.php file and on source you store database_default.php. The database.php is NOT in source control and is an exact replica of database_default.php but with the credentials of your database instead of example credentials. 1. If you have two databases installed in your server, one is mysql the other is postgres and you want to swap between them in one project, if you are using PDO as an abstraction layer, all you need to do is replace a few lines of code (changing the connection type from mysql to postgres and vice versa and the database credentials if they use different) and you can swap between them in a few seconds without the need to change any of the actual functionality
Well, alternatives are never a bad thing. Thanks for clarifying your points :)
Double urgh... Shared hosting and Visual configuration tools... It's basically the same as using dreamweaver to build a website
It mostly depends on how complex your requirements are and how carefully they are controlled. If you're dealing with a very specific product / experience with moderate complexity implementing from scratch / a general framework can be a reasonable choice. If you're dealing with a typical non technical merchant that doesn't really know exactly what they want, then a prebuilt solution like Magento will probably save you a bunch of time when new feature requests magically appear (at the expense of complexity and code quality). 
I agree. The hardest part for me was the payment gateways, but these days i believe there are a lot of choices?
Yeah - things are still all over the place, but at least in the later/ist versions (11.52+ at least, I think) the new UI design has a search tool so you can just start typing "Email" or something and find email accounts and forwarders, etc. It's still not amazing, but it is an improvement!
Surely you are convinced that single quotes are *more performant* than double quotes as well ;-)
Just another example of a groundless assumption that is based not on a practical experience but purely on theoretical musings.
You will probably have to alter your workflow. Just try and keep an open mind about it. It was a bit rough for me in the beginning - trying to apply non-IDE workflows to an IDE. For example, you can't really just open a random PHP file. You deal in projects. You can set code standards. Integrates with Vagrant, Composer, NPM, Git/GitHub/BitBucket. It really is just the best dang tool.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Man, there are lots of carts out there that are not Magento. You can go with hosted solutions like Shopify. You could also go with something like WordPress + WooCommerce. Which is actually a really nice platform.
Is it really Object-Relational Mapping pattern implementation or just Object Mapper? Or maybe this is just Table Data Gateway implementation? 
I've checked your website but I don't understand yet what's the "Learn By Doing" problem exactly. Why is it a problem at all? Can you explain please?
What you mention aren't carts but entire ecommerce solutions. 
*1. Well i've done it, so we possibly talk about different things, but it is very easy to just switch between databases using PDO *2.The original comment you replied mentioned "storing your DB password in plaintext in a source file is not a good practice" so I i gave a better explanation on why doing so is not good practice.
I would counter that by saying 'unless you're experienced enough to not have to ask this question, gain some experience and write it yourself'. Im a strong believer in learn by doing and learn by making mistakes. No matter what the project is. But I also strongly agree with your 'dont reinvent the wheel' policy. But sometimes, in my experience, you have to reinvent the wheel to properly understand the wheel and next time be able to determine if you should make your own wheels or get the ones that are per built for you (and 'ready to roll' ;-) ). 
Well, a lot of times I encounter people who ask a question on IRC or SO where basically the only answer is RTFM or "this is too broad". Sometimes, certain people, especially when they're starting out learning programming, need just a little bit of hand-holding. It's hard to get them up and running in their own local dev environment right away and it takes too long trying to walk them through a coding problem asynchronously (*say by gist/codepad*), as there's a lot of back-and-forth. So, phplab.io, gives you a way to get people together, writing and running php code, with no real bar-to-entry. This way you can show someone how to do something in PHP pretty easily with as little friction as possible.
I'd want a wrapper around PokémonGo real API (not through skiplagged), so we can make our tools the way we want. Also i tested skiplagged map, didn't work, or i wasn't able to make it work. If anyone interested in building api from scratch, u can watch the pokemongodev sub-reddit, you have a lot of informations about how the client-server actually works
1. You've done what? An application where you have SQL queries run against different databases using PDO? What databases it supports? 2. Actually you've got very little choice. your database.php is apparently a PHP source file where the password is stored in a plaintext. And whatever vcs stuff is rather irrelevant here. 
Yes, indeed. The benefits of caching are a groundless assumption, in case there is no apparent reason for using a cache. Seeing your examples I am convinced that you are really obsessed with the idea of sparing a field or two from fetching. Does your ORM have any feature other than that?
Looks a bit like a bigger version of http://phpfiddle.org/ , or?
phpfiddle.org doesn't allow you to do real time concurrent editing, as far as I know. Besides, have you ever used their tools before? They're pretty broken last I checked. You can't even get it to run php code sanely. It breaks the output in all kinds of weird ways. Whatever they're doing on the backend they're doing it pretty wrong.
Ou, I use them every now and then. Feels outdated and this here seems to be the better tool. Just saying, that this tool here has a somewhat similar background without judging. :)
The same places as normal: job boards, recruiters, recommendations, local meetups. Probably you don't want to place too much focus on the technologies as a requirement.
&gt; 2) it's fricking Magento. What kind of reasoning is this? Magento is _the_ most feature-rich, capable ecommerce platform out there right now that you can get for free. You really should consider the needs of your employer before you decide to switch platforms simply because you don't like it.
I'm not sure what you mean by "this tool here has somewhat similar background", exactly. Could you elaborate a bit? From what I can tell phpfiddle is just another codepad. phplab.io was designed to be more of a community. Think of it like StackOverflow, except you get to have someone show you how, in real time, rather than tell you how. To me those are very different tools.
If you plan to sell hosting with the sites you develop it really makes sense to use cpanel. Saves a lot of effort having to support clients cause they can do most things on their own. 
[removed]
why not just use a 3rd party letsencrypt client to get ssl certs for nginx ? That's what I am doing with 3rd party client acme.sh https://github.com/Neilpang/acme.sh writing a addon wrapper called acmetool.sh for my LEMP stack Nginx HTTP/2 ssl integration https://community.centminmod.com/threads/welcome-to-acmetool-sh-new-letsencrypt-addon-for-centmin-mod-lemp-stacks.7476/. My wrapper acmetool.sh for my LEMP stack allows you to auto generate new nginx vhost sites/domains and auto setup letsencrypt ssl certificates for the domain + auto renewal and mobile/tablet device push notifications for ssl certificate expiry dates. And eventually Amazon S3 support to sync the letsencrypt ssl certs for server clusters. I've benchmarked caddy vs my lemp stack at https://community.centminmod.com/threads/caddy-http-2-server.5170/ and https://github.com/mholt/caddy/issues/390. LEMP stack wins by a mile back then. So before switching do you own comparison performance benchmarks for your site and web app requirements !
[removed]
Shouldn't be _too_ big of a switch, already using projects in sublime. It was more the interface/theme that threw me off, and I didn't have a lot of time to spend
It borrows a bit of both, and is heavily patterned after SQLAlchemy from Python - which is a great package that I highly recommend if you're ever developing in python. Personally, I'd say it's more Datamapper-like than anything else.
indeed I have just thought i'd add the mention for folks to 'consider' :)
[removed]
Interesting novelty account. I like criticism, especially when it's constructive, but your points are off-the-mark that a longer reply is not worth it. Also, might be taken more seriously if it wasn't a novelty throwaway account.
Letsencrypt is stupid easy.
i am writing shopping cart (from starch) because current shopping cms doesn't pass user needs. quite complex, actually because I need to getting cost expedition which is relaying on 3rd party service and different method of shipping. even tough already plugin, is not suitable and need to add new features. also, the cart has discount season which is different methods (6 methods) with different conditions and date/time. so yeah, basically (in my case) shopping cart are just: - add product to cart - how many? - ask shipping address - wait for payment - confirm payment - ship it and give awb to customer the hardest part was "additional &amp; cool functions" :)
Sure, do it on something that isn't important.. but creating something for the first time and using it in production (for a client) is just bad news in the best scenario unless you have a horseshoe up your ass. Learn by doing... just not on a clients site-unless it's just a new library or something. I'll never forget the clusterfuck of pennies/rounding and shipping/taxes. **cries**
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I actually built an app for scheduling, but it was plagued with one issue. The smaller restaurants didn't need a scheduling service, and the large companies build their own or go with large providers. I also tried to develop an inventory management app, but I had no way to interface with the actual products, so it was basically just a fancy spread sheet hosted online.
Yes and from the answers given to other questions on the thread its obvious the code isn't quite what it should be
Despite being downvoted to oblivion, this has been a great thread, and thank you to everyone who has kindly posted suggestions, you all are a great bunch! :P
I find stripe really easy to integrate with so it is usually my first pick, then Its Sagepay. 
didn't realize prestashop was rewriting partially in symfony. that makes it more interesting, but I would wait and see how it rolls out and holds up. 
I honestly don't see a reason to hire a PHP developer. If you just want to migrate the existing php code to your java ecosystem your java guys should be smart enough to port them. It is a long road for a php guy with no java background to get familar with it. Especially if you have the requirement that he integrates well with an complex application. Expect a lot of mentoring and coaching until he is productive (and the risk he wont be). Other than that refer to xiongs comment.
The approach I go with for traits is thus: * Define an interface * Implement it on classes * When interface methods (or supporting protected methods) are implemented on more than one class &amp; abstract/inheritance isn't available/appropriate, refactor methods (or supporting protected methods) to traits.
Just started to experiment with this as well. Seems like the logical conclusion in some cases, but still feels funny to work with.
Yes! It (likely) will be less vulnerable to "drive by" / "script kiddies" attacks, but possibly more vulnerable to a sustained attack. It's also probably good to get the code reviewed by someone else who knows the ins and outs of php before you go live with it.
The wrapper class doesn't solve it, as it will also need testing and you still have the class_exists method in there, so you will have to mock it for Unit testing, but for the rest I agree.
Right, but you have to modify all solutions to make them fit for use on different markets. Shopware is a lightweight and fast solution. In its latest version 5.2.1 it is very professional and it is much more fun than writing code for Magento. Magento seems not to be suitable for the German market without modules like German Market Ready. The US has different tax zones in the different states, but European shops do not need to know in wich state you are in, so there is no need for that question in the checkout. Im am from Germany and attended workshops in Shöppingen (by Shopware), but we are using Shopware for 22 European countries. We had to buy the language plugins for each country and we still to change the translations in the backend (snippets). - The only language plugin that I missed so far was Slovenian, but it is very similar to the Czech language. - But that process is the same with Magento. Even for the UK we had to change the default translations to fit the local needs. So if you are only selling in the US, Magento is great and you wont see Shopware as an option. But Shopware is clearly fit for the European market. 
What would make it less awkward? I can talk to the CakeDC folks and have them update their example to be a bit more clear.
Trait's to me are a bastardization of DI... a trait ideally should be a class you inject.
This. If a collection of methods are god enough to be a separate trait, that is good enough to be a separate helper class that you inject. 
Just read my comment a second time please, I can only assume you stopped after the first sentence.
A trait is a more efficient way to represent that re-use rather than more indirect cruft. The bytcode doesn't care. There's no reason to use a helper class over a trait other than tradition.
Situation from my actual project. Class from external library uses EventEmitter trait, which is not good enough in my opinion, and I want to use my own implementation. If emitter was injected via for example constructor, I'll have to only put it as a argument $smth = new SuperClass(new BetterEmitter); instead of default $smth = new SuperClass(); Making EventEmitter as an trait seems logical, but it limits programmer. And instead I've to make class inheriting from `SuperClass` which uses `BetterEmitter`. 
I think that there are really few examples of good trait usage, when they are in fact needed and makes project better. I'm currently using them for 2 purposes: `Accessors` trait which exposes getters and setters as properties (I REALLY don't like `$obj-&gt;setFoo('bar');` syntax) - it cannot be done as injected object. Second thing is `Logging` trait, which is not implementation of PSR-3, but exposes getter and setter (+ fallback logger) for use in class, which cannot be done as injected class either. Traits tend to make code less modular, and creating super classes with everything embedded - which by definition violates Single Responsibility Principle. They also limit Dependency Injection (don't confuse it with dependency injection containers). See my [other comment](https://www.reddit.com/r/PHP/comments/4ukqx7/code_smell_check_traits/d5qolbu) OffTopic: I even won't do it as a function (in most cases): array_map(explode(',', $string), 'trim');
Hmm... this wouldn't work for me. The app has a series of content entities, like Article or Media, and some of those entities have keywords as part of their data. I'm using traits in this case to store helper functions, like the one above. Keywords are not really a similar entity so it makes no sense for them to implement the same interface. That said, I think I'm going to refactor this anyway. I've been building everything out on the fly, and it looks like I'll have to do some more complex stuff with keywords, so it should probably be moved into the new code for that.
This is a very good point. It's a bit bullshitty to use traits as if they are objects in their own right. So far, I've only used a trait for a small number of shared functions so I don't have to copy-paste stuff between classes. As soon as something advances to the point where it can be considered its own class, then it's time to start refactoring. Which is what I'm doing now, because I've got to do some other stuff with keywords, and I might as well move this method while I'm at it.
The only places I try to use traits is when I write tests. It helps in solving some cross-cutting concerns without having to resolve to aspect oriented programming. The cross cutting concerns in tests are often assertions or fixtures generation, and using Di or aggregation usually leads up to too much boilerplate code. The other place is when reusing patterns such as the GoF composite pattern. Imo people often fail to evaluate when to use aggregation and fallback to using traits too quickly.
&gt; No one is complaining about Laravel making a new ORM :P Because Eloquent implements the Active Record pattern, not Data Mapper one. An alternative is Doctrine 1, but it's no longer maintained.
Nope, it's called a unidirectional relationship... e.g. http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/association-mapping.html It's actually much more preferable as it avoids making the hydration step too heavy, cf. http://ocramius.github.io/blog/doctrine-orm-optimization-hydration/.
Why is that not sensible? You're still coding against an interface. 
I was thinking you might have issues with function names if you really went nuts with mix 'n' matching interfaces and traits. Having never done that, I've no idea if it's a major problem or not. Just something I thought of.
I agree for anything not involving sensitive data. When sensitive data is involved, go with the proven technology 100% of the times. 
I totally agree. But even then, just for practise, it helps to build your own and afterwards replace it with proven tech for production. But thats of course very counter productive and no one has time to do things twice, just to learn something from it. 
Please put aside the emotion. I know the feeling when you post on reddit and then get some irrelevant feedback. But still. The bare basics is an ORM with a query builder. Nothing, as it was said in the other comment, to be thrilled by. So it should be not basics but details and features. And out of them you take a pride in one which makes a `SELECT id FROM table WHERE condition` instead of `SELECT id, some, fields WHERE condition query`. Which honestly can have only imaginary impact on performance, especially for a regular web-page, where you are selecting just tens of records. Speaking of optimizations, I'll be glad to see any with a real, measurable effect - based on a test, which vividly demonstrates the difference. Speaking of other features - I'll be glad to see any difference from the existing ORM. 
I used to be a dev who used w3schools, I now absolutely hate it (to the point of installing Chrome addons that block it from search results) and now I use PHP.net like a dictionary and Stackoverflow for problem solving. What IDE do you code in? The company I started working at uses some neat tools such as PHPCS or PHP Code Sniffer. You can set rules on how your code should be structured (e.g. making sure there is correct spacing, showing a warning symbol if you left a print_r). Check it out on github - https://github.com/squizlabs/PHP_CodeSniffer. I found my code has been far cleaner ever since using this.
Study the code from open source projects. (not Wordpress though) And branch out from PHP too. Even if you'll be using PHP, it's good to see how things are done in other environments. I'm not a great coder, but what I have learned has been from doing that. Specifically - Laravel via laracasts.com has some very nice ways to organize code.
Does it do HTTP/2 server push? Nginx doesn't...
If you have HTTPS set up already. Setting up HTTPS is a little more involved, even with something like certbot.
This is hilarious, from the linked [company site](http://ipixacademy.com/php-training.php) &gt; OUR PHP TRAINING PROGRAM INCLUDES: &gt; Sessions for overall personality development &gt; Leadership development activities &gt; Interpersonal relationship development skills training &gt; Communication across various employee levels within the organization &gt; Managing stress &gt; Team building activities and group dynamics &gt; Handling performance evaluation sessions &gt; Time management skills and multitasking
This reply is silly. You should use whatever tooling makes you the most efficient. I know programmers that will use vi to code circles around IDE using devs. PhpStorm doesn't make you a better programmer, it just puts all the tools in one spot. 
I recently started learning PHPStorm. 
I've started using Bolt which had made me realize how much I need to learn. 
I've been reading it, but I feel like I need to do something in addition to reading about doing something. Is there a hands on tutorial that teaches principles similar to PHP the right way? 
Wow! Ton of good stuff. 
I have to give a shout out to the [Stop Abusing Arrays article](http://nomad.so/2014/06/stop-abusing-arrays-in-php/) by Gary Willoughby. I've been running into a lot of code lately that uses arrays and all the isset() and type checking has been driving me absolutely bonkers.
To me, it was honestly wading through years of legacy shit code, and being determined to figure out a better solution than what was written there. My first resource will always be php.net, to make sure what im trying to do doesn't already exist as a core function (just look at all dem [array functions Ill bet you dont use](http://php.net/manual/en/ref.array.php) ). My second resource is simply packagist. What I mean by this, is I've seen actually hundreds of projects incorporating either md5 or some custom md5 based salt and pepper implementation. But not one of them ever used [`password_hash()`](http://php.net/manual/en/function.password-hash.php) to deal with storing and validating passwords using up-to-date libs to deal with them. I'm guilty of this. I've also seen so many terribly built bubble sorts, when good ol [`uasort()`](http://php.net/manual/en/function.uasort.php) would have solved the issue (or usort if index doesnt matter) and faster. Im guilty of this. The amount of software Ive seen that implement their own custom inefficient DB wrappers around mysql_, mysqli_, pg_, mssql_, etc etc using and targeting PHP5 and completely forget (or just didn't bother to know) that [PDO exists](http://php.net/manual/en/intro.pdo.php). I discovered Doctrine before I discovered PDO itself. Which is unfortunate because I can thing of quite a few areas where knowledge of PDO would have helped some other projects I was working on years ago. Its amazing how efficient, and terse, your code tends to look when you exploit PHP's built in stuff, so long as you don't mind the occasional inconsistency shenanigan. 
Read books like Code Complete 2.
What exactly do you mean by "bad habits"? Most answers in this thread are PHP specific. While technically correct, I don't believe that's the best way to approach this situation since most code quality problems are language agnostic. Have you read _Code Complete_ or _Clean Code_?
[removed]
Learn from solid resources, I have listed some online and offline ones below. Learn the PSR spec. Get your self a good IDE which will highlight a lot of the basic mistakes before the code makes it off your computer and a lot of IDE's will also auto-format to PSR coding standards. **PSR spec:** http://www.php-fig.org **Online resources Learning resources:** 1) Laracasts https://laracasts.com 2) PHP the right way http://www.phptherightway.com 3) PHP Pandas https://daylerees.com/php-pandas **Offline resources:** 1) Advanced PHP Programming - old book but some very important concepts covered 2) The Pragmatic Programmer - not a book about PHP but considered a programming bible in my eyes 3) PHP Objects, Patterns, and Practice - a great book that covers much more than just the core language 4) Head First Design Patterns - don't be fooled by its childish look this book covers design patterns in a very unique way and the information is actually really in depth **IDE's:** This is more of a personal preference, a lot of people use PHPStorm (I myself used to as well) but over the last 2 years I've been using NetBeans which I have found covers everything PHPStorm does (That I need in my day job) yet its free. 1) NetBeans 2) PHPStorm
Read Clean Code. 
I believe code checks only run on the changed files on commit, so the performance impact is small. However the complete unit test suite is executed so that could become cumbersome. 
There's no need to be an arrogant arse hole, you asked for feedback and I gave you some on the very limited information you have provided. Any code even worth considering written after 2014 should as a minimum, be PSR compliant, yours, as you have stated, is not. So my advice, use something that is standards compliant, well documented and well tested.
It's not a case of your library, its any library in the PHP eco-system needs to be PSR for it to have any relevance in a commercial environment, I couldn't even imagine using a library in modern day PHP that isn't autoloaded 
By and large, I feel the same way. PHP The Right Way seems like a clinical guide to writing poetry... if you know nothing of poetry, it helps; if you're a poet, you look to it and nod; but if you are a writer of prose, or a bad poetry, it doesn't necessarily help you write better poetry. Past PHPTRW, most of the guides I find are "BUILDING YOUR SUPER COOL SINGLE PAGE WEB APP IN BARENAVEL, NUDE, BEACT, WEBSLAPPIFY, FLACKER, MANGO, ..." (Not literally, but close.) Not only do I not want to use 500 components to build my product, I think it's a terrible idea and while the code for it generally looks pretty, I see 5000 files being added to my project that I don't understand and can't justify. TBH, I'm currently looking for an answer to this as well.
Not that I've seen. Most programming and Object-oriented best practice knowledge comes through writing your own code and building your own projects. There's no real "hands on" way to teach the higher level programming concepts and principles that doesn't just involve copy/paste or spoon fed examples.
seems strange to see code like this again after using frameworks for so long. I only skimmed over very quickly but why are you escaping things entering your database and not escaping the output instead? It doesn't really make sense and seems bakwards
naming things [is hard](https://github.com/mikecao/sparrow)
The frameworks definitely teach how to program better. I've taken so much of what I've learned from laravel and used it with Expressjs. It's really awesome!
I would highly recommend you watch some conference videos. A great starting place is _Unbreakable Domain Model_ by Matthias Verraes (https://youtu.be/ZJ63ltuwMaE). I keep a list of some recommended videos that I keep coming back to so shameless plug: https://gist.github.com/jeroenvdgulik/4075122c783b090597a34aa6fa0f642c _edit_ also actually going to conferences is a great way to learn
You just summed up "Javascript Fatigue" in one sentence.
Even in our own forums...
And it's a terrible PHP IDE compared to PHPStorm. Since, you know, it's an editor, not an IDE.
I've been using PHPStorm for several years now. Before that, I used Notepad++ for coding in PHP, and even thought it's not obviously at the level of PHPStorm, the xdebug plugin was decent enough as to do some serious debugging on it. I'd say the ST3 implementation might just sucks.
That's only true for so-called reflected XSS. Persistent XSS is as dangerous as ever. ie. let's say reddit let you post HTML. So you post `&lt;script&gt;alert(5);&lt;/script&gt;` and then it's saved to the DB. It's then pulled from the DB when you reload the page and bam, XSS!
&gt; Our deployment process has been improved because we have replaced slow git clone operations with fast Composer installs Wouldn't composer clone the repository anyway?
I'm not in a position to say as I've not used any 'admin panel' for many years. They all run the same basic commands anyway, nothing you can't do/learn your self. Digitalocean have extensive tutorials on how to just about anything you would like on a server way beyond anything you can do in cPanel. I wasn't saying cPanel was bad by the way, I was saying the host obviously have no clue what they are doing if they think they need cPanel to run PHP. PHP is a completely separate binary that runs completely stand alone and needs no control panel for it to run or be administrated. 
Late to the party but I'm going to share my bad use of Traits. Or at least I'm guessing. Without going into it too much - I use a weird OO style to make WordPress themes. Most of my work is custom functionality and I prefer to use page templates. No muss; no fuss. I will have a directory called ```Templates``` and one called ```Views```. Templates are defined as WP templates and Views have static methods to output markup. I pass the Template class into the View. So, I usually have a ```Page``` &amp; ```PageView``` Trait. They do stuff like get the post ID, or get the header, or whatever. Just common stuff you need when you're building out a page template but not directly related to the main content. 
not with dist preferred.
That's interesting. I do plugin development for WP and I've never thought of using traits with it. 
For future reference, it would have been nice if you'd have explained exactly why it is bad practice, rather than just bluntly replying "its bad practice". Come on guys, lets help each other out here! :)
In fairness, I use a very low number of methods in any trait, and they're limited to those: * That are used by more than one class * That aren't used by every class that inherits from the same parent * That only do one specific thing common to the classes that use it * That only operate on their inputs I still have to support a CI3 app where the lack of namespaces meant me copy-pasting one particular utility function across a number of different classes, and that has bitten me in the ass more than once. Using a trait for essentially the same thing seemed to be the best solution here, if only so that I didn't put non-relevant stuff into the parent class. If I didn't want to use static methods, what would be a good non-trait solution for making these methods available in the right classes without putting them into the parent or copy-pasting them? Is an injectable helper class the only other option?
I've been gathering a list of principles, articles, books, conference talks that answer this question: https://herbertograca.com/dev-theory-articles-listing/
Laracasts
Different languages.
Mollie is a payment gateway, so I hope they take security via a MITM composer hack somewhat seriously :)
Jesus, the article is written by complete amateurs, and they make a payment gateway? 2004 called, they want their dev practices back. 
I don't understand what namespaces have to do with this. If the autoloader doesn't support them, because it's old, then you can use the legacy approach with underscores. The topology of your code is not affected by the use of namespaces, but usage of traits vs. classes does, and this has practical implications about your software architecture. 
You would still need to come the repo initially.
Just wanted to say I can empathize. I learned PHP during the days of procedural programming, the old habits have been extremely hard for me to break.
I use traits in my Symfony projects so that I can reuse Doctrine boilerplate code for entity properties such as id, createdAt, modifiedAt, etc. trait IdTrait { /** * The primary key. * * @ORM\Id() * @ORM\Column(name="id", type="integer") * @ORM\GeneratedValue(strategy="AUTO") * @var integer */ protected $id; /** * Gets the ID. * * @return integer */ public function getId() { return $this-&gt;id; } /** * Sets the ID. * * @param integer $id * @return $this */ public function setId($id) { $this-&gt;id = $id; return $this; } }
Yeah but you only have to do that once per server...
Yup. It's all those people shouting how PHP and WordPress is just shit. When it's really not. You just don't see well constructed WP work very often. I've started using composer in my themes. At the very lease as an autoloader. I code to PSR-2 standards except when I absolutely can't. For example, you have to name some files a specific way for WP to work. But inside that I'll use standard OO structure.
The best way to do it is not look for a site or project guide to follow. Think of a project you want to do, break it into chunks and build a plan. Research as you progress though it and if you want to learn certain technologies make sure to mark them. If you make a big mistake dont tare your work to pieces, evaluate times and attribute a cost to it. Is a rebuild worth it? Otherwise continue forward and learn from it. One thing you need is to be able to manage yourself. A test given to some is to make an invoicing system for clients (monthly basis), plan it out - research the features clients would need and keep your code to an explainable standard. For example some business love BDD driven work so working with phpspec could be very valuable. 
I taught a junior how to use Laravel. He went from Physical Networking and basic HTML and his boss jumped him into Magento (nutcase) and I meet him on the IRC. But to get him a raise we worked together as he was getting less than if he just worked retail. 
Me too. I'm only in my miss 30s, but started writing PHP in 2003 I think. I feel so old! 
I would love to see it as well. I can't seem to figure out when it's appropriate to make a Request that restricts access or use a named middleware like "auth", instead.
Slim Middleware would be a good thing to cover. 
The huge man with a beard image outputted on the CLI after every run would seriously piss me off after a short space of time and it servers no practical purpose
True, but in the context they talk about composer install which is like gits equivalent of a clone. If they said composer update then that would be like git pull. Or at least that's how they tried to put it. I know that in general you should update locally and install in production, but not everyone has worked this out yet. A lot of people still install once and update on every machine.
Summing up two words in one sentence, not bad... ;-)
I'd cover [PSR-7](http://www.php-fig.org/psr/psr-7/), the HTTP message interface standard and why it's important that request middleware have a standard request that it can pass through the layers (reusability, framework agnostic to a degree etc)
What about this intro and summary "Middleware in PHP is something that can be explained in less than a couple of minutes however I have to talk abut something for 28 mins more. So I come up to telling you that it was bad naming and I'm the smartest guy in the room and tell you something about real solid OO principles and design patterns."? :) Please don't be an asshole to your students. You can describe the idea and show in details a few usages: authentication, authorization (to certain extent), CSRF security, rate limiting (bad performance but it's used for it), CORS, logging requests/responses
I'd suggest to try some tests. My experience with fixed arrays was that they were slightly faster on 5.5.9 and slower on hhvm. And you have compatibility issues as literally **all** other methods expect arrays as inputs. So if you do only for Zend, you really need that 0,001% performance gain, your array is `private` and never used outside of your class then, yes, it's a good choice.
Yes I think so. I know that by default it disables SSLv3: http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_protocols
One of the problems with w3schools is it's just like PHP.net but only has examples - no explanation or documentation. As for Stackoverflow - it depends on how you use it. If you just google "how to integrate facebook api" then you aren't learning anything. But if you've tried integrating facebook api and run into an error code and search that on stack, you'll find many others who have experienced the same and will explain the problem &amp; how to fix it. Stack should NEVER be used for copy pasting but for guidance. Every job I've worked at, the seniors have all used Stack and we all use google on a daily basis. Question for you - what programming sites other than php.net do you use? If you run into a bug that you just can't understand, how do you solve it without Stack? 
If you cover everything you listed here, that will take at least 30 minutes!
Interesting. How did those translate over to PHP, or have you moved on from PHP?
Very good article on Xdebug. I'll have to check out getting a subscription. 
I'll play around with it tonight and see if it correctly enforces the use of AEAD ciphersuites (AES-GCM or ChaCha20-Poly1305) by default.
Doing a payment gateway and using Composer, not even doing signature verification of packages, wow those guys are bad.
Well, let's be honest here - WP is pretty ugly. I can't knock it too much, seeing as it got me into web development way back in the day, but it's missing giant chunks of modern PHP. I'm still waiting for some bright volunteer to rewrite the core, but keeping backwards compatibility is probably too huge of a task at this point. And that's a shame because WP is just so damn useful for non-devs.
&gt; I wouldn't be surprised if soon more HTTP requests are served by go lang's http server code than Apache's. I would. Go is a nice language, but you're kidding yourself if you honestly think its HTTP implementation will surpass Apache anytime soon, since Apache's been around for 21 years now.
Yeah, and it sucks.
You can talk about how: * PSR-7 Request/Response are immutable. * Middlewares receive Request/Response * Middlewares *mutate the request/response by creating new instances w/ changes and passing those instances to the next middleware 
Make sure you are not creating a new connection each time you loop. I would check the mysql logs to see what is happening as it could be the mysql service that is crashing. Check the uptime of the mysql server to determine if the database itself is crashing. Also check the mysql process list.
Came to link this ^
Depending on the setting in the php.ini, the maximum run time for a script is only defaulted to 30 seconds. Is it possible that those large galleries are taking longer than that to fully download and as such are being killed by PHP itself?
Check if your max_allowed_packet MySQL variable is set high enough for the data you're sending it.
Looks like either data or memory limit or a timeout on the connection. Sometimes services like this will adjust limits based on current traffic so trying late at night or other parts of the day may be more successful. Maybe try smaller chunks or creating a new connection after so many minutes or seconds. 
C++ was the first language I learned, before PHP, hence the thought process for building data structures. 
I will be messaging you on [**2016-08-27 01:16:30 UTC**](http://www.wolframalpha.com/input/?i=2016-08-27 01:16:30 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/4u9oxg/82_of_websites_are_php/d5sco4l) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/4u9oxg/82_of_websites_are_php/d5sco4l]%0A%0ARemindMe! 1 month ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! d5scp6j) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
That's a good suggestion. Also check your connections while the script is running by issuing the following command on the machine running mysql: `netstat | grep :3306 | wc -l` - the output will be the number of connections. Then check the value of MySQL's max_connections. If you're exceeding that I'd say you need to take a look at the code that's creating the connection. If you're using PDO, instantiate it only once.
I guess if it's for someone new to programming, it's better to have something like PSR2 to guide them than nothing.
Yeah, this is a major no-no. I wouldn't put anything but a simple function into a trait. Your explanation here is probably the best one as to why traits should be limited.
look at net_read_timeout, net_write_timeout, max_allowed_packet, wait_timeout, and of course PHP's max_execution_time (like someone else mentioned). If none of that works, try adding 50 entries at a time, closing the mysql connection, then repeat until all 200 are finished (as a last resort)
A stranger with no sense of humor thinks some half-assed code I wrote sucks? Whatever shall I dooooooo! Seriously though, I didn't come down with a pronouncement from on high that THIS IS HOW YE SHALL USE TRAITS, PEONS, AND THOSE THAT DO NOT FOLLOW MY COMMANDMENT WILL BE CAST OUT etc etc. I just said hey, I'm reviewing my use of traits, here's an (admittedly crap) example, let's talk about this. So far the thread's been pretty good, and I'm glad to read about other dev's perspectives and learn a few things in the process. I made a joke replying to you because, well, you saying it could be a statically accessed utility method - or you saying it sucks - is about as useful here as me saying it could be a purple scented unicorn. There's no context, no explanation as to why that's better or more appropriate. I can't learn anything other than 'this guy has an opinion'. I'm pretty much left to guess at why you think that. I'm hoping that you don't just show up to tell other devs their shit stinks, more or less.
http://www.whitewashing.de/2013/04/12/traits_are_static_access.html
The best use of traits I've personally seen is a basic implementation of an `OuterIterator`: trait OuterIteratorTrait { abstract function getInnerIterator(): Iterator; function rewind(): void { $this-&gt;getInnerIterator()-&gt;rewind(); } function valid(): bool { return $this-&gt;getInnerIterator()-&gt;valid(); } function current() { return $this-&gt;getInnerIterator()-&gt;current; } function key() { return $this-&gt;getInnerIterator()-&gt;key(); } function next(): void { $this-&gt;getInnerIterator()-&gt;next(); } } It's really common to implement an iterator that can often just wrap some other kind of iterator and layer on top the custom behavior. Using this trait means you can use the trait, implement the `getInnerIterator` method and only have to write the custom logic. So why is this a good usage of traits? - It enables code re-use for a common interface. - By itself it's not useful, so it shouldn't be a concrete class... - ...and there's no need for this type to ever be a parameter or return type declaration\* so it doesn't need to be abstract either. - It has only non-static methods. It's a true trait. Hopefully this is insightful. --- \* There are two different interfaces built into the language you could choose from that would be better choices: `Iterator` and `OuterIterator`.
I am totally going to keep mocking you. Too lazy to repeat yourself, but not lazy enough to ignore the topic completely? Man, you are failing the lazy Olympics here. Definitely need extra coaching. Check out Garfield, he's a grandmaster. I read that article when it was linked elsewhere, probably by you, and I thought it was excellent and it really got me thinking. Hence starting this topic, as there's a lot of different opinions in this subreddit.
That saves me from suggesting you look at 'dmesg' and make sure it wasn't an OOM then... ;-)
Are there any good PSR7 implementations extending the interface? I'm particularly thinking of HttpFoundation's ```get``` and ```has``` convenience methods for request values. I started implementing middleware and it's been surprising how difficult PSR7 is to work with. There's been gallons of digital ink spilled over immutability but I wasn't prepared for things like ```ServerRequestInterface::getParsedBody()``` being able to return null, array, or an unspecified object. The only thing I've found so far is Symfony's [HTTP Message Bridge](http://symfony.com/blog/psr-7-support-in-symfony-is-here) which gets the job done but feels counterproductive.
Awesome! I am happy they help you. Subscribe for more dude. :-)
**This is not mine!** But it is really really cool, I found it a few months back and don't know how I lived without it! At its heart it replaces `print_r()` or `var_dump()` and makes it look good, it also shows params for objects and methods, and just a whole lot more! [Github link!](http://raveren.github.io/kint/)
very strange, I'm trying to cd through terminal ssh so it should be there right? 
Well traits are powerful tools but a good PHP developer should be careful with it. There is an article that suggests that sometimes traits are used as glorified static methods, thus it can lead to code smell: http://www.whitewashing.de/2013/04/12/traits_are_static_access.html
In most cases, trait+interface is the superior choice over an abstract class. Simply because of multiple inheritance, which abstract classes don't support (for a valid reason). The only point where you need abstract classes is where a trait requires the interface information (e.g. which other methods are available, which in turn could be fixed by using abstract trait functions) or when you have to do `if ($this instanceof MyInterface)` in any method of your trait to check if `$this` is _actually_ an instance of the required interface. Most of the time, interface+trait is the best solution. You are not bound to a base class (but could still extend one, if you like), you can implement multiple interfaces and use multiple traits and you can choose freely if you want that trait utility or define all interface methods by yourself.