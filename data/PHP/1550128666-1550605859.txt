I mainly know Magento from the hosting side and it is a nightmare
I'm sure "first hire engineer" was really happy about that Magento entry in their CV... 
SQL queries are an important niche since many editors will properly highlight the SQL in a heredoc or nowdoc and it allows you to define the queries separately from the logic that uses them
I mostly at least ``Alt+Ins`` it and leave it alone. Sometimes I provide a short description, but not always. I'd probably be using PHPDoc more if PHPDocumentor was up to date. Unfortunately, as it stands, it's basically unusable on projects using PHP 7.3+
The original version of the MySQL class in this framework was written using mysql_ functions more than 12 years ago. It was then upgraded to MySQLi and then again to PDO. Instead of using PDOStatements and binds I use an escape function with sprintf which basically does the same thing. My escape function does the exact same thing that MySQL does internally. I looked up the C code. It's also [unit tested](https://github.com/Divergence/framework/blob/master/tests/Divergence/IO/Database/MySQLTest.php#L98-L125). Little bobby tables :) My work's ORM (which is also custom) uses prepared statements and binds so I have experience with both. My main beef with PDOStatement is that when you dump it there's no way to see the values. It seriously needs a getFinalQuery() method that will tell you what the database will end up or has ended up running. I also have a custom profiler I made for testing query speed and it stores the PDOStatement objects till the end of the process. For long running cron jobs I've actually experienced it hitting the limit defined in MySQL's `max_prepared_stmt`. Basically if you do $x = PDO-&gt;Prepare() (2^14) - 1 times but your logger is saving all those PDOStatements instead of letting the garbage collector delete them you'll get one of these errors for your trouble: https://i.imgur.com/XoEoIRx.png Queries as strings allows my profiler to log and see the actual query that ran instead of just the PDOStatement with the binds obfuscated. Basically it needs to do this to store all of them, then sort them in the end by speed, and then display the slowest ones in order. tldr; Yes. But there's reasons why I like it the way it is.
There is absolutely no reason why using an orm and learning foreign key relationships are muatually exclusive. And honestly, if you are already able to write simple DQL, 3 hours are enough for theory *and* exercise regarding normalization and another 2 hours to play with constraints. It's not like this topic is overly complicated. Nor does it have to involve _any_ programming. Just fire your MySQL/MariaDB server and HeidiSQL.
&gt; 4 hours are enough for theory and exercise regarding normalization and another 2 hours to play with constraints. You are so far removed from what it's like to be a genuine beginner at this stuff that you have no clue just how much time it takes to really learn something as obtuse to the average person as the normal forms. hey /u/cyrusol can you try this out? give us about 6 hours worth of study time on constraints and the normal forms and lets see whether you can avoid any messy database problems 
I read your [post regarding your impression with Sylius](https://alanstorm.com/five-first-impressions-of-the-sylius-ecommerce-system/) and I've also been looking into Sylius - thank you for taking your time to continuesly contribute to the eCommerce community. I'd like to work with Sylius, and I've tried setting up a development environment and messed around with the system; I like it. 
It's pretty clear to me from OP's post that they are actively in the process of building their own ORM likely because they notice the familiar pattern of code duplication which is an inherent obvious problem when everything is written custom. So they are already doing things "without an ORM" except that all that code is now starting to resemble an ORM so now they are looking for a reference. Pretty much every custom framework I've ever seen ends up resembling a modern ORM or stays spaghetti code forever.
Unfortunately, I couldn't find it in the framework packages.
You might want to look at [Patterns of Enterprise Application Architecture](https://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420) by Martin Fowler. There are 3 full examples that you are looking for right now: * table gateway * active record style ORMs (like Eloquent) * data mapper style ORMs (like Doctrine) The examples are in Java but you probably won't have many difficulties understanding the code.
I've been waiting for this for 15 years.
This. I feel advicing him to learn a framework is a bad advice. Instead of learning PHP he has to learn what another developer has done. In Laravel's case there is many abstract names that dont make any sense. I am a fan of making programming obvious and clear for anyone taking over without looking over tons of documentation. Definetely good with some frameworks but it can be really bloated as well.
 it wasn't Joomla. 
&gt; Instead of using PDOStatements and binds I use an escape function with sprintf which basically does the same thing. Prepared statements also have the benefit that mysql doesn't have to parse the SQL every time when running the same query multiple times. I suppose this doesn't have much of an effect in most cases, though. IMO, it's still nicer because it abstracts it all away; you don't have to call `sprintf` and call the escape function for each of the variables. I also like named parameters better than order-based replacing. &gt; My main beef with PDOStatement is that when you dump it there's no way to see the values. It seriously needs a getFinalQuery() method that will tell you what the database will end up or has ended up running. Good point. Surely this would be pretty easy to implement in an ORM - provided with the array of params you can easily place them into the SQL string for debugging purposes. It'd be nice if PDO provided this. There is [PDOStatement::debugDumpParams](http://php.net/manual/en/pdostatement.debugdumpparams.php), but not exactly the same. &gt; Basically if you do $x = PDO-&gt;Prepare() (2^14) - 1 times but your logger is saving all those PDOStatements instead of letting the garbage collector delete them you'll get one of these errors for your trouble Interesting, but why would you need to call prepare that many times? And why is the logger saving references to the PDOStatements? Shouldn't it just be saving/logging a string?
For JSON why not use `json_encode`?
**Yes!** Many self-taught developers (myself included) started their first project with an urge to create everything from the ground up. I remember outright refusing to use frameworks or libraries, because I thought I would learn more by writing all that code myself. And it's honestly the worst mistake you can make as a new programmer. Because not only are you wasting time trying to solve problems that have already been solved (and doing a worse job at it)... But more importantly, you're robbing yourself of the chance to learn and understand good design. 98% of being an engineer is simply knowing a bunch of design patterns, and understanding which ones are best suited for the project at hand. OP, you don't know this yet, but having a single class to represent a table, and the database connection, and the validators, _is a terrible idea_. Those are separate things, and they [usually] belong in different places. And the reason why you're having trouble finding examples, and why you're getting the same kind of answer from all of us on this post is because _none of us would do it that way_ 🙂 OP, do yourself a favor: step back for a little bit, and get a new framework project working locally—just give it a shot. I started with Symfony, but these days I'd really suggest Laravel. Not only is it a really solid framework, but it's also got some [_really_ great intro/how-to videos](https://laracasts.com/series/laravel-from-scratch-2018). Once it's installed and you start poking around the code, you'll start to see how things are organized. And I think that if you can get through the first 8 videos, you'll be in a much better place regarding the questions you asked here.
I use them regularly. I don't quite understand why you link their usage only with php printing html text. Both heredoc and nowdoc are very useful and nice string formats. 
My current rules: * self-explanatory names, even if they look too long * type hints in PhpDoc only if code type hints are not enough * obligatory @throws * descriptions of @param and @returns/@return in new line so PhpStorm won't complain * disabled some PhpStorm inspections incompatible with my rules Examples: /** * Description of method without self explanatory name (only if not explained enough by @returns description). * * @param string[] $not_self_explanatory_name1 * Description of parameter without self explanatory name. * @param $not_self_explanatory_name2 * Description of parameter without self explanatory name. * * @returns * Result description. */ public function not_self_explanatory_method_name_with_non_ambiguous_return_type( array $not_self_explanatory_name1, ?string $not_self_explanatory_name2, int $self_explanatory_name3 ): string; /** * @return int[] * Result description (only if not not explained enough by the method name). */ public function self_explanatory_method_name_with_iterable_return_type(): array; /** * @return int|string|null * Int - Result description for int case. * String - Result description for string case. * Null - Result description for null case. */ public function self_explanatory_method_name_with_multiple_return_types(); /** * @throws NotSelfExplanatoryException Description of exception without self explanatory name. * @throws SelfExplanatoryException */ public function self_explanatory_method_name_with_no_return_value(int $self_explanatory_name): void;
&gt;I hope IDEs add support for syntax highlighting based on the identifier. PhpStorm already does that..?
This. Do not reinvent the wheel. Use a mature, well maintained tool for the job.
Once you're done with [PHP The Right Way](https://phptherightway.com/), head over to the [Laravel Docs](https://laravel.com/docs/5.7/installation) and make a start on setting up an environment. I then recommend checking out [Laravel From Scratch] (https://laracasts.com/series/laravel-from-scratch-2018) by Jeffrey Way. His tutorials are genuinely second-to-none. Once you've set that up, you'll no longer need to rely on disgusting things like Global Variables :P Laravel includes an ORM ([Eloquent](https://laravel.com/docs/5.7/eloquent)), which abstracts your application from the database, protecting you from all kinds of attacks. Not only that but you'll be able to separate views into components easily and include partials etc. Even as a newbie to PHP, Laravel might help you learn faster.
https://www.youtube.com/user/TechGuyWeb Best web related learning content I've ever seen. Tons of php, including beginner courses, laravel framework, api, etc...
&gt; Can someone post or link to a GOOD, FULL example of a class for a single db table/object? Don't model your database after how the data is presented. Model the database after the data, their relations and the performance requirements, normalize and denormalize as required. Identify all queries accessing the data and add appropriate indexes as required after profiling and analyzing how they're resolved. First then you add the PHP to do whatever. Once class, 700 classes, that doesn't really matter.
Yeah but I call mine &lt;&lt;&lt;WHATSUPDOC
Laracasts has some series that are not Framework related. PHP Practitioner, OOC Bootcamp, etc...
I saw this link, and read it but I'm not sure yet. I don't have the money to buy the licenses every year, for personal reasons, and my company will not pay it for me so I was wondering on using on EAP versions.
&gt; And it's honestly the worst mistake you can make as a new programmer. Because not only are you wasting time trying to solve problems that have already been solved (and doing a worse job at it)... I disagree. Whilst re-inventing the wheel needlessly is pointless, I have seen several juniors start off with frameworks. They take a lot longer to develop problem solving skills IMO, simply because the framework takes care of alot. I think every junior programmer should have some barebones PHP experience without the cotton wool wrapped round them. Please note, I am *not* advocating rewriting libaries from scratch just because you can.
You can't work for a company (commercially) and use the free licenses - even the EAP ones. If your company won't pay for it you'd legally be stuck with choosing a free IDE. As much hate as it gets but when it comes to free IDEs, then visual studio code is one of the stronger options... 
Oh, I see. Thanks for the explanation, I didn't know that.
You don't have to renew every year. With the renewal, you won't be able to get only newer versions, but once bought version is yours forever. I would say that buying once in 3-4 years is enough, in order to pick up the support for newer PHP versions. That aside, you can develop using EAP or evaluation versions. 
EAP has a 30 day evaluation (reset each version). If jetbrains dont release a new EAP for 30 days you version will not open and tell you to download the release version.
Oh cool! I didn't know about that, that makes it cheaper in a way. And with license can I have it installed on my personal laptop and company computer? Or I have to buy a license for each machine?
Anti-pattern is a pejorative word that says nothing really but to point to a paradigm that doesn't follow some arbitrary rule. I don't like Active Record but it has its place. 
&gt; Is your validation in that class or in the controller? Ok, it is a big thing. Validation. I created a library about validation: https://github.com/eftec/validationone because I found the next problem, validation is a thing but you should show the validation somewhere, usually in the View or Presentation layer (but not always). Let's say we have a form: Name: __________________ Address: _____________________ ## What we could validate?. We should validate if the name/address is missing, if the value is incorrect, if the name is duplicated, if the name or address is too long. Some validations could be made via javascript (but it could be cheated), so we should do a validation server-side too. ## And where we should show the information? A fast approach is to show a simple message. Name: __________________ Address: _____________________ **show error here** However, it is not so clear. What if only the name is wrong?. So, the right approach could be: Name: __________________ ** show name error here** Address: _____________________ ** show address error here** **show general errors here** ## tl/dr Validation must work together with a visual container (to show the information). 
VS Code is a great choice if you don't want to commit money on a IDE right away. You can get every feature of a premium IDE through plugins. Some things are even better then in PHPStorm (or IntellJ in generall)) (html shortcuts for example a way smoother) &amp;#x200B; I use it all the time when trying new languages.
You can win PHP elephants.
[removed]
I'm interested to know how an editor can generate the correct functional description from your source code?
Try adding a query parameter. E.g. /mycss.css?foo=bar
How is this PHP related?
It is inside of index.php
You can install it, but you can't use them both at the same time.
Have a look at deployer - works very well for deploying projects and isn't too hard to set up. [https://deployer.org/](https://deployer.org/) Also, as mentioned above, you should have a look at migrations for changes to your database schema.
If a codebase contains this method, but I have never used it I would like to know more than the parameter types. From the name a assume it splits a file. But: \- what are the names of the parts that are generated? \- what happens to the original file, is it kept, renamed, deleted? \- if the file is smaller than $batchSize is it split? \- which exceptions will the method throw in which situation? What happens then if a few parts were already saved to disk? For me, PHPDoc should explain this to me as a user, without me having to look at the implementing code.
Yeah, no problem. Thanks ;)
Just take care because they're sometimes buggy, and I think they have more bugs now than a couple of years ago. Last couple of EAP's were crashing at pretty important steps, and the last one I downloaded several days ago was crashing on "Find in path" - whatever you type it produces an error, and doesn't return any results. I just stick with stable releases...
does a restart of the server also dont load the new css?
It doesn't. 
maybe its the css itself? try making the bodies background red for example. Does it still not work? look at your network tab and check if the file is actually requested.
Not at the moment. There is only one plugin that supports SDL on the server side, but not on the client side. An issue is open on YouTrack for this: https://youtrack.jetbrains.com/issue/WEB-17773
that's like calling a brick mason when a toilet is clogged "because it's inside my four walls" :)
still doesn't work. The .css file .php is in the same folder.
what status code does the network tab in chrome/firefox give the .css? 200 would be ok 404 would be file not found and 304 would be cache
Its 200
My other classmates is experiencing the same as mine. 
ok well then maybe try a fresh installation of xamp or ask in r/webdev sry that i couldnt help you :/
Its ok at least you tried. Thanks for your generosity. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/webdev] [CSS ISSUE in XAMPP SERVER](https://www.reddit.com/r/webdev/comments/aqjbi0/css_issue_in_xampp_server/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Is the CSS valid? A missing } or { can break everything. Can always paste your css file into &lt;style&gt;&lt;/style&gt; and check if it works that way. Beyond that i've never used XAMPP so i'm not sure.
it work inside of style tag. 
Check out swoole.
Maybe post up your code and we can check if everything is alright from that side of things? 
frameworks dont speed things up they slow things down. that's a lot of extra code that has to be executed. cool library for sure but it doesnt do anything for your argument.
It's an extension, not a library. Documentation is on the official php.net site.
the two terms are not mutually exclusive.
Ok, c extension. Happy now? 
I was never unhappy.. php itself is written in c.. I'm not sure what point you're trying to make
That swoole speeds up your php server by only serving to the client whatever is necessary.
makes sense to me.. but we were talking about language speeds not server speeds.
You type hints the code and then generate the phpDoc block. IDE's are smart that way.
i am confident of my code and already checked it many times. I thinks there's a bug in local server. &amp;#x200B;
If your company doesn't pay for your license you can use your personal license at work.
basically they are the same, as 0 is also considered as false. so i guess naa... 
Use whichever expresses the programmer's intention best. This kind of micro-optimisation is best left to machines.
.. or since it's working for everyone else and is not a known problem, it's probably an issue with how you're loading the CSS. Add a small example replicating the issue, add screenshots or whatever. You can't effectively debug something if you approach it as "my code isn't the problem".
I would say there is a lot of value in building everything *once*, solving it the best way you can, then using better libraries and figuring out how they are doing it. I learned a ton from building my first router myself, even if it was godawful. Obviously, getting to the "then" part is very, very important.
IMI, its easy to read if count($var) &gt; 1. If the $array is not an array but an object that implements the countable interface and the return is not an integer. 
Im having the same problem xD If I link to css files on the web(tailwind, bootstrap..) it works But linking with local css files doesnt work. the style tag works just fine @import doesnt work either And i tried relative/absolute paths
&gt; If the $array is not an array but an object that implements the countable interface and the return is not an integer. If you have to work with code like that, you have much bigger problems.
It's a matter of style afaik. I used to always like to leave out the `&gt; 0` (in both PHP and JS), but my style guides require it so I do it. Unlike a lot of functions in PHP, there's no mixed boolean return (old style, e.g. returning `false` on `strpos`), or nullable returns (new style, e.g. `foo(): ?int`), so you know it's always an int. When it comes to style, I'd rather be consistent than analyze every single line to death. If it's an array, PHP evaluates an empty one as falsey already, so if you're certain an array (or a nullable array), then `if ($array) {` is going to be the same in most situations, but people like to be really explicit. I could ask your same question but about why `if (count($array)) {` is better than `if ($array) {` if I know it's an array.
it's PHP if ($array) is all you need
Functionally? They are the same. Practically? It depends on your code standards. Either personal code style or your organization’s. I personally prefer the longer version ( &gt; 0) as it is more explicit about the intentions the coder had at the time of writing.
If $array is not an array, and is an object, I'd expect a better variable name which is more consistent with the object. But you are technically correct.
It makes your static analyzer happy. https://phpstan.org/r/72840eac-f9be-4d83-881e-c82dd1589752
1) This is not a support subreddit. 2) This is not PHP related.
Indeed... if the answer to the question "How many objects you have in this list?" is something "Yes", it's more likely this code has implemented the "Redditable" rather than the "Countable" interface. 
You need a PHP interpretor 
I would personally go by intention. Use the &gt; 0 if the point of the if() is to eventually count the number of items. Use count($array), !empty($array), is_array($array) or just if($array) if the point is just to verify if it exists. I find it just "eases" the reader's mind into expecting to be counting things later on.
FYI `if (!empty($array)) {...}` is faster than either of your choices. https://stackoverflow.com/a/29635982
Cheap music - Check Video "narration" done by typing into a word doc - Check Worst practices being demonstrated - Check Looks like another great tutorial vid!
Yes, but a personal license costs money as well :D
Aside from preference, I can't see a technical reason to use one over the other. Our team prefers to go with the shorter form, because we feel the longer form is redundant.
To iterate further. As stated on the EAP page, you DO have a 30 day time limited license for the product. This 30 day license allows you to work commercially using the EAP. But that's only for 30 days, afterwards you DO NEED a license. Even if you can still use the EAP Software without a license - to work commercially, you'd then require a license.
Yep. Sometimes I think most of the commenters here are lost and think they're in /r/laravel . I made a huge mistake a decade ago when I shifted from being a low-level kernel dev to web dev, and focused on learning Rails and jQuery and purely by examples (so much convention from railscasts...). I should've drilled the basics of ruby and javascript until they were second-nature, and used the frameworks when they were appropriate. Not giving shade to Rails or jQuery either -- obviously hugely influential libs that made a big positive impact, but my code was so much worse than it should've been. I could probably write clearer, easier to maintain, better organized, faster... well everything better, code in ruby 1.8 and es3 today with no frameworks than I did using rails + $ back then.
&gt;If it's an array, PHP evaluates an empty one as falsey already, I've been bitten by this when implementing array-like classes with ArrayAccess and it's ilk. The object would always (bool) to true, regardless of the state of the internal container.
The problem is that this is not Command Pattern. Someone thought that "Command" is a good name for encapsulated parameters.
Nah. you don't only want to check if the array exists, but also if it has 1 or more items.
You don't only want to leave a comment on some PHP code but also have any idea what does it do. This code does not check if the array exists. This code does check if the array has 1 or more items.
Well, I've seen code like this: `if (count($array &gt; 0)) {`. That's obviously wrong, but tricky to notice. For that reason, I'd say `if (count($array)) {` is less "risky".
FYI, this link is wrong on so many levels.
Static analyzers will complain about this, so will PHP 7.2+.
Look like it is no that obvious for everyone, so could you elaborate on why it is wrong but tricky to notice?
Can you explain some of the levels please? I don't understand what is wrong about it - it seems like someone did some performance tests and found `empty()` to be faster than `count()`, so I shared it here.
You’d want isset in that case or even a null coalescing operator since it would throw a TypeError or at the very least a warning if $array didn’t exist.
Parentheses in the wrong place. The `&gt;` is on the array and not on the count of the array.
Yeah, I clarified that point about static analysis
I usually go for `if ($array !== [])`, doesn't have the function call overhead, and is more explicit than `if ($array)`
I use Querious [https://www.araelium.com/querious](https://www.araelium.com/querious)
Not all of them: https://getpsalm.org/r/d4ddbcc0cc
if you already know it's an array, I far prefer `if ($array) {...}`. I think `if (count($array) &gt; 0)` looks better to people who don't have much experience with PHP, and expect it to work like some other language X.
Yep, looks you are right. I think it proves that it's better to be explicit.
First of all this link just shouldn't exist. One shouldn't run performance tests out of the blue, without any reason. Least they should draw any conclusions from it. The difference, if any, is essentially insignificant, and cannot be measured in the wild. Such tests are wrong on so many levels on their own, testing a code that does literally nothing. As soon as the code will start doing something meaningful, the difference will disappear. So you can safely assume that there is none. But some people just cannot wrap their head around the concept of a scale, and that's ok. We are all different and being weak in something we could be strong in something else. So, if you cannot help to mind the 2 cents difference on a $10000 car purchase - well, there is another level for you: this test has been done long time ago, in a galaxy far far away using PHP version that doesn't exist. And with any recent version the result could be completely different. Making any assumptions you already made obsoleted. 
I mean, Psalm isn't complaining, so that counts as happy, right? But yeah, PHPStan's strict rules are a bit more opinionated than Psalm.
ah thanks! indeed
No! Let's try not to succumb to the Javascript-Temptation of "learning frameworks" 
1. FCO for builtins is much lower than for user-defined functions. 2. count(), strlen(), and several others are specifically optimized by the engine to not be function calls at all. 3. Don't micro-optimize, that's the runtime's job.
I generally use sizeof(), how does it compare to count()?
Those "benchmarks" are based on 5.4, which was released some ten years ago, the runtime has moved on. Today empty/count by themselves should be about even, as will the negation versus the compare. The ONLY question a script author should be asking is: Which will be easier to understand (and thus maintain) in five years. Every concern about micro-optimizations belongs to the runtime.
Thank you for explaining. Hearing "You are wrong" without giving any explanation is really disheartening. If I knew it was wrong and why, I wouldn't have posted it. &gt; One shouldn't run around doing performance tests out of the blue, without any reason. Isn't wanting to know which is more performant a good enough reason? With regards to scale, when you have a choice between two functions, why would you opt to choose the slower one, even if the difference is miniscule? With regards to version, that's a fair point. I would be interested to know if there is a difference on the latest versions of PHP. Again, thanks for helping my understand.
&gt; Isn't wanting to know which is more performant a good enough reason? I would say no. Like I said, the "more performant" is likely a fiction. And - worse yet, this fiction is eager to become the reality. You see, people in PHP world are already inclined towards the cargo cult code, writing a code mindlessly, just following some ritual. There is no need to adding another one. It's very easy to seed a superstition but it's almost impossible to get uproot it. There are a lot of people who still believe that they make their code to run faster if they use single quotes instead of double. 
Yep. It only really makes sense if you're getting a type-hinted arg, like `function foo( array $arr ) {`, which is such a specific case. What a lot of intermediate devs struggle with is understanding that fewer characters !== more clarity. What you're really saying is "are their entries in this collection", so doing that in a consistent way, instead of having different approaches depending on the type, makes the code much easier to read. That's not just helpful for newbies either -- it helps everyone skim the code faster. Trying to cram everything into a tiny space like `if ($array) {` makes as much sense as saying `!0` and `!1` instead of `true` and `false`, because you save 2-3 characters each time.
I prefer `&gt; 0` and explicit comparisons in every case. Relying on type casting in logic is a code smell to me.
By the way, another level is using empty() which is completely wrong here. One should never use empty() unless it is positively known that a variable could be undefined. Otherwise you are robbing yourself of a useful error message. So unless explicitly requested, empty() shouldn't be used to tell whether a variable contain a false-like value. A variable itself is as good for the purpose.
I will share this video [https://www.youtube.com/watch?v=9qA5kw8dcSU](https://www.youtube.com/watch?v=9qA5kw8dcSU) This guy is really a great teacher!
Isn't #2 only applicable when the function is imported or used as `\count()`?
FYI I just did a quick benchmark using PHPBench on 7.2 and the maximum difference was less than half a microsecond. In other words, completely irrelevant and not measurable at all.
You don't. This is the very point of the warning. If $array doesn't exist where it should, naturally it should be an error to tell a programmer that they are doing something wrong. 
 Although that might be 'implemented' with method overloading in C++, it could also be implemented through generics if that implementation is power enough. ``` type T = int|string|Bar; class Foo { public function get($name, T $default) : T; } ``` Or ``` class Foo { public function get($name, &lt;T = int|string|Bar&gt; $default) : T; } ```
The typical argument for an ORM is code portability across different databases. If I start on MySQL and want to move to MS SQL Server, for example, a good ORM will let me make the switch without changing your code. However, in practice, this is very rarely a feature that anyone would actually use. Changing databases are huge endeavors that involve a massive dump, massaging the queries (often by hand) to the new database's dialect, a period where you're sending data to two different databases at a time (which definitely does involve code changes), both before and after the official switch-over to make sure you're not losing any information, and finally completely de-coupling the legacy database safely (more code changes to rip out the queries to the old DB). So, if you're lucky enough for all of this to be straightforward (and I don't know anywhere where a decade old database being upgraded, much less switched out, is ever straightforward), then you're looking at 3 weeks worth of stressful work, and having an ORM might save one day. That's the benefit of an ORM that gets top billing on their ad copy: One day saved in an event that's so rare that any developer might do it once in their career. The cost of an ORM? (And yes, ORMs are free software) Well, most PHP developers will learn SQL, at least at a superficial level. They'll be able to do a few simple inserts, updates, and selects. Some who are lucky enough to have tons of data will learn the benefits of indexes the hard way. Most professional PHP developers will learn how to do joins and subqueries. If you know SQL, you'll approach an ORM as a tool to generate the SQL that you already know. If you don't know SQL, you'll treat the ORM -- and the whole database itself -- as a key/value store. If you have wide, shallow tables (i.e., tables with a few dozen columns like home\_addr\_street\_1, home\_addr\_street\_2, home\_addr\_street\_3, home\_addr\_city, ... work\_addr\_street\_1, etc), then fine. It'll work... and everyone who knows relational database design who has had real world experience with these types of tables are cringing in horror. An ORM can never produce better queries than the developer can create by hand. Now yes, if I were to use an ORM, I'll create better queries with it than a business school graduate who was introduced to MS Access in their freshman year can create... But SQL statements that I create will always outperform my use of the ORM, and if the strawman business school grad were to use the ORM, then their SQL statements will outperform the ORM's statements. (Or at least they'll perform the same. Think of foreach loops four levels deep to get a list of items ordered by a specific customer -- We know how to use joins and subqueries for that, but managers whose experience in databases is MS Access? Even with an ORM, they're still going to run queries in nested loops.) My suggestion is, keep *all* of your queries in one folder. Keep it right next to your data objects. Keep it all consistent. Don't grab abstractions to things that have been commonly used for 60+ years like SQL.
sizeof is an alias of [count()](http://php.net/manual/en/function.count.php)
Argh, some of these terms are so alike that I tend to misuse them. After reading more about this, I guess you are right and I have to change the title. Links: * [https://stackoverflow.com/a/30096227](https://stackoverflow.com/a/30096227) * [http://danielwhittaker.me/2015/05/25/is-a-cqrs-command-gof-command/](http://danielwhittaker.me/2015/05/25/is-a-cqrs-command-gof-command/)
Do you have a better name?
New title: [What is a command bus and why should you use it?](https://barryvanveen.nl/blog/49-what-is-a-command-bus-and-why-should-you-use-it)
So essentially here is the problem. I have a two step process for finalizing a payment (there are 2 third parties involved). The first part I need to put a hosted payment i-frame to collect payment. This will redirect (within the i-frame) to a known URL that I can parse. Upon successful payment I need to finalize the order in the other third party system. The problem is, the payment processor who has the hosted payment solution doesn't have a SOAP method to validate the transaction after the fact. So this leaves a gaping security hole where we someone could in theory figure out the 2nd part, and pass bad data since I cannot validate it. Any ideas on how to make sure this is secure? I've outlined a few designs but I all seem to have a security flaw.
So. One thing that is bad about using an email based system to discuss RFCs is that it is hard for people to see: * ideas that have been discussed before, that were generally popular ideas. * why those RFCs failed. I've started curating a list of popular but failed RFCs to make it easier for people who wish to work on similar ideas to know what happened to those previous RFCs and what hurdles would need to be overcome to make them actually happen. If there's any RFCs that have come up repeatedly, that failed for reasons other than being overwhelmingly unpopular, please let me know so I can add them.
First of all, this has nothing to do with PHP. I have worked with payment processing before, it was done by using a javascript library from the payment processor. I would hash any relevant transaction information (invoice, amount, etc) along with my key so that only my request would be valid and forgeries would be near impossible. My code never once touched the CC data, that went straight to the processor. To make it simple, it sounds as if you are trying to engineer your own solution, which will be flawed and result in a data breach. Work with your payment processor, they will be very happy to help you set this up in a secure manner.
Probably wouldn't be helpful for your current project, but PDO prepared statement parameter binding passes the variables by reference rather than by value. That is: $userId = 1; $sql = "SELECT * FROM users WHERE id = :userId"; $stmnt = $pdo-&gt;prepare($sql); $stmnt-&gt;bindParam('userId', $userId, PDO::PARAM_INT); $stmnt-&gt;execute(); $firstUser = $stmnt-&gt;fetch(PDO::FETCH_ASSOC); $userId = 2; $stmnt-&gt;execute(); $secondUser = $stmnt-&gt;fetch(PDO::FETCH_ASSOC); This way, you won't run into the limit defined in MySQL's `max_prepared_stmt`.
If your payment processor doesn’t have an api to validate the authorization, they’re completely incompetent and you need to change immediately. More likely you missed something in the documentation. Also, /r/PHPhelp 
He is a good teacher indeed! Note that (as /u/MorphineAdministered mentioned) my article is not about the Command Pattern but about the Command Bus. Those are different, although they are also very much alike :)
So, this isn't my payment processor. This is a clients, and it's a new integration. I cannot get them to change at this point. I agree that it is absolutely inane, but I need to proceed so I'm looking for ideas on how to best do it. Out of like 14 processor integrations, this is my first time running into this issue.
TIL. TY.
Since travis supports the ability to start your builds on windows (early access) it currently lacks the ability to do so for php. So I just used \`sh\` language to download a certain php version and composer and run my tests this way. Works pretty good. Currently used by [goaop/framework:2.x](https://github.com/goaop/framework).
I prefer *if (!empty($array))* to either... 
Using count($array) without knowing for a fact that $array is an actual array (or implements Countable) is no longer such a good idea. Starting in 7.1 (I think) a warning will be issued. Really messed up quite a bit of code. 
When you move to different languages, sometimes the expectation is explicit is better than implicit. I tried to do an `if len(slice) {}` in Golang and, as expected, numbers are truthy values. ....The longer variant may make working in multiple langs a bit easier
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Knowing more languages is generally helpful for opening doors. You won’t get rejected for a job simply because you know how to use another tool. Should PHP be your top priority? That’s harder to say. There’s a lot specific to your situation to answer that, mostly boiling down to what jobs you want and what’s available nearby. 
One thing I always wanted to see was a strict option for switch, like switch(strict $variable), to avoid not being able to see he difference between "" and 0 and false. Not sure if there is an RFC for that, though
In abstract sense? I don't think there should be any. I may call it "arguments" when describing architecture, but it doesn't represent abstract type (not to such extent\*), and there's no real benefit of using it as if it did. It's a good design to follow, just not an abstract one. If I had for example `Authentication` type, this parameter name could be `Credentials` \- and signature `Authentication::authenticate(Credentials)` would be as good as `AuthHandler::handle(AuthCommand)`. Abstraction is encapsulated within handler, but it requires concrete data structure. Client would still have to know what "command" + "handler" pair he's dealing with. Well, you could encapsulate that pair and have a real command object, but in http it would be unusual, to say the least (cretaing something that passes arguments and calling it right after that instead passing arguments by yourself while making a call). \*) There might be some narrow sense of abstraction as in http where we have PSR's `RequestInterface` and `RequestHandlerInterface`, but request as parameter cannot be anything else than this concrete data access/mutator methods - I cannot use it as any other command. &amp;#x200B;
Because I already have the payload as json strings.
I don't believe there is currently. I'm kind of tempted to propose it myself as allow 'select' to be similar to switch except: * strict comparison. * default break with explicit fall-through. 
This is the problem that I run into when using the design pattern names with other devs. I know that they've been standardized, but the names sometimes suck and aren't always descriptive, leading to me getting blank looks. But then again, the worst offenders are too general to seem to be able to take more descriptive names.
So I actually created a test for this. $conn = DB::getConnection(); dump($conn); $i=0; $statements =[]; try { while (true) { $i++; $statement = $conn-&gt;prepare('SELECT * FROM employees'); $statements[] = $statement; $statement-&gt;closeCursor(); if ($i%1000===0) { echo $i.PHP_EOL; } } } catch (Exception $e) { echo $i.PHP_EOL; dump($e); } Basically binds have nothing to do with it. It's literally how many of them are living in memory at any given time. If you unset() the variable it will free it up.
if $array will always truly be an array, then I don't think it really matters. if it could ever be a Countable object, then it would depend what that object's count() method can return. it might do something ghastly like return a -1 if it encounters an error, which is truthy. 
That is a cool idea. But maybe "declare(strict\_types=1);" does it already? I haven't tried it, I always use a switch statement as if it is being strict .
It's a lot of work to learn it, and get certified for it. Even after 10 years experience with M1, and about 1.5 years of M2, I still had to study about 40 hours for the certification.
So I guess asking in this subreddit describes your subconscious choice already, as you are aware how PHP developers will answer. So I guess what you really want to hear is why you should learn PHP. And there is a lot to be said about that, but here is the gist of it: PHP, especially in the full stack world, is very common and despite the fact that its haters are predicting its end for years, the industry heavily relies on it. PHP7 and Laravel brought new blood into the PHP world, so it can be said with certainty that this fact won't change for the coming years. With your goal of freelancing, Python will probably land you a couple of gigs in Django, but the possibilities are rare compared to WordPress or Magento gigs you can quickly cash in on. For more sophisticated projects, PHP will also be found more commonly than Python. If you are truly undecided, I would either consider NodeJS or PHP as a next step. Ultimately, you should learn both in the long run.
The way this ORM works in particular all SELECTs are cached so it would never run the same query twice. The instantiated objects are kept in memory and changes appear in memory before the update query. We never pull twice for the same thing if we can help it. The long running script where I encountered this was something that calculated for all users and had to pull plan details, and a bunch of other user specific stuff so it literally took hours and had thousands of queries. With the profiler running the PDOStatements would accumulate in an array (and balloon the memory usage to gigabytes in ram). I actually never really solved this. The profiler thinks that single selects are the same across an object since the ID in the text is just the bind placeholder. Basically scaling issues. At first your daily script takes 10 minutes. Then you get 20x customers and now it takes 3 hours.
I'd agree. I tend to use isset() or empty() first for those cases.
Wel, that would be an all or nothing switch. Plus, iirc, strict checking is more CPU intensive and not always needed. With this idea, you could have only those few cases where its required do strict chucking
Mmmm, I always do fallthroguh with a // FALLTHROGUH commentary to be very clear that its supposed to fall through.. I'm not sure if I'd be a fan of explicit fall through in code
I'd like to see theese: * consistent\_callables * generics * method\_overloading * standardise\_core\_library * union\_types
[removed]
I prefer the if (count($var) &gt; 0) because I rarely name array variables $array. It helps me understand the code and ensure the value exists and is populated.
I'm looking for help to have a website that was built with 5.2 migrated to 7.2. The person who originally built the website has passed away. 
Err, yes. Of course. You're creating statements until you reach the limit. I said you can get away with creating only 1 statement: $conn = DB::getConnection(); dump($conn); $id = 0; $statement = $conn-&gt;prepare('SELECT * FROM employees WHERE id = :id'); $statement-&gt;bindParam('id', $id, PDO::PARAM_INT); try { while (true) { $id++; $statement-&gt;execute(); $row = $statement-&gt;fetch(PDO::FETCH_ASSOC); if ($id % 1000 === 0) { echo $id . PHP_EOL; } } } catch (Exception $e) { echo $id . PHP_EOL; dump($e); } &amp;#x200B;
 It's a horrible idea. Don't do it. Then you don't have to worry about 75% of the internet hiring you. 
Depending on the size of the project, this can be a more or less painful process. Did you simply try to run it on a local 7.2 installation? The last release of a 5.2 version was 9 years ago. There will be some things you'll need to adjust. But if you are super lucky, you will exchange mysql with mysqli functions and it simply runs. Then you modernize from there.
Unless that person removes a few files and then it restarts in EAP mod again for 30 days. You can do it but its so much a drag as its "never the right time" for that counter to hit zero, that you simple end up buying a licence anyway. And Jetbrain knows how to milk the customers plenty because EAP or demo mods tend to get released after that expiration time. You can be lucky but its like playing dice. Its was even worse how they do the licence program in the past, with releases conveniently right outside your licence period.
Yeah, peoples dies sometimes. We have all one feet in our grave already, in some way. By experience, you might find issues if [magic quotes](http://php.net/manual/en/security.magicquotes.php) were in use, otherwise the adaptation should be pretty straightforward. Just read carrefully the logs. Later, when works, this possible to optimmize a little, or write shorter code; good est example is: *array()* can be declared with **\[\]**, and to push values $myvar\[\] = ..... But that does not matter much, old codes works, it's made like so.
To add to /u/colshrapnel 's answer, once bought, you have a year of free upgrades, however it's only the latest version *when you bought the license* that you get to keep forever. For example, if you bought it today, you would get 2018.3.4. As you go, it will give you the option to automatically upgrade (which one should). At the end of the license term, though, you have to go back to their site and re-download the 2018.3.4 version.
You sure? Intuition tells me strict checking would be faster because you would skip having to do type fuzzing.
Just follow this: [http://php.net/manual/en/migration70.php](http://php.net/manual/en/migration70.php) 
...and other fun stories I like to tell my co-workers during breaks.
Most big corporations (that I’ve seen) use ASP.NET but really it’s all about the experience. MVC and RESTful APIs are the king. Learn those in any language and you’ll be on the right track no matter which language you choose. PHP is *very* cheap to learn and use
I'd say it depends entirely on your skill level and what kind of products or companies you want to work with. In 2019 you pretty much need to be able to write good JavaScript - I'd venture nearly every dev here has some degree of skill with JS. If you're looking to build entire sites on your own, it's nowhere near as feasible to do nothing but 100% server-rendered content now. Eg I do all my presentation layer in react.js , and my PHP is there to process restful/graphql requests, run some SQL or call some other backend/3rd party API, perform some business logic, then send some JSON back. If you want to work with a team and get hired doing web dev, php is great. If you want to support clients that are already PHP (which is a lot of them), then yes focus on PHP. If you want to freelance and build new webapps from scratch, you're going to need to at least learn JS. Might be easier to focus purely on JS and do backends in node. 
Thanks for replying Very helpfull
Did the M1 experience help at all with the M2 certifications? 40 hours doesn't sound too bad though!
That would be awesome, although I think the latter is handled _reasonably_ well with static analysis tools (but native support is even better). If enums ever materialize, I think that such a thing should also require either handling the exhaustive list of values or have a default case (whereas the existing switch would let you handle only a subset of enum values).
seems to work for go - https://github.com/golang/go/wiki/Switch#fall-through
My problem is with quickform..
According to [this article](https://commandz.io/post/php/2018-04-21-check-php-version-compatibility/) you should go with [https://github.com/Alexia/php7mar](https://github.com/Alexia/php7mar).
It is amazing how this book is still so relevant.
5.2 to 5.3 might be hard. But 5.3 to 7.4 (even) is piece of 🍰 https://getrector.org 
The biggest problem I had was migrating from Posix to perl compatible regular expressions. There is no way I could find to automate this completely. By comparison moving from mysql to mysql was a breeze and could pretty much all be done with scripts.
if you daily work is programming php and your company refuses to pay for such a licence than you should quit. its a bit like forcing a bus driver to use a bike for his daily job.
Hi guys, I recently finished all my exams and had an interview for a job as a PHP backend developer. They gave me a task which includes a login and registration system. I was searching online but its kinda hard to find an updated version with pure PHP 7.2 + (no frameworks are allowed and OOP should be used). I was wondering if someone could help me. Any good sites with tutorials, videos etc. Don't get me wrong here. I need to learn and understand what I made. It should not be too complicated. Requirements: * OOP PHP 7.2 + * "Remember me" - Cookies * MySQL * Password Hashing This should be everything. I appreciate any suggestion/help!
"The person who originally built the website has passed away." I am not a lawyer, accountant, or anything like that. But please take note: GET SOME LIFE INSURANCE. You never know when you will pass away -- will your family have enough money to get them through those difficult times without you? 10x your yearly income in term life insurance is a good thing to start thinking about.
Isn't that just a copy of the type hints? That's not the documentation that explains what those parameters mean.
I agree. Anyone else with me?
Hi guys, I recently finished all my exams and had an interview for a job as a PHP backend developer. They gave me a task which includes a login and registration system. I was searching online but it's kinda hard to find an updated version with pure PHP 7.2 or higher (no frameworks are allowed and OOP should be used). I was wondering if someone could help me. Any good sites with tutorials, videos etc. Don't get me wrong here. I need to learn and understand what I made. It should not be too complicated. Requirements: \- OOP PHP 7.2 or higher \- "Remember me" - Cookies \- MySQL \- Password Hashing This should be everything. I appreciate any suggestion/help!
It's pretty consistent, they have a continuous stream of eap releases until the production release is made available. At that point they take a 2 month break and eap restarts. 
The problem lies in the fact I have no experience in PHP coding.
Euh, it is your job interview, not ours! I really think you should be able to do this on your own. At least, if I were hiring you.
The problem lies in the fact I have no experience in PHP coding.
The problem lies in the fact I have no experience in PHP coding.
duuuuuude, thats like 5-6 functions at most. are you sure you are ready for job market?
I understand your point. It's not like I have found nothing. I just want useful resources and good practices. You always can get good sites and people to follow! Sorry if you felt confused. I'm not begging for someone to make this for me. I just want to learn! :)
Trying to be! 
Yeah, I am also sorry, I believe if somebody here helps You it is going to be the opposite of help to You. I hope You can do the task yourself. One small tip though - first make this task without thinking about the version of PHP required and after You've finished just add some of the new features / remove deprecated ones. That's how I always do the tasks and it really helps if You focus on getting shit done first. 
Thanks for the advice! Makes sense. 
Yeah, that might cause issues too :) First, is it a linux server?
Then I don't see you successfully migrating a coffee base between those versions without hiring a knowledgeable developer that has been around for over 10 years.
I don’t say this to be dismissive; it’s the honest truth of how I’d figure out something I don’t know how to do: I’d hop on DuckDuckGo and start reading. If you’re finishing a college degree (of any kind) then you should be fairly competent at discerning between low and high quality sources of information. Find good sources, read a bunch, identify common suggestions, then: Get something working do { // make improvements } while (time_remaining_before_interview); 
I did 5.4 to 7.1 last year, and there was quite a bit of work. Coming from 5.2, you are definitely going to have a bit of a challenge. I can help steer you in the right direction if you don’t mind waiting a few hours for my answer. 
The former express a clearer intent. Intent is important for the reader of the code.
But what examens die you finish? I asume something thats has to do with programming. What you are asking is basic skills of a developer. First make a plan, what needs to be done. What functions do you need. Think of what your end product should look like. Al that you need is basic PHP, all functionaliteit is in standaard functions. You don’t need any framework are resources for that.
Thanks! I think I understand what all of you wanted to say. Let's get started then! I hope I come back with a complicated question so you guys can't find a solution :D Thanks again.
I can’t help it. One quick piece of advice: if you see something using some version of sha for password hashing - leave that website. 
My college professor was SHIT. But even with that I figured out my own registration and login etc without help. Seriously. Think it out in baby steps man. If you can do it procedural, write it that way so you have your idea down and convert it to oop
Start with getting things into version control. Attempt improving code quality with with phpcs and/or phpcbf. If your project is mostly vanilla PHP without some older frameworks/components that relied heavily on particular behaviour of older PHP versions, you might be pleasantly surprised that not much will need to be heavily modified.
bcrypt is the way :D 
Thanks! OOP is a little confusing right now. The procedural version is already finished. 
Really? It copes with posix to PCRE migration? If so I wish I'd come across it sooner ...
In that case my strong suspicion is that your cheapest, and best, option will be to get someone to start over rather than trying to migrate.
Your developer died and you have no experience. You'll want to start looking for local developers to do this project, or remote if that's your thing. I'd try and do a better job of explaining the project than "Migrate 5.2 to 7.2". Is it a website? Do you log in? Is it based on a common framework? By the way, be careful passing the code around. There's a possibility that the code itself will leak implementation details—passwords, accounts, vulnerabilities, etc.—you'd rather not want in the open. 
You probably want the PHPhelp sub. However, don't (re)post this question as it is - it is not answerable. Mostly, Reddit programming subs are lightly moderated, if at all. Thus, you are permitted to ask anything you like, even if it is not answerable. This is not actually a great situation, because you would be better off knowing that your question is not answerable. To remedy this, read [this advice](https://stackoverflow.com/help/how-to-ask) - although it pertains to another site, it is very good general advice. General takeaways - use good titles, make an effort before posting, and describe the problem in detail.
Well I suppose but.. The thing is, in PHP I always use // FALLTHROUGH comment in places where it needs to fall through. This is so that when others here read it (or myself a year later) they can see that I intended it to fall through. If PHP would really add a "fallthrough;", I'd actually welcome that, but not when they'd remove "break;" as in reality, you just substitute one possible bug for another. 
I'm not, hence the "IIRC". I remember reading it a long time ago that === is slower than == as it does == plus a type check. I extended that to switch() in this case, which I figured was reasonable. Maybe it's not. Either way, sometimes loose checking might be preferable, sometimes strict. Since PHP is loose typed, I think the default should be loose checking and with an added "strict" do strict checking..
Of these, I look forward to generics the most, but fully understand why it hasn't been tackled yet. It's a doozy. I'd also love to see enums and brief closures, which are both complete no-brainers for the language, and the only thing seemingly standing in the way is for internals to stop bikeshedding every time they come up. I hope PHP never sees method overloading or annotations. The rest is sort of whatever.
So, which framework would you recommend for an e-commerce agency in 2019?
I meant to say backslash. I always get the two confused.
People have to do it of they access global functions from inside a namespace (php namespaces would be the terms to look for) so it's not a design decision but a needed thing. 
If you're not inside a namespace it's pointless. If you're in a namespace it makes the reference unambiguous (to a human I mean) as to being to a global function and not a function in the same namespace, and it can in certain cases make the code slightly faster for a few builtin functions that PHP can optimise if it can be certain (because of the `\`) that you're using and not a namespaced function.
I've never had to do this while inside a namespace. Under what conditions is that necessary? Userland functions?
Yes just user land functions no system stuff.
"The problem lies in the fact I have no experience in PHP coding." - you pasted the same answer to 3 posts here. What are you actually asking us to do? If you have no experience in PHP coding, if I can assume that, then you won't be able to do it. Your options are to either spend few years learning PHP or pay someone to do it for you. Simple. 
Just for reference, === is faster for the reason /u/MaxGhost says. == still needs a type check because it has to check if the two sides can be coerced to the same type, then if required it has to actually perform that coercion before it can check for equality. 
/u/EldoranDev is wrong: https://3v4l.org/ca9Dk
https://www.reddit.com/r/PHP/comments/8r9siq/strict_switch_statement_a_proposal_by_sarah/
I really want to see asyncs in PHP, I know with the PHP procedural workflow this would be a little difficult to implement, but they should implement something like this: `async function myFunc(): void{` `mysqli_query_thing("select * from bigtable); //takes like 20 seconds` `echo "Hello"; //or produces error and errors are on to be displayed or something` `}` &amp;#x200B; `if(true) await myFunc(); //this runs but its output won't be displayed, instead it will be stored in a file you specify in PHP.ini or in a derective` &amp;#x200B; `echo "template.html"; //This gets printed and output buffer is sent to the browser` &amp;#x200B; This would completely finish NodeJS at least in the web thing
There are two advantages in this: 1. your statically referenced symbols don't need to be looked up anymore. Tools like static analysis ones will know that the referenced symbol is the global one, without having to look for alternatives. 2. it becomes impossible to mock out the function (I consider this an advantage - seen people misuse this sort of mocking too many times) 3. it has some marginal performance improvement (although irrelevant if you aren't writing library code) To avoid turning this into a merge-conflict-and-giant-diff-soup, consider importing the functions you use, instead of prefixing calls with `\`: &lt;?php declare(strict_types=1); namespace My\Scope; use Some\Import; use function str_replace; // ... lotsa code ... $a = str_replace($b, $c, $d); // ... lotsa code ... I'm (as usual) pitching for https://github.com/doctrine/coding-standard, which does this automatically for you.
Some good reading: [https://laravel.com/docs/5.7/authentication](https://laravel.com/docs/5.7/authentication#introduction)
Lol, good luck
Thanks a lot! 
In a nutshell: You don't and it will be easy to start from scratch. You could salvage the database and something else but nothing more. I explain: * The chances that this application is spaghetti is high. * The chances that this application is buggy and filled with patches (a Frankenstein) is high too. * And, the chances that this application lacks resources (money) is high too. A well-funded application (internal funded) is well maintained but this application is here collecting dust. 
I like to set all my `use function`s at the top. That way, it's clear where everything in this file comes from. It also gives a nice summary at a glance of what's in the file.
I highly use PHPDoc and I also use deep-assoc-completion (it's a free plugin for PHPStorm) https://github.com/klesun/deep-assoc-completion It adds autocomplete to an array but also allows enumeration. ```php /** * Create an user * @param string $name name of the user * @param int $age age of the user * @return array|null an array if the user is right of null if the operation fails. */ function createUser($name,$age) { return []; } ``` In any case, an additional documentation inside the code doesn't hurt. It is not only about type-hinting but also about explanation. 
* Around the same performance than PHP 7.x with OpCache. * Not compatible with PHP or Composer. * Not compatible with Windows. * A small userbase. I don't see it with a future. 
This is mostly my guess, but considering the performance difference is probably negligible it doesn't really matter. Checking if a file is writable doesn't write to the file. It just checks permissions. So there's only an io read there. To optimize, don't open the file until the first write is needed. Keep it open until the last write has finished (or the script dies) and then close. You could also buffer the entire log in memory and do 1 quick write at the end (not recommended for logging tho). Or the least optimal way is opening before each write, writing and closing immediately. Now try all 3 of these methods in a loop that does it 10.000 times and see how much difference in execution time there is. 
Ah there you go, I forgot writing about that before. However, I don't think an rfc was made for that.
Never too old to learn, nice surprise.. I'll start using === more then
You should hire someone then.
No.
If they would let me on the list, I would throw these up and see how they go over: [https://github.com/ellisgl/PHP-RFC-Stuct-Data-Type](https://github.com/ellisgl/PHP-RFC-Stuct-Data-Type) [https://github.com/ellisgl/PHP-RFC-Static-Class-Type](https://github.com/ellisgl/PHP-RFC-Static-Class-Type) [https://github.com/ellisgl/PHP-RFC-Advanced-Type-Hint-Validors](https://github.com/ellisgl/PHP-RFC-Advanced-Type-Hint-Validors)
I see. In that case, I would hire someone. With such an old codebase, chances are high that there are security vulnerabilities a professional should take care of. I would recommend someone local in this case.
The performance of comparison operators really shouldn't be a factor in deciding whether or not to use them. The execution time difference under real world conditions is negligible in pretty much all circumstances. Prefer `===` because it is explicit, not because of a imperceptible speed difference.
You’re incrementing $i before you’re using it 
1) It’s probably not a good idea to nest a while loop inside another while loop. 2) I’m not sure how much data you’re looking at, but you could also store the data in a temporary array and then use the array_diff function to return any unique values in the second array. 3) You can accomplish a similar result using the following SQL and store the result in a single array eliminating the need to have two nested loops: &gt; select Email from mailmerg where Email not in (select Email from cleaning)
Not used bootstrap but that last sentence doesn't sound right at all. Your JS should be in the &lt;head&gt;&lt;/head&gt; tags of your HTML. Always remember the point of PHP is to make HTML (Sometimes other frontend languages too but that's not the point) If something like the JS isn't working do yourself a favour load the page then go to "View Page Source". It'll show you where the issue is usually. 
Js also goes at the end of body since the html is loaded at that point. For scripts that access the Dom, this is useful.
I mean I've always thought standard procedure was just to do document.ready( function (){... Or window.onload() I've never seen any website just stick it at the end. 
 if ($stmt = $mysqli-&gt;prepare($sql)){ $types = ""; foreach ($value_matches[1] as $c) { if (preg_match("!^[0-9\.]+!",$c)) { $types .= "d"; } else { $types .= "s"; } } $stmt-&gt;bind_param($types, ...$value_matches[1]); } I have the above code for use with a mysqli prepare stament. I'm classifying values in \`$value\_matches\[\]\` as either a decimal (d) or a string (s). &amp;#x200B; Unfortunately, my current regex code (!\^\[0-9\\.\]+!) classifies dates such as \`2018-10-22\` as decimals (that gets turned into simply \`2018\` in the \`bind\_param\`) instead of a string. How could I modify the regex in my if statement so that it classified dates as type strings (s) instead of decimals (d)?
You've used the \`\^\` beginning of string but not a \`$\` end of string &amp;#x200B; Try \`!\^\[0-9\\.\]+$!\`
I have been around this for 7 years and i could do this!
Wonderful, thank you so much
Many websites stick it at the end to allow the browser to render the html instead of waiting on loading the JavaScript.
Be mindful that your regex will match `1.2.3.4` or even `...` since you're not caring about where the decimal is. `/^[0-9]+(?:\.[0-9]+)?$/` may suit you better
select c.Email as cleanEmail, m.Email as mailmergeEmail from cleaning c left join mailmerg m using (Email);
That's why you should include your script in the head and use `defer`. It is fetched immediately, and executed once the HTML parsing is done.
https://github.com/php-casbin/php-casbin#our-adopters
I was curious, so I tried a couple of things. looks like you could just use `is_numeric` instead of regular expressions. $values = [4, 'abc', '2018-02-14']; foreach ($values as $value) { $type = is_numeric($value) ? 'd' : 's'; var_dump($type); } Result: $ php test.php string(1) "d" string(1) "s" string(1) "s"
Hey, thanks for your answer. As i said i wasn't really concerned with optimization and right now i am going for the approach you described first, wait until first write. As you said the writable checks probably perform an io read so there must be some kind of filehandle created anyway, which is then probably buffered by php and reused? That was kind of my question, is it necessary to concern myself with lazy "open for appending" or is it negligible because i touched the file before, even when it wasn't for writing.
Reference official document [https://casbin.org/](https://casbin.org/)
I mixed up some things, it's needed to be sure that the right function is called if you need something from the global namespace http://www.php.net/manual/en/language.namespaces.global.php
Looking forward to your use
I actually also using \` $array !== \[\] \` as it more declarative and BC breaks around count(). &amp;#x200B; Well, the array identity still has the shortest opcodes generated: \- array identity: [https://3v4l.org/KgeQb/vld#output](https://3v4l.org/KgeQb/vld#output) \- count without implicit namespace declaration: [https://3v4l.org/FP7aY/vld#output](https://3v4l.org/FP7aY/vld#output) \- count with implicit namespace declaration: [https://3v4l.org/E1WnK/vld#output](https://3v4l.org/E1WnK/vld#output) &amp;#x200B; So, implicit NS declaration IS enabling that optimization, or we need to clarify which PHP version we are talking about.
FYI https://regexr.com has everything to learn about regular expressions.
[more on this](https://sourcemaking.com/design_patterns/command)
Low effort help post
I, too, was a fan of regexr until I found https://regex101.com/
Thanks, I'll take another look at it!
Look at the second part of this answer on SO: [https://stackoverflow.com/a/51418215](https://stackoverflow.com/a/51418215) &amp;#x200B; For those functions, there is a very good reason to add a \\ if you're using PHP7+ &amp;#x200B; For the rest, if you're not redefining native functions in namespaces, it's just style preference. Personnally, I prefer not adding unneccessary chars to the code.
only for external scripts, which should be the case most of the time, but having script at the end of html will work all the time even without defer attribute.
Aren't enums a little redundant with the way PHP uses arrays though? The example given could easily be translated to PHP array use. Enum: enum Days { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, ; } Array: $days = [ 'SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', ]; After that, the switch statement is just a slightly different syntax with all of the same functionality. As of PHP7, a constant can be declared as an array using `define()`. PHP7 Constant: defiine('Days', [ 'SUNDAY', 'MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', ]); Am I missing some benefit that differentiates enums here aside from a little sugar?
I visited both those sites a number of times but guess I'm a sub-human 'cause I could not figure out how to make practical use of them to help me with this particular problem.. so I'm glad people responded here
I Could find the packages; I can’t find the middleware. ;)
You have `yield [from]` which already lets you do this sort of things. Look up amphp and its examples.
Especially between versions 5.2 and 5.3 you need some intimate knowledge and experience from that era. Think about comparing objects in expressions, how dates work differently, what parts of the application depend on specific Suhosin configuration, etcetera. Not to demean your knowledge and understanding of modern PHP, but it's not very likely you've worked a couple of those 7 years with PHP 5.2, given that it has been EOLed for longer. You will very likely miss a lot of subtle issues that are more obvious to more elder PHP programmers, that can have major consequences and side effects. Beyond 5.3, the upgrade path should be smooth sailing, apart from having to replace the mysql_* function family.
`&gt; 0` is extra 4 letters (space;smaller then;space;zero), but that's a silly optimization. There are hundreds (thousands?) of lines of code to be optimized away by good abstractions. Saving a few letters here and a few there is not gonna save us as much, and we are too likely to produce code that can't be understood at a glance.
The primary substantial difference is that you don't get type safety with a constant array of strings. This leads to situations where e.g. someone passes "M" instead of "MONDAY" into your `function foo(string $day)`, and that can't be caught during static analysis. You could [use class instances](https://github.com/myclabs/php-enum) to get the type safety, but the syntax is a bit uglier and it requires pulling in a dependency, which I find rather silly for such a basic language feature.
Interesting answer. Thank you.
I'd like to know too. As I mentioned in [another comment](https://www.reddit.com/r/PHP/comments/aq7emn/what_are_your_thoughts_on_magento/egg0eaz/), /u/alanstorm wrote an excellent article series regarding Sylius (with Symfony as framework) as a viable option to consider. I've spent some days working with Sylius though, and it feels a bit flaky working with the existing ecosystem (plugins, libraries themes) mainly because many of them aren't up to date with installation documentation or even compatible with the current version of Sylius, which makes it really difficult to test out thoroughly. I like the interface and workings of it (and the fact that it's made on top of a modern well-known framework). Second, as a company providing eCommerce solutions, I see a lot of work in just providing the first setup for a client, mainly because shipping methods, payment methods and so on needs to be made from scratch. That being said, I _know_ that someone has to start doing it, and it might as well be me (or the company I work in).
This question is awful but answers are worse. The question has been hanging around for 4 hours and not a single soul was able to come up with the primitive query what the Op need is a single query SELECT c.Email from cleaning c LEFT JOIN mailmerge m ON m.Email =c.Email WHERE m.Email IS NULL This query will return all emails from cleaning that are not found in mailmerg 
It's less than [two days ago this last was posted here](https://www.reddit.com/r/PHP/comments/aq3x0f/phpcasbin_an_authorization_library_that_supports/)...
Interesting, thanks
Just read foreign code. There is not a magic tutorial for everything.
How much is having the website worth to you?
There's a difference between been marketable as a Phalcon developer versus working in a company that has a few projects using Phalcon.
Sure does smell like spam
Active Records links model onto a database table, so they are direct copies of one another. ORM is a data mapper, it maps objects to databases, where an entity can hold data from multiple tables or even pull data from other sources in parallel with database. Search "active record vs data mapper"
In my experience the active record approach gets you up and running quickly if your model is simple enough to match your database. It comes packed with a lot of convenience and you require little boilerplate code. But it generally also means that your model classes extend from the active record base class, which causes tight coupling with the framework, complicates testing and makes it less flexible in the long run. I worked on a project where we added domain logic to our active record classes and it was very painful. Model classes became huge and packed with mixed responsibility. The data mapper approach takes longer to set up initially but it helps you separate responsibilities for well-maintainable code in the long run. I've been working on it in a smaller project for a while and personally it's truly a pleasure. You can write all your domain logic, application logic, tests for everything and only in the end you code the database part. After two years you change your mind and get part of your data from an external API? No problem, you just need to rework the mapping part but your entire domain model remains untouched.
That's pretty dead library, unaware of later 7.x releases. I'd suggest using Phan instead (not for this particular project because it's 5.2 and Phan cares about 5.6+ only), then setting its config for backwards compatibility issues, targeting 7.2 or 7.3, and going from there. It helped me a lot when migration our monolith repo based on Kohana2 framework... after months of work and testing, it's happily running on PHP 7.2 since December '18. 
Doctrine works by mapping classes to database tables. The main benefit of Doctrine over Active Record is that your model is decoupled from your ORM. You can take literally any object (even an object in a third party library you didn't create) and map it to a database table rather than your Entities extending an Active Record "base class". This tends to give you more flexibility when modelling your problem domain.
In my experience it doesn't take long to setup your DB using an ORM like Doctrine, of course this depends on the complexity of your DB. But things like the "Symfony Maker Bundle" make creating your entities a lot easier. Or even let Doctrine create your entities for you based on an existing DB. Doctrine is more complex though than Eloquent for instance due to the sheer amount of features and configuration options available. My personal preference goes to an ORM, as i do not like my entities to do things they should not be responsible for (ie saving themself to the database). For me there is never a reason to use active record over an ORM.
\*Active Record anti-pattern
&gt;The data mapper approach takes longer to set up initially I've heard this said a lot but I've never really seen any evidence of it as someone working with both patterns regularly. Both patterns require you, one way or another, to list out your properties and describe their types and then run some sort of command to update the database schema. The only thing that can take a long time with doctrine is if you want to map a preexisting database table to a class, but that's something you can't normally do with Active Record.
just to add, one other key difference with a data mapper is that you can take a preexisting database table and map it to a class, where as with ActiveRecord, the database table normally has to "fit" the AcitveRecord
In a nut shell: separation of concerns. This is a fundamental of programming in any language for any reason. It's pretty hard to overlook. The mapper pattern lets you build your model in code and map objects to some persistence layer, whereas the AR pattern pulls the entire DB into your model and usually restricts you to table operations. Doctrine 1 was AR, Doctrine 2 is a mapper, it's pretty popular so maybe that says something to you more than I can. I've used Doctrine 1/2 and Eloquent a lot and I can't think of a single reason for Eloquent to exist. 
Eloquent: ActiveRecord Doctrine: DataMapper CakePHP's ORM: DataMapper ActiveRecord is hard coupled to your ORM. The Model knows how to save it's own data. This tight coupling is OOP-Wise bad and lead in very big projects to problems. DataMapper is the opposite.
An enum is essentially a glorified integer with a defined range (0-6 in your example). They are useful because they provide type safety and intent. For example, the following should not compile in a sensible implementation: \`\`\` enum Color { Red, Blue } let x = [Color.Red](https://Color.Red) switch x { case [2](https://Color.Green): break case 'Yee': break } \`\`\` 
I dn'ot know exactly how Eloquent works but with Rails you could decouple any logic from the model and even logic business decoupled for some specific rules.
After reading the discussion, I wonder what percentage of Doctrine users make (I guess the default) the mapping 1:1 (or close enough) between database and entities, as opposed to fully leverage the idea of mapping, to make entities more decoupled from database schema.
Really great article! I'm really happy to hear this. Congratz!
I doubt any handle is created. The file itself probably isn't touched but instead the index of the file system is just read. Tho I'm guessing. You could look at the source of php and the way the file systems handle these kinds of calls. It's interesting, surely. Just not very practical knowledge. 
```php &lt;div class="products-list-price"&gt; &lt;time datetime="{{$product-&gt;released_at}}"&gt;{{$product-&gt;humanReadableTimeDiffBetweenReleaseDateAndNow}}&lt;/time&gt; &lt;/div&gt; ```
What about it?
Welcome to to XXI century. This is a usual syntax for *template engines* used in PHP applications. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Looks like blade https://laravel.com/docs/5.7/blade#displaying-data
[https://3v4l.org/](https://3v4l.org/)
Thank you! Trying it out now.
As a developer of a project that uses thousands of pthreads a second on a very large scale project that spans hundreds of servers all over the globe I for one welcome our new threading overlords :)
I may be wrong, but I think php-fpm work with CGI [https://en.wikipedia.org/wiki/Common\_Gateway\_Interface](https://en.wikipedia.org/wiki/Common_Gateway_Interface) So you will need a web server to use it. &amp;#x200B; However there are other projects like [https://reactphp.org/](https://reactphp.org/) that may fit you needs in the sense its php running is own web server. 
**Common Gateway Interface** In computing, Common Gateway Interface (CGI) offers a standard protocol for web servers to execute programs that execute like console applications (also called command-line interface programs) running on a server that generates web pages dynamically. Such programs are known as CGI scripts or simply as CGIs. The specifics of how the script is executed by the server are determined by the server. In the common case, a CGI script executes at the time a request is made and generates HTML.In brief, an HTTP POST request from the client will send the CGI program HTML form data via standard input. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
It's not really clear what you are asking. Timestamps are just numbers, so yes of course you can add them togeather. &amp;#x200B; Also, /r/phphelp
gmdate('H:i', abs($diff))
&gt; does php-fpm only work with web servers and cannot serve files on its own? Yes.
Oh, sorry about that. Didn't know that such a subreddit exist. So, what i have is this: &amp;#x200B; 4 TimeStamps: 08:00, 12:00 and 13:00, 18:00 I calculate the Difference between the first two TimeStamps and the second two TimeStamps with $a-&gt;diff($b), so i get 04:00 and 05:00. Now im looking for a way to add those two Differences togheter, so i get 09:00, but i dont know how.
Have been in this guys situation before, got recommended PHPTRW, found it useless. I don't think he is the target demographic.
By itself, it can't. but if you use web server written in PHP that responds to HTTP requests - you can. But that's a completely different story and seems way past what you need/want/can do :)
Looks promising. Keep up the good work! 
Just about everything I have seen is 1:1. Two limitations of Doctrine are to blame. First is that within a given set of entities, only one entity type can be mapped to a table. So you can't have multiple versions of entities representing the same table. The second is that you cannot split an entity across multiple tables. So if you have a Game table and a Team table you end up with individual related Game and Team entities thus spilling your database schema logic into your app. You cannot define a GameTeam entity with information from both tables. Actually, a determined developer can work around some of the limitations by creating views and such. But I don't see that very often. Doctrine works great for CRUD. It becomes more cumbersome when your business objects don't line up nicely with your database tables. 
you are right, I just read an answer from https://www.reddit.com/r/PHP/comments/7gbacv/have_the_php_and_phpfpm_merged_now_or_are_they/dqhw7wt/
yup, I just read this https://www.reddit.com/r/PHP/comments/7gbacv/have_the_php_and_phpfpm_merged_now_or_are_they/dqhw7wt/ Got to know `php-fpm` from phpenv: https://github.com/phpenv/phpenv#php-fpm thought it would work without web-servers, apparently it needs web-servers lol
&gt;Oh, sorry about that. Didn't know that such a subreddit exist. Proceeds to ask question here anyway...
I think you're first point might be a bit off given that doctrine does do inheritance, although I would agree that its inheritance concepts are limited too. 
Yes and no. Yes as in it is always a good thing to know more about programming and languages. No as in you already know Python so you have the "regular web backend development" in your toolbox already. I would rather invest into frontend or lower-level languages. Learning new paradigms and mindsets is more important than learning to do the same thing with 5 different languages. You can transfer quite a bit of general Python knowledge over to PHP, though PHP is more similar to Java than to Python I would say. I do suggest you try PHP out and see how it feels, does not hurt to invest a few days to get a general overview of how the language works. In terms of freelancing and finding work I would bet that learning PHP will land you more, though less glamorous gigs overall when comparing with Python.
&gt; Mostly everything works fine except for the fact that the navigation bar is not “behaving”, when the window size is reduced, the navigation bar is not reduced... It smells a problem with CSS. Can you try commenting the .js lines? (Bootstrap-design could work without JS) 
AFAIK, the collapse is handled by JS...
Neat, thanks for sharing. Do you know why it's those specific functions? Also, would I get the same benefit from importing the functions at the top of the file? I imagine the answer is yes since it does the same thing either way but I don't know how it's implemented in PHP core.
Can you help me understand your second point? I've mocked functions in unit tests before, is that what this would prevent, and if so, why is that considered bad practice?
&gt; I can't think of a single reason for Eloquent to exist. You are hardly trying then. 
Eloquent’s query builder is the thing that really gets me between the two. If you are handling large data sets you will see a very large decrease in speed on your queries. I was working on a query not too long ago and the query with eloquent to get 10k rows (a pretty normal thing) would time-out at 30 seconds. The raw query took &lt;1 second. Since this I never use the query builder on queries like this. Which is unfortunate cause it’s the majority of our queries. 
To all of the naysayers calling Magento (2) a bloated pig: while I do agree that it is a very large and heavy platform, it's that way for a reason: flexibility and scalability. Magento allows a merchant to do more than any other e-commerce platform on the market and can grow as the needs of the merchant grow. Additionally, Magento has announced a planned shift toward a microservice-based architecture which will allow the merchant to pick and choose the features they want/need, thereby making it a much lighter platform. &amp;#x200B; For those saying that M2 is more complicated than M1, in my opinion M2 has a much better architecture than M1. I do agree that they went a little overboard in some areas and probably should've based it on an established framework like Symfony or Laravel. Once you get past the somewhat steep learning curve, it is not too bad to work with.
A very important distinction that I rarely see mentioned is that Doctrine and most data mapper ORMs use a ['Unit of Work'](https://www.martinfowler.com/eaaCatalog/unitOfWork.html). With Doctrine all of your writes are queued in memory until you 'flush'. I don't mean it's using a database transaction - it's actually queuing the writes in memory. When you flush Doctrine determines what order to apply the writes in - it doesn't necessarily match the order you called them in. This can result in some interesting behavior like [inserts always being executed before removes](https://github.com/doctrine/orm/issues/5368). Since the entity manager keeps a reference to every managed object it will stay in memory until you tell the EntityManager to stop managing it. If you are doing bulk operations (i.e. imports &amp; exports) you need to call EntityManager::flush and EntityManager::clear every once in a while to keep the memory down ([docs](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/batch-processing.html)). This can get awkward when you want to keep some objects in memory like the current user. Generally you are better of writing queries and avoiding the ORM entirely for these operations if possible. The Unit Of Work might result in your transactions being held open for less time and you won't need to use explicit transactions as often. It might result in less writes since they can be batched. Eloquent doesn't have a Unit of Work. It does have rudimentary dirty tracking to prevent unnecessary updates. Each model tracks it's own state so it knows if it should INSERT or UPDATE. All of the writes are immediate, but can be explicitly wrapped in a transaction.
&gt; The only thing that can take a long time with doctrine is if you want to map a preexisting database table to a class, but **that's something you can't** normally do with Active Record. Sure you can.
[https://codeanywhere.com/](https://codeanywhere.com/)
I don't know if I'd recommend _any_ framework to an ecommerce focused agency. Hosting has become such a hostile enviornment and preemptive security is an incredibly hard sell in the agency businesses. Plus an ecommere agency has so many other things to worry about -- shipping logistics, tax responsibility, keeping customers engaged and returning to the site, etc. Add in the usual agency dance around justifying your continued value -- ugh. As long as VC keeps the price of cloud based platforms like Shopify artificially low, an agency is better off passing that responsibility off to those platforms. Maybe a Product Information Manager to act as a source of truth, but that can be as simple as a google sheet and a shell script. Since I'm guessing that's not the answer you wanted -- framework wise I think your current choices are WooCommerce and Sylius. With WooCommerce you get the WordPress ecosystem for free (for good or for ill) and a business unit at Automattic that seems genuinely interested in helping small business owners. WordPress development is its own special brand of special, but their super simple plugin architecture ("we'll load an include for you and also events but we call them filters and hooks") means you can keep your own code pretty clean. That said you are, ultimately, dealing with a system that jams products into a database table meant for blog posts, so YMMV. Sylius is fascinating me right now. They're a young company and the plugin + docs/install situation hasn't settled yet, but a base set of ecommerce functionality that you can build on top of with Symfony seems pretty appealing. If you have an idea that requires a store front with unique features that you want a team of developers maintaining over time, Sylius certainly seems like the best bet out there right now. 
the M1 experience didnt matter much with M2 certification. 40 hours of studying is A LOT , imho. I got 85% which is pretty good.
https://alf.nu/RegexGolf check out regex golf and build up practice.
Good Lord, what is your project?
You mean pagination? By 1 at a time?
You’re going to have to support your claim. Just throwing a sentence like this to a learning question doesn’t help explain why or why not one is preferable to another in a given situation.
Yea, I thought as much, regarding the M1 experience. I'm sure my employer will give me dedicated time to revise :)
Are the schemas for the sentences the same each time? If so these expressions may work: `Departed\s+([A-Z\s]+)` `arrived\s+at\s+our\s+([A-Z\s]+)` I only tested these against the examples you provided, but in a nutshell, the capturing groups look for uppercase alphabetical letters and spaces. You may need to add commas or other special characters to handle those cases, if they arise.
&gt;Neat, thanks for sharing. Do you know why it's those specific functions? Also, would I get the same benefit from importing the functions at the top of the file? I imagine the answer is yes since it does the same thing either way but I don't know how it's implemented in PHP core. I suppose it would work but I'm not 100% positive. As for why those functions, it's because they can be replaced by Opcodes at the first "compile". &amp;#x200B; In PHP 7+, PHP will read your PHP file and pre-compile it. \- It will delete every comments \- It will delete every if(false) paths in your code (typically if you make a call to a native constant it will be replaced by the value and precalculated) \- It will reserve memory for variables and store some immutable arrays in shared memory \- For the specific functions above, some can be replaced too. For example : $a = \[1,2\]; if(\\count($a) &gt; 1){ } can be replaced by if(true) because PHP already reserved a space in memory for $a AND its size. The same goes for every function in the list. PHP will be able to know in advance what the result is going to be and it could delete entire chunks of your code if it doesn't apply, and it will do it only one time (not at each execution of the script) &amp;#x200B; I have a cool talk about PHP7 optimizations including this one, explained way better than me, but it's in french... [https://www.youtube.com/watch?v=sliLs1hTvBc](https://www.youtube.com/watch?v=sliLs1hTvBc) I don't know if there is one in english (I would be interested to know if someone has one)
Comparable has been attempted twice, I think. A third in the works... 
Please see item #4 in the side bar. It often seems to be missed by people posting in here. With your specific issue, I have been in a similar situation and would gladly offer my perspective on it if you could make this post follow rule #4. PM me once you do and I'll weigh in.
I like this argument a lot and I agree with your explanation for the core difference between Doctrine and Eloquent; however, I disagree with your conclusion. Eloquent exists because on a lot of projects it saves time. As developers, we all like to think ahead; we like to think about how this solution is going to scale, how it's going to change, and how we're going to deal with the headache that is implementing those changes. Something that's easy to forget is that there's a lot of projects, I would argue most in fact, that **will never need to change**. There's a lot of work out there that, upon completion, will barely be touched again. In these situations I think Eloquent is ideal because it saves time. There's been some debate about how much time Eloquent really saves, but remember that the simple act of alleviating the need to think about your models and their association to database columns is saving time and mental resources. In short, Eloquent (and any Active Record ORM for that matter) isn't what I'd build my future on; but it's certainly what I'd build my prototypes and one-offs on.
Technically it was a different repo, this one is Laravel-centric. (I spent a good while looking at it last time trying to decide if I should use it as ACL for my side-project, but I decided to wait for now)
Good bot, thanks!
Please read the sidebar rules. This belongs in /r/phphelp
I see that the PECL release is in the works. How long does that usually take? Am excited to try.
You can try now without PECL ... git clone https://github.com/krakjoe/parallel phpize ./configure make install If you have more than one version of PHP installed, make sure you use the correct `phpize` and pass `--with-php-config=/path/to/php-config` to `configure`. If you only have one version, you don't need to do anything special, but it will need to be a ZTS build. PECL won't be very long, my very capable release manager and good friend Remi Collet will be on it sometime next week, it should also in appear in his repository about the same time.
What about Swoole? They say, it uses their own thread implementation. The best part about it is sharing sockets between them, wrote a sample websocket server and it worked like a charm.
Can you tell me how Eloquent does save time compared to Doctrine when it comes to RAD? This is not rhetorical, I'm asking because I'm more familiar with Doctrine and less with Eloquent, although I'm familiar with other Active Record implementations. Sure, it's easier to understand so if you've never used any of them the learning curve is lower for Active Record (and I assume for junior devs that's one of its main attractiveness), but other than that how I don't think one or the other saves a significant time.
Unless you are a web hosting company, I don't see any reason why you might want to allow your customers to execute raw PHP code. With PHP version incompatibilities, PHP modules, nginx changes (note that you can't have per-dir user-configurable configuration like you'd have with Apache \`.htaccess\`), you are about to be a web host. &amp;#x200B; What is the problem are you trying to solve? If you want your customers to define a certain logic for a workflow (IFTTT-style), take a look at Symfony Expressions and such. Also take a look at these stuff for some ideas: \- Serverless functions: They are isolated, and has a configurable time-out limit. Wouldn't play well with a database. Cheap. \- Web hooks: Let your customers host their stuff anywhere they want, but expose a URL endpoint that your application calls on certain events. \- Managed EC2/Cloud instance: Use AWS/DigitalOcean/etc API to create an instance on behalf of the customer. You can this new instance with your base server with virtual networking (VPC in AWS lingo), so your clients can access the main server for database, files, etc. This way, you have the control over what to show and what not to. Provide them with AWS key for a non-root, a username/password for a database user that only has access to specific database(s), and call it a day. 
I agree that it does not save significant time. The time it saves is basically equivalent to however long it would have taken me to write out the data objects properties and annotate them with doctrine to associate to the database columns. I don't believe the time it saves is superficial either, though; in fact I'd argue that for myself it's about the same as the time saved using bootstrap for layout and styling as opposed to doing it myself. There's time savings but they're just little that simply add up. This is why I think eRloquent is good for prototyping, because you're likely already going to be using lots of tools, modules or other utilities to Dev time investment down to a minimum.
Hey, I just wanted to apologize for my tone in your thread. I don't know why I went in guns blazing. While it's true I'm fatigued with threads with deliberately provocative titles, I was also being provocative with the emotional reaction. So I was no better was I? Apologies, hope you're well.
Well ... there are three basic execution models for any code, but specifically we'll talk about PHP ... Imagine you have three functions to execute, each with 5 instructions, it doesn't matter what the instructions are ... click the links and look at the images before reading the rest of the sentence, sorry about the quality of the images, I couldn't find the originals ... [Synchronous](https://imgur.com/VA6Hbhr) execution is the thing we're all used too in PHP: All of the instructions for task one execute, then task two, then task three. Easy to understand. [Asynchronous](https://imgur.com/rkbxBWI) execution interleaves the instructions for each task, but, the tasks must yield control to another task, so that it may execute some instructions, then that task yields, and so on. This is what we have with generators and yield, it's used to great effect in frameworks like amphp and others. [Parallel](https://imgur.com/rkbxBWI) execution is when the tasks are not split up (so your code looks like normal synchronous code) but are executed in parallel in different threads. You can't have parallel execution without real threads. So, that's two distinct models of concurrency: * asynchronous concurrency (interleaving instructions) * parallel concurrency (no interleaving necessary, but threads are necessary) Confusingly, you will hear some people talk about "concurrency" and mean asynchronous concurrency, and some people use the word "parallelism" for parallel concurrency. Regardless of the terminology, you should now be clear about the differences between these models of execution. Asynchronous concurrency is mostly used in the realm of I/O, but it also used in other languages to implement what is called "Green Threads": There is only one true thread of execution, and the code was written like synchronous code but the engine/framework/compiler etc interleaves the instructions for the programmer. Green Threads then, are a kind of co-operative multi-tasking, but the act of co-operation is generally taken care of at levels below the code the programmer wrote, so that unlike normal asynchronous code, the code looks like synchronous code. Swoole implements co-operative multi-tasking, and if you were following along, you already figured out that this is not based on parallel concurrency, but on asynchronous concurrency. When the readme says "you can think of co-routines as individual threads", it's referring to green threads. No user code is executed in parallel, it is executed asynchronously. The internals of swoole does use threads but to service I/O, not to execute user code. You could write the last sentence for me now, I hope :) Parallel and Swoole have different models of execution, and are used for different things.
What about using documents if you don't care about schema? I get that it's easier to create a table and just start using it, but it's not that much easier imo for the price you pay.
I guess this holds the same for ReactPHP, right? 
Right, it's asynchronous concurrency ...
Thanks for the great summarization! Just a quick note, Parallel image is the same URL as Async. I tried pthreads several years ago, but I really couldn't figure out how to make a socket server to handle chat server. After learning Erlang, I found Swoole, which (at that time) lacked Async Postgres support (it has been released by now), so I didn't really look into it. Turns out Swoole has multiple modes of operation. It doesn't do threads, but processes: "SWOOLE_PROCESS: multiple process mode, the business logic is running in child processes, the default running mode of server". Since the whole project has very weak documentation, and I haven't had time to inspect the code, I just assumed it meant threads.
Very interesting work, I'm looking forward to your progress. I'm currently working on a middleware which needs to resolve multiple independent api calls for each request (combining the results into a response once the longest running call is done) and was going to use pthreads, but I might just try parallel instead.
Active record is better for rapid development because there's less boiler plate and configuration, so if you need to build fast, that's what I'd recommend. Data mappers like doctrine on the other hand encourage more intelligent code structure, flexibility and better testability and hence are more suited to long term builds where robustness and extensibility is favoured over development speed. It should also be added that some developers advocate no orm, with hand rolling sql in your own repo and query classes. Custom sql is the most flexible and can be the most performant, but it's more tedious and you'll have to design your own migrations and schema maintenance tools. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Let me preface this by saying it's not an answer to your question: I think an API coupled with webhooks would be a better way to go. Let your customers host their code elsewhere (and they're not limited to just PHP at that point). Take a look at Shopify or other SaaS/PaaS offerings. &gt;the application source-code (read only). I'm surprised you would offer this to your customers. Someone will eventually take it and use it for themselves.
You can decouple the model from business logic with something like repository pattern, you can even swap the Eloquent with Doctrine easily when needed, as long as the repository has contract to follow
its not a webserver, seems odd to expect it to serve files. Debian has a slower release cycle. Thats not automatically a bad thing.
Our product is already open-source. ☺ Webhooks is a cool idea, but it partly defeats the purpose of not having to provide your own server (since the product is open-source they might as well host the entire system instead).
Any idea how hard it would be to make a php unit wrapper that uses Parallel? (I know of, and have used liuggio/fastest in the past to great success, but if there could be something easier to set up it would be nice.)
Our product has a plugin system since many years, but so far we couldn't use it in our SaaS, only in the self-hosted solution. We do in fact have an expression language already! It gives a lot of flexibility, but it's not comparable to a full-fledged plugin system. Oh, so you can "mount" local volumes to AWS instances? Something like that might be necessary at a certain scale. I was hoping to find a middle ground that would fit our current workload, but maybe I'm wasting time.
I made a docker image: https://hub.docker.com/r/sarkedev/php-parallel Thanks again!
I love the heredocs especially when writing like a xml file as skeleton and fill it with values afterwards e.g. &lt;&lt;&lt;xml &lt;Root&gt; &lt;Somesub&gt; SomesubPlaceholder &lt;/somesub&gt; &lt;/Root&gt; Xml; Now you can youse str_replace to replace SomesubPlaceholder with the actual value and dont have to worry about messing up to build the actual xml in a loop or so. Its actually quiet comfortable to use too as most IDEs will highlight it in the given language and enforce a proper formating of given language so its more easy to read than having a messed up string in like line 10738. Also this way seems more natural to me that to use a builder class to generate the output like SimpleXmlElement which is perfect for reading and building very complex XMLs but a bit overkill for like a simple Post Request Response (which is mostly what my uses for xml and json are) So yes heredocs are really useful and definitely under appreciated
I try to use it and describe what each function does and give extra information. But truth to be told in most cases it feels unnecessary to provide a phpDoc e.g. getter, setter of cource but also functions like /**Does this *@param array $someParam someParam that do this */ function doThis(... $someParam) Is like telling what was already writen there again For more complex functions that need explication of course it is necessary but mostly I feel phpDoc should get a clue and try to understand the method name of like getSomeParam and autogenerate a phpDoc for a getter or just autogenerate what I would have to write again so I just have to adjust it like with above example doThis(...)
No idea I'm afraid ...
Honest question incoming (I've used Eloquent very much, because Laravel; unfortunately never worked on a project using Doctrine): I believe that in practice I benefit *a lot* from lazy loading capability of Eloquent. I get a model and never need to think about when I need to access any relationship. When the time calls for it and I need a collection of models and I *know* I'm going to access relations of those collection, I eager load them to prevent the `n+1` issue. I'm working on GraphQL projects to, baked by Laravel/Eloquent, worked good so far. [https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/advanced-configuration.html#association-proxies](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/advanced-configuration.html#association-proxies) talks about proxies for achieving lazy loading; this whole thing is labeled under "Advanced configuration". Maybe I'm on the wrong track, but to me this would be a pretty basic thing. Or am I mixing things up? Or, from [https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/tutorials/extra-lazy-associations.html](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/tutorials/extra-lazy-associations.html) : &gt;Associations are marked as Lazy by default, which means the whole collection object for an association is populated the first time its accessed. But doesn't that mean it's coupled, again? If it's just a mapped object, the why I understood it, it shouldn't be able to populate anything from the database. When I look further through the docs, I see that the lazy loading capability seems to be a annotation/configuration setting for a relation. So either it's always lazy or not lazy loaded, depending on this. I _guess_ I can override this behaviour, if necessary? Maybe when formulating the DQL? I also found https://www.uvdesk.com/en/blog/doctrine-proxy-objects-lazy-loading/ , I think I'm getting a better picture. But boy, having to understand all this feels way more complex then just using Eloquent. But then, this is what I'm used to so obviously I'm biased. Why is "lazy loading" such an import thing for me? Because the I almost can't comprehend the multitude of different context a model is going to be used in, and only when I know I would need more upfront, I perform eager loading (otherwise it would be a waste of database resources to do it every time, even when not needed). I get the feeling that Doctrine is really an exciting thing, but unless I have to "right project" for it, I can't see the benefit having to deal with the extra overhead. Appreciate some clarification or further pointers, thanks!
yes - https://easyengine.io/tutorials/php/directly-connect-php-fpm But just use nginx if you're using it in a web environment....you don't gain anything from running it independently.
Lol sounds like a scam. 
PHP programmer looking for a job. Progress is made after bitcoins have been paid.
Just use guzzle man 😏
\+1 for Phinx. Framework agnostic and flexible enough to allow several use cases (one-server project, multi-server and/or multi-environment capable, etc(
[implode.io](https://implode.io) &amp;#x200B;
&gt; I get a model and never need to think This is the problem. It's actually a great feature for some things, but we currently have an army of Laravel/Eloquent developers preaching the gospel without any clue as to the long term problems. &gt;talks about proxies for achieving lazy loading Doctrine lazy loads by default, just -&gt;join if you want to eager load. You shouldn't need to worry too much about advanced config for the most part. https://www.doctrine-project.org/2009/05/29/doctrine-lazy-loading.html &gt;But doesn't that mean it's coupled As a user of the object you don't care where the data comes from, or when it comes. It's just there, so there is no real coupling. The class is literally a plain php object. A great way to see this is to try and mock (properly, without booting laravel) a model. You can't. I get there's always a learning curve moving from one system to another, but mapping isn't that bad, and I'm pretty sure you'd appreciate the flexibility, and more importantly, the integrity of a proper model that is not aware of the db and can enforce it's own consistency. HTH
you have a mysql connection smack in the middle of your domain object, for a start.
People just love to ban my stuff around here, but here's what you asked for. Simplistic class (allows you to create Concise UUIDs (22-digit base62 UUIDs vs the typical 36-digit ones). In other words, it transforms `d318fb95-5b49-47ca-abd5-326a60524e70` into `6QKnU3XheQMk3E6Vq1B4l6`. It also has 100% unit test code coverage. * https://github.com/phpexpertsinc/ConciseUuid/blob/master/src/ConciseUuid.php Here's a much more complex app: https://github.com/phpexpertsinc/workday-planner/tree/master/src It will spit out an array of DateTimes for the actual and observed Federal holidays of the United States of America, but has support for other countries to be added. It uses composition instead of inheritance to do this, which is a Very Good Thing To Learn when you want to join The Big Boys. It also has 100% unit test code coverage. https://github.com/phpexpertsinc/workday-planner/tree/master/src Here's the kit-and-kaboodle: My PHP Genetic Algorithm framework: https://github.com/phpexpertsinc/php-evolver
[https://repl.it/languages/php](https://repl.it/languages/php) 
I think Docker/LXC containers is the way to go. Go take a look at [codio.com](https://codio.com) \- thats how they implement workspaces and keep everything separate. If you email them they may give you some architecture ideas. &amp;#x200B; Basically you are setting up a webserver for each customer in a docker container with a different service number. You probably need to randomize the hostnames, so the customer code / plugin is effectively quite unique and hard to guess - your core code will connect to the plugin via hooks maybe using curl calls at URIs like [http://xe321245ea55:6900/hooks/1/whatever](http://xe321245ea55:6900/hooks/1/whatever) \- you could give your customer limited ssh /sftp access to their containers. There will be authentication/firewall/logging setup needed in the OS. Its possible you could host the LXC containers in AWS virtual machines too which gives you another layer of separation. &amp;#x200B; This sounds like an interesting project for you - have fun trying out some stuff but make sure you have logging enabled,ports disabled, ufw configured etc. on the machine hosting the plugins and check regularly for any hack attempts. You probably want some kind of OAUTH type authentication between your core code and their plugins. Note there's lots of open source systems utilizing plugins (like wordpress, drupal etc.) &amp;#x200B;
It depends a little on the type of project you are doing. Does your PHP output a complete page, then some input in the browser sends a request for another full page. Or is it a single page application where you output a bunch of html/css/javascript and then receive AJAX calls to just send data down to the HTML page. These 2 different types of apps work a little different. &amp;#x200B; Typically for the first type of app you will have multiple files called xxx.php with the initial index.php. Some of the files might be includes (like header.php, footer.php). For files that show a whole page of data, you do not really need to overthink how the code works. Something like this: &amp;#x200B; // start or connect to session, include autoloader // get args from client request, and log this request // validate args - return error page if args are bad // extract user id, role id or app id // authenticate - return error page if not allowed access // connect to DB using PDO to get dbId // startup class to execute this request (might have a switch statement here to route different requests // execute class method to get response - OPTIONALLY use guzzle/curl to execute on different app server // log response, cleanup resources and return response // die &amp;#x200B; // class\_XX.php file contents (dbId passed in, args passed in) // prep and execute PDO statement to get data (Optionally use a DB extraction layer) // prep format of data being sent back (whole page of json\_encode for AJAX request &amp;#x200B; // class\_DB.php (abstraction layer for PDO select, insert, update, delete requests) // main reason for using is to log every SQL request, measure performance etc. // I sometimes have different methods for select a record, vs select a record-set // Note an ORM may have one class per table, bit not frameworks will normally have // an abstraction layer just for the SQL request types. Another reason for the abstraction // layer is if you change db later (even tho PDO is reasonably db agnostic) its only one place // to change the calls (say for example you decide to go to mongodb or some other daft choice) &amp;#x200B; Now this is all pseudo code above but it shows a reasonable way to structure your code. Feel free to ask any questions. &amp;#x200B;
I use them a lot. To output various templates with variables (html output, emails, SQL, even some json formatted data if there is a reason not to use json\_encode on an array). I love heredoc format, its one of the biggest omissions from javascript (think about all these crap template libraries when it should have been native.) Now in ES6/EMCA15 I think is is native but using backticks. Oh well.... &amp;#x200B; &amp;#x200B;
This has nothing to do with PHP.
Sample db or working example please
Yes you should.
What the fuck, go away.
Hey, thanks for the feedback! Yeah, I will definitely look into more about the solution using docker *together* with webhooks - it might be a small modification in our product to make the plugin event system talk with an external (but still hosted by us) service.
I think you got the wrong subreddit.
If it's a REST api, you might also be able to use cURL. http://php.net/manual/en/function.curl-multi-init.php
From your top post I thought it is a very bad idea giving customers access to the SaaS via executed code on your servre, including access to the database etc. But after this explanation I understand you are essentially a shared hosting company for just one specific product. I wouldn't go the Docker route, because for PHP the shared hosting model is actually 20 year+ proven deployment. You should look at how hosting panels like Plesk, CPanel separate customers from each other (different user, different fpm pool, ...), maybe even use one of these tools as the foundation of your solutiion, maybe invite a security / operations person from a large shared hosting company for 1-2 days to give yo uan overview. 
Yes absolutely. It’s brilliant. A backend that would have taken us weeks now takes us an afternoon.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Hi, Although im not an expert, and some nice ideas have been given, I can make 2 suggestions: 1. Use a PHP VM, which restricts what php stuff can be used and can provide a solution fir different php versions being used https://github.com/ircmaxell/PHPPHP 2. Build and provide a DSL (Domain Specific Language) to your customers. Glagol is kind of a DSL framework built in PHP with which u can build a Domain language you can provide your customers for them to build their plugins in. For example you could provide for the the Salesman and the Car entities with the allowed behaviours/methods, and they would write the behaviour using that. https://github.com/glagol-dsl Hope this was helpful. Good luck.
what you exactly want to know because your description is not that clear. DM me may be we can come up with something 
Ah, good to know, thank you. Unfortunately, it's not REST, just php clients to apis that do independant computational work.
Can anyone point me in the right direction. I am having a hard time finding resources on how to do with. I can send json to the API bu using $payload = json\_encode(array($post\_data)); &amp;#x200B; The API should return a key which you can then send back as a cookie when using post/put/delete/ect... to the API to show your authenticated. &amp;#x200B; Help please. 
Way too little information, we have no idea what you're looking at or what kind of authentication you're talking about. When asking questions, please provide any relevant information and also add what you've tried so far. Also, /r/phphelp
On the website https://api-platform.com/ you have a "They use API Platform" including both open source projects and companies using it in production.
Hm, I think we use ISPConfig in some places. Maybe I can have a closer look at that. Yeah, inviting a consult would be great! Just have to convince the boss. 😆
Maybe he wanted to pass this as a reference into a function like array_walk?
Hard to know for sure with such a small snippet, but generally such a pattern would allow you to delegate the comparison to when it was actually used, such as if $this-&gt;mediaType could change between when isImage() was called, and when the test needed to be performed. Pretty obscure though. There are much better ways of doing it. 
Hi, thanks for the feedback! Wouldn't both 1 and 2 imply a pretty big performance hit? We have a small DSL already, but only for minor logic configuration by nontechnical people. But it's definitely an interesting idea.
PSR-12: All PHP files MUST use the Unix LF (linefeed) line ending only. Good luck with that when certain important windows tools don't support it.
I'm not a big fan of the OOP paradigm. I'm forced to learn php for school so I was looking for resources for procedural programming in php.
There is [pinba](http://pinba.org/) which adds little to no overhead. Mostly useful under highload/distributed PHP backends
Sure, also PCRE to PCRE2. It's never too late :)
I would like to second the thanks.
I want a distributed commission system for multiple users system. I create my child with 1 unit margin. And his sub child was created with 0.5 . So if sub child create transaction i get 1 unit as commision and my child will get 0.5. This need to be done for multi level
Same - StatsD. I ended up not using the library so I could just send one packet at the bottom of my front controller. I never got around to wrapping it in a class but I like the idea. From there collectd has a statsd listener built in. I'm using collectd for other stuff like load / disk IO / bandwidth monitoring. Collectd feeds graphite which feeds grafana for the pretty pictures. I've been meaning to replace graphite with influxdb but haven't got around to figuring that out. Installing graphite requires specific versions of python things that conflict with every other python thing that all conflict with each other - the whole process pisses me off. So it's not that graphite doesn't work, it just feels brittle. I ended up dockerizing it so I didn't accidentally sneeze on a python dependency.
https://leanpub.com/phptherightway/ is free ebook
it's not "advanced" but it covers popular design patterns 
can you please tell me about the distribution system in percentage instead of units. ??
The problem with semver IMO is that it doesnt always work in a framework context. Something I described [here](https://www.dereuromark.de/2016/01/29/developing-cakephp-3-plugins-its-fun/). Framework-Semver would be needed here. x.y.z x: framework major version (BC breaking change) y: plugin major version (BC breaking change) z: plugin minor/patch version (BC) if semver is 3, then f-semver would be 4 digits. Or with your solution of only 2 we would then have 3 - makes total sense! But that hasn't yet been introduced anywhere, and as such framework depending coding is usually quite the mess and needs some docs/lookup tables to keep track of the version matching.
It'll work though personally I'd say &lt;script&gt; tags should be avoided as much as possible. 
I use it in production. Can't divulge much about it but it's a fascinating piece of engineering. 
&gt; I'm not a big fan of the OOP paradigm. Why? &gt; I'm forced to learn php for school so I was looking for resources for procedural programming in php. The usual "issue" with newcomers to PHP is basically moving from procedural to OOP. If you're not writing OOP, how are you not writing procedural?
Glagol is “compiled” into php so the performance hit is residual, virtually none. PHPVM, i can’t say.
In atom there is a package php-cs-fixer that runs on save and fixes errors there appears to be one for vs code &amp;#x200B; **php cs fixer** [https://github.com/FriendsOfPHP/PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) &amp;#x200B; **Vs code extension** &amp;#x200B; [https://marketplace.visualstudio.com/items?itemName=fterrag.vscode-php-cs-fixer](https://marketplace.visualstudio.com/items?itemName=fterrag.vscode-php-cs-fixer)
I prefer system languages ​​like C or Go. I also used Java but I do not like the idea that everything should be an object. Since it is possible to use mysqli both in a procedural and object-oriented way, I thought I could use a procedural method for everything in PHP. I do not want to open a debate and I do not want to look like a purist or something. I'm just looking for someone to tell me if I can use PHP in a procedural way and advise me of good sources If this is not possible I will use OOP without too many regrets
VSCode has an extension for that. https://marketplace.visualstudio.com/items?itemName=ikappas.phpcs
If you're already comfortable with other languages, I'd just look at the examples in the manual. PHP really isn't that different from what you're used to. I doubt you'll find much in the way of resources for procedural PHP, let alone good ones. The best I can think of is maybe some old drupal 5 docs/tutorials, if you can find them. The current version is drupal 8, so that might not be easy.
learn about it independently from php. 
Are there design patterns unique to PHP or are design patterns a principle of software development ou can learn without focusing on alanguage (It's a serious question, for instance whenever someone says they want to learn a programming language my first suggestion is Principles of OOP over at lynda.com - it's language agnostic but an important foundation)
Thank you! I will try to do other research 
I love these!
Can parallel be used via FPM or is this CLI only?
2months fresh - https://matthiasnoback.nl/2018/12/principles-of-package-design-second-edition :)
&gt; A backend that would have taken us weeks now takes us an afternoon. This is exactly it, very RAD. I had some trouble when trying to get out of the RAD and build something a little bit agnostic from API Platform. From my experience API Platform is a whole framework that you have to embrace completely, and forget about traditional approaches like MVC. I don't even consider it Symfony (even though of course it is based on it). I would recommend it for CRUD scenarios, or cases where you want to go fast and either offload the project to someone else and move on (e.g. a web agency) or keep the project internally and embrace API Platform completely (and become expert of it). I don't see it to fit teams using Symfony or Laravel extensively and trying to save a bit of time for an API in a bigger application. That's just my experience of course.
You mention "during development": - if it is on your machine you can use PHP-CS-Fixer or PHP CodeSniffer, both have a PSR-2 preset. If you want to save yourself some time you can use [Pretty](https://github.com/mnapoli/pretty) which will run those tools for you - if it is in continuous integration you can use [prettyci.com](https://prettyci.com/) to run all the tools above on every commit and pull request
I'm trying to understand the difference between parallel and pthreads. Correct me if I'm wrong but parallel is meant to be like pthreads but simpler to use? Also would parallel be suitable to run entire applications in a thread (handle a HTTP request to return a response)? I'm thinking about this in the context of [bref](https://github.com/mnapoli/bref), a project that allows to run PHP on AWS Lambda. The way it works is that there is a main process (the `bootstrap` file) that fetches events (HTTP requests) to process, and currently it spawns a new process per event. By executing the PHP code in a threads would avoid the overhead of booting a new process (like in the PHP-CGI times). You can find more details here: https://github.com/mnapoli/bref-bootstrap-benchmarks
Since you are set on not using webhooks or FaaS you might have to resort to containers or virtual machines indeed. This is a lot of new things to manage. I don't know enough to help more but maybe a strategy could be to reserve the possibility to use custom plugins only to clients paying a lot more. Then you could host those clients on a system like platform.sh where you deploy each client separately. This is way more work, which is why I don't think you should do it for every client. I had to deal with something similar at a previous company and this is a whole company strategy thing.
Did you read it? Looks interesting! Although I'm always scared of buying books that don't have reviews yet.
I got no problem with a down payment. Not a scam not a ripper Will do escrow of you're choice 
Actually, manually fixing a safe plugin environment is what we're doing now for some big clients. BUT, we want to *sell* plugins, as many as possible, so therefore it's important that everyone can use them, both self-hosting and SaaS. Nothing is 100% ruled out yet. Didn't know about webhooks and FaaS before starting this thread, so I'll read up on it!
I strongly recommand following Laracast’s free video serie on using VS Code with PHP !
Haha watching it as we speak! Just bumped into it.
Right I understand. I made and use [Bref](https://bref.sh/) for [prettyci.com](https://prettyci.com/) initially, it allows me to run builds in AWS Lambda. For a larger application (maybe like yours) running the whole thing in AWS Lambda could be a solution but I guess that could take some work. What some companies started doing is replacing webhooks with FaaS (e.g. Lambda). Not in the sense "install 3rd party plugins in the application which runs entirely on lambda" but rather "our app runs on our servers, but you may hook into it via custom code that runs separately on lambda". It depends on your needs and what you are able to do.
With respect to data security I'm not sure we can use AWS or any external provider, but of course we could roll our own lightweight solution in a similar manner, e.g. having PHP plugins running in a separate container communicating with the old architecture using webhooks.
Making sure the uploaded file is an image and not a `.zip` file or Word document?
&gt;without any clue as to the long term problems 🤔 &gt;Doctrine lazy loads by default, just -&gt;join if you want to eager load. You shouldn't need to worry too much about advanced config for the most part. [https://www.doctrine-project.org/2009/05/29/doctrine-lazy-loading.html](https://www.doctrine-project.org/2009/05/29/doctrine-lazy-loading.html) Quite flexible, interesting. However, I'm not sure what worries me more: * loading a "model" partially, and having each not-loaded field lazy loaded (Doctrine example) * loading a "model" partially and having each not-loaded field automatically default to null (Laravel) Actually, I think it's the former though the latter of course has problems. But the latter is usually caught in tests and rarely do I not select all fields *when* I want to work with models… but you can say that for the former too (how do you check for superfluous SQL calls?). &gt;A great way to see this is to try and mock (properly, without booting laravel) a model. You can't. Absolutely correct. I never found a way to do it. Especially when I started, this was a bit confusing. Now a few years into the project, I realized it doesn't really matter. There's literally nothing on models I need to mock anyway. Everything data fetching/mutation code is in repositories anyway. OTOH, integration tests are very much necessary to properly cover enough business logic to make sense. At least in my experience. "Complex" relations, multi union/joins, still also respecting database server logic (triggers at al) =&gt; it's simply not possible to write everything in "unit" tests in isolation or the mocking becomes so obscene it's not worth it. The downsides are of course complex tests and complex test dependencies. OTOH I like it. Easy to also test/verify database server side logic, once you've the infrastructure already taken so far. Actually I'm not arguing over anything, just wanted to mention it :-) I'm comfortable where I am but can't eager wait to try out a different pattern but can't really find a project/task/case for it, unfortunately. Is there a "killerapp" open source project covers advanced features using doctrine? Quick search found sulu/sulu-standard but no idea if that would be a good representative 🤷‍♀️ And, thanks for your time, enjoying a healthy exchange!
I haven't read principles of package design fully, but I am reading his latest book, Style Guide for Object Design, which is great. I'm a big fan of Matthias' stuff (books, talks, workshops...). He's a great teacher.
Design patterns are just that, patterns. You can implement them in any language. Afaik, [the Head First book](http://shop.oreilly.com/product/9780596007126.do) is sorta considered the bible. I believe that one uses Java for it's examples. 
That's sort of what I figured (from the name) so doesn't need to be PHP specific :) 
We use a nice injectable class around StatD, sending metrics to Datadog. Works like a charm 👍
Thanks! I'll check it out
&gt;But it generally also means that your model classes extend from the active record base class, which causes tight coupling with the framework, complicates testing and makes it less flexible in the long run. &gt;I worked on a project where we added domain logic to our active record classes and it was very painful. Model classes became huge and packed with mixed responsibility. There's no reason this has to be the case, this is urely a design decision. You should be keeping your business logic decoupled from your database access layer on non-trivial projects. Eloquent doesn't force you into this kind of mixed responsibility set up and it's very testable.
Ditto pretty much - it writes to statsd - which was being fed into Grafana using telegraf; but is now going into stackdriver. I'm not sure about stackdriver at the moment (it only allows 500 custom metric names, which is probably a problem) so I might investigate other reporting backends (datadog probably as I keep coming across it).
And is that to their dogD or whatever it’s called?
&gt; loading a "model" partially, and having each not-loaded field lazy loaded (Doctrine example) You would have to do that specifically. By default all properties are eager and all relations are lazy, you have more control with dql, and you can add hints to annotations too. &gt;There's literally nothing on models I need to mock anyway You should be mocking the models when you test logic that uses models, not when you test queries etc. &gt;it's simply not possible to write everything in "unit" tests agree, but it's a bit like a food pyramid with unit tests at the bottom, integration tests are ice cream. &gt;mocking becomes so obscene it's not worth it. this is usually a code smell, if your code is clean then unit tests are easy to write. with an integration test you shouldn't mock much of anything at all. Sylius might be worth a look, I've heard a lot of good things but not had a good look at code tbh. FWIW I think the thing that bugs me the most about Eloquent is the lack of integrity of the model. I've actually seen this in live code: User::select('house.*')-&gt;join('house') and you have a 900sqft user with 2 bathrooms and a garage :(
Why would curl_multi be restricted to REST apis? It's not. It is async though, not parallel.
You are correct, RESTful or not is not the real issue here. I'm just not calling http apis at all. Just functions from other php libraries. And those are what I want to run in parallel.
&gt;Sadly, no. We'd love to stream/offer talks for download but at $2k per track per day (venue rules) that's something we can't swing at this point. Though I'd encourage folks to bug NomadPHP to pick up this talk for online consumption at some point :)
I mean, we have at least one Aggie presenting... [https://www.longhornphp.com/lineup/#daniel-cousineau](https://www.longhornphp.com/lineup/#daniel-cousineau)
It isn't an accessibility issue; PHP has had some pretty big issues over the years. Many of them have been fixed, but I imagine a bunch still exist. 
I have been using PHP before OOP was introduced. FOP is my default mindset. That said, functions are incredibly easy. What do you need to know? OOP is also easy and you are likely adopting it without realizing it. Interacting with a database is something that should be done in an OOP manner, IMO. Aside from that, FOP is a great solution for such a wide array of issues that I always have a very nice "func" folder with nice libraries of custom functions I create with every project. The primary thing I think functions are useful for is reducing redundant code, in particular when that code is not actually PHP. Do you have a block of JavaScript/HTML/CSS that allows buttons to be created and/or function properly? Crate a PHP function that accepts variables which change the needed segments. Almost every aspect of most projects can be reduced to a few simple functions.
Hahaha, thanks buddy, I appreciate you!
If PHP is the FL Studio of programming languages then who is the Soulja Boy of PHP?!
&gt; User::select('house.*')-&gt;join('house') :-/ These are really stupid mistakes, they just happen. However, such a particular bug is really easy so spot (code review) and easy to be noticed with test. I struggle more with behavior: `Model::select('*')-&gt;join('other_table')` Columns of same-name will overwrite it each other and if your test data is not diverse enough, you wouldn't even notice. It happened too often so we create the rule that **all** references must be fully qualified `table.column` (i.e. `table.*` for above select), no exceptions. No problem after that :-) but it's sad this is necessary.
Youuuuuuuuuu! Crank that terrible code out!
It's accessible if all you're doing is monotonous 4x4 beats and canned loops. It's gets a little more involved when you stat getting into tweaking oscillators for your own sounds, automation, and chopping/slicing beats.
If your on AWS you could use CloudWatch metrics: [https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/cw-examples-publishing-custom-metrics.html](https://docs.aws.amazon.com/sdk-for-php/v3/developer-guide/cw-examples-publishing-custom-metrics.html)
I personally would be all for them. Just like any new language feature there is a potential for abuse, but at the same time I feel making annotations actual part of the PHP language would be great due to being able to opcache them. It would be interesting to see what, if any, kind of performance improvements native annotations would have to the ones in Symfony, Doctrine, and any other frameworks that rely on them. 
Isn't @ symbol still an error control operator? https://secure.php.net/manual/en/language.operators.errorcontrol.php
It's a "no" from me I'm afraid. I think there's already an effective and well-standardised method (Doctrine Annotations) of adding annotations to classes / functions etc and that's using docblock comments within /** ... */ and I don't see what particular benefit adding syntax changes to the compilable code itself would bring. I would be more than happy for PHP to include inbuilt compile-time support for parsing docblocks and storing that alongside the reflection data, as it would offer improved performance, and existing implementations could act as polyfils for older versions. Things which do have direct effects on the processing should, IMO, be keywords and should be part of the function / class / method declaration. For example, to stop certain things being optimized away in certain languages, there is the keyword "volatile". As-is, I don't think this RFC makes a convincing enough case for this change vs the present, extremely well supported method. 
\*Please\*, do not start the "you are turning PHP into Java". As a matter of fact Java annotations started in docblocks too so PHP with current docblock annotations is already copying Java, just an older version. There is a large part of this community, mainly Symfony/Doctrine users, who would really like to use proper annotations. If you don't like them you are free to avoid them as you are already doing with docblock annotations.
Unless Michał posted this themselves... &gt; Status: Draft **Don't publicise draft work** The site wiki.php.net/rfc is a tool that is meant to allow people to draft RFCs and share the idea with other people who want to work on the RFC before it is a polished idea, and before it is ready to be presented to the world. Having someone other than the RFC author announce the RFC on internals before the author thinks the RFC is ready for comment, is "not okay". If you discuss an RFC on internals before the author thinks the RFC is ready to be discussed, the only thing that could achieve is to make the conversation less productive. If you want to influence how the RFC is drafted, it is appropriate to reach out to the RFC author, and offer to help them. 
They both aim to solve the same problem, however ... Rubix is faster, easier to use, more modern, and more complete Php-ml is older, and has more contributors &amp;#x200B; A quick speed benchmark shows that Rubix ML KD Neighbors classifier is about 30X faster than Php-ml's K Nearest Neighbors classifier for the same problem (1,372 banknote samples w/ 4 features, training plus one pass of inference over the entire dataset). Here's a screencap [https://github.com/andrewdalpino/rubix\_vs\_phpml\_knn\_benchmark/blob/master/docs/rubix\_kdn\_vs\_phpml\_knn\_screencap.png](https://github.com/andrewdalpino/rubix_vs_phpml_knn_benchmark/blob/master/docs/rubix_kdn_vs_phpml_knn_screencap.png) The reason for this is Php-ml is the naive implementation while Rubix ML is the optimized tree-based implementation, and that is just one example You can check out my work here [https://github.com/andrewdalpino/rubix\_vs\_phpml\_knn\_benchmark](https://github.com/andrewdalpino/rubix_vs_phpml_knn_benchmark)
Django/Node/PHP developer here. I can't speak about market shares as I'm usually free to choose the tool for job and because of this I can add another useful information: sometime PHP is the right tool for the job. For example take a look at api-platform (and react-admin). There is nothing like that on Django/Flask/Node.
I've read 1st version 3 years ago. I knew about 50 % of it, but this book gave me complex image about the whole design idea. &amp;#x200B; From a programmer's point of view, but mostly from people-reading-my-code-after-I-leave-the-company view. I mostly thought about myself before this book.
So this basically &lt;a href="https://www.doctrine-project.org/projects/doctrine-annotations/en/latest/index.html"&gt;Doctrine annotations&lt;/a&gt;, just in the core?
Even in \`/\* @ \*/\`?
Because docblocks weren’t designed for that purpose. Plus there’s benefit in structured annotations via classes/objects that docblocks can’t provide (i.e. synthax validation) not to mention inheritance and composition. I’d totally make use of them to structure my code better. 
This would be fantastic. 
The underlying point of this RFC appears to be to remove the /** */ So whenever any pre-whatever-version-this-was-added-to encountered the @, being an existing token with an existing meaning, it would cause a fatal compilation error.
I’m not a big fan of annotations in general, but personally I’d prefer a language-supported option over a community standard if I’m forced to use them. I am a *very* strong believer that comments should not change runtime behavior, and deal with the suggested configuration of e.g. Doctrine with deep regret. I also don’t see this as being a BC issue for libraries - they already have docblock annotation parsing which wouldn’t break. This would add another code path to handle, but it wouldn’t stop the exiting one from working. 
&gt; I also don’t see this as being a BC issue for libraries Any library which used this would be unable to be used with any previous version of PHP as it would cause an immediate compile-time syntax error. Thus, is completely backwards incompatible. 
It has worst learning curve than Drupal :D Total waste of time and resources. I haven't seen so many anti-patterns in code for a while. It's 2019 and they relay on Zend, with some strange DI implementation. Frontend using jQuery, lot's of spaghetti code. 
I’m referring to *consuming* libraries, like Doctrine. I can’t imagine a lot of situations for annotations to add value in library code, but instead in user code to be consumed by libraries. Yes, if the library itself used it, it would be a BC break. 
Comments should not be used for processing and yet, in PHP, it's common to do that *because* the language doesn't have proper annotations. This does nothing but solve a problem that already exists. You should be able to strip all the comments from a piece of software and have it still work -- that's not true for PHP code. I don't see why anyone would be against formalizing something in the language that has been used by the PHP community in a poorer form a decade. 
My only complaint with this is the use of stringy bits in the API. We shouldn't be using more strings for "class", "function", etc. 
&gt; You should be able to strip all the comments from a piece of software and have it still work -- that's not true for PHP code. That's like saying you should be able to delete all metadata from an application and it still work. 
&gt; I am a very strong believer that comments should not change runtime behavior I used to strongly believe that... until I started using annotations in Symfony. I got over it really quickly when I saw the light about how spectacularly useful annotations are. Annotations are a standardized format. They don't look like comments, even though they're in a comment block. It ends up working really well.
That's the point. We shouldn't be storing meta-data in comments. Annotations would put the meta data in code. 
This is a library I wrote a couple years ago and am excited to share with you. It wraps around PHP's poorly documented OpenSSL extension and makes encrypting and decrypting data fairly easy. Please share any constructive criticism. Thank you for looking. =)
And putting them in code would be a massive backwards compatibility break, and couldn't be polyfilled... so I say again, what is the real benefit?
Not necessarily, it is moving the annotations from a doc-block to regular "code." Doctrine can, and likely will, provide it's own wrapper functions, both for ease of use and backwards compatibility.
Strongly typed though? hmm?
Wouldn't the same happen if `@` didn't have an existing meaning? Non-comment annotations are obviously a breaking change.
Yes, anything along this lines would be a breaking change, and as it would only serve to duplicate existing de-facto standard mechanisms, it has a significantly higher barrier for "worth it". Due to the backwards compatibility issues, IMO uptake would be glacial to say the least. You'd be looking at at least a couple of years after it made it to core, and assuming PHP 8.0 that would probably be sometime around 2023. 
With that argument we should never change the language at all. If you write a library that uses new features, just put the appropriate version of PHP as your minimum requirement in your package.json. There have been less useful breaking changes like the new array notation. So, there will be other new features in the next version (personally I'm hoping for arrow functions), and it's quite likely that these will be used (and break BC) a lot more by libraries than annotations.
Yes, this is what I mean by the model has no integrity, with the mapper everything is mapped to methods and there's no ambiguity :) 
No... the argument is that the barrier for such changes is much higher, as it ultimately doesn't offer anything that isn't already standardised. 
This doesn't just "serve to duplicate existing de-facto standard mechanisms", it makes the existing mechanisms a lot more efficient. Parsing annotations on the engine level is way better than having to parse them yourself. Also, this would be a nice change for PHP 8.0. Just look at the adoption for e. g. strict types - yeah, it took a couple of years, but now we can pretty much rely on them.
I think that having metadata in code instead of comments is a good enough reason, and it's not like anyone is forcing people to use it. If you write a library and you need annotations for some reason (honestly can't think of many reasons why libraries would need them at all, they are almost exclusively used for convenience) then you can still choose between using the new standard and requiring whatever PHP version this would be in, or using the old Symfony style and requiring symfony/annotations in your package json.
Perhaps I'm mistaken, but you seem to have a different definition of backwards incompatible than others. This addition wouldn't be backwards incompatible with an _existing_ PHP application. It is a new syntax, just like short-arrays were in 5.4, null coalesce operator in 7.0, etc. PHP's long-time goal is to avoid breaking changes in existing code. If an application or library chooses to require this syntax, they are requiring a minimum version of PHP to be supported. That's pretty commonplace in this ecosystem already, nothing really new here. It comes with the typical trade-offs of onboarding and support. If a library you use decides to use this syntax, but you haven't upgraded PHP yet, you have options.
Not sure I follow. What would you replace them with? The purpose of those is exactly a string literal - defining what type(s) the annotation can, well, annotate. For example: @Annotation @Target("class") // This annotation can only annotate classes class ExampleClassAnnotation { // ... } @ExampleClassAnnotation // GOOD class ExampleAnnotatedClass { @ExampleClassAnnotation // BAD, FATAL ERROR - cannot annotate method public function foo() { } }
My background is primarily Java so that tends to show in my code.
It's not a backwards compatability break. If this shipped in 8.1, it wouldn't stop existing 7.2 code from working on 8.1. Code written to run on 8.1, that used this feature, wouldn't work on 7.2, but what of it? That's what version numbers mean. Adding the null coalesce operator in 7.0 wasn't a backwards compatibility break, because it didn't break existing code.
&gt;I am a very strong believer that comments should not change runtime behavior, and deal with the suggested configuration of e.g. Doctrine with deep regret. I feel the same way. I really dislike the current way annotations are shoehorned in. This does solve that issue, which is the one thing I like about it.
You keep saying that but I'd really like you to explain how this would break BC? I don't think you're using that term correctly.
It wouldn't be valid in this context (body of a class) so the parser should be able to differentiate if it's given a second meaning.
A few days ago I had to update an old library of ours to use OpenSSL for AES encryption since Mcrypt got removed in 7.2. It was a nightmare to update it but I'm glad we did because the old library was using ECB to match MySQL's baked in AES_ENCRYPT functions (MySQL used to only offer AES-128-ECB for its built in functions). Needless to say I wrote a conversion script to pull all the encrypted data from the database and re-encrypt it with AES-256-CBC-HMAC-SHA256 (we're not using MySQL's encryption functions anymore anyways). It's just ridiculous that PHPs documentation on the OpenSSL library is so poor because I had to cross reference everything against reputable PHP libraries to make sure my IVs and HMAC hashes were being implemented correctly.
It's almost like notepad is a text editor.
yeah-yeah, cheating I know \^\_\^
I think he means define constants like TARGET_CLASS so that, for instance, you could start typing TAR and an ide could suggest values 
Perhaps it's not the best choice of language on my part. Let me clarify - There is an existing de-facto standard for using annotations for classes, functions and so forth. That standard, according to packagist, has over a thousand dependent packages, and close to 85 million installs - It's obviously well established. Based heavily on the examples given in this RFC, the writer seems to suggest a lot of things such as hints to IDEs should be given their own syntax inside the code, this would obviously be incompatible with previous versions of PHP, no big surprise there, but it does it in such a way that completely ignores the long established, well refined, and widely used mechanism for doing so. It would be more apt to say that it would almost force a BC break on the libraries and softwares which use the current de-facto standard, unless, of course, they completely ignored it and continued using docblock comments, at which point the feature barely seems worth the time for the internals team to implement. It seems to me, the most effective use of the resources would be to add the current mechanism to the core and add it to reflection. I'm not sure why we need new syntax for it when there's a whole ecosystem built around an existing method. It just seems extremely unnecessary to pluck it out and put it somewhere else. Don't get me wrong, I'd love to see annotation information in reflection without the need for user level parsing, but I feel this would be somewhat re-inventing the wheel and not getting anything else from it. 
Wait, is there any non-html web page?
Been doing this for years for straight html. My more recent web pages are Php and for that I use vim. 
I think - no :), a browser can display information in another extension, but it's rendering only the html output.
It would *not* cause those libraries to stop working - they would function fine and could continue to choose not to use this standard. Your issues here are valid concerns, but they are not a BC break.
Can we catch up in room 11 on stackoverflow ? Writing several essays here is probably not the best way to communicate with you about this.
InfluxDB with self made [helper class](https://github.com/tuupola/instrument) to send the data. Grafana for dashboards. Telegraf to send non PHP related telemetry data such as io, memory, load etc.
The problem is that you compared two different algorithms. 
Not so many differences from Java annotations. The only I don’t like is a having plain strings for targets. I think constants are more reliable here. E.g. @Target(Annotation.CLASS) vs @Target(“class”).
So....it’s Cakewalk?
It's quite a lot like Python. e.g. this routing code from the flask project @app.route("/") def hello(): return "Hello World!" 
It can ... but you should think very very carefully about how you use threads within a web server as mentioned in tangent on blog post ... while the example given in the blog may seem extreme, or even irrelevant to what you're doing, it still requires careful thought and consideration.
Looks a fucking mess that’s for sure
You should also setup one time lint commands, so you can run on demand. We don’t bother with IDE plugins as you end up with masses off them and eventually slows down, so we just learn how to do it, then use git hooks to prevent pushing unless it passes 
New Relic has a really good profiler for external calls to database and outside HTTP(s) stuff.
Not an argument, It's an observation. The PHP community seems longing for features available in Java: Generics, Annotations, Type safety, people are even crazy about that poor thread support in PHP and then there is Symfony and that ORM which is clearly more than just inspired by Spring and Hibernate.
I don't really get the whole point / purpose of annotations. Why not write it inside "proper" code? What are they really good for? I don't even think they improve the readability or flow of the code, instead they add another layer of complexity without any gains. &amp;#x200B; I hope this RFC won't pass.
If you just need the data and not an instance of a Model, then you shouldn’t have been using Eloquent in the first place 😂 so it’s a good job you decided not to, it wasn’t intended to be used like that
As far as I know generics and annotations are available on every single major object oriented language. Doctrine is a data mapper implementation. Data mapper ORMs are available everywhere, even Ecto on Elixir, which is a pure function language, is mostly a data mapper.
So basically “I don’t understand this and don’t want to take the time to understand it so nobody should have this feature” ? Is that the argument you’re making?
Test command is a part of the real production application, so it needs some time to rewrite before publishing.
Some of my clients have asked for features and intergrations that WordPress can't handle without faffing to make fit. I've heard good things about Larvel and was wondering if that's a good next step? &amp;#x200B; My sites usuall include a custom page builder(ACF fields), and a form builder so if and framework has these sorts of features let me know. &amp;#x200B; &amp;#x200B;
&gt;Are you sure you installed and enabled phpiredis correctly? Yes, because I've put die('called') in the \`Predis\\Connection\\PhpiredisStreamConnection\` class, to make sure it was called. Also, I've checked installed extension via \`php -m | grep phpiredis\`
&gt;It's technically less portable because the output is not compatible with the default serialization I hate PHP's default serialization :) Its not readable anyway, so I prefer the binary serialization.
This comparison feels extremely on point. Oh and I got a friend who produces tracks using FL studio and they sound absolutely amazing.
This isn't internals, last I checked. Also I can see the RFC fine, so it must be publicly viewable for people outside of internals and I don't think it's fair to expect people not to post it anywhere if it's on the internet for everyone to see.
So what?
Ah, interesting. Thanks for sharing! &amp;#x200B; I thought that was detail not-relevant to the proposal. I wish there were diffs instead of long texts.
Annotations don't enable the programmer to do anything that they couldn't already do in the application code (ignoring faux annotations via docblocks here, as I consider them the same as real annotations). So, it's understandably confusing why some programmers want them in the language. And when this point is brought up, the conversation usually turns to a loop of "here's how I would use annotations" followed by "here's how you can do that without annotations" over and over. At the end of the day, I think annotations are semi-popular because of the perceived convenience and benefits of information locality. I could write a novella on how this locality is actually a trap, but suffice it to say that it's better for the long-term success of your code to separate its concerns, rather than abusing this locality to keep things "at your fingertips", so to speak. I'm also not a fan of the tendency for custom annotations to introduce confusing semantics into the application (usually for perceived brevity), where comparable "real code" alternatives can be more self-descriptive.
I'd also recommend using Grumphp. It will run tools like PHP Codesniffer and Mess Detector when you attempt to push a new commit.
It's all about how you use the tools you have.
I really want them, but most important, that method parameter can have annotation. Real-life usage: &amp;#x200B; \`\`\` // Symfony controller &amp;#x200B; public function listDirectory(@Inject('gaugrette.my\_filesystem') FileSystemInterface $fs) \`\`\` &amp;#x200B; The reason is that sometimes there are multiple services implementing the same interface; when this happens, Symfony can't know which one to inject so developer have to resort to yaml file, CompilerPass or similar. With annotation like in this example, programmer can specify which one is wanted and is locally specifed, not in other files. &amp;#x200B; Other advantage could be injection of tagged services: &amp;#x200B; \`\`\` public function \_\_construct(@Tagged('app.my\_tag') array $taggedServices) \`\`\` &amp;#x200B; &amp;#x200B;
"Please show some restraint." ["I want it now."](https://youtu.be/2zcVnNwAHys?t=61) 
Love that video, and you make a good point in a funny way, but I understood it the first time around. What I'm saying is that I think it's unreasonable to expect this sort of thing to be up on the public internet, and then tell people that it shouldn't have been posted when someone posts it on Reddit. If people don't want this posted, why not hide it? I mean I understand that this RFC may be in a stage where Michał is not ready for this to be critiqued, and even that he doesn't want people posting it everywhere, it's just that I think that posting it on the internet publicly sends the opposite message. It's not like the RFC site was built by people who don't have the chops to hide posts from people who aren't logged in, and I fully expect them to have enough common sense to realize that an RFC will be seen if you put it up publicly, and that it's out of their control where it gets posted.
Bro do you even php
Really not a fan of annotations, but having them as a legit language feature would certainly be better than just stuffing them in comment blocks.
It is readable, just not pretty.
Can you share your benchmark? It doesn't mean anything unless others can replicate it or verify it.
Honestly - how is the first example better than just hinting the class I want directly? It's basically what you are already doing, just in a more roundabout way.
"I was staring at that person in their bedroom because the curtains weren't drawn. If somebody wants privacy they shouldn't have had the curtains open." Just because you're able to access something doesn't mean that you should access it. And even if you get access to it, you don't have to distribute it or comment on it. &gt; It's not like the RFC site was built by people who don't have the chops to hide posts from people who aren't logged in, There's a trade-off. It's better for the RFC process to be open and for the RFC site to be easy to use, in particular some RFCs should be reviewed by people in the userland communities (e.g. Symfony, Laravel Docrtine etc) who don't have php.net logins. 
I’m writing a workflow type design tool, the end result of which is generated php code which will be executed but may also be worked in further by the development team, Coming from a C# background, attributes would seem a natural fit for typing generated methods to ids within the design tool, and to communicate when they have been altered (so cannot then be updated by the tool). Given this is an RFC, so won’t be available for a while, what are the alternatives you guys mention in the “nothing that can’t be done a different way”? I was thinking maybe a &lt;methodname&gt;_info() method that returns the info? Any other thoughts? 
Add this to top of your x.php file ini_set('display_errors', 1); ini_set('display_startup_errors', 1); error_reporting(E_ALL); Should do the trick. 
Thanks a lot! worked like a charm!
This isn't like leaving your curtains open and getting upset at people for staring at you through your bedroom window. It's like leaving a magazine in the breakroom and getting upset at people for reading it. &gt; It's better for the RFC process to be open and for the RFC site to be easy to use, in particular some RFCs should be reviewed by people in the userland communities (e.g. Symfony, Laravel Docrtine etc) who don't have php.net logins. Look, either the process is open to review by the community, or people can't post or comment on it. You can't have it both ways. Again, this isn't internals. You are here on Reddit telling people not post something that doesn't break either Reddit's rules or this subreddit's rules/guidelines but since you are not a mod of this sub, that's not a demand that's up to you to make. If internals don't like it, they need to come up with a set of rules that's enforceable.
Sometimes multiple services will have same interface, even **same class**. Yes, it is totally possible in Symfony and is a great thing to have when you need it. Gaufrette is most used example of that situation but I have seen others. &amp;#x200B; Let's say you want 2 different folders on local filesystem to have 2 services to manipulate them. In reality, both services will have **same class**. If it was Amazon S3 adapter; sure, you will get different class but same interface. But not when you have 2 local dirs or 2 Amazon storages or 2 FTP servers etc... That is why you can't just typehint the class, it is not enough information. The great thing is with service, you can do decoration in case you need it, maybe change config with compiler pass based on some param or environment... Pretty powerful advanced stuff that I use very often but always have to resort to yaml. &amp;#x200B; Note: To point one thing; it is completelly irrelevant if Gaufrette (and other bundles) use 1 class that is configured via adapter. That doesn't change the fact that typehinting param is sometimes not enough. &amp;#x200B; &amp;#x200B;
Okay, but I want expand that and talk about what they're actually being discussed for on internals, and that's control over JIT targeted at PHP 8. JIT is mean to be quite transparent, however, there will be cases where specific tweeks are required, such as if a function, for some reason, performs particularly bad or causes an error. Consider if one of these functions was in a major framework, Symfony, Doctrine, something like that. If using docblock based annotations (by the compiler parsing them), they would effectively be transparent to anything which did not understand them. Thus, the framework could add the annotations to disable JIT, or do something in particular with it, while still maintaining compatibility with previous versions (Symfony for example supports 7.1+). If new annotation syntax is added, that library can no longer be used with previous versions of PHP, because they're no longer transparent. If annotations had been added 6 or 7 years back, before the release of 7.0, I would have been all for it, they would be the established ecosystem, 5.6 would be still be dead, and everything would support them. Instead, what looks to be important mechanisms for controlling JIT, things which are completely irrelevant to previous versions, but which would otherwise be transparent, will instead cause compile-time parser errors. That's quite a cost. My view of this still stands, annotations would have been great, if they were added half a decade ago. But now, IMO, docbloc annotations, parsed during loading the script, make a lot more sense. If they did want to use in-code annotations, they would, IMO, need to add the syntax parsing for them right now in 7.3, and maybe even backport it to 7.2 (because a lot of people are holding back while 7.3 is fixed up), to maximize the number of versions that, at the very least, won't error out upon encountering the new syntax. 
You could output the php configuration by calling phpinfo() in your script and seeing which .ini file is parsed. Should be something like /etc/php.ini. You can then edit that file with the settings detailed above. 
Thanks for share my repo! 
1. layers not really have to be separated via namespaces. Layers should be visible in terms of dependencies, not directory structure. 2. It is much better to have directory structure based on features/bounded contexts, rather than technical aspects (yes, this is much easier in terms of creating boilerplate, but what the point of saying that it is DDD if you ignore DDD part). 3. Having directory structure based fully on technical aspects of your system creates unneeded coupling between modules (because in PHP module = namespace). So in short, the rule of thumb to develop good to use directory structure for your project is "place things that change together in same module". This way you will have higher cohesion. p.s. The whole idea of having DDD boilerplate is weird to me. "DDD is about the journey, not the destination".
That wasn't always the case, and also Java didn't invent them. PHP always did pick features from other ecosystems. Java is undeniably a huge influence. And doctrine shares more than the type of its nature with hibernate. At least the Germany Wikipedia page is stating that. Also I remember code in that space (Symfony, Doctrine) where even the comments where an exact copy of the Java original, I think it was Bean validation. Sorry that I'm so vague, but my memory is not too well with these old facts.
I don't have write access to that file
and I'm new to ubuntu so don't know how to gain access &amp;#x200B;
You're welcome! It helped me define layers in ways I didn't even think about in my DDD learning journey. 
Sorry, that's how the Internet works. PHP internals isn't in charge of whether a link to a public RFC is shared on Reddit. 
We need enums.
You could use your same argument exactly for namespaces in PHP. There was already a de-facto standard for them, the same incompatibilities, etc. "I'm not sure why we need new syntax for it when there's a whole ecosystem built around an existing, well tested method." In a sense, your argument could be used for almost every new syntax feature in PHP. 
Namespaces were not designed to be transparent, they had a lot of user-level functional changes to them, hierarchies, local scoped functions, things like that.
Very nice summary. In my experience, with PhpStorm you're best off with they key-naming approach because that will be shown directly in the test output runner. Another protip not many people know : you can use multiple data provider sources for a test. 
You're right, I didn't actually realize that before. Someone just responded to the post with a similar comment, I've updated the post to reflect this newfound knowledge, thanks!
try the sudo command
Awesome! Internet is wonderful 
Completely forgot to address the latter point. Also didn’t realize that (damn, was just starting to think I knew this stuff), but thinking of it, I guess it makes sense. Not sure if that would aid readability though. If you were to use two data providers with, let’s say, thee test cases each and the second test case of the second data provider fails, how would that be reported (if not explicitly named)? Dataset #4, or dataset #1 with the name of the second data provider? (Not in a position to test right away, but it sparked my interest)
My 2 cents: &amp;#x200B; \- multiple data providers for one method grouped category (e.g. provideUserData(), provideAdminData() etc.) \- \`yield\` over \`return array\` - less nesting for all items + reusable variables
Mathematically they solve the same problem The point is that the Rubix \*implementation\* is faster
Following contains nice examples of different architectures (MVC, Service Layer, DDD, Clean Architecture). It also summarizes their comparison, but you'll need to use translate if you can't read French. [https://jolicode.com/blog/notre-retour-du-symfony-live-2018](https://jolicode.com/blog/notre-retour-du-symfony-live-2018) Just click on titles, they lead to github repos with code.
If you don't separate by folder nor naming convention, difference between domain and technical layer will be really difficult to spot. Dev team will inevitably start to totally mix them up, because you can't easily tell what type of the class you are looking at in the first place. But this is general problem with DDD designes - nobody knows where boundary of business part stops and technical part starts.
First point makes sense, especially when handling a large number of test cases, second one I’m still considering if I would personally prefer it over arrays. It does decrease the level of nesting by one, but introduces a keyword for every test case. I’d say that variables are just as reusable for arrays as for generators. I’ll probably make up my mind soon 😉 Thanks for the input!
&gt; they had a lot of user-level functional changes to them, hierarchies, local scoped functions, things like that. That's not really true. PHP namespaces are just glorified syntactic sugar for long prefixed class and function names. We got along just fine without them, I don't see any reason why we needed namespaces by your argument. also, user-created annotations have nothing to do with the JIT. 
&gt; I could write a novella on how this locality is actually a trap It seems to work pretty well in all the languages I've used with annotations. It seems pretty obvious that if you want to provide meta-data about classes and properties to libraries that attaching that meta data directly to the classes and properties makes the most sense. Clearly you can do with it. But if I'm adding a new property and I want to attach some meta data to it (say for my ORM) then I don't want to go to some other file/method to do that. 
I agree, but in PHP "::class" will give the class name as a string, so I think you can have it your way (if this is implemented)
&gt; PHP namespaces are just glorified syntactic sugar for long prefixed class and function names. Not quite, things in namespaces have different symbol lookup mechanics than things at global level. That's why putting \ before root namespace functions works as a micro-optimization, because being a fully qualified name, it skips the namespace-level check. &gt; user-created annotations have nothing to do with the JIT. The whole reason internals is considering adding annotations is because of JIT, which were seemingly already done by parsing a @jit doc-tag: https://externals.io/message/103903#104209 
1-2-3 -&gt; This structure isn't prefect. You've to try, fail and adapt to your needs. It works for me and the teams I worked in last 3 years, but it's a silver bullet ;). "The whole idea of having DDD boilerplate is weird to me" And to me also. I was just a quick way to start new personal projects. I think people don't use it like it is but take some ideas from it. "Not scalable" Why? You can split team by bounded context. I worked in companies with a monorepo like this with more than 80 devs and worked quite well. 
&gt; will be really difficult to spot. My point is that this difference comes from the responsibilities of a class and class name should show this responsibility clearly. &gt; But this is general problem with DDD designs - nobody knows where boundary of business part stops and technical part starts. The problem even worse because nobody knows the boundaries of your buisness parts, separation of concern on a business/technical level is the easy part. 
But this is PHP. You mentioned this project is strongly typed. I'm confused.
&gt; Not quite, things in namespaces have different symbol lookup mechanics than things at global level. PHP resolves all the namespaces to their fully qualified name at parse time (on a per-file basis) and then just runs the code as it would if all those names where just underscores instead of backslashes. The only exception is global functions get a global lookup for backwards compatibility and that's why that micro-optimization does anything. Ironically, if we never had namespaces we wouldn't need that micro-optimization either. So another point for no namespaces. &gt; The whole reason internals is considering adding annotations is because of JIT, which were seemingly already done by parsing a @jit doc-tag: Interesting. Well technically they could continue parsing doc-tags just like all PHP user-code does. It doesn't require or not require annotations any more than any other code so it's pretty moot for this discussion. If doc-tags suck for that, then they also suck for everything else. If they're fine for that, they're fine for everything else. 
This is seriously awesome. For anyone who's not using AMP or Promise patterns in PHP yet, you should really start looking into it. PHP was one of the first to implement \`Generator\`s, which means you can even do something like the \`async/await\` pattern in JavaScript, so long as you pass your promises back up to an AMP coroutine. e.g. if I want to write code that reads like synchronous code, and does something that could update files, then check if it did, it's as easy as: public function doSomething(): Generator { $watcher = new FileChangesWatcher($this-&gt;myDirectory); $this-&gt;doSomethingThatMightChangeFiles(); if (yield $watcher-&gt;compare()) { return 'The files changed!'; } return 'It didn't update the files!'; } The more good libs we can get supporting async, the better. 
oh hellll yes. also structs
&gt; Dataset #4, or dataset #1 Dataset #4
Sure classes have a static property which contains name of the class as a string. But how is it related to annotations?
Check out the VLD opcode view on https://3v4l.org Compare the following: ```php namespace a { function hello() { echo "hello from a\n"; } } namespace { \a\hello(); } ``` and ```php namespace { function hello() { echo "hello from root\n"; } } namespace a { hello(); } ``` You'll see the first version, being full qualified, uses INIT_NS_FCALL_BY_NAME where as the second version, being fully qualified, uses INIT_FCALL with the exact name. ```php namespace a { function hello() { echo "hello from root\n"; } hello(); \a\hello(); } ``` Even within the same namespace it uses the INIT_NS_FCALL_BY_NAME opcode unless you make it fully qualified \a\hello();
I have a pen and I have an apple. What can i do with these? 
That doesnt solve the problem. I've seen the docs. My point still stands they are confusing as hell.
I appreciate the effort here but it doesn't change what I'm saying. You'll notice that in opcodes both calls to "hello()" are prefixed with the namespace. Because at parse time, PHP applies the namespace to all the calls. The INIT_NS_FCALL_BY_NAME basically says if this function doesn't exist (fully qualified) then strip the namespace and try it as a global function. You'll notice that nested namespaces with hierarchical lookup doesn't work in PHP like it does in Java, C#, or C++. Because PHP namespaces are pretty simplistic and is just basically doing text replacement. It's not that much more complicated than prefixing everything with underscores -- it's syntactic sugar to save you from typing. This is also why the namespace character could not be "::" with unified lookup between classes and namespaces (again, like other languages). To get to the point I'm making, namespaces have some minor syntactic and usability improvements that PHP make PHP better. Annotations are the same thing. Take something that is a pretty nasty convention (whether it be metadata in comments or underscores for namespacing) and put it into the language properly. This is progress. It's not consistent to be for namespaces but against proper annotations. 
awww hell no.
We'll see how it ends up, I plan to continue to follow the discussions about it on internals. Based on it previously having 60% voting against it, I'd say at this point it's still unlikely to happen. If they do add it, I simply hope they get it added as soon as possible, IMO it would be best if it was backported to 7.3, and definitely 7.4, even if JIT doesn't end up in 7.4, the longer versions are released without the syntax throwing a parser error, the less pain will be experienced when it's finally used for triggering things in the virtual machine. If they're going to add things which effect how userland code performs, I'd still like to see those as keywords (or declares), as there should be a solid expectation of them throwing a compile error if the VM cannot meet their expectations.
Implementation of different algorithm (yes, improved, but still different). Naive implementation of KNN has very similar predict time. But KDN is faster in RubixML (which php-ml don't have) :+1: Also for benchmarks I recommend phpbench with \`--retry-threshold\` that can improve the stability of benchmarks. [https://github.com/phpbench/phpbench](https://github.com/phpbench/phpbench) 
I don't expect it to pass either. PHP development is mostly conservative with occasional spikes of intense new stuff. But I really wouldn't expect new keywords.
Which one?
&gt; but introduces a keyword for every test case What does that exactly mean? &gt; I’ll probably make up my mind soon 😉 There no better way than to just try it :) It's a matter of seconds with Rector: - [return array to yield](https://github.com/rectorphp/rector/blob/master/docs/AllRectorsOverview.md#yieldclassmethodtoarrayclassmethodrector) And go back if you don't like it: - [yield to return array](https://github.com/rectorphp/rector/blob/master/docs/AllRectorsOverview.md#returnarrayclassmethodtoyieldrector) I migrated this way over 150 test cases in ~30 seconds and never went back :)
Pineapple Pen
This is pretty neat! If you don't mind me asking, what technology did you use to make repeated two-way trips between the 2019 and 1994? I have some questions for Milton Friedman I'd love answered.
This is the author: [https://twitter.com/el\_stoffel](https://twitter.com/el_stoffel)
Ah, thanks! I'll forward my questions to him, as based solely on the picture it's clear he's a time traveler.
Crazy stuff... So... About that warframe wiki...
So out of curiosity, this presupposes a looping or otherwise continuously running PHP process, yes? Meaning that async/promises don't have much use in a single request -&gt; response situation, as they're really just blocking at that point (i.e., the response is going to be dependent on the resolution). Or am I misunderstanding the use case? Thanks for any info.
Yea, it was PHP 7.1. You can instantly upgrade [99 % of cases with Rector](https://github.com/rectorphp/rector/blob/2e62d080f4a853e84e2b17bff246d579a9663dcd/config/level/php/php71.yaml#L8) though.
Agreed. [Machine implementation](https://github.com/rectorphp/rector/pull/1056) in progress...
Oh they totally work on a single request too. I have many routes mapped by Slim that put a single coroutine at the very top level. Eg if I make 5 API requests pulling from a paginated page loader, one call to analytics, and then a bunch of db calls, I can start all my api requests that have no dependency to run in the background while I query my db. So if my queries took 200ms and my api calls take 200ms, the whole thing is 200ms instead of 400ms if I did them in serial. So yeah eventually one will block, but it'll bottleneck on the slowest one instead of being as slow as all of them put together. It makes it easy to do the dependencies too, since it's likely that some queries will need to run after the API, but some don't. 
Yeah I wasn't trying to imply they were the same algorithm In fact I was purposely stating that they weren't in response to OP's question about the difference between our libraries In either case, I'm glad you're part of this discussion Let me know if you ever want to work on a feature together
&gt;Oh nice! I was looking at all the comparisons and didn't even notice that each language has its own details page. Thank you!
This is rad, thanks!
Then you would just use a previous version of the library. Like you do *any time* a library implements a new PHP feature. Your argument is literally against any new development in PHP whatsoever - do you not see that?
Strong typing is nice because a class, method, or function will tell you *exactly* what it needs to do its job. That was one of the goals of this library.
Why did you have to match MySQL's AES\_ENCRYPT functions? This sounds like a fun story. &amp;#x200B; Yes, it sucks that the documentation sucks. It looks like it has gotten a lot better since this library was written. The documentation used to just be parameter names and not much else. It was embarrassingly bad.
Yes, it sucks that the documentation sucks. It looks like it has gotten a lot better since this library was written. The documentation used to just be parameter names and not much else. It was embarrassingly bad.
Oh cool, that does make sense, I hadn't thought of that approach. Thanks for the reply!
If I understand your original comment correctly you want to be able to write a contant instead of a string when referencing a class. What I am saying is that currently you can use the static "class" property (which is essentially a constant) in place of a string for the class. I don't see how this would be different in the case of annotations.
Good style! You can now automate all this hard work [with Rector](https://github.com/rectorphp/rector/pull/1056). I've added this rule today
Not sure what you're talking about, the connection is global (well, in the DI container), generally. Also nothing stopping you from using a repository object to wrap the model
To add onto this, the Eloquent query builder is pretty awesome if you don't need the model objects. I hate writing SQL, feels much nicer with the query builder.
https://github.com/tagadvance/Elephant-Encryption/blob/master/src/tagadvance/elephant/cryptography/Base64Cryptographer.php Base64 isn't cryptographic. https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded
What exactly are you requesting?
I didn't write the original library that was being used, so I can't really say exactly what the thought process was. But I believe at the time all database INSERT/UPDATE queries that contained fields needing encrypted were encrypted via Mcrypt (I think so the PDO wrapper would accept an array or object for INSERT/UPDATE). But when SELECT-ing the encrypted column data, MySQL's native AES\_DECRYPT functions were used in the query strings. So at the time, Mcrypt was used for input, and MySQL's AES\_DECRYPT was used for output. Eventually the codebase was updated to let the models handle encrypt/decrypt and bypass the MySQL functions, but the encryption cipher was never updated (\*facepalm\*). 
&gt; Also nothing stopping you from using a repository object to wrap the model and return what? AR models with a database connection in them? or some other model that's *not AR*
The database connection is external to the model. I'm not sure what your argument is honestly. Maybe you misunderstand how Eloquent works?
Strong typing is nice because a class, method, or function will tell you ~~exactly~~ what it needs to do its job. That was one of the goals of this library. Types aren't enough to make a program valid, even less in dynamic ones.
Penapple
Any example of that API code somewhere for reference ? IS it internal or external api we are talking about ? Even more interested in Symfony/Laravel ?
No, you can't. It's called **Active** Record for a reason. If you try to abstract away with repos then you cannot return the Eloquent models, at which point you might as well not use Eloquent.
Yeah, you can. Accept as input and/or return POPOs or arrays or Laravel Collections. The Eloquent-y models can be fully internal to the repositories.
So map objects to your eloquent models? Like a data mapper? What is the point of using Eloquent?
Because it makes writing the queries super easy and you can bind events, really easy to muck around with in CLI with tinker, built-in migrations, first-party support in Laravel, etc. So many reasons.
Google: DQL, Doctrine Events, Doctrine Migrations You're building a custom data mapper, seemingly *because laravel*. I mean, you're literally telling me there's nothing wrong with Active Record, and then telling me the lengths you go to to hide it behind an ORM.
https://www.txstate.edu/philosophy/resources/fallacy-definitions/Faulty-Analogy.html
The learning curve for Doctrine is way bigger. This matters a lot when you're having junior devs work on the project. Lowering the amount of tools they need to use is a big deal. I know Doctrine can do all those things too, I never tried to imply it didn't. I'm saying that Eloquent has all the features I need, and therefore is the reason I use it. You're arguing that there's no reason to use Eloquent, but I'm saying yes there is because it has everything I need. I'm not really going to great lengths. I'm just having a repository class per concern of my domain code which has methods that do the DB read/writes via Eloquent. If we want to swap out the ORM, we can just swap out the implementation in those classes. No big deal. I still don't understand your arguments against active record in general, they all feel like [straw men](https://en.m.wikipedia.org/wiki/Straw_man).
Close your eyes immediately, delete browser history and go take a shower. Some internet dude told you so.
You are using Eloquent essentially to write SQL, and then building your own mapper inside repositories. IT DOES NOT DO EVERYTHING YOU NEED. /I give up. I mean, just from this convo a massive argument against AR is that you have to build a mapper to protect your code from it ...
It literally does though. If I used Doctrine for the repository part then it would literally be a project dependency... That I don't need. I'm trying to abstract away the DB. If I did it your way (if I'm understanding your argument) then I'm just straight up adding a dependency to my domain code. That makes no sense. Also, it's not "protecting my code", wtf did you get that from what I said? I'm just separating concerns. That's something that's almost always beneficial.
The domain model is separated by the mapper, it's as you yourself already said: the repo hides the implementation. It's exactly as you are doing it but you don't need the EXTRA step of Eloquent &lt;-&gt; POPO because the mapper already does that for you. If it's not protecting your code then why don't you return the Eloquent models? Why are they hidden? You will only hear what you want to.
Appreciate all your insights. Now I really need to find a way to get it :) 
Okay, I'll admit I was unclear on how Doctrine hooks into the models/repositories, hadn't read the docs in a very long time. I read the getting started guide, and all I'm seeing is additional complexity and 2-3x more code to do the same things I'm currently doing. - Models don't extend anything (which is good) but they need either annotations (which I hate, because I don't like comments driving behaviour) or XML mappings (which I also hate, because XML is gross) or YAML which is deprecated (which I also hate because it has so many ridiculous edgecases in parsing values) - There's a global EntityManager dependency which you have flying around (I guess this is normally managed by DI, but still kinda weird) - You need to run commands to update your schema mappings after changes (easy to forget, extra thing to worry about) - Repository classes extend EntityRepository which feels like it defeats the purpose of repositories, because now they have a dependency on Doctrine. Looks like the point of that is to get access to the EntityManager. Feels like that should just be an injected dependency instead. - The UnitOfWork stuff is something I'd never need in any of my apps. It's so rare that I ever have more than a small handful of DB operations to do at a time, and if I really needed, I could just wrap the `-&gt;save()` calls in a transaction. I could go on for hours as to why it's not a good fit for me but those are the standouts.
Or you can try this lib: https://github.com/antanas-arvasevicius/enumerable-type
Does it have benefits over `myclabs/php-enum`, or is this just NIH?
Thanks everyone for your feedback - I'll dig into this a little bit more.
(To save anyone a google, like I needed, NIH = Not Invented Here)
You are absolutely correct. That is a poorly named component. If you look at the constructor it can only be used when wrapped around another `Cryptographer`, which is what it was intended for.
A small clarification: all public interfaces should return a promise, not a generator :)
in the whole discussion there isn't a single valid argument why annotations are bad for the language. 
&gt;annotations (which I hate, because I don't like comments driving behaviour) How about global magic driving everything? Seriously, you have a problem with annotations but no problem with $obj-&gt;something() being magically intercepted and routed to a static call? You can't stand annotations explicitly mapping a &lt;-&gt; b but you're quite happy to have no mappings at all and not know if a join is going to overwrite a similarly named property on your "model"? EntityManager feels icky but who gives a fuck about the database being embedded into the very heart of your Domain Model. Oh, sorry, you do, which is why you're busy rebuilding the mapping bit so you can hide Eloquent away where it can't do any harm, and simultaneously denying that it's at all harmful. Laravel sells itself as a once size fits all, super scalable, magic pill that solves all your problems. In reality it's a pretty hacky framework that just comes with everything plugged in and turned on. Which, incidentally, is the opposite of the current trend to unplug everything and build the software you actually need. I wonder what the uptake would be like if Laravel also offered Doctrine as a first class citizen like Symfony did with Propel and Doctrine. I would put all my money on Eloquent being seen as the toy it is, and Doctrine recommended for any serious work.
A small clarification: all public interfaces should return a promise, not a generator :)
Yes, I'm okay with the magic because it has a very positive effect on my productivity. It's very clean and easy to reason about as a programmer. I rarely need joins because I can do `with()` which does a separate query to eager load the related data and hydrates those models. Because of that, I never run into issues with property overwrites. Again, the DB isn't embedded in the model. The model has a reference to the DB connection. That's different. Old implementations of AR (Yii 1.0 did this) had the model extend Database or whatever which is (now) obviously a terrible idea. That's not how Eloquent works. Also I never implied Eloquent being harmful. I've been saying separation of concerns. That in no way means harm. That means making components more easily swappable. Your points about Laravel are completely irrelevant to the conversation (and are largely untrue, but I'm not going to entertain a Symfony vs Laravel fight).
&gt; Yes, I'm okay with the magic because it has a very positive effect on my productivity. But you're not ok with mapping annotations because you're some kind of purist. &gt;Again, the DB isn't embedded in the model. The model has a reference to the DB connection. The connection is a resource, you can't have anything except a reference to it, I have no idea what you're saying. &gt;Also I never implied Eloquent being harmful. I've been saying separation of concerns. Why are you separating your **O**bjects from your **O**RM? This isn't separation of concerns, it's a strange way to use an ORM as a DAL.
I would go 1 step further for readability. Instead of having: /** * @return array[] */ public function sessionDataProvider(): array { return [ 'fresh-session' =&gt; [ 'session' =&gt; [], 'showLogin' =&gt; true, 'showUpgrade' =&gt; false, 'showPrimaryButton' =&gt; true, ], 'not-logged-in-subscription-unknown' =&gt; [ 'session' =&gt; ['loggedIn' =&gt; false], 'showLogin' =&gt; true, 'showUpgrade' =&gt; false, 'showPrimaryButton' =&gt; true, ], 'logged-in-pro-user' =&gt; [ 'session' =&gt; ['loggedIn' =&gt; true, 'subscriptionLevel' =&gt; Subscription::LEVEL_PRO], 'showLogin' =&gt; false, 'showUpgrade' =&gt; false, 'showPrimaryButton' =&gt; false, ], ]; } You can have: public function sessionDataProvider(): \Generator // You can import it to avoid the leading backslash { yield 'fresh session' =&gt; 'session' =&gt; [], 'showLogin' =&gt; true, 'showUpgrade' =&gt; false, 'showPrimaryButton' =&gt; true, ]; yield 'not logged in subscription unknown' =&gt; [ 'session' =&gt; ['loggedIn' =&gt; false], 'showLogin' =&gt; true, 'showUpgrade' =&gt; false, 'showPrimaryButton' =&gt; true, ]; yield 'logged in pro user' =&gt; [ 'session' =&gt; ['loggedIn' =&gt; true, 'subscriptionLevel' =&gt; Subscription::LEVEL_PRO], 'showLogin' =&gt; false, 'showUpgrade' =&gt; false, 'showPrimaryButton' =&gt; false, ]; }
&gt; because you're some kind of purist lmfao If https://wiki.php.net/rfc/annotations_v2 gets implemented I wouldn't mind it as much because it would actually be a native language feature instead of a reflection hack. &gt; I have no idea what you're saying I mean that the connection isn't owned by the model. See https://github.com/illuminate/database/blob/master/Eloquent/Model.php#L1245, the connections are managed in a pool, and the model just gets the connection object via the resolver. &gt; Why are you separating your Objects from your ORM? I was mostly giving that as an example as for a way to avoid tightly binding Eloquent to the business logic. To be clear, I don't use repositories for 100% of my DB access, just the parts where I need to abstract away domain code which might be transplanted into other projects at some point. The rest (i.e. user management, whatever CRUD to allow for a frontend) is just using it as-is. You also said: &gt;you're busy rebuilding the mapping bit That's implying an overestimation of the amount of work that is. It's just simple interface + class that wraps the actual access to the models. Nothing fancier than that.
&gt;Look, either the process is open to review by the community, or people can't post or comment on it. You can't have it both ways. Or you know, you can just try to expect better from people...
My problems with enums in userland: * PostStatus::DRAFT() === PostStatus::DRAFT() -&gt; false * if implementation caches enum instances to deal with the previous problem, it unfortunately won't work out of the box when unserializing such enum classes (a new instance will be created every time)
Doctrine's power is that once you've mastered it, you will have 100% separation of concern. And it makes it easier to add extra custom business logic into the right layer. It also makes code more reusable and easy to debug. I love the doctrine listeners system. It scales well. With a nice architecture, you can build your own custom layers. Adding a complex query filter is a one liner in our system. 90% of the time, you are doing a 'classic query even with a bunch of joins' or 'count query'. But to get there, it took me a few years on Doctrine practice. Not to mention I'm still discovering new hidden powers sometimes. &amp;#x200B; I read a lot about **Active Record pattern** whether it's from Ruby on Rails or Laravel and I was never impressed. If I've mastered a more powerful solution why go down to an easiest and less capable ? For speed ? I'm way faster in the long run. My velocity stays extremely high with Doctrine. &amp;#x200B; I've also come to appreciate the situations where you SHOULD NOT use any ORM.
BTW, there is one thing to know about PHPUnit's data providers that almost noone gets right: Data Providers are supposed to be \*\*static\*\*. There are all kinds of weird behaviours when they are not and for example they get called in setUp(). See this for reference: [https://stackoverflow.com/a/4262801](https://stackoverflow.com/a/4262801) It's also interesting to see that even in the PHPUnit docs this is not pointed out: [https://phpunit.de/manual/6.5/en/writing-tests-for-phpunit.html](https://phpunit.de/manual/6.5/en/writing-tests-for-phpunit.html) No wonder this is not commonly known.
That's not what I said. I even added a few arguments, e.g. worsening of code readability. You could have taken the opportunity and instead of replying with such a comment, told me the advantages of those annotations.
Great arguments for core support!
I guess my main problem with annotations is that I never saw a actually really good and useful example of them. I saw them used e.g. in PhpUnit for something like "@expectedException FooException", where you could also just simply use \`$this-&gt;expectException(FooException::class);\` in the beginning of the test method. On the other side, I often saw them used for validation purposes. Also quite easy and clear to just pass specific variables to a validator / whatever. It doesn't even save time to use those annotations and I also strongly doubt it improves code readability. Moreover, if everyone uses custom annotations, IDE support will also be much more difficult (if ever available for it, you would have to configure your custom annotations manually first in some project config), etc. So please, I'm really interested in seeing a good use-case for annotations and might even change my opinion about it. It's not that I'm 100% against them, but so far I never saw a good usage.
Maybe try https://github.com/Zul3s/enum-php . Look like myclabs implementation but using singleton. Si PostStatus::DRAFT() === PostStatus::DRAFT()
&gt; lmfao well not really sure what to say when you point at something sensible, call it a hack, and go back to using globals and magic everywhere, without any sense of irony. Annotations are compiled, so reflection is pretty irrelevant, and the one place they really do make sense is in config like mapping. &gt;I mean that the connection isn't owned by the model. It makes no difference. The model is tightly coupled to the db and the connection is able to be abused by anyone. It doesn't get more "in the middle" than that. &gt;I was mostly giving that as an example as for a way to avoid tightly binding Eloquent to the business logic. See ... tight binding/coupling. You have to go out of the way to decouple the model from the database despite using an ORM. This is crazy. I honestly can't understand why you keep saying the DB is not in the middle of the model and then literally saying they are tightly coupled. &gt;I need to abstract away domain code which might be transplanted into other projects at some point Not sure you understand what the Domain is now ... &gt; CRUD You can abuse Doctrine as a simple CRUD wrapper no problem at all, at least if you do that you are a step ahead in a refactor. &gt;interface + class that wraps the actual access to the models You say my thoughts on laravel are irrelevant, but here's another example. Why on earth would you have an interface for your model? It makes no sense ... seems to be a Laravel standard practice tho.
&gt;At this point it's time to stop and think. In an ideal world, we'd have built-in enums in PHP: &gt; &gt;enum PostStatus { DRAFT, PUBLISHED, ARCHIVED; } &amp;#x200B; Nope. In ideal world we would like string based enums, integer based enums, explicit integer based enums, exhaustive checks for if+else and switch. All that should also be compatible with discriminate unions (which are a single type where you always know which member type is held at a given time in a variable). &amp;#x200B; If by enum we just mean "guarantee of no more members" then it's very limited power. Add some of the above and that power skyrockets ;)
&gt; interface for your model? Repository interface. So that you can swap out the repository's implementation whenever. That's the point of interfaces. Has nothing to do with Laravel. Anyways, I'm done, this argument is hopeless, we're both too stubborn to agree on middleground.
I'm using this https://github.com/consistence/consistence/blob/master/docs/Enum/enums.md it has nice doctrine support.
Yeah, fixes the first problem, not the second though: $class = new SomeClass(); $class-&gt;enum = PostStatus::DRAFT(); $class_unserialized = unserialize(serialize($class)); var_dump($class-&gt;enum === $class_unserialized-&gt;enum); // false You'll have to add this to SomeClass: public function __wakeup() { $this-&gt;enum = PostStatus::byValue($this-&gt;enum-&gt;getValue()); } 
Thanks for the Monday morning chuckle.
&gt; middleground My point: Eloquent (AR) is bad because of the tight coupling and leaky DB. Your counter: Eloquent ORM has none of those properties as long as you stop using it as an ORM and just use it as a DAL inside a custom built ORM. I mean, I have to agree. But it's stupid.
Why would you make the \`const\`s private and use magic static calls instead of just doing: new PostStatus(PostStatus::DRAFT); That would solve all problems mentioned in the article. It just removes all the unneeded magic and required annotation support.
Absolutely right. There's also no actual need for enums when you think about it: everything can be solved with classes. To me, the question is not about how this problem can functionally be solved today, but rather which syntax could be added in the future, how the code would look and how writing that code can be improved.
because the exact same thing but in comments (so we are parsing **comments** for functional behavior) is not worse?
Why does php even have a multiplication operator? one could simply write a loop with additions instead! /s
https://dev.to/jorgecc/phpstorm-and-enumeration-that-works-onb Using a constant is not always recommended: For example (as explained in the blog) it could work. &gt; setWeather(Someclass:SUNNY); But what if Someclass has other constants. Adding one class per enum? We can't create a single class for only a constant, we are bloating our code!. Also, let's say that we don't use "using", so our code could look like: &gt; setWeather(space/somespace/Someclass:SUNNY); // not pretty. One alternative (that I already mentioned, because I like it, is to use PHPDoc and a plugin for PHPStorm called deep-assoc) &gt;/** &gt; * @param string $weather=['sunny','rainning','cloudy'][$i] &gt; */ &gt;function setWeather($weather) { &gt; //... &gt;} 
* Java = Maya * C# = Cinema4d. * PHP = Blender * Python = Poser * JavaScript = ZBrush (it's weird as f* but everybody use anyways). 
&gt;Slim does not include any built-in solution for interacting with **databases**. This is entirely up to the developer. this is pretty much what symfony is from version 4 and up. &amp;#x200B;
&gt;Years later, I heard about Symfony and tried to give the MVC world another chance. The concepts were quite familiar this time, but the framework was really huge and I kept thinking that a framework like that was really over-engineered for my humble needs. Not that I'm saying Slim is a poor choice at all, but this is a very inaccurate (or, rather, outdated) description of Symfony. Symfony as of Symfony 4 is a microframework and offers basically nothing outside of routing and a service container out of the box, _but_ it allows you to very easily expand it with additional components when (and if) you need them, using [Symfony Flex](https://symfony.com/doc/current/quick_tour/flex_recipes.html). &gt;Slim features the famous template engine Twig as rendering solution. However I feel perfectly comfortable and happy with PHP code in template files, so I always use the other alternative: the php-view rendering engine. I don’t feel like learning a new syntax to do things I am yet able to do… until I found a valid reason. That's fine and all, but I feel like you're choosing to ignore the historical reasons the PHP community collectively decided to use template engines in the first place, despite PHP itself having that functionality. One benefit of template engines is that they're significantly more concise than PHP code and offer specialized syntax for stuff you often need to do in templates, but most of all, they're _predictable_ in that they only let you do the small number of things you *should* be able to do in a template. I suppose if you're working solo this isn't a super big deal, but if you're working on a team, it's a pretty nice benefit to know that Twig (or whatever) won't let some junior dev stick a big glob of non-view-related logic in a template.
with two years of a dedicated 30 hours/week studying you can literally anything. 
I'm right there with you. I was rolling my own before any of the current frameworks existed. Something I was happy to get rid of once I found an alternative. I love the Symfony components but the framework makes too many decisions for my liking. I used Silex until they decided to abandon it and move to the micro kernel approach with Symfony. I gave it another go at that point but ended up moving on to Slim instead. Same basic experience that Silex gave me so hopefully they're not going away anytime soon.
About safety and isolation, Docker is not an alternative to a virtual machine. Docker is not for that. And of course, a Virtual Machine is not an alternative (+2000 customers). Protecting the database is trivial since you could restrict the permission per-use. However, protecting the files is not trivial. Let's say I am a customer and I want to upload some code. Can you restrict what it is used?. For example, let's say I upload the next code ``` eval('some code'); $fp=fopen('aaa'); echo "ok"; ``` you could censor some functions and convert it into: ``` \\ eval = nope \\ fopen = nope too. echo "ok"; ``` However, what if the customer over-use the system and resources?. ``` for($i=0;$i&lt;99999999999;$i++) { miningBitCoin(); } ``` 
I tried Slim but it was such a bad experience for me that I switched to using Laravel.
Java, C#, and Python have annotations, Its the time to PHP.
So what?. ``` @public() function example() { } ``` Could be interpreted as: ``` public(); function example() { } ```
The problem with the internet is even the most inexperienced can give their 2cents in the matter. By the quality of the content, is obvious the writer doesn't need any framework for the job he does, and even if he did, he lacks the experience to understand the difference between them to choose one over another.. &amp;#x200B; Medium should implement a 'downclap' so people can downvote all the shit thats posted there
Author of enumerable-type here. Hi, myclabs/php-enum uses "private const" to declare options my implementation uses "final public static function ", so, it depend on your preferences, my implementation is pure object oriented without any magic, so you are getting full autocomplete and refactoring tools on IDEs by default, no need extra comments to add. Also in php-enum: * you need to use ```equals()`` instead of regular `===` as in my implementation. * persisting into database you have only enum keys of string type and it's hard coupled with option name. * value object construction when you have only ID (e.g. when fetching data from database) is only possible by calling constructor e.g. "new Type(value_from_db)" so this will always create new object and some optimizations(caching) is not possible. * call to values() always creates a new array of objects so it's memory inefficient. * isValidKey() and isValid() - library differentiates between values and keys, and it's not clear what is enum key? This design proposes that library users will use "enum keys" for some logics. Specifically my library forbids uses of any "key" like strings (to prevent future refactoring nightmares) and just operates on objects which can be only referenced by xxxEnum::Option1() Pros of my library: * enum options is objects, only one object per option. * comparison by object references * prohibits bad practices to use options as strings (no API for that, only fromId("key")), so before using enums if you have it's needed to always call ```fromId("key")``` first and work with objects not "keys" anymore. So methods like isValidKey, search, isValid, toArray, keys, becomes only redundant without need of real use. Cons of my library: * no native serialisation due PHP not allowing passing existing objects in deserialisation process. 
Anything that relies on your IDE+plugins with docbloc's to enforce type hints is just a no go for me. Despite docblocks ubiquitous nature, not everyone on your team uses the same IDE or plugins to enforce it.
&gt; However, what if the customer over-use the system and resources? You cannot limit this with a web hosting application like cpanel or ispconfig? But with docker it's easy, right?
Has the best practice stabilised around this yet? I can see it both ways - declaring every function with a `: Promise` followed by a coroutine function inside the body is really verbose. If my method's 3-4 lines already (as they often are), then I'm using over 50% of the method simply to declare it. It also ties that particular method to a specific Promises implementation. If I return `Generators` directly, I can leave it up to whatever caller's implemented `wait` or event loop to do that. You can also easily await other `Generator` returning methods, e.g. `$foo = yield from generatorThatGetsFoo();` Not sure one is straight up better than the other, and Promises in PHP are kind of the wild west right now. Ideally I'd extend `Traversable` with an interface so I know it's returning something I can use in a coroutine, but unfortunately you can't declare generators that return something that extends one of the allowable return types: php &gt; interface Awaitable extends Traversable {} php &gt; function bar(): Awaitable { yield 1; } Fatal error: Generators may only declare a return type of Generator, Iterator, Traversable, or iterable, Awaitable is not permitted in php shell code on line 1 So to me, `Generator` makes sense since I'd call something `Traversable`, `Iterator`, or `iterable` if it were a collection. I guess technically a coroutine is a collection of async things you can wait for though..
I aint buying into the idea of Annotations, but I will support this one 'cause at least it makes annotations a language feature rather than comments. Annotations in comments are abominations, native support for Annotations aint without flaws but are a least much better than the current userland alternatives. 
Python doesnt have annotations, these are called Decorators and they are vastly different. Javascript has the same Decorators concept in their latest versions. book.pythontips.com/en/latest/decorators.html
&gt;Has the best practice stabilised around this yet? I can see it both ways - declaring every function with a : Promise followed by a coroutine function inside the body is really verbose. If my method's 3-4 lines already (as they often are), then I'm using over 50% of the method simply to declare it. It also ties that particular method to a specific Promises implementation. If I return Generators directly, I can leave it up to whatever caller's implemented wait or event loop to do that. You can also easily await other Generator returning methods, e.g. $foo = yield from generatorThatGetsFoo(); &gt; &gt;Not sure one is straight up better than the other, and Promises in PHP are kind of the wild west right now. Ideally I'd extend Traversable with an interface so I know it's returning something I can use in a coroutine, but unfortunately you can't declare generators that return something that extends one of the allowable return types: [https://amphp.org/amp/coroutines/](https://amphp.org/amp/coroutines/) `Use Amp\call() to always return a promise instead of a \Generator from your public APIs. Generators are an implementation detail that shouldn’t be leaked to API consumers.` &amp;#x200B; &amp;#x200B;
Actually I think its about time to deprecate the error suppress operator and remove it in PHP 8. Its existence was a mistake to begin with, it does not help programmers write better code at all. If it is absolutely necessary, maybe a @suppress annotations at the top of a function/method to suppress all warnings within the function/method body is a good compromise. 
Interesting. I really wish the Short Closure Syntax will become part of PHP Core one day, at least before PHP 8. I plan to make an ORM like Entity Framework's fluent interface, which wont be easily doable without short closure: http://www.entityframeworktutorial.net/code-first/configure-entity-mappings-using-fluent-api.aspx
Its time for Go fanboys to accept that the hype for GoLang is not going to deliver, they can just chill out and face the truth that GoLang will stay as a specialized smaller programming language always. Really sick of all these posts telling people to use GoLang when it offers little to no practical benefits, especially advertising posts like this one. 
It so hard to relate to an article like this when it says things like this: &gt; I don’t feel like learning a new syntax to do things I am yet able to do… until I found a valid reason. &gt; For the same reason stated above, I don’t like to learn an ORM as Symfony suggests. How anyone in this industry can be resistant to learning something new, even something as standard as a templating engine and ORM, is so foreign to me. 
While Medium may lack a downclap, thankfully Reddit has a downvote - it's a feature that your comments seem very receptive of.
Weirdly enough it has been upvoted more than not.. But I understand you too had an urge to shit your 2cents in the internet.. 
I prefer to shit quarters.
I think the only good thing about Slim is the middleware. The benchmark is like 4 years old ... Symfony routing is way better now. &amp;#x200B; If you are interested PSR7 is not getting a lot of love and one of the reason big companies are stopping to follow the PSR.
When you are not also using mutation testing, then your test coverage is a lie. 
The reason is because in the arg typehint you're just typing `string` instead of something like `PostStatus` and it knowing that all those enums are considered `PostStatus` objects (instad of just strings) You *could* pass in "abcdef" as an argument and the interpreter would think it's all good to go. This leads to comments like `@var string The Post status. One of the PostStatus:: constants.` where simply saying `__construct(PostStatus postStatus)` would enforce a lot more
What you're talking about is similar (or the same) to something called "Event Projection" in CQRS. The idea is to push the same event to multiple recipients so that it can be handled by more than one system in more than one place with more than one language. The generally accepted way to handle event projection is to just dispatch the event to a single Event Store (say, RabbitMQ) and then have your recipients *subscribe* to the that Event Store. So rather than dispatching to 3+ different channels all at once, you only have to dispatch to a single channel. The advantage of this is that it decouples the domain that fires the event from those that rely on it. Rather than your code knowing *where* it's dispatching to, and needing to be changed when you want to add new recipients, the event dispatcher only needs to know **that an event happened**, which is the way it should be. It's only the concern of the recipients to know what events they're listening for. That being said, if you really want to dispatch to multiple channels, [SimpleBus](http://docs.simplebus.io/en/latest/Guides/message_recorder.html#combining-multiple-message-recorders) has a way of Aggregating event recorders, maybe that's what you're after
Docker is not completely isolated, it just a process running on the same host. Docker is not an alternative for a virtual machine (security). However, if you don't mind the security and you want to run different processes then you could run different threads of PHP (one per port), you don't even need nginx to do that (unless you want to use reverse proxy) neither docker. Since you have 2000 customers, let's say that you assign 200mb to each customer. So, you will need in total 200gb of ram, plus the overhead and 200mb are bare and it excludes mysql. 
I’m just saying purely aesthetically - least most IDE collapse comments 😂
I think the Laravel Event Bus is something to look at. It is based around events and (optionally) handlers.
\**furiously trying to horizontal scroll the textarea image*\*
I’ve worked with event-band, a project library of my friend, a few years ago. Its main purpose was to seamlessly integrate Symfony’s event dispatcher with RabbitMQ (and potentially other brokers as well) so that you could declare an event listener as a “parallel” listener (I don’t remember the exact lingo it used for this) and it would not be called in the same thread but instead a message would be sent to an appropriate exchange in Rabbit and, once you’ve started a consumer, it would be dispatched in the consumer just like a normal event. I must say this was way too inconvenient to use. The amount of configuration it required was quite a bit, to the point where doing things manually by calling basic_publish and so on would have been, if not easier then very similar at least. It also needlessly adds a few levels of indirection. The main issue with this though was inability to go from “caller site” in my IDE to the callee and vice versa. For that reason I was thinking about integrating AOP with Rabbit instead so you’d be able to directly call a method that is marked with fe `@RabbitSomething` annotation and an AOP pointcut would intervene and send a message to Rabbit exchange instead and interrupt the call to the method returning early, while in the consumer in another process, upon getting that message, this method would be called with the same arguments and all. This would make it easier to navigate through message-broker-assisted calls in the IDE.
Also, the test coverage metric alone does not speak to the quality of the tests. Much of the work that goes into good unit testing is spent towards good test writing. I also was interested to see that the gamification aspect was not mentioned except for the headline.
That's branch or line coverage?
Usually, I try to avoid inheritance and go for composition or extend an abstract class. &amp;#x200B; I am discussing a critical problem that arises with inheritance and traits using code samples. &amp;#x200B; Have you ever worked in a large project that used a lot of inheritance and the design got out of hands?
I hate configuring apps with arrays or YAML or some other shit. Give me an interface I can implement, let me configure my app with full autocompletion you bastards.
Frankly, I don't understand why anyone would have thought reimplementing PHP logic in config would be a good idea. One of my big irks about Symfony. To be fair, I've never given it a real chance; I've used Yii, then Laravel, and I'm pretty satisfied with it.
There is some mutation testing. The mock object "Canary" I made get [randomly generated](https://github.com/Divergence/framework/blob/daaf78aa4b10ad59bf52b9e31480c748ad82e8c3/tests/MockSite/Models/Canary.php#L175-L188) and they make use of every field type the ORM supports.
The gamification aspect is self evident once you setup your code coverage reports. The score goes up or down with every commit so that's the incentive. You're right though I should have written a blurb on it.
... isn't extending an abstract class considered inheritance though?
It's line coverage. What's in the gif is available to view here https://travis-ci.org/Divergence/framework/jobs/494493126#L667
Yeah, I understand how the coverage number going up is incentive. It's just a matter of making your point in a way that matches your headline. From your headline it sounded to me, as someone who writes unit tests, that you were using some additional approach to gamify what you were doing beyond the stuff that is core to the process - like the coverage number.
Of course, but extending an abstract class is better in terms of design. In the article I also demonstrated an example using an abstract class. Delete was left empty, but when you are extending a class your delete method will have code.
Right, it just felt like you're saying "inheritance is bad but extending (inheriting from) an abstract class is good." 
Being from a C++ background, not being able to use multiple inheritance in PHP makes me sad. 
If you wrote that article is obviously biased against inheritance / traits the code is bad by design that's why you examples make sense to you. You can't blame a tool for having a bad user.. Inheritance / Traits are very useful if correctly implemented. Because if we fallow your logic PHP is indeed a horrible language just because it allows bad coding practices, has many others do for that matter... So no they are not an evil to be avoided, just like any code written they have to be used wisely.. And in some projects they save you hundreds of lines of repeating code. For ie in your case where Editor can't delete, but still can access the class, it would be less code to validate user permissions than write different class for every role. And in a real scenario you should be doing that anyway also if an editor user is calling that method is because it's used somewhere and you need to return a 'permission denied error', so making your code more complex and hard to understand really has no benefit.. And if you do see the need to inherit and do so in an abstract class you only making your code hard to read, might work if you are solo, but in a team I can see people fighting with you over it (reason you created this I believe??) PS: I don't favor inheritances much, and try to avoid them, but to keep the code cleaner and easier to understand, if by design I see it's best to inherit or use a trait i do so for more than 10years, besides my yearly years where I barely understood the difference between a class and a method never had a problem. 
I don't have much experience with C++. You can use Traits in PHP to achieve that. &amp;#x200B; How did multiple inheritance in C++ help you with your designs? &amp;#x200B; I don't find multiple inheritance a nice design in PHP, but in C++ it might be helpful.
PHP is the Delphi of Pascal compilers. Or how about, because I've seen PHP scripts for Renoise back in the day so... PHP is the Lua of Fruityloops?
I completely agree with you. It always depends on how you use the tools. That's why before getting on the article I said this: &gt;Before I go through the explanation, I want to be transparent about this post. &gt; &gt;I don't find inheritance a disaster, I just think developers overuse it. Most of the times it is not needed. If I have to use it, then I swap for an abstract class if possible. &amp;#x200B; I also have 13 years of programming experience and in big projects, inheritance becomes difficult to manage and debug. &amp;#x200B; I never said that inheritance and traits are bad. The title was a question. I just wanted to point out a critical problem that arises with inheritance and traits.
We use Slim at my work, and I'm sure it can be good if we were the ones that built the app, but the original developers are no longer here and trying to figure out and sift through a lot of their decisions and code, with no documentation of how they built it, is frustrating beyond measure. 
I really want to thank all of you that clicked on the link and spent your time reading my article. &amp;#x200B; I have been working on Devlob for 6 years. I have been uploading free courses on YouTube for 6 years now and posts on Medium for about 3 years. &amp;#x200B; It makes me really happy to see that some of you wanted to read my article. &amp;#x200B; Again, I appreciate your time! THANK YOU!
I need to make a doctor appointment website for school, most of it is done, i can start a session when i login, i destroy it once i log out. The only problem that i have is that i'm having alot of trouble with making the profile system, displaying the data of the logged in user from mysql. I can't find any examples for a mvc structure, not simple ones atleast. I'm desperate, this is very important. If anyone can help me, i would appreciate it. I just need some kind of example of how it is supposed to work, the model-controller-view combo with sessions. &amp;#x200B; Thanks already
Multiple inheritance in C++ when you inherit multiple implemented methods is quite hell anyway.
What is mutation testing? Testing when your variables don't have the right type?
RemindMe! 1 Day
I will be messaging you on [**2019-02-19 19:22:44 UTC**](http://www.wolframalpha.com/input/?i=2019-02-19 19:22:44 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/as0upl/does_anyone_have_an_example_of_a_very_basic_mvc/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/as0upl/does_anyone_have_an_example_of_a_very_basic_mvc/]%0A%0ARemindMe! 1 Day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
See - https://en.m.wikipedia.org/wiki/Mutation_testing - https://github.com/humbug/humbug - https://github.com/infection/infection
Thank you
We need to get rid of the "antipattern" term. It completely undermines the often overlooked aspect that every feature has good uses and bad uses. Rarely is something just "bad" or "anti" in general.
To be honest the post was just getting too long. I've already spent many hours working on it and just wanted to release. I plan on writing more about other details of the process I didn't really have time to get into this time.
I don't consider them to be anti patterns per say, but I think it's more difficult to use inheritance and traits safely in PHP. I tend to use composition over inheritance because paradigms like dependency inversion better enable polymorphism in most situations. I only really reach for traits when my delivery timeline doesn't allow me to write better code, but I think they have a danger of creating god classes.
TIL
OMG, that's so true! When I worked on my course, I was really skeptical about the "Antipatterns" section. &amp;#x200B; I decided to include it only because sometimes developers just start writing code without thinking and I wanted people to point out some problems that arise because of that. &amp;#x200B; As I said in the article, Inheritance and Traits are not bad, just overused. I just wanted to point out a critical problem that is introduced with Inheritance and Traits. &amp;#x200B; But I DO AGREE with you! The term is just awful.
This is the main reason why i did my own framework. Convention over configuration for the win!
Many of the things we use traits / interfaces for now really. For example, a great many different types of objects would inherit from an EventListener and EventBroadcaster class that implemented a listener pattern. The broadcast methods would be brought in as protected methods so nothing outside the class could get at them unless it was friended. It might be extending a superclass, and suddenly you've ended up with 3 or 4 inheritance elements. Other examples might be that an object in 3D space might represent a user, a block, a physics object, but they would all inherit from a Coords3D class and therefore have X, Y, Z coordinates, but also things like support functions for calculating distances, tangents, collisions, things along those lines. Let's say you want to add specific behaviour to one of those functions, a hypothetical "nudge()" function. If it's part of a separate object then unless you have circular references between the 2 (usually an unpleasant thing in C++) then your main entity cannot communicate with the parent. You also find you can't do the equivalent of instanceof() when you are using the unextended instances. I can't go "thing at XYZ coordinates is an instance of a solid wall" because it's not part of that thing, it's just a property of it.
&gt; As I said in the article, Inheritance and Traits are not bad, just overused. Yup. I probably use inheritance in 20% of the situations I see other people use it in. It's a lot of trouble when it's used as shoddy alternative to composition or interfaces. But it still saves a ton of work when used wisely in few select places.
meaningless without knowing the size and complexity of your codebase 
EXACTLY, THANK YOU! &amp;#x200B; Totally agree with you! They have their place! But as you said, "In few select places". &amp;#x200B; Developers, especially Junior Developers just use it everywhere. I can't blame them. Inheritance is so easy to understand compared to composition. Of course, they will overuse it. &amp;#x200B; My goal with the post was to let those people know that bad things can happen with that approach. &amp;#x200B; "Fuck Reddit, I have to wait so much to post a comment. Reddit I am not a bot for fuck sake! :("
How do you mean, you dont want anyone to open them? Usually, you make a download action/file that checks access, and then streams the file with appropriate header/mime-type.
The files will be in the server, so I was wondering if I save them as binary (instead of plain open) just in case I have a curious server admin. I'm not saying it will happen, but I just don't trust people sometimes.
I have the exact same opinion, my friend. Inheritance and Traits are more difficult to use correctly and safely as you said in PHP. &amp;#x200B; I also prefer composition over inheritance, it just makes the code better. &amp;#x200B; Hahaha I do the same. If I don't have enough time then I go with inheritance, but I always make sure to go back and refactor the code. Sometimes I do it during my free time and I don't get paid. But I prefer that over some badly designed code that will hunt me in the future.
You know, I wish PHP had an inheritance-like composition pattern, I feel this would've solved a lot of the inheritance abuse, i.e. where this exact logic: class Foo { private $bar; function __construct($bar) { $this-&gt;bar = $bar; } function hello($a, $b, $c) { return $this-&gt;bar-&gt;hello($a, $b, $c); } function world($d, $e, $f) { return $this-&gt;bar-&gt;world($d, $e, $f); } } Becomes this syntax: class Foo { function __construct(private $bar) {} function hello, world from $bar; } TypeScript has the constructor shortcut feature, and I think Kotlin has the composition (exposing object methods) feature.
This is what I wanted to point in the article. &amp;#x200B; Suppose class A extends class B and uses 5 traits. How do you manage that? In my post, I used 2 methods, but in a real-world example, you have countless methods.
Yes I understood your position, I have too seen horrendous code, what I was trying to say is the 'problem' only arises when the code base is started by a junior dev. or someone that didn't keep up to date with new patterns. If the code base was created by someone with experience or the dev team is in the same skillset there's no problem that justify implementing more time consuming solutions. The alternative suggested in the blog post not only takes more time to deploy, it also makes the code harder to read, so why adopt it instead? 
Do you feel like using a framework? Or are you going barebones?
My guess would be your problem is caused by improper escaping in your SQL query. (It's impossible to say for sure without either all of the values used in the query or the final query as seen by the SQL server). This is best resolved by using prepared queries. See: https://phpdelusions.net/pdo#prepared Aside: Link posts on reddit are only designed to handle a single link. If you want to use multiple links, use a text post. Additionally it may help you get answers if you post some of the content in the post itself, saving people clicking on to other sites. In future you might want to use /r/phphelp instead as it's dedicated to helping people with specific coding issues (this and more in the sidebar).
Forget about MVC. It doesn't translate to the web and people just get hung up on the acronym. Focus on separation of concerns and understand that your webapp simply takes an HTTP request and returns an HTTP response. The Symfony docs has a great tutorial on how to go from a flat PHP app to a modern style application: https://symfony.com/doc/current/introduction/from_flat_php_to_symfony2.html
Thanks for the comment, i'll take a look at it
I have to use a framework, they're very strict on how it has to be built up. 
If you can't have anyone looking at them the answer is to encrypt them. I would go further and rename them, store the original name, a row salt and the file type in a database. Then you just have a directory outside the webroot that has nonsense filenames with encrypted content.
Some of the features have so many negatives that they are not worth the supposed benefits in nearly all situations. And in doubt and ever changing requirements of environment it's not worth taking the risk. You also have to keep in mind that people who came up with such things like inheritance lived in the days when software could be shipped like a commodity product. Thus adopting to ever changing requirements wasn't really a priority. Inheritance made some sense back when, especially early on in languages like C++. &amp;#x200B; However, as the time passed we slowly learned that the practice is generally unproductive and causes more trouble than adds benefits. However due to BC promise a lot of the languages still keep dragging on those bad features. In one of the conferences James Gosling, inventor of Java by answering a question from the crowd formulated that if he was to design Java again he would not add class inheritance. Noting it as a mistake. You will also notice that new languages also stay away from inheritance as they do not have to maintain BC promise. For example, Go doesn't have inheritance and it doesn't need it. Rust doesn't have inheritance and it doesn't need it. All classes in Kotlin are final by default. Etc. If you want to keep your code clean in PHP, while we cannot remove the class inheritance. We can make deliberate choices not to use it. And prefer composition instead as it most flexible way to achieve code reuse while maintaining flexibility, which is dead on requirement in a lifecycle of any web application. &amp;#x200B;
Thanks. I want to learn to do unit tests but sometimes it can be scary (specially without knowing how to for example mock the database and without examples). Viewing your code was helpful 
Yeah this is why I never implemented the singleton in myclabs/php-enum. It would have to either work every time or simply not offer it as a feature, else it's deceiving.
IMO it looks a lot cleaner and makes sense for certain types of configuration. Bundle configuration in Symfony and Symfony routes and firewall configuration as well. I don't like having my routes as annotations in controllers, it makes it more difficult to get a good overview of what you have registered in your application without having to dump the router. I also dislike configuring services with a yml file, autowiring makes a lot more sense for that use case. Also I don't know if you consider them configuration but what you can do with Doctrine annotations in Symfony is insane, it's super helpful for configuring your database entities.
YAML sucks
&gt; I don't like having my routes as annotations in controllers Me neither. I like Laravel's approach of dedicated route files where you explicitly define all your routes with PHP code as mappings to controller classes or just closures; allows nesting, obvious middleware assignments, etc.
I love Slim Framework, but wouldn't recommend it to inexperienced developers. It's like choosing a Linux distribution: Laravel is like Ubuntu and Slim is like Linux from Scratch.
&gt; For example, Go doesn't have inheritance and it doesn't need it. Rust doesn't have inheritance and it doesn't need it. All classes in Kotlin are final by default. Etc. "Go doesn't need it" doesn't solve any of my problems when I use PHP, because PHP isn't Go. Go has anonymous fields, for example. If and when PHP gains some theoretical future feature that allows combining functionality dynamically (i.e. composition), we can have the conversation again about whether inheritance is "all bad". Until then, inheritance has its uses. Also Kotlin's "all classes are final by default" was a really misplaced example for a language without inheritance, you know that. It still has inheritance. 
What you posted are simply bad implementations of inheritance. And your abstract class solution at the end is also sub-optimal. If you have an Operations class like you described in your post with a different subset of features in each child-class the parent class shouldn't provide those methods in the first place. Now you have a delete method that does nothing and silently fails without raising an Exception. "Oh, wait… Do we now have an empty method? Yes, we do! Is that bad? NO!" Yes this **is** bad. Don't implement a class if you can't fulfill everything the parent class requires of you. If I as a 3rd party programmer (or someone who joined the team years later) pick up this code and call the delete function I expect something to happen. IMO the best way to solve this issue is to either provide appropriate traits like a DeletableElementTrait or offer multiple interfaces that only provide one method. Then you could simple have ``` class Editor implements DeleteableElementsInterface {} ``` And if a class needs both the edit and delete method you can provide an interface or Class that implements both DeletableElementsInterface and EditableElementsInterface and implement that interface. That means a bit more checking down the line if your Widget implements the required interface for that action but it means there is no confusion about what yourWidget can actually do. Or at the very least raise an Exception if a non supported method is called to inform the caller, failing silently is a really really bad idea IMO.
You also got a few resources in there: https://github.com/theofidry/awesome-mutation-testing :)
I don't like language "hacks" and magic methods like \`PostStatus::DRAFT()\` because a class constant is not a method. Point.
Don't be scared of tests. Tests are just plain code :) Instead, be scared of untested code! When you have trouble writing a test, keep in mind: be pragmatic. What you want is find a way to make sure your tested code works. That's it. Everything around it, the different layers of testing, how to mock and all of that stuff is just to help out to achieve that.
I'm a bit baffled by your answer. PHP has a quite a few DI IoC container implementation. One of them being straight port from Java Spring, you might have heard it, it's called Symfony. So no, there is absolute no need for inheritance. It's just developers being lazy mainly. Or hacking something together to be shipped for 3rd party client they won't need to worry about later on. Kotlin does live in Java ecosystem and thus uses many of it's patterns. However, the obvious intent, so to say idiomatic way, is not to use it and the language itself hints you at it.
&gt; DI IoC container implementation We're not talking about this at all...
You wrote that you are afraid of your Server admin. If you want a user friendly solution there is nothing you can do. You can still always download them from the database or restore them from the file system. If you want a somewhat secure solution encrypt the files with the user password of the uploader. However that means if the uploader ever looses his password your file is gone forever. You can also encrypt the files with two different keys, one that you have and one the uploader has that would reduce the risk. However then you'd still have the problem that you would need to store the key on the server if you want to allow for an automatic password change process and at that point the file can be decrypted again. However even if you choose to only encrypt it with the user supplies key (which is probably a bad idea to start with) your sysadmin can still extract the secret key from memory and then get the files that way. The way to solve this is to not store files on a server you don't trust. Or you can download the files inside the browsers file storage and then decrypt them with javascript like Mega does it.
We are talking exactly about this. You yourself mentioned it: \&gt; If and when PHP gains some theoretical future feature that allows combining functionality dynamically (i.e. composition) Well, if you have no idea what DI IoC do when I cannot help you.
I suggest you look at the code example elsewhere in this thread that I posted. Also tone down the arrogance.
I don't see anything particular in your example. I can recommend short piece: "Object Calisthenics" if you have trouble keeping in line with Law of Demeter.
The code example doesn’t violate the Law of Demeter, and the point of it isn’t to avoid such violations. You simply have no idea what I’m talking about, and honestly I would try to explain *again*, but your focus isn’t understanding, but talking down to me as if I’m a first year junior programmer. Have fun. 
IMHO: * Usually, a service class is stateless, so I don't need to instantiate so it doesn't use extra memory and I can call it statically. * Other classes that use states (Database for example), they work as a Singleton and PHP permits several ways to create a Singleton, PHP is quite flexible about it. * And there are a few ones that I created an instance on runtime. ``` $service=new ServiceClass("arg","arg); $service-&gt;callMethod(); ``` I don't think we need some sort of "magic" to do that. For example, the use of "container" on PHP, it is a so-so port of what JAVA does. JAVA has a real container (each instance of the service class is cached, JAVA is about optimization), while PHP creates a container and an instance per call!. Containers are practical but it has a cost. 
What I see is you offering a poorly though out implementation as a solution, seemingly not thinking about consequences but focusing on "ease of use". Which is common pitfall as of why people start using inheritance. It does seem that you are trying to shoehorn a solution to a problem which have already been solved in much safer and more reliable way. That's what I'm trying to convey here. However, it seems the attempts are futile, probably due to my inability to approach people in reasonable manner, I can take that. However, that doesn't take away from the fact that the proposition is as about as useful as tits on a fish. I guess that will be all.
In short: you must trust in your administrator. There is not another way.
Do you even know how anonymius fields in Go work? Like tits on a fish? As I said, your arrogance is not impressing me. Go display your superiority complex elsewhere. 
Banging my head against this one as I type as I convert some stuff over onto Symfony's DI container. Fortunately I'm only using components rather than the entire framework so I said screw it and have configured all my services in PHP. 
You are missing the point of a message queue. **A Message Queue System is not about speed, is about stability against a high demand of concurrent calls.** For example, let's say what we have a service and it is accessed by 100 customers at the same time. And what if each customer uses 0.01second, so 100 customers will use 1 second (in total). Now, what if the load increases up to 1000 customers? In theory, the worst case could take 10 seconds. However, the main problem is not the slowness but how some transactions will be canceled or dropped. What if it is a payment system?. A Message Queue works in the concept of stability, so every transaction will be executed in due time, maybe they will take a second, a minute, an hour or a day, but every single transaction will be committed. A year ago I create a minimalist Message Queue for a customer and it uses Redis. https://github.com/EFTEC/UsagiMQ My bottleneck is Redis while your bottleneck is your database (PostgreSQL) and it is a big bottleneck. AFAIK, it is not the first project that uses Redis for MQ. 
You can annotate functions in other popular languages
If you're using a framework, consult its documentation. You'll want to look for areas surrounding **authentication**, which is the ability to identify yourself as a certain user based on private credentials (e.g. email + password), and then **how to retrieve the currently-authenticated user**. [Here is an example for Laravel.](https://laravel.com/docs/5.7/authentication) It might help you identify the language you need to find the information. That's about all I'm willing to offer. Do your own homework.
most of the time, PHP doesn't do anything... only waits for a response during a I/O operations. It only means that your service does less useful work per unit of time. It's just that your application works for a quarter of the possibilities. And if this is normal for your project, it doesn't mean that it is normal for everyone. If the project uses a message broker, this doesт't mean that the processing speed is secondary. &amp;#x200B;
You really should write another article backing up this instantaneous claim of yours. In my case the count(null) issue was in a Symfony library. Instantly updating a third party library? Instantly is not a very long period of time. Does rector really take care of forking a repository, branching it, making the change, adding a test case, pushing the changes and then filing a pull request? Be great if it did.
One thing I really am not a fan of in Slim is it's use of psr-7. It's very verbose and just nowhere near as simple to work with as http-foundation IMO. I miss Silex, that was a great little framework.
Linux from scratch would be writing your own framework (or language, maybe). Slim is like... Slackware or Arch. You get the basics but not much else, and have a lot of flexibility in how you set it up.
I want to get into and understand this article but it's not really sticking with me because i don't understand the examples. If your first example used traits atomically with edit and delete, your problem disappears because Editor only uses the trait delete. Your second example is a concrete class destination following some domain logic of two addresses. Iv never seen a problematic inheritance even do that. You would have an atomic Address, then Destination has two Address members and then your User class has one Address member. I get that we have to come up with examples but after reading this i still thought traits were a better solution then the ending of your article, it's just that the traits were being used incorrectly and atomically had too much responsibility. 
Also if allow_url_include is enabled they could remotely execute their own php scripts on your server. 
Factories are not analogous to symfony services, as their instances are shared by default. Also, Symfony DI of course do have analogous PHP syntax for configuration. You can't complain about DI container for your choice to go with YAML format.
That is not gamification though. It's just measurement. My bathroom scale does that too without pushing me in any way towards making the number smaller. 
I would store them on something like Amazon S3, with no public access by default and generate a signed URL when needing to fetch the content.
It felt like a game to me when I was coding it. I had to think of creative ways to increase code coverage. How can I make the biggest increase in the shortest amount of time? Sometimes that meant writing tests. Other times that meant ripping out bad old code that wasn't worth keeping. In my case hitting 90%+ got my badge to green which made me feel like I was "winning" the game.
That too. Any time I start using a lot of SQL functions, variables, flow control, etc, ORM and query builder go out the window. Though I'm slowly converting some to stored procedures and trying to make migrations to create the procedures so they're still under version control.
Some commercial addons don't support 2 yet. My company is doing a new platform on magento 1 because they need a specific plugin called MageXM that is still working on a magento 2 release.
As it happens I just went partially down this route. I ended up tagging certain classes with various (empty) interfaces and when the DI container is being built prior to compile, I reflect the entire class structure and pull out the ones I need by which subclasses they extend / implement. Assuming I go to bed before 5am, by the time I'm done I should have got it working where it's locating classes that implement ServiceRegisterHook and allowing them to add their own bits and pieces to the container builder. Mercifully, no YML, XML, or anything other than pure PHP.
so, what frameworks didnyou use at your last position? wrote my own we’ll be in touch
Hi guys! Few months ago I learned React/Redux, essentials. I made few small apps. But I want to learn backend and how backend works. I think that PHP is best backend language for total beginners, but there are too much hate on internet, and I lost motivation to learn PHP. All posts online are about that php is worst language ever, about bad design, php developers are not real developers. I want to sharpen my skills with React and Frontend and learn basic backend in 3 months, after that I want to apply for job. Can you guys share your stories about working and learning with php, I want to learn PHP and need some motivation :) Thank you all, and have a nice day! :)
Yes, actually. https://github.com/hparadiz/technexus All the source code for my blog: https://technex.us/ admin at https://technex.us/admin/ Reference this code: https://github.com/hparadiz/technexus/blob/master/src/App.php How it works: App::init() runs on every page, sets things up, runs the main router App::$Session = Session::getFromRequest(); either makes you a session or sets it up based on the user's cookie If $Session-&gt;CreatorID is set that means a user is logged in. Login is checked on literally every page load. if( isset($_POST['username']) &amp;&amp; isset($_POST['password'])) { it will run the logic for checking the username/password and setting $Session-&gt;CreatorID. It will then redirect to the current URL to get the page to display in logged in state. This allows you to always show the login page on a URL that is behind a login when a person is logged out. When they login they will login to the same page so they won't lose the URL. The admin controller is dead simple. If the Session has no CreatorID simply show them the login page. https://github.com/hparadiz/technexus/blob/master/src/Controllers/Admin.php#L23 Otherwise it does normal admin routing. You could rewrite this in any framework. 
What you just said is a plain gibberish. "save a file as binary (instead of plain open)" doesn't make any sense. All files are are always binary. To open is a verb, not a file format.
It basically handles your routing and thats about it. At tha point you might as well just use Symphony components so you can grow into a bigger framework (if need be) or just roll your own. I chose Slim for a very thin client that connects into our bigger CakePHP API. I wish had gone with Symphony components or Laravel instead. Nothing wrong with Slim, I just prefer kitchen sinks.
Dude, just to let you know, https://github.com/Divergence/framework/blob/master/src/IO/Database/MySQL.php#L185 is a fucking shame. 
With all due respect to PDO. Really don't need those there.
What they are trying to say is that it’s 2019. PDO has been around for how long now? Trying to show anyone code that doesn’t use PDO is terrible.
Yes, I reckon it's rather a legacy stuff. But anyway, someone could actually use it and impose an SQL injection. 
You mean that feature which is one of the primary source of runtime errors in Go? Maybe instead of complaining for lack of hype features learn the basics. There would be no need for anonymous fields with DI IoC. And if anonymous fields did fulfill the need for composition there would be no need to develop things like CloudWire in Go. Di IoC handles composition in most managable way. You yet continue to bable something about inheritance or it's method inheritance or how supposedly php can't achieve composition dynamically. That's blatantly absurd in attempt to justify to push malpractices in code. 
You use doc blocks to help you out with autocomplete. You use PHP type hints to enforce them. If you use them where you shouldn't, you will get a TypeError.
You still have zero clue what I'm talking about. Look, you can't go in some thread hijack someone's opinion and say "hey you didn't mean X, you mean Y, and Y is addressed by Z, you moron". I know better than you what I mean. I'm not talking about *wiring* objects together, but writing classes which implement interfaces partially or fully through objects they composite. DI won't write the class for you. You can keep shouting "lalala" with your fingers in your ears, your point about DI is still absolutely irrelevant to what I'm talking about. So kindly take your mental problems elsewhere.
Not likely. https://github.com/Divergence/framework/blob/daaf78aa4b10ad59bf52b9e31480c748ad82e8c3/tests/Divergence/IO/Database/MySQLTest.php#L98-L125 I've literally been writing PHP since before PDO existed without SQL injections that you very much because I sanitize ALL input.
It IS using PDO.
&gt; writing classes which implement interfaces partially or fully through objects they composite But I do. The problem that it's not that I don't understand, I do understand, it's just irrelevant feature which adds nothing to the language. The problem you supposedly arise doesn't occure if you follow OO properly. You achieve same functionality in effect via DI with more clarity, control and even compile checks in case of Symfony. If you suggest that object should by default inherit some other objects interface due to being composed with that object, that's terrible idea.
&gt; You achieve same functionality in effect via DI OK, since you're particularly dense, let's try this in the form of a school homework. You have this interface: interface Foo { function a(); function b(); } You have this object implementing it: class SpecificFoo implements Foo { function a() { ... } function b() { ... } } You have this object, which needs to implement Foo via the object it's given: class AnotherFoo implements Foo { private $foo; } Now. Do this via "DI" without writing proxy methods manually, dickhead.
And what's the issue with proxying manually? Hint long chains aren't an issue in OO.
F
Please go on. Explain. Hope it doesnt boil down to the first objection I raised which is "easier to write" at the cost of explicit behavior which can be cought at compile time. While at it please also explain how are you going to mock implementation of the interface when testing main class within php ecosystem. And also how are you going to ensure that contact doesnt break somewhare else in the code without compile checks.
&gt; at the cost of explicit behavior which can be cought at compile time. Nonsense. Of course the IDE/compiler/interpreter can understand such a simple declarative syntax. In fact, it improves the ability for analysis. &gt; While at it please also explain how are you going to mock implementation of the interface when testing main class within php ecosystem. Same way you usually do. This has nothing to do with it. &gt; And also how are you going to ensure that contact doesnt break somewhare else in the code without compile checks. Again, nonsense. No "compile checks" are abandoned.
I'm not entirely sure. Maybe make a few simple Laravel ( or any framework ) projects. I learned a lot trying to make my own framework.
I mean, not to be rude, but this is /r/PHP. Of course _we're_ going to tell you your friend is wrong, and PHP is as relevant for webdev as it's ever been. You'd have a much better chance of getting a wide range of answers to this question if you posted it in, say, /r/webdev. Also, this is a nitpick, but there's nothing more "recent" about Python and Ruby, both of those languages are just as old as PHP is. 
I don't know, but saying it's not relevant without any arguments is just a waste of discussion. Everything is relevant in the right context. It's like saying food is irrelevant because of soylent.
I am sorry to ask this question But what do you mean when you say framework ???? Is it a project like in visual studio??
Well, it certanly can't be bad for you. :) If you already know C# and how to program, picking up PHP for WordPress (most common type of jobs on upworkI think) and such sites should not be so hard. You would need to know the syntax and the basic functionality, all of which you can find on php.net and stackoverflow, and various tutorilas. Give it a try. If you want something more than WordPress, see the popular frameworks, Symfony and Laravel. With them you will get into concepts you know from C#, like Dependency injection, Repositories, ORMs... 
PHP is still one of the most used Language for Websites. So Knowing at least Basics of PHP is never bad. But... there are a lot of PHP Dev. out there (especially) on the "get a Freelancer sites". if you want more request learn one of the new hip languages like GO, Kotlin or Rust. &amp;#x200B; To awnser the question for PHP. Learn one of the big Frameworks(Laravel, symfony, cake, etc....) until you feel confident enough to build every common use case and you are good to go
The web is baked into PHP's DNA. You can straight up embed it in HTML (I don't recommend it, but you can). You can't really do that in Python or Ruby. The way a PHP application is served also makes it easier to scale and more robust. If the request bombs, only *that* request bombs. There isn't an application running that can crash out and needs to be restarted like you get with Ruby and Python. I would argue there is no *better* language for server-side web development than PHP. I would also argue there's no better *alternative* server-side language than JavaScript/Typscript running in Node. Dealing with JSON APIs is nice and native and you can write isomorphic code on the front-end and backend. If you need to serve and handle JSON and/or do some real-time websocket communication, JS/TS and Node is the shit. Python and Ruby would not be anywhere close to my first choices for web development to be honest.
That's logical fallacy. You pretend to compare, but saying php is good because its good. Why won't you learn one or both of those two languages so that you can compare superb metaprogramming facilities of each one? Or immensly more sophisticated syntax of python, or beautiful DSLs rubbists have. Why are you content with "but PHP 7!!!"
Well thank you for your time and your response I will take a look at rust go and kotlin
OMG this test case is hilarious. You test SQL injections with bobby tables case. Unbelievable. And the idea of "sanitizing"! You should really emerge from under the rock where you spent the last 10 years. For some reason I didn't manage find this function's usage when i looked the first time but now i see it actively used in the active record. And likely somewhere else in the code. Well, my condolences. 
Show us what you have so far
If you don't trust your admin, either remove them, or yourself from the entire situation.
Thanks for your insight. I just googled the release dates for Python and Ruby and realized Python actually predates PHP! It's strange that everyone I talk to touts them as recent languages. The frameworks may be comparatively recent but the languages are equally mature. Thanks once again.
If your function call needs to be mocked in the middle of some execution path, it is very likely that it is because it performs I/O or relies on global state: introducing an explicit (injected) interactor is preferable instead. An example of this can be seen with using `time()` vs injecting a `Clock` service.
PHP and Go are good friends. We do PHP apps with Go microservices and are pretty happy all around. Rust isn't there yet. I tried so hard to love it for embedded systems, but the learning curve is brutal (albeit it's getting better, and docs are improved); I swear hello world can get you pulling your hair out in the beginning.
A framework is a type of library that helps when writing web applications. ASP.NET is a framework.
No, visual studio is a good IDE. In general we use PHP on, say an http sever, to handle requests, use some logic, and deliver information back to the user who see's it on the browser. A lot of that handling of requests and logic has security concerns and also regular PHP patterns of coding (e.g. MVC) that have developed over time. So, we start with a framework of code that does a lot of this work for us, and then build our application on top of that.
This particular function is MISusing PDO. Or even abusing actually. There is no use case for such a function. For the data literal a prepared statement should be used instead. For any other case it is essentially, deliberately, completely u s e l e s s.
PHP / NodeJS are the only good things for backend web development. &amp;#x200B; PHP -&gt; You can run it with Apache or without, you can simply do "`laravel new webapp`", and that's it NodeJS -&gt; You can run it with or without Apache/Nginx, you simply type "`npm install express`" and start coding &amp;#x200B; PHP is better suited for serving plain text templates NodeJS is better suited for REST APIs (Even though PHP can do exactly the same) &amp;#x200B; &amp;#x200B; Big advantage of using NodeJS, you can develop a whole web application using 1 stack of technology, use ReactJS for the frontend, and Node for the backend, all javascript, so you can feel more comfortable &amp;#x200B; There is no "EXTRA" benefit by using Python of Ruby, other than the experience of using those languages, if you are more experienced with dJango, go with it, but I have a lot of experience with node and php, and I'd use PHP if I had to use a relational DB, if I had to use noSQL I'd go with the JS stack, but then again, what's really the advantage of using Ruby of Python? &amp;#x200B; Also, PHP 7.0 is already outdated, people would prefer 7.2 and 7.3, I personally prefer 7.2 because I don't see the benefit of 7.3 &amp;#x200B; I think PHP 7.0 should have been delayed and simply be merged with 7.2, they added a bunch of featured from one version to the other which honestly deserved a major release, PHP 7.0 didn't offer much beside the huge performance and the deprecation stuff, PHP 7.1 and onward were the real game changer
To elaborate: the very point of PDO::quote() function is to do a **complete** formatting. For simplicity it could be defined as adding quotes around and escaping them inside. It means the PDO::quote() result without quotes is just meaningless. Good for you when you add quotes manually. A catastrophe when you don't.
Have you tried /r/phphelp ?
Your editor live templates!!! ;) And maybe some glue script that \`touch\` all the files based on convention.
Multiple union + CTE + window functions will stretch almost any ORM I dealt with. There is zero need for re implementing those features in PHP if db supports them. Thankfully, MySQL finally gets them so I do hope ORMs will improve. Equating O with full static domain objects is a disadvantage.
CTE or window functions seam to be beyond ORMs I dealt with, (apart from ofc allowing for pure SQL sent over connection managed by ORM)
Recent? Ruby and PHP were both released in 1995. Python was 1990. If you're going by which has had the biggest changes to its basic syntax and implementation in the last two years, PHP is the newest hands-down. I'd say python is the darling of academics, and tends to be favoured by the cowboy-coder, does everything alone crowd. It's often praised for reading like English, which I consider a huge weakness. English is a terrible language to code in. It also conflates familiarity with simplicity, when those are two very different things. Ruby has been on a sharp decline, because if you want a weakly-typed, highly supported language with lots of libs, JavaScript running on node is a better choice. PHP nowadays I'd compare more to Java or c# than to py or rb. It's all about defining interfaces and namespaces, and is clearly optimized for writing well-organized object oriented code. Ruby is equally oo focused, but tends to be nicer for weak-typed work. Hence Ruby's popularity with "convention over configuration" frameworks like Rails. While you can write code pretty similar to Java, php is a lot less strict about making you write everything a certain way. So you'll see some really sloppy stuff out there only because it's possible (famously the WordPress core). That also makes it a great web language for projects that need to implement something that works quickly, and start to clean and organize the work once the purpose of the application become more obvious. I'd say the closest competitor to PHP right now is TypeScript, a JavaScript superset that also optionally lets you use interfaces and strict argument &amp; return types. 
Man Rust feels so good to work with until you want to use a Cargo package and realise everything is tagt as "ALPHA DONT USE IN PRODUCTION" the language is just not ready for the mass right now. &amp;#x200B; I also use GO and PHP, PHP for the normal website backend and GO for Cronjobs and Websocket tasks. I didn't mean to sound like its a this or that choice, more like if you choose a language just for the sake of getting a lot of freelance work, PHP has to much competition to be that language. 
[removed]
*sigh* unless you have something useful to contribute please go away.
It's fine if you need enumeration values only for one method/function, but this wouldn't work if let's say you need a type of "WeatherCondition" with predetermined values/options. And many places where WeatherCondition is needed. e.g. input validation, GUI display, business logic. In these places you probably would use some kind of switch () { case xx: break; } to do some logic. Imagine that requirement changes and you need to add new weather condition. How would you find (in your example) all places where are you using your "WeatherCondition" in code to add logic for new condition? And the most uglies thing for these enums as constants as strings as ints is that these all constants can be freely used as arguments in all APIs without any warnings. E.g. if you define EngineStatus::ON, EngineStatus:OFF and define Lights::ON, Lights::OFF it's impossible to prohibit usage of semantically incorrect constants - example changeLightsStatus(EngineStatus::ON);
I actually really enjoyed .NETCore mvc when i tried it out for a semi-large webapp. When following conventions and best practices everything is really structured and easy to follow/dive in
[If I had more time, I would have written a shorter letter.](https://quoteinvestigator.com/2012/04/28/shorter-letter/)
Wow, such a high horse. Looks like you are taking that Yii / Laravel mixup of yours as a spotless masterpiece.
One of the biggest advantages php has over Ruby/Python is return types. A quicker execution is an added bonus. With Symfony DI IoC you even get some compile check coverage. Static analysis tools seem to be very on point too.
yeesh
this sounds exciting! i just wish i knew what you're talkin about haha 
&gt; The reason is because in the arg typehint you're just typing string instead of something like PostStatus &gt; You could pass in "abcdef" as an argument and the interpreter would think it's all good to go. No you could not... If you read and understand what I am writing you would see that I create a `PostStatus` instance and not some random string. The constructor of `PostStatus` validates the value (e.g. using reflection) or any other means so that no you can not pass "abcdef"... Even the linked enum library in the article enforces values through reflection.
Let's be honest, it's not about reimplementing PHP logic, it's about having a discrete service locator which actually has intelligence embedded and solves real life problems. You have to learn to trust other people, and in that trust config coding (at least the one described in the original post) is one of the many point you want to trust other people with. Service location and configuration a common pattern to solve in many languages and many software, especially extensible one, and a complex one to solve. For example, with Symfony 3.4 or 4, you tend to let it autoconfigure and autowire your services, you almost don't write yaml anymore as soon as you keep a standard project structure. It brings lots of improvements that custom PHP initialization code will never achieve in a standard, reusable, and comprehensible way (allowing to work as a team much more easily): * automatic service replacement depending upon the environment (plugging in stub implementations in unit testing configuration for example), * service decoration for free, you don't have to modify framework code, or other's people code to implement the decorator, facade or proxy patterns, * you can replace services transparently without writing a single line of code except the service itself, within complex already existing applications, * PHP has a lot of flaws, such as slowness (not so true anymore using PHP 7) still, compiled containers do apply lots of micro optimisations and lazy initialize pretty much everything, a thing your code will not do, or at least not as well in the end, * service registration is a dump and fastidious work, I'm very pleased a framework does it for me. This is not a complete list, and it is arguable, but as of today, that's the main points that actually help me saving a huge lot of time. Not in the project setup phase (I still have to read some bits of documentation for wiring edge cases) but for everything that goes after that, especially once you mastered subtleties for environment specific configuration, service stubbing (for example, plugging a foo connection service in a staging environment, a web service stub in testing environment, etc...). That's just my 2 cents, problem arise when configuration is too hard to understand and write, but when it's discrete, or minimalist, it's something we all desperately need.
If you are an intermediate PHP programmer, my book [Professional PHP](https://patricklouys.com/professional-php/) could be a good fit. Check the table of content to see if it's something that is interesting to you.
Event projection, huh? Sounds about right! Thanks for the tips!
So it wasn't seamless at all, then?
PHP tooling has improved significantly over the last 10 years. Rails vs ZF1, Symfony, or CodeIgniter weren't much of a comparison-- especially _without_ composer. Today, IMHO, its much more about community and libraries than language-- and PHP has a very strong community and very strong tooling. --- In talking about web-technologies: its surprising you didn't mention TypeScript (or Javascript). I think they're tooling has a bit to go before its ideal, but: * The TypeScript type system is vastly better than PHP (Unions, Ad-hoc interfaces, enums, optional strict null checks, decorators) * The integration with frontend HTML/CSS/JS is (currently) unmatched-- especially if combined with react-static, next.js, or Gatsby. * Everything supports async (and more importantly: timeouts). * Using new features is the easiest of any language: tools to run on old platforms that don't support new features are standard. Main Con: The package _repository_, (npm) sucks in comparison to its alternatives.
*Hey just noticed..* It's your **4th Cakeday** SavishSalacious! ^(hug)
The truth is outside of a minority of cases that need huge levels of performance or have specific needs like very good concurrency features, then it doesn't really matter what language you use for the backend. If someone says language X is terrible, then really that just means it is someone to ignore because they lack objectivity and are unable to separate their own subjective preferences (which is all the difference is in most cases between language X being terrible and language Y being great) from the reality, which is they are all perfectly decent for building the bask end of websites.
A framework in PHP terms is simply a library to help you program some tasks faster. In PHP a few famous ones are: Laravel, Symfony, ... The bigger question that i always found. Do you really need it as PHP from itself is already heavily designed around web productivity. Another issues that i personally have is that a lot of those frameworks end to be written in such a way, that you end up learning the framework. My advice is always: Give a man a fish, and you feed him for a day. Teach a man to fish, and you feed him for a lifetime. So first start small. Write some code in pure PHP. You need REST API handling. Look up some of the frameworks and see how they do it or find code examples ( Google search with PHP gives you instant access to 1000s of examples how to do X, Y, Z ). Step by step learn how the logic works in PHP. PHP still has some quirks that are better you learn from the start, then can be puzzling if you run into a issue later. Is that issue PHP? Is it from the framework? Is it my code.... So the less layers / abstractions in between the easier to learn from your mistakes or PHP quirks. PHP is very loos typed and if you come from C# it really opens a up big world of easier development but also can feel strange :)
&gt; PHP -&gt; You can run it with Apache or without &gt; NodeJS -&gt; You can run it with or without Apache/Nginx Or you can run Swoole and have NodeJS in PHP *lol* 
Very well written good sir &amp;#x200B;
&gt; I'd say python is the darling of academics, and tends to be favoured by the cowboy-coder, does everything alone crowd. Strange, out of the three in my experience PHP is the most likely to be used by "cowboy-coders" be they solo freelancers or in some trash web agency, let's not even go into Wordpress "devs" and has also by far the highest amount of devs I've encountered who do not have a relevant degree. Where as for the large companies I have worked at over the years, Python has been far the most commonly encountered language out of these three, because it is hugely used in machine learning, pen testing, etc. Which then means sometimes it then gets chosen as the backend for the web simply because a company already has devs familiar with Python, so why even consider something like Ruby or PHP in that situation.
The main practical reason is so you can avoid exposing designers and such to actual php code. Beyond that, it certainly does seem redundant. 
Auto-escaping and inheritance. 
Probably inside Job
This comment doesn't make any sense. 
Sure if you can copy and paste then make it work why not
No in 2 years 
"PHP: Hypertext Preprocessor" Redundant indeed.
Incredible
[this](http://fabien.potencier.org/templating-engines-in-php-follow-up.html) article perfectly covers this topic
PHPStorm.
I work with PhpStorm, VS Code works fine if you install the proper plugins
Separation of concerns, safety, less verbose. And then there's all the extra features like inheritance, blocks, autoescaping, filters, etc.
you could google this question, it was asked more than a million of times
From personal experience, its just a good way of keep the backend/frontend systems seperated, I know its not an excuse for bad coding practices, but it does help with an extra layer of security preventing the frontend being able to execute PHP which is shouldn't be able to (which could display more data than it should). With the frontend guys I work with, they don't need to know/understand PHP to get there HTML/CSS/JS working etc, but are still able to produce fully functioning websites and not have to worry about the language the backend works on. &amp;#x200B;
In case it isn't obvious (it wasn't for me, when I first tried [PHPStorm](https://www.jetbrains.com/phpstorm/)): &gt; **PhpStorm = WebStorm + PHP + DB/SQL** &gt; &gt;All the features in WebStorm are included into PhpStorm, with full-fledged support for PHP and Databases/SQL support added on top.
Anything that you can do in YAML in Symfony, you could do as PHP instead. There are PHP examples in the documentation for all of the configuring. The reason "why" is because YAML is simpler, easier to read, and gives more flexibility.
You could ignore the post too
In to say mcedit (Midnight Commander) in ssh console :p
PhpStorm or netbeans VSCode / SublimeText if you install proper plugins &amp;#x200B; To work with vueJS &amp; Laravel i find VSCode more helpful than PHPStorm due to plugins but it has its quirks, so test all the IDE's you can and go with the one you like the best, i personally have both phpstorm &amp; vscode 
no doubt, PhpStorm go for it you wont regret..
[Model view controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) This is one way, but not the only way. With more javascript for interface, php as json handpoint, and websockets, found good time to keep everything super simple, cause it's **crazy faster.** 
Sure, PHP can act as a template engine, but not as a very _good_ one. On the other hand, modern PHP template engines, like Twig and Blade: - are _significantly_ less verbose and more easily readable than PHP, especially to people who might need to work on your templates but aren't very familiar with PHP. - are safe by default, and require you to be explicit about it if you don't want your output to be automatically sanitized. - come with a ton of template-related QoL features, like inheritance, filters and default blocks, that help make your templates more concise and easier to both read and write. - are a simple way to ensure that your views _only_ contain view logic. This is useful as an additional safeguard for the quality of your codebase, because it ensures no dev will be able to stick a bunch of non-view-related code in a template, no matter how inexperienced.
But I did not want to
Neither did he!
Phpstorm
good article but it would have been nice to see blade mentioned
You can go to the moon with any text editor.
What plugins do you use for VSC ? I tried the most popular ones and they work fine but not astounding. Trying to see if there isn't something cool out there I'm missing out on.
I work in a lot of languages, C# and PHP included. There's nothing about PHP that's special enough for you to learn, but some of the frameworks just absolutely destroy .NET and ASP in terms of usability. I'd honestly say Laravel is my favorite framework for any language I've ever worked with. We can build APIs so much faster using Laravel at my company compared to when we have to use .NET. It comes with a performance trade off, but this is fine for some clients.
For straight PHP and JavaScript I've used Vim and more recently Emacs (evil mode) with the appropriate plugins and both of those were great, approaching the functionality of PHP Storm but much, much faster (and better looking). Depends on what is important to you I guess. 
The only way a server admin won't be able to see the files is if the client (e.g: browser) decrypts the files and the server doesn't have access to the decryption keys. You can make it harder-- but ultimately the server admin still has access to anything the server does. If the server can request decrypted content, so can the server admin; If you require a token/key from the client to be sent, the server admin can intercept that request and store it; and so on.
I personally prefer to wait for a page to load and then have it completely loaded with all content, instead of having it instantly "loaded" and then staring at placeholders while the actual content (and 500MB of scripts) is loaded in the background. Just my preference. One advantage of rendering everything on the server and then serving plain html with as little JS as possible to the client is that you can optimize the hell out of it and throw more resources at it on your side, cache it as much as you can, and it all works independent of the client browser. JavaScript disabled? No problem. Slow internet connection? No problem, plain HTML still loads relatively fast. Almost no computing resources on the client? No problem since we're not building the DOM on the client. 
Another thorough message by Joe Watkins: https://externals.io/message/103903#104433
Definitely - we've only *just* seen other languages start to pick up ML libraries, which have been almost the exclusive domain of py for a while. Since so many academics love py, and they're the ones doing the first wave of ML, it sort of self-propagated from there. It's ironic that it took so long, because there's such a demand for it (especially in JavaScript), and while the applications can be complex the basic library requirements are pretty simple (e.g. google glove is really just calling a web service; cosine similarity on a set of word vectors is a 2-line equation, etc.) Once they start including things like their own sentiment analysis then it gets more involved, since you need to provide some dataset along with the lib, but if all you need is something that can do the basic King -&gt; Man is to Queen -&gt; Woman vector (the "hello world" of wordvec), it's really not that tough.
I do python at my job, PHP for my side projects. Gotta say I prefer PHP. And mostly with what we've heard about the creator of Python leaving the direction, and PHP getting on horses to make it faster, I do not regret betting on PHP.
Wow you are the 4th one who suggests Laravel Well ok i will take a look at it 
That is the definitive robust way, you are describing, of course. Plain html is the way for long term, example when saved on the archive, for search engines. Yes js can be disabled and then all die! Need fallback, if doable! Some peoples likes to use tons of libraries, but we can keep it super simple without them, usually few files of js, 5kb each is enough for many things. Browsers are evolved super smart,and cache all that! Modern browsers api are strong. (Fetch, import, etc) I don't even bother much with server caching, php is also super smart nowaday and do all this for you. Yes he detects if the served content changed, otherwise use a cached version already. Using php ressources to build json/jsonp, overwriten when created, it's hard caching. Php check if the file changed all alone! Last one, maybe completly unuseful, but using the dynamic domm techniqque, this is then easy to make offline switvhing app. Page always respond! Depend of the theme that is a plus!
The performance numbers I've seen on internals suggest 20-50 percent improvement. Between this, and preloading, if I can get an extra 20 to 50 percent performance out my server cluster at no cost, that's going to save me a fair chunk of change in the long run. This was a demo from a long time ago, which really impressed me: https://www.youtube.com/watch?v=dWH65pmnsrI
Almost no one is rendering fractals in their production applications though :/
&gt; add unnecessary level of verbosity Huh? Isn't the opposite true? Templating engines remove a lot of the verbosity necessary when using plain PHP. @foreach ($foos as $foo) {{ $foo }} @endforeach or {% for foo in foos %} {{ foo }} {% endfor %} vs. &lt;?php foreach ($foos as $foo): ?&gt; &lt;?php echo htmlspecialchars($foo, ENT_QUOTES); ?&gt; &lt;?php endforeach; ?&gt; "Plain PHP as a templating engine" kinda works, but it's very verbose and falls apart as soon as you need more advanced features like inheritance or components.
It's a big list so hard to tell by head, when I get home max I can do is export the list and share here
PHPStorm is fantastic. &gt; Only requirement is to work in remote (ssh) If your project isn't too big, you can use sshfs to mount the project directory locally and use any tool you want. For larger projects, this gets really slow though. I use PHPStorm, set up a deploy target on the dev server, and set it up to autodeploy on file save (SFTP or SSH). This gives you a fast local copy synced to a remote server as you edit. &amp;#x200B;
well, all you mentioned was `new PostStatus(PostStatus::DRAFT);`. of course if you add in all that checking and reflection, or use a library, then you could do that - you didn't mention any of that. and look at all the code you're standing up to make an enum, this shows why an enum would be nice finally, even with your example, an ide wouldn't be able to suggest you what string to use in the constructor, you'd still need to add comments to direct the developer as to which strings to use. a real enum class would make development quicker and not require you to fail once to see the error 
Like with a lot of things in software development, you can go *way* overboard with something and turns out it sucks. If you use it in small amounts and as needed to assist you, it can be useful. Also, I really dislike configuring services with yaml. Routes, I can do with yaml, the basic app config I can do with yaml, but services seem to work better with xml for me.
Both the demo that you linked to and theoretical improvements are unfortunately very unlikely to actually effect a "typical" PHP web application. A JIT practically requires a long-running app that hits similar code paths consistently, and then optimizes what it can in those code paths, for it to be useful. Common PHP web apps like those that you stick behind PHP-FPM, Ngnix, and/or mod_php (Apache) are short lived processes that fire up to serve a single request and then exit/die. These types of apps are incredibly unlikely to benefit from a JIT at all, and are unfortunately what most PHP users are likely to be running. Not to be a downer, but the kinds of things that we're seeing a JIT benefit so far are very theoretical or are benchmarks/demos that are tailored to show off the JIT by running algorithms that you'll rarely see run, let alone implemented, in PHP. While I'm hoping that introducing a JIT might finally mean that long-running processes with event looping and asynchronous routines become more popular in PHP, that would mean a completely different development model. Unfortunately, in it's current state, I am worried that the proposed JIT won't have much of an impact at all, but will instead make the internal development much more complex and bloated. Internal development is already somewhat limited, due to the skill set it requires and the breadth of features and standard library that ships with the PHP runtime. We'll see. For more info, check out this Twitter thread from some internal developers that discusses the same issues: https://twitter.com/SaraMG/status/1093304037372506112
&gt; You must already know that yourself, Nikita, and Bob are really the only active contributors that are qualified to talk about technical aspects of the JIT, to improve it, to find or fix bugs That's pretty scary and confirms the point rasmus was making: &gt; if [implementing JIT] is adding substantial maintenance overhead or significantly increasing the barrier for contributions, I'd say, think very carefully about this.
Python is better suited for cli and analytical process, IMO. Ruby is basically Python syntax, without the spaces requirement, and really handy at getting a web site or api up fast, especially with Sinatra. PHP rates the same as Ruby but with a more Java like syntax, especially if you work with Symfony.
That's true
I think it depends on what you're doing inside the trait. I've seen traits handle a lot more business logic than it really should.
exactly
RemindMe! 1 day
I will be messaging you on [**2019-02-20 15:22:14 UTC**](http://www.wolframalpha.com/input/?i=2019-02-20 15:22:14 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/asa5w8/best_ide_for_javascript_and_php/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/asa5w8/best_ide_for_javascript_and_php/]%0A%0ARemindMe! 1 day) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ____id____) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
The blog post was written in 2009; Laravel v2 (introducing blade) was released in 2011.
Thank you for saying this. PHP is rarely the choke point of speed for normal Web applications.
Wkhtmltopdf 
&gt; Common PHP web apps like those that you stick behind PHP-FPM, Ngnix, and/or mod_php (Apache) are short lived processes that fire up to serve a single request and then exit/die. I can't speak to mod_php, but the point of PHP-FPM kinda is the notion of long running processes serving thousands / millions of requests before they terminate. 
RemindMe! 1 day
I use [https://github.com/spatie/browsershot](https://github.com/spatie/browsershot)
The *process* in PHP-FPM may be long lived, but (as per the HTTP idiom) there is no state that exists from request to request that userland PHP can access. So web applications fire up, perform their work, then exit. This is in contrast to something like, say, a WebSockets server that handles its own persistent connections by having a loop where it sits in a blocked state waiting for network traffic most of its time, handling client requests without some other process like an HTTP server sending out (F)CGI requests.
If you think forgetting a semi in php us bad, wait till you try to find that extra or missing space in python...
The entire point of opcache (of which JIT will be a part) is that the opcodes are shared between requests. That will be further extended with 7.4 (or maybe 8.0) with the addition of preloading to allow at-process-start compilation-to-opcodes of all the PHP files which will create additional fixed routes. 
Ctrl + P
Am having a problem with my new host I moved all my word press page to a new host , and some .php pages i use as SEO posts to have a good Rank in google , the web developer who uploaded these files , uploaded them as encrypted version so my new host is detecting them as suspicious contents and suggested to re-upload the files as unencrypted version So how can i do that , is there any soft i can use ? Here what the host said : Scanning \[/home/myuseraccount/public\_html\] ... Please wait... \[GEN\]eval\_base64decode \[06/03/18\] /home/myuseraccount/public\_html/instalacao-de-granito-em-sao-paulo.php \[GEN\]eval\_base64decode \[06/03/18\] /home/myuseraccount/public\_html/granito-alto-padrao-em-sao-paulo.php &amp;#x200B; **So can i download them from my ftp , pass them to a software or app and then re upload them as unencrypted version ?**
This. The rendered product is exactly the same as rendered in a webkit browser (ie chrome) which makes for the laziest and easiest solution. I use the following wrapper on a website that generates 1000s of PDFs every day: https://github.com/mikehaertl/phpwkhtmltopdf
There is very little (zero) good reason to encrypt entire PHP files in such a manner. I'd put the chance of them containing malicious code at about 90%
[https://www.jetbrains.com/help/phpstorm/using-live-templates.html](https://www.jetbrains.com/help/phpstorm/using-live-templates.html)
Are you asking for an AJAX tutorial?
As someone knee-deep in a long-lived WebSockets-based server process, JIT is exactly the kind of improvement I am hoping for from the next version of PHP. This expands the number of uses cases that PHP can be utilized for, which increases developer interest and brings in a wider pool of potential contributors. A project can only bring in new blood towards its own development if it is constantly broadening the pool of its users who then become invested in its success and want to contribute to its future.
Sorry about how I put it. I am trying to build a Document Management System for small offices. I don't know how similar software do to store the files: Either just using a random name but still able to open or some encryption. 
I understand. I am trying to develop a Document Management System, and I was wondering if there was a way to have the files stored securely. Based on the replies I got, I will just store them outside the web root.
RemindMe! 1 day 
Alright, thanks
Is there a way to unencrypt them ?
Ok I see, thanks!
Shit the fuck up
You are right but PHP can now do things we could only imagine few years back. Example: some smart people used generators to build async execution. Instead of using short-lived share-nothing architecture, we can now use tools like Swoole and PHP-PM and avoid framework bootstrapping. I tested both, they are amazing! &amp;#x200B; Same can happen for JIT; I am sure someone will make tools to build simple games in PHP. Those older might remember demo/intro scene that gave Amiga a big boost. Heck, we even have tools now: [https://github.com/krakjoe/ui#captures](https://github.com/krakjoe/ui#captures) So even though JIT will probably not make web apps much faster, I am all for expanding the market and bring new people with their ideas. And who knows, their experience might give us static compilation that would dramatically boost not just UI rendering but web apps as well.
You'd have to upload the file and the code that loads them somewhere. 
&gt; or netbeans 😨
Show us the files. Or at least the first 10 lines of one of them. 
In the part that you quoted, u/Rican7 (correct me if I'm wrong) was talking about designing server side script applications that are event or connection based, rather than request based. That is, a script could be listening for search autocomplete requests, and the script would respond right away without any request set-up and tear-down that PHP scripts have. Between requests, the PHP sits waiting for new requests, rather than the web SAPI waiting for an FCGI call before it sets up a PHP script. You're talking about optimizing the set-up and tear-down portion of this, by keeping the PHP script's opcodes cached in memory, by keeping the web SAPI processes running, and doing a more thorough branch compilation ahead of when it's called and cached by using a JIT. Your paradigm is still based on handling individual HTTP requests as separate entities (which they are; only the session should join them, as HTTP itself is rightfully stateless). Rican is wishing for a completely different paradigm from HTTP, which is more connection oriented (such as Websockets) or specific event oriented (such as responding to autocomplete requests).
As someone who has contributed to PHP before, this is one of my major concerns. Change becomes a lot harder.
&gt; You're talking about optimizing the set-up and tear-down portion of this, by keeping the PHP script's opcodes cached in memory, by keeping the web SAPI processes running, and doing a more thorough branch compilation ahead of when it's called and cached by using a JIT. Well yes, JIT wouldn't be much use if the process exited each time now would it :-) ... so it's a good job it doesnt.
https://www.unphp.net/
So much this. I can't understand how people like to write PHP tags everywhere.
mPDF is the best I've used recently: [https://github.com/mpdf/mpdf](https://github.com/mpdf/mpdf)
Your understanding of these concepts is appreciated. The example I was using, however, didn't exclude an HTTP server from being implemented in that manner. HTTP server applications built in other languages and on other runtimes often are long-running single processes that handle each incoming HTTP request in a new thread or on a "green thread" (co-routine; sometimes runtime scheduled/abstracted). This style of web server development is something that PHP developers typically are abstracted away from, via PHP-FPM or a similar SAPI, but its otherwise quite common.
Last project was a Laravel project, and I found dompdf to be the best tool for that particular job - someone had written an extension that allowed it to compile pdfs from laravel blades, so it was a cinch to roll it into the project 
I’m gonna make a radical assumption here and get severely downvoted!!! I assume that php has not learned from past mistakes and is going down the same road. In ten years I’m sure we’ll be asking why do we have a jit compiler. Php is written in C and C is fast, so why throw another layer in there? Unless I’m missing something oh so vital that we must have a JIT compiler 
Because a lot of people, not saying this developer is, comes from laravel where you don’t have to learn anything other then the basics. Makes for, in my opinion, a shitty developer when they refuse to learn new concepts or “proper concepts” what ever those are.
Maybe with a JIT sodium_compat could [implement Argon2i](https://github.com/paragonie/sodium_compat#features-excluded-from-this-polyfill_. Maybe with a JIT phpseclib could [support encrypted OpenSSH private keys](https://github.com/phpseclib/phpseclib/issues/1082#issuecomment-396122366). Just because areas where PHP could benefit aren't immediately obvious doesn't mean that they don't exist or that the only instances where you'd need such speed increases are purely academic.
Funny because I went from WordPress to Laravel which are probably the 2 worst with not having to learn anything new. I love learning though so still learned Python, Go, Groovy, TS/Vue, and Ruby plus various other DevOps tools/DSLs. Probably makes me a jack of all trades and master of none but I feel like I learn new tricks/concepts every time I work in a different language and those skills can usually transfer. 
This is the list of active ones in my current project, most are to make working with laravel and vue easier. Same are experimental, but if you read the descriptions it gives you an idea if you might need it or not &amp;#x200B; bmewburn.vscode-intelephense-client abusaidm.html-snippets amiralizadeh9480.laravel-extra-intellisense cjhowe7.laravel-blade codingyu.laravel-goto-view dbaeumer.vscode-eslint dweber019.vscode-style-formatter ecmel.vscode-html-css eg2.vscode-npm-script Equinusocio.vsc-material-theme PKief.material-icon-theme esbenp.prettier-vscode formulahendry.auto-close-tag formulahendry.auto-rename-tag Gruntfuggly.todo-tree lukasz-wronski.ftp-sync MehediDracula.php-namespace-resolver mikestead.dotenv mkloubert.vscode-deploy-reloaded mrmlnc.vscode-apache octref.vetur onecentlin.laravel-blade patbenatar.advanced-new-file remimarsal.prettier-now robinbentley.sass-indented ryannaddy.laravel-artisan sasa.vscode-sass-format sleistner.vscode-fileutils spook.easysass stef-k.laravel-goto-controller wuwei.upload yukidoi.blade-runner
&gt;Instead of using short-lived share-nothing architecture, we can now use tools like Swoole and PHP-PM and avoid framework bootstrapping. I tested both, they are amazing! I haven’t had a chance to play with Swoole or PHP-PM yet. How do these avoid framework bootstrapping? Are you just suggesting an immutable bootstrapping of the framework with an async server reusing this for subsequent requests? Doesn’t 7.3 include a caching layer for this now without the need for async?
More real performance numbers are around 13 to 20% on preloading. Somebody did a real world test on their company source code and that was the gain they got. You get more gain, the more heavy the framework is that you are using ( translation: Too much junk being loaded ) This is performance you can already get for free when switching over to Swoole/Amp or already existing PHP extensions, that hold the PHP files into memory. Hell, Swoole gives you a easy 300 a 350% performance increase without waiting for PHP 7.4 Preloading ( useless for Swoole ) and whenever PHP JIT will come. The issue is that JIT does not provide a lot of real world performance increases. JIT has been under development for the last 10 years on and off. Multiple tests of JIT got the same issue: Great for synthetic benchmarks where your comparing PHP to a compile language or other JIT language. But in real world performance, it did diddly squat because how PHP works. Most of the code that PHP runs is C code already. Its only when you write big / long lasting cumbersome pure PHP code, that you will see some benefits ( like manual image processing in pure PHP code ). The real issue with PHP is simply its design: **Load classes/resources**, process requests, **stuck waiting for IO**, render result, **dump all that performance**, ... repeat. And trow in also the whole Webserver -&gt; FPM or whatever interface communication. PHP 7.4 Preloading will take a small bite out of the **Load classes/resources** issue. JIT takes a small piece out of "process requests" but again, it does not solve it. Swoole has shown that if the PHP developers are serious, they need a nodeJS like management build into PHP. Aka, develop the build in test webserver to a full fledged solution. Build in Async IO. In memory keeping of processes... That is where the real performance is, as Swoole has shown. When Swoole even beats the current darling of Webspeed Go, it shows that PHP its C code is actually extremely well developed. https://www.techempower.com/benchmarks/#section=test&amp;runid=b25eefae-1b06-4fda-ad8b-c825b05bb70b&amp;hw=ph&amp;test=fortune&amp;l=zijnjz-7
Make your own. It's as easy as a DB query.
I feel you do not understand where the performance issue with PHP are located. Even if PHP has a JIT that keeps the optimizations in memory ( say also hello to even more memory usage ). Those optimizations are only part of the bigger performance issue. We already have a PHP JIT ... its called Facebooks HHVM. Notice that even with a JIT, Facebook their HHVM is the same speed or slower then PHP 7... And Facebook has plenty of smart people that worked on on this for years. People see the speed from some JIT results and start dreaming that JIT is a magic bullet. It is not. It can give a large speed increase in very specific tests but in the real world PHP ( and HHVM) have other issues that limit its speed. As Swoole and other solutions have clearly shown.
I have made a website without using a framework. I would like to add comments to some of the pages, without having to use a third party comment system like Disqus (because of adverts and privacy). Are there any solid comment systems out there? Or or am I probably better off just coding it myself? Preventing spam would probably be the biggest issue.
I recently had the same Problem. I use domPDF + Teig for rendering of the template. Its awesome, can recommend :-)
Up-voting your comment because its correct. I see people not understanding what JIT really is and how it works. They think its a magic bullet and while it can speed up some very, VERY specific tasks, on the global hole for PHP, it does not. We already have PHP JIT ... Do people forget what Facebooks HHVM is???? PHP 7 closed the gap and with every release PHP has been increasing its performance. But the real issue are not the JIT. Its the way PHP works with its fire-and-forget behavior. Its IO blocking. Those two are the real barriers in PHP performance. Swoole by keeping PHP in memory and non-blocking IO, shows a 350% speed increase. That alone proves where the real issue is. The main problem is, that going this route means fundamentally altering how PHP is hosted. And that is a big issue for a lot of the existing software, that is totally not designed around long running processes and async io. Its also the reason why PHP Core developers prefer to keep this approach out of PHP and they simply point to Swoole.
Curious. What privacy? They're all public comments, unless Disqus employs user tracking. As for ads, I know they need to monetize somehow. It may be that you could pay a monthly fee to go ad-free.
???? 
I shall see about profiling my own organisation's codebase on it when I have a free moment to set up the docker images, in particular I'm curious to see how some of the microservices will perform, especially as they're already well optimised as they're designed to get hit 5 to 10 thousand times per second and are CPU bound. 
There is also [https://github.com/KnpLabs/snappy](https://github.com/KnpLabs/snappy) that I've used before. and would recommend.
It's fairly easy to roll your own, to deal with bots use google captcha
&gt; Which increases developer interest and brings in a wider pool of potential contributors This may be true for your PHP applications, but it's totally incorrect for a project as complex as PHP already is. The learning curve of today is steep, to make changes to the engine of right now is hard enough, it takes very many people to work on things like typed properties or scalars on function boundaries, over the course of many years, many hundreds and hundreds of hours. There were I think 5 attempts at scalar types on function boundaries ... 5 ... That's today ... The PHP of tomorrow is looking much much bleaker to me, if it is in fact going to be tomorrow (or too soon) ... The fact is that unless you have experience in writing and maintaining a JIT compiler, you are lost in the internals of one, you can't introduce new language features, you can't find bugs in a useful way (somewhere in this 50k LOC, something goes wrong). We will need a button on bugsnet that just assigns almost every bug to one person if the JIT is pushed upon us too soon. Things will change, internals are as excited about this as everyone else, but nobody is paying most of us to work on PHP, we have to squeeze it into normal life and normal work. It will take time for that change to come, and I very much hope that come vote time, voters think carefully before erecting a brick wall in the way of progress. There's a lot of confusion about what a JIT is good for ... WebSockets are not a thing that can be helped with a JIT in general, they are by definition not CPU bound but I/O bound. A JIT can help *some* CPU bound code go faster, but it does *have* to be CPU bound PHP; You may be able to measure a difference in some cases for applications that are in general I/O bound, for example an HTTP2 server that implements [huffman](https://http2.github.io/http2-spec/compression.html#huffman.code) in PHP may well see a measurable increase in performance *for that part of the code*, but help your I/O go faster *it cannot*, except as a side effect. Arguably, there's a lot of code in use in the ecosystem that is CPU bound, for example almost anything in the security field is clearly CPU bound code, however, it is mostly not written in PHP, and there is no meaningful difference between calling such code from the VM, and calling it from JIT'd code, the result is the same, control is taken away from Zend and returned when the CPU bound work is complete, the CPU bound code already having been run on the CPU directly because it was an internal function. When it comes to opening doors to other use cases, this is absolutely right, or it should be. However, as a result of this being written by one person with a very narrow focus, the JIT doesn't work on Windows, it doesn't work on Mac, it doesn't work on some fancy server architectures, and it's not thread safe - any one of those things may seem unimportant to you, but the fact is PHP supports every one of them today, so talking about widening scope is not really realistic, it does precisely the opposite, it narrows the scope of PHP in general in it's current form ... Of course, this is another thing that will change, but not without time and careful thought, and lots and lots of collaboration.
/*here you go*/
&gt; Laravel which are probably the 2 worst Laravel is not a bad framework. Its just very easy for new developer to get stuck in that mind set of "well this framework does this for me so who cares what happens down below" WordPress on the other hand ... Jesus. Nough said.
Yeah I like laravel a lot. I actually use lumen most of the time now. 
It gets worse when you get into more complicated templating. Do you suddenly require the need for multi level caching? &amp;#x200B; With plain PHP this is where it falls apart, because now you will be storting bits in variables to store in cache and check if something is in cache etc etc. With volt {% cache 'key'%} Your template for {{ product }} {% endcache %} and the output is then cached so you dont need to re-render a block which doesnt need re-rendering until 1 hour later?
Disqus employs extensive user tracking.
Proper security/auth isn't, sadly.
&gt; As someone knee-deep in a long-lived WebSockets-based server process, JIT is exactly the kind of improvement I am hoping for from the next version of PHP. The fact that you're having something long-lived is irrelevant for JIT. It's attached to the opcache. Also currently it is not adaptive, thus it doesn't learn about your hot path or anything (which it also could in a short lived request world) The relevant question is whether your scripts are CPU bound. If your websocket server mostly does IO by forwarding data from/to another backend service (database or something) the gain is minimal.
My project is very much CPU bound, as I'm having to matchmake up to tens of thousands of concurrent users within very narrow parameters, of which any one of those possible combinations will not be valid for our use case and will require trying a slightly different combination until our parameters are satisfied, over and over again for essentially all eternity. And while I'm not arguing that the JIT is a panacea that will solve all problems, I do think it's a good thing that it is a focus for PHP moving forward especially because of issues like the ones you're raising, in that it is opening light on problems with how the engine is structured and the overall complexity required to introduce new features. The mere fact that it is breaking so many things will prevent it from reaching wider use without addressing those fundamental issues. For companies whose use cases would benefit from JIT, they now have an impetus to get involved and support the engine development further whereas the innumerable number of business and developers that use PHP in its current state already ignore it unless something breaks their particular application, in which they just go complain in bug reports.
It's not I/O bound even remotely.
No, it's not about long lived or often used code paths per se. The question is whether your application spends notable time on CPU doing calculations of some form. If your code has a long running loop with database calls JIT won't have any effect as all time is spent waiting for IO. But even for CPU bound tasks a JIT won't neccisarily bring benefits. Maths like the Mandelbrot demo are very good candidates. The less maths, the less effects.
There isn't a whole lot available. I've used [HashOver](http://tildehash.com/?page=hashover/) on a couple of my sites. Very light-weight and easy to integrate. I did not try [Commentics](https://github.com/commentics/commentics), but it looks interesting.
&gt; For companies whose use cases would benefit from JIT, they now have an impetus to get involved and support the engine development further No company (AFAIK) currently supports PHP engine development by donating engineers to PHP's development. It doesn't make good economic sense - why have engineers work on something that won't pay off, if at all, for a couple of years? Super large companies can afford R&amp;D, but even then the efforts are normally for the betterment of the company, not some wider goal.
That stinks.
If you look at the techempower benchmarks you see that Php frameworks are very slow, and with a JIT engine they could become much faster. So probably normal web apps can benefit quite a lot from a JIT. Whether they’ll benefit a lot from this JIT in particular however, I couldn’t say.
The risk of drastically reducing the people who can work on php and increasing the time these people would need to implement fixes/features after implementing these changes seem to be way too big. Sure almost every risk is associated with some benefits which many have already mentioned but in my company if I would have to do a risk benefit analysis the result would probably be that such a implementation would not be approved. I already feel the entrance for new maintainers is quite unappealing (although a lot of this could be changed through better documentation and "marketing").
Companies only provide resources to projects that are directly benefiting them, hence why early Facebook drove so much to try and improve upon the language. Once it gets to a state where it meets their needs as they are, they won't be incentivized to continue devoting resources to it. PHP's current state is more than good enough for exactly what it's currently being used for, hence the lack of outside contributions. By opening the language up to new use cases you can spark new interest from companies who would now depend on those performance improvements and functionality gains, otherwise stagnation is the most likely result. If a project only does what is most comfortable for the current lot of developers that are working with it, than it will inevitably die. It has to be able to attract fresh blood by solving new problems or old ones in a better way.
Exactly. And why I stopped using it for my sites, even though it is the most unintrusive way to add commenting functionality. I still haven't found something as good as it. But I value the privacy of my users more than the features it provides. :)
Notepad++ Nah. Jk. It's definetly Phpstorm.
https://docs.php.net/wkhtmltox https://github.com/krakjoe/wkhtmltox
True, but in this case its more meta. they obtain all kinds of neatly packaged information to sell about you, all neatly organized. if you are not paying for the product you are the product etc. Can someon find your reddit comments? sure. How about every comment you posted on the entire internet in one click, organized by category, number of total users, url, average participation, etc. companies using datamining and AI no doubt love this. End of the world? no, but I dont exactly like it either.
I now use VS Code, I do no longer see the need to use anything else. So many extension.
Mixed bag. I'm not going to advocate secuity via obscurity, but I worked on an old custom website that had a from scratch forum. md5 for password hashing, no mysqli, etc. 200k users and has existed since 09 without issue. Is that a good thing? obviously not, but if realistically 10 people are going to use it why overthink it. I rebuilt part of it in symphony for fun and the live forum had pagination errors, missing comments, and workarounds galore lol. It only became obvious testing/ comparing. I'm also not advising recklessness.
&gt; Nonsense. Of course the IDE/compiler/interpreter can understand a simple declarative syntax like function a() from $foo. In fact, it improves the ability for analysis and reduces the chances for human error when the intent is a straight proxy method. While PHP is quite smart, hands down, smartest of all IDE's in the ecosystem. It's not an issue of not understanding. It's an issue of not knowing what your parent class effects without checking for all usages. Making refactoring quite scary practice as it requires common check for usages. While it may highlight something in child class which inherits the interface, it won't highlight anything in parent class. Second problem, unit tests won't help you, as you cannot easily mock an inherited method. Inheritance is coupling. And put it simply, if you cannot test it, you cannot use it. Anything else is really unprofessional. Unless you are going to write a test for each child separately, and that's quite insane frankly. Not sure where you get an idea that I praise Go. I don't really like the language, but I'm aware enough to recognize it's traction. I used it as one of the examples of 'new wave' languages which have no necessity to keep the BC promise of old with malpractices. However, I do play with Rust quite a bit. It has traits as zero cost abstraction. And while it's a bit messy way to achieve code reuse Rust has something PHP doesn't. Very, very strict compiler. So many of the issues I'm presenting aren't a problem. &gt; Every language has slightly (or vastly) different approaches to the problem Yes and some are worse than others. This naive view that right tool for the job in attempt to smuggle an idea that each and every tool has it's benefits praises the tool creator as an infallible, I don't deny context and I've explicitly mention that with Rust, however, not all are like that. The idea by itself is bonkers. &gt; Those are 3 methods you need to implement on an object Interfaces. Pass dependencies as arguments which can be tested separately from abstraction.
Thanks.
TCPDF: &gt;https://tcpdf.org/examples/
&gt; By opening the language up to new use cases you can spark new interest from companies who would now depend on those performance improvements and functionality gains This isn't how companies work, though - rather than devote time to improving a language, those companies are much more likely to just use an established language with a large existing userbase.
Good man!