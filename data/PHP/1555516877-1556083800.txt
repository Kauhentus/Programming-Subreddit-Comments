I love this analogy :)
The guy who doesn’t even understand what he’s looking for is calling the “code person” a moron. People that work for idiots write idiotic code.
You should still be able to form a \`fn($a) =&gt; fn($b) =&gt; $a + $b\` though, right? Arrow functions are limited to one expression. And in that case, it is one expression - it's just an expression that returns a function that also returns an expression.
Why did we not go with: `($x) -&gt; $x * $y`, like JS did? Is there a reason we cannot use `-&gt;` in php? I feel `-&gt;` would be nicer than `=&gt;`, since `=&gt;` is mostly used in associative arrays. *Waits for the downvotes*
Great name and news :)
I'd say that Zend Framework is not really relevant as an 'application framework', or at least not compared to Symfony/Laravel. However, there are quite a number of very popular and great quality packages under the zendframework umbrella, like [zend-diactoros](https://packagist.org/packages/zendframework/zend-diactoros/stats) or [zend-eventmanager](https://packagist.org/packages/zendframework/zend-eventmanager/stats). Most of the zendframework packages are designed to be used independently. Ofcourse, there is also a ton of ZF1, ZF2/3 legacy projects out there. We still migrate about a dozen large ZF1 projects each year. All in all, I think it is great to hear that efforts are made to properly build a foundation around the ZF ecosystem.
Thanks! I've never shared it before and it's good to hear that it made sense to others besides myself.
It's all explained in the [RFC](https://wiki.php.net/rfc/arrow_functions_v2). There is a paragraph about using `-&gt;` called _Using -&gt; and --&gt; as arrows_. The RFC authors have done a great job analyzing all possibilities.
$a ? ($b): Type ==&gt; $c : $d; it's already gone too far.
It needs a 2/3 majority, right now it would pass.
Not _everything_. You're still free to define the expectations that return real objects. In fact, you should probably avoid using mocks for data (e.g. value objects, entities). Using mocks as the only approach for tests will just lead to tests that are brittle.
People are definitely going to abuse this feature purely because it reduces the amount of code. I'm waiting for the first hacky 'solution' around the single expression limitation. Thankfully, as far I can see, you can always turn an arrow function into a normal anonymous function without BC breaks.
Why did you write this instead of spending your time encouraging someone else who did build their own framework?
&gt; PhpSpec is slowly dying: https://packagist.org/packages/phpspec/phpspec/stats I wouldn't use the term "dying" yet. However, the loss of the popularity is a shame since I consider phpspec to be a vastly better choice compared to PHPUnit or Codeception when it comes to unit testing (I have a strong dislike for assertion based frameworks in general).
It looks like even Symfony makes heavy use of `@` to protect file the operations against race conditions. Example: [FilesystemTrait.php](https://github.com/symfony/symfony/blob/master/src/Symfony/Component/Cache/Traits/FilesystemTrait.php). &gt;@mkdir is shooting yourself in the foot from a feckin' cannon. Yes, true. But how would you solve such an problem with PHP then? Any better idea?
Readability: "fn" sounds like f'in - which is short for 'fucking'. So 'Fucking item equals or greater than item less than 10. The is nothing that explicitly status that anything is returned from this, which is annoying.
To ask the questions I did.
I did not even see that to be honest with.
All functionality in PHP belongs to an extension. I imagine that most libraries you could write in PHP could also be implemented as modules; here's a [hello world](https://github.com/p810/ext-hw) extension I wrote last month. One real world example that comes to mind is the async framework [Swoole](https://www.swoole.co.uk/). Performance and access to low-level code are two examples of reasons one might write a module instead of user land code.
&gt; How do you honestly understand this `[[]+[[0][0]]][0]{[]}``What a fucking mess.
&gt; So you roll your own. The community sais no, do not do that. Or they come back and say "great learning exercise." That's enough fuel for me to keep going and improving with my product ;) &gt;Would it take off? No. Why? because I am nobody (even if I released with full test coverage, 100% documentation and use cases - similar to laravel). Here's the thing. If you want your framework to take off, you have to dedicate time and resources to make it fly. It is not just as "I made something. It is good, let's all use it". It is about trust in a product. I use a framework (or a hosting service) that I know it will not die in few months because of lack of time/interest/support. If I use a new framework, I have to make sure it is not just an experiment. I need to know the person o people behind it are committed to improve the framework and give support for x amount of years. How will I know that? Well, I check their development roadmap, their source of funding, and how often are they planning to release LTS version of the framework. Would the new framework be able to give a support policy like this: https://laravel.com/docs/master/releases#support-policy
This is how all arrow functions work, and Rust (one of the most loved languages) already uses fn to define a function, so it's not all that weird or unknown. I would have liked to leave off the fn like other languages do, but it's understandable why they didn't if you read through the rfc because of existing usages of \`=&gt;\`. A single expression means it returns that expression, f =&gt; x returns x, you can always explicitly declare returns too: \`f =&gt; { return x; }\`
Going Laminas is a big change, I wish you the best with it. &amp;#x200B; Just a few words: I've really enjoyed working with expressive... especially how much care you put in the architecture. It's brilliant, very decoupled, easy to test... I particularly liked the way you keep using .php plain files for configuration. Not too much magic. Easy to refactor. Swoole support is nice to have. And I feel expressive is a really good framework to be used with it. I love MVC, but thinking in middleware has its place for sure. Dependencies are injected where they have to, and it's often easier to work with it. This is a very different approach for symfony, lumen... both have pros and cons. I don't know your plans, but I would love to see more adoption of expressive. Few point that I would have liked to start with: \- The factory boilerplate: I see there's AoT with zend-di, but I haven't found it at the first place. I think it should be the recommended way in the doc, as well as zend-servicemanager. Should be the default imho. \- A more complete skeleton with auth, session, oauth, doctrine... eventually a way to "opt-out" what to you don't need. I know it's easy to add, but facilitates adoption. People looking for a base framework can still remove what they don't need. \- Middleware/Handlers dependencies on request attributes.... Is there any way, recommendation to declare those dependencies (i.e. an handler requiring an authentication attribute). That would be fantastic. &amp;#x200B; Keep up the good work and thank you.
My suggestion is generally just to ignore naysayers. Most people are pretty tribal. In a society where realizing your potential can be difficult given the socio-economic circumstances, many people come to express themselves by adherence or allegiance to what is already established. This is as true for PHP frameworks and libraries as it is for sports. Make sound, well-reasoned technical decisions. &amp;#x200B; You can generally get a better idea about how well you're doing by how shallow the criticism is. Also, not every framework/library solves every problem for everyone and criticism tends to be louder than acceptance.
Javascript uses `=&gt;`, not `-&gt;`. Beyond that `($x)-&gt;` could be calling a method on `$x` in PHP.
Because there is no need to reinvent the wheel. If you can bring something really new to the table, it will take off. If you do the same thing but in purple, we won't bother learning it. Make something because there is genuine need for it, not because you have the urge to make something.
Well my comment was more of a joke. On the other hand, this seems to become more an item that is border lining on language inconsistency where fb is a function, but not a function and also starts to remind me of short tags (which that shouldn't have become a thing IMHO. Question mark equals what? Oh echo...)
What on earth is accounting for 400,000 downloads a day? Given that in total there are under 100 million WordPress sites in existence, the download numbers for Zend seem completely unrelated to actual usage.
&gt; cool design patterns for end developers Why would it magically allow for "cool design patterns"? It's a syntax. Cool design pattern is often shorthand for "obscure trickery", which is not a good thing.
This is why Python is so popular, despite it's glaring flaws.
Thats not how a lot of frameworks started, they solved a fundamental problem yes but they did it because the creator wanted it that way. So your argument falls apart on that principle.
You are completely right &gt;.&gt; - I had a brain melt for a moment.
Zend is actually doing very good, 3rd place in trend, 2nd place in absolute downloads numbers last year: https://www.tomasvotruba.cz/php-framework-trends/
I get what you're saying. However, I think the short open tag, meaning `&lt;?=` not `&lt;?`, is actually very useful when using PHP as a templating language. I've never seen it used anywhere else outside of templates. `&lt;?php echo` is pretty verbose when you have to write 50 variables to screen in a template. While having fn and function adds two different ways of "doing the same thing". They are functionally different in regards to scope. Closures are a very powerful language feature that opened up lots of possibilities for developers, so making them simpler and now giving the option to implicitly include variables from the parent scope makes them more similar to how other languages operate and easier to nest closures, while keeping the explicit option available. The explicit use(..) of function() is very useful in some cases, so I like the fact that there is a way to do both.
"That way" is exactly the something new. Don't make a clone of Laravel or Symfony, don't make yet another guzzle or composer, but if you can solve an existing problem in a different and compelling way, people might be interested.
I don't understand much for the post. What will change for me as end user apart namespace name in 2020?
Your logic somewhat falls apart though when you look at... all the frameworks out there. It seems like (not being facetious) you are the one who’s saying there can be no more frameworks, that there is just enough frameworks out there that there isn’t room for another. While I do think Symfony is pretty much “the” PHP framework, that’s not to say there’s things that presumably couldn’t be improved upon in a new framework that someone creates. Just look at the decision not to follow a certain PSR, what if the creator of said new framework does want to follow PSR to the T?
Sometimes you don't need a framework. There are libraries for almost every use case out there. And pretty much every part of Symfony or Laravel can be used standalone.
If they promoted it here we, by we I mean the community, would rip them apart for not following PSR to the letter - regardless of reasons. I have seen it done before.
I think removing, from my example of "cloning laravel" magic - which people hate - would be solving a problem - one of many. Again it was just an example.
Awesome!
I find it funny that if you look at PSR, it's like no short tags, but short echo is fine. When you've been working on so much legacy code and you see the mix of &lt;?, &lt;?php, &lt;?= and &lt;?php echo all through a file, it makes you wonder how much time you have had to do to in-brain look ups. Also PHP as templating language was great when I first started with it in when PHP 4 was released. It lowered the bar of entry. Unfortunately, I think that is one of the top 5 things that made a lot of people say "PHP is awful". While being able to do the exact same thing 10 different way is nice, but part of me thinks that having it at the language level (not logic implementation) isn't a good thing, since it just adds more to remember. echo() vs print() comes to mind (I know there are very slight differences between the two...). I think some things for brevity is overkill, while some are nice, like array() to \[\] make more sense, since array() isn't a function and \[\] just feels like a data structure. Maybe I'm just old and crabby.
It's probably about the way they count: &gt; it has over 400 million lifetime downloads of all packages associated with the project, The framework itself has 61 packages (see: https://raw.githubusercontent.com/zendframework/zendframework/master/composer.json ) and if any of those are used in 3rd party projects they get counted as well. It's as if Symfony would add all those Laravel and Drupal numbers because they used one or more of Symfony's packages.
Appreciate it.
I think the biggest thing you need to think about is r/PHP is definitely not the same as the greater PHP community. If I created any open source code today I would pick other ways of marketing it outside this sub as it's pretty toxic all around.
The "magic" is one of Laravel's selling points for many of its users, particularly the junior ones, though. It makes the learning curve much easier and preserves them from the complexity. And the other, more experienced Laravel users already know how to use it without any magic. So removing the magic from Laravel is not really a problem in need of solving. Now, if you mean making a framework as easy to learn as Laravel is for less experienced devs, without all the magic and while keeping its other robust qualities, then yeah of course. But that is a Unicorn.
&gt;would have an immense impact on my day-to-day programmer life How? Can you give me some examples? I'm genuinely curious, as I would probably never use them that often at all. I find the readability too low and it limits my desire to want to comment the absolute crap out of my code - lol.
That's a cool RFC! Can't say how many times I've been confused, not knowing that something is passed by reference. How realistic is it to emit a warning when the `&amp;` is missing in a few years?
So basically just writing your own code in c and php just abstracts this code much like how php already is structured ?
So basically just writing your own code in c and php just abstracts this code much like how php already is structured ? Like if you need to interact with some custom hardware on the os you would write it in c and make it a php module and bam your php code can now interact with that device ?
I think I like version with `fn` keyword more than popular one. I believe syntax highlighting will make it stand out from other arrows and parenthesis and help readability.
I look forward to implement this in AST and php-parser
Ergonomics can impact which design patterns you're willing to use, though. Imagine this: You want to create a tree with arbitrary transformations. You have a tree of numbers, and you want to add 5 to each number, then double it. In the current syntax that'd look like \`$tree-&gt;apply(function ($node) { return ($node + 5) \* 2; })\` But if you wanted to expose an API that let you compose the functionality from smaller parts (which is always good), you'd start to get crazy syntactic noise. \`$tree-&gt;apply(\[(function ($node) { return $node + 5; }), (function ($node) { return $node \* 2; })\]);\` In the new syntax that looks like: \`$tree-&gt;apply(\[fn($node) =&gt; $node + 5, fn($node) =&gt; $node \* 2\])\` Higher-order functions, functional compositions, continuation passing, and many other successful design patterns become quite a bit nicer to look at. You *can* implement things like that now. You technically can do it in C with function pointers. The PSR really doesn't like one-line functions either, so it can really reduce a lot of noise in places where these patterns are used. Obviously you shouldn't shoehorn functional programming into places it doesn't belong. The places where it is used will get a lot cleaner.
Extensions for PHP 7 are very similar to those written for PHP 5. Of course, there have been changes to the Zend API, even between minor versions of 7, and some things are notably simpler (for example, no fumbling with object handles). Unfortunately, much of the documentation out there is outdated; I've found that going through the built-in module source code is the best way to learn. There are also some good, up-to-date, and relatively straightforward extensions worth checking out (e.g. [ds](https://github.com/php-ds/ext-ds) and [decimal](https://github.com/php-decimal/ext-decimal)). While performance is certainly improved in PHP 7, some things simply cannot be done in pure PHP. My experience with Zephir is mixed, at least on PHP5 - the learning curve is very low, but the additional dependencies and effort don't really justify the performance gains (which can be anywhere from decent to nonexistent). I have some limited experience with PHP-CPP on PHP 7, but you still pretty much need to know C.
Yeah, your example is perfectly valid.
&gt;Of course, please correct me if my assumption about people not actively maintaining PHP is wrong, I wasn't able to find a list with all people who are eligible to vote, and I don't know in detail about what those 71 people do in regards to PHP Reading through your posts, it seems like you're trying to gatekeep the voting/decision making on language changes, which is a slippery slope that ends in plummeting adoption rates.
Heya! I used to maintain a storageless CSRF implementation at [https://github.com/Ocramius/PSR7Csrf](https://github.com/Ocramius/PSR7Csrf), but stopped after `SameSite=Lax` made it redundant. How does this library compare to `SameSite=`? Is it still needed, if you can assume that the clients will have `SameSite=` support?
Well, they do in fact count those ;-)
Not much: this just makes sure that the framework is in good hands after the company that sponsored it for so many years moves on.
I just read something earlier from Phil Sturgeon (I think is his name) about this. I might be butchering what he was saying (I'll look through history shortly and see if I can find the link) but he suggested rather than re-inventing the wheel with so many options, why not contribute to improving existing frameworks and kind of pooling our talents, time and resources together to make much better products. I can agree with that, especially those who work in the professional php world. &amp;#x200B; I would likely very rarely contribute to large projects like Symfony or what not because I'm not familiar with it, good enough to do so, nor share much the same end goal as they do. I prefer my code as small and efficient as possible, which usually means things are sacrificed here or there or don't cover every available option, unlie many large enterprise level frameworks. &amp;#x200B; But, to each his own. If you enjoy writing new stuff, then go that route. It's never a bad thing to hear anothers point of view.
I would very much like to read what he said in his post if you can find the link
It was more of an example then a "Im going this route" - an example to make my point.
I see, thanks
It is dying, just compare it to other similar-level testing frameworks: https://www.tomasvotruba.cz/testing-packages/
because I don't have a tardis and it's no longer 2018.
https://philsturgeon.uk/php/2014/10/20/php-wars-attack-of-the-clones/
This, basically. The apps I work on have severe time / performance constraints, where if a request takes too long, the request time is wasted. (Think live video where a chunk received too late is already behind the manifest time and causes missed chunks or buffering). When I first started all I knew was PHP, since then I have gradually replaced around 45% of our code with asynchronous Rust. None of the major PHP frameworks has performance characteristics / the specific traits to write code in a way which worked with the application (when your app isn’t focussed in routes but instead on processing multiple interleaved data streams, what exists quickly falls apart). Sometimes, you need to build a boilerplate app and use a boilerplate framework is a good idea (especially if you expect others to be working on it), sometimes it’s time to reinvent the wheel or trawl packaging looking for specifically what you need.
Which is a shame, I often find that as time has gone on, PSR seems to be creating needless complexity in the name of flexibility which no one will ever reasonably need. This comes at the cost of code and design complexity, and performance overhead in the form of wasted abstractions. Sometimes PSR is great, sometimes it’s a self aggrandising layer of bull.
You forgot the PHP open tags mate, this is just gonna write your code to the page, classic beginner mistake right there
A repository is literally just like a fancy array of entities, with methods to help you put new entities into the array, and query entities out of the array, and put modified entities back into the array. Not unlike a Laravel collection, in fact. So a repository is a *collection* of entities, except the repository has the responsibility of persisting those entities in some way. Could be through the ORM, query builder, raw SQL, or maybe even a JSON document storage mechanism of some kind. The main idea is that the domain that uses the repository doesn't care how the repository persists those objects. It simply interacts only with the public API of the repository.
&gt; For example, if I created a framework tomorrow that was as easy as laravel but with little to no magic, (get rid of Route::get, Facades and make active record much less magical) Little known fact, in your `web.php` and `api.php` file : // Instead of this : use Illuminate\Support\Facades\Route; Route::get(...); // You can do this : /** @var $router \Illuminate\Routing\Router */ $router-&gt;get(...); If you look at your `RouteServiceProvider`, the `mapWebRoutes` for example, the router instance is in context where the route files are included. Route groups pass the router to the closure : $router-&gt;group(function (Router $router) {});
Yes!!! I just found this before checking messages on reddit and was reading it :D Thank you good sir/mam/person
No problem! He seems to have pretty good insight!
To come up with an aggregate of 2.4 billion.
&gt;I'd say that Zend Framework is not really relevant as an 'application framework' anymore, Such bullshit from framework fans. Zend is as relevant as Symfony and Laravel is. Laravel is gaining and Symfony is as strong as ever with Zend being just behind those two. There's likely more QUALITY applications out there using Zend than there are for Laravel. And that's not based on the framework but mostly on HOW PEOPLE USE THE FRAMEWORK...
I wrote my own simple token system with Libsodium send-token.php `&lt;?php` `$datetime1 = new DateTime();` `$datetime2 = new DateTime("+1 minutes");` `echo "Original " . $datetime1-&gt;format("Y-m-d H:i:s");` `echo "&lt;br&gt;";` `echo "Adjusted " . $datetime2-&gt;format("Y-m-d H:i:s");` `echo "&lt;br&gt;";` &amp;#x200B; `$key = "d78327a69553f6ce0330e03411efe6748a4c35cc32d96984b24577e682c66dae";` `$key = hex2bin($key);` `$message = $datetime2-&gt;format("Y-m-d H:i:s");` `$nonce = '728245456bec7218e908c306f97171608b1687426549efe9';` `$nonce = hex2bin($nonce);` `// Encrypted` `$ciphertext = bin2hex(sodium_crypto_secretbox($message, $nonce, $key));` `echo "&lt;a href=\"processor.php?token=" . $ciphertext . "\"&gt;Send&lt;/a&gt;";` `?&gt;` &amp;#x200B; And processor.php `&lt;?php` `if (isset($_GET['token'])) {` `$token = $_GET['token'];` `} else {` `$plaintext = "2000-01-01 00:00:00";` `}` `$key = 'd78327a69553f6ce0330e03411efe6748a4c35cc32d96984b24577e682c66dae';` `$key = hex2bin($key);` `// The original message nonce` `$nonce = '728245456bec7218e908c306f97171608b1687426549efe9';` `$nonce = hex2bin($nonce);` `// Decrypt our message` `try {` `$plaintext = sodium_crypto_secretbox_open(hex2bin($token), $nonce, $key);` `} catch (SodiumException $ex) {` `echo "Error in token";` `}` `if ($plaintext === false) {` `echo "Invalid Token";` `$plaintext = "2000-01-01 00:00:00";` `}` `$tokentime = new DateTime($plaintext);` `$currenttime = new DateTime();` `if ($currenttime &gt; $tokentime) {` `echo " Logout";` `}` `else` `{` `echo " Logged in";` `}` `echo "&lt;br&gt;";` `echo "Original " . $tokentime-&gt;format("Y-m-d H:i:s");` `echo "&lt;br&gt;";` `echo "Adjusted " . $currenttime-&gt;format("Y-m-d H:i:s");` `echo "&lt;br&gt;";` `?&gt;` &amp;#x200B; It just check for time validation but you can add IP address and more to validate the user.
To use a framework is cool because we don't want to reinvent the wheel and it's easy to add new members without explaining how it works. &amp;#x200B; However, a framework is, ahem, a frame, a walled garden. &amp;#x200B; So, a framework is good for some situations and bad for others. THERE IS NOT A SILVER BULLET.
Yeah, that example is one good use case for writing a PHP extension. You would use the interpreter's API to define functions that interface with your C library.
I have wrote PHP for about 14 years, started when PHP 4 was still a thing, when the coolest stuff you can use was OsCommerce (just to put in context how long I've been wrapped with PHP). I have also wrote at least one public micro-framework and I'm the one-man-army developer who makes Chevereto Image Hosting script. I've also wrote tons of JavaScript (ES5/6) and I've also used several different libs for handling JS from the old scriptaculous up to nodejs. &amp;#x200B; For today standards is just ridiculous to tell you to write everything on your own. But you should go the other way? Fortunately, you can save tons of time by using well tested and proven components which is the best thing that you can do IMO. &amp;#x200B; If you build end-user software, having your own framework is the wisest advice I can give you. Not for being in the cool kids party or to showoff your skills, is to make your daily work more pleasant for yourself. It will push your skills, you will face the task of building the prototype, learn about cycles, caveats of the language, etc. Follow that path and with time you will be clever enough to tell when you have to craft and when you have take from others.
That's not the syntax being proposed.
ok...... Why didn't you spend your time encouraging someone else who did build their own framework instead of writing the post? Sorry for the trick question... but the answer to all your questions is the same.
Wish we could just drop the `fn` altogether and have something like this: `($x, $y) =&gt; $x*$y` We have this style syntax in other languages, so maybe there is something up with the PHP interpreter that prevents us from being able to have that?
We all know what PHP framework versions are out there. But which version ones "favorite" in the framework community? Is it the last one? Is it the LTS version? The table shows a few interesting points: - Symfony 4.2 is 2x more used than Symfony 3.4 LTS - laravel/framework is pretty active across 5.4-5.8 versions (latest) - Zend 2.* is used approx. 4x more than Zend 3.*
The internals list is an open discussion forums. "Users" can push ideas and share opinions. (The openes also has downsides) They influence by convincing people with their arguments. However the decision in the end has to be done by people who understand the technical impact and who have commitment to the project. Certainly the current selection of people is a bit random, but it's also relatively fair - contribute to any part of PHP.net and you are granted an account. Picking individual projects or maintainers is tough and easily leads to political fights both in the php.net as well as the $framework community.
I think OPs point is that all we're getting out of this is syntactic sugar and this change doesn't unlock any of the things that you mentioned. As an aside, I'm really not a fan of the shortening of `function` to `fn` since it just obscures readability. It would have been a better choice to drop it entirely, that way you can have something that looks like this: ``` $tree-&gt;apply([($node) =&gt; $node + 5, ($node =&gt; $node * 2)]); ```
&gt; I am so flabergasted at how these people make a framework and release it and the communities pants get soaked. But when some one else does the same thing or attempts to - the community sais "great learning exercise, now go use Y framework." Because a tiny fraction of personal frameworks are interesting and become real supported projects, while most are uninteresting. If you think you have a good reason for making a framework, do it. The odds are against you, but the odds were against all those other framework authors too. However before you write your own framework, remember: * Do you have a reason for building a framework? What will it do differently? * Your boss expects you to use your time efficiently. Is your framework going to justify the 500+ extra hours (~$30k+ in my market) you will put into it? * Do you have time to provide documentation to developers who will support the sites you build with the framework? * Do you have time to support developers who build sites on their own with your framework? * Can you commit to supporting your framework in a year? In five years? In ten years? By all means, we need people to work on new frameworks, but a new framework is usually not a practical answer.
In my case, the style of my code is whatever PHPStorm decides it should be ¯\\\_(ツ)\_/¯ But in general, in PHP, the recommendation is first brace inline, unless you define a function with a return type.
`[($x) =&gt; $x]` is why. Is this an associative array with `$x` as both a key and value? Or is it a non-associative array whose only element is an anonymous function?
2.49888 billion. Did it really increase by 100,000,000 in the last 2 hours? :o
To me it's clearly the latter. I could see that messing with the interpreter though.
Just curious, but what could be a use case for this? I really cannot see any (not being negative)
Dreadful is the word that comes to mind. &amp;#x200B; PHP should be allowed to die. It did what it was needed -- now it's time to move on.
You cannot. You need some proper colossal moron to even consider that and put it into the proposal. But this is PHP, what do you expect? People that know what they are doing? Ha.
It's a single expression. It has no other purpose apart from \`reduce()\`, \`map()\`...
I think you accidentally a word
&gt; imagine being "forced" to work on certain things by outside control That's pretty easy to imagine, given that it's the current state of affairs for basically anyone with a job. Jokes aside, is it really any worse than an entire community being at the mercy of whatever a handful of contributors want to see in the language? Isn't this the *exact* reason people hate on Google for "controlling the web" via Chrome development?
And exactly how many people who vote on these RFCs, and this percentage, have actually managed teams of inexperienced PHP developers, within, say, the last 5 years? I bet the answer is one to none!
Have you tried Slim?
People who code in C land have no idea what their language decisions impacts have on those of us who actually, you know, use the language professional and manage teams of inexperienced, and (worse!) unprofessional, developers.
Just wait til you spend 50% of your day code reviewing others code and you'll see why this is a TERRIBLE idea!
You have to review idiots who will use it, tho, unless you never plan to be at my level professionally.
"The concept that we have something as good as a wheel right now in programming is ludicrous, we don't."
Why didn't they propose `&gt;.&gt;-`? i mean, it couldn't get that much worse!
&gt; you can add IP address and more And every phone user will hate you. Nowadays, client IP ain't stable.
Nah is it good?
I personally love it. Whenever I have a project that doesn't require the scope of laravel/symfony I reach for slim.
I concur to some degree. I for one can say that I don't use much of PHP anymore, but in the days where I was deeper involved I spent notable time reading code of varying quality, talking to PHP programmers etc. Also most people involved in PHP core came into that not as C programmers but from being users with a need. Only few come in noticing this is a platform where an academic thing can be implemented (that's i.e. how traits got in Stefan was student/reseacher and PHP was easy enough to patch) Many of the contributors are consultants (thus go from user to user) or, in their primary job lead larger dev teams or are working on improving performance of their employer's sites. But then, of course, PHP has a huuuuge userbase of very mixed quality/experience and the ones getting seriously involved are typically the ones in the higher tiers. At the same time many of those have experince with shortcomings and mistakes made in the past ... In a way the whole thing balances itself - sometimes things move fast then more and more people speak up and the process slows down, then some people have a need for change and push it and it speeds up again ... contributors come, contributors go, PHP lives on as long as people need to solve issues.
Just had a squiz, looks bloody sweet! Pretty much what I was trying to make with my vanilla make-shift micro framework haha.
Shame the `fn` prefix is practically required, but that's life. Looking forward to this. Closures get really messy, especially for functions like `array_map` where it's the first argument.
Psst... closure comes before the array in `array_map`
They really nailed the "micro" part of micro-framework and it's just so easy to extend and build around.
I personally have a love hate relationship with frameworks. In personal projects I opt for the no framework framework (use libs of my choice to basically do much of what a framework does anyways). While, yes there might be things that take a little more time to dev, but I know it's not going to filled with a lot of anti-patterns and magic slow down.
Iv been developing my own framework on and off over the past 5 years. Through that 5 years i have completely scrapped and re wrote with my learning several times. I have now reached a point where i am pretty happy with it and it does not change very often anymore and i use it for my own software products. I have had it working successfully in products for around a year now. My inspiration for all my sleepless nights in this is because in just a general sense i disagree with a lot of what the other frameworks are doing fundamentally. For example in my ORM i select fields of tables by auto generated const column names with and use intellisense instead of literal typed strings like all the other current frameworks do. My ORM: $memberRepo = new MemberRepository($app); $member = $memberRepo-&gt;GetWith([ Member::Email =&gt; $email, Member::EmailConfirmed =&gt; true ]); Doctrine: $user = $em-&gt;getRepository('MyProject\Domain\User')-&gt;findOneBy(array('nickname' =&gt; 'romanb')) I have tried to discuss what i'm working on with other php developers and get feedback on making your own framework but they talk to me like i'm a fucking maniac. I have thought about going open with MIT for a long time now but i just don't feel very pushed to because i feel like i will be examined like a weird bug more than cultivate an open source community.
If this was on github I would love to look through the source.
I always put the curly bracket into the next line. Allman/BSD style all the way! I don't care what that stupid PSR-2 recommends (coding style guides that recommend spaces instead tabs for indentation are disqualified by default anyway.) (I'm probably a minority here... :D )
Because you are smart enough to make a framework and not smart enough to make a framework that isn't going to get popped by the first chucklefuck with wfuzz.
While it would be great to see arrow functions added to PHP, don't use the =&gt; operator as it's still used for assoc arrays. I know there are workarounds, but -&gt; would cause less trouble imo.
That's pretty much why I wrote my \_own\_ framework. I certainly share it too though. Sometimes I want feedback from a larger audience. Sometimes I think others might find it interesting. Sometimes I simply think it would be \_more useful\_ than another solution. But when I do share it (including work), what the author posted certainly resonates. What I think a lot of this comes down to is what one's goals are with it. My #1 goal is creating a framework where I can use and integrate the myriad of libraries and components which make sense for a given project \_quickly and easily\_. It is a solution for me to be able to create technically fitting solutions while not being tied to any one solution, hence, the framework itself doesn't really do much. If a better caching library comes along, it's easy for me to swap it. If I don't need a caching library, it's easy to leave it out. Traditionally I think microframeworks fit this role, however, many microframeworks still had a of overhead added with respect to how to properly integrate a third-party library. They weren't super clear, configuration was messy, dependency injection was awkward. I've not looked much at Lumen, but from what I know of Laravel, I don't think I'd be very impressed. In short my \_own\_ framework does what I want and need most... flexible and robust configuration, clean and simple dependency injection, and the most commonly used basic functionality. Beyond that, it's all just whatever the best libraries I can find for the job are at the time.
The [RFC linked in the original post](https://wiki.php.net/rfc/arrow_functions_v2#sectionedit12) has a discussion on the many ways the syntax could be written and the problems with each. It's well worth reading, but yes, in short the syntax without any leading unique symbol is ambiguous with existing PHP constructs.
For this use case I'd recommend node.js
The `fn()` keyword is intended to clear p any ambiguity, as explained in the [RFC](https://wiki.php.net/rfc/arrow_functions_v2#sectionedit12). `-&gt;` introduces a different set of ambiguities, as it's the object operator symbol.
Slim framework.
Only API? lumen by laravel
I wrote a framework for myself 10 years ago and have used it on a dozen projects. No hacks yet.. it can be done. Taylor is not some kind of untoucheable code god nobody else can measure up to.
Second for Lumen or Slim, and Laravel if you want to use it for more than just an API, such as a headless CMS to manage that data.
'easy to get other people on board' is the only reason i'd use someone else's framework instead of the two i've written. And it's a solid reason.. &amp;#x200B; ..but man, i hate being in those walls.
Everyone I talk to says php is dying. I'm happy to see a more optimistic perspective
I’m hesitant to adopt nodeJS. I know it is stable and used by huge businesses. I am not comfortable enough with it to run in production. I have nightmares about npm and modules included. I read a horror story about a developer removing a basic trim function referenced in hundreds of other modules and breaking everyone’s environment that updated.
I would rather see them use an underscore _($x) =&gt; Having letters in your code makes it more difficult to quickly distinguish syntax from variables, function names, etc.
Essentially any modern (even some non-modern) PHP frameworks should allow you to do a CRUD API with not much difference on implementation time. That said, PSR-15 middleware support might be beneficial depending on how many bells and whistles you need to add between the actual CRUD operations and the requests/responses as then you can basically pick and choose functionality from a list like this: [https://github.com/middlewares/psr15-middlewares](https://github.com/middlewares/psr15-middlewares)
My experience is that going from 5.6 to 7.3 is even bigger speed difference than what he sees. But I suspect it depends on the application/type of work being processed. But man oh man is it fast. I have nothing against Python, but this notion that it's somehow better is simply untrue. If you prefer it, fine, but it's certainly in no way superior at web dev. 80% of websites use PHP, but somehow it's unpopular....
People who think PHP is dying live in a technological bubble
Mainly, it is an alternative to Javascript for people who are more comfortable with PHP scripting. Besides, WebView is now available for Go, Python, C#, Ruby, all of which are scripting languages. So why should it not be available for PHP, which has a huge developer base?
That's great. If you know what you're doing go nuts. 90% of ding dongs can't do that. They should use the #defaultoption.
I actually never use frameworks, despite everyone else I know who's a developer begging me to. Sometimes it's a tiny project, in which case it's overkill and I look with mild displeasure at anyone who thinks a three page site needs a framework, but then there's my bigger projects where I'd clearly benefit from using one, maybe. I don't, for three simple reasons: a) I dislike being forced into a specific way of working. Frameworks do this. b) I'm not a beginner, but I'm not an expert either. I'm just "competent". Using a framework hides areas of weakness from me, doing it myself means I can address them. c) It's more fun and I don't care about padding my CV. Also, though not really a main reason, I feel like frameworks might lead to inflexibility. Whether that's coming up with hacky workarounds from a limitation in a framework, or inflexibility in someone's thinking because they're too used to a framework, both are negatives.
ooops .. thanks but can't edit title here anymore
Don't think of this approach as a bug or weird approach! This conceptually reminds me of jooq and querydsl, where auto-generation plays a pivotal role in adding safety and ergonomics to the problem space that strings simply can't. If you promoted this as experimental or personal and not as a go-to solution until you are ready, I think it would be okay to share.
Do it if you want, especially if it brings you joy.
How does your ORM work with relationships? I'm using Eloquent at work but fetching over multiple tables doesn't feel very eloquant (read: elegant)
Check out symfony based https://api-platform.com
Yeah it’s all the new full stack JavaScript developers that think JS is their end-all, be-all.
who is seriously still on 5.6? answer boatloads...and yes upgrading to any 7.x branch will blow you mind.
I'd say the ones with the most active community. Outside of job offers I haven't heard anything from zend the last years. So no wonder nobody uses version 3. When I look at SO, Codeigniter seems to be a used one.
I have a generic class named Set which does a lot of preparation work around relationships. Here is an example: //Gets sales named "ProductName" with sales equal to or over 10 $sales = $saleRepo-&gt;GetMany(new Set([ (new Where) -&gt;GreaterThanOrEquals(Sale::Amount, 10), //supports nested or/and conditions (new Where(Join::Inner, Product::ID, Sale::Product_ID)) -&gt;Equals(Product::Name, "ProductName") //...infinate list of additional tables to join ]), $page, $pageSize, [ //Select which fields of base table to fetch, if empty selects them all Sale::ID, Sale::Amount ], [ //Selects fields of joining tables, strings are to define new field name Product::ID =&gt; "Project_ID", Product::Name =&gt; "Name" ]);
The reality of frameworks are developed due to naive exuberance. Don't get me wrong when I say new people when they come from substantial experience in another language they have not experienced and then suddenly can do things they couldn't before with some other language it inspires some of the best of us, and this is where being naive about a languages ecosystem is great. Being ignorant of the ecosystem eliminates hindrances of the mind to prevent that devil behind your ear from saying.. nah.. you don't need to do that, someone already wrote this out there, so you're just wasting your time. The exuberance because you've pumped up to use this new language to solve every problem you couldn't previously and because you're new to the language you suddenly start building structures to make your tasks quicker because maybe you had not thought to use some other framework or library to solve the very same problem. Ultimately people not building new frameworks is really a sign that the people using the language are very mature and are no longer hyped / pumped about building new things and throwing away a few years of their life to code day &amp; night to write this new amazing library / framework. My 2 cents.
Interpolation would look like: `fwrite($h, "$meta\n$value");`
Yes, of course. Just @-ing is a lazy butt strategy. If you want to do it properly, you can @ (or catch), **then check the error**, see if it's the expected one, and of not - re-instantiate the error and let it bubble up to whatever handler. It was done before using error_get_last() and now it is shifting towards try-catch with the same functionality
&gt; _Look at JS - they have a new library (framework) every day (not literally) and **no one harps on them**._ ahahaha oh wow --- You are correct in as far as it's difficult to break into the widely-used framework market as a new developer, but I don't see that as a bad thing. New frameworks or libraries have to demonstrate *potential* and *staying power* to gain traction. Going to your boss and saying "*hey, I found this new framework AwesomeSauce v1.0 and I want to start using it! It's so cool, we will be the first ones using it, we will have to deal with all the growing pains, we will not find any extra developers familiar with it so you won't be able to move me away from this project, the author is a single person with no track record and there's no paid support, but it's so sweet and useful and awesome!*" is a creative way to trigger a Resume Generating Event. … Assuming you work for a sensible business, that is. If you are freelancing and your contract ends in three months and you don't care how your snowflake contraption will be maintained, or you work on venture unicorn cryptoshit that could fold up tomorrow and not be missed, feel free to do whatever you want.
Honestly? If it was a regular text post I would hate it. There are already plenty of ads for jobs on Facebook, Instagram, Twitter and whatnot and Reddit is a platform for sharing content, not ads. If it's a paid Reddit ad that targets specific subreddits and demographics then sure, but I would definitely downvote a job posting as a natural text post.
I want to live in that bubble.
Symfony with FOSRest. Pretty slim framework which you can always grow into something bigger later
I've actually started referencing to colleagues it already.
Yes please
CodeIgniter which I think is a very unpopular opinion.
Lumen
I am not even sure it is stable for all use cases. If it were, then PHP wouldn't be numero uno on web even after so many years since node was released.
Maintainer for [Slim Framework](https://github.com/slimphp/Slim) here, I would suggest that you look at what we offer. In comparison to Symfony/Laravel we try to run with as few dependencies as possible which is great if you want to build a lightweight REST API. Check us out!
This one was developed by Kevin Dunglas who did ( did most of? seems to have been in charge of? ) the Serializer component in Symfony. Api Platform is really great and the way to go for sure.
None. In PHP you do not need a framework to set up a simple application. You just user _composer_ (that's the package manager) and pick the libraries that you need from packagist (that's the package repository site).
&gt;Taylor is not some kind of untoucheable code god nobody else can measure up to. Laravel is built by thousands of people at this point and exploits have been found, it has four CVEs to its name. Just as Symfony has twenty-seven CVEs to its name and WordPress has fifty-three, despite the thousands of people that worked on those. Magento had a SQL injection vulnerability discovered recently that has been lingering in the codebase for well over a decade,, across a major version bump that was nearly a complete rewrite. This is despite the thousands of contributors, multiple private security audits its received over the years and its use by huge multinationals. Unless your framework is extremely simple, it is probably vulnerable to something, just something that's required a bit of creativity beyond a naive injection technique. People who say things like "understanding security is not impossible" fundamentally misunderstand security.
Kevin seems to be a jack of all trades, he and his company Les Tilleuls have their hands in almost everything symfony related
I think you intentionally a word.
It's an unpopular opinion for a reason. Everything about it is horrible and screams "this was written 15 years ago".
PHP is dying (quite literally), but it doesn't need to be like that: [https://blog.spiralscout.com/php-was-never-meant-to-die-830de87915ee](https://blog.spiralscout.com/php-was-never-meant-to-die-830de87915ee) &amp;#x200B; With new tools coming to play like AMP, ReactPHP, Swoole, RR you can start experimenting with new models of PHP development. You had to see the eyes of RoR developers when they hear that PHP is capable to respond in under 1ms for some endpoints with the fullstack framework inside.
« composer require api » (if i’m not mistaken it’s an alias for api-platform). Api platform is crazy, you can go from nothing to functionnal api in less than 10 minutes if you have simple needs (if you need custom filters/specific serialization group it might need more time but everything is in the documentation), and api-platform integrates with varnish (just a config entry and bam, varnish cache invalidation is a go), mercury, has a front+documentation all generated without you doing anything + plenty other goodies.
What sort of strategy do you use for migrating those ZF1 projects? I maintain a horrible legacy ZF1 project and we're planning to talk to the client soon about migrating it to a newer Zend version. There's still lots of technical debt to clear up, but we need to start actively taking steps to migrate it in the near future. It already uses Composer and any new classes use proper namespaces. Most of the resources I've found were pretty vague on the subject and I'd be interested to hear how others have achieved it. The vague strategy I had in mind was: * Namespace the remaining code properly * Replace each dependency in turn on Zend 1 with its counterpart new component, eg zend-db, zend-cache * Finally migrate the main application structure Is this the sort of approach you'd take?
Just php, everything else is a pure loss of time. header('Content-Type: application/json');
Yii2, generate a crud and then use ActiveController. You just have to write one line of code per model. https://www.yiiframework.com/doc/guide/2.0/en/rest-quick-start
And guess what mister clever-man. Most of those libraries come from one of those frameworks...
Using an underscore is not possible though, as explained in the RFC, as it is a valid function name. While the other suggested/feasible characters could take its place, I feel like they'd make the code equally difficult and, to some degree, arbitrary and obscure.
There are subreddits dedicated to jobs. Some a little more generic like /r/jobbit, some more specific like /r/phpjobs (much less busy). Each likely has it's own rules and variations on those rules, but they should be similar. I would just post in there. And IMO I don't think I would care about how old the account is as long as it describes something that interests me and links to a website posting about the job. That could be to a company's website that I can use to research the company or a post on a larger job listing site. As far as ads go, I use ublock and so I personally wouldn't see them or even think to look at them for a job listing if they were there.
fixed)
Improper C programs, however, are simply rude.
Hehe, now let the downvoting brigade do their work (BTW I agree!)
We're one day into the vote, and it looks very promising!
 I think one will have to do a bit more plumbing with FOSRest than with API-Platform, but that comes with a simplified integration into the usual architecture of the full framework. (At least "knowledge" wise, since FOSRest is basically Symfony with some API extras.)
Awesome. Now you just need to add [badges](https://docs.travis-ci.com/user/status-images/)! to the README. How are the unit tests coming? Do you need help getting started?
We need to pick up an api platform as well. Currently we’re using Drupal8 but Symfony solution seems tempting.. So our options seem to be D8, vanilla Symfony with or without FOS rest bundle and API-platform. So I was wondering that how much does API-Platform deviate from basic Symfony..?
For most people, the bottleneck is the database, but every little bit counts I guess.
This differs based on personal experience. E.g. I saw very few Zend job offers in my life, but that's because I don't look for them (notice them) and I go to 2 modern job portals. Download stat removes this subjective distortions. As for CodeIgniter, it didn't get to the table due to low average day install (&lt; 1000), see https://packagist.org/packages/codeigniter/framework/stats
https://www.reddit.com/r/PHP/comments/be8d62/zend_framework_becomes_laminas_project/
good bullet list could be a cool article if fleshed out.
&gt; the style of my code is whatever PHPStorm decides it should be no, the code style of phpstorm is whatever you decide it to be...
The nice thing about Les Tilleuls it's that's not even just 'his company'. It has a special status under french law of 'cooperative' company where workers are associates, all have the same power of vote and share the benefits.
I think it should be the former for BC.
\+1 to this. I've used Slim in the past and it's pretty nice.
See [http://www.laravelbestpractices.com/](http://www.laravelbestpractices.com/) for a more extensive set of rules.
&gt;why not contribute to improving existing frameworks and kind of pooling our talents, time and resources together to make much better products It's not something I've done personally but I've read a number of stories of people creating features or improving code for let's just say a PHP framework and for those PR's to simply be rejected without comment or a genuinely valid technical reason other than the maintainer doesn't like it. That is what forces forks and splits in communities, CodeIgniter was notorious for it and what eventually lead to it falling so far behind and then abandoned by its owners when they lost interest. If they took on board peoples suggestions and improvements, who knows it could have carried on being the dominant player. It's not a phenomenon unique to the PHP community its across all the communities I have worked in. Developers are emotionally attached to their creations and some times make decisions on emotions rather than technical reasons, I understand where they are coming from it's hard not to. However, it completely dissuades people from contributing their free time in the future.
And I decided that it should be exactly how PHPStorm says it should be
A five-item list to show two ad banners. Reported as spam
Also works awesome for non-REST APIs. Routing is super easy: make crud with one command and it's like \`/your\_model/create\` that already made for you. To add new route, you just create a method in controller, no config shenanigans. The only downside of Yii2 is strong bound to its active record, but in case of most APIs, AR is ok.
ha, I'm currently working on a legacy project (\~15 years old) which still has some PHP4 code in it and is deployed on a custom built server by some amateurs that refuse to upgrade from PHP 5.2
Lumen
Man, I've wanted to setup / work for one of those co-ops in America for years. Every time I've mentioned it to colleagues over the years, all I hear is "Communism = BAD!!"
I recommend Laravel. Just leave the web.php empty and disable sessions.
If you're familiar with the general architecture of Symfony (especially the event-system) I'd say you'll quickly adapt to the difference. And that's (at least to me) is the major difference [https://api-platform.com/docs/core/events/#the-event-system](https://api-platform.com/docs/core/events/#the-event-system) (See the Action-Domain-Responder parts), additionally to some nice out-of the box supports for 'DataTransferObjects', etc. It is documented that one may use a "Classic Symfony approach": [https://api-platform.com/docs/core/operations/#creating-custom-operations-and-controllers](https://api-platform.com/docs/core/operations/#creating-custom-operations-and-controllers) I however am pretty fond of the ADR style and adapted to that pretty quickly. And of course - and I learned that the hard way using FOSRest for almost 2 years, where API-Platform really shines (again at least to me) is great extensions to Serialization supporting most (Hypermedia driven!) Content-Types out of the box!
like i said there are boatloads and I am sorry for you but, not enough to commiserate..I keep projects updated within reason 6-18 months of current unless there is a serious reason; or i am no longer part of the project ... its that simple.
I think it's really ignorance. I'm too hoping that I could one day work for a co-op or a non profit organisation.
Thanks for all your suggestions. The things I'll be looking into are the following. \- CraftCMS for building websites where it's just about content \- Directus whenever I'll be needed to build a web-app
&gt; I am not even sure it is stable (or reliable) for all use cases. If it were, then PHP wouldn't be numero uno on web even after so many years since node was released. Not really, that isn't how things work. Node could be the most stable language that has ever existed, PHP would still be the most used for small sites. For small sites if PHP does a reasonable job then there is little reason to change, which of course is made even less likely by things like Wordpress where most users do not care what language their CMS is written in. The place you see PHP losing out nowadays is larger projects, where 20 years ago PHP was picked a lot for big projects, these days it is not, things like Slack choosing PHP are a rarity.
Yeah, I save so much time by just reimplementing the same stuff in every project.
Good post, thanks for sharing your concerns. &gt; Look at JS - they have a new library (framework) every day (not literally) and no one harps on them. In my experience, devs who are very willing to try new tools and learn new things are very likely to end up using JS regularly and become part of the wider JS community, because there are many types of problem where JS is arguably the best tool for the job, and certainly the best supported ecosystem (e.g. cloud, frontend). The level of investment in the JS ecosystem by companies like Google and Microsoft is very significant and the amount of value being added to that ecosystem is huge. PHP as a language is certainly improving, but I suspect that we (PHP) don't attract quite the same number of forward looking, open minded devs as JS because, as it happens, PHP is not the best supported language for any of the big growth areas in software (cloud, mobile and AI come to mind). Nor do we receive the investment or boast the growth of JS. With these things in mind, I think that those devs who actively pursue new tooling and new ways of doing things are more likely to be working with JS than with PHP, and so I can see why the JS community might be more willing to embrace new ideas than our own community. I totally get your frustrations -- they are absolutely valid -- but I'm not sure that this is an issue which can really be affected by any conscious efforts. Rather, I feel it's the result of greater forces.
Will there be any business logic, or do you just need to persist JSON documents with an HTTP interface and auth?
I feel that most of the time this sentiment is directed to people/companies who want to make their own framework for their own products, and is often just based around the NIH mentality. The problem with doing this is that, especially if you're a company, you need people to be maintaining the framework itself and updating. The proprietary frameworks I have used in the past have been hideously outdated and horrible to use, why would you want to invest the time/money into maintaining it when, for example, you can use the work of the Laravel contributors for free? If you released a new framework that provided a reason for people to care about it, I absolutely think you could get people's attention.
This is the best answer.
Are you shitting me? Even if you aren't using a framework, you should at the very least have some kind of basic boilerplate together that pulls in any dependencies you use all the time and glues them together. I sure as hell don't have time to reinvent the wheel every time I start a project.
[removed]
&gt; screams "this was written 15 years ago". hmm. So, Old == Necessarily Bad
[removed]
Until Composer and PSR came along the PHP ecosystem was utter bilge. Every framework reimplemented the same things, test support was either absent or laughable and code reuse was painful. CodeIgniter is a relic of that time.
Somewhat off topic but I'd just like to chip in with an observation. As a PHP junior looking into frameworks I was deciding between Laravel and Yii. One thing that pushed me over to Yii is documentation. I've looked at Laravel docs as well as Laracast, but I've found Yii's Definitive Guide a lot more useful for a beginner.
&gt;I keep projects updated within reason 6-18 months of current unless &gt; &gt;its that simple To you maybe, wish I had no real technology to worry about and no function that would break. You do not choose to get stuck in an old version, it gets pushed on you.
Kids been shouting this for over 10 years now, see you in another 20 when PHP is still running the web.
Just rebuilt one at work using Lumen, which has been fairly pleasant actually. I've also used Slim which is nice and light
Why use Laravel when you can use Lumen which is much more lightweight?
Usually our test environment is 100 times larger than the functional package, like I have an error handler component with 5 short classes, I still need PHPUnit or Codeception to test it right?! So on dev I don't think it is a problem. It comes with the benefit that you can have the version you want, instead of relying on a random version from the system, which may or may not be compatible with your app, if it's locked in composer you know it will probably work. I guess my assumption came from the mentioning of the use of multiple template engines, I assumed you have one for the functional package already and it bothers you that there will be another in dev. If it would bother me that much, I could set up exclusions in PHPStorm so it doesn't suggest any classes from there, nor shows it in search and inspections etc.
at my work place we have used Lumen for an API but we are considering replacing it with Laravel, because a lot of Laravel packages that we use don't have a Lumen equivalent and can only work with Laravel
We use slim in our enterprise app. It's a breath of fresh air. So simple, clean and fast.
Why don't they work with Lumen? I can't think of many cases where a well-designed package would work with Laravel but not Lumen.
Yii2 is very good (and soon yii3)
That's what I'd do too. The node/Apollo/Prisma stack is really attractive if you want to do graphql.
There are legitimate situations where you might choose to hand roll something rather than using an existing framework but always consider this. One of the reasons frameworks like symfony and laravel are so stable are because they have drawn from expertise of hundreds of people. Security experts, software design experts, scalability experts, speed optimisation experts, usability experts etc. etc. You could be the most proficient software developer in the world and you would still not have the same level of expertise to draw from and the vast majority of developers possess less expertise than they think they do. We think we know everything because we don't know about the stuff we don't know about.
&gt; though I'd love to see more people like /u/ocramius having voting rights. He does have voting rights. So do a couple of the Symfony people, the Composer guys, and Zend framework (rip.) Most of the time they probably have better things to spend his time on than reading RFCs in great enough depth to bother voting. But it's more their feedback which is useful. If they say "this idea is going to be bad" they are listened to. e.g. the RFC for annotations failed, mostly because it didn't fit the needs of the Drupal and Doctrine projects: https://github.com/Danack/RfcCodex/blob/master/annotations.md#some-people-dont-like-annotations Although I think there could be some cleanup of the rules of who is allowed to vote, I don't think lack of userland users ability to vote is one of the problems that needs to be solved.
I recommended Symfony Skeleton (not the full one). I use it for an API that gets tens of millions of requests per day, and performs many internal management and data crawling tasks.
Zend now will be renamed Laminas.
I'm currently working on a product API @ work using Yii2. The way it all works together is just perfect. Versioning is easy, build-in filter criteria, able to expand data. Etc etc. It heavily revolves around ActiveRecord, but if you're building a resource API like me, that's not a problem.
+1, use all the time
&gt;I keep projects updated well so do I, I refuse to begin a new project on any version &lt; 7.2 but here, it's not in our hands
I was more than a little drunk last night. I didn't realize the article was talking about Laravel (reading the OP, who does that?). Laravel is fine. "Rolling your own from scratch" isn't.
+1
I guess you just read the first 3 words of my comment :) PHP model using "dying" model of execution, in which request comes as process state, once request is executed the process will be destroyed (or wiped out). So PHP is literally dying on every request. &amp;#x200B; The article and tools I mention used to bypass the dying model concept and gain x10-40 times higher performance on PHP applications by daemonizing PHP applications. &amp;#x200B; So kids can shout whatever they want, but we will keep using PHP for a while.
Slim + eloquent got me up and running very quickly with an API
Lumen uses less disk space but I guess with only code you use being auto-loaded the performance difference is small, and Laravel is more "batteries included" and has more powerful auto-configuration so it's good if you just want to get to work and not worry as much about setup. I'm mostly judging that based on differences I've seen between instructions on how to install a package for Laravel vs Lumen. I've always just used Laravel.
Just curious, how do you handle relationships? For a while I tried to build an ORM but the thing that stopped me was populating model relationships. For example, let's say an Article has a User and a User has many Roles. The `Article` class has a `$user` instance variable and the `User` class has a `$roles` instance variable. The only way I could think of populating those fields was by querying all the data when the model is created, but it would result in several queries and be horrifically slow. How do you populate relationships?
+1! We use Slim for our main organization API. It's big and crazy and complicated and Slim is perfect for creating the routes. It's lightweight and gets out of the way and lets you build your architecture however you want. If you want something opinionated, telling you how to do things, Slim may not be for you. But if you want a very specific tool for a very specific job, check them out.
Laravel or Slim Framework, depending on project size*.*
Law of Demeter broken in Usage section of docs does not look good $response-&gt;getBody()-&gt;write("Hello, " . $args\['name'\]);
Slim is awesome for this!
+1
I select compositions of models always off the back of one main model with things joining in on it. So for example if i wanted a list of people under an article with a specific role it would look like: $members = $memberRepo-&gt;GetAll(new Set([ (new Where) -&gt;Equals(Member::Active, true), (new Where(Join::Inner, Article_Member::Member_ID, Member::ID)) -&gt;Equals(Article_Member::Role, Article_MemberRole::Admin), (new Where(Join::Inner, Article::ID, Article_Member::Article_ID)) -&gt;Equals(Article::ID, 1337) ]), [], [ Article::Name =&gt; "ArticleName" ]);
For non-Symfony people, being able to specify an alias like `composer require api` is a feature of Symfony Flex. It will work if you already have `symfony/flex` as a project dependency or have `symfony/flex` installed as a global Composer dependency. Symfony Flex uses an external-to-Packagist repository to add an extra layer of goodies to standard Composer packages. You can browse Flex-enabled packages (including looking up aliases) here: https://symfony.sh/
Laravel would probably be the best framework in the PHP world. Lumen works if all you need is an API. It's a streamlined version of Laravel
Many more sites than you'd think. This week just finished upgrading a large news site to 7.3 from 5.6. We have a couple other sites that are in need of upgrading too - some running even older versions.
I'm going to suggest [http://flightphp.com/](http://flightphp.com/) \- super easy and lightweight.
Yeah, I guess you could call the database an oversized meatball and the code spaghetti for most projects that outgrow their original purpose lol which is how bottlenecks happen in the first place.
You had me in the first half, not gonna lie. die();
Thanks for your suggestion, we just tried it and managed to speed up our tests by approximately 40%. We even added an update to our blog in hope it will be helpful for others too :)
Yes, we only use it in functional and some integration tests. Unit tests should mock all database calls.
Not all PHP apps even use a database.
I would prefer the block based syntax or the Haskell syntax using the \ but I've been waiting for this RFC to pass for so long now that I really don't care anymore. I think it's good enough at this point! Many thanks to Nikita Popov, Levi Morrison, Bob Weinand for making this one possible! ❤️
I still can't figure out which one I prefer. I use [functional php](https://github.com/lstrojny/functional-php) which has them reversed. The advantage obviously being that it's easier to read. But the array_map version matches the argument order in haskell and makes much more intuitive sense. I would definitely side with the latter if PHP had true functions as first class citizens.
Well, i do agree some parts of your post, but i disagree of making your own framework: first roles: \- junior \- medior \- senior \- lead &amp;#x200B; **For junior devs** It is important to learn one or more frameworks but shouldn't create one yet **Why** This will protect you from a lot of things in php which can lead to security breaches in your code. Also most frameworks work in a certain way for a reason, mvc (model view control). Some frameworks come with an orm (Object Relational Mapper) which speed up development significantly . **For medior devs** You know at least one framework to work with but want to create your own for some reason. When creating a framework you need to know a lot of stuff about handling the data. I wouldn't recommend this, but at the end it will improve your coding skills, so yeah basically a learning experience. **For senior / lead devs** I would say, go for it if you have the time, i don't think your boss will give you the time to create a powerful framework and if you think you can create a framework in 3 months, forget it. It will take years (or you can create a micro framework probably in a few months) depending on the modules you want to get in the framework. Don't forget the documentation which comes with a framework. Money: While i think a good framework can cost money, some good ones (what is good, when you write your own :P) are free. Your business model can be service / training / support but in general most companies won't use your service / support. When they do, they might be big and the problem is: can you train / support these big companies by yourself or do you need people for this and are you up for this as well. Also the community part of the framework can make or brake your framework. **As for myself** When i went working with php4 i was working in a group of 3 programmers: the first programmer there created a basic framework. then the second programmer came (me :d) and started expanding the basic framework. Then php5 came out and a 3rd programmer came: Due to the introduction of OOP in PHP5, a migration of PHP4 to PHP5 and the newcomer with already a lot of experience in PHP5 (and java background) We created there a new framework. She also wrote an sql class which was easy to implement and pretty good in escaping the bad mysql words. Then in 2010 i started at home with my own framework project and switched jobs a few time. Then i was working for a food delivery platform 2012 and the CTO gave me my own project with my own responsibilities. I had the choice of choosing an existing framework or build my own frontend website with separate backend application. Because of the previous experience with own frameworks and the lack of experience in the other frameworks around i did choose to build everything from scratch. At a certain point ( 3 months later) i've choosen Smarty again as a template engine and needed to rewrite the views. After that ( 2 years later) it all works well and i did a lot of code cleaning in the meanwhile and i get a junior developer to help me with the project. Because of me helping the junior developer too much i couldn't make the deadline for the backend application which resulted in not extending my contract over there, so job hunting again. In 2015 i started at a research company which had it's codebase build on top of the Symfony 1 framework. While Symfony follows certain rules which where completely different then i was used to, i started at home in 2015 also a new framework. I picked the good stuff from Symfony and my previous created frameworks and started developing it. After 2 years of development of my framework ( +/- 10 - 15 hours a week on average) i decided to re-create a framework one more time (My current framework). A few reasons for my own framework: File location / autoloading, handling JSON the right way, For now no form classes, in Symfony, especially in Symfony 1 , some forms are really hard to make due to the framework rules. In such a case you cannot blame yourself and you might get stuck with the framework, which is dangerous, a framework should HELP the programmer and make things easy. If it gets in the way or you need to make quirks to get stuff working, that framework might not suit you. **My framework** While a lot of stuff already works great it still isn't finished. I think my version 1.0 will be ready in about 2 years (hopefully 1 year) and in a year the first documentation will be online. Also keep in mind what you want in your framework and what not. My framework still can use Smarty as a template engine, but my problem was (and is) it couldn't handle anything else then template files or at least i couldn't get Smarty to work on a specific feature (or it would be to slow). Anyway my framework utilizes json files as configuration / data files and i needed in the beginning to have variables in json. While variables is relative easy, a later moment i wanted also functions and modifiers. This made it way more complex which resulted in creating your own template engine / parser. While a parser can be part of a framework in my framework it wil be a requirement. So in July last year i started creating version 2 of my parser, my first parser was after a lot of work, working, but some stuff was buggy / depending on php's function: token\_get\_all() and readline() problems . the token\_get\_all resulted always in undefined tokens in the parser and it can change overtime so i needed my function. After my holiday last year unfortunately version 2 was vanished from github so in november i started on version 3 of the parser. Now 6 months later the basics a working again and hopefully it is ready in 2 / 3 months. Building such a parser will result in building your own programming language (at least, i do). Not that i am unhappy with Smarty / Twig, those weren't capable of things i wanted them todo (templated json files for example). The learning curve of basically writing your parser, to parse **your** language will take a tremendous time and you need to be a good consistent programmer otherways you will fail. Orm decision: funny, not reached to this point yet because of my parser. I was looking at doctrine / atlas eloquent and propel. I want to look at this after i finished my parser. I like propel of the model generation and stuff and cannot find this in doctrine / atlas /eloquent. The problem with propel is: outdated version 1, version 2 not production ready... So i probably will try to create my own orm with propel in mind and given that, it will probably be as complex as the parser. Also keep in mind when building your own framework, create a roadmap for yourself because time goes fast and framework development generally goes slow. &amp;#x200B; A*lso if you want to build an application with your framework, that application is delayed for 1 -3 years untill your framework works. Also when building the application don't spend too much time then on the framework development.*
Hey, remco\_cloud, just a quick heads-up: **untill** is actually spelled **until**. You can remember it by **one l at the end**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
then how do I make an array of functions?
Did you read the RFC? -&gt; gives way more issues because it's used for property access.
Every major language has short closure syntax at this point. Functional programming is gaining popularity and PHP will fall behind other languages if they don't allow people to do this easily.
The more complex the project is, the more likely you're going to have something like that occur, unfortunately. My framework is very simple actually and it's main job centers around database access and input filtering. SQL injection should be the easiest thing to avoid by now... do you happen to know how the SQL injection worked, by chance?
Sorry if this sounds dumb but what does a shorthand have to do with functional programming?
Some Laravel specific packages assume the existence of Laravel services that aren't included in Lumen, or specifically require global helpers like `public_path()` that Lumen doesn't include.
CI is not usually installed via composer https://www.codeigniter.com/user_guide/installation/index.html
The [injection bug](https://www.ambionics.io/blog/magento-sqli) was in the code for creating prepared statements and required a design flaw in a single controller to be exploitable. These kinds of subtle vulnerabilities are what you find in the majority of code that has already had thousands of eyes looking over it.
Using Laravel instead of Lumen for our API was the same for us. There was a lot of things we needed/wanted that didn't work with Lumen. It was actually refreshing to work with Laravel in that context too. I enjoyed it &amp; would recommend.
There are many more situations where lambda expressions are useful. // Specify a way to convert keys to some object $presenter-&gt;setKeyConverter(fn($key) =&gt; (new CamelCaseToSnakeCaseNameConverter())-&gt;denormalize($key)); // Provide a lazy constructor for data types $resolver-&gt;setDefaults([ 'empty_data' =&gt; fn() =&gt; new Person() ]); // In combination with monads Option::fromReturn(fn() =&gt; $this-&gt;findUser($id))-&gt;getOrCall(fn() =&gt; throw NotFoundException()); Option::fromValue(null)-&gt;getOrElse(fn() =&gt; $api-&gt;loadSomeValue()}; // Things similar to map/reduce unique($list, fn(Item $item) =&gt; $item-&gt;getKey()); // items in list unique by their key sort($list, fn($a, $b) =&gt; $a &lt;=&gt; $b); // specify how to sort a list some($users, fn(User $user) =&gt; $user-&gt;getName() === 'Tony'); // As callbacks combined with coroutine based http API $httpApi-&gt;request('/users', fn(Response $response) =&gt; $this-&gt;handler-&gt;handleResponse($response-&gt;getContent());
Yep, we've migrated a couple of Lumen APIs over to Laravel - the advantage of having the same core codebase when it comes to updates and implementing features outweighs any performance advantage we found when you're familiar with optimising Laravel.
underscore is not possible but I probably would have liked `\($x) =&gt; $x + 1` better. That being said if you IDE makes fn orange or w/e just like `function` and `class` it will stand out just as much as anything.
In functional programming you very often use functions as arguments to other functions. Because we don't really/truly have functions as first class citizens in PHP you very often use lambda's. Not having to write shit tons of boiler plate code when you want to use functional programming constructs is obviously a massive benefit.
Please try /r/phphelp
Why are you so upset about the `&lt;=&gt;` operator. I see you complaining about this absolutely everywhere I look
5.5 checking in
Plus codes are what you're looking for: https://plus.codes/map/
Endless pile load of crap over and over. This is what you produce.
thanks I reposted this there.
how can I use this ? How can I retrieve my "plus code" position using a java code or/and a php code so later then stored in the database to show it later on the page.
To add to this point: Never ever call the current employer to reach someone you want to recruit. It nearly cost me my job...
Rubbish. What you've mentioned above is only practical for the very smallest of API's.
In this case, yes. CodeIgniter is awful after you’ve used Symfony or Laravel
/r/phphelp /r/javahelp Figure it out.
Yes. I just realized how easy this makes everything! Its basically better than wordpress. See this basic example of a page with a pagecounter: &lt;?php include 'cache_handling.php'; // echo a simple page counter echo $_GLOBALS['cache']['counter']++;
It actually pisses me off about all the "professional" freelancers in here that are working for clients to deliver something and pushes a homegrown framework... If you are lucky and the product delivers value to the client, at one point they will want to extend it, add features to it or fix bugs... But that will be extremely costly and hard for any new developers that join the project! My best guess is it will be untested and probably very little documentation. I think the biggest reason is hard to breach the framework market is because the standard is incredible high! Insane amount of time has gone into the major frameworks... In the end, there are 2 alternatives, either you are doing it for a learning exercise (great!) or you are working to produce something of value... Also, give me one thing that is hard to do with Symfony (my framework of choice)? For example on of the problems above, you can return a streamed response(I'm using it to stream private content from a s3 bucket, fast and performant with no memory issues), or a binary response that have builtin functionality for resuming files, and can work with different proxies for even faster responses! Or the guy with his custom ORM, I would configure my User Repository in the config, and use it like this : ``` public function getUser(UserRepository $userRepo, string $email): User { retur $userRepo-&gt;findOneBy(['email' =&gt; $email]) ; } ``` With all the million edgecases and security risks with rolling your one-man-army ORM, I hope the companies now what they are getting! /end of rant Tldr: the standard of the current top frameworks are incredibly high, and culminates the work of thousands of people, so to build something that trumps all that work is probably extremely naive and arrogant. (Especially as a single person without feedback or discussions from peers).
I am failing to see any benefits of having a namespace separator as a way of identifying arrow function, if it's followed by an opening round bracket. That is to say - other "benefits" than confusing programmers by using a known character (PHP namespaces and escaping stuff) for a new, completely unrelated effect.
I kinda feel Laravel is too recent to have a history podcast.
I know. There are no packages with that vendor name yet.
It can't be measured then.
It started in 2010. That’s a pretty long time ago, especially in software land.
If we're measuring in lifetimes of an average javascript framework then Laravel is *eons* old
why post this here? I thought this is laravel subreddit? /s
Same here, at least make the decade mark.
IIRC Taylor Otwell used to be a .NET dev so Laravel may feel familiar. I've personally used Laravel to build APIs many times when I used to build Phonegap apps - the app and admin would both use the API. Lumen has nearly always been too minimal - the only times I've started an API with Lumen and still been using it at the end was for a microservice for sending push notifications and a web hook, every other time I've run into something that made it worth switching to Laravel. Don't buy into the idea some people have that making an API performance is a matter of picking the right framework. I've made my APIs extremely fast by optimizing queries, caching and setting appropriate HTTP headers.
Do you know the history of Symfony ? Especially as a single person without feedback or discussions from peers (well in the beginning: Fabien Potencier was the core writer (I am using symfony 1 at work) and yet everywhere i see the author is him. and your example is still not the right way of getting an user by e-mail. it is a way and probably the Symfony way... I personally would prefer this: &lt;?php $user= UserQuery::create() -&gt;filterByEmail($email) -&gt;findOne(); but anyway that is propel orm 1 &amp;#x200B; and this would even be better: &lt;?php $user= User::filterByEmail($email); &amp;#x200B; because why should i care about a query or a repository, that can be implemented in the model static function call. &amp;#x200B; What kind of security risks would a senior / lead developer risk with using pdo as a base. Because i am currently thinking of creating my own orm probably based on propel behavior. off course extra eyes on code will improve code quality, so do tests. and working with a lot of programmer colleagues will help as well ( or have worked with a lot of other developers) and start discussing code with code reviews real easy. &amp;#x200B; for example you have 30 programmers at your company and you rotate the code reviews through the teams over to other teams as well, you all 30 programmers will have nearly the same code quality at the end. With that in mind and a developer with years and years of experience could create a safe way to connect with the database. Before there where orms we had to connect to them anyway. The web was unsecured for a long period of time and without that insecurity we wouldn't be that far with security nowadays. From wrong implementations we have learned our lessons md5 anyone for passwords ? Then functions became available for right implentations. But mathematical not worthy to hack is still a thing... What if you need a supercomputer to hack a password; what would it cost to hack it: like current implementations: time to encrypt: 50 ms, time to decrypt .... (anyone?) What if it took 20 days for a price like 500.000 dollar, (rental supercomputer for 20 days of computing) But that password is worth ? you probably forgot to implement that. a password could be worth millions of dollar so let's rent that supercomputer and start bruteforcing it... now the cost is here (which is for that forgotten implementation) so we increment the cost, which results in longer login verify time, you don't want to wait minutes to login, would you ? So because of that, there is a theoretical maximum amount of dollars which should be behind that password... What if the price of that same super computer becomes available 5 years later for 1000 dollars. That is what happened and i doubt it will happen again...
It's \ in haskell because of how much it looks like the lambda sign.
You should ask /r/phphelp
Another way to find the location (in the PHP code) of a segfault is to run PHP under gdb, do a `source path/to/php/.gdbinit` and then run `zbacktrace`.
The Letter_Grade column doesn't exist in the gradetable table. Also. https://stackoverflow.com/questions/45140483/php-javascript-101-separation-of-concerns https://phptherightway.com/#web_application_security
The error messages means your database table doesn't contain a column named 'letter grade'
You should also read up on SQL injection and how to properly store user input into a MySQL table: [https://websitebeaver.com/prepared-statements-in-php-mysqli-to-prevent-sql-injection](https://websitebeaver.com/prepared-statements-in-php-mysqli-to-prevent-sql-injection)
So what do I have to do to my code too fix it ?thanks guys
Do it. Put in all the hard work and take all the risk in going all in on a company, then give up control to people who've only ever known how to collect a check. There's a reason you don't see more of these, and it's not because of jokes about communism.
Why wouldn't you just store latitude and longitude as two decimals? If you need to perform calculations in your database, you could look into point data types, but it's probably unnecessary for you.
This. We are rebuilding our old Django backend using api-platform. You get automatic rest/graphql APIs fully working on the Symfony ecosystem, so you can plug your own stuff should you need it, we did this for authentication. There is builtin support for react-admin too.
This has nothing to do with Slim, but with the [PSR-7](https://www.php-fig.org/psr/psr-7/#3-interfaces) HTTP message interface.
the problem is how to generate it using gps permission from the browser or the mobile app and the second problem is how to convert longitude and latitude to a google map to display on the page.
You use parentheses around your short closure expressions to make it clear that it's to be a closure. Kind of like how in JS in array functions you would place parentheses around the braces to express that that's an object you're returning rather than a block of statements you're executing.
There is nothing more dead than Zend Framework, even by any other name.
Slim.
&gt; I think the biggest reason is hard to breach the framework market is because the standard is incredible high! Insane amount of time has gone into the major frameworks... 6 months before laravel 1.0 was release. Yes if we count from 1.0 to 5.x then yes an incredible amount of time, dedication and money &gt; Also, give me one thing that is hard to do with Symfony (my framework of choice)? Nothing, some people might think symfony is hard - when its not, when used properly. &gt; With all the million edgecases and security risks with rolling your one-man-army ORM, I hope the companies now what they are getting! So then with a framework like Zend, Symfony and Laravel - they were "home grown" - how did they get going if 1.0 of their software - today - was laughed at? &gt; the standard of the current top frameworks are incredibly high, and culminates the work of thousands of people, so to build something that trumps all that work is probably extremely naive and arrogant. I agree the standard is incredibly hard, but again with these frameworks we depend upon come from 1.0, which would make your statement hypocritical no? They did not have thousands of people - some started with one man. So based on your TLDR and the rest of your comment would that not make them naive and arrogant? Especially laravel when Symfony already existed? or Symfony when Zend already exists? or any other framework when X already exists?
Good god, that's a bizarre way to do SQL. How'd that slip by the internet's code fashion police?
I'd never reach for CI to start a new project nowadays, However, it's a bit much to dismiss it entirely as garbage. I've several systems for clients which were first put in development five years or so ago. They're still being upgraded but never going to be rewritten into Laravel because of the cost involved. So long as you're aware of the limitations, program tightly, and document where needed they're perfectly fine for continuing to deliver a business system - each of them is currently supporting an SME with several millions of dollars, and in one case tens of millions of dollars, of turnover. CI is still being maintained and upgraded too - it was \*so\* popular in it's heyday that I expect it will be a viable solution for existing systems for another decade at least. I'm still doing the occasional upgrade of Access-based SME systems to web - and Access reached it's high-point as SME back-office system of choice (combined with MSSQL) sometime around 2005 or so.
And what makes you say that? I mean, other than being a Laravel Fanboy?
The one hope I have with this news is that the project may finally have enough financial resources to spend into proper documentation. As documentation is the one true issue this framework has and always had.
Counter argument, what makes him wrong? It’s definitely not as popular as CodeIgniter, Laravel, Symfony, Silex, Cake, Yii, Symfony, Phalcon, or Slim. I don’t see many packages require Zend by comparison to other projects in the same spaces as Zend components. I don’t see the commit frequency of other projects with Zend. It seems he may not be all that wrong, wouldn’t you agree?
&gt;or i am no longer part of the project it can get pushed on you but, you always have a choice to deal with it or not.
Attaching strace to the process is helpful too
Seems intersting, might give it a spin later, thanks for sharing.
I didn't say that the standard was equally high when symfony 1 was released, but it is now. The maturity and flexibility of these frameworks are very very high. Of course in the early days you could be justified (in a business value perspective) to roll your own framework, but today with Symfony 4 or Zend Expressive?
Magento provides special kinds of fun. The codebase is enormous and implementation techniques and design strategies differ all over the place due to its long history and ever changing development team and goals. EAV database models are extremely flexible, but really unenjoyable to work with and prone to a host of issues that can outweigh the advantages it provides. Partly the size and complexity of the codebase comes by way of necessity, it is an extraordinarily flexible platform if you understand how it works and blew all of the competition out of the water when it came to enterprise eCommerce for a long time. On the other hand, much of the size and complexity comes from many poor developers working over many years and features that were half-implemented solely to meet the requirements of a specific enterprise client and then pushed into the open source version. There almost certainly are more holes, but the same can likely be said for most pieces of software of a similar size. Remember that this vulnerability was only discovered after a decade, after enormous amounts of resources have been dedicated to try and find Magento vulnerabilities, by Magento's developers, independent security firms, end users and, of course, malicious users. Despite this, to the best of my knowledge there have been no major breaches of the high profile Magento shops of companies like Coca Cola, Ford, Nike, Fox, Nestle, Airbus, Skype and thousands of other high street brands.
About security, if you have a team of 30 engineers, I'm sure you can pull it off with the right experience, but why would you? About password hashing, I don't know how important and valuable the password of my user is, so I make sure to use the highest "cost" of encoding the password our server will allow, as this changes in the future, I can increase the cost and rehash the password with max 30min of work in symfony, or if it's an old account I can disable/delete the password and force the user to reset it... About the repository, if you will learn from history, instead of repeating their problems with the cost to fix it, you probably want a repository (think single responsibility principle). I like to think about "building on top of the shoulders of giants", I want to solve the business case efficiently, and make sure the next person after me can start working with solid documentation. By using commonly known best practices, it's easier for them to reason about the code and be productive. I want to limit my exposure to security vulnerabilities, so I use a well used and tested framework 😊 it's not about if I could make it...
Definitely will try this out. If I may ask, what makes your tool a good option to use over other, existing solutions? I am in the midst of a personal project which does not use a framework, and have not yet settled on a DI solution.
An alterntive: https://github.com/rdlowrey/auryn
A good starter tutorial However, you should talk about refresh tokens. The main thing about JWT is they are supposed to be short lived.The reason it should be short lived is that you dont generally have a way on revoking access with a JWT. So someone who steals a JWT has full access without you being able to remove it. Sure you could store the JWT in the database, but that completely negates the reason of using one in the first place (saving a database hit). What is short lived? Well depends on the application. I typically set mine for about 15 minutes. So how is a refresh token come into this? Well to issue a JWT you need credentials. You really dont want to kick your user back out to a login screen every 10 minutes to obtain them (nor store them in your application). A refresh token is stored in the database, you then create a new endpoint that allows you to generate a new JWT with the refresh token. A refresh token will typically have a much longer expiry. Again depends on application, but I often will have it set for a week or two. You can store any data you wish in a JWT, but never ever store sensitive information since it is easily reversible. The data cannot be changed, but it can be viewed. I would store the ID but skip the rest (first name, last name, etc)
Splitting your comment in points: - tight coupling bad for libraries - you’re right, being used to Java now for a few years I forgot that there’s a difference between how logging is standardized in Java and how it’s done in PHP. I think for what I proposed to work there would need to be a new PSR introduced which would standardize the LoggerFactory and LoggerFactoryRegistry of sorts, from that point you’d be able statically configure libraries’ LoggerFactories. - the boilerplate however hurts not the lazy ones but those who are trying to get through the miriads of lines of completely unnecessary code, it’s mainly about reading and not about writing. But adding to developer experience is also a nice thing and a good boost to productivity (not because having to type less means spending less time but because having to type less means that the idea that you’ve outlined in your head will have more chances of being implemented in a timeframe small enough that no details will be able to escape your memory _while you were typing_, this has happened to me so many times with eg Java that when I switched to Kotlin I noticed how much more I can get done simply because it takes so much less typing to declare a data class and a strategy for handling it in some way for example). - about SRP, I haven’t personally seen a project that doesn’t violate this principle, sadly. But I accepted it that even though it is possible to split your services and classes carefully enough to reach that SRPiness, it’s usually not practical in the day-to-day web programming. We are not building web servers or OS kernels after all, the complexity here is not _that_ high while the importance of fast delivery of features is high enough, plus the availability of people being able to produce high-quality code is so low, that it makes sense to make a trade off on things like SRP and just solve problems that arise when you don’t adhere to some of these principles (eg solve not the root cause but the consequences - surprisingly this does make sense sometimes)
Looks quite clean codewise. For single responsibility purposes and more transparency in the public interface I'd split up the bind method into two methods, one for adding one service and another for adding a collection of services. Also by convention, method names should contain a verb so for example getItemByKey instead of just item might be clearer. Good work overall in my opinion.
"This has nothing to do with Slim" - but this is in Slim docs on first page lol.. . Thats why fw like laravel winning this contest (SF fan here)
Sorry about it. I'm new to posting with English language and to TI community, nice to see they still prefer articles instead of 30 minute video. I don't own any of these ads and gain nothing even if you interact with them. Next time I'll expand each bullet point and provide whys and e.g.
Javascript on the server is basically asking for trouble.
I rather like the idea of having a recurring megathread for self-plugging stuff. Mods?
You seem to be going down the same dead-end as I did several years ago. While it is true that `new` in anywhere in your code makes that piece of code really hard to test, that is a lot smaller problem than you think. Such constructions in your code only mean, that you first need to have all of the internally instantiated classes to be "trusted" (i.e. fully covered with tests). These days I use a mix of internally instantiated (as in, `new` in a middle of a method somewhere), factories and builders. Most of the domain entities I create using `new`. Most of the data mappers I instantiate using factories (because they need a PDO as a dependency, which has to be shared) and then there are some "adapters" and "parsers" that I make with builders, because they need a complicated pre-configuration. P.S. There is no such thing as "models". Model is an application layer (singular), not a class or object. Stop perpetuating that Rails marketing crap.
No he is wrong. I live in Germany, NRW and there's quite a few big / global companies around myself. I had been in contact with quite a few of them (Trivago, Check24, Sipgate, Siemens, just to name a few). And for more than 90% of them, neither of them is using anything but Symfony or Zend for the mayor part of their enterprise architecture. While there's certainly a rise in Laravel offers recently it still does not compare to the strength of both Symfony and Zend. So as far as my area is concerned roughly 50% is symfony, another 35% is Zend and Laravel is a rising trend with the remaining 15%. I just hate these utterly bullshit comments of people who clearly are nothing but framework fans without ANY knowledge of actual working conditions.
I had to use lldb on macos, gdb is broken there
I recently helped upgrade 2 large codebases from 5.3 to 5.6! &amp;#x200B; It's a 10 year old product that tens of thousands of people use every day and pay money for. No plans of upgrading any further – it would mean upgrading Cake 1 &amp; 2 to be PHP 7 compliant.
The fact you see it almost exclusively in big corporate environments, with funds to spend on training and stuff. I'm dealing with ZF3 project right now - there is almost \_NO\_ documentation to speak of. Most of the components are barely covered and a lot I have to read and see if it still applies from posts from like 2010-2014 for ZF2. The project itself is a mess that every single person in the company understands that we have next 4-6 months to somehow stabilise our project so it does what we need to and we are rewriting da fuck out of it from scratch on SF4+. It is a total disaster here - without a highly skilled team of 4 to 6 people, an architect and a few support roles it is just barely possible to keep it designed well and properly coded. And there are very little developers who actually know ZF - the company I joined never found one in 7 months of searching.
Yes. Cookie should be capitalized (Cookie), as should Content-Type and Referer, but this should work fine. If sending multiple cookies, it'll look like this: `Cookie: foo=bar;test=1;banana=bendy\\\r\\\n`
Nope, it is not correct to post help questions in /r/php, you are supposed to ask in /r/phphelp instead
Thanks.
cURL also has a memory only cookie jar if you're referring to that. But yes I'd probably also opt for Guzzle.
&gt;Furnishes most elevated magnificence alongside more noteworthy effectiveness and convenience. Literally what. &amp;#x200B; &gt;It has the best capacity to transfer into the HTML esteem. what.
Only decade? That's like nothing in COBOL terms. #realFrameworksHaveLongHistory
It’s pretty lightweight, has no real dependencies (expect the psr packages), psr-11 compatible, allows you to load in your personal cache store with the psr-6 compatibility and much more!
&gt; but I wanted mine to be static so I can use it easily without any additional dependencies or even worse, global instances. You keep using that word (static). I do not think it means what you think it means. static is a horrible solution for logging. You're losing all the benefits of dependency injection (ability to change logging configuration based on things like environment - eg. log to memory / null in tests). You've also lost the ability to log to multiple files - because static properties, the way they're being used here, are basically just another form of "global". monolog and psr/log don't use static for a whole bunch of very good reasons. And "without additional dependencies" in a composer-powered world is just NIH in this case.
Does Flysystem still throw implementation specific exceptions for its adaptors? I love the concept behind it and use it for several projects, but it frustrated me that you couldn't just swap which adaptor you were using because there was no common error handling (except for things like NotFound / Exists).
I am not sure but that's a very good feedback. I'll discuss this with Frank (the creator of the library itself), it should be "easy" to fix :) .
For many of those exceptions a Flysystem typed exception would actually be unhelpful. Those adapter specific exception should be addressed by a developer, not at runtime. Since the case for these kind of exception hinting is to be able to handle them at runtime it kind of defeats the purpose of having them IMO. Plus you can always just catch generic exception types. &amp;#x200B; If you have compelling arguments to add them I'm all ear. However, I've discussed this a number of times and a "always wrap all the exceptions with a generic exception type" as a default strategy is a pretty serious no-go for me since it turns Flysystem into a exception black box when those aren't handled with a deeper level of inspection (which again defeats the purpose of exception interfaces because those are for generic handling, no specific handling).
Following
This article is a **plagiarised** version of https://dzone.com/articles/design-patterns-the-builder-pattern
I'd argue that if you're writing an abstraction out that's meant to be drop-in compatible, you expect a common set of abstracted error conditions from it, without that, the benefits of drop-in replacements are severely diminished. At a minimum I would like to see an AuthenticationError, PermissionsError and RequestError all inheriting from a single IO exception, naturally the original exception from the underlying SDK / library should be available via $ex-&gt;getPrevious(); Personally when I last used Flysystem, I wrapped the Filesystem instance itself in another wrapper, and surrounded everything in try { ... } catch { ... } to make sure that if I ever did swap it out it would be transparent to the caller, and that only the details of the detailed error message would change.
What's the point of this bundle? Sounds like it only does things that the symfony container already does.
We’re still waitiiing...
Thanks for the tips! I’ll gradually move the bind method to deal only with single items, instead of many. I’m glad you like it!
You should try it ;) . The combination between named autowiring aliases, expressive configuration and the recipe make the experience really nice IMO. I agree this bundle is quite simple, but it tries to do things right and efficiently.
That's seems to be method chaining, but not the way PHP does it but rather the way JavaScript does it.
[A rhetorical question is a figure of speech in the form of a question that is asked to make a point rather than to elicit an answer](https://en.wikipedia.org/wiki/Rhetorical_question)
I'm sorry, but your naming strategy might collide with an existing deployment tool well-used, large community and well-maintained within the PHP community, named (to no surprise) [Deployer](https://github.com/deployphp/deployer). This could be a real issue for you, if you want your own tool to get any kind of traction with PHP users.
Every outside abstraction should be wrapper in an internal use-case driven layer, so by that account, you're handling this by the book. I don't agree that the benefits of this diminish even the slightest bit. If you want to capture all types of exceptions from any adapter, just catch the \`Throwable\` interface. Every expected exception within Flysystem is already handled and returned as either an expected response or another type of internal exception. When somebody doesn't have permissions to write to an S3 bucket, that's not a filesystem abstraction concern, that's an AWS/S3 concern. Further more, the developer should deal with this, not at run time, but they should either fix their credentials. If the credentials are user-input, they should be verified prior to their use within Flysystem. It's not Flysystem's purpose to verify credentials. &amp;#x200B; The request error cases are either actual bugs (which requires a fix somewhere, network failures, or any other type of failure like 503's from the provider. All these things fall into a category a common exception type doesn't resolve. Catching a common exception is literally the same as catching the base exception type from PHP, albeit there's more code for me to maintain and more errors to be aware of for no value. &amp;#x200B; To make sure you understand me. I'm asking for any practical reason to do this. Which the "now I can catch all the exceptions" case is not one of, since you can already do this because PHP is PHP. If you have such a case I'd be more than happy to discuss this. I've opted this many times yet, had many discussions like these. To this day there's been either no further response or just a re-iteration of the theoretical point that this somehow breaks interoperability, which it doesn't.
[A sample](https://github.com/Ocramius)
&gt; It's not Flysystem's purpose to verify credentials. I think we'll have to agree to disagree here. To my mind, the entire point of an abstraction + adapter layer is to expose a common interface, and that means common function names, common parameters, common return types and, I would argue, common exceptions / error conditions. If it's converting inputs into whatever the adapter requires etc, but not converting outputs (and I would consider an error as an output) then it's only doing half its job. If a call fails because of permissions, that's still the call failing, and I would expect a PermissionError or general IOException to be thrown, not a AwsSaidNoGoodLuckParsingThisError or some equivalent from GKE. Flysystem is described as: &gt; Flysystem is a filesystem abstraction library for PHP. By providing a unified interface for many different filesystems you’re able to swap out filesystems without application wide rewrites. If I can't use it without either a) wrapping it in my own wrapper or b) having to put in adaptor-specific error parsing at every call, then I'd say it's not exactly living up to what someone would expect from it. Personally the largest application I used, I had a choice of replacing my existing File IO interface with Flysystem, or sticking with my original interface and double wrapping the adapters. I chose the latter. The lack of consistent errors for the caller was a deal breaker for me.
Welcome to laravel - that was in regards to your P.S
Thanks for your information!
Opinions?
Plagiarism and apparent mixing of PHP with some other language notwithstanding, this example is deeply problematic because using the builder pattern, you have zero guarantee that your object is correct and valid after instantiation. $bankAccount = new BankAccountBuilder()-&gt;setOwner("Homer")-&gt;build(); That is perfectly legal to do according to this example, yet it will result in an *incomplete object*. And if the business rules allow for such an incomplete object to exist, that's a big red flag for me. I can't count the number of times I've been burned by poorly defined objects that can exist in just any old state. Null checks everywhere, branching conditional logic if property X is set or not. Turns into spaghetti really, really fast. IMO the builder pattern is a code smell covering up for another code smell to begin with.
Naw, have no disillusion of that being a good thing. Some folks like video versus reading. I'm satisfying the masses. ;-)
Some folks prefer video to reading. ;-)
And some people prefer actual content vs padded videos. Excessive self promotion is typically frowned upon, too.
I think AliasTrait.php shouldn't use external methods. It violates the whole purpose of traits, you can't simply drop it in any class. Probably, it's better to add methods to the class directly
It depends on who you're trying to impress. Someone linked Ocramius' github repo, but that's not a realistic goal for anyone asking this question. Let's look at what might convince a director or anyone tasked with hiring talent, that you have a command of your craft. &amp;#x200B; **Open Source Project Owner** Most impressive item would be to demonstrate you can maintain a proper open source project. While that alone would earn recognition, decent test coverage, legit release strategy, clean documentation, and a managed issue queue would each add credibility. If the code was clean and followed standards, I wouldn't need to see much more as this demonstrates you not only have the PHP chops, but I could depend on you to function autonomously without too much oversight. &amp;#x200B; **Documentation** Documenting projects is overlooked. Even if there are questionable points in your code, the ability to make complex concepts digestible is highly desirable. It not only shows you know what you're talking about, but it demonstrates the ability to communicate to everyone from peers to end users. If you don't have a knack for documentation, think of complicated projects you have used which were easy to get started with. Use their documentation as inspiration for your own. &amp;#x200B; **Open Source Project Contributor** Expecting everyone to own a project is not realistic, so the next best thing is to see PRs to other OS projects. Beyond the code, this shows experience with the coordination and communication required to work with others on a project. &amp;#x200B; **Non-PHP Contributions** Commits to projects in languages other than PHP demonstrates an ability to adapt, which is useful even when working exclusively in PHP. Technologies evolve and there's always something new to learn. The use of other languages and technologies shows you are open minded and not just a one trick pony. &amp;#x200B; **Any Personal Project or Contribution** Don't trip on how a personal project may reflect on you. Maybe the project is old, maybe it's not useful to anyone, and maybe it's nothing you are very proud of. Misc projects are like old photographs, a snapshot of where your mind was at back then. If you are not finding issues with code you wrote a year ago, then you might not be progressing. The point being that any decent director/developer responsible for evaluating talent knows this. Seeing any activity from a couple years back is far better than seeing nothing from the past. I'm not talking about publishing entire websites, but maybe it's a seed you use to start projects, examples demonstrating how to use an API, or even a repo of documentation. There is value in seeing a history of a developer publishing projects. If nothing else, it is proof of some experience. Consider this if you are new, and have nothing. Just start putting things out there that interest you at the time.
Yeah I coupled that trait directly to the Pouch class. That’s the purpose of its existence. But I would happily put those methods back in the Pouch class if I’m violating clean coding practices.
Okay great. I’m a recruiter so I want to improve how I go about reaching out to people as my employer doesn’t force cold calling some do t some don’t I don’t want to
&gt; And there are very little developers who actually know ZF - the company I joined never found one in 7 months of searching Quite curious as to how badly an application can be designed to not understand the code-flow. I will never argue against Zend having absolutely shitty documentation. As I've said it's the worst trait that Zend Framework has had every since it's first version. However, if senior developers do not understand a ZF2/3 Application then I would argue against the fact that this is Zends fault. A badly designed application with lots of hidden - and undocumented - magic happening is bad in any framework...
Is this a joke? o.O
Let's put it this way: A controller, containing \~3.7k lines, about 60 to 80 methods and 2 service classes that are defined and written in that same file that are used in that controller. That contains about 70% of the app functionality. I'm not talking about "small" things of logic in php templates with elaborate if-else statements running almost 1k lines long, switch-case statements running 300-400 lines handling input data variations of the form based on a field value and it goes on and on and on. Can I get a sense of it and work with it? Sure, in my 13 years I have seen worse. Is this salvageable? Absolutely, fucking, not. Thing is - ZF is complicated in a sense that without an architect - y'r fucked unless you are the architect. Nor the Zend DB encourages a good layer separation in general and debugging the thing is seriously hard when a var\_dump generates an OOM even if you have a single record result from DB. It has absolutely no protection from anything - this is like doing pure C development - you are free to shoot your leg off with a shotgun 20 times a day. In right hands - sure, it might be awesome, but I literally would trust with it 0.5% developers.
I've used [https://packagist.org/packages/thesoftwarefanatics/php-html-parser](https://packagist.org/packages/thesoftwarefanatics/php-html-parser) and had all sorts of issues with it. I know the website recommends using the original package but the links to this other package just point back to the same website. I've even tried tidying up the HTML with PHP tidy and that helps somewhat but still not perfect. I know I can easily do this in Python but for some reason doing this in PHP seems to be a major problem. Or am I simply using the wrong out of date and no longer supported PHP library even though it comes to the top of google search results?
It's good that you're asking. Think about the level of people you'll be recruiting. The more senior people are time and bullshit poor. I'd wager an email stating clearly job title, type (contract / perm), job description, salary / daily rate, duration and location would get you more responses that voicemails.
Some point to correct, receiving a dependancy by its interface ist called dependancy inversion and the first part isnt that great, because you create theories but remove them by saying its fixed in the latest versions of PHP.
Hi /u/Felix_267, thanks for taking the time to read my post and leaving a comment, I really appreciate it. Nevertheless, I think I'm misunderstanding your comment, I don't remember making reference to Dependency Inversion in the article, what are you trying to say is that I should we the term Dependency Inversion instead of Dependency Injection in the first paragraph? Also, could you point to specifically which theories I am creating in the article? Are you referring to the lack of type hinting and return types that I mention at first? I specify that this behavior only affects PHP 5.x, maybe my narrative was a little ambiguous. Thanks for the feedback!
&gt; A controller, containing ~3.7k lines, about 60 to 80 actions and 2 service classes that are defined and written in that same file This has NOTHING, literally NOTHING, to do with Zend Framework, though. As I have suspected it's a code base that's probably been constructed by a person that doesn't understand any basics of software engineering. Probably the framework was used - at the time - because it was "cool" but not understood by the developer. Therefore the code is absolutely terrible and yes, you'd most certainly NEED the original architect to somehow make sense of it. Though arguably I'd doubt that even the original architect of said code would still be able to understand said code. &gt; when a var_dump generates an OOM This happens with every single modern Framework out there and it's pretty easy to understand why this is happening. This is why Symfony, Zend and Doctrine have dedicated Debug::dump() classes that limit the levels that you would dump. &gt; I'm literally learning the app and the framework by blindly poking the code and by adding type-hinting and seeing what an object has in it's auto-complete and experimenting. Because there is no other way - no docs and barely any decent info on google. I'm sorry for you having such a terrible experience but I hope you'll come to the conclusion at some point that this is just not a ZF issue. I have probably written hundreds of thousands lines of code by now using Zend and I'll fairly easily find myself around software that I've written 10 years ago. Given the fact that others rarely have a hard time joining me on projects I'd say it's safe to say that it's just not the framework thing. Quite frankly: while ZF (or recently Expressive) is my framework of choice I don't _REALLY CARE_ what Framework is being used. I struct my software mostly framework agnostic. Services, Models, Database - these things don't care what framework they are being used by. All the framework does is handling mundane things like Dependency Injection, Sessions, Request and Responses, Routing, all this junk. The rest, that's my application. And my application works, no matter which framework you put on top of that.
**TLDR:** When you define an interface with a method that "accepts `Animal`" as input, it is an error to make an implementation that only accepts `Bird`, because the expectation is that you can handle all kinds of animals.
Unrelated to interfaces, will contravariance allow us to catch very specific exceptions with the generic exception class?
Exception catching is already covariant, `catch (\Throwable $e)` will catch any exception or error thrown (but is considered an anti-pattern).
It's not an anti-pattern when you have a legit use for it (like passing it up to something like New Relic regardless of the type of error).
&gt;Its basically better than wordpress. Impossible!
100%. Not everyone wants errors going to STDOUT at all.
I thought about adding a TLDR section at the beginning of the post, obviously I didn't, yours works well!
As /u/AlpineCoder alredy said, catch already works this way.
You didn't really answer his question. We want to know what it is for.
I stopped reading when he/she said America was a desert land when Columbus arrived.
Hey Max, thank you for sharing your article. As an editorial critique, I don't feel that its content supports or reinforces the title. I spent most of my time reading the article thinking that the examples themselves didn't really make sense, not so much PHP's interpretation of them, and wondering when I was going to actually learn something weird about interfaces. By establishing your core premise early and spending the meat of the article explaining and enforcing it, I feel you'd have more success. Perhaps the title "How a New PHP 7.4 Feature Will Make Interfaces More Flexible and Powerful". Also, I didn't get much out of your `Parser` example. Even your final "best scenario" code just shows you instantiating `JSONParser` directly, making no use of the `Parser` interface and polymorphism. Having a concrete example of how this fixes your previous critique would be powerful. This is especially important to help sell this to PHP developers, especially those with little to no experience with other programming languages and don't know why covariance and contravariance is powerful and important. I hope this advice can help you improve your writing and continue to share with our community. :)
Really good article, very informative, sometimes I felt it was a bit over-specific but loved the way it was structured. I love to see that RPC is still not dead since I have a project of my own with it, love the idea of creating an application and decoupling its underlying protocol (HTTP/HTTPS) and just focusing on how it get things done. For the type of person who likes to see code, so here's the [git repository for twirp](https://github.com/twitchtv/twirp).
You're correct. For new devs, nickname is more readily understandable and doesn't evoke the "Oh, geeze. Now I gotta go look up what that is too..." that are commonly present in many tutorials aimed at beginners. It's always best to cut the technical terms when appropriate when you're getting someone up to speed with new concepts.
Hmm. `JSON` is subtype of `Format`, so it doesn't represent contravariant parameter type that linked RFC allows. It's allowed to pass subtype without typehint change (with LSP in mind), and I don't see the need for different typehint in given example either. I'm not even sure yet if I like this RFC. For me it makes sense for subtyping generics with variable contracts (and its in/out wildcards), but when it comes to hardcoded typehints it seems weird. Anyone got some good use case example showing the need for it (beside magic stuff)?
\&gt; he/she they
*Closed as subjective.*
Yup looking for opinions.
I think that you should formulate the data before writing it. You’re calling `file_put_contents` for every entry. Push the entries to a concatenated string then once you’re done looping to the data write it in the file.
LOCK_EX is causing it to pause while it waits for an OS lock. Either use it on both writes or neither, preferably the latter. Are you expecting this to be run by multiple users simultaneously?
File creation (And adding several lines to existing files) is much slower than just running a loop, because constantly writing/saving to disk is also affected by disk speed, processing, running tasks, etc. Off the top of my head, one thing you could try is having the while loop save the data to an array, and only writing to a file when the array reaches a certain index, then the array is cleared (reset a counter) and start a new one.
It must really hurt when you take a shit. Anal retentive much?
Thanks, I'll try that. I'll remove the file_put_contents from the existing while loop, and I'll just use the while loop to process the JSON and to put all values in an array. Then I'll implode the array to a string, then use the string to write to the txt file. That way file_put_contents is used once per JSON file, as opposed so 10's of thousands of times. I hope it helps. I'll let you know once I try.
No, it will be only run by a single user. I only used LOCK_EX because it starts a new line in the txt file which I need. Without the LOCK_EX the data is written on the current line of the txt file. I'm sure there's a better alternative to start a new line. I tried the obvious &lt;br&gt; and /n but they didn't seem to work. Looked into it online and someone said just add LOCK_EX, and this fixed the new line issue.
&gt; All the above statements can be used with parentheses as they are statements. First, the phrasing alone makes no sense. How being a statement explains that parentheses are not required? print_r($var); *is* a PHP statement, but parentheses are required here. Second, whatever explanation phrased as "parentheses are optional for X" makes no sense as well. As I already told you, it *may* sound as &gt; All the above statements can be used with parentheses as one can add *parentheses* to almost any code block, such as argument for include. But the only sensible statement would be &gt; Using parentheses with require and include (as well as echo) is just a superstition. Parentheses do not belong to such operator. PHP treats parentheses as a part of the argument. And in some cases it may even lead to problems. TL;DR: using include with parentheses *just* makes no sense. writing include('file'); is as weird as writing an assignment as $var = ('file');
No need to implode it into a string; file_put_contents also accepts an array. If you have a couple helper routines: function sel($x) { return "{$x-&gt;country},{$x-&gt;ip_address}\n"; }; function project($x) { return sel($x-&gt;postParameters); } You can use a single array_map call to get the data into the correct output format: $rows = array_map('project', $mp-&gt;response-&gt;data); Then save everything in one go: file_put_contents("$date.txt", $rows);
&gt; Including can be done starting from the document root. (using $_SERVER['DOCUMENT_ROOT']) Is something strange as well. Why only include but not any other filesystem-related operation? Why only document root? And - most important - *why* someone would want to use the document root? There is no explanation. To be honest, I have a feeling that you just reached the level where your own knowledge is no that solid, and as a result your explanations become muddled and uncertain which makes your articless less helpful. Or you just started to put less effort into your articles thinking that you will just post them on Reddit, collect the feedback and make them good. I can tell you this is **not** the way to go. Either put much more effort into your articles (and do not cheat, posting a link to such a trifle topic as include) or don't spam with your links here at all. Because your frequent posts *are* starting to look like a spam, despite your first two tutorials, on basics and OOP were rather good.
I'm going to rewrite it in a similar way right now since both you and another user suggested it. I will let you know how it went. Thanks for the help, I appreciate it!
Okay, I won't be posting here anymore.
You do not have to use parenthesis with language constructs.
It is not the point of my comment. Just put more effort in your tutorials, and post links to whole tutorials, not separate chapters
Your posts use a lot of words to say almost nothing, congratulations. I use document root for includes all the time, just because you don't doesn't mean it wrong. You should get your autism checked out
One of very few good articles.
Thanks! This helps a lot. I'll try it out.
Try \n
Speaking of autism, nowhere did I say I don't use the document root. I did say something different, so check yours (: However, indeed I use it very seldom, and advise you to follow this example, as using the document root will backfire once you will start with a more or less solid application.
With file_put_contents you are opening, writing, and closing the file each time. Open a handle with fopen() then write with fwrite(), then close with fclose() and you will see a significant speed boost. You should use file_put_contents only if you are writing to the file once.
It is slower but not that slow. Use your common sense.
&gt; When somebody doesn't have permissions to write to an S3 bucket, that's not a filesystem abstraction concern, that's an AWS/S3 concern. I'd recon that's actually an AccessException in the same flavour as a file that has r-- permissions. You can't write to it. Exactly how S3 handles permissions is to be translated to IO exceptions by the abstraction layer, but "403 forbidden" is, for an end user, the same as a file not being world-readable and the user requesting it not being the user or in the right group.
And remember to use double quotes ("), not the apostrophes
Thank you so much for this response. I truly appreciate it.
Thanks a lot for the feedback! Glad you enjoyed it.
Thank you!
I was just kidding
Looks very interesting! We are using more and more micro services but communicating with them always ends up to be one of the hard things. Looked at gRPC but they have no server lib for php. How does this perform performance wise?
RPC definitely isn’t dead. As far as I understand, it’s used extensively in microservices. Google authored gRPC which uses HTTP/2 and Protocol Buffers.
Honestly, I haven't done any performance tests yet, but I use it in internal systems and works fine. It's not easy to evaluate it's performance though, given gRPC should in theory be faster for a number of reasons (http2, more performant languages, etc) I will try to come up with something though.
So you kicked out your frameworks for performances. Why do you even used it in the first place, you lost time and the opportunity to make concise code. Yes php is extremely fast with optimizations. You advises are flawn and 3 years+ outdated. I must underline this, you are definitely wrong, and it's bad for younger. What's the point, let them play with what they want. It feels like you are trying to convince yourself by flagging others. Bad attitude.
What? That response is incoherent gibberish.
Why not PHP_EOL ?
https://museum.php.net/php1/
Php became popular after php3. Most developers were using cgi perl in that time.
`PHP_EOL` is only required if you've opened a file for writing in binary mode, in normal write mode PHP will automatically convert `\n` to the correct line ending for the platform.
You're probably looking at PHP/FI, the first versions before PHP3 came along. https://www.php.net/manual/en/history.php.php
I started using it in 97, so 2.x was the earliest I can remember.
So I can't really comment on a portfolio as a whole, but when I've looked at the Github of people who apply to places I work at, there's a couple of things I'm interested in **if** I find some personal projects. Not having these isn't a negative, but having them definitely catches my eye * *Some* sort of code style standard. If it's enforced by a CI build, even better. We'll be expecting you to use our code standard (Usually PSR-2, with a couple adjustments), so it's not important, but it's nice to see that you apply style standards of some kind. * Documentation. Just a simple `samples/` folder, or even something in the README explaining what you've got there. Again, not necessary because personal projects are personal projects. But it's a nice to see * If you have a library you're publishing, I'd really like to see some Unit Tests and a CI badge on your README. I don't really care if your CI is red and failing, but if someone's got a CI badge at all it shows that there's some thought put into it. Now, none of the above are necessary in my opinion because I don't expect candidates to have a pre-prepared selection of code for us to look at and if there is something on their Github, it's going to be personal projects and it's not really fair to mark someone down for not following professional standards on personal projects. That being said, if you have anything you've done personally, even just something like a file uploader, put that up there. Have you tried your hand at some coding challenges anywhere? Upload it. It doesn't even matter what it is, don't be shy. No one who goes through your personal Github will judge you on what you put up there. Just take something, no matter how messy you think it is, throw some PSR-2 config at it and use a style fixer to auto-fix it. Add Travis or something similar to enforce PSR-2. Add a `README` or `samples/` to explain what's going on. Congratulations, your project is now more eye catching than 95% of other projects I'll look at from candidates. TL;DR: When I look at individual projects I'm not looking at how well written or architected they are, I'm interested to see what kind of thought you put into your projects. And putting no thought into them doesn't count as a black mark against you
Same here
Use common sense you will get it, maybe lookup for a framework, if that might help your slow mind to progress it's a win.
Issue responder here. After also having this pop up here, I've decided to actually help that guy and build something. Probably also out of personal curiosity. I've come as far as dockerizing this and make it somehow run. * https://github.com/devilbox/docker-php-1.0 I've then added four example scripts (basically all cgi combinations that were available). Three of them seem to work (or at least show something) * http://localhost/phpf.php (fails) * http://localhost/phpl.php (shows something) * http://localhost/phplmon.php (shows something) * http://localhost/phplview.php (shows something) However, I am still not sure If I've done everything correct, especially the CGI configuration: https://github.com/devilbox/docker-php-1.0/blob/master/data/php-cgi.conf And the other issue I am currently facing is: How would I actually write a simple **Hello World** in PHP 1.0 (This is what I've tried in the above four examples, but none echo out anything from my code: https://github.com/devilbox/docker-php-1.0/tree/master/www)? Anyone with deeper CGI knowledge and/or actual PHP 1.0 knowledge wants to jump in and give a few hints?
Try to use not too much memory. write to an open file handle often and asap. avoid big arrays. Do not do too much sting operation in memory when you can just fwrite it. ;-) so fopen before the loop and fclose after the loop once and run like crazy with fwrite.
I was late in the train, php4.
Yep, good ol' cgi perl....There's a as/400 webserver framework still using it lol
No input other than I enjoyed reading your response. The nostalgic days of refilling printer toner and point and click sysadmin. Those were the days.
PHP was made before I was born lol.
It was mainly just &lt;?php .... ?&gt; fragments embedded in HTML files. Date/time and hit counters, mainly. Only at PHP 3 was it treated as a full-blown programming language.
I don't think a *Hello World* would have looked like that back then... with the &lt;?php ?&gt; stuff and all. Check the history page @ https://www.php.net/manual/en/history.php.php to see an example how code back then might have looked like: https://www.php.net/manual/en/history.php.php (more like some extended ".shtml"-kind of stuff) (I started with PHP 3, so sadly (or luckily) I don't have experience with older releases ;) )
I think Livejournal uses it. Maybe not anymore, it's so different now
Look at cgi-dev 2 it’s an awful rpg web framework used it once god I hated it.
Back when PHP was for C was twig is now for PHP... how times have changed.
https://github.com/phplang/php-past/tree/PHP-1.0.8
Wow. Looking at the history, v1 was released when I was 4 😄
Yep, PHP 1 only really shares a name with the PHP we're all familiar with. The syntax was entirely different, using HTML comments to embed code in the page.
I used php back in the day. At the time most people were doing perl CGI scripts, which was about your best option for doing dynamic web pages. There were no frameworks, no MVC, no testing frameworks. It was the wild west. But PHP was a bit of a revolution because now you could just take your plain old html page, give it a different extension, and put little bits of code in it! It was honestly amazing. And better yet it was pretty similar to C code so it was easy to pick up. Features? No. It had the basics. We weren't doing amazing things back then. But PHP was a great alternative to your other options which were largely C and Perl CGI scripts. Java was just starting up and at the time was really aiming for desktop usage (with it's cross platform UI the selling point was that you could create an app that would run on any OS and platform). The only other competition really that I can remember was Cold Fusion and PHP was a lot more open and, of course, free. I really got into it just before v2 was released, but it was still a bit niche back then. It wasn't until 3 came out and the zend parser came out that it really took off.
Not even that far yet. First of all I have no clue (and couldn't find any info online), which of the cgi scripts I am supposed to use. However I am assuming the one that fails (`phpf.cgi`). However, I only got as far as getting a 500 with the following error: [Sat Apr 20 15:29:11.547926 2019] [cgid:error] [pid 106:tid 139907871192256] (8)Exec format error: AH01241: exec of '/usr/local/apache2/htdocs/phpf.php' failed [Sat Apr 20 15:29:11.548368 2019] [cgid:error] [pid 8:tid 139907653678848] [client 172.17.0.1:48156] End of script output before headers: phpf.php Basically `End of script output before headers`, which after a quick web search revealed that I somehow must first send `Content-type: text/html` followed by two newlines. I tried it with perl (same Docker container) and it works, but PHP 1.0 seems to be a beast difficult to tame.
This is not related to interfaces at all, or rather not just interfaces. Type variance is a property of a hierarchical type system, not just interfaces. **Interfaces do make complete sense.**
Can I be the first non down voted comment? I listened to this, and I was amazed - intrigued and inspired. To start from nothing - as a side project, and to take it to what it is today, love it or hate it, he basically took rails and ported it to php. Not literally but in theory. He made something so easy and so fast to develop in and something that scales and isn't as opinionated as rails but still has its own way of doing things which can be turned off and on.
Thanks for this. I tried it and it's literally over 20 times faster with fwrite. I appreciate the help.
x isn't a number!
Still got production code on 5.3 and most of our work is on 5.6. We have components running on 7.2 but they are very small percentage of the total code base. So yeah people still use 5.
I remember being super equipped with the cgi-bin loaded with NewsPro. Stylin' for 1999.
&gt;built with &lt;3 Ugh. &gt;Built by developers No shit. Anyway, where's the documentation? :p
I thought I was advanced at the time for using Server side includes but started with PHP somewhere before 3. Once 3 came out I switched everything to php3 and thinking back, i don't think I sanitized anything at all, lol.
Thank you
Hi /u/itsumadekokoni, thanks for taking the time to read my article and leave a comment, I really appreciate it. So bad to read that, I'm trying to create my own narrative style and thought to add a bit of sarcasm were appropriate.
Hi /u/akeniscool thanks for taking the time to read my article and leave a comment, I really appreciate it. I consider most of your critiques valid, and think the article could be improved in these and some other ways, however I prefer not to edit the current version of the article (unless I find/someone reports a typo or error in the code), that way I can keep track of my evolution as writer. Nevertheless, I will keep in mind your recommendations to apply them to new articles. Thanks again!
Hi /u/marcusneumann92 thanks for taking the time to read my article and leave a comment, I really appreciate it. I agree that contravariance and covariance aren't just related to interfaces, however I do not agree that interfaces in PHP currently make complete sense because they're missing a crucial feature of OOP.
You're welcome. A perfectly valid decision to leave the article as-is, and apply to future writings. I look forward to seeing more of your work.
You should include more about why this was created, and what problem(s) it solves. In my limited experience with Jenkins, it already knows how to deploy my applications either automatically or manually. Why do I need another app to help me use Jenkins?
Thanks a lot
I think you missed the whole point of the article.... it is basically describing the difference between static!and self.
Don’t forget you VBScript
Perl was the thing on apache web hosts, back in the day.
Mail.pl Contact.pl
&gt; ages 18+ Like what?
Personally I go against half of psr-2. It’s all preference really. Your source code should be readable. For example the OP’s question I put my start { on the same line always with a space before. My ending } is on a separate line lined up with the declaration. The need for the beginning { to be on its own line was due to crappy editors way back when. true, false, NULL, is how I write mine. I use tabs and not spaces. By default a tab is 4 spaces worth and takes up a single character and not 4. Making the files smaller. Just because there is a PSR telling you to do something doesn’t mean there aren’t arguments (valid ones at that) to not do it that way.
+1
All true, but when you have large teams, including some transient members, it's a good idea to use a standard, so that diffs only include meaningful changes.
&gt;Anyway, where's the documentation? :p Since its still in early stages and thing may change - alot. No documentation is avaible at this time. Closer to 1.0 and when the projects api is more finalized wiki will be filled.
Psalm creator here - if anyone has any questions, happy to answer (and if the documentation needs clarification, happy to do that, too). I [originally posted](https://www.reddit.com/r/PHP/comments/7ou7z7/psalter_a_tool_to_fix_the_issues_psalm_finds/) about this in January 2018 - we use this functionality at Vimeo intermittently. I've just added support for removing methods and properties, but that deserves its own write-up. You can play with *that* functionality by using `--issues=UnusedMethod,PossiblyUnusedMethod,UnusedProperty,PossiblyUnusedProperty` with Psalm's latest master branch.
O...K. apparently, I am too stupid to post on this sub. Anyway, I am looking for people willing to help me out maintaining a db-wrapper. **Why another db-wrapper you ask?** Well, it is part of a framework used for a large corporate project so I will have to maintain it. But it is &amp;#x200B; \- fun to code with \- easy to learn/understand \- usable in almost any context/framework and \- less verbose than most other wrappers you know &amp;#x200B; So if anyone is interested in helping me find bugs, write documentation, further develop etc., please let me know.
True, but if you’re running the project you can specify your own standards as well. Hell I’ve even gone as far as packaging atom and distributing it to devs as a standalone atom to use. Which has several plugins to push those standards. Just as some people have mentioned to run a checker before committing. The same can be done for any standard you come up with. While I agree a standard is a must, what standard is used is up to the end user.
Perl was reason why it was easy to switch to php. And as someone mentioned — It might have been called and known as php/fi.
How does Doctrine DBAL (not to be confused with Doctrine ORM) not fit all of those points?
I started with PHP 2.0/FI in September 1998 and age of 16. I definitely remember it was way before we had the php3 extension to differentiate between 2.0 and 3.0.
How the hell did you find a linux distro old enough to compile it? That's the biggest problem I had with trying to get PHP3 compiled. Glibc had moved well well on.
&lt;?php didn't come about until after, and as a response to, &lt;?xml. in I believe 1998. Back in the PHP/FI 2.0 days, all we had was &lt;?. I remember &lt;?php coming out in PHP4, if I'm not mistaken.
I have nothing bad to say about DBAL. The approach of writing queries is rather different, though. It uses a Singleton which is very straight forward and readable, but can become verbose. Example DBAL: $queryBuilder-&gt;select('id')-&gt;from('users')-&gt;where('email =?')-&gt;setParameter(0,$email); Same in neoan3db: Db::easy('users.id',['email'=&gt;$email]); Both would translate to the same prepared statement, but you can see how developing a bigger application can be faster with less code.
Lets do it!
Yeah. That was or is still a part of asp isn’t it? I still, seldom but still, see websites with vbscript ado database error codes. 😊
I saw the tweet which showed the massive removal diff after your team ran it on the Vimeo code base. Was pretty impressive.
Should also be noted that psr-2 was voted in by 22 people. Out of thousands (probably millions) of developers.
Why not just use a Data Access Object instead? $UserDAO-&gt;set_email($email); or $UserDAO-&gt;set("email", $email);
Faster with less code is debatable. Problems I see include ambiguous api. Ask and Easy aren’t very descriptive. Your configuration is stored in global scope and is hard coded in source rather than an injectable configuration. And lastly, it’s a static singleton, meaning working with multiple databases is virtually impossible. I’m sorry, but I’m just not seeing it
lets not for all the reasons outlines
Grpc supports persistent connectiond via fpm &amp; extension which I think is what gives it the performance edge.
`PHP_EOL` is nice for visibility in code, but you're right it's not required
That's fair, `PHP_EOL`.
Yes, ask and easy are naming choices one can certainly argue about. The fact that the configuration can be handled by defines (if this is what you meant by hard coded) is neither a requirement nor does it prevent changing the environment variables during execution (and therefore e.g. switch databases). It is merely a possibility to 'auto-set' configuration. But you sound pretty set and I don't want to press you. I can tell you really looked at it and I thank you for your consideration, assessment and time.
I would say that is a good solution for handling model-data in general, but now show me your DaoFactory or whatever layer deals with actual db-operations.
O believe i started around php3... But I have long since stopped working with php, I believe during php5 was when I moved away from it.
Interesting. Wasn't the owner of PHPStan planning to offer baseline functionality as a paid feature?
psuedocode: &amp;nbsp; UserDaoFactory create($user_id) $UserDAO = new UserDAO($user_id); &amp;nbsp; UserDao var $user_id __construct(user_id); set(); get();
Oh damn can't use your package, need to be 18. Will you make it available to under 18's in the future?
Was the wild West back then. I feel like just now we are approaching a moderate level of stability and maturity on 'the web'.
This is above and beyond. 👏👏👏👏👏👏
Not sure if you're up to constructive criticism, but I can't hold it anyway. I would say that your wrapper can be distinguished by a very common feature, which many beginner developers are prone to: to me, the aim of this wrapper is to write as little code as possible. So it makes the code *easier to write.* However, when gaining experience, developers tend to value the code that is *easier to read.* Because writing a code is trifle. While debugging and maintenance *are* real things. And in this regard, I would say, your wrapper loses to the plain old SQL or any other *verbose* syntax. Honestly, SQL clauses and functions are *named for the purpose*. `CONCAT_WS()` tells you what does this function do. Or at least lets you to google the purpose. What I am supposed to google looking at a code like this? `Db::ask('/user',['name'=&gt;'Richard Hawk'])`. I would say that your entire wrapper is an overgrown [beginner's `select()` method](https://phpdelusions.net/pdo/common_mistakes#select), written out of the same premises - to save yourself typing of "useless" SQL keywords. Although you can use your wrapper at your job, which, among other things, would provide the job security for you, but such a newly invented syntax would hardly be received enthusiastically being offered to the community. Because things that many people are supposed to work on must be comprehensible and easy to pick up. But, I said already, your syntax is very quick to type but very hard to pick up.
An obligatory note on SQL injections. First of all, the escape() function you are using on table names does escape *anything but the actual symbols* that could break SQL syntax for the identifier literal. You need another method to quote identifiers that would do it according to mysql syntax. Next, writing INSERT and UPDATE wrappers is a tricky business. Because of, again, SQL injection. I even wrote an [article that demonstrates the actual injection](https://phpdelusions.net/pdo/sql_injection_example), which, although based on PDO, demonstrates the principle which is universal for any driver. I can take it that all array keys are already validated in your application and thus cannot contain any malicious code, but when offering your wrapper for the common use you have to look at that from the different angle: there is no guaranty that some user would put the array keys right from the user input (which is somewhat follows your paradigm of "writing as little code as possible"). Therefore, your insert and update methods must provide a solid protection for the field names.
Quoting https://en.wikipedia.org/wiki/Nimda , "_Nimda is a malicious file infecting computer worm. It quickly spread, surpassing the economic damage caused by previous outbreaks such as Code Red. The first released advisory about this thread (worm) was released on September 18, 2001_"
Author of PHP-CRUD-API here, maybe my little project can help you out. See: https://github.com/mevdschee/php-crud-api
I think so, do you mean this one? https://medium.com/@ondrejmirtes/next-chapter-in-phpstan-saga-3bfd7ffdb81d
Great job! You should write more about these features. Static analysis is great, but **static analysis working for us is much better** :) I do the same with Rector so I'm happy there is more of us now. Btw, I looked for a PR to Psalm itself, that would run type changes + removing dead code, but I couldn't find any. Do you have some?
&gt; How the hell did you find a linux distro old enough to compile it? I didn't, I am evily compiling three times to get the job done: https://github.com/devilbox/docker-php-1.99s/blob/master/Dockerfile#L19-L21
Which extension. Can you point me to a source?
\`try { /\* code \*/ } catch (\\Throwable $) { /\* handle \*/ }\` &amp;#x200B; How is this not generic handling? &amp;#x200B; Since you reply to none of my counter arguments and just keep re-iterating issues I'm responding to I'm just going to assume you're only here to troll. I'm gonna spend my time elsewhere.
&gt; Since you reply to none of my counter arguments and just keep re-iterating issues I'm responding to I'm just going to assume you're only here to troll. I'm gonna spend my time elsewhere. Oh dear. I was quite happy to keep it to debating the technical merits, but you seem to want to make this personal. I'm regret to inform you, that your inability to understand the merits of an argument, does not make those merits any less valid. One would have hoped that numerous independent engineers arguing the same, or similar points, would have provided you with some insight into the scope of the problem in real-world applications. I would further add that the (tiny) sample size of comments / votes on this thread, suggests your counter-argument has failed to be persuasive to others. I don't mean to take anything away from you, your package is well used, and is, for the most part, well designed. Your interaction with others, like your exception handling, has scope to improve.
He is not interested in fixing these issue for years now. He just would call you a "troll" when you insist discussing these problems.
&gt;The combination between named autowiring aliases, expressive configuration and the recipe make the experience really nice IMO Setting up Flysystem Services in DIC
Sidebar reading? Where you promoting your site in some way?
&gt; Sidebar reading? Yes I read the sidebar therefore here the question because I don't understand it. &gt; Ask questions about frameworks but &gt; No help posts and &gt; not including discussion but often a discussion is a question. --------------- As you can see I don't get it. Even if I read the sidebar.
And that's PHP. Roll credits
Ask q about framework.. EG. Whould cakePHP or Symphony meet my needs for x project? No help posts: Google/stackoverflow instead. No discussion: ie. don't spew an opinion about something you hate/like
There are subs specifically set up for help with programming. Try r/PHPhelp. It's simply not what this sub is for. This sub is for topical discussion, sharing news in the PHP community and talking about interesting new tools and libraries. If it was open for questions/ troubleshooting that content would swamp the sub and all the topical discussion would get drowned out. Use r/PHPhelp to help get answers to problems you are having, use this sub to share a new library you like or talk about your opinions of different methodologies or talk about professional issues in industry.
I don't think it's possible to draw a line. There's many reasons why a question would be worth here. It depends a lot on the question. There's questions where the person asking does not need help per se.
Yes I know that one but for example this post https://www.reddit.com/r/PHP/comments/bf8p0b/file_put_contents_is_too_slow_am_i_doing/ it hot here in this subreddit. Why is this one not considered as help post and therefore it should not allowed? And why some people can post a description and not all users? &gt; This sub is for topical discussion, sharing news in the PHP community and talking about interesting new tools and libraries. use this sub to share a new library you like or talk about your opinions of different methodologies or talk about professional issues in industry. How if I can't post a description? Often Topics need explaining but I can't explain them just only in the title.
Unfortunately PHPhelp is a small subreddit so help is limited.
The tiny volume of posts on phphelp shows that there’s no danger of “drowning out discussion”. All that’s really changed is that /r/php has become a dead zone.
The OP clearly said they understand that, you're not answering the question. The question is why posts are allowed that belong in /r/PHPhelp. Stating what /r/PHPhelp is for doesn't answer that.
&gt; Ask q about framework.. EG. Whould cakePHP or Symphony meet my needs for x project? But why is this not a help post? &gt; No help posts: Google/stackoverflow instead. And why are some here even trending/hot? https://www.reddit.com/r/PHP/comments/bf8p0b/file_put_contents_is_too_slow_am_i_doing/ https://www.reddit.com/r/PHP/comments/bdig5s/any_compelling_reason_to_use_soap_vs_file_get/ and so on... &gt; No discussion: ie. don't spew an opinion about something you hate/like Sidebar says discussions are allowed.
That post is in a bit of a grey area because it raises an interesting discussion point about the behaviour of PHP. You are right though that it is often up to mods to use their discretion. It's an important rule otherwise you can guarantee every other post would be "I just updated my wordpress website and now it won't load please help me".
I really don't know what to say to that. Your abstraction layers make sense, but none of this is dealing with databases. Either I fail to see what you want to convey here or this is simply off topic.
Okay but how to write a description for that question? I only can post a title.
Please don't take this the wrong way, but to evaluate on which level I would like to respond to this, may I ask at how many years of experience you can personally look?
Ahh now I get it why the rule exists. It's not to prevent question/discussions it's more for to prevent questions from wordpress/lower skilled php devs. But what I need to to do write a description? I can just only post a title.
They are not *allowed*. There is no AI to tell a help post from a discussion post, so help post just *appear*. But supposed to be eventually removed when one of moderators wakes up from the hibernation.
I'm sorry that you confused sarcasm with White Supremacist ideology that insinuates that Native Americans didn't exist until a White man found them.
I really don't see why questions aren't allowed here to be honest. It's not welcoming to the wider community and /r/phphelp (and this subreddit) don't really get enough posts for the requirement to be warranted. I really wish questions were allowed here but were simply flaired as such so people who wanted to could filter them out.
Text posts are probably disabled through subreddit CSS. I'm using RES and have CSS in all subreddits disabled (so they all look the same) so I disabled the disabling of text posts.
This is a complex question. Speaking of years, there is a lot, but I am a slow learner, so let's call my experience moderate. I worked at several projects, years long, using the full range of database interactions - from raw API calls to Doctrine.
It drowns information in noise honestly. To me those questions are extremely annoying because I am here to find useful links and read discussions.
If it is a matter of removing those posts I would be glad to help.
I don't think this subreddit should suffer because of that. This subreddit is not about technical support (per the rules), so I don't see why another subreddit's successes or failures should make us ignore the rules of this one.
That's a legitimate response, I appreciate that some communities have been overwhelmed by the noise to information ratio. I still hold my opinion, that I would prefer to be more inclusive of questions (most people get a "rude" response of: post it to /r/phphelp instead of here), but I understand why you feel that way instead.
I've been following your twitter discussion, I don't have an active account on there so I'm going to reply here with a few points: ```php try { /* some flysystem operation */} catch (\Throwable $e) { // Without knowledge of the underlying adapter, please explain how // I would know if this is a permanent error, or temporary // such as network conditions } ``` ```php try { $fs-&gt;writeStream('/my/path/here', $fp); } catch (\Throwable $e) { // Without knowledge of the underlying adapter, please explain how // I could tell a permissions error, from a network error, from // something else } ``` For something that handles exceptions better, I invite you to take a look at Guzzle, which as I'm sure you know, is likely the underlying HTTP framework for almost every API based adaptor Flysystem uses. Catching TransferException acts as a catch-all for Guzzle operations, if the caller needs to be specific in their handling, they can first catch ConnectException and know it's an issue before connecting to the server, or a ClientException to handle cases where the server rejected the request, or ServerException for if there was some kind of unrecoverable server error. It allows the programmer to write code to handle specific error conditions, and present the user with an appropriate error message. If I want to do that now, I have to take every call to Flysystem, and wrap it in an all-encompassing try / catch block, then, with full knowledge of the adapter, inspect the contents of the exception and translate those into something I can respond to. If I change the adapter it uses (such as if I switch from AWS to GCloud, Azure etc), then I have to change my code at every call site to be able to get meaningful information out of it. Obviously I can wrap this, but when you present your system as an abstraction library, I naturally expect these differences to have already been abstracted away so I don't require underlying knowledge. As I've said before, I shouldn't need to know, or care, which adaptor the Flysystem was initialised with. I see you are working, or at least contemplating, writing version 2.0. I would strongly suggest you take the opportunity to develop an exception tree, and enforce that your adapters throw meaningful, standardised exceptions in the event of an error. ```php public function writeStream($path, $resource, array $config = []) { /* ... */ try { return $this-&gt;getAdapter()-&gt;writeStream($path, $resource, $config); } catch (\League\Flysystem\Exception $ex) { /* well behaved adapter already converted its exception */ throw $ex; } catch (\Throwable $ex) { /* this adapter black-boxed an error */ throw new League\Flysystem\OperationException("An unhandled error occurred while writing the file", 0, $ex); } } ``` I wish you all the best in your future improvements.
&gt; it's more for to prevent questions from wordpress/lower skilled php devs. rephrase that to questions _too trivial that can be solved with a google search_
Do you use an app in your phone or a browser to access Reddit? I'm on my phone, using reddit loosy app, it allows title and text (optional) - when I go to add post. As for questions, I think it is in the interest of the person asking that they are not allowed, as there are few questions about php that have not been answered in stackoverflow yet. And agree with people saying it is a gray area, one cannot automate their removal, and sometimes a question can trigger interesting discussions about some PHP behaviour/limitation. Mods are right to allow such questions to slip in.
Mee too. I use the redesign. Every subreddit looks the same but I still don't have that text field. This hinders good discussions to provice all needed infos. Maybe it is linked to karma?
&gt; Do you use an app in your phone or a browser to access Reddit? Desktop, Windows (Mac). This is how it looks for me: https://imgur.com/W78kqKD
Maybe the rules should be changed.
&gt; But supposed to be eventually removed when one of moderators wakes up from the hibernation. This makes me laugh ^^
And questions of which the answer is only helpful to the person posting it. I categorize it as 'selfish posts'.
With C++ optimizations turned off, nothing to see here folks.
Test it in your phone, it seems to be an interface limitation in the browser CSS - I guess not intentional.
But a lot of ppl. will not post here because it could be a question/discussion post. As a whole php community we prevent here good discussions because ppl. think it does not belong here but in fact it would be fine here. And that you can't post a text/description hinders as well a lot of user to post here good and helpful discussions.
[removed]
But great result for PHP nevertheless!
On the phone it works but this issue is already there since I joined this sub about 10 month ago. I use the redesign of reddit I should have no custom css. I don't get it...
The escape function is indeed something on my list and there are more considerations to the purpose and intended use that go beyond escaping possible injections. As for securing keys: That is an interesting opinion and reminds me of a discussion I recently encountered where people blamed Laravel for making it possible to "misuse" a function and therefore create a security risk. From a structural standpoint: promising secure column escaping might prevent injections, but if used effectively allows the client to "send" custom queries, posing all kinds of security risks not associated with injections. (E.g. Why bother with injections if you can change someone else's password) This is why even if the wrapper would provide such a feature one MUST take care of securing/constructing the passed in arrays. Hence I think what you are suggesting is not a db-wrapper's task, but depends on the application/framework and respective structure.
Permission errors are not in Flysystem's scope, regardless of what your opinion on that matter is. As I've said before, the library will not verify your credentials. You should configure your adapter correctly, those exceptions shouldn't be handled at runtime. So any exception you get should be handled as catastrophic failure, be it network errors be it otherwise. In those cases there's only a few options, you can fail or retry. Runtime code should not be responsible for non-runtime issues. &amp;#x200B; In terms of you being right because you had some upvotes. There's hardly been any issue or PR adding exceptions like the ones you describe. Also, you can be rude and insulting all you want, but what I do with my free time is my choice. If my work bothers you so much, feel free to not use it. It's all the same to me.
&gt; and intended use that go beyond escaping possible injections. This statement is wrong on many levels. First of all, **no escaping is ever intended to deal with injections**. That's two different realms, only slightly interconnected. Using escaping to prevent injections will inevitable make your code prone to one. **The current usage of the escape() function is a textbook example.** Second, any function "that go beyond escaping" is bound to corrupt your data, at the same time guaranteeing no security. Sadly, but you are yet to learn basic security rules, and it means that your wrapper should be discouraged from use.
So to sum up whats in the thread: Fibonacci (n=32) time: PHP 8(?) no JIT: 0.1779s PHP 8 JIT: 0.050s C++: 0.047s C++ optimized: 0.0188s So its a really good improvement for PHP. Its not like we are at actual C++ levels of performance but that will never be the case. And this is a really specific case where JIT helps to improve the performance, there's a lost of code that won't have any speed improvements from JIT.
Precisely.
What I'm trying to say is that you can abstract away the database layer so that you can use an existing DB wrapper without sacrificing concise code.
Wow. Vtec kicked in. No seriously it's great.
It's just not comparable, and you know why.
I see. I had to ask as I confess I developed some sort of scepticism over the years concerning "technical writers". Many of them overestimate their knowledge and lack actual production experience. And assuming you have the proficiency to provide valuable input, I still have to take into account that at least as a secondary goal you will want to drop some links to your articles in here. That said, I have a different opinion on the balance of providing a low learning curve and intuitive readability - and production speed. This is surely a question of personal preference, but my personal experience has given me the impression that picking up required patterns for particular use-cases overweighs the initial hurdle, given the team's velocity picks up marginally due to adoption. However, that depends on the size of the projects, I suppose.
I mean, if you really want fast speed with some PHP module, you should have written that module as a C/C++ extension to begin with.
And at n=32 no less. The error margin is so large that the results are meaningless either way
How does this compare to PHP7?
&gt;Great job! You should write more about these features Yeah, articles are great (but when there's a choice between writing articles, documentation, or code I tend to lean on the code &amp; documentation sides). &gt;Btw, I looked for a PR to Psalm itself, that would run type changes + removing dead code, but I couldn't find any. Do you have some? Not sure I understand
I'd be happy if you were able to provide something more constructive. Why don't you provide an example to demonstrate vulnerability? This would give me something tangible rather than having to explain how/why we have a miscommunication regarding what the intended use of the escape function is.
One word: StackOverflow :o
StackOverflow already exists for that sort of thing. The last thing I want is to be deludged with a whole bunch of "HALP! My PHP4-esque terrible code isn't working and I dno't know why!" and it's some really stupid typo [pun intended!]
old.reddit.com
It was &lt;? with PHP/FI 2.0. &lt;?php came out only after &lt;?xml was invented and popularized, circa 1999.
Your history is fuzzy. The first 3 PHP versions were largely the sole work of Rasmus Lerdorf. Zend Engine wasn't invented until PHP 4. And PHP 5 represents the great refactor and when Rasmus went from lead architect to regular dev + evangelist.
&gt; StackOverflow already exists for that sort of thing. No on stack are only questions allowed you can answer. Discussion are not allowed. Reddit should be a place for that.
Boy, it shows how fucking old I am, but I remember from the PERL and C++ CGI days that the very first thing you ever outputted, before the first &lt;html&gt; was: echo "Content-Type: text/html\n\n"; That's ESSENTIAL to avoid those "End of script output before headers" CGI errors!
I co-wrote the first PHP bot EVER. Ran in PHP 4 as a DAEMON largely on Undernet's IRC servers where it was a channel mod / keeper. It was the first PHP daemon of its kind and it had a frontloader that let 95%+ of it be updated without needing to restart it, which was CRITICAL to maintaining control of an Undernet channel. By the time I was done, you could control it via IRC private message, DCC message, telnet, the BRAND NEW SSH, http://localhost/, and the BRAND NEW PHP-GTK! It was really state of the art. I ended up writing it to ask for, download, parse, and allow users to search for everyone's MP3 playlists. I ended up with a MySQL database that took up all 5 GB of my hard drive back then and indexed some 1 TB of mp3s. https://sourceforge.net/projects/phpegg/
TBH not everyone who is interested in a consolidated place to speak and view what's going on with PHP likes to see people ask questions like how to connect to a database for the 10,000th time in the same day. If your question can be quickly Googled, you need to be flogged for posting it here and not in /r/phphelp -- strictly for cleanliness' sake.
Thanks for the correction.
I understand. It's out there for over 15 month and I just learned about it yesterday. Judging by up votes it's new for more people. I mean real PR where you applied these rules. Not just screenshot of +/- numbers.
The PR is an internal Vimeo one
&gt; most people get a "rude" response of: post it to /r/phphelp instead of here To be fair, the sidebar very clearly states that all support questions should be posted in /r/PHPhelp. After a certain point it's very easy to get annoyed by such posts - it's not like this info is hidden somewhere.
Apologies for not replying sooner. Migrating a complex ZF1 application can be tricky and fully depends on the type of project and the client's short and long term plans. First, you have to realize that you cannot do a clean migration from ZF1 to ZF2+. ZF2 was, for many core components, a complete rewrite without any upgrade plans in place. If your project is only upgraded/migrated to be able to run it on PHP7.2+, I would suggest you keep it as is and only apply PHP7.2+ fixes to a forked ZF1 and possibly hide the application behind a strict firewall. When we migrate a ZF1 application, we somewhat follow the following steps: - Document all features and functionalities of the application. - Define which functionalities can be removed, which need to stay, and which need a rewrite or modification (and in what timespan). - Define how you are going to replace each core ZF1 component (with what other library, in what style, etc.) and what the new project structure needs to be. - Write a quick and simple functional test suite of all functionalities which will be kept. - Set-up a Symfony environment with a ZF1 fallback system. All requests will be routed through the Symfony app. - Add various ZF1 adapters (such as a base controller with methods matching the ZF1 controller, a symfony/templating engine using Zend_View, various factories based on Zend_Application_Resource logic) to be able to quickly migrate all ZF1 code to the Symfony app without having to rewrite most of the code. - Start moving the ZF1 code to the Symfony app, using the new project structure. - Start actually migrating the code to new components. We usually do this in order of importance, based on the most pressing new feature requests. We usually choose Symfony as the framework to migrate to as it is incredibly flexible and allows you to temporarily run ZF1 code within the framework until you've migrated a component. My main advice would be to create a new environment as soon as possible, as ZF1 is just not flexible enough to temporarily run modern code. Furthermore, I would suggest you do not blindly migrate a ZF1 component to its ZF2 counterpart, as some components are either abandoned or possibly lack modern features you'll need. Instead, look at what the project needs in the (near) future and with what modern package you can implement this most efficiently. Good luck!
You can Google it. Stack overflow is full of direct answers to a question like this. You may start from realizing the fact that escaping is orthogonal to injections, and should be never used to prevent them. Although generations of PHP users indeed thought otherwise, it is not so hard to realize the actual purpose of escaping if you take time to think on the matter. I gave you some pointers in my other comment, but you preferred to shrug them off. A "security of your database interactions is none of my wrapper's concern" attitude is appalling, if you ask me. But as long as you keep with it, it gives you power to dismiss any evidence. It means I'd just waste my time
You are in the full right to think like this. I am just trying to explain why it would be hard to rally other people under your banners.
In here. Everything decided for that version yet has been many times already posted in this sub. Mostly it's the further language cleanup. As of the new features, they will be added eventually, during the development of this version that is just started. So it's somewhat naive to expect the foll list of changes at the time.
This place literally receives like 2-3 posts per day on a weekend and maybe 5-6 posts on a weekday. It's not a matter of enough manpower, it's that whoever is already in charge just doesn't care enough to put in any effort.
&gt; As a whole php community we prevent here good discussions because ppl. think it does not belong here but in fact it would be fine here. Help posts almost never result in an actually valuable discussion, at least from what I've observed.
Stackoverflow has become cancer due to the overmoderation. Everything is breaking someone's interpretation of the rules. People only care about their points there, not actually being of help to someone. And god forbid you try to post in some of the older tags like C/C++. You'll be chided for even stepping foot in "their" domain without first having read Kernighan &amp; Ritchie/Bjarne Stroustrup. The only good things that come out of SO are from 2+ years ago. Now it's just a festering cancer waiting for something better to come along.
the problem is not "lack of covariance and contravariance", but the lack of generics. in your C# example, you used generics to solve it. if we take a look at PHP cousin, HackLang ( already have covariant returns and contravariant parameters ), we will run into the same issue, and to solve it we would use generics. Hack Samples : * Same issue as PHP : [https://gist.github.com/azjezz/811e6beaaa85b1146b776b3622a4ce4a#file-type-error-hack](https://gist.github.com/azjezz/811e6beaaa85b1146b776b3622a4ce4a#file-type-error-hack) * Solved with Generics : [https://gist.github.com/azjezz/811e6beaaa85b1146b776b3622a4ce4a#file-generic-hack](https://gist.github.com/azjezz/811e6beaaa85b1146b776b3622a4ce4a#file-generic-hack) &amp;#x200B; the `ParserInterface` promises that it accepts `Format`, meaning any class that extends `Format`. while `JsonParser` accepts only `JsonFormat`. therefor, its breaking the promise it made by implementing the `ParserInterface` interface.
But the help posts aren’t looking for a discussion, they’re just looking for an answer. Stuff posted here about discussing using X vs Y is (usually) fine.
There is full list of new features in PHP 8: https://wiki.php.net/rfc#php_80
I know. I ask for some other external PR on open-source project that shows the real-life usage.
It's not that hard to implement since it's based on the open-source project. I've added cache locally for one project where I had to wait for 10 seconds, to see the result. It was under 1 sec then.
Why I should use node over PHP? Why should I use PHP over node? All questions and a type of help post which are not allowed. So we cant get into a discussion.
Plus the removal of all existing deprecated functionality :)
Not bad. How does one get ahold of this development version of PHP8 w/JIT?
Writing C or C++ is a lot more work in development and maintenance and makes deployment more complicated. The less this is needed, the better. Also if PHP becomes more efficient and you are under load it can reduce hardware needs which is good for your wallet and the environment. How well PHP-JIT will work for general purpose use cases is to be seen.
I can't speak on behalf of the moderation team, but I have no issue with that type of discussion happening here (other than the pointless circle-jerk that it will inevitably devolve into). Although if it becomes the same question twice a day, it becomes stupid. Something more like "Those who migrated between PHP and Node, why did you do it?" could actually lead to something interesting. If you're just looking for strangers on the internet to validate the decision you already made, yeah, go away. In my mind, a help post constitutes debugging code. And skimming /r/phphelp for the first time in a year, that's mostly what's going on.
People have lives and jobs. Not everyone has a strong desire to spend all of their free time waiting for something to pop up in an unpaid moderation queue.
[haven't seen that meme in a long long time...](https://i.kym-cdn.com/photos/images/original/000/626/354/cea.jpg)
I am interested if JIT will improve regular apps that are running under swoole or similar solution. i.e. when PHP stays in memory instead of dying after each request.
For normal PHP: 0.1779s
I played around with PHP 2/FI. I remember rolling my own session code because there was no session handling in PHP. There was a library called something like PHPSessions which I think worked with PHP3. Looking at the current docs for functions like session\_start(), it seems like sessions were built in until PHP 4. &amp;#x200B; I mostly remember initially playing around with ASP / VBScript and then discovering PHP which seemed a lot more flexible. PHP could do many of the things that ASP needed addons for, i.e., binary DLLs which hosts were reluctant to install.
You can do both with the mobile app. You can only add titles on the webpage
But this must be a bug or not?
No, they did it on purpose. They don’t want people asking for php help on this sub. They want those posts to go to r/phphelp. This sub is more for sharing links and talking about php as a language
How does `PossiblyUnusedMethod` work? I would have imagined you'd have to give Psalm one ore more entry points to assume are used, and then anything that can't be reached from there is unused. But [the docs](https://github.com/vimeo/psalm/blob/3.2.8/docs/fixing_code.md#possiblyunusedmethod) don't say anything about specificying an entry point.
Thanks, that's really useful. We're planning to migrate to PHP 7.1 from 5.6 this week, as I've been using that in dev since November, and on UAT for a month. After that we're going to talk to the client about the long-term plan and mention that if it's going to be around for any length of time they'll need to budget time specifically for migration. The application doesn't actually use all that much of Zend - it uses zend-db and zend-forms, and not much else. It only uses zend-cache for the database metadata, and when I needed to implement caching I went straight to Stash with Redis. The biggest issue is likely to be migrating the queries since they're by far the most used part of Zend. There's also some very fat controllers. While it had no tests when I inherited it and it's very difficult to test, I do have some basic Behat tests and some snapshot-style tests for checking for unexpected changes in the output, and those should help. Again, your insight is much appreciated!
That is always hard. This is why well documented libraries are rightfully collecting most users, therefore most collaborators, therefore most potential to further develop, update, bugfix and so on. It's almost like you need some kind of marketing to hit the ground running.
Thanks, that's really useful. We're planning to migrate to PHP 7.1 from 5.6 this week, as I've been using that in dev since November, and on UAT for a month. After that we're going to talk to the client about the long-term plan and mention that if it's going to be around for any length of time they'll need to budget time specifically for migration. The application doesn't actually use all that much of Zend - it uses zend-db and zend-forms, and not much else. It only uses zend-cache for the database metadata, and when I needed to implement caching I went straight to Stash with Redis. The biggest issue is likely to be migrating the queries since they're by far the most used part of Zend. There's also some very fat controllers. While it had no tests when I inherited it and it's very difficult to test, I do have some basic Behat tests and some snapshot-style tests for checking for unexpected changes in the output, and those should help. Again, your insight is much appreciated!
[removed]
[removed]
I mean, I never claimed writing a C++ extension is NOT any of the above things. The whole point of PHP is the relative speed of development and ease of maintenance/deployment - each C++ extension does not have those benefits, and complicates deployment. That being said, **IF** you need speed that bad, you can probably afford the resources needed to develop such an extension (and it's probably still way more efficient than writing the whole server-side with C++).
If you have Internet access you can just download it.
the negative index array one still has me confused. never really ever seen an array start with a negative index before or know of a use case. maybe someone can enlighten me?
[https://imgur.com/a/okahSTG](https://imgur.com/a/okahSTG)
It would be great if a future version of psalm could detect line 5 in https://psalm.dev/r/bbe123d053 as dead code, and psalter could remove lines 4,5,6 and 8.
I was asking for a tangible example as that would have given you the chance to notice that the escape function does not escape values as you seem to believe. It was meant to address certain pass-through declarations of the framework the wrapper originated from and now needs to be reconsidered. You will find it being used in the delete-function which, as you might imagine, is not intended to ever receive User-Input in the sense that the client determines which table to delete from. By no means do I hold the position that the wrapper should not ensure security. What I am saying is that at one point the coder HAS to make sure to define possible columns. This can never be left to user input directly. In an extreme example: Db::easy('table.*',$_POST); One can see how securing the keys of $_POST against injection simply wouldn't scratch the surface of what's concerning about such a use. So forcing the coder to e.g. a manual solution like Db::easy('table.*',['column'=&gt;$_POST['column']]); Is still better than telling him: don't worry, your keys are secured against injection. This is what surprised me in your article about injections and this is why I asked for your production experience. While looked at it isolated your remarks make sense. From a standpoint of a complete application however, one would question how that alone would guarantee a secure interaction with the DB, if ultimately the WHERE can be constructed by the client. But let's try to realign ourselves: I guess neither of us is here for the purpose of debating. Can you offer improvements or provide a realistic example that shows vulnerabilities? If so, are you willing to share that in a way that helps me addressing these findings? I do not want to have "the power to dismiss security concerns", but am interested in providing a stable and secure solution. Given my familiarity with the code-base, you must understand that my approach is based on a more practical rather than theoretical perspective. This is why I do value your remarks, but need some hands-on examples in order to evaluate actual risks.
Yeah, this whole thread has me a little confused. Of course it can't *really* compare to optimized C++. That would be ridiculously disappointing for C++ if a scripting language with a JIT compiler could match up to its performance abilities. That's part of the trade-off when choosing languages. And yeah, this post is a contrived example, so developers may see better or worse performance ratings for their use cases, which also affects their decision on what languages to choose. That's the decisions developers have to make. To me, those saying it isn't cool to see this progress are being oddly pessimistic. It's a good improvement, but I what are the expectations for a noteworthy improvement? "PHP officially faster than languages associated with good performance" doesn't seem like a realistic headline.
Damn, I wish I had internet.
That's great and all, but it's not representative of real world workloads. There's a massive difference.
I’d argue that’s basically impossible for a public GitHub project that I’m not the maintainer on, because there’s no way of knowing for sure what plans there are to use things in the future. At Vimeo I (mostly) know what’s what.
See I hate the constant noob questions. Same with all the web related subreddits I'm in. I am a professional and I want information and news. Once I get past the first 2 or 3 pages of my personal feed, everything from php, web_design, webdev is all just stupid questions. It's really frustrating.
I’ll write up something properly soon, but have a look at the [release notes](https://github.com/vimeo/psalm/releases/tag/3.2.8) - basically you have to use `Codebase::methodExists` in plugins to register methods that Psalm cannot see. You also need to be using `--find-dead-code` (or the same option in the config).
In my opinion this sub is truly of very little value.
I think a main target of that RFC was the array_fill function. Any reasonable person would expect `array_fill(-2, 5, null)` to return `[-2 =&gt; null, -1 =&gt; null, 0 =&gt; null, 1 =&gt; null, 2 =&gt; null]`, while (prior to that RFC) it will actually give you `[-2 =&gt; null, 0 =&gt; null, 1 =&gt; null, 2 =&gt; null, 3 =&gt; null]`. Apart from that particular WTF, I think this is a pure consistency RFC, not something that one would generally encounter in practice.
Just for demo
ah, yeah that makes sense. thanks for the response :)
all my clients requesting Fibonacci things will be so happy. nevertheless, this is amazing and I can't wait to see how it affects real word apps. I'm quite sure php will finally loose this "slow" stigma.
If those apps use a lot of native PHP functionality ( not C calls to extensions ), then the answer is Yes. Swoole has no effect on the PHP code being run, Swoole simply provides a build in HTTP server for PHP, that prevents PHP from dying on each request. On every request, you are still going to run the PHP optimized code. If this was "old" PHP or JIT PHP optimized code, its the same from Swools perspective. The reality for web development, unless you run very mathematically or specific code, the JIT is not going to improve performance that much as DB access will still stall you the most. Now, if you are running heavy tasks like image manipulation in pure PHP or Excel generation, i expect to see a large increase in these tasks. Another angle where you will see more advantage, is pure scripting tasks. The best way to compare the new JIT, is that it opens up some doors that used to be slow in PHP. And moves PHP more in the level of something like Perl perhaps? The real power for Web development, is Swoole because it forgoes that horrible PHP dying on each request. But it also introduces a different design / programming paragon on the level of Go, as you need to be more careful to clean up your dinner on each request. For normal PHP users, who do not rely on Swoole, PHP 7.4 with Preloading will also introduce a hefty boost but not on par with something like Swoole. So the future will be more: PHP 7.4 ( + JIT 8.0 in the future ) for the people using the old way PHP 7.x + Swoole ( + JIT 8.0 in the future ) for the people who want more speed and are willing to deal with the issues that arise of holding PHP in memory.
yours &gt; escape function does not escape **values** as you seem to believe vs mine &gt; the escape() function you are using on table names does escape anything but the actual symbols that could break SQL syntax for the **identifier literal** alone shows the communication gap. Anyway, &gt; You will find it being used in the delete-function which, as you might imagine, is not intended to ever receive User-Input but the function is called anyway, being absolutely useless here, no matter whether a user input is expected or not. Which is illogical to me. Another problem is that you are asking too much from your library's user. &gt; What I am saying is that at one point the coder HAS to make sure... is not far from saying " the coder HAS to make sure that all values passed to the database are properly escaped". Which is again a logical contradiction to me: you agree to secure the values, but refuse to secure anything else. It's hard to communicate when you don't get the other party's logic. To me, the protection must be full and consistent. You are right in regard of giving a user the control over the field set, which is mentioned in my article. But the only proper solution will be **to make it just impossible** to let the user input into array keys. Otherwise an injection will happen, sooner or later. And you will blame a coder, not your precious library. Given such attitude, I wouldn't recommend it to anyone.
C++ optimized was also posted. Still, a 3 times boost compared to "old" PHP in a very specific test, is not something to look down on.
We just upgraded to php 7 at work it’s steps ahead of the previous version
The issue is that some resources are not readable available in pure C++ extensions. One the comes to mind is PHPExcel / phpspreadsheet. I expect that JIT in case of this might generate some noticeable performance boosts. Or how about PDF generation or other tasks tasks that may grow in complexity and execution times in pure PHP code. And yes, i know there are ways to get faster Excel/PDF generation but most are not exactly as user friendly as simply installing some PHP code ;) Most of use do not have the time or money to spend on writing C/C++ based extensions for PHP. So any speed boosts to PHP is a always welcome addition, even when its only in specific cases.
Fair enough, the escape function threw you off and I understand how it doesn't make sense to you in the context of the wrapper alone. I get that but don't see value in explaining why it is still there if it will need to be repurposed anyway and doing so would introduce a complete separate code base. So let's ignore that for now. But let me try to get to the gist of what you are saying: Your concern is not that the keys are not protected but that the pattern-choice of using arrays create the possibility for the coder to directly insert Client-Input? Is that correct? If so, I really didn't get that until now. And securing anything against "creativity" is rather hard. I am sure you have seen stuff like: $function = $_REQUEST['function']; $someDBwrapper-&gt;$function($_REQUEST['table'])... So my question is: where is the cut-off line? When would you say it's the responsibility of the developer to ensure security?
The laravel subreddit has more discussions about php than this php reddit. This subreddit is in my opinion poorly handeled and scares users away with that rules. Even the fact that you cant write a description to your post says a lot.
But where to draw the line look at some hot/trending posts. There are clearly questions help posts. Some are okay and some not. I never know where to post my questions/discussions about php.
Thank you for such a high-quality article amid the mostly dreck usually posted here. I just wish it had proper PHP syntax highlighting.
I completely agree noob questions are annoying but if you disallow all questions you kick out even the good ones which would be beneficial if we talk about them. See this question: https://www.reddit.com/r/PHP/comments/b86nj9/how_can_the_doctrine_orm_be_datamapperpattern_if/ I violated the rules with that question but it was an okay question with a lot discussions.
Thank you for your compliments. The blog is written from scratch with minimal dependencies and no JavaScript or cross-domain requests. No google analytics either. All for your privacy. NB: I tried to add some color with the means that I have.
&gt; tackoverflow has become cancer due to the overmoderation. Everything is breaking someone's interpretation of the rules. That is the reason why I post nothing on stack anymore...
Just scroll down this subreddit ordered by hot/trending a lot of help/question post resulted in nice discussion and nice insights.
I didnt see which way he did the calculation. Wonder how must faster using this would be: ``` function fib($n) { $phi = (1 + sqrt(5)) / 2; return round(pow($phi, $n) / sqrt(5)); } ```
I wouldn't call your question a support question. It was meant to spark a discussion, which is not only fine here, but even encouraged. It's a totally different kind of "help".
That's the difference. It was a good question. Which is why no one cared about the rules and hence why OP posted this thread about some people not caring/following the rules and some having to. No one cares about the no help rule if it's a good question.
I already use swoole and it really makes an impact because Symfony is booted only once, saving about 20-50ms per request, depending on project (and version). But the real thing I would like to know is if for example Doctrine hydration would be faster and by how much. Or using generator/iterator to go thru 10 million DB rows and generate CSV. &amp;#x200B; So some realistic test, Fibonacci generator is nice but not real-case scenario.
Can happen. My phone has internet but I can’t tether. Home/office might be down.
After seeing all the fun stuff you can do with array spreads with React/Redux, I'd be so excited to get this. It would make a lot of simple array operations so much simpler to write!
Yes, my point is that it doesn't seem like a viable way to make money when people can easily build open-source solutions.
Then they should let others who do have more free time or desire to do so! This subreddit has been a goddamn mess for years.
You need to use old.reddit.com unfortunately. Moderators disabled text post bodies for new reddit. Yes, I agree, it's absurd.
Compared to PHP 7?
I could have used this just last week.
This would be awesome. Lots of great RFC's going through lately, I'm excited for the future of PHP.
There are even php haters who don't know that there is PHP 7. Many of them also does not know that there are php frameworks like Laravel and Symphony.
I could see some good usages for this, but I don't understand why it couldn't support string keys the same way that array_merge does. The consistency with argument unpacking seems like a red herring. It'll lose a lot of potential usages if the developer has to know ahead of time whether the keys are strings or numerics.
I'd say that this is a good limitation for now: semantics around unpacking of maps should likely be discussed in a separate RFC, if needed. The current proposal is a subset of possible unpacking operations, so it can be expanded.
Yep. This would be a great addition to PHP's already unparalleled array functions library.
True, but we had company assigned Skype accounts on the work computers.
I'm hesitant to agree. Technically you're correct that it could be expanded in the future, and if we were talking about a framework that might do it in 3-6 months I could see this as a plausible step in the right direction, but if it doesn't happen for 7.4 (which might be what you mean and I'm jumping the gun here) then the earliest we would see that happening is ~20 months from now in 7.5 or 8.1. It would also mean that a lot of frameworks will have to delay making use of it until their minimum version is above the version of PHP that throws type errors for strings (e.g. ~3-4 years). For what it's worth JavaScript has unpacking for arguments, arrays, and objects so there's decent precedent on the semantics.
Send a second RFC to expand this then: there's a few more months of time to land stuff into 7.4.
The line is very simple to draw. The single responsibility principle. With your approach, the security is spread among the whole code of your application. While it should be concentrated in a single place: a database wrapper. When you are preparing an array with data, you could be unaware of its destination. It could go to a database or elsewhere. [For newbies it is not clear even whether an HTML form is not a part of a PHP script and needs to be protected](https://stackoverflow.com/q/22534183/285587). So it all depends on the user's understandig of security. And it's a straight road to a disaster. All problems with SQL injections during all these long years were caused by **vague and uncertain rules**. As long as the burden of ensuring security lies on the developer, while the rules are not certain and infinite, there **will** be injections. It's just a human factor. People will keep forgetting to perform some essential action. [For example](https://blog.ircmaxell.com/2014/10/a-lesson-in-security.html). At last, a simple set of rules has been developed: values go through placeholders, everything else is explicitly hardcoded. So it's not that hard to create a wrapper to comply with these rules: if it's an ORM, then insert/update wrappers are welcome, identifiers hardcoded in the entity class. If it's just a wrapper, then only raw SQL is allowed, with identifiers explicitly hardcoded in queries.
Agreed. I think CI is "obvious" first way to try. I don't have any numbers, but it seems some people prefer it. Look for e.g. StyleCI - https://styleci.io/, it's basically `composer require &lt;coding standard tool&gt;` for 10 $ a month. I'm thinking about a similar approach with Rector instant upgrades. It seems to work for Laravel upgrades - https://laravelshift.com/, where author claims to upgrade 8000 applications, one for 5-10 $. Rector will deprecate this in the future, because as you said, it's easy build on open-source solutions. I think the future of business is help with big old legacy code-bases on a personal level. Cases like "we have PHP 5.3 with 10 million lines of code, PHPStan show over 50 k errors. We need to get to PHP 8, Symfony 5 and 0 PHPStan errors. Here you have a budget for 2 months" will be common
I think the author was asking about new features, but sure :) Do you have any link for this? I found only your closed and not merged PR: https://github.com/php/php-src/pull/3770
another language
There is server lib for PHP: [https://github.com/spiral/php-grpc](https://github.com/spiral/php-grpc) But it's not based on PHP-FPM so you'll have to work with daemonized scripts (with pros on performance and cons of memory control).
Hey buddy, you are not too stupid to post here - constructive feedback like u/colshrapnel has given you is valuable. He is an extremely qualified dude (author of phpdelusions.net, which I would encourage everyone to take a look at). Keep at it!
Hey this is awesome! I digged a little bit into a project named [directius] (https://directus.io) recently. They offer a similar api plus a UI to interact with any database. I think it requires some extra configuration, though, specially if you want to have user access and relational data. This approach seems very nice to bootstrap an api and do the front end. You would still need to add user access and stuff like that, but in an existing project that wouldn't be an issue.
# I am evaluating Symfony framework. I have observed following in symfony framework: * It's implementing all OOP properties and design pattern in best possible manner. * Following best practices at every steps But it has also * Very stiff learning curve * Require very skilled programmer to work on the symfony project * Since programmer will very skilled - certainly they will charge more * In short ... **Symfony require a programmer (all other resources too) to have that level of skills which Java programmer requires.** So why shouldn't we write the application in Java Spring Framework which has: * MVC * Easy to start and well documented * Large community similar to PHP (even Symfony don't have that much big communty) * Performance - Java will always faster, scalable and more performant than PHP and the same apply for Spring vs Symfony PHP was designed for simplicity and getting things done. Earlier, Java EE was the headache that problem was resolved by Spring and many other framework came in the market - Lightbend, Akka, Vert.x &amp;#x200B; However, other PHP frameworks are still very good i.e. * Yii2 * Zend 2 * Expressive * Slim However, you can still argue on larger project require many thing to follow But I would here - If I 'll have to write any complex application why I would consider Symfony?? Why not Spring??
Thank you for your kind words. I will give directus a try! Note that the difficulty is not in exposing the data, but in defining and enforcing a security model. There are several handlers in PHP-CRUD-API to implement such a security model.
Go on use Spring.
It would be simpler to have categories and let readers filter out those they don't want.
Thanks for taking time to share a project you care about. I find your code to be not so readable and I would suggest you to be consistent in your syntax formatting.
Dear Lord, if you have the option to use Java instead of PHP - go for it! You won’t believe how many devs are stuck in the shitty nightmare of a platform for the lack of better options.
You wrote a leading question, full of assumptions without concrete evidence. Symfony also has - MVC - easy to start and well documented - large community - performance (why do you say java will always be faster, scalable and more performant than PHP?!) In case u actually want to have an answer and are not trolling: - from a developer perspective PHP is easier to learn than java, cozz it started as a scripting language and is loosely typed; - from a business perspective PHP developers are cheaper, theres plenty of research about this on the web, just google it; - there are some language constructs that JAVA has but PHP doesn't, like generics, which can make code slightly easier to write; - performance wise, at the moment, JAVA is more performant with CPU intensive applications, like machine learning, however web applications spend most time waiting on IO so for web applications I don't think JAVA has any performance advantage on PHP. Furthermore, the next version of PHP, v8, will add a JIT compiler which will make it usable with CPU intensive applications as well. Bottom line, from a developer point of view, if you are building a web app, choose the language you are more comfortable with. In practice I don't think there is a relevant difference.
You wrote a leading question, full of assumptions without concrete evidence. Symfony also has - MVC - easy to start and well documented - large community - performance (why do you say java will always be faster, scalable and more performant than PHP?!) In case u actually want to have an answer and are not trolling: - from a developer perspective PHP is easier to learn than java, cozz it started as a scripting language and is loosely typed; - from a business perspective PHP developers are cheaper, theres plenty of research about this on the web, just google it; - there are some language constructs that JAVA has but PHP doesn't, like generics, which can make code slightly easier to write; - performance wise, at the moment, JAVA is more performant with CPU intensive applications, like machine learning, however web applications spend most time waiting on IO so for web applications I don't think JAVA has any performance advantage on PHP. Furthermore, the next version of PHP, v8, will add a JIT compiler which will make it usable with CPU intensive applications as well. Bottom line, from a developer point of view, if you are building a web app, choose the language you are more comfortable with. In practice I don't think there is a relevant difference.
I just wrote a blog post about my latest package: PHP Taskman. It's a tasks runner for PHP, written in PHP and extensible using YAML files. It's still a work-in-progress, there are still a lot of things to do and polish, but it's already quite usable. Feel free to give me some feedback, ideas or any other improvements, I'll do my best to reply :) Happy easter all!
Now that's one feature to get excited about. However I'm not sure if I like the syntax. I would've expected something like C++s extern where you can open a code-block and write in whatever language you are going to write. It would even help IDE highlighting where they can just switch the parser when they see the "extern" keyword.
The PR was only for CI, the merged commits are referenced in the PR description.
Also consider the deployment cost for each of the stacks and as others have pointed out go ahead with java/spring if you want to.
Good morning, The "stupid" was in reference to the fact that I wasn't able to create a post including a link, but had to post a link and then comment on it. (It is this very first "instead of a Post-Body" comment you are replying to). I am thankful for constructive criticism, I just have to challenge feedback in order to evaluate whether it's valid or not. Do you know u/colshrapnel, or is your assessment based on the referenced authorship?
Uh, I tried to. Can you point me to an example?
Ah, alright then! I do not know u/colshrapnel personally, no, but his posts are on point imo. For reference I have about 6 years experience with PHP, and would say I learned a great deal from his website and comments on Stackoverflow.
Why post this? It was accepted a while ago
I believe if we start a discussion about scalable architecture by discussing *directory structure*, then we're really not discussing scale, are we. DDD is also not inherently scalable on its own. DDD is simply a system of terms and rules that proposes *one possible* separation of concerns in an enterprise app, which is neither eternal, not exhaustive as to the needs of a modern application. In other words, DDD is a helpful read, but using it as your Bible for architecture is really taking the wrong lessons out of DDD, as Eric Evans would himself tell you. Another problem I see is discussing the domain *monotonically*, as in "should I build my domain Eloquent, or should I built it in Laravel Doctrine". As long as you're thinking about your domain as a monolithic ORM layer, that's not a scalable domain in any sense of the word. It's not scalable to changing requirements, it's not scalable to third party data sources and APIs, it's not scalable to being split into separate aggregates across separate teams, and it's not scalable in terms of performance, as no scalable architecture is just ORM + SQL (even if SQL still remains a part of the picture, and that's good). Scalable architecture is about separating your app into clean, isolated components, that communicate through minimal interfaces not dependent on frameworks. This then allows every component (or module, or service, or call it however you please) to be implemented in the best way possible. Maybe it'll use a different framework than the rest. Maybe a different language. Maybe it'll reside on a different machine. The freedom of making those choices is what makes your architecture scalable in general sense. Apart from that, I believe we keep defining directory structures and conventions out of vanity and tendency to bike-shed over superficial concerns, than address deep issues in a deep way. Most of this is up to convention and subjective preference, and it doesn't matter for the end result.
Simple reason; Symfony is **far** more powerful than Spring. I know because last year I wanted to make the switch to Java because of generics, real annotations etc... But I checked the documentation and Spring is really weak. &amp;#x200B; Example: just check the docs for symfony/forms; it is bigger than documentation for **entire** Spring fw and that tells you something. Look for advanced things like data transformers and form normalizers, just to get an idea. Extending forms is also super-powerful thing but you need to set a project to understand it; even docs are sparse, it really is hard to explain it. Or custom data mappers; again, very hard to explain but great when you need immutable objects. Or things like argument value resolvers; in short, you can get **any** value injected into controller. Symfony already comes with plenty of resolvers but it is just 1 file to create new one. &amp;#x200B; Any custom annotation over route gets automatically injected into $request. That is not documented at all but I use it all the time; one example is to render active menu on the left side based on active controller. So no {% if route..... %} mess in twig files, just one annotation and one listener solved the problem. &amp;#x200B; I could go on but trust me, I have seen people moving from Spring to Symfony and that says something. Yes, Java is better language but tools are more important. And PHP will eventually get generics and variable annotations (these 2 things I really miss). About speed: my very complex apps run in less than 20ms per request, under swoole, and on $40/month server. Sure, it is not as fast as Java would be but I can make that site in much less code than in Spring. Less code, less potential bugs.
I have one rule for directory structures, when it comes to reach 7-8 elements it's time to break down. If you have 50 controllers then you should have 7 folders. It's ok if one folder has 10-15 elements but it should remain rare. Why 7-8? It follows an [ergonomics principle](https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two). The average human brain can remember that much but no more. If someone gives you 7-8 numbers you can remember them, but given 10-15 you won't.
[Link](https://mattdoescode.com/scaling-laravel-architecture)
I second this! It would let us unite as a comunity.
Well, security as a whole is of course spread beyond a db-wrapper. Just to be clear, there is security in the sense of managing secure queries and then there is access control e.g. what entities is a particular session allowed to access in the first place. We have always created examples where Client-Input is directly passed to a db-layer which I think we agree should never happen in the first place. Assuming we are aligned on that, you basically warn based on the premises that a different layer (like the login module in the Drupal example) passes on raw client data? And your conclusion is: since potential developers might forget/not know security implications, convenience must necessarily stop when it makes it possible to accept insecure data. So comparing two possible forms of writing: Db::ask('&gt;SELECT foo FROM bar WHERE baz = {{baz}}', ['baz'=&gt;$value]) And Db::easy('bar.foo',['baz'=&gt;$value]) Which both translate to the same statement, you would force the first as the mapping cannot be passed in? (In the first case, an invalid key would simply not be matched) The problem with being explicitly hard-coded in general is that I have personally seen people being very creative in constructing queries. Especially when it comes to APIs for front end driven projects. So let's assume the first parameter of a given wrapper is a SQL string. What prevents developers from constructing that string based on Client-Input? Or in a more challenging way: Give me any db-wrapper, and I'll show you how NOT to use it. But seriously: You mention ORMs which is more of the realm of where I would like DB interactions to be seen at all. So going back to the two examples I have given above. You basically would suggest getting rid of any capabilities allowing columns to be defined in array-keys, and force building update/insert wrappers on a per-model base?
I've admittedly not had a job interview in 10+ years... are these really the kind of things people get asked to write on the spot nowadays?
On a completely different note, as some other commentators have pointed out I seem to have problems with accepting feedback: I wanted to let you know that I value your input and enjoy the exchange. I hope you don't misunderstand my rebuttals as "blocking".
Maybe, maybe not (depends on the interviewer), but this helps develop reasoning and problem solving. Of course the best way to learn programming is to tackle projects that are engaging.
Too bad. Suck it up buttercup.
In general, that [post](https://mattdoescode.com/scaling-laravel-architecture) suggests incorporating DDD-design elements rather than following it religiously. Overall the structure seems fine and the practices seem to fit with Laravel's recommendations and expectations. The only minor detail I disagree with is having a "Core" module: better naming there could help lead to a better structure.
So basically, get it in and accepted, then build on it.
Can you explain what I task runner is? 😅 Is it like queues in Laravel?
Questions about why your code isn't working goes to phphelp. Questions about PHP itself, like why something is the way it is, its history, etc, would be okay here, I believe.
Just wait until you have to review crap code using this in the next 10 years.
That specific example doesn't help the community at all. It's been done a thousand times, it's easily googleable, and it will just incite violence. There have been plenty of questions in this sub, as long as they're not support ones. I think ultimately the answer you're looking for is that the rules are down to the interpretation and discretion of the moderators.
I agree. It feels like it's just an extension and not part of the language since you're basically passing a string to a function.
&gt; (why do you say java will always be faster, scalable and more performant than PHP?!) Because it is, in almost all cases. Java has several advantages such as being compiled, multithreaded, and non-blocking I/O. When it comes to processing something, Java should always be faster unless you're using a C extension.
Not going to happen, I'm afraid - that would entail a top-to-bottom rewrite of Psalm, and would massively increase Psalm's running time and memory consumption.
Well, for one, you don't handle `--` at all, or prevent LIKE attacks, at all. Your escape method really is a joke.
yes, there's a lot of discussion about it.
I solved the anagram one by just adding all the ascii values together and praying there wasn't a coincidence lol
I see. That's not clear from the PR at all. Moreover with "WIP" in the name.
In general, that [post](https://mattdoescode.com/scaling-laravel-architecture) suggests incorporating DDD-design elements rather than following it religiously. Overall the structure seems fine and the practices seem to fit with Laravel's recommendations and expectations. The only minor detail I disagree with is having a "Core" module: better naming there could help lead to a better structure.
You've stayed at the same job for 10 years? I really hope you own the place.
This question is hardest to answer. The difference between the theory and the practice you mentioned before. In theory, the answer is yes: only hardcoded queries are allowed, whereas update/insert wrappers should be built on a per-model base only. In practice I do understand that it's a tradeoff you will never agree with. Anyway, if you ask me, I am inclined towards the most secure solution. And my current suggestion for the beginner programmers is to stick with hardcoded queries (you see, I am biased towards simplest solutions because I see too much questions on Stack Overflow from beginner programmers). As a tradeoff for your wrapper, I would suggest to at least implement the identifier quote function, as shown in the section 6 in the article I linked before. It will not only prevent nastiest SQL injections but also will simply prevent an error if someone would decide co call a column `order`. This is better than nothing that you have at the moment. Of course there is a risk you already mentioned (though you've gone too far saying that allowing user-defined field names will let "someone change someone else's password" as it would involve to fake the data value (id), not the key). There is still a danger though, for example, if you have user roles in the users table, a user-tampered array key could lead to a privilege escalation. And leaves a question mark hanging around.
Just an example...
&gt;Any custom annotation over route gets automatically injected into $request. Can you explain this point? I'm not aware of this
See it the same. Why did i never ever missed that feature? Because its unreadable.
But look at hot/trending posts here there are exactly those help posts. The line to draw is sometimes arbitrary.
Thanks.
Yes, his website is getting very positive responses. And I understand why. There is a lot of beginner stuff out there, but then there is a gap until you reach the level of more scientific articles. His website addresses this huge gap nicely and effectively.
$string1 = strtolower(preg\_replace('/\[\^\\w\]/', '', $string1)); &amp;#x200B; Then I added the ascii values, same as you. It was fun, I love little programming challenges.
The second exercise, isn't that basically just a passthrough to array\_chunk? Or do you want them to implement a chunking algorithm?
Which one is it? Numbers? When I was doing these exercises myself the goal was to learn/revise both algorithms and PHP. One one hand knowing how to approach and solve a problem is good, on another why reinvent the wheel when standard library solves the problem. So, why not both?
Array groups.
&gt; array_chunk Oh, TIL that there is `array_chunk` in PHP, thanks. That's why it's a good idea to practice these sorts of problems. :)
&gt;just skip the whole block You can't just skip the block. For example int f() {puts("}"); return 5} Where does that function end? It's not at the first }. You need to be able to parse the language just to be able to skip over a block, which is a little bit too much for an FFI.
I'm excited about the possibility of this and array comprehensions like Python has.
Thank you for this. Your findings are usually good, but this one is great. We need more articles like this, hot from the hands-on experience.
Also you learned how to write a di container. Not everyone knows how to because all are using frameworks right of the start and never ever program such components on their own. It dont has to be the best at all.
I love exercises like this. Seriously, so much fun!
Sure. First, you know when you have menus in admin, when you render them in Twig you have to create complex if-else rules and apply some class ``active`` based on route name or url? Things can get even more messy when you have tree structure. Even when you use some bundle/package to render menus for you, you still have to resort to if-else but in PHP. Instead, I use this: ```php /** * @Route("/", name="admin_contracts") * * @SidebarActivate(target="'admin_contracts'") */ public function index(): Response {....} /** * @Route("/create", name="admin_contracts_create") * * @SidebarActivate(target="'admin_contracts'") */ public function create(Request $request, Mailer $mailer): Response {...} ``` In other words, both actions need to activate **same** menu on left side. ``SidebarActivate`` is my custom annotation, pretty simple one: ```php namespace App\Annotation\Controller; use App\EventSubscriber\Menu\LeftSidebarSubscriber; use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationAnnotation; /** * @Annotation * * @see LeftSidebarSubscriber::onSetupMenu() */ class SidebarActivate extends ConfigurationAnnotation { /** @var string */ public $target; public function getAliasName(): string { return 'sidebar_activate'; } public function allowArray(): bool { return false; } public function getTarget(): string { return $this-&gt;target; } public function setTarget(string $target): void { $this-&gt;target = $target; } } ``` And here is the trick; in my ``kernel.controller`` listener, I do this: ```php /** @var SidebarActivate|null $sidebarActivate */ $sidebarActivate = $event-&gt;getRequest()-&gt;attributes-&gt;get('_sidebar_activate'); ``` This is real instance of my annotation, Symfony already made it via reflection and injected it under defined alias. But in this case, I am interested in parsing ``target`` as expression: ```php if (!$sidebarActivate) { return; } $target = $sidebarActivate-&gt;getTarget(); $expression = new ExpressionLanguage(); $result = $expression-&gt;evaluate($target, ['request' =&gt; $event-&gt;getRequest()]); ... Here I know which menu should be active. Rest of logic is irrelevant... ``` This is the screenshot https://imgur.com/a/xpnyS7q. You can see Contracts on the left is active, and it is active for listing, editing, creating or delete confirmation pages. All that via single annotation over controller. Shown example is **very** simple, other pages has much more complicated usage like this: https://imgur.com/a/Uyc5SyV That page has subtrees and 2 filtering URL params on every page. But I don't care about that. Again; listing, editing, creating and delete confirmation pages... will always show correct menu with submenu active. --- I hope you understood this, I actually don't have simpler example, sorry.
The \_best\_ thing on PSRs is the point: &amp;#x200B; Use spaces, no tabs allowed. &amp;#x200B; Fuck it. yes im on the space side but i would never ever switched because there is a "psr group" who now spamming like hell to use spaces. I would definitely use tabs for the sake of freedom. Its not a "standard" its a narcissist group of how "real php" should be and there is no discussion /end. I dont want do part of that.
I got multiple php 5.5 and even more 5.6 servers in production. There is not enough time to redo all the legacy software and were basically waiting for the customer to shut down their services. But that takes time....
Throw more hardware on your database. EZ
I can't see why crap code using array merge can get crappier with this.
&gt; There is still a danger though, for example, if you have user roles in the users table, a user-tampered array key could lead to a privilege escalation. And leaves a question mark hanging around. Uff, I guess relational design is a bigger topic that people seem to neglect as a topic ever since NoSQL solutions became so popular and occupy the learner. But in reality: wouldn't this only be of interest if an attacker had access to a system user anyway? How can that be without having access to the file-system (in which case I wouldn't have to make this detour)? Shared hosting running off of one VM? &gt;As a tradeoff for your wrapper, I would suggest to at least implement the identifier quote function, as shown in the section 6 in the article I linked before (adding and escaping backticks) I was thinking about something similar I'd like your opinion on: Since column-names are in a predictable format, what would you think of a regular expression only allowing certain characters (e.g. [a-zA-Z\._] ) through? This would open up the possibility to a) also catch keywords (like "ORDER" in your example) , b) build an extendable filter/regex to allow for additional characters in needed. &gt; (though you've gone too far saying that allowing user-defined field names will let "someone change someone else's password" as it would involve to fake the data value (id), not the key) I have seen it all, so I was thinking of rather extreme examples like function updatePassword($userInput){ $set = ['password'=&gt;someHashFunction($userInput['password'])]; $where = ['user_id'=&gt;$userInput['user_id']]; Db::ask('user_password',$set,$where); }
Can you post some examples?
Yes use PHP. It will be a lot of better than this old and getting older java shit.
Please ignore the escape-function for now. You will see that security is handled differently. There are only very few instances where LIKE can be generated or used. Can you give me an example of how you would generate a LIKE attack towards this wrapper? &gt;On the same note: Treat your seniors with a lot more respect. Who are my seniors and where did I not treat people with respect?
Specifically related to Redux, https://redux.js.org/recipes/using-object-spread-operator Some of these examples won't work as-is because currently the PHP impl doesn't support string keys (see RFC for the reasons). But basically, things like prefixing an element into a new array becomes something like `$newArr = [$newItem, ...$oldArr];`
that's a much safer way to do it, especially making it lower case, that way we're testing if it's an anagram by our standards rather than an anagram by the machine's standards, and of course ignoring punctuation and spaces. Nice idea. I love programming because of this. I spend a lot of time on [codingame.com](https://codingame.com), which let's you do these puzzles and actually race other people trying to solve them.
Yeah there’s no way that works. It would say ‘abc’ and ‘bbb’ are anagrams, if I’m following your logic correctly.
It's just my opinion, but this is way too easy. As a dev going in for an interview, I'd expect something more challenging. That said, in the past I've found that my interviews never had these kind of tests. I've usually had to sit with the lead dev and talk about my experience, and he/she usually just asks if I know foo, bar, etc...
Fair point. Can you give an example of a more challenging exercise? AFAIK there are ~3 types of interviews: doing whiteboard while trying to implement some funky algorithm, takeaway home exercise that may take 6-10 hours to implement or an interpersonal skills test to see cultural fit. For myself, this was a good opportunity to flex some Travis CI and PHPUnit muscles.
Taskman is a command line tool. To run a command you have to run `./vendor/bin/taskman [COMMAND]` If you want to have custom commands, ship a `taskman.yml.dist` file in your project and add your custom commands in it.
I don't like such limiting solutions. There is always someone whose accounting system is using table names with spaces or dashes. Besides, i don't get what do you mean under "catching keywords". but most of all I don't understand why you're such against the syntactically correct quoting prescribed in the documentation.
1. From scratch, show how the Observer pattern works. 2. From scratch, show how to correctly implement a singleton class. 3. What is the difference between an interface and an abstract class? 4. Given some MySQL database credentials, tell us what tables are in the database. From the second table, tell us what columns are in the table. (I've actually had this during an interview)
Nice, more questions to practice. Thanks! Were you allowed to use Google during the interview? I know this sounds silly, but trying to memorize all different whatnots is arduous. For example, if they asked for PostgreSQL instead of MySQL it would be a little bit different.
In 2 people?
..or umlauts ;-) you're right. What do you mean by being against quoting? Do you refer to the fact that I do not use it when constructing queries? Because you are right, I should. I am against using keywords as column names, though. I personally see no good reason to call a column e.g. 'order' and consider it bad practice. But I see how I should not make that decision for others.
Your logic is sound, that would not be a correct solution. It would work for "elvis" and "lives", but also for "abc" and "bbb". The OPs solution is much better. [https://github.com/azdanov/php-interview-exercises/blob/master/exercises/Anagram/Complete/AnagramComplete.php](https://github.com/azdanov/php-interview-exercises/blob/master/exercises/Anagram/Complete/AnagramComplete.php)
I don't get it. This functionality is already provided by composer under the scripts section of composer.json.
Google was not allowed. MySQL is by far the most used database for PHP web applications. I wouldn't worry about the others.
You shouldn't. Java is a much better language than PHP. If you have a choice, please use Java. Or even better: use Kotlin, which blows both of them out of the water and pisses on their ashes.
&gt; Less code, less potential bugs. But it sounds like you're relying on more magic, which I have found tends to bite you at some point when complexity increases. I've not used Symfony for anything remotely complex, so I can't really comment intelligently. Just letting you know that I'm raising an eyebrow over here.
Another question: &amp;#x200B; Define "Dependency Injection Container" and describe how they are used in modern PHP frameworks.
Composer allows you to create aliases for scripts. You cannot override them and you cannot use variables in them. &amp;#x200B; Let's say that your project is a Drupal sourcetree. In order to install the project, you ship with the project a file `taskman.yml.dist` that contains a command `drupal:site-install`. ``` drupal: root: "build" database: "mysql://root:@db/drupal" commands: drupal:site-install: - ./vendor/bin/drush site-install standard -y -r ${drupal.root} --site-name='Site name' --site-mail=info@example.org --locale=en --account-mail=admin@example.org --account-name='admin' --account-pass='admin' --db-url='${drupal.database}' --sites-subdir=default ``` This way, it's very easy for anybody to install the site. However, the database URL might be different on your setup, this is why it's possible to create a file 'taskman.yml' that contains only the variable that you want to change: ``` drupal: database: "sqlite:///.db.sqlite" ``` You have now customize the commands with your own variable, without changing anything in the source tree. Clean and easy, just using a simple yaml file. Taskman allows you to do all of this.
He specifically discussed how the tooling for symfony is more robust than spring. Relying more on pre-built vendor code is not the same as relying on more magic.
Yeah, that's what I meant by coincidence
Yeah, that looks way better (although I’m sure you can do something more efficient)
I was just glancing and first stumbled upon your Ladder exercise. The solution you have is way overkill. Here's my solution: &lt;?php function ladder($size){ for($i = 0; $i &lt; $size; $i++){ printf("%- {$size}s\n",str_repeat('#',$i)); } } ladder(3); ?&gt;
You are right! Thanks for sharing. That's quite clever. I was trying out different ways, and some are just better than others.
He/she doesn't actually give any explanation or example for how or what tooling is better, unless I'm reading too fast and missing it. But then he/she says: &gt;&gt; Any custom annotation over route gets automatically injected into $request. That is not documented at all but I use it all the time; That doesn't inspire confidence and sounds more-or-less like magic to me.
2008 represent
It is arbitrary, because it's up to the mods. If they feel something is beneficial to the community, it stays. If they feel something is not beneficial to the community, it goes.
[example 1](https://github.com/sroehrl/neoan3-db/blob/d8b9125e1f6585a21b1cb32d3253a938b6d7ba92/DbOps.php#L69) [example 2](https://github.com/sroehrl/neoan3-db/blob/d8b9125e1f6585a21b1cb32d3253a938b6d7ba92/DbOps.php#L92) [example 3](https://github.com/sroehrl/neoan3-db/blob/d8b9125e1f6585a21b1cb32d3253a938b6d7ba92/DbOps.php#L156) [this is a public method, i have no idea what this method does based on its name and phpdoc](https://github.com/sroehrl/neoan3-db/blob/d8b9125e1f6585a21b1cb32d3253a938b6d7ba92/DbOps.php#L170) I found a lot more things that should be improved but I think you get the general idea of what I’m trying to say.
I smell politics in this. Zend Framework is hardly used by anybody in the age of Symfony, Laravel and CodeIgniter. Is it their attempt to take over PHP development?
No. What's happening is that Rogue Wave Software is dumping all their idea people (and the work they're responsible for) in favor of marketing, so they can get more money. It happens to a lot of companies.
First and foremost, arguing the benefits of each of the many tools that are bundled with symfony is beyond the scope of the reddit comment section. However, you’re picking a single point among their several points and trying to use it to discredit their entire argument - which is that spring doesn’t have these tools to begin with. Regardless of how you feel about the merit of their fourth point, op has presented several other *facts* that indicate the toolset bundled with symfony is more complete than what is bundled with spring.
SlimPHP + PHP-CRUD-API, as described [in this blog post](https://tqdev.com/2019-automatic-api-slimphp-3). NB: I'm the author.
Such thing exists: [http://phpjs.hertzen.com/](http://phpjs.hertzen.com/) :D
Thank you for taking the time. You are definitely right about Docblock-declarations! As for your examples: Unfortunately I am not getting the general idea of what else you are trying to say. Are these referring to readability, consistent formatting or the fact that these are unexplained public functions?
We're having a miscommunication. What you and the commenter are referring to as "tools", I'd refer to as "features". Whereas, I thought "tools" meant things like linters, static analyzers, debuggers, etc. So I thought they were arguing that PHP/Symfony development tools were better than Java development tools. Now that I understand what you mean by "tools", let me reply to *that*. I never attempted to discredit their entire argument for Symfony. I made a remark about one specific argument they made: that less code implies fewer bugs. When comparing two codebases, I'm saying that the one with more magic will be buggier than the one with less, even if the latter is more code. Symfony's powerful features invoke more magic than one would with Spring, ergo I believe Symfony will be harder to use to produce bug-free code. Whether my argument is *correct* is another issue that I'm willing to debate. But don't misunderstand what point(s) I was trying to make. You are the one who tried to refute my claim about Symfony having "magic", to which I responded with a quote about something that is most definitely magic.
checking in &amp;#x200B; I regret that choice deeply
Blech
Why? It keeps things nice and distinct.
Actually, what I wrote was never a magic. Symfony basically **forces** you to write nice code, there is no things like magic __call and __get methods and my phpstan is set to max level; not a single error. Yes, occasionally I do need to put ``@return User[]`` or similar but that is only because of limitations of PHP, nothing related to Symfony. If PHP had generics, I woudn't never have them as all my code is in strict mode and 100% typehinted. In fact, I think those magic methods is the worst thing in PHP. The example I provided with custom annotation is something noone has to use if they don't want. But it is super-powerful tool when you know how to use it. Really, that is not magic, all languages uses annotations as extra info; metada is data about data, nothing more, nothing less. I rather pick big box of tools instead of just hammer and a screwdriver. There is one crucial thing I forgot to mention; unlike other PHP frameworks (not libraries), Symfony has compiled container. One of **many** benefits is that user cannot missconfigure something; if it happens, Symfony will not compile and will tell you what went wrong. Very much like compiled languages, except this is on framework level. Simple example: if some bundle requires string as parameter and user provides a boolean, Symfony will tell you that on next refresh. But configuration rules can be **far** more complicated like array prototypes with required keys and its types, nested levels etc... Or... if I messed my annotation, same thing would happen. It would either not compile or just stay in $request doing nothing on its own. But you ctrl+click, and IDE will show you what code is using it. --- So as u/nanacoma said; I explained just very few tools that Symfony has and Spring doesn't. And trust me, Symfony has so many tools that it takes months just to take a grasp on them. I work 7 years with it, no other languages/frameworks and I still don't know everything. But it allows me to make super-complicated stuff in just few lines. Luckily, docs are great but more important is the clean architecture. Once you understand it, whole new world opens. So yes... I do complain about lack of generics (or at least typed arrays) but unless something even close to Symfony appears in Java or Typescript, I will be using PHP.
Okay but they could give us at least the option to write a description. A good questions needs explanation.
More specifically: this would mean that the PHP syntax would need to become a superset of C syntax, and a PHP parser would necessarily require a C parser.
To be blunt: your code is unclear and sloppy.
Yeah lets just let all those special secrets and SQL queries be view-able right in source, what could go wrong?
Keep your static types out of my browser, thanks.
I'd love it if the person who downvoted would contribute something more constructive. Always willing to learn!
I can write a description on a new post. Not sure what your issue is there.
The magic I was referring to was the annotations. Obviously I have no idea if you were using PHP magic methods. And, no, not all languages use annotations. Spring *does*, but I've written backend apps in Rust and Go that did not use any. Phoenix (Elixir) doesn't either, but it does use macros which are still a little magic. Why does that matter? Exactly because of the points you're making. Phpstan gives you a thumbs-up? You still don't know if your annotations are correct because they exist *outside* of the language you're working in. Now, you have mentioned this compiler thing. **That** is the kind of tool that can prove me wrong. If it uses those annotations to actually produce real PHP code that can be analyzed, it would alleviate my concerns about relying on magic. If that's the case, then it's a point against Swing and for Symfony for sure, because I *really* think annotations-as-code is a terrible mistake.
So what are the benefits of this announcement? Last time I messed with Zend they were working on a micro framework.
I imagine he wrote this with a shit eating grin the whole way through.
Honest, but not helpful ;-(
the people previously maintaining zend framework have renamed it and are working on it separately now.
With WebAssembly this is already possible ;-)
Oh completely different to what I imagined, however sounds very cool! I will take a look. 😺
Ohh so trick is annotation must be subclass ConfigurationAnnotation! Nifty, thanks a lot!
What do you mean?
As for Zend usage, it's 2nd largest in the downloads and 3rd in trends: https://www.tomasvotruba.cz/php-framework-trends/
Thanks! What practical case would you like to see next time?
I think this is a good exercise for everyone to do, so congratulations to the author on his post, the thoughts in it, and the bravery to publish them. However, I think that the layers help understand the dependencies direction and therefore help in getting inversion of control done right. And the layers are missing in the way it suggests how to organise the code. if you wanna see how I do it, check here: https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together And here: https://herbertograca.com/2018/07/07/more-than-concentric-layers
Although I do agree with you for the most part, I wouldn't dismiss folder structure so fast. I feel that folder structure, and the resulting namespaces, need to be used to convey meaning and boundaries, just like methods and classes but at a higher granularity level. If properly done, it also helps to do inversion of control because layers dependencies will become explicit and can be easily tested for using something like "deptrac". If done properly, a component (domain wise module) should be able to be easily used as a microservice (technical and team isolation) and be extracted into a microservice when needed, therefore helping to make it scalable and so on. if you wanna see how I do it, check here: https://herbertograca.com/2017/11/16/explicit-architecture-01-ddd-hexagonal-onion-clean-cqrs-how-i-put-it-all-together/ And here: https://herbertograca.com/2018/07/07/more-than-concentric-layers/
Tough crowd... I was jesting.
These questions measure something very different than OPs questions. OPs questions are specifically about problem solving whereas yours are mostly about regurgitating definitions. I’m not saying that yours are unlikely to be seen during an interview but they are a different type of problem. As a side note: My experience has been much more “problem solving oriented”. Have you really encountered similar questions? These seem entirely useless for screening candidates.
PHP community is like PHP the language.
till today i did not know i can access strings like arrays $string\[0\] wow
Annotations are not magical, they have been in use for 7-8 years, since Doctrine2 appeared. Sure, it is not language construct but until [https://wiki.php.net/rfc/annotations\_v2](https://wiki.php.net/rfc/annotations_v2) is implemented, I can live with few extra characters. Just like I can live with ``@return User[]`` because we don't have generics. And noone is making the fuss about that. But it still doesn't change my point. Even if this RFC is implemented, nothing would change except few star characters. Keep in mind I used **simple** example. Important thing is that I have tool that saves me writting code for reflection. Not a big save, but still a save. &gt;And, no, not all languages use annotations Java, Typescript, C# does... different name but identical usage. It is always something that framework or user uses, never the language. With Symfony, you get that instance for free and injected into $request. And there is a reason for that; Symfony has concept of embedded controllers and full support for ESI tags. That is the reason why it gets injected into $request so ``kernel.response`` listeners can read them and change headers or whatever they want. So annotation like ``@Cache(120)`` will be read by some integrated listener (1 line) and add extra headers that reverse proxy will understand. And only that small block of page will be cached for 2 mins, other parts don't have to be. &gt;because I *really* think annotations-as-code is a terrible mistake. I think you are just scared of new things, I was reluctant to annotations as well when I first saw them. But I quickly saw their power and changed the opinion. Also, keep in mind that in Symfony/Doctrine, you don't have to use them at all. They work perfectly fine with yaml, xml or plain php code and due to compiled container, no perfomance difference. I prefer to have related things in 1 file, not scattered. --- But I wish if you would stop using that **one** single thing as argument against Symfony. Look at forms and its power, forget annotations. That is something no other FW can even come close by. And what I said about symfony forms is probably 1% of what they can do.
Closer to Laravel's Artisan package, or sort of a Laravel Zero. I love these cli tools.
I have had interviews where the questions were like what I showed. I have had interviews where I was told to sit down at a computer, connect to a database of unknown tables, find specific data, and build a page layout similar to one shown on a piece of paper. I have never had an interview where I was asked to solve extremely simple PHP problems like what OP has shown. You may think these questions are useless, but you may one day have some of these questions asked to you, and so just be aware that employers do ask such things. "Regurgitating" a definition may just show an employer that you actually know your stuff.
Which version are you on?
Know what the new framework is called?
Linux Foundation in a nutshell: Microsoft is part of the Linux foundation. Is it because Microsoft changed its mind?. Ha, no, Microsoft is still suying and harrassing Linux distro. So, why Microsoft is part of the foundation?. It's a legal move, Microsoft "owns" part of the foundation.
Sorry, I didn’t mean imply that OPs problems were standard interview problems either. I just haven’t encountered the type of questions you mentioned. I’ve mostly come across problem solving questions during my interviews and not much theory. That’s all I was asking.
Four key people left as a result — the ZF guys, as well as some of their php-core devs. http://zsuraski.blogspot.com/2018/10/the-future-of-zend-engine-and-zend.html?m=1
Have you tried writing a technical blog in your non-native language before? Do you think this is an easy thing to do?
Laminas.
Are you on old reddit?
But who's the OP? I just assume the top comment is the OP until they say "I'm not the OP".
 [https://externals.io/message/103452#103453](https://externals.io/message/103452#103453) &amp;#x200B; there is no "concat" of string keys, only a union... unless you actually reorder the keys
JS and PHP are not comparable. array\_merge is "magic", it's neither a concat nor a merge, it's bot at the same time,therefore it's ambiguous &amp;#x200B; use + if you want to merge maps, ... if you want to concat sequences
I think they are nitpicking your english; it should be "with 2 people". Nice article tho
Thank you for linking to the discussion thread. --- The comment by Nikita is exactly my argument as well. &gt; This looks reasonable to me. The array_merge() behavior is certainly the one I would (in PHP) expect intuitively, and it is likely the most useful one as well, striking a balance between behavior useful for pure vectors and pure dictionaries (and falling short if it's not either ... as is usual in PHP). Whether I have a numeric array or a string array, I don't want to have to think about that when my intent is to merge them together. Trying to figure out which is which and when to apply which is just another complexity I don't need. --- &gt; The most important thing is that we don't want it work like array_merge(); in other words, it must not cover both lists and maps at the same time. I'd really like to know _why_ that limitation is being applied. I don't see any supplied justification for that view. --- &gt; ["a" =&gt; 1, "b" =&gt; 2, ...["a" =&gt; 3]] &gt; or is it equal to &gt; ["a" =&gt; 3, "b" =&gt; 2] &gt; overlaps the functionality of the + operator (bad idea imo) It doesn't actually, because + ignores the values in the right half if it already exists (even if they're numeric, which makes it occasionally hazardous to use in a generic Collection object) (whereas array_merge is the opposite). The result would instead be `["a" =&gt; 1, "b" =&gt; 2]` with `+`
I saw your two examples and just wanted to cut in. What do you think of this? $user = $user-&gt;GetWith([User::Email =&gt; $email]); Some homebrew code from my personal framework.
Yes, directory should convey components. But your confidence depends on the specific project you’re working on, not just all projects at once. Pretty finding specific directories for specific types of classes doesn’t help with architecture. It obscures it. So the only correct directory structure is “it depends on the project”.
Can click the link or copy paste on mobile :(
The spiral and queue from stacks ones aren't bad, I had to think a bit about those. Here's another one: Your input is a series of tags. A starting tag is comprised of ascii chars, and and ending tag is a slash followed by ascii chars. Your output is a boolean: true if the tags are balanced, false if they're not. E.g. `['a', 'b', '/b', '/a']` is balanced, but `['a', 'b' '/a', '/b']` is not. `['a']` is not balanced, nor is `['/a', 'a']`, but `['a', 'b', '/b', 'c', '/c', '/a'] is. Easy enough if you know the data structures you've already gone over, but not quite so simple as "implement this data structure". The pure data structure questions are better suited to lower level languages, where there are no builtins like array_push. Most questions at [HackerRank](https://hackerrank.com) and [Code Wars](https://www.codewars.com) are also good examples.
I told you guys here, in /r/PHP, about how Rogue Wave would be Really Bad News for PHP, especially Zend Server and Framework. I was viciously ridiculed here and elsewhere. But just like the 2008 collapse I publicaly warned people about in 2007, i'm being vindicated.
Did I ever levy a single word of ridicule to you?
But now they're working for free when they have a chance, while before it was their full time job. Huge difference.
Probably just a whole bunch of Zend_ACL and Zend_Lucene.
https://stitcher.io/blog/php-jit
You da real mvp
I don't know if there is an official definition but I take it to mean either the original commenter (beginning of the comment thread) or the original poster (person who posted the actual post) and just look at context to determine who it is in that particular case. In this case I meant TatzyXY and the actual post.
very good writeup of his work. if this gets more attention and more devs what will happen?
this will be possible at some point with webassembly. if that happens php will rise to get the world domination
Just because a lib doesn't get regular updates doesn't mean it's dead. Some are just mature enough to not require regular updates, often the case for libs for a standard. Another popular lib JWT you can check out is https://github.com/lcobucci/jwt.
Well, plenty of very experienced devs (including uncle bob) have talked about the layers that a typical web application has. This is all about structure in general, which needs to be adjusted to the specific project we have at hand. &amp;#x200B; The fact that they are generic ideas, doesn't make them pointless. They are extremely useful, they give us a set of ideas, and when we get a new project we pick up the ideas that are useful for the project at hand and apply them. &amp;#x200B; I feel the same regarding how we reflect those generic ideas into the code base. They are generic ideas, so we can think of ways to reflect them into the codebase in a generic way. Then, when we get a concrete project we can pick up the ideas that are useful and apply them. &amp;#x200B; So I don't think that talking about generic folder structure is a pointless exercise, I think its a good exercise. &amp;#x200B; What I do think it's pointless is to just not think about it, nor discuss ideas with other people, be it generic or concrete ideas. And it's especially damaging to discourage others from doing so.
I disagree. Spreading arrays only makes sense if you're working with a _list_ of items. If you want to spread maps, you're dealing with lots of implicit context and cognitive overhead. In my experience, these cases are better handled with objects instead of arrays.
You must've missed your favorite "Uncle Bob" saying you should never structure your projects according to class types, hence layers, but rather components. The layers are the micro-structure, and components/modules are the macro-structure. Flip that around and you have a mess.
`firebase/php-jwt` has been perfectly stable in my experience. I can see why you'd be worried about it not having been updated recently, but in this case it makes sense - it's not as if the standard has changed, and the whole thing is barely a few hundred lines of code.
Ughhhh, the DB configuration in global constants feels like PHP 4 code
Argument unpacking is cool to type check non associative arrays but I hope someday it gets replaced by array type checks. Something like `function (array[string] $x) {}` it would allow to improve code a lot.
No, I didn't miss it. And I didn't say anything otherwise. &amp;#x200B; Furthermore, he also doesn't say to ignore layers. Both components and layers should be, somehow, reflected and explicit in the codebase, so all developers know where they should put a certain type of code, and where to find a certain type of code. Not doing that will leave you with a mess.
Nothing short of amazing. Anthony, you're a god.
No. And every fucking article about DDD in some php Framework should be hanged over running water then burnt and theirs ashes spread around the solar system. Frameworks are just details in DDD. Your app may even be just a detail. What is your company making? What is your Core Domain on which you should assign your top people and resources? What is on the periphery and can be using software from outside? DDD is more a way to organize your company and decide what to focus on. The architecture you get should come from analysing your domains, your contexts and change when your common knowledge about those get better. Instead of reading these kind of blogs and applying cargo-cult php DDD read the [red book](https://www.amazon.fr/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577).
&gt; Furthermore, he also doesn't say to ignore layers. Neither did I. &gt; Both components and layers should be, somehow, reflected and explicit in the codebase, so all developers know where they should put a certain type of code, and where to find a certain type of code. Not doing that will leave you with a mess. A good project doesn't have top level directories like "controllers", "models" and so on. That doesn't help you structure your project. It rather helps you persist the illusion you're organized while in fact this is as good as sorting your classes alphabetically in folders.
CodeIgniter? Is it not dead also?
Post Fully Updated Now ! Mistakes &amp; Problems has solved .. now this post user's (password) data not stores into plain\_text to database and i use password\_hash &amp; password\_verify function method technique to store &amp; retrieve password into database. thanks.. [https://www.programmingblog.in/2019/04/21/how-to-create-a-complete-login-system-in-php-session-encryption-included-with-mysql-database/](https://www.programmingblog.in/2019/04/21/how-to-create-a-complete-login-system-in-php-session-encryption-included-with-mysql-database/)
I started to learn https://github.com/gregurco/jobeet-tutorial/blob/master/docs/README.md a few days ago, it seems really good introduction to symfony
I "discovered" this after just a few years, you're not alone.
I see, thank you. Good to know, I'll use it next time :) What does "in 2 people" mean then? &lt;blockquote&gt;Nice article tho&lt;/blockquote&gt; Thanks!
Let's look at Zend package data - https://www.tomasvotruba.cz/package-downloads-by-version/#zend All these have at least 200 000 downlaods/month and were released in 2017/2018: - `zend-modulemanager` - `zend-mime` - `zend-loader` - `zend-mail` - `zend-captcha` - `zend-session` - `zend-text` - `zend-log` - `zend-server` - `zend-escaper` - `zend-eventmanager` (over 1 133 000 montly downloads) - `zend-i18n` - `zend-code`
It *is* an extension. I don't think there's any good reason to make FFI an integral part of the language.
I'd start with [Awesome Symfony Education list](https://github.com/pehapkari/awesome-symfony-education) Cherry-picked and time-proven sources on various Symfony topics. If you like video and jokes, go to [SymfonyCasts](https://symfonycasts.com/). Last but not least, people learn the most from mistakes - downloads [Symfony demo project](https://github.com/symfony/demo), run it and try breaking it. There are lots of explanatory comments, that show you documentation in a practical way in 3 lines.
Wow, assuming 92 is your birth year, I am surprised you still remember PHP4. If you feel less nostalgic, feel free to use the Environment class to set your variables in a more "modern" way
I can recommend https://www.tomasvotruba.cz/ which focuses on DevTools, Symfony and PHP in general.
They aren't. They are looking for sponsors. I suppose no-one will give money to Zend if all of the Zend developers are working on Laminas.
The fuck you smoking? This has nothing to do with Microsoft.
An object only works when you know exactly what keys something will have ahead of time. There are still many times where you'll be working with an arbitrary set of data that needs to be keyed off a string and then transformed in some way. In checking my most recent project's code base for usages of array_merge I've found plenty of scenarios where it's a list, a few where it could be either (generic Collection object), but one specific one is a map. It's a map of fields (the keys) to their type (the values), ordered by occurrence, and it's merging the map of previously known values on top of that to preserve the previously known. That's a bit of generic array logic that couldn't be duplicated with an object. I also use `+` _ a lot_, but that's mainly because I find it much more succinct than `array_merge()` and know ahead of time that the array keys shouldn't, theoretically, be conflicting. JS has an object spread operator that works much the way I'm talking about having it work for arrays in PHP. It gets used very frequently to do much the same thing as above.
"in 2 people" would mean physically inside two people.
I can see some uses for this. But do not use this for security SQL queries/keys. Everything else is fine. Something like an associative arrays in Javascript, but bigger?
https://github.com/tymondesigns/jwt-auth if you're using Laravel/Lumen.
I don't know :) My point was exactly what such an article that appears from the practical experience, not from theoretical musing is the best. But I have no idea what your next practical experience would be :) Also, let me suggest to repost it on habr.com. Nowadays reposts are allowed there, as well as the English version.
What the fuck is this
Loïc Faugeron blog is a must read. [https://gnugat.github.io/](https://gnugat.github.io/)
You hit nail on head. Even now as I'm reading the responses your description is basically spot-on accurate. This has been so much fun, and I am loving the results :)
I see :D that seems a bit incorrect. Thanks!
I see, I know what you mean. I tend to go to theory and intellectually thoughts myself. In the end that produces a very boring post, that people don't understand, but *I just need to tell them*. I'll remind myself to be more practical. Thanks for feedback. &gt; Also, let me suggest to repost it on habr.com Sure, I never heard about it, but go for it!
I mant, this way you could introduce yourself to (a part of) Russian audience before your talk on PHPRussia, so it will get more attention ;)
Still using firebase/php-jwt. As others have said it's stable and adheres to the standard.
APIs can serve all sort of content.
I still have some ZF 1 libraries (Date, Mail and maybe one more) running in one old project on PHP 7.x and it still runs fine. Very good, robust code. It's a shame they dropped support for a lot of functionality in v2 onwards. Though I guess there are better native PHP alternatives I could rewrite the code to use now.
The ZF1 components that were dropped were mostly dropped due to lack of active maintainers at that time (almost a decade ago), which is why they were not ported over. For example, `Zend_Date` now has core support via Derick's awesome work on `DateTime`, which is much nicer.
If you're building something from scratch, I'd recommend checking out https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid and maybe considering Paseto.
I still have no idea what habr.com is. You have my permission to share it there. I didn't get through adding forms, too long to do some real work.
I'm getting a little frustrated with this subreddit. Please stop putting words in my mouth. I never said not to use Symfony. I never said that Symfony was bad. I never even said that something else was better. Symfony may very well be the best framework ever conceived. That **still** doesn't invalidate anything I actually said. All I said was that I am skeptical of your claim that "less code = less bugs" when the less code comes from annotations. I still believe that to be true. Because it's not **actually** less code. It's just secret, hidden, code that you can't read and debug, and that your PHP tools like your IDE or phpstan can't help you with. This is, of course, pretty far off tangent now, but I'll continue about annotations anyway. I am not afraid of new things. I've written backend software in PHP, Java, Kotlin, Clojure, Elixir, Rust, JavaScript (Node), and Go. They all had things I liked and things I didn't. I LOVE new things. I LOVE the cutting edge. Comments-as-code is not it. The only thing worse is ActiveRecord-style ORMs. The fact that libraries and frameworks in Java, PHP, C# use annotations is mostly a *symptom* of bad languages that are not expressive enough. It's like using C macros. In a language with a powerful and/or flexible type system, you don't need magic comment strings to help you generate code. Notice that all three of those languages are shockingly similar when it comes to language design (in that both PHP and C# are copycats of Java). I don't know about TypeScript, but I can't imagine why a TS framework would use annotations. Even Express.js doesn't use annotations for routes, etc.
Did you re run composer?
No, what switch should I use?
Composer install
Composer install
From the phpMyAdmin docs 1.31 Which PHP versions does phpMyAdmin support? Since release 4.5, phpMyAdmin supports only PHP 5.5 and newer. Since release 4.1 phpMyAdmin supports only PHP 5.3 and newer. For PHP 5.2 you can use 4.0.x releases. PHP 7 is supported since phpMyAdmin 4.6, PHP 7.1 is supported since 4.6.5, PHP 7.2 is supported since 4.7.4. So probably downgrade to 4.6 on PMA.
I did that. No change. I'm going to try to downgrade per Rimbles comment.
Ok. Thanks. I'll try that now. From what I had seen 4.8 would work with 7.0 but it's worth a shot.
Jesus christ. GTFO you're not wanted.
Compare what exactly? What kind of differences?
If you mean comparing the output of a given piece of code, there is https://3v4l.org/ for snippets If that's not what you're after, it might help if you explain what you're trying to achieve.
If it could analyze the php5 code and show the lines or functions that would not work in php7 that would be awesome
Take a loot at [Rector](https://github.com/rectorphp/rector).
[https://github.com/sstalle/php7cc](https://github.com/sstalle/php7cc)
Why not share this as a link and not a discussion?
I am trying to migrate an app from php5 to php7. I was hoping there is a tool that would show or highlight the syntax errors that needs fixing. Hopefully this provides some clarity
Update composer with the version you need, then run again.
https://github.com/PHPCompatibility/PHPCompatibility Do note that there are some language changes that are very hard, if not impossible in some cases, for automatic tools to detect. See the "Upgrading" appendices in the PHP manual.
Thanks alot :)
Hey, prince\_868, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Where are all those Laravel downloads coming from? I know it's one of the most popular web frameworks on Github and in the PHP realm but I still can't fathom 2M people requiring a Laravel installation every month... Does this maybe include composer updates as well?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I would check out the deprecated features and backwards incompatible changes here - [https://www.php.net/manual/en/migration70.php](https://www.php.net/manual/en/migration70.php) &amp;#x200B; If you wanted something that would actually show you the syntactical errors, you get the PHP7 executable for your OS and change your linter/syntax highlighter executable path in your IDE.
Hello, I wanted your feedback about these few tips I wrote for building frameworks, any suggestions ? (by the way sorry for my english, it's not my native language, tell me if i can fix typos \^\^)
Hi, There is this series of video : [https://www.youtube.com/watch?v=82yVPNwC8cY&amp;list=PLjwdMgw5TTLX7wmorGgfrqI9TcA8nMb29](https://www.youtube.com/watch?v=82yVPNwC8cY&amp;list=PLjwdMgw5TTLX7wmorGgfrqI9TcA8nMb29) (The guy speaks in french but shows code) &amp;#x200B; It shows you how to build a real website with real examples, how to implement security, how to setup CRUD, etc... It is quite complete and clean, you can check it out if you're not afraid of french speaker :) &amp;#x200B; Have a nice day
I learned a lot from code https://codereviewvideos.com his courses are free if you don’t need the videos. I would really like to pay for them but his subscription is pricey
I would not call this "tips for building frameworks". These are general tips for programming everything. Nothing should be made without namespaces or performance optimizations. Even business logic. "dont silence errors" will happen... if not in the framework itself then some code monkey will paste a @ somewhere in the business logic. &amp;#x200B; More generell tips for a framework would include the headline "Documentation". (You got that) A Framework without documentation is pain. I see that with mine everyday when 3 developer asking some default questions about it. &amp;#x200B; I also wrote the "framework" on the fly with the developers so it grows with the application and its needs. i dont know if it is the right way but it feels like it? Eventually i will come back here tomorrow and paste some experience with my framework and my team here. &amp;#x200B; (My english is also not good. Feel free to overlook the errors)
If all you do is run a binary/PHAR file, then why not write it in something other than PHP? IO operations on PHP are relatively much slower than other low level languages, correct? Wouldn't it be faster to run if it were written in a language like Go, Rust, or C and therefore save you time in the long run?
&gt;Because it's not **actually** less code It is when used in right context, like my example. Check out more realistic usage: [https://symfony.com/doc/master/bundles/SensioFrameworkExtraBundle/annotations/security.html](https://symfony.com/doc/master/bundles/SensioFrameworkExtraBundle/annotations/security.html) &amp;#x200B; Otherwise, user has to write 3 lines and inject 1 extra dependency: \`\`\`php public function index(Security $security) { if (!$security-&gt;isGranted('ROLE\_ADMIN')) { throw $this-&gt;createNotAllowedException(); } ... rest of code... } \`\`\` &amp;#x200B; Tell me, how is this not example of saving on code and making it more readable? &amp;#x200B; &gt;It's just secret, hidden, code that you can't read nor secret, you can see my example at top and read it. You are **literally** one ctrl+click away. &amp;#x200B; &amp;#x200B; &gt;that your PHP tools like your IDE or phpstan can't help you with They do because as I said, all my files are strict with 100% typehints. And the usage of annotations is almost the same as in other languages, it is always only some code that can use it. Other inluded in FW like @IsGranted or my example, it is irrelevant. Language itself does **nothing** except instancing, which we wait: [https://wiki.php.net/rfc/annotations\_v2](https://wiki.php.net/rfc/annotations_v2) &amp;#x200B; &gt;but I can't imagine why a TS framework would use annotations Same as Spring and Symfony: [https://docs.nestjs.com/controllers](https://docs.nestjs.com/controllers). And because Java and TS has variable annotations, user can even autowire scalar params or have more control over services that use same class (adapter pattern). &gt;The fact that libraries and frameworks in Java, PHP, C# use annotations is mostly a *symptom* of bad languages that are not expressive enough You have 2 options here; either you don't understand their value, or thousands of developers who made those languages are wrong. &amp;#x200B; Hmmm... I wonder what that can be :)
Just upgraded some real old legacy to the new PHP. If the code base is not gigantic (Team &gt; 100 people) then you can do it with try and error and search and replace. Its not too much. I hope you got some tests.
&gt; Using greentext arrows on reddit
May i ask you why you downgrading? I never saw that in real live. its not even a small version jump. Why should you do that? youre loosing a ton of performance
Hi, Thanks for your feedback ! You right, these tips could be applied to programming in general, true \^\^ I've wrote this article after reading a lot of thread concerning custom made framework so it inspired me, I associated both at the time. &amp;#x200B; By the way, since you mentioned you've made a framework, is it public ? I'd like to see it by curiosity aswell, if you don't mind of course ! :) &amp;#x200B; Have a nice day !
First i like your approach that youre not running away from building your own framework. &amp;#x200B; Its "closed" open source but i will make every component open source on github over time... Not much to see there expect the not working dependency injection we are using? [https://github.com/PurHur/FractalOfGreatDependencyInjection](https://github.com/PurHur/FractalOfGreatDependencyInjection) (sorry for the german readme but it doesnt run like it is now) Also note that the base of this is probably now like 2-3 years old.
&gt; Tell me, how is this not example of saving on code and making it more readable? Because the code is written **SOMEWHERE**. Just because you wrote one line doesn't mean those three lines don't exist. They just exist somewhere that you can't see. There is not less code- there's more. There's the code that is generated **AND** there's the code that reads your comments and generates that code. It's **far** less code to add three lines and inject a dependency. And it's almost certainly easier to write unit tests for! It's also more readable because I can see that there's a dependency. The other way makes it look like there's not a dependency when there really is. &gt; You have 2 options here; either you don't understand their value, or thousands of developers who made those languages are wrong. Or that those languages became popular in the 90s and early 00s, and we didn't know everything in the 90s that we know now. So in some sense, yes I guess they are "wrong". But more generously, those languages were great for the 90s, the same way that flip cell phones were awesome. But we have better now.
https://symfony.com maybe?)
Hey, how did it go with the project?
ReactPHP + Synfony (SINGLE COMPONENTS NO FULLSTACK EVER!!!) &amp;#x200B; and you have a rock solid base and it will be totally scale able horizontally.
What bothers me about all these is how irrelevant they all are to actual day to day programming on a PHP project. Like okay cool you know how to do the Fibonacci exercise. What now? Do you know how to write SQL queries? Have you ever mapped an ORM to a data store? What about rate limiting an API? Ever had to setup Single Sign On? Have you ever scaled anything from 100 users to 100,000 users? How do you handle job running? Concurrency? How would you debug your server locking up due to 100% CPU usage? Ever configured a dev environment on local with xdebug? Breakpoints? Command line tools? Ever normalized data between multiple third party APIs? What does normalization even mean to you? What about unit testing? Mocking data pre-test and cleaning up after test? How do you make it fast? What's the autoloader? How do you properly setup composer? Tabs or spaces? Why? Windows, OSX, or Linux? Why? Favorite IDE? Why? Are their opinions so strong they can't work with others? On and on it goes. In the past 6 months at my job I've dealt with all of the above issues and more. I would still probably fail most of the exercise in your Github repo. Mainly because all of them are irrelevant to the actual work and honestly I can't be bothered to sit here and memorize various math algorithms that have quite literally nothing to do with the work. PHP comes with with [13 different sort functions](https://www.php.net/manual/en/array.sorting.php). None of them test you for how to write a bubble sort. I'd rather a candidate know when to use one over another instead of knowing how to write just one or two of them from scratch. Here's the thing though. I've written bubble sorts before. In college. When learning C &amp; Java. In no way shape or form do I ever practice them or actually remember them at a moments notice. I look them up like a normal person if I ever actually need them. When I interview a candidate I don't use any of these nonsense exercises. I have one small code exercise at the end which makes use of recursion. The rest of the interview is an open ended series of questions on systems and just basic "shooting the shit" style questions. The nuance of how you answer the questions tells me everything I need to know about a candidate. On the flip side if I'm the candidate and someone asks me one of these I know they actually suck at interviews and my immediate instinct is to walk out. I try anyway to be polite and not burn any bridges and most of the time I'll come up with a correct solution but again my initial instinct is "I don't actually want to work here anymore". So what do you do instead? Be creative. Have fill-in exercises. Write an abstract class and an interface and have them build you a class that implements both. Write some code with obvious mistakes. Have them fix it. Build a full from scratch login system. Have a user already in the database with a hash already there. Make them fill in the authenticate function. Watch them not use password_hash and ask them why. Make them use Google. No exercise should take more then 15 minutes. The majority of the interview should be you digging deeper into their previous roles. Have them tell you success stories or cool hacks they've put together. You'll learn way more about them both as a person and as a developer.
But it totally depends on your application. Dont just take "the best".
You can also try Adminer unless you really need phpMyAdmin. Should just work with any PHP version.
&gt;Because the code is written **SOMEWHERE** Is my English that bad? I said multiple times that annotations by themselves do literally nothing. &amp;#x200B; &gt;They just exist somewhere that you can't see. Well looks like my English is bad because I said multiple times that you are one ctrl+click away of seing where it is used. &amp;#x200B; &amp;#x200B; &gt;Just because you wrote one line doesn't mean those three lines don't exist. Yes, those 3 lines do existing. But only once. Otherwise, I have to repeat those 3 lines + 1 extra dependency **everywhere** I need security. So just for 50 routes, it is 100 less lines and 50 less dependencies saved. Not to mention more complex things than this or the fact that I can put just one @IsGranted over controller, if all methods use same rule or are inheriting it. &amp;#x200B; \--- &amp;#x200B; But I give up, sorry for my bad English. Repeating same thing multiple times didn't help you in understanding my point so it is best we go other ways.
No luck.
Needed for Snipe-IT
I'm partial to my own framework which has a full ActiveRecord ORM and a REST API Controller. ActiveRecord and the REST API has 90% code coverage. It only supports MySQL but I kinda like that cause it's not abstracted out like Doctrine to support multiple data storage engines. I've built dozens of sites with it.
I wholeheartedly agree with you! Practical &gt; Academic
As i said before, i agree with that. That is beside the point. My point is that reflecting on generic folder structure is not pointless, it is a good exercise.
Good article in general, have my upvote. But the example in the "Performance" section is appalling. It's a textbook example of handling performance completely wrong way. &gt; On small arrays, this shouldn't be felt but on bigger arrays it can cause some slowness in your application. Dude, it's the fekkin **big array** that causes "some slowness"! Instead of hunting fleas that will improve the performance for the whooping 0.0001%, get to the real cause! Your app just shouldn't deal with big arrays, at least when processing a user's request. Just think of it. It's processing of a big array makes your app slow, not a trifle function call. You should always fix the real cause.
Try a different version, 7.0.32 or something else. We had a problem with array_column in this version which worked in other versions.
i want to vote yes.
If you are struggling with multiple php versions on the same server. this is the time to learn docker :3
How is not?. People don't read. Who is the linux foundation?. Microsoft for started but also AT&amp;T, IBM, Intel, Samsung, aka all cool guys.
^(None actually, notepad++)
The main point is be able to extend the tool. PHP developers know mostly the PHP. That's why php-parser - a parser for PHP written in PHP - got so popular. Until then, there were few other parsers, but not really got populator or maintained for a long time.
When you open [the package detail](https://packagist.org/packages/laravel/framework) - you see there are [*Dependents: 6 606*](https://packagist.org/packages/laravel/framework/dependents). That might be one source. `laravel/framework` is a package recommended almost everywhere, so every Laraval extension probably requires it. That might be another source. 3rd source would be Laravel applications. Btw, when we give the Laravel number to perspective, e.g. with [`symfony/console` has 4 911 068](https://packagist.org/packages/symfony/console/stats), it becomes quite real.
It isn't dead because it hasn't seen an update in more than a year. It is dead because there are many issues no one has addresses and many patches sitting in the queue that no one has looked at for many many months. I agree many projects that are simple and pretty stable don't need regular updates that is why that isn't the only factor I look at.
ack vote no!
That makes sense, thank you
Yikes, using ternaries more than two deep seems super sketchy.
Agreed. I think it's a good idea in the end, but every time I see people bitch about this issue I think to myself that if you've got anything in your code where this matters it's already clear as mud and which direction it works in is the least of your problems with it.
`vi`
Your English seems fine, but we're definitely talking past each other. We'll agree to disagree. Best of luck to you.
Dhole is an open source library in Node.js and PHP that wraps libsodium. It's designed to be easy to use, hard to misuse, and secure-by-default. It even provides a mitigation for fault attacks against Ed25519, should I eventually write a C/C++ or ASM port of Dhole for smart cards &amp;c I started with the PHP implementation because it was the first language to adopt libsodium. I'm branching out to others as time goes on. I hope someone finds it useful, or at least, neat.
According to its [requirements](https://snipe-it.readme.io/docs/requirements), snipe-it runs on any php version lower than 7.3. So why do you choose to install an eol version of PHP that doesn't get security patches anymore, when 7.2 would also suffice?
In case someone hasn't noticed the post has a link to a post with the answers to that question from 8 years ago.
What is your reason for wanting to keep this in the language?
Glad to help!
Configuration on how the programming language behaves? Sorry, but that’s a hard “no” for me.
Reasonably clean, readable code. Solves an actual problem without convolution. Documentation is straightforward. Multi platform. Tests for the core functionality. Uses a package manager friendly format. Package developers take heed, this is how it’s done. Kudos.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
It's less than ideal, but we're talking about what would be the best bad. We can work around the same defaults in everything from 100 years ago, or we could just explicitly opt into different standards. Like wouldn't it be nice if instead of every single page on the internet having x lines of reset CSS to get around the defaults Netscape Navigator interpreted HTML as when Columbus brought the first websites over on the Mayflower, and every browser has maintained since so all our Angelfire sites still look just like they did, we could just opt into a different set of standards?
How can i be sure that your new thing doesnt open a hole?
Interesting idea. I started Robo because alternative projects provided yaml or xml syntax, which is very limited compared to what you can do with PHP. But yeah, one day the wheel make a turn and we've got Robo with YAML syntax! Why not :) I have one suggestion. Yesterday I found myself running .travis.yml comands by copying them one by one into terminal. Maybe taskman could execute .travis.yml as well, if it already supports YAML? That would be helpful.
What if I want to use two Composer packages, one with LTR associativity and one with RTL? Do I have to fork one to "fix" it? That just sounds like a bad idea.
I think the issue at hand is fairly minor and uncommon, and adjusting existing code will be relatively trivial. Additionally you can use a linter to detect and (attempt to) fix it. A hard break is a much better solution here, much better than an external configuration directive that changes the meaning of the code.
This doesn't make that issue better or worse. Packages will just have to paren so it didn't matter, same as it seems they will now.
Perhaps in this instance yes, I just wonder if in general it wouldn't be a better way to go sometimes. Not a perfect way to go, but a better way. But yes, this seems to be much more along the lines of "if you backed yourself into this dumb corner in the first place, you can fix it here and there". Though I say that and watch it turns out 5 dependencies will throw the warnings for a year before someone gets around to it.
The best answer: Ask a cryptography expert. Failing that, you can take a stab at the code yourself. The PHP code for symmetric encryption [looks like this](https://github.com/soatok/dhole-cryptography/blob/949ea1e0db915346d3319d37148a74f9f6f38fc4/src/Symmetric.php#L106-L193), for example. [Encryption](https://github.com/soatok/dhole-cryptography/blob/949ea1e0db915346d3319d37148a74f9f6f38fc4/src/Symmetric.php#L114-L129) is 16 lines, [decryption is 29](https://github.com/soatok/dhole-cryptography/blob/949ea1e0db915346d3319d37148a74f9f6f38fc4/src/Symmetric.php#L155-L193). Places that a security vulnerability could be introduced: * Base64url encoding/decoding (cache-timing side-channel leaks) * I'm using Paragon's library for this, which claims to be constant-time. * Downgrade attacks * The acceptable headers are whitelisted, and covered by the authentication tag. If you provide an invalid header, it fails to decrypt anything. * Nonce misuse * Should never happen thanks to `random_bytes(24)`. If there's another attack possible that hasn't been addressed here, which doesn't **also** affect XChaCha20-Poly1305, that'd make for a *very* interesting attack research paper.
This is a definite yes, from a code reviewer's perspective.
We had these sort of configs in the Deep Dark Days of PHP3 and PHP4. magic_quote_string? :-/ I've already been down that nightmare path. # Just say NO!
Not just from you, we have a hard policy against introducing ini settings affecting language behavior. One of the last instances of this is going away with https://wiki.php.net/rfc/deprecate_php_short_tags.
This is exactly the problem we had with all the configuration options (magic_quotes ::cough::) in PHP 3 and PHP 4. Only idiots would promote this sort of stuff.
Cool. Share with us your source code or GTFO.
https://github.com/divergence/framework Here's an example website: https://github.com/hparadiz/technexus
But what if we were still working around the fact that by default magic quotes were always on? What if every script we wrong had to start with some call to some dependency's undo\_magic\_quote\_damage()? You're looking for perfection where there isn't any, but IMO this is a perfect example of something I'd rather just be able to opt into having off instead of having to write my code in 2019 to every bad call PHP 0.1a made.
Id be worried about being fired if I was using nested ternaries.
&gt; The left-associative behavior is generally not useful Lol understatement of the century - it’s literally useless. Kudos to Nikita for proposing this. Would there be any harm to not making it an error in PHP 8 and instead make it a BC break? We’ve done stuff like this before e.g. changes to variable handling like `$foo-&gt;$bar['baz']` in PHP7. Is that why some people voted against this RFC? Because that’s the only reason I can see.
So packages would have different rules from "normal" PHP scripts?
None more than they already would and do.
Symfonycasts.com The content is worth the price, but if you don't want (or are unable) to pay, the code and the video transcript are available for free.
Tanks. My question was aggressive and you answered really well and like you are open to everything. Thank you! This is needed for good security components. But I will have a eye on it.
Right now, the behaviour is defined. It's the same in every PHP installation. With your proposed change that would no longer be the case. If a library author doesn't think of this, they will upload code that is potentially broken on some machines. How can you not see that this is a terrible idea?
a) They already think of this plenty. They aim at specific versions, they name space, and so on. b) The "fix" here would be exactly what the RFC is proposing to do. There would be no downside added here.
Looks good to me, would have to try it to have a place to say. Neato, thanks for the tip!
Nested ternaries are like variable variables.
Just wanted to say that I *love* this project and have been involved in it in the past and can wholly recommend it. Everytime I made a suggestion, a solution was implemented in PHP Desktop fast. I've used it in multiple small projects and loved it. The real benefit and beauty of the project in my mind is that there is no special code to use it. There are no special directives for different platforms or setup code. You can literally download PHPDesktop, drop your existing webpage in the www folder, and run the already included exe and you've got a completely functional desktop app. That's just incredible and couldn't be simpler to use. Not only is it super simple to use but it also allows you to have a web app and a desktop app with *literally* the same code base. I don't have to create two git repos for different versions. It's really incredible.
I ran into this problem last week. I was using sqlite for testing and after deploying to our staging env (mysql) I got an exception for trying to order by a non existent column. I still use sqlite while developing because it's so much faster and then run one more test using mysql before any deployments. To be honest, I haven't done too much digging around in sqlite so I'm not sure if it's the database internals or the ORM (Eloquent).
cause i gota dig around and rewrite code that was working fine, didnt know this was even an issue.
I recently had a situation where dealing with big arrays was inevitable. I was syncing fitness data in a given period for a person and this data needs to be de-duped so people don't get double credit. Doing this traditionally you have a foreach inside a foreach. Date for a few days? 10 records? No problem. 4 months in 400 records? Have fun with 100% CPU usage for a few minutes. What do? I ended up writing a Collections class which pre-indexed the fields I needed as they were added to the collection so the result set was already known when you needed it. What took minutes before now takes 10 seconds.
Code golf?
I like variable variables. Lol I use them often for doing a bunch of the same things on multiple variables quickly. Granted, arrays are better and easier to use, but when your supervisor expects all of your variables to be single, explicit values, you get creative to avoid having the same line over and over.
I think you might misunderstand this. If your code was working fine under this type of chaining, I'd be surprised. Carefully look at the examples and where the parentheses are placed. The results are completely useless. Fixing your code is not going to be difficult.
How do you think it compares to https://github.com/paragonie/halite ?
code works fine, i know how it works. ive been using php almost 20 years. dont talk down to me.
I see nested ternaries like this in code I'm reviewing, it's not getting approved
Looks great! Good post too about all the different moving parts. Looking forward to when we can pre-compile PHP libraries in deployments. A bit of a tangent, but could this be used give better tie-in with the PHP source, allowing more extensibility using PHP? Writing PHP extensions is it's own tech with all the ZEND macros and such. There is an alternative to use [Zephir](https://github.com/phalcon/zephir) but it doesn't expose the internal zend functions, and more importantly it isn't PHP. Would love to hear your thoughts.
What exactly is your legitimate usecase for this syntax? I'm sure /u/nikic would love to know as well. If you don't give examples, how are we supposed to discuss this?
$x = $y == 1 ? ‘blah’ : $y==2 ? ‘meh’ : ‘blarf’; there no use case thats a big deal but forcing parens seems a waste of time
What is the use case for nesting ternary operations at all?
no reason imo to fix something thats not broken. add the option for parens but dont force it. if its weird to look at, lets dump regex
For the love of god... Stop telling people to use RAM as the main factor in PHP-FPM calculations! https://www.reddit.com/r/PHP/comments/auz2il/high_volume_tuning_php_fpm_on_nginx/ehbhaeg/
Yeah I don't think it works how you think it does. https://3v4l.org/GFepJ
&gt; _your supervisor expects all of your variables to be single, explicit values_ a) micromanagement b) busywork to justify their useless existence c) recto-cranial insertion Pick two.
&gt; _Like wouldn't it be nice if instead of every single page on the internet having x lines of reset/normalize CSS to get around the defaults Netscape Navigator interpreted HTML as when Columbus brought the first websites over on the Mayflower, and every browser has maintained since so all our Angelfire sites still look just like they did, we could just explicitly opt into a different set of default standards?_ You mean like quirks mode vs standards/almost standards mode?
Get off my lawn! But seriously, I've been using PHP 15+ years, only recently learned chained ternarys work this way. It's never been an issue before because chained ternarys are gross so I just don't do them ¯\\\_(ツ)\_/¯
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
😂 I don’t know why. He’s an older programmer who prefers as many things as possible to be written in Perl and croned. He refused to use git forever and still doesn’t trust it—he still copies and comments out lines of code when they change, in addition to copying files he changes to ../backup/YMD/file_name.old.php or to /file_name.YMD.php; He got mad when I gave him an account on all the machines and told him we shouldn’t have a root ssh key—he still sshes as root to this day despite the CEO and I telling him repeatedly that the root accounts shouldn’t be used. He doesn’t like sudo. He uses the default color scheme of VI with no plugins and mouse mode off... but relies heavily on notepad++ for heavy lifting. he has a script which he refuses to turn off that backs up the entire code directory to a zip file every night and mysqldumps to a zip file every night as well— this locks up the database regularly and even corrupts tables often enough that I check for overhead every morning looking for tables to repair. in addition, these are written in Perl even though they only issues shell commands and very well could be a simple bash or POSIX script if it was even necessary. We’ve gone through so much storage doing this. Oh and everything is logged to files which he saves indefinitely—there’s logs from 2007 on the internal servers. We have multiple servers on the same internal network, but instead of centralizing and querying each server directly, he dumps tables with OUTFILE (Perl scripts) copies them over FTP, and loads them INFILE (also Perl scripts) at the destination. This is all croned. In this process, which happens multiple times daily, data is loaded into temp tables, the live production tables are dropped, and then the temp tables are renamed. Since this is all croned, there are points in time where there’s data just missing and things don’t work. He doesn’t like when I use heredoc to syntax highlight—specifying that a solid-color string is superior, nor does he like it when I format things on multiple lines and aligned for readability, positing that each string variable should be one long ass string that wraps around however many times or should be concatenated with .= He always uses echo to output html, css, and js. Even when there’s no PHP logic, he usually uses echo if it’s within a .php file. He’s not a fan of when I escape PHP to do large blocks of HTML. He loathes it when I write classes instead of procedural or functional code. He doesn’t like to use name spaces and doesn’t trust autoload over require_once He hates when I do things in JavaScript using Ajax instead of having the entire page hit the database loading all the same data every time a button is pressed or an interaction occurs. He relies heavily on pop ups to do things and isn’t a fan of modals. He says MyIsam is better than InnoDB, we can’t use NGinX, or Percona, and everything is Latin1 instead of UTF8mb4. There’s encoding problems alll the freaking time. But he’s been with the company for ~15 years. His croned Perl scripts are the backbone of a large percentage of the business, and they moved the company from $1M to $200M /y over time. He’s a nice guy and works hard. I’ve only been with the company for 3 years and I’m young and “inexperienced.” The general attitude is that I haven’t been around long enough to understand the reliability and importance of doing things this way. But honestly, if I was in charge of the programming department, everything would be quite different than it is now. For certain, this isn’t the best way to do things.
In a lot of ways it's simpler: * Halite does file encryption (which includes a lot of machinery for side-stepping TOCTOU attacks), Dhole only deals with strings * Halite has separate key objects for asymmetric cryptography (i.e. `SigningSecretKey` is Ed25519 while `EncryptingSecretKey` is X25519). Dhole derives a birationally equivalent X25519 keypair from your Ed25519 keypair. If you're nervous about birationally equivalent Montgomery keys from an Edwards key, you'll feel safer with Halite. * Halite has other auxiliary classes (e.g. `Cookie` and some merkle tree implementations) which I didn't see any value in. Given the choice between the two, you should Halite more. It's got the pedigree of being a Paragon project, and has endured years of analysis from other PHP security experts. Whereas Dhole is a hobby project I started for my hobby game dev projects and decided to open source. As a matter of pride, I'll try to make Dhole as secure as I can. However, I'm just one guy, not a security team. The upshots to my library are: 1. It works in PHP and Node.js 2. It's smaller and easier to audit (albeit, at the expense of not having features other people may need) When in doubt, ask a cryptographer. I believe we're using the same ciphers, etc. since both rely on libsodium.
I am screaming right now! Holy crap!
it does, sorry if the code i typed on my phone didnt work.
Thanks for the detailed response! Appreciated.
Beautiful. Would you like to trade? I have to deal with Indians who write standalone .php files that load all of Magento to make two raw SQL queries complete with SQL injection. 😁
Dude, again, if you can't post an example to support your claims that your code works as expected, how are we supposed to discuss this?
noone does. so why bother changing it?
Nope. As much as I hate this way of working, I have slowly pushed my way through by talking directly to the CEO on a regular basis about how we could improve things. He’s the one who helped me push the git workflow using separate sandbox servers synced through git hooks for the files and croned rsync for the database. Not quite the best, but an improvement to say the least. We’ve replaced many old ftp calls with rsync and scp which are way faster and more reliable in our experience thus far. It just takes time, but with my supervisor living in a completely different state, I have an upper hand in shaping the future of the company.
Of course there are situations where dealing with long arrays is inevitable. But again, it is not a simple cheap function call that makes them slow. But the amount of calculations itself. And one have to deal with that amount in the first place, like you did. So, my point was that optimization is important, but it is not done the way it is advertised in many articles on internet: just change one function call for another, and you're set! And telling a reader they must avoid processing big amounts of data (by means of selecting only a certain amount, or indexing, or caching, etc. would be the real help.
I didn't realize how lucky I am...
Dude, again, why fix shit that isnt broken?
Because it is broken.
the example i weote while driving on my phone?
i dont give a fuck anymore. add parens who gives a shit
I agree. I'd prefer to see the right associative behavior in PHP 8.
Do I need to repeat myself for the 3rd time? Provide an example to further your point.
example: i said i dont give a shit anymore and im sick of seeing your name.
You actually didn't say that earlier, but fair enough. Also you admitted to texting and driving... which is insane.
The fucking short closures thing is a mess. CAN WE NOT HAVE `$a = function() { }` ALSO inherit the parent scope?! ffs.
Shh.. None of the guys making the decisions about the language's direction actually do code reviews in PHP! None of them manage teams of PHP devs. In fact, some of them have never worked on major PHP projects. I kid you not! It's like the "landed class" in 18th-Century England making decisions for the American commoners. The same basic disconnects.