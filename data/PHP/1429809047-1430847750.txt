I develop in CI 3. My recommendations: -Name your models and/or controllers with prefix/suffix. You need to do this to avoid name conflicts since CI3 do not use namespaces. -Define all of your routes. CI does not force you to do it, so you may end up in situation that you don't know which controller/method is run when you have lot of endpoints and you mix in statically defined routes with automatically resolved routes. -Beware that built in profiler saves all of the sql queries in memory, so if you need to do some large sql batch job and have logging of sql queries enabled in profiler, that's what causes OOM error. -If you use database transactions CI does not discard these when PHP error occurs, so you may end up with frozen queries in you next instance. Just be aware of this fact. Simplest way to "ungang" it is by resetting sql server. -Don't try to do everything with built-in query builder just for database abstraction. Just use raw sql when you need something that QB does not support (e.g. delete with joins). Or 3rd party query builder. -Sessions mechanism in CI3 is not perfectly compatible with pure php implementation. If you need other apps to access this data, you need to load sessions from location specified in CI3 config. Simple $_SESSION['stuff'] won't cut it. -Built in template parser is too basic, so don't use it if you need more than most basic stuff (built-in one e.g. doesn't support conditionals, shows syntax errors for empty foreach etc.) -If you need to do database management in your framework with some more complex stuff (e.g. foreign keys, enum fields...), don't use dbforge. It's too simple. Or use it, but you will need to do some stuff with raw sql.
i know it's mega basic, it's meant to start off very simple to easy people into the eventual playlist (perhaps i should have uploading all at the same time..?), to be honest I'm pretty new to youtubing so its all going to be a learning curve. you're right though, I should show how to set up the local dev environment too - currently working on a mac so it'll be a mamp install.
What's next is fixing those typos in docs ;) funciton time funciton date funciton now
Thank you! :)
I know both, but they are too heavy for my use case.
Dad jokes are fuckin hilarious. I mean, I'm sorry your uncle touched you as a kid, which has caused you to grow up to be such a stoic individual, but why bring that negativity to those you don't even know? **That** seems cringeworthy to me, or at least more so than a simple joke, man.
&gt; Disabling the submit button still allows people to submit by hitting enter in a form field. The html5 standard says it should not happen. Hitting enter in an input field should trigger the default submit button. If the button is disabled, then it should not submit the form. http://www.w3.org/TR/html5/forms.html#implicit-submission But I just tried and the form does submit in IE11 :( So, yes, what you said is correct. Edit: markdown
[PHP can run V8 JavaScript.](http://php.net/manual/en/book.v8js.php)
CodeIgniter 3 still supports PHP 5.2 and aint adapting to the latest PHP techniques and practices, this is 2015 already my friend. I dont know your company's history though and what an application it is building, so I cannot tell exactly if it will benefit from CI3. But in general, CI3 is not to be recommended for new projects, its best suited for legacy projects, especially if your old application was built upon CI2. In most cases, stay away from it and make sure your software is up to date. Read Anthony Ferrara's blogpost and you understand why you should stay away from CI3 unless you dont have a choice: http://blog.ircmaxell.com/2014/12/on-php-version-requirements.html
&gt; It seems this developer ONLY develops in CI. Big red flag right there. &gt; port our ecommerce soltions to CI Even bigger red flag.
SQL Developer isn't a database, it's a tool for interacting with/managing your database(s). You don't connect PHP to SQL Developer, you connect PHP to your database.
Indeed, we need to continue to implement more commands. create-project is a pretty important one. Long-term I'd like to make the actual Composer commands more portable so that they are more easily usable by other Composer-related projects.
I didn't say I was a PHP developer for 8 years, I said that I was a developer for 8 years. Thanks, however, for not actually reading what I said and assuming I'm a colossal piece of shit.
Cool! Keep on coding! :)
I discovered process wire after doing a bit of search. Am very happy with it so far. 
I made this purely because I wanted a PHP port of [Ruby Slim](http://slim-lang.com). And while I was making it, I noticed I didn't like the more verbose control structures of Ruby Slim. Like why write `- unless items.empty?` if this is just as easy to understand and much shorter: `? items`. But I can imagine opinions differ on this, so I'm willing to write more verbose versions of these control characters if more people request this. So I'm not using this in production just yet. I think I will though, if I can make it as complete as Ruby Slim and Laravel Blade are. Right now it's still missing some features that are needed to make it really powerful. If you want to add or suggest features to make it more powerful then please do!
Posts like these (and the one preceding it in her blog) make me sad. They seem like desperate cries for controversy and clicks because the author is no longer able to produce any concrete programming-related content. I'm incredibly disappointed with the immense oversensitivity we're facing every day, and believe stuff like this actively harms the community and cooperation between not only subgroups within a single community, but different communities. Yes, there are problems that need addressing - like the very wrong attitude towards women at most events, or judgmental attitudes towards various types of minorities - but wearing a comical shirt is *not* something that should offend you and it just reminds me of the [rocket scientist's stupid shirt shenanigans](http://www.theverge.com/2014/11/13/7213819/your-bowling-shirt-is-holding-back-progress). At work, I poke the JS and Ruby guys and they poke me, and none of us take it seriously. A professional should be able to both take a joke, and finish a project in his tool of choice. If a complaint against your environment offends you, you're not a professional because you obviously just don't feel secure enough about it.
I grabbed the latest source from Magento2's github repos, composer-install'd the dependencies and ran the installer. Then I ran the inspections on `app/code/Magento`. For the most part, the result was just as bad as in 1.x - I got 17k instances of "undefined method" and 3k instances of "parameter type mismatch". The icing on the cake was 4k instances of "undefined class" -- I don't understand how that is even possible, tbh.
Why are people so obsessed with templating engines? 
Extractor and Parser are required dependencies and as such I'd argue that they should be passed explictly, but named constructor is a neat idea. I can implement it straight away, but maybe you are interested in contributing? I'd happily welcome PRs with this and possibly other ideas, for example from [this list](https://github.com/thunderer/Shortcode#ideas). Thanks!
I didn't know about this, pretty cool. But then again, would you really want to run JS inside PHP? I don't see the use case.
&gt; He has to run this third-party code sandboxed Then he's looking for a sandbox--not PHP VM's or PHP-ception.
[ummmm](https://github.com/Evertt/Slade/blob/master/src/Nodes/VariableNode.php#L23) Also: [htmlentities()](https://github.com/Evertt/Slade/blob/036901990ad8f6783a7fca4371675cec02a02db5/src/helpers.php#L126) is incorrect, that should be using `htmlspecialchars()` instead (htmlentities is the wrong tool). Finally, I'm extremely warry about using a regex-based parser, as it could contain several weird and hard to track issues...
Cool, I'm pretty much refactoring everything after all this suggestions, but if it all stays as it is structure-wise (only a constructor and a method) I'll go the function way instead of having a whole class. Thanks!
Well everything has a templating system. I'm not sure why. I was chatting about it with another developer and we were wondering what's so hard for developers about just doing &lt;?php foreach( $array as $item ) : ?&gt; As opposed to : {{ each $array as $item }} 
Your's is quite a bit different than Laravel's. Looks like it saves some time. 
Observing a book as it's being written... that's quite fascinating, actually. Yay, we're in the future.
I disagree completely. By definition, you can't implement portions of generics using `instanceof`, because you remove the generality. Function parameter overloading is also a code smell, and if you're using `instanceof` to emulate it, your problem is likely improperly designed interfaces (or lack of an interface at all). It simply has no place in properly designed code.
My preference comes from the fact that I just like to look at minimalistic code. So this: ? user.isAdministrator ul &gt; moderators li = moderator.name Looks much nicer to my eye than this: &lt;?php if ($user-&gt;isAdministrator): ?&gt; &lt;ul&gt; &lt;?php foreach($moderators as $moderator): ?&gt; &lt;li&gt;&lt;?php echo $moderator-&gt;name; ?&gt;&lt;/li&gt; &lt;?php endforeach; ?&gt; &lt;/ul&gt; &lt;?php endif; ?&gt; Can you imagine that? You don't have to agree of course, but I wonder if you can imagine that I prefer the first option just because it's easier on the eye?
Thanks man! Would you have any suggestions for features to add or syntax to change? :-)
It's not about falling over "the new" technologies, it's about the fact that the new technologies encourage better standards closer to PHP core (namespaced autoloading rather than proprietary include syntax) and simply make you more productive: migrations, command line tools, autoloading, ORMs, containers etc. I haven't tried CI3 so it may have all of that, and if it does, great. But if not, then objectively speaking, it's not as good as modern frameworks because it lacks the tools they provide.
Is it possible that [you don't know everything](http://www.linuxtopia.org/online_books/programming_books/thinking_in_java/TIJ303_012.htm)?
Even if you didn't know their name, [you must have heard this?](https://www.youtube.com/watch?v=0A8KT365wlA) but yeah.. cool name! If you want serious feedback, your project looks neat - but I'd also be wary of anything regex based. If that were changed I'd probably use it.
Could you give me some advice on how to tackle problems like these without regex?
The only issue I have with templating systems like that is that I don't know, at a glance, what it's doing. For example, if I didn't see the side by side of `&gt;` and `foreach` I would have no idea that's what it's doing or that it's evidently magically singularizing the argument to give you the `moderator` variable. It adds just that much more time to bring someone new on board or contribute
idk.. are less than and greater than signs really what makes HTML terrible? I don't really see the point in removing those. Otherwise nice stuff!
Meh.. I don't have any experience with CI3. But, I got started with PHP frameworks using CI2. I think it's ok for starting out with PHP frameworks and "OOP" code. But I wouldn't use it for a real project.
Yes it's an optional argument. Square brackets are a pretty common way of marking this up in many API documents regardless of language. 
Ehm, cough: $system_tags = new system_tags($this); foreach($core-&gt;tags as $tag_name =&gt; $tag_method) { $this-&gt;template = str_replace( '{' . $tag_name . '}', $system_tags-&gt;{$tag_method}(), $this-&gt;template ); } That said, if you insist: $system_tags = new system_tags($this); $callback = static function ($matches) use (&amp; $tag_method, $system_tags) { return $system_tags-&gt;{$tag_method}(); }; foreach($core-&gt;tags as $tag_name =&gt; $tag_method) { $this-&gt;template = preg_replace_callback( '/\{' . preg_quote($tag_name) . '\}/', $callback, $this-&gt;template ); } You can also optimize this by combining all tags in one regex, and figuring out the right method from $core-&gt;tags in the callback. It'll be faster. It's under question what $tag_method really contains, however. If it's not just a method name the examples will need modification. You can pass name and arguments as an array and then use call_user_func_array() to invoke the right method with the right arguments.
&gt; didn't know about this, pretty cool. &gt; But then again, would you really wa Isometric ReactJS apps in PHP, of course.
&gt; Nerd rap == Dad jokes Gotta do type juggling first! -Dad
Thank you for trying to help me. $tag_method is the method name. It's basically calling a method ($tag_method) for generating the content of a tag such as {TAG_NAME}. I edited my original post to show that I went a bit further but now I'm stuck again. BTW I tried your code and it didn't work unfortunately. 
For the reasons you've shown PHP is pretty horrible as a templating engine, that's probably why so many people have implemented their own! For reference, here's what your code might look like in Twig, which is becoming a pretty popular templating language these days (e.g. Drupal have decided to use it for V8). It's obviously not as succinct, but it's pretty easy on the eye too: {% if user.isAdministrator %} &lt;ul&gt; {% for moderator in moderators %} &lt;li&gt;{{ moderator.name }}&lt;/li&gt; {% endfor %} &lt;/ul&gt; {% endif %} 
I have to code blindly because I don't have the rest of your codebase in order to run and test the code. The examples cover how to do the replacement via str_replace or preg_replace_callback. See the overall approach and adapt it to your needs. BTW, in your EDITs above you forgot the pattern parameter (check my code more closely). 
Just a friendly reminder. The mysql_* functions are deprecated and already removed in the next major php version. If you are new to php: Don't bother with them and look at mysql**i** or PDO.
Wow! You guys are awesome. Thanks for all the feedback. I will definitely take this into account in the coming days. It's 02:13 AM here, and I am going to bed. I will respond in the morrow. have a good day/night.
Yes, square brackets are often used to denote something that is optional.
jokes are subjective, people respond differently. the thing is, people seem to dish out jokes or insults only when it's safe (like insulting java/php/js/ruby/etc). try some real challenge: try doing a nigger "joke" around some black people.
I kind of, sort have, maybe, messaged before seeing his code. This is cleaner than what I've seen in Laravel's blade. A lot of the tempalting systems I've seen have just been wrappers for echos and ifs. This *IS* cleaner.
Thanks for the heads up!
I am the author and I would be extremely interested to see how you could achieve that syntax. If you have a proof of concept/snippet to show me how it can be done, I would make the necessary changes to the library.
Have to admit, this is a bit too far for me. I understand, and respect, that some people may have had experiences in their lives that would make them sensitive to specific issues. However, walking on eggshells on the off-chance that you run into folks like this, or changing the way you *are* and grew up because you are afraid of hurting someone's feelings? These are issues most of us learned to deal with in our formative years: elementary and middle school. And while I'm not sure if it's "accepted" fact, I have read it enough times that I have internalized the following: men and women bond differently. For example, when around my friends I make crude, gross jokes. We hurl insults at each other. When one of us does something stupid we pile on. None of this is done is a truly negative, hateful manner, I believe it brings us all closer as a group. From my understanding, women do not share this bonding methodology. I make fun of node.js because it has the "flavor of the month" feeling to it, but it has proven itself to be a good technology. I make fun of rubyists because many exude a holier-than-thou mentality, oblivious to their language's shortcomings. Also, making the jump from an elephant stepping on a ruby, to an elephant stepping on a woman's head is quite far-fetched and strawmanning. I honestly have no idea the thought process that led the author to that comparison. It seems like a cheap way to raise hackles to me.
Because is kinda dead
I'll implement your const idea for sure! But for the f\func() syntax, I'm not sure it's possible. You should take a look at the ugly "hack" I had to do to get "static" functions that are "curried" (it involves closures + __callStatic). The reason behind that was to have a nicer syntax(No $ everywhere).
Oh it most certainly is possible: // File "load.php". namespace Foo\Bar { class load { static public function arithmetic() { require_once __DIR__ . '/arithmetic.php'; } } } // File "arithmetic.php". namespace Foo\Bar\Functions { function add($a, $b) { return $a + $b; } const add = 'Foo\Bar\Functions\add'; } // User app. namespace Some\App { use Foo\Bar\load; use Foo\Bar\Functions as f; load::arithmetic(); echo f\add(5, 6) . "\n"; // 11 $callable = f\add; echo $callable(5, 6); // 11 } Here's a running example: http://3v4l.org/s5oBb Should you *do it* though... another matter entirely ;) Might give people a pause at first. Regarding __callStatic tricks, sure you'll lose those. Sort of. I mean... you could still eval() more functions into a namespace... but do you want to I don't know. Maybe not :)
I don't think I quite understand what you're asking for. Can you tell us what output you are expecting, and what you are getting instead? Also, please let us know what the values of all your variables are; not just of $firstName.
Not a fan of Slim on ruby but it looks really neat.
Hmm upon second look, I'm not sure why you use __callStatic and $implementations. Why not just static methods?
I don't get it either. What's wrong with php's templating syntax? If you end up having to put something more complicated in your views you have the full power of php available instead of having to figure out how to do it in $templatinglanguage .
I smell SQL injection vulnerability on your sample.
Well its for an assignment, but i used the realescapekey() function. Doesn't this work against SQL injection?
I don't know which library you use, but realescapekey() is not in the built-in ones...
Sorry, I meant to say realescapeSTRING. This was something my instructor advised us to use.
Which library do you use? EDIT: Also, why do you need "LIKE" in order to look up people by name? And why do you look up people by name and not something hard, like email, or primary key?
In theory, but that'd be an unnecessary FE development nightmare. 
Very impressive. Can't wait to try it out! Very intuitive!
Hm. I've been looking for a templating engine to use for the reactphp framework I'm cobbling together. I might give this a try and see if it's quick enough and allows for caching the resulting php or not.
I would agree with /u/ircmaxell . Generally if you're having to use eval(), you're doing something wrong. It's late and I'm tired, but tomorrow I'll look if there's a better way to do what you're doing and see if I can't submit a pr 
I'm guessing something like the typoscript thing in typo3? It's the stuff of nightmares.
Pretty vague question. You could post the MySQL error you are getting. Do you have error reporting turned on? Try to var_dump($query) before passing it to your database object and running the query in Workbench or HeidiSQL. Unrelated tip: Get a PDO wrapper that provides SQL injection protection. Many also protect again breaking queries with data containing keywords or quotes.
I suppose the argument is that `- unless items.empty` has a much clearer intention than `? items`, especially if you are not familiar with the syntax. Also, losing the `$` in the variable name makes it that little bit more indecipherable. I like where you're going with this, I've been a fan of HAML templates in Ruby, but I still think having a clear intention is important for readable code, and we shouldn't pretend that variables in PHP don't have a prefix.
Mustache has changed the way I code. Even another template engine like blade looks too verbose to me now.
Have you tried running the query directly against the sql database with sample input?
Look for other jobs, and make sure you interview them as much as they interview you before accepting. Most decent employers won't care that you didn't work the same job for years on end, they just want demonstrable skills - and the really good ones just want to know you can learn and solve problems. Also, don't underestimate yourself, I know senior back end dev's that wouldn't know half of what you were talking about above. You're resume/cover letter is just bait to get in the door. It doesn't matter why you made a website, just talk about what you did (like reducing magento page loads :) ) and how you did it. Also (heh, I've been where you are, it's almost uncanny actually, we had senior engineers refuse to implement nginx ssl termination because it was risky) if you can, don't ask for permission, just do it and show them how it works. That's actually got me from "impossible" to in production before.
As we all know it "premature optimization is a root of all evil". Nearly all memory allocation mechanisms are handled by interpreter. You can of course read its source, analyse what it does in a different situations, but it must be a really long running script solving really hard problem to see any difference at all. Of course do know when PHP is copying things and when it is referencing them (for example how foreach() works), but it's kind of a general knowledge, not ancient arcane spells.
I'm actually intending on compiling the templates to pure php, as you can see [here](https://github.com/Evertt/Slade/issues/9). I'll just need some time (and support?) to figure out the best way to do that. :-)
Thanks! I like that you can appreciate it. :-D
Thank you. It was my intention to make the syntax both short and still intuitive. I hope you'll like it. Don't use it in production just yet though, I don't believe it's ready yet.
So far I believe it's really slow. I'm using regex all over the place and I'm not caching anything at all. I'm actually intending on compiling the templates to pure php, as you can see [here](https://github.com/Evertt/Slade/issues/9). I'll just need some time (and support?) to figure out the best way to implement that. :-)
Nice!
&gt;These are issues most of us learned to deal with in our formative years: elementary and middle school. I think it's less learning to have a thick skin as much as learning not to act that way in the first place. It's not that no one thinks "Tommy is a stinky breath". It's that no one would consider it acceptable to say. And just imagine if adults treated each other the way high schoolers do. That would be a special kind of hell. We're just so desensitized to it all it's invisible. It's the baseline. If you said your child drew her first picture and I replied "Crayola crayons are child abuse" most people would think I was a douchebag. But it's par for the course when it comes to tech. (The fact the guy who made the comment is trolling up the comment sections of the article really isn't helping the "it's just a joke" argument either.)
Hmm, then I'm just confused why laravel prefers to use htmlentities over htmlspecialchars. Because I stole that line directly from laravel's code. &gt; You create a lexer/parser. Great idea! So how exactly does a lexer/parser process such things without using regex? I'm sorry I really am still quite an amateur when it comes to these things.
I'll think about it. So would you recommend that I literally copy the syntax `- unless items.empty` ? Or do you have a slightly different suggestion? :-)
Wait! Only do it on a hobby project though! I'm honestly not convinced that my code is production ready. It's slow, it's missing features and maybe I've missed important bugs as well. I would love to receive bug reports and pull requests though so I can fix those issues. :-D
That is not possible. We have allready started the CI3 path.
I don't think you will be able to significantly influence CPU cache usage by how you write your PHP code. As you already said, PHP is too high level for that. However fetching a class or object property into a local variable will likely improve performance for a different (simpler) reason: Looking up a local variable is just a lookup into the CV table followed by a type check. This lookup is inlined into whatever VM instruction requires the variable. Looking up a static property on the other hand requires a separate VM instruction, which (in the fast-path) requires looking up two pointers from a cache table, performing some sanity checks and copying the value of the property into a temporary variable (and incrementing its reference count, which requires another memory lookup). The actual instruction that requires the static property then has to fetch that temporary variable and afterwards destroy it (i.e. usually decrease its refcount). Of course all this will be influenced by cache behavior. The CV table lookup might be more likely cached, because it is located on the VM stack next to other commonly used values. But in the end, it's also just a lot less work that has to be done, even if you do not consider caching.
I would take another approach: Create a *FruitIdentifier* interface which extends Fruit with additional methods like *identifyLeaves* and use this interface as type-hint in your Farmer class methods
Maybe use twig? it has some basic logic, can be customized and even compile into php...
hehe yes. I was kind of expecting a wall of Laravel/Symfony/slim, but there still are some very helpful comments here from people who have CI in production.
My company is a bunch of twats. Rocking Java Swing in the main application. (One customer consumes 3 gigs of ram for every instance of the app they run). The management thinks Java/Swing is ahead of the curve.... soo yeah.
So what do you think of mine? (A)
To be honest in terms of features, integration and extensibility it doesn't really compare with [Glide](http://glide.thephpleague.com/) (maybe it will give you a few ideas).
Yeah I'm afraid so too, but I will give it a shot somewhere next week. :-)
&gt; The only issue I have with templating systems like that is that I don't know, at a glance, what it's doing Totally agree. I don't think the 2nd, templateless example is bad at all. You can read the HTML tags, which are totally at home in a view anyway.
The tricky part in designing a plugin API is figuring out the right extension points. The plugin architecture is a secondary detail.
Of course, Glide is a really awesome tool and it's design to be a powerful image processing system. It give me some ideas to find the difference and maybe adjust my project direction. Thanks for your answer!
&gt; Then you have to worry about hook call order, register, deregister and what not. It seems like a good architecture for handling plugins is to expose your application's event dispatcher to plugins and let them listen for the relevant events. If the OP is using Symfony's event dispatcher component or something similar, it should handle all of that out of the box.
1. You should take a look at the [PHP Package Checklist](http://phppackagechecklist.com/) and follow the steps listed there. 2. If you want to encourage adoption, your code needs to follow the PSR-2 coding standard. This means PascalCase class names, one class per file, and several other things. 3. I always have notices converted into exceptions in my codebases, and IIRC so does every major framework out there. Having your code throw notices is a dealbreaker and casts doubt on it's quality.
Vastly over estimate?
I'm not sure. Can you give me an example of what $statement might look like after the replacement has been done?
Most often devs estimate in much optimistic way, thus about 90% projects exceed the time limit...
Minimize expectations
You're site loaded what was essentially an empty page. Is the trick to not actually build a site at all?
He didn't say this was fool proof, but it wont allow people to type in UPDATE DELETE * FROM db... It's an intro to Php course and we only spent the last 2 weeks on SQL. I'm sure we'll get into more security as the course continues, but thanks for the feedback.
I could suggest you to looking at the Microkernel pattern.
So a line like this: == Form::select('tags', blog.tags) Could change into: Form::select('tags', $scope['blog.tags']);
You'd probably be doing him a favor. No one wants to work with somebody harboring a superiority complex.
It might be really convenient if you were moving a system over from smarty to blade or to twig.
The number of domains I had to temporarily allow in NoScript to get your page to load is too damn high.
WooCommerce isn't absolutely terrible
Amazing how nobody spotted this earlier. 
So, here's the deal. You can't directly remove usage of eval by using preg_replace_callback. I decided to do look at how Laravel does it and they cache their templates as PHP. So the input it parsed and the output is sent to a php file. I suppose you could say that your template engine is no worse since running the PHP as a php document is the same as eval. But I think the primary difference is that the template engine isn't running the code upon compilation of the template, and by doing it that way, there's no way for any recursive compilation. I hope that helps a little. [Here is the compiler used by Laravel](https://github.com/laravel/framework/blob/5.0/src/Illuminate/View/Compilers/BladeCompiler.php)
man, traffic so high... didn't expect as strong audience, but please, stay tuned and try once again in a few days
&gt; really weird behavior by Symfony components Weird usage of Symfony components might be better suited. &amp;nbsp; I can't reproduce this in any Symfony application and [symfony.com](http://symfony.com/xxxx/app.php/services) screams 404, like it should. So this makes me think that its an implementation bug, not an upstream bug (_i.e: it should be fixed in Laravel_).
~~Symfony.com is run on Drupal, apparently, so this doesn't apply. See [PR](https://github.com/laravel/framework/pull/8508) mentioned in the StackOverflow answer.~~ The Symfony.com guys chimed in on the PR and cleared things up.
Avoid Magento like the plague. 
Incorrect. Symfony.com is using the full stack.
Oh. I see they chimed in in the PR. Cheers, good to know
Just of curiosity, on a scale from 1 to 10 (_where 1 = does not worth the trouble and 10 = totally worth it_), how much do you consider this a micro optimization ?
CI is bad because it doesn't use any of the features that have been developed for PHP in the past *eight and a half years*. Would you use a frontend framework that only has features supported by Internet Explorer 7, Firefox 2.0, and Safari 3?
Ok, what is a concrete example of this? What does the CI version look like and what does framework x's version look like? Why is framework x's version better?
I've done this a few times in my career. in general I've found it best to migrate one piece at a time while maintaining the legacy codebase. Once you hit a critical threshold you can just swap the last bits out and then remove the old framework. You can either migrate side-by-side in the same ecosystem or use something like a reverse proxy to have another system handle the "new" version. This is definitely a situation where having good testing helps a ton so you don't break anything.
&gt; I'd argue that Composer is an industry standard and you shouldn't put such load of code just to support people who can't or won't use it. They'll need only to write some require()'s on their part, nothing you should care about. In the end, you're right, I probably shouldn't care. I've taken your comments to heart and removed all the extra stuff the Symfony package had, because you were right - I didn't look closely enough and there was a ton of extra junk in there. But do I still have an extra file? Sure. But by the same token, the presence of a PSR4 autoloader doesn't hurt anyone either, least of all the lowest common denominator. &gt; As for the interfaces, many of them still break ISP as for example your ShortcodeInterface does contain both methods for shortcode state and its handling. That's my general perception that you're still moving parts of the library here and there trying to find right place for it. Apart from the injection of the Manager Instance, I'm not sure I follow where I'm storing any kind of State in the Interface you've listed. You might be confusing the AttributeInterface and getAttributes method with some kind of state retention, but if you look a little deeper, I'm actually using a Shortcode's attributes property to define recognized *defaults*. Not the state of a given instance at a point in time. THAT (meaning content and attributes) is injected into the handle method by the manager after parsing. If I'm wrong, can you expound? You're welcome to make a pull-request as well to better show me what you mean. &gt; Last but not least maybe you remember Shortcode library at https://github.com/thunderer/Shortcode I do. I had politely declined not as a slight to you or an unwillingness to collaborate with other people, but rather to force myself into unfamiliar territory. I'm also sure that you came across this project from my previous post, and that if you remember from one of my original comments, there are a number of "firsts" for me that I'm trying to integrate into my development workflow. I've been developing in C# and PHP for about 6 years now, and I'm at a point now where I am actively seeking new opportunities to take myself out of my comfort zone in an effort to be a better developer. I'm declining not because I think I can do it better, or because I have some kind of objection to your project, but because my personal sense of satisfaction is tied to figuring out things for myself - even if it's from the hard way.
That is very weird, because I thought the Laravel Routing is 100% from Symfony2 HttpFoundation/Routing. So the bug you're describing would be in any Symfony2 App too? Which version are you running?
What is the reasoning behind switching frameworks? Is the app currently working and functioning in the current framework? **EDIT** Short answer is DON'T, unless you have a damn good reason for *needing* to switch to the new framework.
I don't have a Symfony app to test it on, but on a Laravel 4.2 app, I create a folder inside public called "xyz", and also add a route for "xyz" in routes file, and it gives the error: This webpage has a redirect loop ERR_TOO_MANY_REDIRECTS I mean it makes sense, if you were trying to link to assets in the public folder and the names conflict with a route... but it is still weird.
http://cmf.symfony.com/foo/bar/app.php/news Edit: This was posted by user lukasgeiter on the referenced [PR](https://github.com/laravel/framework/pull/8508), just to clarify that I didn't personally find this.
Not only is it an advertisement, it doesn't actually say anything. There's no practical advise in this article beyond vague discussions about writing good documentation (which takes time, and when it's skipped, it's usually precisely to meet a deadline), and choosing an open source license (which you usually aren't doing when building an ecommerce platform). The "case study" doesn't actually name a client, and it rattles on about creating an "open source library" which it then can't name. And the one screenshot of source code just demonstrates they don't actually code in English.
Found this: http://stackoverflow.com/questions/4614147/uploading-a-file-larger-than-2gb-using-php but I can't say how useful it is since I've never attempted anything like it myself.
depends on how your htaccess/vhost/whatever is set up. with rewrites, usually you tell apache to check if a file exists first, before forwarding to the framework.... So this isn't really that weird.
So why does it give an infinite loop instead of just serving the file? 
Security, performance. The existing framework is deprecated outside of security fixes, and our app architecture sorely needs modernizing (we're not even using composer!)
[Not an article, but related.](https://news.ycombinator.com/item?id=9414235)
Taking the '2' out would be a more fair comparison: https://www.google.com/trends/explore#q=codeigniter%2C%20symfony&amp;cmpt=q&amp;tz= Doesn't show that much of a trend towards Symfony, but there is a tiny uplift.
It's weird that it doesn't just resolve to one or the other. But, then again, I'd rather get an error to save myself some headaches down the line.
So is this a security issue? I see that it's a bug, but not much of anything else.
It changes their hashes. Because hash is based on previous commits. So if someone has the same commits locally, you push this tree and they pull it, they'll run into issues. But as long as you're the only person working on a branch or you have not pushed those commits yet, this is perfectly fine.
We had the same behavior in sabre/dav as well, for the same reasons but realized it could in fact cause some major security issues. Say if the url was actually representing some kind of REST service and you are issuing this HTTP request DELETE http://example.org/foo/bar We are deleting `/bar`, right? Now imagine if the user had control over the naming of `/bar` and they actually called it `index.php`. The same delete: DELETE http://example.org/foo/index.php is now treated as a `DELETE` to the root of the application. This is just one example. In our case people were deleting entire directory trees when they intended to delete a single php file. This was fixed a long, long time ago though.
But.. but its the symfony thing now, ain't it? 😊
Launch a vm and test it out. 
Looks pretty good, actually signed and and have started testing this for my app. www.asknice.ly I have been very tempted to build an admin for tracking detailed events, but when you are a startup time is critical. Would love to know more about it. P.S. I would suggest you show a better example of doing an async request using curl eg. I have stolen this from some other friends at Raygun.io git repo for PHP. The code is not complete but you get a very very good idea how to make your requests async without having to wait for Understand.io to complete the command, hence non blocking. $curlOpts = array( "-X POST", "-H 'Content-Type: application/json'", "-H 'X-ApiKey: " . $this-&gt;apiKey . "'", "-d " . escapeshellarg($data_to_send), "--cacert '" . realpath(__DIR__ . '/cacert.crt') . "'" ); if ($this-&gt;proxy) { $curlOpts[] = "--proxy '" . $this-&gt;proxy . "'"; } $cmd = "curl " . implode(' ', $curlOpts) . " 'https://api.raygun.io:443/entries' &gt; /dev/null 2&gt;&amp;1 &amp;"; exec($cmd, $output, $exit); return $exit; 
Well, there really aren't that many different ways to store nested data in a relational database. [This](http://mikehillyer.com/articles/managing-hierarchical-data-in-mysql/) is a great article on MySQL and [nested set](https://en.wikipedia.org/wiki/Nested_set_model).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Nested set model**](https://en.wikipedia.org/wiki/Nested%20set%20model): [](#sfw) --- &gt; &gt;The __nested set model__ is a particular technique for representing [nested sets](https://en.wikipedia.org/wiki/Nested_set) (also known as [trees](https://en.wikipedia.org/wiki/Tree_(data_structure\)) or [hierarchies](https://en.wikipedia.org/wiki/Hierarchy)) in [relational databases](https://en.wikipedia.org/wiki/Relational_database). &gt;The term was apparently introduced by [Joe Celko](https://en.wikipedia.org/wiki/Joe_Celko); others describe the same technique without naming it or using different terms. &gt;==== &gt;[**Image**](https://i.imgur.com/PF93HH2.png) [^(i)](https://commons.wikimedia.org/wiki/File:NestedSetModel.svg) --- ^Interesting: [^Hereditarily ^finite ^set](https://en.wikipedia.org/wiki/Hereditarily_finite_set) ^| [^Subgenomic ^mRNA](https://en.wikipedia.org/wiki/Subgenomic_mRNA) ^| [^Joe ^Celko](https://en.wikipedia.org/wiki/Joe_Celko) ^| [^Hierarchical ^database ^model](https://en.wikipedia.org/wiki/Hierarchical_database_model) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqo2vdf) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqo2vdf)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Nested set model**](https://en.wikipedia.org/wiki/Nested%20set%20model): [](#sfw) --- &gt; &gt;The __nested set model__ is a particular technique for representing [nested sets](https://en.wikipedia.org/wiki/Nested_set) (also known as [trees](https://en.wikipedia.org/wiki/Tree_(data_structure\)) or [hierarchies](https://en.wikipedia.org/wiki/Hierarchy)) in [relational databases](https://en.wikipedia.org/wiki/Relational_database). &gt;The term was apparently introduced by [Joe Celko](https://en.wikipedia.org/wiki/Joe_Celko); others describe the same technique without naming it or using different terms. &gt;==== &gt;[**Image**](https://i.imgur.com/XmQBoVw.png) [^(i)](https://commons.wikimedia.org/wiki/File:NestedSetModel.svg) --- ^Interesting: [^Hereditarily ^finite ^set](https://en.wikipedia.org/wiki/Hereditarily_finite_set) ^| [^Subgenomic ^mRNA](https://en.wikipedia.org/wiki/Subgenomic_mRNA) ^| [^Joe ^Celko](https://en.wikipedia.org/wiki/Joe_Celko) ^| [^Hierarchical ^database ^model](https://en.wikipedia.org/wiki/Hierarchical_database_model) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqo2vu2) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqo2vu2)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Unless it's for some intranet stuff I wouldn't try to do single file uploads of 2gb over the internet. Maybe have a look at something like AWS S3 multipart uploads. You could then use javascript to split up the file into smaller chunks, allow the user to resume the upload should it fail halfway and store the file somewhere with (probably) more redundancy than your server.
Granted that should not happen, so it is a bug in HttpFoundation (_ref: [PR #14335](https://github.com/symfony/symfony/pull/14335)_), but because this problem occurs in certain conditions (_i.e: rename the entry point_) it could also be considered as an implementation bug. &amp;nbsp; Anyway, it will be better to fix this in HttpFoundation, because it looks like other people are not very receptive to bug reports, which raises questions about their level of professionalism.
I've had greats success in the past with the modified preorder tree traversal algorithm. http://en.wikipedia.org/wiki/Tree_traversal
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Tree traversal**](https://en.wikipedia.org/wiki/Tree%20traversal): [](#sfw) --- &gt; &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), __tree traversal__ (also known as __Arkiletian tree search__) is a form of [graph traversal](https://en.wikipedia.org/wiki/Graph_traversal) and refers to the process of visiting (examining and/or updating) each node in a [tree data structure](https://en.wikipedia.org/wiki/Tree_(data_structure\)), exactly once, in a systematic way. Such traversals are classified by the order in which the nodes are visited. The following algorithms are described for a [binary tree](https://en.wikipedia.org/wiki/Binary_tree), but they may be generalized to other trees as well. &gt;==== &gt;[**Image**](https://i.imgur.com/z2u4h58.png) [^(i)](https://commons.wikimedia.org/wiki/File:Sorted_binary_tree_preorder.svg) --- ^Interesting: [^Nested ^set ^model](https://en.wikipedia.org/wiki/Nested_set_model) ^| [^Infix ^notation](https://en.wikipedia.org/wiki/Infix_notation) ^| [^Graph ^traversal](https://en.wikipedia.org/wiki/Graph_traversal) ^| [^Micromouse](https://en.wikipedia.org/wiki/Micromouse) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqo3ci9) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqo3ci9)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
True true, but in a round about way (for absolute beginners) it's kind of what happens. The server interprets the php code inside the tags and outputs the html to the browser. The basic videos are for people who really are new to php coding, but perhaps you're right and i need to explain it fully at the beginning..? I'll work on my scripts :)
Nested Set can get pretty hairy in practice. Especially when working with large amounts of data. Updates are very slow unless you always append in the tree. Try for an implementation of [Closure Tables](http://stackoverflow.com/tags/transitive-closure-table/info) instead
Sorry but there is no other action to reasonably take. It's a Symfony bug apparently as has been shown by links to Symfony sites with the same bug. Also there are over 7,600 closed PRs on Laravel. Perhaps 0.01% of those contain a terse response?
I never publicly "flipped my shit on him". Also I didn't dismiss his issue. I said I would consider what to do but didn't consider it (still don't) a very pressing security concern since Laravel is secure by default on this scenario. After I said I would consider it he sent off a public email to a security list disclosing everything which I consider a huge no-no when discussing security things with a project maintainer that said they were considering what to do and had not decided yet.
Hard to put in a reply, but it mainly boils down to everything Paul says in [his book](http://mlaphp.com/) ([review](http://www.sitepoint.com/modernizing-legacy-applications-php-review/)). Go step by step, identify stuff that can be incrementally improved, and treat your old framework like legacy code. We had a whiteboard where we flagged every smelly part of code which could not just be taken out and injected into the DI of the new framework. We then focused on that one part until we made it extractable and package-able. This produced a bunch of services in the end, some of which we Phared and even sold (as for example with the rule powered state transition machine). A very important thing to note is that the old project is getting **abandoned**. You cannot support or even bugfix the old one while working on the new one - you'll notice some bugs and fix them implicitly while refactoring, _sometimes_ allowing for a quick backport into legacy, but unless you can dedicate a separate person or team to do maintenance of the old system while you work on the new one, you'll miss the deadline by an even larger margin. Don't assume it can be done, we did this mistake the first time around.
Dude... You don't help yourself by being defensive...
Do you have control of the front end uploader? I use PLUpload on the front end and it has an awesome chunking feature. 
Asking such a non specific question in StackOverflow is calling for downvotes. I feel for you bro.
I was kind of expecting that, but I'm okay with it. Nothing ventured, nothing gained. :-)
use an authentication library
I can't stand Weird Al either. At least I'm consistent ;)
Are you sure you want to write your own? You might be able to leverage existing code. Take a look at this article by [Jonathan Wage](http://jwage.com/post/31623163785/writing-a-parser-in-php-with-the-help-of-doctrine).
I wish I kept my notes from university, we covered stuff like this (creation of parsers and compilers) using JavaCC. I built a very simple version of BASIC :p First write your grammar out using BNF. Once you've defined the grammar, you can use a parser generator to do the hard work of creating a parser based on the grammar. Perhaps tools like ANTLR or JavaCC support PHP output, I'm not sure. Edit: looks like Antlr only supports Java, C#, JavaScript, and Python. Perhaps there's a similar project that supports PHP though. 
Thanks for the info, you were spot-on with your example :) I have a ton of static class variables floating around, and I wondered if it'd be worth it to redeclare them as local variables in the function that contains the server loop. Thanks again for the thorough explanation :D
If your goal is to learn and make your own, look for a copy of [Language Implementation Patterns](https://pragprog.com/book/tpdsl/language-implementation-patterns). While the examples are in Java, it nicely breaks down how certain types of language feature can be handled by corresponding chunks of logic. The author is the main guy behind ANTLR.
I wanted to learn new things. 
&gt; Asking such a non specific question in StackOverflow is calling for downvotes. &gt; Because SO is meant for specific questions. This is a poor question for the site and the community, because there's no real good answer to it. The answer is basically "learn about parsers, since there are tradeoffs involved". And time and time again we've seen those style questions degenerate on SO. Hence why the downvotes. In short, it's hard to trivialize incredibly complex subjects the way the question does, hence it's incredibly hard to answer the question in a way that is generic enough to make sense for SO...
&gt; Well, there really aren't that many different ways to store nested data in a relational database. This is a great article on MySQL and nested set. While I'd recommend nested sets too, there are actually countless ways to represent nested data in a relational database. 1. You can store node path in a varchar ("materialized path"). 2. You can store node:node_ancestor in a separate M:N table. 3. You can store node:node_child in a separate M:N table. 4. You can have a parentId column (more and more RDBMS support recursive queries today, including sqlite). 5. Nested sets, of course. 6. You can store lists of ancestors, children in JSON columns, or even whole trees in JSON columns (you can argue that's not relational, and it's not, but it's well supported in say PgSQL). And the reason the different ways are countless is because you can combine the above 6 approaches (and I'm missing some I bet) in many ways to achieve hybrid solutions. Any scalable solution would in fact be a hybrid, because nested sets are relatively easy to query against, but are kinda expensive to update (add, remove children, move subtrees etc.)
http://www.plupload.com/index.php
To answer the actual question rather than complain about SO... start with [BNF](http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form) and fix the ambiguities in the grammar that ircmaxwell pointed out. Maybe the [CSS grammar](http://www.w3.org/TR/CSS21/grammar.html) will help?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Backus–Naur Form**](https://en.wikipedia.org/wiki/Backus%E2%80%93Naur%20Form): [](#sfw) --- &gt;In [computer science](https://en.wikipedia.org/wiki/Computer_science), __BNF__ (__Backus Normal Form__ or __Backus–Naur Form__) is one of the two main [notation techniques](https://en.wikipedia.org/wiki/Metasyntax) for [context-free grammars](https://en.wikipedia.org/wiki/Context-free_grammar), often used to describe the [syntax](https://en.wikipedia.org/wiki/Syntax_(programming_languages\)) of [languages](https://en.wikipedia.org/wiki/Formal_language#Programming_languages) used in computing, such as computer [programming languages](https://en.wikipedia.org/wiki/Programming_language), [document formats](https://en.wikipedia.org/wiki/Document_format), [instruction sets](https://en.wikipedia.org/wiki/Instruction_set) and [communication protocols](https://en.wikipedia.org/wiki/Communication_protocol); the other main technique for writing context-free grammars is the [van Wijngaarden form](https://en.wikipedia.org/wiki/Van_Wijngaarden_grammar). They are applied wherever exact descriptions of languages are needed: for instance, in official language specifications, in manuals, and in textbooks on programming language theory. &gt; --- ^Interesting: [^Extended ^Backus–Naur ^Form](https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_Form) ^| [^Augmented ^Backus–Naur ^Form](https://en.wikipedia.org/wiki/Augmented_Backus%E2%80%93Naur_Form) ^| [^Molecular ^Query ^Language](https://en.wikipedia.org/wiki/Molecular_Query_Language) ^| [^John ^Backus](https://en.wikipedia.org/wiki/John_Backus) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqokykb) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqokykb)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Call me stupid but I have used PHPstorm for over a year now and never noticed that Ctrl + S saves all files instead of just the one I am working in. I am too used to pressing Ctrl + S in every file as I edit it. This does not answer your question but it just shows how little influence the lack of this feature has on my behavior as a developer :D 
For those using Debian, I'd recommend using the Dotdeb repo instead of the "stable" repo. Due to the feature freeze, Jessie is already a release behind. Guillaume runs a tight ship at Dotdeb, and is always on top of new releases! Link: https://www.dotdeb.org/instructions/
Save button? What year is this?
But .. but .. PHPStorm is autosaving, why are you ... using Ctrl + S ?
you are very correct, dotdeb is awesome, unfortunatly we can't use it and I know a lot of people are stuck with the official repo too
I agree with /u/AlpineCoder that the proper solution here is object composition. You may use DI (inject in constructor, setter), or not (create Encoder directly in the object), but using a trait for this feels unwarranted. When using traits you not only are hard coupled to the encoding code in a way that's harder to refactor later, but also run a risk of property and method name collision, because traits stuff everything at the same object level. And why? So you can call $this-&gt;encode() instead of $this-&gt;codec-&gt;encode(). It doesn't seem like a great win. I use traits mostly for three things: 1. I need reusable object-level proxy methods that expose functionality from an object I hold inside (i.e. trait Foo { abstract protected getBar() {} public function serveBeer() { return $this-&gt;getBar()-&gt;serveBeer(); }}). 2. I need default methods in an interface (class Foo implements Bar { use BarDefaults; }). 3. The code I need to reuse *requires* to be at the using object's scope (for example reusable __get, __set, __call and so on functionality).
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Cross-cutting concern**](https://en.wikipedia.org/wiki/Cross-cutting%20concern): [](#sfw) --- &gt; &gt;In [Aspect-oriented software development](https://en.wikipedia.org/wiki/Aspect-oriented_software_development), __cross-cutting concerns__ are aspects of a [program](https://en.wikipedia.org/wiki/Computer_program) that affect other [concerns](https://en.wikipedia.org/wiki/Concern_(computer_science\)). These concerns often cannot be cleanly [decomposed](https://en.wikipedia.org/wiki/Modularity_(programming\)) from the rest of the system in both the design and implementation, and can result in either *scattering* ([code](https://en.wikipedia.org/wiki/Source_code) duplication), *tangling* (significant dependencies between systems), or both. &gt;For instance, if writing an [application](https://en.wikipedia.org/wiki/Application_software) for handling medical records, the indexing of such records is a [core concern](https://en.wikipedia.org/wiki/Core_concern), while [logging](https://en.wikipedia.org/wiki/Data_logging) a history of changes to the record database or user database, or an authentication system, would be cross-cutting concerns since they touch more parts of the program. &gt;==== &gt;[**Image**](https://i.imgur.com/SKUHkbr.png) [^(i)](https://commons.wikimedia.org/wiki/File:AspectWeaver.svg) --- ^Interesting: [^Tracing ^\(software)](https://en.wikipedia.org/wiki/Tracing_\(software\)) ^| [^Concern ^\(computer ^science)](https://en.wikipedia.org/wiki/Concern_\(computer_science\)) ^| [^Aspect ^\(computer ^programming)](https://en.wikipedia.org/wiki/Aspect_\(computer_programming\)) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqom405) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqom405)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Alternative solution: class PhalconControllerAdapter extends \Util\PhalconController { public function __construct(GenericController $controller) {...} } class SlimControllerAdapter extends \Util\SlimController { public function __construct(GenericController $controller) {...} } // For maps: $phalconMaps = new PhalconControlerAdapter(new MapsController()); $slimMaps = new SlimControlerAdapter(new MapsController()); Now you no longer need to create two *extra* additional classes for every real controller class and 2/3 of your classes can be removed from your codebase.
thks everybody for these intersting points of you and advices. I have not really found a existing library like I wanted. So I created something very simple. https://github.com/Raphhh/balloon Do not hesitate if you want to provide feedback! :) 
Force of habit! :D 
Where I work we use a base of stable with apt preferences for certain packages in our web stack to be pulled from unstable / testing. While this occasionally causes some weird update behavior because every now and then a new dep will need to be pulled from unstable or testing because the one in stable is not enough, overall it's been very successful.
That's horrible.
Are you talking about PSR-1 and PSR-2? [PHP_CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer) has both [PSR-1](https://github.com/squizlabs/PHP_CodeSniffer/blob/master/CodeSniffer/Standards/PSR1/ruleset.xml) and [PSR-2 rulesets](https://github.com/squizlabs/PHP_CodeSniffer/blob/master/CodeSniffer/Standards/PSR2/ruleset.xml), [among others](https://github.com/squizlabs/PHP_CodeSniffer/tree/master/CodeSniffer/Standards). Not online, admittedly, but it's relatively easy to integrate into pre-commit hooks and the like.
Me know too. I just hit Ctrl+S after basically everything , sometimes even in webpages
version control? You can turn off auto save, and have it show an asterix next to unsaved files too.
It's denormalized information, so hard to update and hard to search. It only hardly allows polyhierarchy (one item with multiple parents). You cannot use fast index search with it.
Here I build starter app using slim, twig and eloquent while ago, but doesn't have any time to play with it again recently https://github.com/xsanisty/SlimStarter/ 
I wrote my first draft of a grammar file for my templating engine: [http://devign.nl/grammar.ebnf](http://devign.nl/grammar.ebnf). Would you like to tell me if I'm on the right track? And maybe help me a bit on how to convert those regexes to proper EBNF code? So far the draft should describe the grammar of this: css: body { color: #333; } and: html body.some-class #some-id attr1="something literal" attr2=true attr3=variable.name table tr: td As you can see elements can also be nested by a colon, instead of indentation To see an example of what features are included in my template language you can see this example, though this doesn't show all features. [https://github.com/Evertt/Slade#example](https://github.com/Evertt/Slade#example)
&gt; Yeah I guess the decorator pattern in cleaner, although phalcon controllers do instance themselves when a route is matched, and in that process they inherit access to the app's DI. If your Phalcon router directly instantiates classes from just their name, that's a limitation of the framework you use, and it does indeed pretty much force you to have classes declared that are empty shells combining statically other code. That'd be unfortunate. A sensible design would allow you to use a factory (a simple closure, say), as instancing a controller is not a responsibility of the router in the first place. It shouldn't be the responsibility of the router to do DI for your app either. Phalcon is simple to the point it makes your code more complex than it has to be. The sequence in my apps is (very) roughly this: // Returns matched route. Doesn't call anything $route = $router-&gt;route($request); // Opportunity to instantiate the controller with custom logic, using the info supplied in the $route. $controller = new SlimAdapter(new $route-&gt;className()); // The dispatcher runs the filters, controllers, views. $dispatcher-&gt;dispatch($controller); &gt; By the way, you're declaring two classes as well, so I'd still have the same number of classes in the end. In your case you have 3 classes per controller = ctrl * 3 = 1 * 3 = 3 classes/traits In my case I have one class per controller and 2 universal adaptor classes = ctrl + 2 = 1 + 2 = 3 classes/traits So yes, same number of classes. Now let's imagine a *real project with 10 controllers per framework:* - Yours: 10 * 30 = 30 classes/traits - Mine 10 + 2 = 12 classes/traits 
Get off your high horse. If you have any experience maintaining a large open source project you will realized the what the maintainer have to deal with on a daily basis.
What's a potential use-case for this? Recording analytics for a non-browser endpoint like an API?
Ok, yeah, I get it now. But, as I told you, Phalcon is a bit rigid in that aspect. It will look for xController in xController.php, leaving me no room to instance it with your adapter. My aim is to leave these controller mocks wherever Phalcon expects to find one, and then use a trait to fill its shell with my own logic. It turns out it was easier to make Slim act as Phalcon than making Phalcon act unopinionated. But it might be just me not knowing enough Phalcon to do it. Phalcon does a lot of magic routing whereas Slim expects you to declare the routes not on the Route object but instead directly in the App object. Perhaps I should use your idea to declare two routing adapters, one extenting from `\Phalcon\Mvc\Router` and the other from `\Slim\Router`, and make them decorate a common route logic without implicit magic nor mixing of concerns.
Thank goodness it isn't what I thought it was. I thought it was PHP rewritten in Javascript. Phew phew.
As a sysadmin I like this.
Mind sharing why?
 I thought it was going to be an updated version of http://quercus.caucho.com/ - but I guess it's different if it's instead a compiler to JVM bytecode, rather than a container. &gt; Features &gt; Using java libraries and classes in PHP code. This is the most interesting bit - after 3 minutes of searching, I couldn't see any documentation on it. Is this actually implemented? &gt; Features &gt; Unicode for strings (UTF-16, like in Java) You have chosen......poorly.
Eh, even if it doesn't get everything, it gets you 99% of it in a form that's fairly formal and other people can easily understand. It's a shame if it doesn't get all of it. Can you link to what you found about a "hack" for it?
Is there support for structs? Does the project has static typing available (for heavy calculations)? I'm a Java beginner, so I guess the answer is to create a Java library on my own, so I can import the classes in PHP mode.
JPHP supports only original language features. If you want to import java classes, you need to implement a wrapper class https://github.com/jphp-compiler/jphp/wiki/For-Contributors
Ok thanks, I'll check it out.
There's many ways to skin a cat. Code quality and maintainability are the important thing. I'll take a well written Python application over a poorly written PHP one, and vice versa. I think bashing another language is more about members of a "community" waving their dick around trying to fit in. It's human nature to have a rival/enemy to unite against as a group.
I was loading namespaces incorrectly, now it is fixed. About the extensions guide, that's exactly what I was looking for. Thanks!
I was expecting Japanese PHP
I'd like to see some benchmarks for this.
I meant that in ShortcodeInterface you have both method `getName()` which is for information about shortcode state and `doShortcode()` which is related to its processing. I read your code once again and I think that what you're calling "shortcode" is actually its handler, maybe that's me being picky but still I think that data containers and "actions" should be separated. Consider wrapping shortcode "data" (name, parameters, etc.) in separate object, it'd be much more readable (and yes, I did exactly that in my code). Thanks for explaining reasons behind your decision, I didn't know that it's for learning purposes. I wanted only to note that if this project is not used by you in any real-world projects you should note that in README. You got some stars on GitHub for this code which means people liked it, but still, responsible project ownership is about clearly stating what it is all about. If you actually use and plan to support it then everything is okay.
Eh, doesn't matter if it's python or not. Just define something called "indent" and "dedent" (which you can't actually define in EBNF), but the document will still be easily human-readable. Then you just need to find a way of detecting them in the document.. You *might* even want to fall back to regex for this part. Or just keep track of the spaces at the start of the line as you tokenise each one, and then insert an indent/dedent token as the amount changes..
Me too. JPHP reminded me of JRPG.
I thought it was going to be a Jewish PHP where every token is in Hebrew except T_PAAMAYIM_NEKUDOTAYIM which would confusingly be named T_DOUBLE_COLON. This is much better.
Oh, so its safe to do as long as you haven't pushed your local commits?
the font on the page is somehow screwed here and there
you don't always get to decide what software you use depending on your work environment, in our case we have a security team (I've never met any of them in RL) and they decided that we can only use Debian stable and it's official repo.
Thanks for the feedback! You can log *anything* because it accepts json. We've started off with Laravel because that's what we know best (and needed/wanted to scratch a few itches), and we'll grow it from there. One of the big downsides of most automatic log services is that the data is just sent as a plain string, and that really inhibits the ability to really search your data. Our Laravel service provider is a super easy way to get some real insight into your log data (like getting line numbers, file names, paths, request ID, user ID, etc). But yeah, send us json and we'll eat it all up :)
it's not what i thought it was. i assumed it was a PHP parser for javascript. then i could run server side javascript and client side PHP.
Good luck. You aren't the first to try this. The most successful is Quercus. They stopped updates a year ago. If you don't need any modern features, it performs quite admirably. http://quercus.caucho.com/
The twitter login asks for permissions to post tweets 'for' me....
Well, it's easier for apps to maintain state between requests when they don't die. You can have variables that aren't destroyed at the end of each request. It's also easier to share state/data between each request. Often times PHP devs have to use some kind of shared memory or service (memcached/redis) to accomplish the same thing. The downside to this approach is lost scalability. One of the reasons PHP scales so well is because nothing is shared or kept between each request.
Hamsandwich.io. JS developers tend to scoff at accurate or descriptive names.
[Github's language statistics](https://github.com/facebook/hhvm) suggest it's mainly written in C++.
The decision to use Debian stable and the official repo has nothing to do with PHP. We did ask to be able to either use dotdeb or install php from source, both were rejected. The security guys are like gods in corporate environment (20k+ employees).
Frameworks in other languages do the core setup (eg. routing rules) only once when the app starts, so you only incur that performance penalty once. PHP needs to do that for every single request. 
Because that's the only way strict types can work in the PHP world. Otherwise you'd be forcing people that use your code to use strict types. Also, why does it matter _to you_? You declare all your code strict and you will get whatever it is you ask for, `string`s, `int`s, `bool`s, `MyAwesomeClass`. Anyone using your library can choose to not use strict mode and go about their merry way.
&gt; Otherwise you'd be forcing people that use your code to use strict types. Uh, yeah, no shit. That's the point. Just like when I add a method to an interface, I'm forcing them to define that method. Strong type hinting is a contract, and we're allowing that contract to be broken. &gt; Also, why does it matter to you? Literally my entire first comment was me explaining why it's important to me. We wouldn't have `declare(strict_types=1);` if this wasn't important to people. Some people don't want type conversions. When they type hint for a string, they want a string. Accept that, and move on.
Interfaces enforce a contract, not a coding standard. Strict types is not a contract to external files. It is set on a per-file basis. To you, the library developer, it doesn't matter what the end user uses. Your library will get whatever it is you're asking for. Let me repeat that, because you seem to be missing the point **Any code that declares strict types will always get the types they are asking for.** &gt; Some people don't want type conversions. When they type hint for a string, they want a string. Accept that, and move on. If you want a string in your library, type hint it as a string and you will always get a string.
yes, sometimes client's aren't mature... that's why we have to educate them a little :)
it's just icing on the cake :)
right
Dude, if you're not going to read what I said, then don't reply. The other guy already made your arguments. I've made counter arguments that, like the other guy, you're not addressing. So seriously, for like the 5th fucking time, why do you think have the strict_types operator, or strict comparisons `===`, if type conversion was always acceptable behaviour? The answer is it's not. Performing automatic type conversion is not always the desired behaviour, which, in case you haven't figured it out by now, is the reason the strict_types operators added to the RFC. Ill say it one more time to make sure it sticks: automatic type conversion is not always acceptable. That's why strict_types was added. Just because you don't understand why anyone would want strict type checking, without conversion, doesn't mean anything.
About damn time! Debian is awesome, and I appreciate the point of each release is to be extremely stable, but they really need to work on a new repository for STABLE upgrades. Moving from PHP 5.3 to 5.4, 5.5, 5.6 or 5.7 would not be considered a bleeding edge, experimental or unstable upgrade, yet it was completely ignored by Debian's core repos. You shouldn't need to rely on adding extra repos for stuff like this.
And the difference between "an integer that's been converted to a string" and a string is... nothing. In fact, you wouldn't even be able to tell. And to your function you don't need to care. Why do you care what it was originally? If you don't want type conversions in _your_ code, make sure everything is strict and you're done. But you have no say over how anyone else writes their code when it comes to type hinting, and once again, so long as your code gets the type you want, you don't need to care. From your point of view, it doesn't matter and it can never matter. You have a string, do with it as you will. I've worked with many languages that are strongly typed, but this is the only language (AFAIK) that has to work _both_ with strongly typed code and weakly typed code. Without supporting both, all existing PHP code would need to be re-written strongly (if that's the way the developer wanted to go). This way, file by file can be changed. &gt; No kidding, and I'm asking why. Read the RFC. Search the internet. It has been talked about to death. I honestly think you haven't read up on how this is implemented because everything you have said is either flat out wrong or irrelevant and has all be discussed countless times here, the PHP mailing list and across countless blog posts.
3) Know your limits?
&gt; I think the webstack only has limited workers Yes it does, but *why*? It limits the number of processes or threads that are used *in order to scale the way the authors intended*. Think about that for a minute ... It's cool that you can run something in the "background", but beware that this disrupts the machines ability to perform as a web server optimally at scale. These "background" processes are not background in any real sense, they have the same priority as any other process. They are expensive to create and tear down, very expensive. If you're looking for a rule-of-thumb, and I think you are, then let it be "offloading work to another process is only a good idea if you did not create that process, or if that process can be reused". Software like Gearman is great, it does allow you to offload to a process you did not create, that will be reused. There are other solutions to the same problem, but what you are doing now is not going to scale well. Change now while things are relatively simple would be my advice.
I'm not really sure what your point about `===` is supposed to be because that is completely unrelated to this. `==` and `===` are around because the end user needs to know, e.g. if `strpos()` is returning `0` or `false` because PHP is weak. `strpos()` doesn't care if you pass it `1` or `"1"` for the offset though, and with PHP7 it won't even matter because `strpos()` will _always_ see it as `1`. You've gone on and on about how your code cares about what (type) it was passed from the end user but you haven't yet actually given an example where, as a library developer, you care how it was passed to your function. Why do you, as the library developer, care if they passed it as a `1` or as `"1"`? How could that _ever_ alter what your program does? In your function you would all ever see it as whatever type you hinted it as (`string` or `int`). &gt; strict typing because it doesn't seem important to you Important? Probably not, but I'm super excited to have it in the language and being able to use it. STH is a great addition. You seem to be against it because of some weird notion that you should have any say into how a parameter is passed into your function, when all you actually should care about is what type your function is actually dealing with. Read Anthony's blog post - http://blog.ircmaxell.com/2015/02/scalar-types-and-php.html - and actually see how STH works.
&gt;== and === are around because the end user needs to know, e.g. if strpos() is returning 0 or false because PHP is weak Oh, that's interesting. So if I define the method `setPos(int $pos)` it just *might* be important that PHP doesn't automatically convert a boolean value to an integer. It just *might* be important for the caller to check for Boolean false before passing a non-integer to the method, and if they don't an error should be raised to catch that bug. Weird. It's almost like strict type checking serves a legitimate purpose. &gt; You seem to be against it because of some weird notion that you should have any say into how a parameter is passed into your function You seem to think PHP doesn't make mistakes when doing type conversions. It does, and that's one of the reasons we strict comparisons like `===`, because you can't always trust PHP to do the right thing. &gt;Why do you, as the library developer, care if they passed it as a 1 or as "1"? Because the person who is going to be using the library the most is *me*, and I want strict type checking. Now instead of doing something reasonable, like allowing me to declare my method as strict *in one file* (where the method was defined), I have to instead put `declare(strict_types=1)` in every single file where the method is called. Does that sound like a reasonable approach to you?
That's fine, but personally I disagree. One of the things about strict typing is it leads to fewer bugs. Partially because of IDE and compiler reinforcements, but also because it forces the developer to think about what they're doing. PHP could use a good hefty dose of that. The language should be evolving into a language that forces the developers to think about what they're doing. While it's true bad code can be written in any language, it's a little harder to do in other languages. Precisely because they enforce some good practices.
&gt; That's the point. That's not the point though. The point is to specify that your method will only accept a given type - be that an integer or whatever so that you can do away with a pile of defensive manual type checks and better reason about YOUR code. And in fact the type you request is all your method DOES accept... strict or weak caller mode doesn't even enter into it. Think of it like the default behaviour being that the engine does an implicit cast... so in your ideal world where the caller is required to pass a variable of a given type they would need to do something like this: $someInstance-&gt;someMethodAcceptingAnInt((int) $someVar) Except in weak mode, the cast is entirely implicit. The cast is still (as I understand it) still completely there - your code actually receives a bona fide integer (assuming it's castable under PHP's casting rules) - your code is in fact utterly unaware of the fact that the cast even occurred. I'm struggling to think of a case where it would be beneficial to you to enforce the strict type on a user of a library you have written. I'm happy to be persuaded if you have an argument, but I just can't see it. I can completely see the advantage of enforcing strict types on code that you own and manage, but for code which uses your code, why would you even care? At the boundary between your code and theres nothing is different from your code's point of view. It literally never even sees the difference. Whats more, if PHP's new scalar type hinting worked the way that you suggest it should it would constitute a massive and perhaps insurmountable BC break. Think about it... Project A deals with PHP's rather permissive type juggling rules, and depends upon a library from Project B. Project B decides that it's going to enforce strict typing... with a simple composer update Project A is suddenly broken and forced to make changes for no reason other than to satisfy a requirement imposed upon it by a third party library that actually doesn't need to care what a consumer is doing. 
Any idea for coding a library / Class / PHP component to show off my coding skills ? The few ideas that came to mind: 1. Some kind of responsive HTML generator using GRIDS- This maybe far too frontend'ish. I more of a backend guy 2. Timer Class to time things. Too easy I think.. Any other suggestions please ?
&gt; strict or weak caller mode doesn't even enter into it I'll point you to my comment [over here](http://www.reddit.com/r/PHP/comments/33z69v/comparing_the_php_7_and_hack_type_systems/cqq32kr). There are times when the function should care, and I still have to write defensive code even though I've already gone through the trouble of adding strict type checks. &gt;$someInstance-&gt;someMethodAcceptingAnInt((int) $someVar) Yes! That's exactly what expect the caller to do. I expect them to make a conscience decision in how the casting will be handled instead of leaving it up to the language to decide. &gt;I'm struggling to think of a case where it would be beneficial to you to enforce the strict type on a user of a library you have written You're kind of looking at this all wrong. It's not about my functions. It's about the language. I'm asking whether the feature, as implemented, is beneficial to the language, or does it give more ammo to the PHP haters? Should we force devs to make better choices? I think so. I said this in another comment, but the person using my library the most is going to be me, and I want strict type checking. The way this feature is being implemented forces me to put `declare` statements in every single one of my files instead of only on the file where the function is defined.
I still think I can keep doing this for some time before moving to RabbitMQ or Geaman. I am not worried about the 0.1ms it takes to start a process as I know they only run roughly every hour. With other processes every half hour. So the starting and stopping of these execs shoudl be fine. I understand that I can create a single worker (or several) that is managed by Gearman. And when they consume to much memory and crash they will be restarted. But I think a much simpler solution which allows a lot for my vanilla code portability is just running the exec in the background. All the feedback helps, I don't by any means know the correct answer, but I do feel that getting long running code off the HTTP stack will make my app more snappy. 
I did
Don't move all JS to the bottom, only move stuff that is not required before load and is fine to run after DOMContentLoaded has fired. Things like jQuery and Analytic code should stay within the head, just assure your using a CDN or if hosted locally are caching appropriately and they won't trouble you. 
Working with Twig in Silex, how can I override parts of built in templates, like form themes? In Symfony, if I want to customize bootstrap_3_horizontal_layout.html.twig, I create my file under views/form and then extend the original, but this does not work on Silex. How can I do the same thing in Silex without copying the entire form theme into my views directory?
If setPos takes an interview and some user of your library passes a bool because they don't check, that's their fault and it will automatically get converted to an int. If they care they will declare their code as strict too. Your library doesn't care what they are doing. &gt; I have to instead put declare(strict_types=1) in every single file where the method is called. Does that sound like a reasonable approach to you? Yes. It does. Otherwise it's a completely unacceptable backwards compatibility break. PHP _has_ to work with both weak and strong type checking. If, by some magic, WordPress decides to use some strict type coded PHP7 library, they are not going to be able to rewrite every single line of code just because of one library. **You** cannot force **your** preferences on other users just because you like strict typing. If you are going to be the main user of your libraries, set your Ide to ensure all files include strict types by default. 
try coding a template-engine. it's fun and may come in handy sometime
Cheers buddy! Do you have / know of any OS SF2 projects that use, what you would consider, best practices? (Other than Sylius, as you previously mentioned)
this was already requested for the php5-ondrej (ubuntu) packages: * https://github.com/oerdnj/deb.sury.org/issues/7 * https://github.com/oerdnj/deb.sury.org/issues/41
I am totally content with mustache. So no point there. I should have mentioned I get motivated only when I am coding that is going to be useful IMHO.
Even with the TLS implementation in PHP 7, ZTS still does not come for free. As such, it is not viable to enable it by default. Having separate zts packages (which requires having separate packages for *everything*) is probably a lot of additional work and not worthwhile for the small number of users who need it. Compiling PHP yourself is pretty simple.
Even on a single machine, I'd still do Gearman for two reasons: 1. shell_exec/exec are pretty dangerous -- I see you are passing args to the script, if those are user variables you're in for a world of pain when someone changes them to a malicious command. 2. Even baring the first problem, your callout method has no "relief valve" support on it -- with a job/worker system, you get a queue. You can determine if you want 1 workers (and thus one job at a time) or 100 workers. exec will just continue firing off till the cows come one. Finally, I really wouldn't put much weigh on freeing up memory from web requests -- it's probably not a large factor here. The point of getting out of HTTP quick is mostly so you give users a fast response -- ultimately memory, cpu, and even disk are pretty cheap.
I thought there was multi-threading in PHP. It's called using a message queue and then using something like hhvm/python on the backend? :)
Yes, for a lot of scenarios it is a valid solution, and sometimes better than threads. But I wouldn't call it "multi-threading in PHP" because it requires additional message queue server. In some cases however you do need normal threads, and return the result in the response. 
I've never learned as much on my own as I have from talking with other developers. If you haven't had much experience working with other developers, I highly suggest you use this opportunity to learn from someone else. I've seen developers who work alone and develop very bad habits with no one to keep them in check. I know you don't want to hear this, but you should set up code reviews and pair programming sessions if you want to get the most out of this employee. Don't come up with creative ways to avoid contact. Best of luck.
Thanks anyway
If you're trying to avoid talking to your fellow developers, you're going to struggle, and more so - your projects are going to suffer from it. You don't have to have meetings and be all formal - but being able to go to the Lead / Senior / Project manager when you need help, have a question, or get stuck is essential in the programming world. I'll go ahead and predict, that if you restrict communication to support tickets and refuse to have simple conversations, that you wont find many developers willing to stick around. 
Yes. Calculate the deviance from the perfect match and select the first row when ordering by the deviance ascending: select ABS($ideal-bar.foo) as baz, bar.* from bar where ... order by baz asc limit 1 
What's with this? declare(strict_types=1); Seems like they just made up a new format? Why not declare("strict_types", true); Or declare("types", "strict"); Or declare("types", TYPES_STRICT); Etc. 
Did you really mean "web purpose language"?
Yes. PHP is going the way of the dodo bird. Don't use it. This internet thing is simply a fad and will go out of style within 2 years. It'll be replaced by an organic neuron net. To connect, people will need to walk up to a Neural Net wall and shove a lab-grown trunk down their throats. Why a trunk? As a tribute to the dead PHP.
This guy is right. Listen to him
&gt; Someone mentioned to me php is dying. Yeah it'll die any second now, it's scheduled to coincide with the arrival of flying cars. That said, it's still a good practice to keep your code modular and split into simple services, that can be written in any language. Even if PHP won't die for another few decades, doesn't mean 100% of your project should be done in PHP as a monolith you can't move partially to another language as you see the need to (I typically have PHP web front-end connecting to backend Java services). PHP will continue to be around because despite its flaws (which are disappearing at a surprising rate with every new release) it still has strong benefits for simple web front-ends, which is basically most of the web. Dynamic, highly flexible, easy to deploy piece by piece, and a rich (if messy) standard library that does everything out of the box that a site needs. EDIT: Oh, and basically all shared hosting servers run on PHP. Forgot the big one. No other language right now lends itself to shared web hosting like PHP does.
Thanks for the reply. All the articles I've read so far recommended otherwise. I'll go deeper on the matter then. Do yo u have some reference url to look at? Anyway, for the sake of discussing, if moving jquery to the bottom was a requirement, what could be the ways to tackle the problem stated above? 
Your example is a bit extreme. You've eliminated *presentation logic* from the presentation, which means it'll end up in the controller, which is also not great. To understand how a template should look it helps to understand what data the controller passes to the template. It usually is the pure collection of data to be shown, without assumptions *how* it's shown.
https://wiki.php.net/rfc/scalar_type_hints_v5#why_not_use_use_strict_instead_of_declare
No comments, yet? Well I think the attack is pretty nifty. It's also interesting how the attackers compliment Magento for their security measures. I guess for most of us Magento looks pretty old (using Zend1, pseudo-namespaces), but for what it is, it'd well crafted. Looking forward to 2.0 which will be finally build on composer and everything else that's cool these days.
If you are talking about "write everything yourself procedurally"-php, YES. If you mean Framework supported ooPHP, very likely not. But I expect "do everything on your own"-approaches to become rarer over time while "use framework with plugin"-approaches will continue to be more and more important. As long as you keep up to date with new Techniques and try to stay on top of your skills, php will always be useful.
Only way I can immediately (and reliably) think of is to have some form of login unique to each user, and then track the usage for that login.even if it's literally just a username, but some way to distinguish who it is.
Websockets can also can also be done with ReactPHP. Visite reactphp.org
I think that's the reason they exist, but it sure does get tempting to abuse those buggers.
Let's add Latavel to that... https://www.google.com/trends/explore#q=codeigniter%2C%20symfony2%2C%20laravel&amp;cmpt=q&amp;tz=
Java coders need a j version of everything.
I am the only developer on my team in the country. Here's what I advise: For what you're talking about, agile development would benefit you if you implement it correctly. This means: 1. You need to have a daily SCRUM session. This isn't much and probably isn't much different than what you've done before. What you're working on, what challenges you had, what you will work on. It doesn't have to be long but you should have enough time blocked off so you never have to cut them short. This might be 5-10 minutes on most days, but will sometimes be longer near important milestones. 2. You need to be available over both email and chat/phone for those "what do you think of this method" or "why did you choose method x here" questions. You are, however, allowed to wait until you are at a stopping point before responding. 3. Code as documentation. This doesn't mean no documentation. It means that code should be easily readable and that documentation should supplement the code, but you don't need to repeat yourself in documentation. It also means that function and variable names are very important, as you need to be able to infer their use through the name. 4. Define and enforce code styles, documentation, and comments. I strongly recommend adopting all of the PSR code styles and enforce a rule for docblock comments. At a minimum, @param, @return, @throws are necessary as are a description of the class and function. Variables usually don't need a comment if they are named well, but I sometimes comment them for the IDE. 5. Enforce testing rules. Use an automated testing platform. The parameters are up to you, but you need to be able to see passing tests and be confident that you can merge to master without creating a bug. 6. Depending on your management and coding style, it can be useful to define interfaces together (or at least come to an agreement before proceeding), especially for classes that you will both be using. 7. I also recommend a rule: nothing gets merged to master without review by the other person. We have a "review needed" tag on our PRs, and we comment "merge it!" or a suggestion after reviewing. You can set up a system where a lot of the communication happens as part of the process, but you still will need a short daily call and whatnot. On another note, it's important to know your team members on a personal level as well as a professional level. The call will help with that, as will team building exercises (ours are normally just go out drinking and the company pays for it... it doesn't have to be paintball or minigolf or the standard team building BS.)
&gt; I hate meetings and I don't want to talk to him too often. I want both of us focus on programming. You're definitely trying to solve this the wrong way. In order to program effectively you need to be synchronized with the people you're collaborating with, and this happens via emails, interfaces, architecture, git AND ALSO by talking. Having fluent communication with someone doesn't mean you need to waste time, a focused 1:1 meeting can be done on Skype in 15 minutes with both your editors open, discussing the code. Whatever your worry is about communicating with people you need to resolve it, or else you'll suffer, your colleague will suffer and your project will suffer most of all.
I will give that a go, thank you!
&gt; As can be seen, those exceptions can be broadly divided into two main categories: LogicException and RuntimeException. All of those exceptions are self-explanatory from their names. For example LogicException represent any errors caused by the logical errors in your code, RuntimeException represent any errors that are caused after script has run eg runtime errors; I chuckled while reading this attempt to rationalize the names of the various built-in exception types, because, see, all exceptions are "logical errors" and they all happen at "runtime". I sympathize with the author, who's just trying to go through this paragraph via handwaving without saying anything that might turn out wrong. Actually, the reason we have that specific set of exceptions is because they [were lifted almost 1:1 from java.lang's exception hierarchy](http://www.javamex.com/tutorials/exceptions/exceptions_hierarchy.shtml). In Java there's a concept called "checked exception" which means you must have a catch block for them or declare you'll throw them, otherwise you get a compiler error. To allow for unchecked exceptions the "RuntimeException" class exists, which is unchecked, as well as all classes that inherit from it. Hence the name "RuntimeException" means "NotCheckedAtCompileTimeException", and they thought "Runtime" is a shorter name for this idea, can't blame 'em. In PHP *we have no checked exceptions*. We have only unchecked ones. But whoever was looking at Java, didn't pay attention to this, so now we have RuntimeException in PHP which really serves no purpose at all. The rest of the exceptions listed have a similar history. They mean something specific in Java, and PHP they just... well, they're a bunch of names, and we can pretend they "are self-explanatory", but PHP doesn't throw any of these itself, so we're left to either have endless debates about semantics or pick one at random and throw it. In reality, I almost never see code in the wild throw one of those. I see libraries attempt to *extend one of them* when creating their custom exception classes as a sign of courtesy, but that's also rare. &gt; See more at: http://codeinphp.github.io/post/throwing-your-own-library-exceptions-in-php/#sthash.vC1daMRE.bCfLmlvj.dpuf Can you please remove this obnoxious copy/paste interception script from the site? It only serves to annoy.
First, go read [this explanation of threading](http://truelogic.org/wordpress/2012/07/17/dummys-guide-to-multitasking-and-multithreading/). The answer depends on the context of "threading" being used in your question. I'll define both. First, it can refer to how PHP is being run, most often as either fork/prefork (as a CGI, as a prefork Aapche worker with mod_php, or under FastCGI). Sometimes, PHP is run under a threaded environment, like the prehistoric ISAPI filter or as Apache's new threaded worker model with mod_php. Second, threading PHP can refer to [Joe Watkins' pthreads extension](https://github.com/krakjoe/pthreads), which allows you to actually use threading from within PHP itself. I personally have yet to find a use case for pthreads, and haven't encountered a problem that a message queue or work queue can't solve... but I also tend to only have *boring* problems.
Thank you, I'll look more into how I can implement that!
But is having the option of using a thread in PHP really a bad thing? It feels like you're arguing "in case X, use Y because it's better", but that's assuming it's always better - which isn't not. In my instance, I have the choice of threaded PHP, some ajax hackery, or setting up a nodejs server. So why not let me have to preferred choice of continuing with PHP, instead of forcing the "x does it better" mentality? Yes, it does it better, for *some people*.
PHP hasn't been specifically a "web purpose language" in quite a long time.
&gt; $math-&gt;sum((int) $firstNumber, (int) $secondNumber); If you read the rest of this discussion you will see that your example is *exactly* what I expect the caller to do. Not only do I expect it to be allowed, I expect it to be done that way. You know, like every other language with strict types.
I don't know, which is why I asked for the cases he described. If someone wants to only use PHP, that's the developers choice and they are free to use whatever works for them. Far be it for me to impress my design choices on anyone's project. :)
Number 2 is the big one.
&gt; Please do not frequently submit links to your own content, exclusively. It's likely to get spam-filtered. http://en.reddit.com/user/sarfraznawaz2005/submitted/ Yeah, tone it down a bit eh?
What ever lives, will one day die. Yes PHP will die. But not yet son, not yet, not yet! 
The one and only (unlike Phil).
yes and no. PHP will be replaced by PHP. Meaning that the language is currently nothing like the language as I learned it 10 years ago. I expect PHP to be even more different 10 years from now. I look back at projects I wrote years and years ago and I am disgusted. HTML mixed into the same code with SQL statements using mysqli. yuck. Most of the PHP hate seems to forget that PHP has changed over time. 
https://phpacademy.org/videos/register-login https://www.youtube.com/watch?v=T4NTdRvIrdk
True enough! Any system with an application level storage object can do this I guess (ColdFusion, for example). Every other framework I've used does not. Most languages do not have an "application" accessible to them - PHP, Python, Ruby, etc. I don't remember offhand if JRun has that or not... So for the record, Rails, django, Flask, and Laravel (along with dozens or hundreds of others) run from-scratch on every single request. ColdFusion and ASP (all .net languages?) have an application level storage that only executes once for multiple requests. Sound about right?
&gt; Rails, django, Flask, and Laravel (along with dozens or hundreds of others) run from-scratch on every single request I know Laravel runs from scratch because PHP. Not sure about the others as I don't have much experience with Python nor Ruby. Node.js frameworks like Express definitely do once-off setup too, and in fact a lot of the environment is shared between all requests (ie. global variables you set in one request will be visible to other requests). Django might actually do some initialisation when you create the WSGI handler, I'm not too sure as I've never used it. Rails appears to have some support for app-wide init code, for example [react-rails](https://github.com/reactjs/react-rails#server-rendering) creates a pool of JavaScript engines that are reused across requests. &gt; ASP (all .net languages?) ASP.NET is the web framework on top of .NET, so it's all ASP.NET regardless of which .NET language you're using. Most people use C#, some people use VB.NET, but there's nothing stopping you from using any other .NET language, like F# for example :)
That will still error as it still executes straight away, you're just hiding the error from the window scope. If he really wants to move jQuery to the bottom of the page, without also moving other scripts that depend on it then he should be wrapping it into an anonymous function that is fired on load/DOMContentLoaded. 
&gt; Yes! That's exactly what expect the caller to do. I expect them to make a conscience decision in how the casting will be handled instead of leaving it up to the language to decide. So... a composer update which includes a library that has decided to turn strict type checking on should break your code? That's.. just wow. Worse, due to the enormity of the BC break, the chances people will simply not update to PHP 7 is high. Further, you as a library author really shouldn't have to CARE whether someone implementing a solution using your code uses a cast or not. It's literally not your problem. If there are bugs introduced in their code you can point them to declare strict to resolve. It is completely *not* your problem. From your code's perspective there is exactly zero difference. &gt; You're kind of looking at this all wrong. It's not about my functions. It's about the language. I'm asking whether the feature, as implemented, is beneficial to the language, or does it give more ammo to the PHP haters? I honestly don't give a shit what the PHP Haters say. Most of what they argue requires them to ignore the metric shitload of PHP code that is in the wild. You seem mad because it's not implemented 100% the way you want, therefore you are thinking it's not broadly beneficial? &gt; I said this in another comment, but the person using my library the most is going to be me, and I want strict type checking. Well isn't that great - you have complete control over your code, so you can opt in and have the precise behaviour you expect. &gt; The way this feature is being implemented forces me to put declare statements in every single one of my files instead of only on the file where the function is defined. IDE new file macro will be your friend then. Look, the solution is far from perfect. It is an imperfect compromise for an imperfect language. The other options were thoroughly explored. Strict in the manner that you want simply would not have passed the vote. Then you'd be stuck doing type checking and writing oodles of boilerplate. This is the best possible solution for the current reality of PHP. And it provides a path towards strict by default in the future, if internals want to go that way. 
That just pushes the problem to a different place. If you have multiple servers behind some kind of load balancer with normal PHP you either need to lock the connection to one server once it's been established somehow, or you need to share session information between servers (usually using a DB store for session data, redis, etc.) The first one is what your default "doesn't die" application requires anyway, and your second option is how you would make your "doesn't die" application handle that sort of thing anyway. I've gotten pretty far into this recently, as my team is building a ReactPHP based WebSocket server similar to Node in PHP, and to handle data synchronization we are building a sync service that sits behind all the entry points and keeps them up to date with each other.
I happen to use the print_r, var_dump and var_export functions from phpjs when debugging cause I'm lazy and like the way they output data. :P
&gt; sanitize($username); Where did this function come from? It's probably not what you should be using there. 
Why would it die out? It's the most used web language, there's TONES and TONES of great frameworks out there for it, and PHP 7 is coming out later this year or next year. It's far from dead, and it's not going to die. At least, any time soon, or any time that anyone here would care about.
It's in the video, I believe as a way to check through the username
&gt; This way, if I want to use the modules developed by him The "I don't want to talk to him" thing has been discussed by others already so I'll focus on this: modules and programming against interfaces is good, very good. However it is not meant as a solution for human interaction. You both need to keep up to date on the whole project. Not in every detail, but I advise against going the "my modules VS your modules" solution. First that means that collaboration will be minimal. You will not learn from each other, you will always be in a situation of "client - provider" and will be constantly asking for new things in his modules, or adding (or refusing to add) new things in yours for his needs (that you might have trouble to understand). Another reason why it's bad is if one of you leaves the company, the most common scenario is that you have to maintain his modules and realize it coded in a way that you don't like at all. And you'll end up throwing a lot of it, rewriting a lot, etc. On the contrary, working together is a great way to learn, to work to produce consistent work according to common and agreed patterns and guidelines and be confident that each of you (of future developers) will be able to contribute or take over every piece of code.
&gt; This component includes a dump() function which is a much better alternative to the regular PHP var_dump() function Not when Xdebug is installed. Xdebug cleanly formats all of my data and I can see it all up front. `dump()` makes me click to see it. Why is `ctrl+click` the way to view expanded data? Why isn't the default just a simple click? *Why do I have to click at all?* What asshat thinks debugging info should require work to get at???
It won't die. But it will lose a lot of space to newer languages. In Tiobe Index it's been trending down consistently year over year. PHP for a long time was the only choice for Web Development - Perl was displaced by PHP, and JSP never managed to be as popular. Smaller communities, such RubyOnRails, grew by attacking PHP. Nowadays, experienced PHP developers that faced one of the many shortcomings in the language are turning to more modern choices such Scale, Clojure, Go etc or simply working around the language, such HipHop and Hack. I wouldn't bet all my eggs on PHP only nowadays. But it is still a strong contender. 
definitely prefer having to click through.... Rather not crash my browser with a fuck ton of debug statements from a large object.
&gt; I still think I can keep doing this for some time before moving to RabbitMQ or Geaman. I am not worried about the 0.1ms it takes to start a process as I know they only run roughly every hour. With other processes every half hour. So the starting and stopping of these execs shoudl be fine. But the question you asked would have lead to much much more than that, right ? It sounded like you intended to move all your API calls (which I assume are invoked with most page loads) to "background" processes.
Don't know why this is downvoted, I know some people don't like you but it's always good to have more PSR7 libraries. 
Yes? Who wants to needlessly click to open their debug info when they don't have to?
If anyone can download code why didn't you put it on GitHub? You can charge for support and licenses anyway.
I am trying to connect to MS SQL server. I am currently trying to open the ports of this instance that were inactive in SQL configurator
You can also install them with composer require global &lt;library&gt; Now with this, instead of using just ```composer install``` you can use ```composer install --no-dev``` so you still can have your dev dependencies on your project for other contributors And if you then have ```$COMPOSER_HOME/vendor/bin``` in your path, you can use ```phpunit -c .```
Uh, dude, topic exchanges. That's what they're for. 
This would be interesting for tools (e.g. as I mentioned in my other comment [couscous](http://couscous.io/)). PHPUnit however isn't the best example as we use it both as a tool (the `phpunit` CLI test runner) and as a library/framework (our test classes extend and use PHPUnit classes). Your code sometimes relies on a specific version of PHPUnit. But except PHPUnit, yes it would be useful to install other tools as phar. Because of the conflicts I've described in my other comment I've come to not use Composer so much to install tools as their code (and the code of their dependencies) can get autoloaded.
First off, yes frameworks are slower than raw PHP, that will always hold true. However, you're more likely to hit bottlenecks in almost every other facet before your framework's requests per second become an issue. The benefits of using a framework are vast, but I've always believed it's all about the project at hand. Take these two situations for example: 1. If you need a landing page with a single call to action, a framework like Laravel may be overkill. 2. If you're building a multi-user API/Blog/CMS a framework will not only increase productivity, it will (hopefully) ensure better organisation and security. If you're still worried about performance, take a look at a micro-framework. You'll still receive the majority of the benefits (KISS and DRY), but the performance hit will be lessened.
Yes, I already fall in the same problem, global dependencies trigger problems with incompatible updates... It's because of that's conflict that the idea come...
Unless it evolve.
That is so much less readable than: if ($blTest) return $post; if ($post === false &amp;&amp; $session) return $session; return $default;
Can code written as "raw PHP" be faster than many frameworks? Yes. You can write code to be very specific to the task at hand, using every optimization available. Frameworks are written as "general purpose" tools to handle the vast majority of cases. Is it always faster? Not necessarily. The code you write may not be as performant as the method used by the framework (which often has had many eyes, or uses libraries developed by people with years of experience). Will rewriting your application without using a framework immediately fix all your performance problems? Probably not. Your performance problems are far more likely to lie in the code that you've written on top of the framework. You might be able to make some gains by not using a framework, but you're more likely to make better gains by looking at your own code. So should you rewrite your application without using a framework? The only way to tell is to profile your applications code and database queries and measure where the bottlenecks are. You also have to factor in the extra development time required writing code that does the same things a framework would do for you (and then debugging that code or running into the same edge cases most frameworks have already run into and at least documented if not fixed).
[Yes](https://www.techempower.com/benchmarks/#section=data-r10&amp;hw=peak&amp;test=json&amp;l=sg), but [not so much](https://www.techempower.com/benchmarks/#section=data-r10&amp;hw=peak&amp;test=query&amp;l=sg). Most of these examples are too simplistic to take at face value, but what you can see is that as you get more complex and involve more systems, you see the speeds even out because, often times, the language/framework don't end up being the major bottleneck. As others have noted, there are lots of other important reasons to use a good framework well aside from speed.
If you're asking this question, then there is a high chance that you aren't able to write code as fast, secure and well organised as you would find in a leading full stack or micro framework. Learn how to use a framework, then learn how it solves common application development problems, then decide if you want to use one or not
I'd suggest communication mainly for bonding. I work in an office of 9 developers (Java,PHP,Javascript) and it's good to have a giggle and a joke. It makes speaking to people relating to work issues much easier. It doesn't feel like you're hassling them because there's a friendship there. Definitely don't avoid face to face communication
No level of abstraction will ever be, for each codepath, as efficient as an idealized implementation at a lower level of abstraction. This is a concept known as "abstraction penalty". Further reading: http://en.wikipedia.org/wiki/High-level_programming_language In practice, however, frameworks like laravel and symfony (and their associated ORMs eloquent and doctrine) often result in applications which have _less_ load on the server, and more importantly, are used for web applications that _feel_ like they load faster to the end user. When you have a standardized approach to routing, caching, ORM, etc, many important optimizations that might be prohibitively expensive to implement and maintain can be simple enough to set up with little work. Keep in mind also that your stack is going to change over time, so a non-framework implementation you write may be optimized today for your single-node deployment with apache on PHP 5.3 on mysql, but those optimizations may not matter next year when you move to nginx on PHP7 w/ postgres. I've seen deployments that were very efficient for the time -- routing essentially handled by apache mod_rewrite on a separate webserver node, lots of repetitive code with for-loops (or even just unrolled loops) that could be handled more clearly/reusably with function calls, and long, hand-tuned SQL. These sites would turn into lumbering dinosaurs compared to modern implementations on a popular framework, which are organized to nicely cache/invalidate cache and use a CDN. It's surprisingly common to see applications hosted on a $3M/yr mainframe that could run on a $20/mo VPS with a $0.08/GB CDN, if they were implemented today.
I feel like the main point you missed, is that frameworks are slow **relative to plain old PHP for simple hello world apps**. Unless you're serving a huge number of requests then you'll probably never notice the speed difference. Dropping frameworks due to worries about potential speed issues sounds like a severe case of premature optimisation to me.
&gt; If we declare main.php strict, PHP happily returns 4 despite the mismatched type we are passing into log(). So we're forced to call strict on every file that we want to force strict types on? That's a bit odd, is there a way to force strict on every file?
OK, just thought I would check, as it's not all that often people use MSSQL with php. :) As for the port, I'm assuming that you can connect to the MSSQL server with something like SQL Server Management Studio on port 8081? From what I can tell looking at the MSSQL server setup on PHPStorm, it looks like it should be simply a case of entering the relevent details on the form.
Premature optimization is by definition premature. To balance it out, though, here's a saying I like: &gt; If you fail to plan you plan to fail. This isn't a direct answer to the OP's question, not is it necessarily addressed to your specific comment; I just keep hearing people say that framework performance doesn't matter when realistically it very well could.
&gt; WordPress for instance. I was with you up until this point. :(
I prefer most groups and nested values to be collapsed... rather than be presented a crap ton of debug output. same reason browser developer consoles display the dom tree collapsed. can't magically know what bit of debuggery you're interested in / no eyeball tracking and eye-clicking yet.
Definitely more than 1% of the time. More like 60% of the time. And yes, i want to click through. 
Why the link to the blogspam? Real content is in Laracasts, meaning it's behind a paywall: https://laracasts.com/lessons/broadcasting-events-in-laravel-5-1 That being said, I've got a Laracast subscription and highly recommend it. Looks like an interesting video, Jeffrey is always on point with them. edit: as /u/wesrice points out, this video is actually free.
They're difficult to test. They hide a classes dependencies. They create tight coupling.
Stateful statics are notoriously awful to test. Unit Testing with stateful statics littering your code is a brutal, frustrating experience. But don't take my word for it, give it a try, either way you're bound to learn something.
Mainly, the lack of ability to do dependency injection. With statics you will always end up with a direct dependency on the DI / IOC container, which breaks inversion of control. If you don't know about these principles, it's worth learning.
It's worth noting that this video is not behind a paywall and is offered as free content on Laracasts.
Because it offers a small summary of the video, for people who don't have 8mn to watch it. Thought it might be useful for people at work and stuff that still wanted to know what it's about
If you only need one UsersRepository then only create one instance, where's the problem? who's forcing you to create multiple instances? :)
Singletons are useful when used appropriately. Angular, for example, integrates services which act as factories for singletons. This is a fairly new library written by (what I assume) are a talented group of developers at or associated with Google. Whenever you have a particular resource where duplication would cause more harm than good, a singleton is perfectly adequate. But like anything else, it can be overused.
Can we go meta for a second? This looks like a solid opportunity. How many years of experience would the average (legitimate) applicant have for this kind of a position? 
/r/phpcomposer
I've removed your job post because we only allow remote positions to be listed; That way it's fair for the community.
I'm saying this because I was curious how'd something written in PHP send events to JS. It felt like real value. Turns out it doesn't send events to JS - the meat is in Pusher and Redis, and the value that Laravel provides is "integration with Laravel". You seem to say all PHP code is like that, but there are many PHP packages with meat in them too. Say [this Office file parsing library](https://github.com/PHPOffice). Imagine if you installed this and it said "oh, you need an installed MS Office 2013 or later, or an API subscription to ConvertOffice.com". But it doesn't - it just works. That's real value.
&gt; so you only need one UsersRepository to represent that, right? Yep, that's the right choice for all time! What could *possibly ever change*? Oh wait, what's this? We want to be able to run unit tests that don't hit the database at all? Hmm, that would be easy to do if we could pass in mock/stub versions of the UsersRepository.... Oh wait, what's this? We want to be able to run integration tests, that check that information about users gets created and saved into the correct database tables? Hmm. That would be a lot easier to do with being able to specify a new UsersRepository per test... Oh wait, what's this? A business requirement to be able to search the archived Users table rather than the live data. Hmm, we can re-use the current search code, but only if we're able to be able to tell it to use a different UsersRepository... Seriously - although in trivial cases using coupling between different bits of code can be a decent trade-off, for complicated code it is very likely to come and bite you in the bottom. And anyway, doing it properly with dependency injection can be made really easy with a decent Dependency Injection [library like Auryn](https://github.com/rdlowrey/auryn). All you have to do is setup how the objects are created: $entityManagerDelegate = function ($conn, $config) { return \Doctrine\ORM\EntityManager::create($conn, $config); }; $injector-&gt;delegate( 'Doctrine\ORM\EntityManager', $entityManagerDelegate, [':conn' =&gt; $conn, ':config' =&gt; $config] ); $injector-&gt;share(Doctrine\ORM\EntityManager::class); //We only every want one of these. $usersRepositoryDelegate = function (\Doctrine\ORM\EntityManager $entityManager) { return $entityManager-&gt;getRepository('Users'); }; $injector-&gt;delegate('UsersRepository', $usersRepositoryDelegate); $injector-&gt;share('UsersRepository'); //Most of the time we only want one of these. Now if you have a class or function that needs a UsersRepository like this: class UpdateUser { function __construct(UsersRepository $usersRepository) { //.... } function fooAction() {} } The `fooAction` can be called with `$injector-&gt;execute(['UpdateUser', 'fooAction'])` and the UsersRepository gets created. Boom. We've achieved the same goal of having a single instance of UsersRepository created which is fine for most of the application. But then when we come to write the test cases, it is easy to switch out what object actually gets instantiated and pass in a mock/stub version instead. 
If your main concern is speed, check out: http://phalconphp.com/ I originally went to it for the speed, but stayed because I think it's actually a really good framework regardless of speed. It's modern, has most things I need, and I prefer not having a shitload of framework code in my projects. Even with the complete rewrite in Zephir that they've just done, they didn't break compatibility with Phalcon V1. Nice that you don't need to make a bunch of changes when you upgrade.
I don't think, and never said, that the whole site is blog spam. In fact this is my first introduction to it. I meant no offence at all. My point was merely about this particular post in the context of its submission to reddit. The original content of your post is one sentence: &gt;Also, check out all the other new goodies coming to Laravel 5.1 and Matt Stauffer has a written tutorial on broadcasting events. That's fine, I'm not against blogs making posts like this. It's a great way to alert your readers to new Laracasts and I've nothing against it. What I had issue with was submitting the blog post containing a quote and one original sentence, over the content people would be directly interested in (the laracast video). To me blogspam is when a low-content post that is basically just referencing a high-content post is submitted to a service like reddit. To be clear, the post itself is fine, it's that the post shouldn't be submitted to reddit. Anyways, I hope there's no hard feelings and keep up the good work! edit: to add a thought experiment, if I created a post saying "Check out this new post on Laravel-News about broadcasting events to JS" and linked to your post, should I submit my new blog post to reddit? 
this question sounds as you would think, that it is a mistake to use laravel for a companys project
This has been my experience with building two large applications with versions 4.1 and 4.2. Here are the primary missteps I feel I made during those two projects: 1. **Keeping all Validation Logic in the Model**: This was fine when validation didn't have any external dependencies, but when validation involved checking data in a different model, I ended having two sources of validation, which significantly increased validation complexity 2. **Overuse of exceptions for validation**: Laravel makes this fairly easy to do, and I think that in many cases it's perfectly acceptable. However, part of our application included importing a lot of data via CSV and going through cycle of attempting validation, catching the exception, recording the validation errors, repeat slowed the import process down considerably 3. **Carbon Package Gotchas**: For example, it will throw an exception if someone enters a non-standard date format, and there's no really convenient way to handle that with model-based validation 4. **Using Laravel's Facades for Domain Services**: Seemed like a good idea at the time, ended up being more trouble than it was worth. It introduced less obvious coupling between services despite making mocking said services slightly more convenient. 5. **Eloquent's static Boot method**: Since a static attribute it used to determine whether an eloquent model is booted or not, this caused issues with testing because the static variable state was preserved between tests. Classic Global State testing issue. 6. **Using Eloquent for Everything**: One of those applications was primarily API driven, and some of our data was too simple to justify using Eloquent for it when a simple database mapper would have sufficed. Eloquent has a ton of features but it's also the closest thing Laravel has to a God Class. That being said, I still consider Laravel a solid framework and I have no plans to use a different one for large projects. For smaller projects I'll probably continue to use Slim, though I may check out Lumen once it's a bit more battle-tested.
I liked your post a whole lot more when you linked to that old thread, *without* that rant you added :P &gt; Uhm... It sounds like you're trying to say that PHP is more prestigious/functional than Java. Nope, I'm trying to say Java still exists, so... use it? You make it sound like Java's gone so now all we have is all those memories of better times. BTW, most of my projects are PHP/Java hybrids (PHP front-end + Java services). I even use checked exceptions (for one thing)! I've just never seen people come out of the closet about it before ;)
Even better - have the storage for the repository injected in, rather than using inheritance.
[Make sure you have all the packages installed correctly for SQL drivers](http://stackoverflow.com/questions/27726061/connect-php-application-to-ms-sql-server/27726265#27726265)
Do you have any examples of what you were able to build with the framework?
FYI there are alternatives for websocket in PHP, e.g. [Hoa\Websocket](http://hoa-project.net/en/Literature/Hack/Websocket.html) seems like a pretty solid solution.
Thanks for that, the blog post didn't have any technical content.
I don't think that Angular is a bad example of "engineered well". In fact all dependency injection containers provides single instance of service... But this is not an example of singleton (you actually can ask DiC in Symfony or Injector in Angular to create new instance of service). Singeltons are not so bad...They just been used wrong so often that they became anti-pattern. Especially in PHP world.
My mistake was using Eloquent. It was difficult to test and somewhat counter-intuitive for such a large database. About half-way through I switched to Doctrine. That said, I do not think Laravel as a whole is a bad choice. It all depends on what we need and how we have to fulfill the milestones of the project, much like how Symfony is inappropriate for a personal blog IMO (I just use some components). If Laravel can stand up to it, I don't see a reason not to use it.
This is the function I have for it: function sanitize ($data) { return mysqli_real_escape_string($data); }
You have to click through to the video. Edit: I don't understand the downvotes, just letting him know about the video which does have technical content in it. Also it isnt that obvious you have to click the title to get to the video
In theory I agree that it would be useful (I don't like to watch videos) but this specific blog post said nothing, at least it didn't summarize the video (see the top comment above which is a much better summary).
Ratchet author here. I have *less* time for new features (sorry). It's still maintained and is a fully functional implementation of the RFC6455 WebSocket protocol. 
When building a fairly large application, the main mistake I've made is shoving all controllers, views, and routes in their respective default locations. Laravel makes it trivial to customize this, and what I've found works best is to take a Symfony-esque bundle approach and break up the http layer of my application into separate mini-apps that live in their own folder. That structure looks like this: &lt;ProjectName&gt; Apps/ Admin/ views/ controllers/ forms/ AdminServiceProvider.php // just registers routes.php and the views namespace routes.php These apps always encapsulate everything under a subdomain or the first major URI slug (e.g. admin.site.com or site.com/admin) so that it's intuitive where to go to get them and so that there are never any route conflicts (as you're including multiple routes.php files). Meanwhile, all domain/business logic lives inside of its own directory, and everything in Apps is nothing more than the HTTP layer stuff. 
That's definitely a matter of opinion.
Thanks for the heads up, I missed that it was using `[foo](1)` for footnote style links instead of `[foo][1]`. It's fixed now :)
It sometimes feels to me like Laravel is the Apple of frameworks. - Every new thing they bring out is marvellous and awesome and you need it right now - A large part of their fanbase is insufferable - Led by some guru who the fanbase worships - Everything they do, has been done before, but they manage to package it in a nice and convenient way I love that Laravel is creating so many opportunities for people, I'm just a little worried that we'll end up with a pile of Laravel developers, not PHP developers. 
rails or django
* static classes hide dependencies, which can lead to violations of the Dependency Inversion Principle * static classes are much harder to refactor * static classes use the global state, so you cannot control their impact and lifetime across an app * static classes make composition much harder, leading to lack of extensibility and flexibility * static classes couple the implementation to the object's lifetime If at the moment you only want 1 instance of an object across a whole app, set up your app's dependency injection container to create just one shared instance.
&gt; it's a good thing Yes, for sure, however, I'm still worried that we'll end up with a black box system and "Laravel devs" won't know what's going on behind the scenes. Just look at the current top comment by /u/BringTheTanks : &gt; I'm saying this because I was curious how'd something written in PHP send events to JS. It felt like real value. Turns out it doesn't send events to JS - the meat is in Pusher and Redis, and the value that Laravel provides is "integration with Laravel". Good on them for figuring out what's going on, but I'll bet you a lot of others won't. And then when you ever switch to a new job where they might not use Laravel, you'll have to learn all of those things again. 
&gt; I'm still worried that we'll end up with a black box system and "Laravel devs" won't know what's going on behind the scenes. I think this kind of fear is somewhat unfounded. We use Laravel extensively at my company, but hire PHP devs.. people who don't know how to use the language and can only use one tool stick out like sore thumbs. As for a black box... I don't care how Laravel specifically does things - only that I can find out if I have to. Coding against black boxes (any quality abstraction really is a black box after all) is actually insanely productive. I get what you're saying, but I don't see the doom and gloom of a future where people only know Laravel.. Laravel's community itself actively pushes against this kind of thing in my experience. &gt; Good on them for figuring out what's going on, but I'll bet you a lot of others won't. And then when you ever switch to a new job where they might not use Laravel, you'll have to learn all of those things again. You figure it out at config time... you either need a pusher account (which is the default behaviour, you have to plug in your pusher api keys and such..), or a redis installation (which you again need to configure). The mechanism by which it does this is not invisible. Looking at the code on github it looks like one of the least black-boxy things that Taylor has built in recent times actually... fairly clear what's going on... If you wanted to do it all in PHP it looks like it would be a trivial job to write a Ratchet driver for it... Anyway. Like I said - I get what you're saying... but I feel the fear is largely unfounded.
&gt; It doesn't change the fact That's an opinion. Not a fact. And that is strictly YOUR opinion, that not many people here seem to agree with. None of what you said is a straight fact. You are just a grumpy dude who wants to complain about shit.
Solid argument. And yes, I am grumpy. I'm grumpy when technology is needlessly harder to use than it should be. We're surrounded by needlessly hard to use technology. Don't people have higher standards? It's frustrating as FUCK to wade around in a wasteland of pervasive bad technology. OSX doesn't let you independently change the scroll direction of your mouse and your trackpad. My LG bluray player turns on my LG TV when I eject a disk and then close the drawer rather than checking to see if a disk is present and then not turning on the TV needlessly. Var dumper makes you click to get access the very thing it's supposed to give you: information. There is literally no other reason to dump info except to see it lol.... Joomla exists. Hulu periodically crashes out and restarts my Apple TV. The Fitbit scale I bought shuts off mid-message through the setup cycle, even though it completes the setup just fine, making me think it failed or the batteries died. I could go on and on with hundreds of examples of shitty, inadequately designed technology by people who either don't care enough or don't try hard enough or simply have no fucking idea what they're doing. So yeah, I'm grumpy.
Given up arguing with a donkey.
I would be interested in working on something like this. I completely agree that ecommerce seems to be way behind current Web applications. 
I am inclined to agree, however thinking about all the things you have to set up yourself for a fully functioning ecommerce site, with taxes, gateway order placement, shipping, admin dashboard, magento offers all these technical things out of the box. For dev teams I can see this being more feasible, however if you are lone wolf, Magento still seems the better choice just because everything I mentioned in this regard is point and click. 
really unacceptable admin auth bypass CSRF 
There's also a native [get_browser()](http://php.net/manual/en/function.get-browser.php) function available.
You should keep in mind that browser sniffing based on the user agent is considered a bad practice. It's not so hard to pretend that I'm Internet Explorer version 43 when I'm actually using Chrome. The worst is when you serve a website depending on the user agent of your visitor. See: https://css-tricks.com/browser-detection-is-bad/ Instead of serving a website depending on the user agent of the visitor, you'd better use a library as Modernizr to do capability testing.
I think it can be useful to do not overload the Composer vendor folder with only useful binaries classes. Also it can allow be tricky to integrate and validate all the dependencies of PHP Code Sniffer for example which are not really necessary in the project...
Yes I see your point here, you're totally right. The thing is tough, if someone has the resources to invest on a new platform with a more modern approach instead of going with Magento, this is going to be a very good investment for the company in the long term. To have a big ecommerce company with Magento you need developers, so why don't use your developers to build something light this? Also people could open source the codebase of their single components/apps to make them reusable, in this way we will have a complete system doing all the things that Magento does, just combining the components that we need. I personally would never invest on Magento if I had to build a long lasting ecommerce website with a good revenue. As a developer I know that it's going to be difficult to maintain and customize in the long term.
Nice follow-up on the previous post! I completely agree on the future being Service Oriented Architecture applications. I work at a Wholesaler with a custom ERP package. No SAP or any other well know system, powerbuilder + SQL is what runs the place here. So we have our own PHP framework in place, the approach your are suggesting is where I want to bring the framework too, creating an actual API layer for our ERP system. Right now, everything is done through stored procedures. Great from a security standpoint but a hell to use in any modern application/language. Having this in mind, most settings and content is managed by our ERP as is all business logic, which makes it a pain to use things like Sylius or any other e-commerce platforms/frameworks. Currently we ("we", since I'm the only dev here ^_^) are developing our own API to serve our own customers in the first place, and probably to serve our own future applications.
Disclaimer: I haven't yet read your article, I might raise something you already answered; sorry in advance. I've been building Magento based shops for nearly 5 years now and maintainability and customization are in fact its two best aspects from a developers pov. Everything can be extended, overridden, configured or discarded, whatever your requirements might be. The observer mechanism - while having its drawbacks - offers a way to modify anything, without having to rewrite or modify the core. As a client, I would much rather invest in a solution that's wide spread and has several companies that use it. If a developer or company is no longer desirable for whatever reason, I could simply contract another and wouldn't be stuck with just one team. E-commerce is an important and in many cases the only sales channel for a firm, they need to be sure that it won't go unsupported if for example, the original developers go out of business.
From their stance on self updating web apps I would steer clear.
This really is the only reason. In other languages (like Python) where it's possible to mock/patch pretty much anything, I don't steer away from static class methods (or pure functions for that matter). In PHP (and Java/C# I guess) you have to work with what you have, which means you stick to the things you can easily mock/replace in tests - that is, class instances and dependency injection. I'm working on a large legacy PHP codebase right now, and static method calls are stopping me from bringing it under unit test coverage. There are techniques to work around this (like creating a static proxy for a real instance), but when writing new code just avoid it altogether.
Thank you, I'm glad you liked it :) The system you describe seams a wild beast to handle, especially if you are the only developer on it. Good luck!
Yes your're right, one of the point that I'm trying to make in the article is that it will be easier to do this kind of things with a REST service. You could plug your importer/exporter/whatever easily as you would have a well documented platform to interact with.
Don't use `?&gt;`... At least not in your examples. This is bad practice. Also... function selectAllTasks(JSONModel $controller) { Is it an some-kind of query-builder? Why is it named as `controller`? The same thing with class names... Why it called JSONModel? Why SQLAbstract instead of SQL interface or something... Also in your first example you preform two SQL queries... why? Anyway, look at [Spot2](https://github.com/vlucas/spot2).
Frameworks usually offer a lot of pre-optimised functionality that helps you out a lot if you do larger projects. Sometimes reinventing the wheel is a good idea, but most of the times, using the established version is just the faster, easier and more reliable way. In the end, the algorithm of your main function and its runtime contribute more to the weight of the application than the overhead. You don't need to optimise every bit and byte. done is better than perfect and sometimes the extra time spent to do more optimising isn't worth the result. But if you want to do something perfect, release it for a framework, so everyone can use it. 
You might want to check http://elcodi.io/ It's an Open Source e-commerce platform base on Symfony2 bundles.
I havent measured it, if it took 0.1s to start a new process then my solution sucks for "quickish" tasks and I can see the advantage of job queues. I really want to measure how quick I can start X tasks, I might test this with a bash script... That would be quite fun. But for the API the smart thing is not to background it as the HTTP stack is going to be pretty efficient if this process is pretty quick. What I have been caught up in talking with 3rd party API's eg sending email via mandrill which takes about 1s to respond. These things suck and hence I have talked a bit more about backgrounding tasks and getting them off the HTTP stack. Short answer, I will use RabbitMQ or Gearman, I just dont want to complicate my app right now. 
I'll definitely take a look, thanks
The server being Windows server 2003 running on a mac pro i assume?
I think the use of the term "raw PHP" is a little bit odd. What are we comparing here, a framework that does nothing, to a PHP script that does nothing? Hello world examples? An entire application? Usually the last of those options would be the case, and at that point, you will have had to build most, if not all of the things that the framework would provide. I think you make an important point about potentially using a micro-framework, but I'd like to expand on it. It's really quite simple: use the right framework for the project at hand. If you're making a really, really simple app, maybe an simple API, a micro-framework may be great. If you're making a big application, then you'll end up turning that micro-framework into a fully-featured one anyway.
Even then, do something like this in that case: $result = $default; if ($blTest) { $result = $post; } else if ($post === false &amp;&amp; $session) { $result = $session; } return $result; EDIT: elseif!
I've actually been thinking about bulding an ecommerce solution along similar lines and I've done some research into the area. Basically, the solution is to crawl the site to create HTML versions of your pages, and serve those up to search engines. It's described fairly well at http://builtvisible.com/javascript-framework-seo/ and https://developers.google.com/webmasters/ajax-crawling/docs/getting-started - there are also services like [Prerender.io](https://prerender.io/) that will generate these pages for you.
Take a look at Moltin. That is a shop REST service. It may give you some ideas.
-1 For posting a tutorial to w3*anything*.com
PHP can't unload a class, so you can't update a class you've already loaded, unless you rename it. Even if you rename it, the old one will stay in memory, your process will keep bloating up holding old code it doesn't use. So instead of all this, make your process capable of saving progress, gracefully shutting down so you can restart it. Then all of that stuff you're thinking about won't be needed. Alternatively (or additionally) consider splitting your app in two: 1. The daemon which consumes tweets and sends them off to a processor. The daemon should be kept so simple and dumb you'll (almost) never need to change it. 2. The processor which will have the bulk of the logic, you'll change it often, but it can be stopped and restarted for a code update (and the daemon just buffers, waiting for the processor to restart and start accepting tweets again).
Frameworks have relatively slower execution speed but enable faster development. Also, it's usually cheaper to increase server specs than to hire additional coders, so keep that in mind too.
This post made me go look around for information on Reactive Programming and I found [this interesting document](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754) for anyone else in the same situation. So...I'm only through the first quarter of this article and as I read I was thinking that RP would be more javascript oriented. Obviously this can't be the case, or else the Rx libraries wouldn't have a place. Is RP a design pattern, similar to MV* or ...something else?
 extract( $_POST ); //!!!
Just thought I'd point out that it appears this library hasn't been maintained in more then a year or so... If you want to go down the reactive hole, perhaps find a maintained library.
Interesting. I'll take a look, thanks
&gt; The most common/biggest mistakes I've seen are related to abusing the ORM. I really Eloquent used the data-mapper pattern instead of Active Record. I'm actually very interested in [Analogue](https://github.com/analogueorm/analogue), I just haven't had a chance to try it yet.
+1 for prerender.io :)
There currently is a course running on coursera on Reactive Programming: https://www.coursera.org/course/reactive 
Yep, we fell into that trap, too. Tried so hard to stick to Eloquent that we had some convoluted constructs when a single tuned query was much simpler and far faster. Also, `$model-&gt;hydrate($array)` is completely undocumented. Also also `$model-&gt;setAttribute($field, $val)`
Nice catch, I didn't even think - for once - to check commit dates
Rx is a language agnostic implementation of FRP (Functional Reactive Programming). Rx has implementations in several languages (Javascript, Java, .NET, Python, PHP, etc). Its concepts include Observables (including their operators), Observers, and Schedulers; everything is a sequence. FRP is a paradigm (different style or coding and thinking) not a pattern. MV* is an architecture pattern on how to structure an application. I wouldn't compare the two of them. 
Hi Andrew!, Thanks for your opinion about my work. Yes standard is bit kind silly made about the whole logic... The idea why I taken out fetching from the CacheItemPool::getItem is because in standard they saying that CacheItem should be portable and do not depend on CacheItemPool. But it has some quirks no checking for cacheitempool assigned in getter and similar things... But main point was deferred loading only then needed... Imagine you load 100 items and everyone is getting load then you really need just several of them... :D Yes I will write topic about my experience on PSR-6 then I have time as I am working now on other stuff (PHP Forking, Inter-Process Communication, IPC Event Dispatcher for my php http server (Ruby Unicorn Clone :D)) I do not wrote memcache driver because I do not use it anymore. Maybe in future with unit test I will write them. For expiration I would make separe item in cache store it there. I have looked at your library already then I was working on this :)
We have a deploy task in our ant build script, and it roughly does the following: * hg archive to a build directory * composer install --exclude-dev --optimise-autoloader (not sure if that's the right syntax, but you get the idea) * shell script to run through the vendor directory and get rid of anything that doesn't need to be there, mostly test roots, .hg or .git directories for our internal packages etc. etc. * rsync to staging server. Writing the shell script is the most difficult part, and you need to keep it up to date (although luckily, almost every packag I've come across has distinct test and source directories).
Short answer: restart the process. Really no way around it. Long answer: Using some sort of process control system is going to be really important, if you're not doing so already. You can have the master spawn (and manage) children with the `pcntl` extension and have the children work in the background. You can have your deployment process send a signal^1 to one of these processes to cleanly terminate and then respawn the children on the new code. You could alternately set up some sort of polling interval to `realpath()` your `current` directory and reload if it changes, but I'd advise against that (that's approximately what was done where I used to work... very messy) The bonus of using a worker manager is that if your long-running process dies, it will be detected by the manager and automatically restarted. This should leave you with nearly zero downtime. This is the model that nginx and php-fpm use. I wrote [a library](https://github.com/Firehed/ProcessManager) to do this if you'd like to experiment. It's quite stable as long as you're not doing anything stupid, as the only thing it does is manage workers (mine's been running for over a year without interruption). You'd have to extend the abstract class to fit your use-case but I don't think it should be too complicated. I think the examples may be a bit out of date, but reach out if you can't figure it out and I'll see what I can do for you. ^1 : `SIGHUP` is common for this, although I feel that `SIGUSR1`/`SIGUSR2` are semantically more appropriate. I typically reserve the latter for logging `debug_backtrace` to a file to try diagnosing a hanging worker; combined with `strace` you can typically get really good information.
tl;dr ➡ *We can use "if" in a template to conditionally include a field.* I think for more complicated scenarios it's better to have a snippet for every field and just enumerate which fields you use in the form, loop and output them. This way, we avoid the risks of our forms turning into mazes of ifs (been there, done that).
How about using something like Odoo (formerly OpenERP) as an ERP backend and using a modern framework (SF2, L5, etc) where you can then leverage Odoo's API? I always hated the mix of ERP and front-end.
IIRC the composer people specifically said they didn't want to do this - and I kind of see their point. I've just looked, and we actually removed this step a while ago - we decided it wasn't worth the hassle. Disk is cheap, and since few files change between releases in the vendor dir, and we use rsync, deploying is still very fast.
The term singleton has become overloaded. There's nothing wrong with something *in your app* returning one instance of something *from a library*. Some people call this "a singleton". The problem is when a class *from a library* decides to only allow one instance *of itself*. That's also a "singleton" and is actually what "the Singleton pattern" refers to. It's a problem because an app should have control over the lifetime of the objects it uses. A library has no enough knowledge to decide how many of itself an app needs, when it should be created, when it should be destroyed etc. And frankly there are few reasons for a class to want to enforce itself as a singleton. It's not like "making a single instance of something" is so much code one has provide the logic for it in the class itself: class App { protected $i; protected function getOneOfSomething() { return $this-&gt;i ?: $this-&gt;i = new Something(...); } } Tada.
Thanks for your extended explanation! I was trying to decide how I wanted to explain it further, but fell short. A lot of components in ASP.NET are singletons, which hurts the ability to do unit testing and dependency injection around routing/views. But as you mentioned, singletons can be a good idea in the application scope.
My biggest mistake was not checking the clients hosting environment before I started using 4.2. They were running PHP 5.3 :(. Thankfully it wasn't too difficult porting it back to 4.1. Other than that I attempted to use Ardent to throw validation into the models. Big mistake but came to a nice happy medium by going back to Eloquent and storing validation rules in the model.
Can you install a work queue? (like Beanstalkd or Gearman) ... Cause I would suggest keeping the phirehose code light, and that way, if you need to make changes to a database or something, you won't have to stop the phirehose code. As someone who is currently working with the current Twitter Streams, that is something that has helped me a whole bunch.
I've found that having any sort of 'if' logic in a template (or any sort of HTML) leads to problems down the line. There's almost always a way to extract the logic to somewhere better (like the server code or javascript).
Will look further into this but the first thing that came to mind is that mysqli only works if your server/host supports [php version 4.1.13 or newer](http://www.w3schools.com/php/php_ref_mysqli.asp). Might want to check that! Will get back to this.
With the clients available now, I don't see that happening :)
If 80% of your requirements are solved by a stock WordPress install, 10% are from community-provided addons, and 10% custom work, then it makes sense to use WordPress. If you're doing anything where peoples' lives or livelihood is at stake, however, I would recommend hiring an appsec-savvy developer to build your project.
We care. But our clients don't want to pay for it. They want it pretty, and they want it cheap, and they want it now. Secure doesn't even enter the equation.
What in your statement prevents us from investing our time to build tools that make it easier to do the secure thing than to do the insecure thing, then to cultivate habits that support a better security hygiene? Your clients might not care, but neither do blackhats care about your clients' livelihood.
The fact that we don't get paid for it. I've gotten really cynical about trying to add enhancements to code that they clients haven't specifically requested. Sure, it will help long-term, but short-term I need to pay the bills. If that's not bad enough - try getting QA to approve including the code, let alone their testing cycle.
What I try to do is add to our "best practices" so that any new code that gets written, or any old code that gets touched, is repaired and enhanced to the best of our knowledge and abilities. "Built SQL" is not allowed in our code - everything goes through either stored procedures, or if it's new code, web services. This slows down development a lot, but it improves security as well. I'm trying to migrate everything to HTTPS, and it's still a struggle, since I have to integrate with IT to get certs. We also have a lot of third party code, which I keep updated and keep my fingers crossed that nothing blows up on my watch.
Why? Because our clients don't "see" security issues. They see bugs. They see missing features. They want that shit fixed yesterday. They don't know, care, or understand that typing `&lt;script&gt;` or `DROP TABLE users;` into that textbox is going to cause something bad to happen. How do we justify these costs of hardening security to managers and clients? There will be literally no visible changes to the platform. What if the entire platform is behind a login wall, and only a few hundred people have access? Why would people that are paying to use the software try to destroy the software? What developer enjoys working on fruitless, thankless, security issues when they could be building cool new shit? And hey, who ever puts a single-quote in their name?
One reason tends to be the "very special field" where the products we ship (computer programs in general) lives. In this "very special field" there are no rules and the adversaries can do whatever they can come up while trying to break the target. This coupled with possibly _complex_ problem domain (i.e. with PHP you need to now the language quirks, problem complexity, documentation complexity and every single bit and piece which could turn into a security hole - some way or another.. and so on) makes it very easy to just "let it slip". Especially when the program size grows, it becomes more important for the programmer to be "security minded" (it requires a special mindset an a lot of dedication) to be able to keep up with the bad guys. No wonder it may not be the thing for every programmer out there. One may get along quite well (at least in certain situations) just by using good tools (i.e. audited components to build with) and best practices (without being especially security minded), but the bottom line is that it doesn't matter if there is just one hole or if there is 100 holes, _the weakest link is all that matters_. And there could be very well the remaining 1 hole open even if you used well audited components and all the best practices you could find from "best practices sites". This is ultimately hard and sort of impossible problem.
Because I use a PHP framework that has security/sanitizing as a core way of doing things, so I can be pretty confident that my inputs will be stored and retrieved with proper escaping, and so much more security features...
This approach only covers one attack vector. It won't help against xss and csrf, just to mention some. Frontend/web devs cannot be ignorant about security, period.
This is a dangerous assumption, as the recent WordPress plugin breach showed. You still should understand what's happening there and what not (not saying that you in particular don't)
From reading the other replies, looks like I'm one of the lucky few. We have regular pen tests performed on our SaaS web applications - no, not just running an automated tool, a very good security professional comes into our office for a week and tries every which way to find security flaws in our applications. Because of this, we practise defensive programming - when adding a new feature we're primed to think about potential security issues, read up on existing, new and emerging threats, make sure we're covered. Oh, and if a vulnerability is discovered? Well - we've got 28 days to fix it and get a new release deployed.
What's this "we" stuff you're talking about? I take security very seriously, and so do many others. Trying to make it sound like every developer doesn't care while simultaneously trying to appear like some sort of paragon of programming purity is stupid.
I am ever so slightly envious of your situation. 
Did you do anything special to integrate Doctrine? Also, how do you handle unit testing - specifically ensuring migrate, seed, and doctrine all use the same in memory sqlite db?
Ditto for me.
What do you mean by "web services", in this instance?
Don't forget to use preg_match_all instead of preg_match if you do. :)
Can I ask why you want to replace the invalid parts of the string? And where that string originates from? To me the simplest solution seems to explode the string, iterate over it, then remove the keys of alpha strings that arent months: &lt;?php $stringParts = explode(' ', $date); foreach ($stringParts as $key =&gt; $part) { if (ctype_alpha($part) &amp;&amp; !in_array($part, $months)) { unset($stringParts[$key]); } } $date = implode(' ', $stringParts);
It has its downsides too! Sometimes we've got commitments to getting features out (large SaaS application with ~30 million users) and we have to move things around, but on the whole, I love it.
People use "we" to justify their own action as a general notion. Dont do that =\
I always wonder, where do you guys read up on those threats? 
Yeah... The reason type3 exists, is that companies can hire "people who know typo3", instead of webdesigners... 
but WP plugins are not going to use your SQLAbstract lib even if its installed. So it won't magically fix unsafe plugins
Certainly not little bobby tables: http://bobby-tables.com/img/xkcd.png
Theyre talking xss, sticking script tags with malicious code into an input, somewhere that it will be displayed back to another user of the site.
True. also: * it's hard work to understand * it's not *cool* to be the health &amp; safety guy * It doesn't make any money directly (a general problem with IT...) 
I had to stop reading the code of the framework I had to use. I was pure horror and I didn't get time to improve it. So I just stuck to the docs and pretended everything was fine. Yii is not nice.
wow, much privilege, so triggered [](/ssdoge) 
Maybe it's confirmation bias but I feel like I see security flaws in .net sites a hell of a lot more than PHP (particularly plain text passwords).
Well put, but from my outlook, the race to the bottom is exponentially speeding up rather than slowing down and improving. I'm not optimistic in the slightest.
Have you looked at WHSuite? They use a number of Symfony packages and use an in-house composer based framework.
Well, for anyone who is interested (I sure am--I wondered about it, but beyond the basic sanitization I wasn't sure how to prevent insecure attacks against your scripts--I found this website that appears to have a lot of interesting PHP security-related things. '[Cheat sheet](https://www.owasp.org/index.php/PHP_Security_Cheat_Sheet)'.
&gt;My site has no SSL Then your site should not be accepting sensitive information of any sorts, especially not payment information. 
payment form without ssl? thats a big big NO NO NO i can tell you what we do with certain types of account data login ip) keep 30 days, then keep hashed for up to a year, then delete basic account data (adress etc) keep until account is deleted basic payment data (adress etc) keep 10 years, then is deleted enhanced payment data (creditcard data, paypal email adress, bitcoin adress) keep for 10 years with a bi-directional encrypted format, where the key is splitted among 3 places (code, filesystem, database) we will moving our site to full SSL within the coming year ... currently everything is ssl once a user logs in - no form ever submitted on a site, even if its just a search, should be non-ssl nowadays. 
In my [anecdotal] experience, from a business perspective it usually comes down to a few key factors: - Non-technical people drive product development - Managers - Sales - Marketing - Time = money, and unless there is a direct ROI, things like security (and testing, documentation, etc) are viewed as "nice to haves" (if you're lucky) - A lack of a standard body devoted solely to security in PHP - If there is one, they should do more to promote themselves to the community as a whole (a cursory google search didn't turn up anything active) - Opinions are like PHP code, everyone has it, but it's usually a hodge-podge of copy-pasta that is either inherently misinformed, or out dated/irrelevant
Your assumption is correct, as of today. I'm undecided whether or not I will continue to open issues when I find flaws in the future. I have a mid-2014 list on my personal website of my open source contributions which covered most of the issues I raised back then: https://scott.arciszewski.me/open-source/ Additionally: * **Laravel**: https://github.com/laravel/framework/pull/8488 - PHP Object Injection in Laravel 4.1, 4.2, 5.0, master * **Symfony**: https://github.com/symfony/symfony/pull/13984 - `mbstring.func_overload` could weaken Symfony's constant-time string comparison utility (in the end, they accepted the patch that /u/ircmaxell wrote, however) Actually, it'd probably just be easier to link to http://github.com/sarciszewski/ since most of the projects I've opened issues and submitted patches to are on Github and you can see my contribution history.
i care about it
You've already got a lot of good information here. Another way to view them: they're in some way a camouflage for globals (or: global state). And there's a reason we don't use globals ...
That would be awesome. If you need a website, I know some PHP. 😏 In all seriousness, this is a great idea. Getting together a consortium of people - hopefully people who can keep their ego's in check and have thick skin - to comb through the dredges of the internet and PHP source code to review issues. They could also be tasked with creating some sort of standard "checklist" of common problems, publish whitepapers on the theory of security, as well as real-world practical implementations of security practices. My hope for such a body is that they would strike a good balance between OSS PHP and Enterprise PHP, for both modern and legacy PHP applications/development. I, for one, would love to be a part of this group in some way or another.
If you absolutely cannot use an SSL certificate, please consider using an off-site payment processor like PayPal Express instead.
Downside: harder to analyze code problems in 3rd party after upgrade. And once you start to have a lot of dependencies this will become an issue. Similar why you want to commit your vendor folder once your project grows (e.g. deterministic multi-server deployment)
I already have the domain wpatchmen.com from an earlier iteration of this idea with a narrower scope lol
Note that it is absolutely against your credit card agreement to EVER write the CVV code to disk (or paper). Even to a swap file. EVER. NEVER. If you store it at all, it must be kept in volatile memory for as little time as possible. Also keep in mind that there are encryption requirements for the credit card number itself. https://www.braintreepayments.com/blog/pci-compliance-basics-for-credit-card-security Whats the penalty for failing to failing to comply? Glad you asked! The laws surrounding credit card transactions in the United States has changed to protect the consumer! Moving forward (effective sometime this year), any company who's gets their customer's credit card information stolen is responsible for reimbursing the consumer (the credit card company is no longer liable). So to put it bluntly: if your shit gets hacked and stolen, it's on you to pay for the shit the scammers bought. This is to encourage appropriate credit card security practices. If Home Depot and Target got their customer's data stolen, you better believe that yours will if you insist on ignoring contracts, standards, and best practices. This is why you've recently seen many credit card companies mail out new cards with chips and many retailers get the new terminals to support the new cards. So everyone has focused on payment processing so far. Additionally, any time you handle PII (Personally Identifiable Information), you need to follow best practices and security standards to keep it safe. Names, addresses, e-mails, and phone numbers are all PII. If you don't want to put in the work, I highly recommend you choose a payment processing vendor. In fact, I recommend that anyway. Both PayPal and Amazon offer easy payment solutions. When shopping, I prefer Amazon's over anyone else's since I use it anyway and it has my personal and business card on file, but there are more good solutions out there than just those two.
Appserv was last updated in 2008 and the stable release comes with PHP 5.2.x, I think it's a bad idea to suggest people use this.
This thread has been linked to from another place on reddit. - [/r/asterisk] [We're the FreePBX Dev team, along with Matt Jordan from Digium. We're over in PHP doing a random and ad-hoc AMA.](https://np.reddit.com/r/Asterisk/comments/34el10/were_the_freepbx_dev_team_along_with_matt_jordan/) - [/r/voip] [FreePBX dev team doing an AMA over on /r/php right now](https://np.reddit.com/r/VOIP/comments/34eeit/freepbx_dev_team_doing_an_ama_over_on_rphp_right/) [](#footer)*^(If you follow any of the above links, respect the rules of reddit and don't vote.) ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
I have a ton of questions that would fall under billable support. I'll leave those to the side for now. First, thank you for your continued work and the freepbx product line. Can you shed light on why system messages have to be mono (8k) and "crappy". Or, am I doing it wrong? Also, whats the best way to use the system's soundcard as an output for overhead paging with the latest freepbx release? Again, thanks for providing a very solid pbx system.
Hi guys! Where are you based?
When it comes to CC payments, most providers offer APIs for verification and payment-processing. I'd strongly recommend to follow that. 
&gt; I have a ton of questions that would fall under billable support. http://webchat.freenode.net/?channels=freepbx Just because it's commercial doesn't mean we won't help 8-) &gt; Can you shed light on why system messages have to be mono (8k) and "crappy". Or, am I doing it wrong? I don't understand what you mean? What system messages? The notifications in the dashboard? &gt; Also, whats the best way to use the system's soundcard as an output for overhead paging with the latest freepbx release? The 'Console' device (chan_alsa, I think) is pretty much the only way. Saying that, it's often cheaper and easier to use a Pi or something, and send signalling over SIP. 
I like this because it's short and understandable. The regex thing is bugging me, because it seems like something I should at least understand how to do, even if I don't end up using it in this particular case, but this code is probably more readable for future programmers (although this is a small project that no one else will probably work on). &gt; Can I ask why you want to replace the invalid parts of the string? And where that string originates from? I'm doing a bad thing. I'm treating a text field as a date field and trying to accept arbitrary user input. I'm parsing [GEDCOM](http://en.wikipedia.org/wiki/GEDCOM) genealogy files. I'm geocoding the places in the file and converting them to GeoJSON so that I can put them in CartoDB and animate the migration of the family tree in the GEDCOM file over time. Everything, including date fields are text strings. The conventional way of listing a date in genealogy is "day 3-letter-month year", where you put the most specific info you know. Most people and software do this most of the time. However, being text fields anything could be there and I'm trying to get the most date-like thing I can find. 
I applaud your efforts and hope that you do continue to find and submit bugs to these frameworks. In reality, because of the efforts of you and thousands of others doing the same thing, frameworks can provide better security than many php developers could ever write on their own.
Are any of you Duke fans?
It might be worth noting that the level of care is going to be very highly context specific. For your own interest I work with a group of very talented developers in a team with an extremely high focus on security, a lot of that comes with the territory of work. As in, regular security briefings, OWASP refresher sessions, PCI compliance and police background checks are all necessary parts of doing the best we can to keep secure. The human factor is always the least secure, and we do our best to abstract the humans away from anything that needs to be secure. As far as actual system/application security goes, we are all very concious about anything we develop and the various attack vectors we're aware of get spread through the chat and communication channels. We not only patch everything (like, everything), but when a patch comes in for a vulnerability we get together and explain what it was that was vulnerable, why it was, and what was done to fix it. We often contribute back to the community with security patches and fixes of our own as well. But previous jobs have definitely been lacking in focus on security. A lot of it comes down to pure naivety. PHP is a fantastic entry level programming language, and much of the community are just people plodding away with the bare minimum making fun stuff. They might escape some HTML here and half-bake some SQL injection prevention. But they're simply not aware of the majority of attack vectors and they probably don't think it's worth it. For a lot of them it probably isn't yet, as their various toy apps will get a handful of views and the worst case scenario someone will break them, but no real harm will be done. If you have that attitude in an application that contained sensitive information, then you should stop right now, read the OWASP top 10, assess your application yourself and then get an third party to assess it as soon as you can. The long and the short of it is, you are taking responsibility for others information and they are trusting you with it. If you don't want to deal with that commitment then sell your app to someone who does before you get sued for all you have and more. 
&gt;I don't understand what you mean? What system messages? The notifications in the dashboard? system recordings / moh (PCM Encoded, 16 Bits, at 8000Hz). Which always gives me a muffled sound file. I thought at one point (years ago), I read that this was specific to asterisk...but I could be wrong. 
Its dangerous to assume that ANY WordPress plugin is secure. That is like the wild west of php development. I am not a WordPress hater because I know it has its uses, but assuming the plugins you using are secure is foolish, I agree.
Who is your daddy, and what does he do?
I use symfony at work, but I still feel like I need to know more about security. Our sysamins deal with server security, and I know the basics of safe DB interactions and whatnot, but I feel like I don't know everything to look out for in my own code. I'm going to talk to my boss about some training on this I think.
Please, please, please continue to report bugs. I know it takes a lot of work to document things like this, but it's incredibly important for the rest of us who aren't as skilled as you. Thank you so much for reporting the ones you have already.
Wow this can't be for real? Hire a company who knows what they're dealing with. You can't just make things up as you go when dealing with CC details... if you are this inexperienced you should just use something like shopify etc
Hey, /u/qwell, where's my hammer? I can't see it anywhere.
Yup, BTW, couple of those \b are likely not needed. Second one, as the first one covers for it, and the last \s*\b can be replaced with (?:\s+|$), but I just laid it out to be logically the way it's in my head. When unsure, wrap in \b :P
A few resources off the top of my head: * [Paragon Initiative Enterprises Blog](https://paragonie.com/blog/) - I'm publishing regular blog posts here on this subject. [This one is good place to start](https://paragonie.com/blog/2015/04/secure-authentication-php-with-long-term-persistence). * [Enigma Group](http://www.enigmagroup.org) - Learn security by hacking a web application * [Hack This Site](http://www.hackthissite.org) - Ditto * [Web Application Hacker's Handbook](http://mdsec.net/wahh) - An actual book, if that's really what you want * [OWASP's Curated List of the Top Ten Web App Threats](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project) - Just know that there are much more than 10 risks to consider! Ranks 11 through infinity are where I tend to focus ;) I'll probably put together a curated list later tonight, since they're all the rage lately.
Thank you!
You're taking on more work than you expect. Designing a secure &amp; performant template system requires good understanding of how parsers are written, and great intuition about eliminating security attack vectors that could compromise your server. BTW, the reason engines convert to PHP first is for performance. I'd propose you check existing template systems like Twig. It has ifs, loops, and so on. Look for keyword "sandbox", a sandboxable template system means effort has gone to prevent attacks when untrusted users provide you with template code to run.
I appreciate the good work you're doing, but the "security flaw" you're mentioning in Laravel only exists if the user intentionally opens security holes in the framework. To quote Taylor Otwell in the GitHub comments you linked: &gt;Yes, people would vulnerable if they used cookie session driver and for some reason decided to totally disable cookie encryption by removing that middleware, or of course not changing the APP_KEY in a production application, which we have several warnings against in the documentation and even set for you on installation via Composer and Laravel installer tool. 
G711 is 8khz. G722 is 16khz. Significantly better audio. Not CD quality, but not two-tin-cans-and-a-bit-of-string quality that uLaw and aLaw is.
I think I can speak for many of us here when I say that I always, and have always, done everything I can to make my applications as secure as possible. 
Edit, the next day: It turns out there's a couple of bugs with unsigned module notifications, that *no one* has reported. Everyone's just jumped to the assumption that we're inherently evil, rather than going 'Hey, do you MEAN to send us an email every single day?'. [There's a ticket open here](http://issues.freepbx.org/browse/FREEPBX-9190). We, the developers, get twelvetybillion emails from all our dev servers every day, so we haven't noticed this, and we're amazed that no-one has reported this as a bug previously. Below is the original discussion. I've seen it. I've given up on it. Anything Ward posts I'm considering as just trollage. The whole issue is based around Ward trying to find fault in boilerplate legal code, the same boilerplate legalese he has on his own stuff anyway. (Really, it's boilerplate. As soon as we have to *actively* do something, rather than just having it automated, or click through, we have to add that. Everyone does that, and I can happily provide links to AWS, Google, etc) &gt; are you considering removing or modifying the indemnification section Yes. I've asked for suggestions numerous times. No-one has offered any better suggestions. Which, I assume, is the reason that this is just normal boilerplate. &gt; Also, how has the new ownership by Sangoma affected the project? That was actually a bit of a worry for me. Being that I'm in Australia, I'm already inherently out of the loop, and having an added layer of bureaucracy was a significant concern. However, it's turned out really well. Sangoma have basically said 'We love what you're doing, keep doing it.', which has been a relief. 
That's it. You'll have to re-record your announcements, but that' pretty much it, if I remember correctly. Feel free to open a bug if it DOESN'T work as it should. High quality audio is something that I personally care about.
Want to add ss7 configuration support? ;)
I see a common theme popping up in the comments of this thread that bothers me. There seems to be a lot of people implying that "clients don't pay for security" and features and less bugs are the only things they want. This is operating on a flawed assumption - that security is an add-on. Security of an application should never be considered something that's bolted on at the end or a "feature" of the system. Take a look at some of the most common prevention methods for the biggest attack types out there. What's one of the major things PHP applications can do to prevent Bad Things from happening? Filtering/Validating input and Escaping Output (FIEO). Last time I checked, this isn't something that only relates to security, it's a good development practice in general. Don't you want to be sure that the ID value you're getting is actually an integer and not a string? If not, you might be doing it wrong. Security is not a "feature" to be added to a system. It's a way of development. There's *way* too much emphasis put on "solve this vulnerability" kinds of things and not enough on making these checks and practices a normal part of a developer's workflow.
We're using the commercial version currently. Thanks. 
So if nobody is going to use it...?
&gt; who should be using FreePBX Everyone! &gt; who shouldn't be using FreePBX? No-one! 8-) We hit a scalability limit at about 5000 extensions. Amusingly, yesterday, we spent a bunch of time with /u/mattcjordan figuring out some bottlenecks, and we've got our 'worst possible' reload times down to about 3 minutes, from the 14 minutes it was the day before yesterday. It was a combination of FreePBX having sub optimal code generating the configuration files, and then Asterisk parsing those configuration files poorly. Basically, if you want to have more than about 10,000 extensions, it's going to get awkward. 
Love it! Thanks!
Huh, really surprised you would say that, since Ward (I assume you mean Ward Mundy of the Nerd Vittles site) has probably done more than anyone else outside of the FreePBX core group to promote FreePBX over the past few years, what with all his tutorials and his builds of "PBX in a Flash" and "Incredible PBX" which contain both FreePBX and Asterisk. Also, I thought I had read somewhere that he is a lawyer, though I may be wrong about that. But he was not the only person in that thread who seemed to think that indemnification section went far beyond anything necessary. Maybe the reason no one has offered better suggestions is that most people are not lawyers, and don't know how to make that section non-objectionable. I read this post https://www.dslreports.com/forum/r30022649- which contains the actual text that some have found objectionable and it did seem rather unreasonable to me. After all you are basically asking people, who are attempting to contribute code to make FreePBX better, to sign a document that could potentially cost them everything they own. IANAL but it appears to me that this isn't an agreement that the module signer won't sue Sangoma, which would be more in line with standard boilerplate language. Instead, this is an agreement that gives Sangoma an easier path to suing the module signer. So, why would anyone want to contribute a module if they are forced to sign something like that? IOW it goes far beyond an agreement not to sue the FreePBX owners if the software fails to perform, which AFAIK is the point of most "boilerplate" language.
Contributing to FreePBX requires no indemnification, (see http://wiki.freepbx.org/display/DC/Code+License+Agreement) having your third party module signed by the Project (that we have no control, input or idea what it may be) does require indemnification, there is no way any individual, or corporation can assume liability for someone's third party application. The module signatures are in place as a security protection mechanism, and not designed to preclude any outside development. It's opensource if you have a better way of doing something please submit at issues.freepbx.org 
Where in Canada? I'm in Montreal :)
&gt; this isn't an agreement that the module signer won't sue Sangoma That's part of the click-through standard licence. &gt; this is an agreement that gives Sangoma an easier path to suing the module signer That is there to cover the event that Sangoma gets sued for something that that the module signer does. This is **exactly** what a 'hold harmless' clause is, but we explicitly spell it out. &gt; So, why would anyone want to contribute a module This has nothing to do with module contribution. That is for someone who does NOT want to contribute a module, and wants distribute it themselves. &gt; I thought I had read somewhere that he is a lawyer This is why I say he's just trolling. A lawyer should know what a Hold Harmless clause is. I have NO IDEA why he's suddenly going 'FreePBX is evil', when I spent almost a full week making sure that this was all highly documented and almost copy and paste-able. http://wiki.freepbx.org/pages/viewpage.action?pageId=29753662 
We jumped to web 8.0.... 13 will be all TWBS and quite a bit more modern. Also it is being skinned with a consistent look and feel. Anyone developing for 13+ should see http://wiki.freepbx.org/x/goDNAQ
Yes, I can imagine that it would be. Like others here have said, however, people like you help make these tools a lot safer for everyone with your persistence and knowledge. Thanks!
I tried Laravel at 4.1, and switched to Slim. Hearing about 5.0 I tried it during its development and loved it, but the lacking documentation made it challenging to complete a project. With 5.0's release I got a site done in about a month. Lumen's announcement was exactly what I was looking for. I had modified Slim to use fastroute, and having Lumen come with it built in was a dream come true. I built [gosniffer](http://gosniffer.me) in Angular and Lumen in two days. I ran into some problems trying to extend blade, but a service provider has fixed that. While I still haven't figured out a simple way to load singletons in lumen. I'll worry about that in my next project.
Also: I was looking through this list. The blog (to some extent) The Engima Group, Hack This Site, and the Web Application Hacker's Handbook all teach how to hack, through which you will learn how things get hacked. This is a lot to learn and I have a life outside my job. Is security a risk that can be mitigated by following best practices and knowing the theory but not necessarily the execution, or do is it important to be able to defeat security (not just know the theory) in order to create a secure site?
&gt; It's not that I think the community doesn't care at all, I'd just like to know why it doesn't care more. It really comes down to the developer. Each person has different expectations for security. So if anything, you question should be: _why doesn't everyone else care about developing secure applications, like I do._ I think that'd be more accurate. 
Any plans to jump to freeswitch?
&gt; What I meant was that if someone submits a third-party module, that can be viewed as a contribution to making FreePBX better. Yes. That does not require a module signing key. &gt; But if I choose to run an unsigned app from a third party, I can do that by simply indicating to OS X that yes, I really do want to run this app even though it's unsigned. That's because getting a signed key from Apple is actually quite expensive and time consuming (last time I checked). Additionally, with Apple, you need to have a complete development environment set up to actually CREATE an app, and if you look at that dev environment that you set up, you signed **exactly the same** indemnity form to create that dev environment. We don't do that. We only need an indemnity form if you want to distribute modules to secure systems. Our dev environments are 100% open source, and fully documented. Anyone can set one up, without any additional indemity As I said, it's one person stirring up trouble and making a mountain out of a molehill. I really am somewhat over discussing this, too, but I'm trying to do the right thing, and engage with the community over this. No-one's offered any better suggestions, and, as I said earlier, this is exactly the same agreement that massively huge companies are using, as opposed to our tiny little one. 
&gt; This is why I say he's just trolling. A lawyer should know what a Hold Harmless clause is. I have NO IDEA why he's suddenly going 'FreePBX is evil', when I spent almost a full week making sure that this was all highly documented and almost copy and paste-able. Have you ever considered that perhaps because he is a lawyer, he's seeing a problem that you're not understanding? Maybe he's not trolling, maybe he's getting frustrated with the FreePBX people who just aren't getting it. I'm not a lawyer and after reading the actual text of the form you have to sign, I can see why no one would want to sign that just to be able to run a third party module on their own system. &gt; http://wiki.freepbx.org/pages/viewpage.action?pageId=29753662 I read that but that contains a link to the form in question: &gt; **How do I get my GPG Key Signed by FreePBX** &gt; Download and sign the FreePBX GPG Signing Agreement as found [here](http://literature.schmoozecom.com/EUA/GPG-KEY-SIGNING.pdf) and email the executed agreement back to code@sangoma.com I tend to agree that no one should have to agree to Section 7 of that document to run a third party module of their choosing on their own system. Even if I were *writing* third party modules I would not want to sign that, because it would create significant liability for me with no upside, at least not if I am giving my modules away for free. So we have two separate issues here that I think are being confused: Should a USER have to get a third party module signed, and therefore have to complete that form, to run it on their own system? I would say, "no way, Jose". This would be like Apple or Microsoft asking you to indemnify them before you could run software that didn't come from their "app store" or repository or whatever source they use for "approved" apps. Should a module AUTHOR be required to sign for a module and in the process agree to that indemnification section? I would say it should be optional. If they don't sign, then it's just like a Mac app distributed through MacUpdate rather than the Apple store. If a user chooses to install it, knowing it's not signed, they accept that risk. But you should not attempt to stop a user from doing that, or nag them forever about the fact that they have made that choice.
&gt; Markham, Ontario. Markham and Toronto are both cities in Ontario, Canada. Bugger, sorry. I try to pay attention to this 8-\ However, currently we're at Head Office, which according to Google Maps is 100 Renfrew Dr, Markham, ON L3R 9R6
Who is the sexiest on the team and why is it rob?
Please don't come and murder us. Edit: Nevermind. Forgot I wasn't still in the US.
I actually started down that path many years ago, and gave up. Of course, if someone really cared deeply enough they could do it. Hanging around in the freepbx-dev channel on freenode would be the place to start.
1. What challenges have you faced in making FreePBX work well on virtualized systems? 2. You know that "Apply Config" button at the top of the page that shows up when you make a change. Well, is there any way to programmatically trigger that event? Like say I have a plug-in application that modifies the DB and I want FreePBX to do the heavy lifting in writing the changes to the Asterisk config files. Thanks for developing such an awesome product!
I code almost everything from existing code. When I can, I move logic to libraries and clean up the old code. Login/remember me/password reset is always particularly hairy because there have been so many different owners, needs, and hands in the code.
I don't know? Have a look at FreePBX, and play around with it. If you like it, go wild. I'm not trying to convert anyone 8-)
&gt; &gt; This would be like Apple or Microsoft asking you to indemnify them before you could run software that didn't come from their "app store" or repository or whatever source they use for "approved" apps. &gt; That's exactly what they do. Uh, no it isn't. You can download an unsigned app from MacUpdate (not affiliated with Apple) or from a developer's web site and use it if you like. The first time you attempt to open it in the normal manner it won't be allowed, but you can go into Finder and open the Applications directory and right click on the app and select "Open", and then it will warn you but allow you to run it anyway. After you do that, you can open the app in the usual manner and the Mac will never give you any problem with it again, at least not until you reinstall OS X. AT NO TIME are you asked to sign a form, or indemnify Apple against anything!!! &gt; &gt; Should a module AUTHOR be required to sign for a module and in the process agree to that indemnification section? &gt; Yes. Explain why they SHOULDN'T be liable for it? Because unless he's creating a commercial module, there's no upside for him. He's making it easier for Sangoma to sue him, but there's no reward that justifies doing that. Sangoma or FreePBX shouldn't be getting in the middle of this at all. If a user wishes to use an unsigned module, you should let them do that and then say "we wash our hands of the matter". You didn't provide the software, and you didn't install it on the user's system, so you have no liability, any more than Apple has any liability when a user installs an unsigned application on their Mac. As far as I can tell, the only reason this is an issue is because unlike Apple or Microsoft, you haven't chosen to give users a way to install unsigned third-party software without being nagged about it forever after.
What do you recommend for predictive dialing?
It's a little bit of both. Sure, you can pick up PHP The Right Way and design your apps that avoid most of these pitfalls. But then again, the author of PHPTRW is also the person behind the Slim framework, which recently had a pretty obvious PHP Objection Injection vulnerability. It's important to know that these resources are limited in their utility, and their application depends on the person using them.
I wasn't going to chime in, but I do own a Mac running Mavericks, and very few of the apps I use came from the Apple store. I have never been required to send any kind of legal form back to Apple in order to use the ones that didn't, and I haven't had to "indemnify" them against anything. This is starting to smell like an attempt to shut out free modules that might offer the same capabilities as commercial modules.
Two years ago I'd agree with you about AWS, but not now. They really cleaned up their internal ports and data interconnects. We've got vanilla asterisk servers in production humming along nicely on AWS. We keep wondering if/when we'll need to migrate to network priority instances, but we really haven't had any need so far.
Thanks, you guys rock! 
***We do not require that from end users.*** Module developers can request a key to distribute their own modules. If they don't want to do that, they can submit the module to us, and we'll distribute it. Mountain. Molehill. 
&gt; Oh… so if they click that X the warning for that module goes away permanently, and never returns? What actually happens is that it goes away until it CHANGES. So if you edited an additional module, or changed another file, it would re-appear with BOTH changes, and you could click X, and it would go away forever again yes. 
Just FYI - when you say something is badly designed, you generally want to give examples. Everyone here seems to think anything that's not their favorite thing is badly designed and shouldn't be used, and opinions are like assholes.
Wow, That is a lot of hints. Does FreePBX support the new Resource List stuff in Asterisk 13? I'm a vanilla asterisk guy so Ive only played with FreePBX once or twice at Astricon.
Gotta love being lectured on U.S. law by a non-lawyer from Australia working for a corporation from Canada. First, there is a major difference between asking someone not to sue you when you give them something for free and asking an open source developer to pay not only their legal expenses but also those of a foreign corporation when anybody on the planet raises a complaint about open source modules that have been a part of most FreePBX distributions for the better part of the last decade. And the foreign corporation also has reserved to itself sole control of the litigation by third parties. Ever wonder why no individual has signed their indemnification agreement other than their own employees?? As for allowing end-users the ability to authorize modules on their own, Rob says it's too hard. Actually, a simple solution was presented to Rob and his cohorts ON THEIR OWN WEB SITE which they have conveniently ignored. It's almost as if they don't want to do it. :-) For more details, go here: http://nerd.bz/1JE42q9
This is why I'm convinced you're trolling, ward. And it's also the reason I've EXPLICITLY been trying to avoid interacting with you. &gt; to pay not only their legal expenses but also those of a foreign corporation * [Amazon](http://aws.amazon.com/agreement/) * [Rackspace](https://marketplace.rackspace.com/accept?1071456663&amp;isDeveloper=true) You've previously mentioned a couple of other places that **explicitly do the thing you're saying they don't**, which is why I'm over this. You are provably, factually, wrong, and refuse to acknowledge that. Yet, when I ask for input to address your concerns with the document, you ignore my requests, and continue attacking me. [This is standard boilerplate](http://legal-dictionary.thefreedictionary.com/Hold+Harmless+Agreement) that is put into almost every legal agreement when one party has extreme power over the other - which this is. The person signing the module has the ability to release a malicious module that only attacks, for example, PIAF, machines. Why should I be liable for that? &gt; As for allowing end-users the ability to authorize modules on their own, Rob says it's too hard. Actually, I didn't say it was too hard, I said that we'd love suggestions, as we couldn't think of an obvious way. Admittedly, we hadn't spent THAT much time on it, as it's not that much big of a deal. You were the first person to actually suggest an alternative, and that's not a bad idea. If you want to write some code that implements that, we might be able to get it into FreePBX 13, but I've got a bunch of other things on my plate to care about, too. 
I think that was what shocked me more than anything else, that they'd accuse you of being a troll when none of them are lawyers, as far as we know. You'd think they might actually want to consider that you have some degree of expertise on the subject of contracts.
I'm not a lawyer. As part of writing this up, we had a bunch of expensive lawyers say 'this is what needs to go there', and we then sat around trying to figure out the best ways to compromise. So, we have a bunch of paid lawyers saying 'This is what needs to be agreed to', and then one random guy on the internet saying 'This is terrible, because I said so'. I'm sorry if I sound annoyed, but I **am** annoyed. I have tried to have reasonable discussions about this, but the entire POINT of the agreement is being disregarded, rather then the wording of one clause. Sure, we can fix the wording. Make a suggestion, offer a change. I'm over repeating myself. Why do you have to be destructive, rather than constructive? 
Such questions are like religion or politics. I don't think you can get a large group of devs to a consensus on _______ language is the best. 
*facepalm* Yes. This is the correct answer. Ignore my comment. 8-)
I made this.
Are you seriously comparing web hosting companies, which potentially could be tricked into hosting a malicious web site, to a **user** trying to use an unsigned FreePBX add-on module on their own system without having to view incessant warnings?
Closing the warning box does not stop the e-mails, and the box comes back after **any** system modules are updated.
Laravel use some Symfony components - but not all. It has many of its own components (such as Eloquent, Blade, Cashier etc), and other 3rd party components. Or to think of it in another way - whilst their is an overlap in components - the way those components are "glued" together sets them apart.
&gt; without having to view incessant warnings? That's not what we're talking about. This whole thread is about what Ward believes is an overly broad hold harmless clause. There are no incessant warnings, and if they are, that's a bug, and I'd ASSUME that someone would have reported it as a bug by now if it was true.
When logging into freepbxdev2, did James Finstrom first use an unprivileged user account and then escalate to root, or did he log in directly as root?
Hey, been using FreePBX at a small volunteer non-profit for a couple of years - it's worked great, so thanks! Are you looking for any contributors for the website, docs, etc?
We have a security@freepbx.org email that you can use - Please don't hesitate to use it if there's something we should know?
The root account on that box doesn't actually have root access. You can tell, because James has been using it and the box still mostly works.
That's such a nice opinion you've got there.
Right in the opinion.
&gt; We have a bunch of paid laywers saying 'This is what needs to be agreed to', and then one random guy on the internet saying 'This is terrible, because I said so'. It looks to me like at least a few more than ONE random guy sees a problem in this - and that ONE that you're probably referring to used to be one of your biggest promoters, though it wouldn't surprise me if he's cooled on FreePBX considerably after the way you've talked about him. &gt; I'm sorry if I sound annoyed, but I am annoyed. I have tried to have reasonable discussions about this, but the entire POINT of the agreement is being disregarded, rather then the wording of one clause. I find it a bit ironic that you're annoyed because people are complaining about something you've done that causes them to be annoyed by banners and emails. &gt; Sure, we can fix the wording. Make a suggestion, offer a change. I'm over repeating myself. People keep offering suggestions, and you seem to want to pretend they aren't there. You just get annoyed. At the risk of being repetitious one more time, give *users* a way to **permanently** turn off **all** the warnings for a third party module they wish to install, so that they never again have to see a banner, email, or anything else warning them about that particular module. Don't require them to apply for a key, don't bombard them with annoyances, let them just say "STFU, I know what I'm doing!" and let that be the end of it. We're talking about end users here, NOT module authors. Don't even get involved in transactions between users and third parties that are not in any way associated with the FreePBX project. That's none of your concern, and if you don't butt in you would have no legal liability whatsoever, any more than Apple would be liable if I run some app they've never heard of. To ME that seems like a perfectly reasonable solution, and it's the way most other software companies deal with third party software, except in situations where they are trying to create a "walled garden" for some reason. By the way, not to argue the point, but I believe it is possible to create apps without using any Apple software that requires you to submit paperwork to Apple. For example, you can create a program using Applescript, and the Applescript Editor will let you save it as an app, and you don't even need any type of Apple developer tools on your system to do that. You seem to be really reaching to find other cases that justify that indemnity clause while trying very hard to ignore all the cases where end users, and in some cases even developers, are NOT required to submit any forms similar to that.
Thanks for the reply. It's been so long that I don't remember the details, but I think the trust factor was a big component. I wanted something that I knew worked (wasn't a PBX guy), had appliances that I could buy (can't remember what you had then, but you seem to now), and was something I could re-apply elsewhere. Actually, now that I type this... I think the problem the window of deployment. FreePBX was the last thing I looked at, and was actually interested, but given very short window of opportunity to deploy, I think there was too much to come up to speed on and too much risk to go any further down the FreePBX path. I'll look closer next time!
Thanks for the detailed reply. It turns out I don't like the Digium solution as it was implemented. Allworx is closed source, owned by Windstream now (I think), but is (more or less) turnkey. I'll give FreePBX a closer look in the future.
Huh? I think you're a bit confused! ;)
People are giving you really bad advice if they are saying you will have to "move up" to Symfony. Laravel is more modern, powerful and robust than Symfony - by far. Better IoC container usage, dependency injection available basically everywhere by default, back-end agnostic queueing, event broadcasting in 5.1, usable ORM out of the box. Not to mention you have the Lumen micro-framework for buliding out APIs and micro-services. A really nice VM ready to go in Homestead. Hundreds of screencasts to learn about the framework on Laracasts. The main Symfony components Laravel uses at this point is Symfony Routing and HttpFoundation. 
This sounds like a fun project to contribute to. Thanks for the link to the article!
All I can say is that we're owned by Sangoma, and Sangoma has FXO cards. You can even buy them directly from us 8-) https://portal.schmoozecom.com/index.php/store/displayStore 
Ah, now you're too busy. You can't make this stuff up!
Every single change in the FreePBX GUI makes the warnings reappear. If that's not incessant, I'm not sure what it. This was opened as a ticket more than a year ago.
Yeah, I was meaning to reply to xrobau - sorry.
I would be very cautious trying to get cards that are cheaper than Digium's. You get what you pay for, and sometimes the lack of cost results in spent time and frustration. That said, I used to use Rhino cards many years ago, but I think they're OOB.
aint no thangs, just layn' down some of this techo jibba jabba, connectin' with you jive turkeys
Oh I see. I thought you were living there. Was it a conference of some sort? 
Hey uh, when you're in wisconsin again, let me know. If it's anywhere near where I am at, I'll buy you a round, at the least. Love FreePBX, useability, and it's pretty stable. Much better than some other *cough*avaya*cough* commercial systems.
I think part of the equation is that every situation is different. PHP is such a perverse language used by such a wide swath of businesses, from major corporations down to little mom and pop shops without their own app dev team. For example, I'm the senior app developer leading a team of 3 at a small to medium sized company. We've been requesting from senior management getting a pen test and this is the first time in my 5 years it was actually approved in the budget. I can't imagine companies smaller than a certain size being able to afford the luxury of paying and outside entity to do an intense security test such as this. Another thing being at a smaller company, we all wear many hats. I'm lead Application Developer, but I'm also by default the DBA. We are our own testers. I have a feeling the majority of companies who use PHP are in a similar position. In companies like this, you address concerns as things crop up and put out fires more often than you get to proactively improve whole systems.
IT -is- a conference, sort of. We're all here talking about FreePBX 14, Asterisk and other stuff. You can also stalk me on [facederp](https://facebook.com/xrobau) where I tend to crap on about Roller Derby as much as other stuff. 
Thanks, i see that now. Forgive my ignorance, but what does this have to do with the agreement in question? Or do I misunderstand.
ah I see. Having used something like that in another language, how is it done without any configuration? You still need to map the interface to an implementation somewhere right? Unless you are talking about Laravel dependencies which are already mapped somewhere.
Some of us find the ORM in laravel to be the opposite of good, so please don't state your case like they are objective facts. I do like that laravel provides the queueing by default, but one can find addon bundles for symfony that do such queuing.
Just embrace Laravel. You will be so much happier :P
Hey, I make a fool of myself up there and you get insulted. How does that happen ;)? That said, let's talk SOLID. Nothing says "single responsibility" and "interface segregation" like a router class with [literally 60 public methods](https://github.com/laravel/framework/blob/5.0/src/Illuminate/Routing/Router.php). Nothing says IoC like encouraging people to pepper their code with global static Router::foo(), View::foo(), App::foo() references everywhere. But I'm sure at least in Soviet Russia they don't call View::foo(). Instead View::foo() calls *them*. Even without the facades, the container has no notion of modules at all, by the way. The router doesn't. The view resolution to files and folders also doesn't. In fact, nothing does. Yay, monolithic app architecture. BTW, when you said "IoC and SOLID" did you realize "D" stands for "IoC" already? But anyway it doesn't really matter what SOLID means, it only matters that you say "SOLID". It rolls off the tongue, and has that satisfying all-capitals look. I fully support such behavior, and I wish you hype with Laravel.
I'm just saying, it seems to score just as well as other major PHP frameworks on objective code quality scores. I'm not saying every class is perfect. But, I'm saying it's a much better framework than Symfony. It's not even close.
As someone pretty impartial, I have had failures with Digium cards. Sangoma cards I have not; on top of that, the warranty is better, the fit and finish are better, and often they are cheaper.
It is AWFULLY dated. You should go download 13, it's MUCH better. There's an alpha ISO out at the moment, which is well worth playing with.
Long time user, first time commenter on this post.. FreePBX is superawesome. I've admittedly been both a big supporter of FreePBX and hugely critical of any changes that I felt were shortsighted or were simply without reason. More often than not, i've either had someone from the dev team (1) explain the changes, (2) discuss, partially agree, and make even just small changes to resolve, or (3) discuss and encourage me to submit a patch to resolve. Hell, I have even contributed some of my really crappy code that made it in as features (albeit after it was cleaned up by a dev)! I've never felt anything was heavy handed among the group, and have always enjoyed working with them over the years. Thanks guys for being superawesome and for continuing to grow this superawesome project. 
Well, well, well... now that indeed looks much better! Oh, and here's hoping FreePBX one day gets voice recognition support (via the Google Speech API, possibly) in the IVR system! (wink wink, nudge nudge)
&lt;3 We love you too 8-)
I'd like to hear it from him. How does the process for verifying module integrity relate to section 7.1.5? Ward, your input would be appreciated. I don't want to misrepresent or misinterpret your point.
I'm honestly just messing with people because I know they get worked up over me thinking Laravel is better than other frameworks.
We'd love to, but Google are being quite limited about allowing access to it. I'm hoping they open up the ability for either us, as a project, or individual users to get keys.
**I** made this. http://imgur.com/snLplqq
wait why are you guys censoring the word 'python' now?
You need a "SabreDAV Creator" flare
I'm just messing with you :)
[duplicate]
My guess would be that no one reported this because everyone thought that was intentional behavior. And while I'm not going to go back and sift through every message that's been posted about this, I am fairly certain I do recall someone mentioning the daily emails in one of the several threads on this topic, which I've been looking at on and off this afternoon.
So no comments yet... Could you please ELI5 this whole masterlock thang?
I believe I have version 5.5.41 so I should be okay with that... would I be better off using mysql over mysqli commands even knowing that that's on it's way out?
sick of these google shills
What did you write? All I see is ******
You should make and sell these. Kickstart it if you have to
`$app-&gt;when('Something')-&gt;needs('FooInterface')-&gt;give('BarImplementation');`
**LEVEL 1 CLEARED!** ------------------------ LEVEL 2: They're both instances of class BarImplementation, and only differ by a string setting passed to their constructor (example: PDO, setting: connection string).
``` $app-&gt;when('Foo')-&gt;needs('BarImplementation')-&gt;give(function() { return new BarImplementation('foo'); }); ```
The bulk of the development in FreePBX continues around the OpenSource components, and we continue to expand the included functionality. With FreePBX 12 we added a completely rewritten User Control Panel, (that includes, presence, call history, widgets/rss feeds, settings, a WebRTC phone and more) support for Asterisk 12 and 13, Support for Asterisk Rest Interface Manager, a brand new dashboard with rss feeds, statistics, and a live system overview, updates to module admin including Beta and rollback support of modules, added htm5 playback to CDR reports, added support for direct slot parking, and we have an Alpha release of FreePBX 13 that is now available for download that is a complete rewrite of many of the core modules to provide a consistent user experience, and a base for more goodness to come. Our commercial modules are typically vertical in nature and are things like the EndPoint Manager that really require full time commercial developer support. We have engineering relationships with manufacturers, and constantly provide ongoing device support for both new and existing devices. If you look at the price structure of the modules they are very affordable. The EndPoint Manager supports over 20 manufacturers devices, literally hundreds of different endpoints can be autoprovisioned, and the cost is currently $75 per PBX. The FreePBX trademark was purchased by Schmooze several years ago now, and the Sangoma acquisition of Schmooze and the FreePBX trademark only strengthens FreePBX. FreePBX is now back by a 30 year old company with an extensive international presence and a solid understanding/experience with all aspects of telephony. As for FreeSwitch, Sangoma does have extensive experience with FreeSwitch, I'll leave it at that.
Actually yes they can. I didn't give you that one. $app-&gt;bind('BarWithFoo', function() { return new BarImpl('foo'); }); $app-&gt;bind('BarWithBar', function() { return new BarImpl('bar'); }); $app-&gt;bind('Foo', function($app) { return new Foo($app['BarWithFoo'], $app['BarWithBar']); }); Better luck next time.
Our problem was we had logic in the middle of views. It was awful. We're doing our best to fix this, and feel free to look at our stuff between 2.11 and 12. That was our first real attempt at fixing this. We're all on github, so if you want to have a look, or even better, offer some suggestions, please don't hesitate!
People just can't accept that maybe, just maybe, Laravel is **actually a productive and enjoyable framework** to develop in for tens of thousands of developers. Not only that, it scores essentially equally on code analysis metrics as other frameworks. So, saying it is somehow consistently less well designed than other comparable frameworks is simply a lie. Meanwhile, the creator of the framework literally just gets to work on Laravel full-time, his own open source project, all day if he wants to. Or just do nothing. _Something_ was done right as far as Laravel goes, and I think it's superficial to minimize that to purely marketing and hype. Perhaps Laravel is more worthy of imitation than Reddit would like to give it credit for.
If you have a bottle of scotch, your attendance is more than welcome. We discovered that everything closed at 9pm!
&gt; I have IDE autocomplete and error checking, while you have strings fed into ArrayAccess. My IDE has autocomplete too... $app-&gt;bind(Foo::class, function($app) { // Note: if BarWithFoo and BarWithBar have any dependencies they will be automatically injected, too... $barWithFoo = $app-&gt;make(BarWithFoo::class); $barWithBar = $app-&gt;make(BarWithBar::class); return new Foo($barWithFoo, $barWithBar); });
Error on line 3: *undeclared class BarWithFoo*. Error on line 4: *undeclared class BarWithBar*. Those are not classes. Furthermore, your IDE still will not know what $app-&gt;make() is returning. **BONUS LEVEL FAILED**
well shit... i wasn't paying close enough attention... what are they?
Nothing, just class-like string identifiers to type when you need those Bar instances initialized in a particular way (with "foo" and with "bar", hence the names). But they're not actual PHP classes. And if one has to create classes for every unique object configuration that would be a big **FAIL** too, so... I guess let's leave it there.
&gt; What you're saying is that the docs encourage an approach which makes IoC impossible. You can't have your cake and eat it too The docs are written for brevity. I had no problem learning how to do dependency injection in Laravel despite the focus of static facades in the docs. &gt; Please refresh yourself on the "Hollywood principle" that is the basis of IoC. You can't register global namespaces with a global string handle and then ask your modules to ask for their namespace by that handle. This makes your modules environment aware (or you risk handle collision). The only way to avoid this is to inject the namespace alias string into every controller, but that'd be going out of your way in order to correct a design mistake/omission in the framework. You'll have to give me an example of this particular limitation of Laravel's IoC container. I've run across no problems using its container, but then again, most of my use cases are straight forward. You might have more edge case usage than I do.
&gt; The docs are written for brevity. Would you mind telling me how is $view-&gt;something() less brief than View::something(). I guess it's the dollar sign. The verbose dollar sign forced Laravel to drop injection in docs. Totally understandable. &gt; You'll have to give me an example of this particular limitation of Laravel's IoC container. I'm talking about view namespaces, which you cited as a solution for view modularity. They're not inverted, so not very suitable for modules, unless you inject the actual namespace into the controllers. I.e. this is inverted and suitable for modules (although, very ugly and clumsy): View::make($ns . '::view.name'); // Where $ns is injected into the controller from the "container". This is not: View::make('myblog::view.name'); // Refers to a static namespace alias which is out of controller's scope. Do you know what would proper design be like? If there was no facade, and $view was *injected with the module namespace implied*. That's IoC. $view-&gt;make('view.name'); // Namespace for this controller's module is implied without being spelled out.
It actually begun a while ago. Haters gonna hate.
&gt; You're not really losing out on anything here in terms of inversion of control. Unless I'm missing something here? Yes, you're missing something. Let's say I have site front-end and back-end. I want one view for front-end, differently configured view for back-end. If I run them entirely independently as two separate projects, as you said, I can just configure the facade. But I run them together (let's say an admin widget showing on the front-end public side when an admin is logged in) then suddenly there's a conflict. One of the modules is going to get the wrong View configuration, or I'll have to play a highly fragile and exhausting game of swapping views in and out of the facade to match the current execution context with regard to which controller is running right now. You can swap a facade but you can't have two facades at once at the same time, every module seeing the right facade. Just a simple example, but a realistic one (I'm just working on a project that has something like that). Things like that mean your code is coupled to global state, so true modularization is much harder, in some cases next to impossible. After all global state doesn't mean "we can't change it". It just means it's global. There's no context. If "can be swapped out" was an argument, we'd just be using global variables: function ctrlAction() { global $view; $view-&gt;make('...'); ... } You can set a new value. Yet we don't use global variables. Think about it.
I am not sure if this will be in FreePBX 13 or 14 but one of our team members is super excited (like jump out of his freaking chair excited) about resource lists so it is on our list. I don't know if you have seen our wall of phones but we will be doing some testing on our [small collection of phones](http://i.imgur.com/dmo3Btq.jpg). 
Well then it doesn't make sense to inject only a namespace-hydrated view factory and then require the view name to be called as well. If we're talking pure IoC, then you would inject a view instance and simply bind the data to it, rather than injecting a factory and resolving a view out of it. Otherwise, if the controller has control over the view it wants, you still don't have dependency inversion. You're not telling, you're asking. *this* would be proper dependency inversion $view-&gt;bind($data); //where the entire view is injected and the controller never uses a factory return $view; But that goes back to API design. In order to achieve that, it comes with a whole mess of baggage. You need to do the view construction outside of the controller, in a non-obvious place like via configuration (a Symfony approach) or a service provider (a Laravel approach). Neither of those sound particularly appealing. If the controller is left in charge of the view it wants to call (namespace included), the API is simple and straightforward like it is now. I would honestly need to see *why* you need to inject a namespaced view and what the actual gains of it would be over the normal use case. Software design is a series of tradeoffs. Adding flexibility comes at the expense of straight-forward usability. Shortcuts in architecture to gain usability might limit flexibility. Personally, I think Laravel has hit the sweet spot and has struck the right balance between easy of use, and "proper" architecture for a broad range of normal use cases.
Never met him but I want to say he is an Astronaut 
just wanted to say thank you. we use the shit out of that server. 
looks kind of sketchy with the .exe file 
Good to hear - I had never heard of you guys either, and visiting your website doesn't actually tell me what FreePBX is, definitely need to do your first paragraph of text on the site as an overview as to what FreePBX actually is, and why it's useful before talking about how technically good it is.
I thought so too, but (bottom of page) links to the source for it: https://github.com/Seldaek/hidden-input so you can compile your own.
If you need to hide your password to ensure its security while inputting it, your password is not strong enough.
Not someone, it is me who created the issue : https://github.com/paragonie/awesome-appsec/issues/1 . It was basically mentioning about Random generator string via /u/ircmaxell [RandomLib](https://github.com/ircmaxell/RandomLib) . If you dislike happy to hear the drawback for he is also an expert in the application security field.
I don't dislike what appears to be a very good library. It is a lot more flexible than just "A random number", which is the context here. I dislike that the response to /dev/urandom is to consider it an "issue" worth of logging as such.
Unfortunately we do not do rsync deploys as we are using a stupid system called "ElasticBeanstalk" ;) - so every deploy - even the smallest hotfix ist a complete "build from scratch" situation. What would the reason be of not allowing maintainers to specify what directories are only needed for testing/doc/examples?
Then if you need that you inject the instance. I can understand your point here, but Laravel let's you decide on what you want to do... So... Don't know why my original comment was downvoted. Bah, guess that's /r/PHP for you.
Is there any specific reason for not liking Eloquent? I have my gripes with it too, just wanted to hear someone else's perspective.
Ok, then allow the end user to add his or her own key to their respective PBX so that issue of liability is minimized.....
Hence why if this continues, we should fork FreePBX (or make a set of patches, ala what Novell did with OpenOffice) that add/fix these issues.
We're annoyed as well. Every discussion about this feels like we hit a continual wall, because the complete reasoning for the module signing is not explained. It seems like lawyers and people higher up decided to do this over more simple solutions. Coincidentally it gives more control, and sorta steers people to Sangoma's commercial modules (or anything signed by Sangoma/POSSA).
Didn't for me ... (android)
The people higher up should reconsider their choice of lawyers in that case, because the indemnification is a literal poison pill to anyone (except companies and Sagoma). Without saying names, has *anyone* actually signed that agreement, *ever*?
[**@laravelphp**](https://twitter.com/laravelphp): &gt;[2015-05-01 14:09:53 UTC](https://twitter.com/laravelphp/status/594141694460755969) &gt;Announcement: Laravel 5.1 will be the first Laravel LTS release in the framework’s history. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/34iomv%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
That's the thing though. "Several Threads". It's hard to keep track of them all. Here's my first attempt at fixing the emails and the unsigned module warnings (of which you can delete and hide now): https://github.com/FreePBX/framework/commit/7409eb26caf2049b4e8e73f3a698b493a4934981 If a file is modified outside of an unsigned module you still get emails. I think that's fair?
Lots of people have. Anyone who actually HAS read the document and has consulted with a lawyer doesn't have a problem with it. We narrow your liability to a single, specific, thing, as opposed to the normal global Hold Harmless that everyone else uses. That was **me** saying 'No, we need to make sure that this isn't too broad'. A standard Hold Harmless clause (exactly the same as the one on Ward's site) has no limitations. Ward gets sued, and he thinks you're involved? Well, you agreed to that. We get sued, it's because of something you did, but it's **not** because of what you did with your signed key? Then you're not liable. It's really disheartening that he's doing his best to attack the project, when we're doing the right thing.
A set of patches sounds great. Go for it! We encourage it. That's what open source is all about! Different ideas coming together to make software work for everyone. A "fork" doesn't have to be a bad thing if you don't want it to be and the fact that we put the source code online for all to see only reenforces this thought (and so does github). I will say however that much of what has been requested is being worked on here: https://github.com/FreePBX/framework/commit/7409eb26caf2049b4e8e73f3a698b493a4934981 Mainly we realized that people were getting waaay too many emails a day and the notices still couldn't be removed about unsigned. You should get an email once and be done with it. It's your system you choose to do what you want with it (in terms of unsigned modules). As for the core files, we are still going to monitor those. I think that's fair at least?
I know, but it harms module writers that are not Sangoma, or a company that can take that kind of risk. The Hold Harmless clause Sangoma's lawyers signed is the equivalent of a nuclear weapon, where the language just needs to remove liablity from Sangoma (I'm not a lawyer, but you should really consult Ward (or anyone else), who has experience in the field (he's got some good points, and is not a Troll. I've seen *real* trolls. He's been one of your greatest supporters over the years). This agreement *indirectly* affects end users by limiting their choice in modules (that don't send emails or display the security warning). Honestly, all were asking for is an off switch that is hidden, so power users (and admins that are comfortable) can use 3rd party modules, without the nag screen.
Then show us an example that matches this that isn't a hosting company. Preferably an OSS project that is sponsored by a corporation (like FreePBX). The only one I recall, is OpenOffice. Edit: I think both sides (ward and the FreePBX team) have good points, but Ward seems to be more sympathetic to the community (just saying). http://nerdvittles.com/?p=13117 http://pbxinaflash.com/community/index.php?threads/freepbx-12-signature-checking.15943/
&gt; Preferably an OSS project that is sponsored by a corporation [Redhat](http://contracts.onecle.com/redhat/molnar.consult.1998.08.17.shtml) is similar. [Openstack](http://www.openstack.org/brand/openstack-logo/), [Canonical](https://juju.ubuntu.com/community/labs/legal/) - admittedly, that's just for Juju, but that was just the first thing I googled. Edit: Just to clarify, none of this conversation has been discussed with a real lawyer, as they cost money which we don't have 8-) -- This is just me googing 'company name hold harmless', and then making sure they explicitly say that they want you to pay legal fees. Every single one of them has done that. Really, everyone does this. It's boilerplate. 
Awesome, I sent you a PM. 
Academics have no real world knowledge of where the industry is headed. Opinions are cheap, as is this one, and should be taken with a grain of salt. The way I look at it, a good language is one that has the propensity to evolve and to keep up with the times. With PHP7 just around the horizon, the adoption rate for PHP will skyrocket. As we speak, most of the internet is powered by linux servers running the LAMP stack. Dont believe me? Check this...http://en.wikipedia.org/wiki/Programming_languages_used_in_most_popular_websites
Laravel is just too complicating IMO. I love the way Symfony2 handles routing, controllers, views the service layer etc.etc.. I also love the service container. Laravel's service container is just a PITA, and dont get me started on the use of static methods peppered throughout the code, introducing global scope! I don't really have time to mull over the nuances of a framework. I need simple, concise documentation, with lots of code samples. I think laravel is not the way to the future, Symfony 3 is, because of a more fluent (no pun intended) community!
Now I'm trying to figure out who you are! Did you comment on Woz's business card last night? 8-)
"usable ORM out of the box". Give me 5 minutes and I'll have Doctrine entities, repositories and migrations all set up for a table on a new Symfony project. Apparently that's not working out of the box. I wish he'd stop acting like a car's salesman and compare the differences instead of acting like everything he creates is amazing and everything else is complete dog shit.
&gt; I think what ward honestly wants is a way to either add a gpg key locally (for that installation) We've been having random on and off discussions about this, but the idea that he floated earlier (root owned module.sig in a specific location, or something) looks like it may be plausible. Still needs more work to flesh it out, or someone to write the code 8-) &gt; or an advanced user option to disable signing That'll never happen, unless we tie it in with some secure Zend thing, which I don't want to do. 
When I don't feel like working for the next 30 minutes: composer selfupdate &amp;&amp; composer update
Right, because people waking around looking at screens never happens.
&gt; If we're talking pure IoC, then you would inject a view instance and simply bind the data to it, rather than injecting a factory and resolving a view out of it. Otherwise, if the controller has control over the view it wants, you still don't have dependency inversion. No, that's a very arbitrary usage of IoC. IoC is about proper scopes and well separated responsibilities. Look, let me walk you through a real world scenario here to show the responsibilities of each side. We have a module with controllers and views. We also have a framework that facilitates using said views from a controller. Does the controller and view belong to the same module? Is a controller using views contextually and on-demand? If yes to both, the controller should be able to control which of its own views it uses. If no (we have swappable themes that belong in *other modules*), then the controller should transparently choose from the theme the app wants it to choose from. In *both cases* the controller retains the right to choose to show an "error" view or "success" view without someone deciding for it from outside, but *in both cases* the inversion of control means the controller doesn't need to know which theme it chooses "error" and "success" from, neither it needs to know *where they are located* (because a module has no absolute static control over its file system location, this is up to the app that wires the modules together), and *it's oblivious of any global namespace aliases* it has to use to access its own views. So all your self-imposed stuff about creating views in advance or using configuration files etc. and what not are simply you arguing with a straw man up there. You described a mess and called it a "mess", good job. It has nothing to do with what I'm talking about here. Try to understand the concept. Proper architecture is not a "mess" (outside of Laravel that is) once you understand the core concept that makes modularity and IoC useful.
I'm not pissed about Laravel. I'm amused. I started with a joke post, after all. But then Laravel's author came, and started talking. For the 60 and 80 public method classes, this stuff... *might happen* over time^1 if you have long-term BC support etc., but it's a bit too soon to happen in Laravel (which just announced its first LTS), and it's even less pleasant for the author to brag that his god objects^2 are "so much better than Symfony" and are "SOLID". Spreading ignorance by misrepresenting facts and terms to fellow programmers does annoy me, I have to admit. I admire his enthusiasm and instinct for bombastic statements, but I wish they were better supported by reality. The reason we don't code like it's PHP4 is because we have this better awareness of what good code is about. I can say without any doubt that Laravel is not pushing that bar up, it's dragging it down. ^1 I checked out of curiosity how our internal framework code is doing. Our record is 18 methods (on a string validator builder class: hasLength, isNotBlank, isOneOf, toLower, toUpper, etc.), our router has one public method: "match" and our app class has one too: "run". ^2 For ex. the route matcher also doubles as a route dispatcher, the app also doubles as a dependency container etc. There's no sensible reason those are not separate classes, and it has tangible effect on the resulting app architecture (for ex. no per-module containers, because multiple modules still share one app).
Sounds like a fair and workable solution to me. Thanks for taking the time to address this problem.
Everyone should be excited about resource lists! And yeah I've seen the wall at Astricon :) 
Are we starting yet another facades debate? I think it's overplayed. So the docs use them (maybe too much), but it is a simpler way to explain things, and they are convenient -- especially when you're just making a small CRUD app or something without a complex architecture, that you don't need or want to invest a lot of time into. Examples with facades are easier to read and practically copy and paste useable. If you don't want to use them, then don't http://laravel.com/docs/5.0/facades#facade-class-reference For anyone who has taken the time to read the docs they'll know that they can inject any of the classes instead.
Store the upload as a temporary file then do your parsing. If it passes validation, move it into it's permanent place otherwise remove the temporary file.
I have further detailed this here: http://issues.freepbx.org/browse/FREEPBX-9190
I have further detailed this here: http://issues.freepbx.org/browse/FREEPBX-9190
The problem is that the files exhaust memory. And caching isn't helping much. I just need away to tell phpexcel to load a certain amount of rows (or memory) at a time. 
The issue was all the yelling was directed at the indemnification clause, with no-one actually saying 'hey, we're getting spammed with piles of emails, are you sure that's right?' As soon as we realised that **that** was what people were upset about, we actually had a look and realised there were a bunch of bugs in there. I really wish people would just report bugs in the right place, rather than assuming we can read minds 8-(
&gt; PCI compliance is not law. PCI compliance *is* law in Minnesota, Nevada and Washington. 
It wasn't closed without comment, it was closed because it was implemented.
You're not a lawyer. Ward is. Could you at least consider that maybe he's seeing something you're not? You guys are smart, but law is not your area of expertise. I'm NOT a lawyer, but even I can see where parts of your agreement could cause real problems for a user forced to sign it, and I explained one possible scenario in a post last night. There has been a lot of name calling and accusations made from your side of the fence, and it's painted you guys in a rather bad light. All I'm saying is that perhaps in this case, you should consider that Ward (and the others who have pointed out that this is overbearing) did not come into this with any ill intentions toward you guys, and you overreacted without stopping to consider that maybe Ward and the rest of us actually had a point. You know, if I go to a car mechanic and he tells me that my water pump is going bad, I'd be likely to say he's just trying to scam me and replace a part that isn't needed (since that's a common scam among dishonest mechanics). But if two or three friends that also know a thing or two about cars have a look at my engine and they all tell me, "no, that water pump really does sound like it's about to go", even though they aren't also mechanics, I might start to think that maybe my initial assessment was incorrect. Well, here you have a lawyer, who in the past used to be very supportive of your project, and a few others pointing out that there really is a problem with the way that document is worded. You may *think* it is the same as those other documents you're comparing it to, but perhaps those are used in different situations where that type of shifting of liability would be more appropriate, or maybe there are some significant differences from yours. None of this will matter if tm1000's changes are implemented, except that I think it will take a long time for all the unwarranted name calling and other defensive posts to be forgotten. The sad part is that if you'd paid attention to what people were telling you from the start, instead of having a knee-jerk reaction and rushing to defend your indemnity section, this could have all been solved with little or no animosity.
codexworld has two posts. Both are blog spam, shit php that would have been okay 10 years ago. Just downvote.
Is it possible to ban links from certain domains from the subreddit? That would be helpful.
I don't know about CodeIgniter as to whether or not there is any library but you could check out [this](https://github.com/theiconic/php-ga-measurement-protocol) and directly use it in CI i think.
Long term support
My mistake. I need to read better. I thought it was odd that there was discussion then it was just closed and added. I suppose the discussion can still take place. 
The right for banks to collect reissuance compensation against non-compliant merchants* has been legalized, but the point remains the same: not being compliant is not illegal. * Edit: in the case of data breaches
&gt; The one in particular that would prevent me from ever considering them is the trespassing of logic in your data tier, which creates a very tight coupling between two things that should be completely decoupled. Well, this is a very good example of your architecture imposing specific constraints on your choices. When we look at "class UsersEndpoint" and table "users" we see different things. - I see them as one thing: the user service, part of my domain tier. - You see two things: part of the domain tier *and* part of a separate data tier. I use service orientation, every service is a standalone module that *owns* its stack and hence its data. So therefore they change together according to the requirements imposed on the module, and the problems you cite won't be there. P.S.: DRY refers to avoiding repeating the *same* code throughout the app. It doesn't refer to an abstraction layer that adapts to *different* databases (hence not the same code).
Option 3 seems best. Seems to me, you rebuilt their whole site. You should have a copy of that code somewhere *ahem*. When they go bankrupt, and they will do. Their customers will lose out. Why not have a start-up, where you create a new business, one that isn't so profligate, is much leaner and where you actually have a steak in its success. For the next 6 months, save as much as you can to bootstrap. Learn as much as you can, of their clients and how the business works. When they go down, quietly make another start up and contact their clients and boom, you are now up and running. Just in case, better check that non-compete clause in your contract. Is there one? 
The viability of this plan depends heavily on the core business and clientele of the existing company, as well as how much of [a complete and utter shark](http://www.imdb.com/title/tt0114594/) OP is.
That's not what Wikipedia says: &gt;In 2007, Minnesota enacted a law prohibiting the retention of payment card data.[15] &gt;In 2009, Nevada incorporated the standard into state law, requiring compliance of merchants doing business in that state with the current PCI DSS, and shields compliant entities from liability.[16] &gt;In 2010, Washington also incorporated the standard into state law. Unlike Nevada's law, entities are not required to be compliant to PCI DSS, but compliant entities are shielded from liability in the event of a data breach.[17] http://en.wikipedia.org/wiki/Payment_Card_Industry_Data_Security_Standard#Mandated_compliance
I wish that just for once, you would admit that maybe you guys screwed up. I was looking in YOUR forums, and saw that YOU were told what the problem was in the fifth post of the thread at http://community.freepbx.org/t/any-way-to-disable-module-signature-checking-for-an-individual-module/28261 If you look at the last sentence, it says, &gt; I could tolerate the blaring warning notices when I log into FreePBX but it's the daily e-mails when there is nothing else wrong that are the problem - pretty soon I would just start ignoring them altogether and would never know when something actually needs attention. That was posted back on March 29, over a month ago, and YOU responded to it but only selectively quoted a part of that sentence and totally missed the part about "it's the daily e-mails when there is nothing else wrong that are the problem." So apparently YOU didn't fully read the post, or it didn't register, or whatever, but please don't try to pass the buck and say that it was the fault of others because of all the irrelevant discussion that followed. It appears to me that you certainly participated in, and I think sometimes instigated, much of that irrelevant discussion! This is not meant to be a personal attack, just stating the facts here. I know you have done a lot for the FreePBX project and I respect that, but please don't sink to blaming others for something that you were told about early on and either missed or ignored.
Thank you for finally doing something about this. I just wish we could have got here without all the name calling and finger pointing along the way. But it looks like you have come up with a great solution!
this!
Sometimes a bit of loyalty can aid in positive references that will result in higher future earnings. Depends how much effort said loyalty takes to display. 
Not a shark. More of an otter. I could never build a city over their ashes. But more importantly, I just don't have any passion for this company's sector (professional / amateur sports). 
Of course, but some people need to be reminded that simply hiring you does not mean you owe them any loyalty.
To be honest it sounds a lot like you need to mind your own business. Unless you've got some skin on the table (e.g. you are a share holder) and are paid on time it's not really your job to worry about which lamps they chose to buy.
We are very open to constructive ideas, criticism and feedback. The trolls have zero good intentions and have no desire to be constructive. No matter how open you are, how patient you are with the guy spraying the room with gasoline you jave to draw a line when he pulls out a lighter and gets ready to burn the place down because it gives him weird jollies.
&gt; I wish that just for once, you would admit that maybe you guys screwed up. I did! I edited the very first post to say that we weren't aware of this bug. &gt; So apparently YOU didn't fully read the post, or it didn't register Correct. We all missed it. But as soon as we were actually made aware of it, we fixed it! 
&gt; your view that Ward was trolling I believe that *because* he's - apparently - deliberately trying to confuse the two issues at stake here. &gt; Also, why do you say, "I have no issue with him claiming he's a lawyer" Sorry if that came across wrong. I was just trying to say 'he can say whatever he wants, but actions speak louder than words'. Our actions, when we **finally** figured out there was a bug, was to fix the bug.
&gt; &gt; Could you at least consider that maybe he's seeing something you're not? &gt; &gt; For sure! I have no issue with him claiming he's a lawyer. I have no issue with him claiming that our indemnification is overly broad. Maybe it is? I don't know. I'm not a lawyer! .....*claiming*..... he's a lawyer? Do you know something the rest of us don't? &gt; However, I do have an issue with him saying it's overly broad and then not saying what the issues are with it. As far as I can see, it's exactly the same as every other hold harmless, and it's what real paid lawyers wrote, and they say it's right. I think the problem here may be that the "real paid lawyers" didn't understand the context in which this would be used. Evan a lawyer can only construct language appropriate to a situation as it's described to them. They may have had no way of knowing who might actually be asked to sign that thing, and whether or not those asked to sign would be compensated in any way. They might have thought that only your employees, or only large corporations that you had contracts with would be asked to sign. &gt; I've asked, so many times, for suggestions on changing it, and he just keeps ignoring my requests and attacking me. (You can look through this thread for at least three times I've done that). WHERE has he "attacked" you? You guys sure are thin-skinned. I see a lot of discussion taking place but to me it sure looks like Ward has tried to discuss this issue logically, and you guys have thrown insults such as "troll". I won't go into the discussion of his responses to you, because I'm not a lawyer. I don't know if you are trying to convince him to rewrite your agreement for you or what (I think he probably gets paid to do things like that, and you'd probably second-guess him anyway since you seem to be convinced he has some malice toward you) but the problem is really with the scope of the document. With tm1000's changes this should no longer be an issue, since there will be no need for users to sign for a third party module they didn't write in order to use it without being constantly hounded about it. I just haven't seen "Ward's vitriol, accusations, and general nastyness towards [you]". Maybe that has taken place in some other forum or a back channel or something, but it sure hasn't been apparent here. If anything it's been exactly the other way around - you've been doing exactly what you're accusing Ward of. I don't think this discussion is the slightest bit productive any longer because you want to play the victim, when all along you've been closer to being the bully as far as anyone reading this forum can tell. Stick a fork in this discussion, it's done. 
Laravel Trade Secrets
About quotas: * And what about all those men who got into jobs/business/promotion just because they were men? Quotas might give incompetent women responsibilities, but they might also prevent a sexist selection (by certain recruiters). Many incompetent men had their whole life this way… * Ultimately, this is about representation : at a social level, **you can't be what you can't identify to** (as a child especially). Of course results won't be seen immediately, but this is a long work to do (generation to generation scale).
Generally, you get one free short stint on your resume. If there's two in a row, people will start to wonder. But the plus side now is that you're currently employed, so you can tell prospective employers it isn't a good fit and they won't think much of it. So use the Joel Test and everything you've learned to find the right company. Take your time but start now.
&gt; Unless you know that the company is going to have severe money problems in the immediate future that might result in you being unpaid or laid off, you probably don't need to panic. I'm hardly a financial expert, but dropping direct deposit due "high fees" would be a red flag to me. Said company running out of money to pay wages seems possible given the OP's description. With Direct Deposit, the OP would find out the day his/her paycheck goes missing. If they're using paper checks, he could see his paycheck disappear a week after he'd already spent it.
Well, TIL Nevada actually made it a requirement. The other two did not, however (read carefully). Though, IANAL and my PCI knowledge is a bit dated these days. In any case, the point was OP isn't going to jail and isn't breaking any laws (unless s/he lives in Nevada, apparently). Still a terrible idea, but I was just correcting some FUD.
I don't think the argument against using hack's `==&gt;` syntax is very convincing. There are plenty of examples where you can get 1 character wrong and it will be valid syntax but will make the program function differently. In general the biggest areas are: Bitwise operators, arithmetic operators, comparison operators. Some specific examples: `|` vs. `||`, `*` vs. `**`, `==` vs. `===`, `??` vs. `?:`. In fact these are actually less likely to get caught in real programs because they generally result in the same types. At least with the `=&gt;` vs. `==&gt;` case, * a) it is only valid syntax in less common scenario (when you are setting a closure to an array key * b) what should have been a function will be the function body, meaning that when your code tries to call it as a function you will quickly find the error * c) it is only valid syntax if the body of the closure is an expression i.e. [$x =&gt; { return $x; }] isn't valid syntax EDIT: I am actually really in favor of this proposal in general and hope it passes, it is lovely for those of us that use more functional-style programming. 
I feel like this is a bad idea for a few reasons: 1. Anonymous classes are on the way. Throwing in an alternative syntax in for functions would be confusing. 2. It looks like short closures get very complex very quickly. Trading marginally less verbosity for more complexity is a bad deal. 3. I don't know about other developers, but for me anonymous functions are a specialized tool. It isn't like array shorthand. It's not going to save any significant amount of time because I don't write them regularly.
The reason why I said this. I know someone who rewrote the companies entire infrastructure. He brought his knowledge and his experience. It wasn't necessarily the companies IP he was taking when the company burnt to the group by the owners actions. He had no non-compete clause and when the poop did hit the fan, a few months later he started up and now is running a successful company. No one has talked about suing him and no one has talked about him stealing IP. The company is defunct, it's done. It's over. :) Now he's a multi-millionaire. Has his own developers working for him and spends his morning surfing. I know what I'd choose to do. :)
As you said, this is not getting anywhere, and I agree. &gt; you guys have thrown insults such as "troll". No, it's only been me. No-one else has called him that. Only me. Everyone else is more politically correct than I am 8-) But, here's a nice article you should read, on the subject of Trollage: http://blog.codinghorror.com/what-is-trolling/ I still think my stance is correct, and until proof otherwise emerges, I'm done with him. Either way, the important thing to me is that the **users** have a solution that they're happy with. 
https://www.google.ca/search?q=freepbx+module+signing Seems pretty well documented to me.
&gt; cancel our direct deposit They are getting ready to short you your paychecks. Start saving your money NOW NOW NOW if you have not already started doing so. Begin preparing yourself psychologically for the moment when they will ask you to "help the company out" and "be a good team player" by letting them not pay you while they work out their problems. Your response should be along the lines of "I've already done the work, so you already owe me the money. I will do more work when you pay me for the work I've already done." The moment they stop paying is the moment your contract, such as it may be, is dissolved. Good luck.
Great point.
Why not just call it lambdas?
&gt; Would you mind telling me how is $view-&gt;something() less brief than View::something(). Because `$view-&gt;something` is not complete. Where did `$view` come from? You must also include more code to show it was either injected or created. Meanwhile `View::something()` works as-is. Brevity. &gt; No, that's a very arbitrary usage of IoC So is yours. Injecting a view composed with the namespace is no less arbitrary than injecting a view also composed of the namespace AND the template path. At least my example is *complete* and the only thing the view can't possibly know is the data the controller is responsible for coordinating for it. Your example is a half-constructed view being injected into the controller. If mine is arbitrary, so is yours, and so is the *current* implementation of view creation without any hydration of namespace OR template path. So for you to claim yours is the only proper application of IoC is silly. You are describing an edge case and it could easily be solved by writing your own view wrapper. A framework can't account for nor provide mechanisms to solve every use case and edge case. To do so makes it needlessly abstract and unintuitive to use (or results in more god-class like design, which you've already said is a problem). Maybe you want to reference themes via namespaces, but that's YOU - that's not everyone else. Laravel gives you the low level tools you need to map data to a template found in a given folder. It's up to you to apply the necessary abstraction on top of those low level tools to achieve your business rules. So forgive me if I don't agree with you that Laravel is poorly designed just because it doesn't solve your exact business rules for you out of the box....
Man, some of these iterator classes would have been very helpful to me on a recent project had I known about them. What else from the SPL have I been missing?
The beauty of language features you don't use often is you can pretend they basically don't exist. You can also pretend OOP support doesn't exist in PHP if you're so inclined, since all^[1] of the core libraries have a procedural API. Don't need closures? Don't use them. Hell, if you're really nuts, you could avoid native string tools and use `array`s to emulate C's `char` construct, which is just a list of bytes. If the PHP core team decides it's worth the maintenance overhead of a new operator and logic to support it, that gives you another tool in your PHP toolchest, but doesn't at all impact your existing code. Often times there's a small area in a large codebase that could will benefit from some rarely-used tools, and it's nice to not have to switch to another language to use them effectively. I personally wouldn't get much use out of this as I've had almost no need to dabble in the FP paradigm, but I like knowing it's an option. (Having said that, my experience with FP doesn't allow me to really evaluate if this is a good proposal. Seeing that I don't have voting rights, it barely matters) ^[1] or enough that it might as well be all of them
&gt; I don't think the argument against using hack's ==&gt; syntax is very convincing. I don't care about the exact syntax that much.....but the real problem with the current choice is that it wouldn't be possible to define types for the parameters of the function. Apparently this is due to the fact that it would be too difficult to implement if the operator is after the parameter list. Some sort of operator before the param list would be required to allow types on the params, e.g. something like: ::(int $x, Foo $foo) {return $x + $foo-&gt;bar} which is a bit icky, but I love me some typehints.
Or senior devs who don't follow the day-to-day of PHP internals. PHP7 won't be out for months, so asking someone about an upcoming feature is pretty damn asinine. That's just poor interviewing technique.
&gt; It is a law in Minnesota, Nevada, and Washington. "It" (being PCI compliance) is only required by law in Nevada according to your source. The law in Minnesota only prohibits storing CC data, and the law in Washington only provides that compliant merchants aren't liable for breaches. &gt; So yes, it is illegal in those states, but no, you won't go to prison for it. No, it's not illegal to be non-compliant anywhere except Nevada.
https://twitter.com/ircmaxell/status/553733314889404416 That was the first time I talked about ~&gt; … At that time somehow most people agreed with me. I wonder what's wrong now. Also, at least on my keyboard, I find alt+n (~) easier to type than doubly shift+0 (==). Also, visually, I can't tell that I ever had problems to differ between `-` and `~` (minus and bitwise not). Additionally you most probably write it `$param ~&gt; $var + $param` with whitespaces around the operator unlike the object operator where you write `$param-&gt;$var` (Well, also depends a lot on the font used). When using `==&gt;` and `=&gt;` however, you have whitespaces around both which makes it much less obvious.
[**@ircmaxell**](https://twitter.com/ircmaxell/) &gt; [2015-01-10 02:01 UTC](https://twitter.com/ircmaxell/status/553733314889404416) &gt; @SaraMG @bwoebi was talking about ~\&gt; instead, mainly for easier parsing and easier differentiation from =\&gt;... ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Correct, but it's a meaningless distinction. In practice PCI compliance is the only way you can comply with the laws and the rules of the banks and the payment brands.
&gt;Do you not use them because they aren't useful, or because they're a pain in the butt to write and read in PHP? I generally only use anonymous functions when I would otherwise have a function for a single callable, am setting up objects in a dependency injection container, and in Silex when I'm being particularly lazy/rushing. The number of keystrokes isn't a big issue for me personally since it's just a couple letters and the enter key in my IDE. Functional programming is admittedly all new to me so this very well could be the bee's knees for functional programmers. I'll have to spend some time learning. Working in OOP the idea of embedded code all over the place makes me a bit twitchy though. &gt;Erm. So? It strikes me as a complication. If you know how to use anonymous functions you'll intuitively know how to use anonymous classes. They build off each other. That isn't the case with short closures. They're their own separate beast entirely and that's going to have a mental cost for developers.
Do what you need to do and trust that you can explain your rationale to reasonable employers down the line. I've had 3 jobs in 3 years, and 1 job spanning 3 years. It's more important to have a network and be active in the local developer groups in your area and expect to change jobs periodically than anything else.
Get a VPS? 
&gt; You can still have multiple repositories that correspond to multiple databases etc., but this is an internal implementation detail of the service. You're missing the point. If you place your logic in stored procedures, you must duplicate that logic on other databases to do what you're referring to here. You're also placing an often unnecessary database connection dependency on this logic (but this really depends on what you're actually doing with the procedure). And, in the case where you need to use a non-SQL-database as your data tier, you're going to have to move that logic up into your domain layer anyway (which is great, since that's where it belongs). &gt; If you think what I say misses a good portion of the point of DDD indulge me and name it. DDD advocates separation of the domain layer from the data layer. Putting logic into stored procedures in your database violates that clear boundary. You should be free to use a given domain layer in *any* application that you want to build around it. If part of your domain layer is sitting in your database, this is not possible. Maybe I want to create an application around my domain layer that has no access to a database. Maybe I want it to use a 3rd party API instead of local data. So on and so forth. &gt; P.S.: [...] This entire block is one big incorrect assumption. I can appreciate that maybe you've had bad prior experiences with SQL-phobic developers before, but I am not one of them. I'm just very comfortable in the fact that putting logic in your data tier is bad design, and, if it were even possible to do it in other, non-SQL-database implementations, I would be very much against it in those, as well.
I've had numerous VPSes, but none of the ones I've found allow you to do what I've asked.
Ditto.
Digital Ocean
Will this damage your rep? Hell no, you stuck it out for another 6 months after your initial concerns and you worked through the problems and helped improve the code base. Just don't try to polish the turd if asked why you left at an interview, be honest their is nothing wrong with your reasons for leaving. 
I don't like it. I think it adds too much confusion in the reading of the code. It's move too much towards the problems we had in PERL. I can also see some of the "valid" syntax being immediately tossed out in the name of readability. For example: $x ~&gt; $x * 2 ($x) ~&gt; $x * 2 These two will be immediately rejected by the community who are against short handed if statements. "Always wrap your statements! { }" array_map($x ~&gt; ($x * 2) + $b + $c, $input); This starts getting difficult to understanding what exactly is going on here...
Banks and payment brands don't make laws. There's a huge, meaningful distinction between laws and contractual obligations.
Exactly my point
Then being eliminated from consideration after failing such an asinine question is a blessing in disguise.
They do help to disabuse you of the notion that ActiveRecord and ORM are things you can have. How are they versioned? How are they upgraded in situ without taking the site down? How are they unit tested?
Yes please! I do not much care for the debate between the proposed ~&gt; or Hack's ==&gt; but I do know whatever the choice that this can significantly increase the ergonomics and readability of functional code and libraries. 
I guess it depends on how much he wanted that patticular job )
&gt; They do help to disabuse you of the notion that ActiveRecord and ORM are things you can have. I can draw no connection from this discussion to ORM / ActiveRecord. &gt; How are they versioned? How are they upgraded in situ without taking the site down? How are they unit tested? Same like anything else. Text files in repo. Same for table schemas. Triggers. &gt; How are they upgraded in situ without taking the site down? Same like anything else. Migrations. Stored procs are rarely changed, because they have a very focused purpose. Truly "single responsibility". If I need a new one, it's far more likely I'd put it under a new name, as I'll still need the old one. &gt; How are they unit tested? Same like anything else. How do you "unit test" your existing SQL queries?
I've grown wary of this conversation. If after all of this you still don't get it, then no amount of further discourse will. Good day to you. 
&gt; you're resorting to ad hominem arguments. Ad hominem is to attack unrelated qualities of your person to conclude any argument coming from you is bad. It's not ad hominem to point out that your argument is so-bad-its-funny, and I'm therefore not impressed. Have a good day.
The amount of things you have done in just 6 months is amazing. You should at least feel awesome about it (I wish I could have done half of what you achieved). Let me tell you my story and if you don't want to read any further, my advice is start LOOKING for another job now while you keep up with this 'mess'. Nothing else. You might have to lower your expectation a bit but you shouldn't have hard time finding one while keeping the pay check coming through for the time being. I am in similar situation as you, only the details are different I guess. I joined an agency right after graduation/internship seeing how awesome they looked and how supportive they seem when I told them I was learning a lot and was expecting a lot of support. On top, they were happy to sponsor my visa as well which made me so ecstatic that I kind of didn't bother going to another interview I had lined up. But right from day 1, I realised there would be no support and I would have ancient code thrown at me. Not that I was writing any better code during that time as I literally was just starting but I spent all the time I had to learn while keep the system working. There was a contractor who 'helped' but only now I know how unbelievably shit he was given the amount he was charging. It still baffles me how that guy could go around claiming he was a consultant. But yeh there was a lot of code that needed improvement. For a while there was a front end guy so I mostly did PHP and some JavaScript (or jQuery rather). I was spending weekends trying to get up to date with the 'correct' or better way to do things (like use PDO instead of MySQL) and get familiar with the CMS we used which I had to learn from the absolute scratch. The manager was supportive but it was more like you are doing well yet rarely understood the lengths I was going to get things done. But I was grateful and knew my own 'noobness' so I expected this as normal. Fast forward 2 and half years and somehow even after learning a lot and having had to do full stack development, handle server issues, etc after the front end guy quit unexpectedly a year and half ago; I am still spending almost 16 hours a day and countless weekends constantly working only getting more stressed and utterly burnt out most of the time. I am writing code I am absolutely disgusted and I have to manually write tons of 'fixes' to fix the thing that was barely working but they constantly change requirement and passively aggressively expect me to have it ready for the client. Seriously I will probably write somewhere in the codebase asking for forgiveness from whoever will have to manage it. I am trying but maybe it is just my lack of skills or that I just do not have enough time since most of the time I am busy fixing the margin and padding. And yet they expand into a bigger office, think of getting more clients, competing against companies that have 100s more devs than us. I can't begin to tell you the absolute disgust I feel when they go on about how awesome 'our' CMS is when it's an open source CMS with some modifications. I guess the worst feeling in all of this is I know this could be so much better yet here I am churning out code that I hate to see. The only reason I haven't just quit is because it is almost impossible for me to find another job given my status as a non-citizen so I just barely hang on but please don't do this; it destroys you inside out and makes you doubt so much. I want this business to succeed and am doing what is humanely possible to the best of my ability to improve what I can. I don't think they are financially trouble as of now but it would not come as a shock if they will be in 4-5 months time. Oh btw, did I tell you that I found that they had installed a tracker software in my work PC for about 9 months now which causes all sorts of issues that I always bugged me as to why it didn't occur on any other work computer. I haven't yet confronted them with it but seeing that totally wiped any sort of respect/belief I had upon these people as this software I found was preventing me or making it hard to get my job done ironically. It's a great feeling to be able to loyal and trust anyone/organisation but like others said here; sometimes you need to just look after yourself. So start looking for another job NOW! 
&gt; Currently Hack has implemented shorthand anonymous functions using the ==&gt; symbol to define them. The position of this RFC is that the ==&gt; symbol is too similar to the =&gt; (double arrow) sign, and would cause confusion. Well, technically ~&gt; and -&gt; are even more similar... &gt; The variable binding is always by value. There are no implicit references. If these are needed, the current syntax with use () can be used. Oh, shoot... In order for a closure to behave like a closure *they should be brought in by reference*. Please let's get this one right finally :(
You can [start a session](https://php.net/session_start), then once a user authenticates, store their username or id as a session variable via the `$_SESSION` superglobal. There are some basic examples [here](http://www.formget.com/login-form-in-php/).
thank you! :)
The map/reduce thing in PHP is broken as arrays don't own the functions operating on them. I find this a thousand times more readable than the example with the proposed syntax which is inherently non-obvious: function sumEventScores($events, $scores) { return $events -&gt;map(function($event) { return $event['type']; })-&gt;reduce(function($sum, $type) use ($scores) { return $sum + $scores[$type]; }); } } A "function" keyword directly shouts "that is a closure here" to me. The second closure (the reduce parameter) requires a lot more than that to understand what actually happens: function sumEventScores($events, $scores) { $types = array_map($event ~&gt; $event['type'], $events); return array_reduce($types, ($sum, $type) ~&gt; $sum + $scores[$type]); } So why don't we create a fix for the "methods belonging to scalar/array values" problem instead of creating this hard to read syntax? Keep in mind you will read code a lot more often than you write it!
&gt; Both approaches have their advantages… What is the benefit of copying variables by value into a closure?! As you said yourself it's trivial to copy when you want to copy. But when I want a reference in your syntax, I'm basically screwed. &gt; like the concept of being explicit about what I want to change by reference. It may prevent accidental bugs... How often do you really have closure reference related bugs in JavaScript? C#? I think you're missing the code style closures are defined to support. Closures are supposed to operate as **first-class statement blocks**, nothing more. Same as an *if* statement block, *for* statement block, *foreach* statement block. *This is why* the lambda syntax you have implemented *looks like one*. So that you reach the same part of your brain that says "this is a statement block". $count = 0; foreach ($collection as $item) { $count++; } $count = 0; $collection-&gt;each(() ~&gt; { $count++; }); $results = []; if ($valueOrNull !== null) { $results[] = $valueOrNull; } $results = []; $maybeMonad-&gt;bind(($val) ~&gt; { $results[] = $val; }); I'm not supposed to think "wait is this a closure, or a code block" and wildly change the way I approach the problem. To truly gain benefit in functional programming patterns, closures **must** feel like they truly live in the context they're written in. And your proposal is ruining this effect by implicitly copying variables in closures. I don't care for us to match the definition of closures just because it's the dogma. But truth is, there's a great reason *why* closures are defined the way they are. It's because *they're most useful* the way they're defined. Additionally, people who write PHP also write JavaScript all day for the browser. Closures work by capturing variables *by reference* in JavaScript (and that's how they work in most other languages too). Let's not introduce yet another discrepancy for all the poor folks who write PHP/JS code all day, by making them use different workflows on PHP and JS. 
Hmm. Thanks. I'll think about it over the night/next day. It'd be a trivial change in patch… well. [I have to say that I initially wanted by-ref, but got told to use by-value… So that's where we're now. Mhm. [Fyi: This tone was much more appropriate. "Why on earth..." isn't really inviting for discussion.]]
Sorry, I get emotional :P I just feel we're *this* close to perfection if we can do it right with variables imports. Thanks for considering my thoughts :)
Love the feature but that ~&gt; is gonna be hard to distinguish from -&gt; on first glance.
What you want I don't think exists. Why are you looking for so much change? 
Nothing could be worse then the transition from D6 to D7. -Former Drupal dev. 
Agreed with this. That was my first thought regarding the ~ symbol. Would be interested to know if that renders oddly depending on different editor fonts on different monitor resolutions.
God... can we stop trying to integrate EVERYTHING into one language? This doesn't make things easier to read, it makes them HARDER to read. Much much harder....
I don't think you had a proper VPS then. Most VPSes are unmanaged and you can change PHP versions as easily as reinstalling or compiling PHP, as well the majority of VPS providers will have some kind of control panel that allows you to reinstall the OS. Linode, Digital Ocean and Vultr are good popular ones, but pretty much any provider, even running stuff like SolusVM, will be able to handle your requirements reasonably well. Linode, Digital Ocean and Vultr as well bill by the hour so if you spin up an instance with x amount of memory and CPU power for 4 hours (for instance) you only get billed for that time too. If your computer is capable though, have you considered just running virtual machines on your computer for this purpose?
You just said it's harder and didn't explain why. This means your comment has little to no value as it stands. The RFC author and collaborators cannot improve unless you give specifics.
Get a godaddy dedicated. Probably the cheapest anyway. You can get 30% or more off on your new purchase with easily available coupons. I used to use them for renewal but they stopped it recently.... So pissed.
Plenty of examples in this thread. I mean, imagine if I had to take over a project where the previous developer had this kinda crap all over the place: array_map($x ~&gt; ($x * 2) + $b + $c, $input); I don't mind closures even though everything you can do with them can be done without. What I mind is the lack of readability in this. It is suddenly harder to figure out where things begin and where they end.
Both issues are orthogonal. Methods on primitives and short lambdas are complementary, not exclusive. Your example using short syntax: function sumEventScores($events, $scores) { return $events-&gt;map($event ~&gt; $event['type']) -&gt;reduce(($sum, $type) ~&gt; $sum + $scores[$type]); } I consider this to be a net readability gain, because the actual operations no longer get lost in boilerplate.
That are not flaws but feature requests from your side. 
&gt; I don't mind closures even though everything you can do with them can be done without. That can be said of anything: I don't mind OOP even though everything can be done without. Does it mean it *should* be said of everything? Absolutely not. Saying that it should be rejected because it could result in unreadable code is asinine as well: for example chaining ternary operators can make worse, unreadable code yet they are absolutely indispensable to modern, readable code.
Another vote for DigitalOcean here. However if you need it to be managed at any point, I always recommend FutureHosting. They've been running for years and seem to be awesome. I've got a cPanel VPS with them for a couple of sites that I don't have to worry about managing. With all hosts though, make sure first check reviews on WebHostingTalk.com - for FutureHosting they usually have offers in the VPS section, I dont think DigitalOcean post offers there, but if you're after unmanaged you cant go wrong with DO, and they are dirt cheap. I've heard good things about Vultr too so give them a look over. I've also had good experience with Linode, but they cost slightly more than DO.
A VPS gives you total control of the OS and it's packages. If you didn't previously have root access and total control, you didn't have a VPS.
Ignore this. Any developer worth their salt knows GoDaddy are, and I'm understating this, pure shit. Seriously if you're using GoDaddy, BlueHost, HostGator, JustHost, or any other EIG owned hosting company for your hosting, you clearly have very little clue about the industry. Put simply, you'll learn the hard way why you should avoid these terrible companies.
No, I made that transition and this one to D8 is going to completely invalidate pretty much everything that the common Drupal dev knows about writing code for Drupal.
I am just comparing to others framework. Still, I think that Laravel5 is the best PHP framework. But I almost always end up of modyfying / writing my own validation mechanism because lack of validating collections is just too severe. Symfony has a support for nesting validation, both using a simple "A has B" nesting and collections as well ("A has array of B"). Also CSRF is so much issue there, so much people are trying to switch them off for one request. Second point, with data object is quite right, just a feature request which I never saw in any framework. Third point, in Doctrine you must define a schema for your database and I am liking it. It offers some powerful features like automatic schema generation, migration generation, quick ability to erase db, recreate it and fill with example data for development. It would help dealing with multiple format data, now you are forced to put $casts=[...] in Model when you want to store json array, boolean, date or whatever in your database. It also describes your table very quickly. It could be defined in Model class like $table is or as functions with table fields. About critic, I dont like changing filters to middle as well, it is just not as intutive. When I look at some middleware, I am still "decoding" - is this middleware ran when request starts or on request end? Also passing a "next" middleware into previous makes me feel a bit wrong about single class responsibility. Should it really be a middleware task to run next one? There is no native way to define i18n routes, changing depending on my language. And please dont think that I would want a Laravel to be second Symfony+Doctrine. I dont like Symfony, worked using both and Laravel outclasses Symfony so much, and Eloquent is way simpler, better and quickier to use than Doctrine. There things are just I need everytime working on med-large size project and some of these points look really basic. 
AWS, Digital Ocean, Linode. In general if you're running a server, everything you want should be a non-issue. Sounds like you're stuck looking at cheap shared hosts.
&gt; no not rly Exactly. It's not because something can already be done in some way that it means we can't add syntax to enhance it. Everything can be done in procedural, but OOP is often better. Everything can be done with anonymous functions, but sometimes closure would be more concise. &gt;chained ternary operators are NOT indispensable. Ternary operators are great. Chained ternary operators should be punishable by death! No doubt about that! You misinterpreted what I said. I meant that while the ternary operator is indispensable, it can be chained and produce unreadable code, just like this new proposal. My point was that unclear code can be produced with anything, and shouldn't be an argument against this proposal.
These guys also do this very well, as-a-service: https://deadmanssnitch.com/
We use that currently as well. And that's why I wrote this. Using the built-in mail function can be a bitch. &gt;what happens if the database is down? Then there are bigger problems than the crob script to worry about :D &gt;eg: syntax-error or some fatal errors. True. I should probably add a shutdown handler and account for those cases. Thanks!
&gt; What ends up happening is that we usually find that out by manually looking at the logs every day. You might want to check a centralized logging solution, like Logstash or FluentD. &amp;nbsp; And why did you preferred to write a new package instead of using Monolog ? With Monolog you can combine various handlers, which allows you to manipulate that data how ever you want (_save to disk, send email, send via remote API, etc_) and if you use a central place to keep your logs, it is very easy to see if that error occurred on all machines or on a single machine, which might help to isolate the problem and to automate the process of removing that machine from production. 
Sounds like you'd be well-served by local VM. https://puphpet.com
For this to work, it would have to be blindingly fast. And the connection between the editor plugins and this service would have to be persistent and fast too. Slow code suggest is worse than no code suggest...
You still didn't say *why* it's crap or why that is harder to read. Provide concrete reasons *why* you think it's crap or harder to read.
&gt; Do you think something like this is possible, and do you think as a community we should make this happen? It's possible, of course. That's *precisely* what TypeScript does, and it's what project Roslyn is for .NET languages. They provide command-line / TCP services for autocompletion, error detection, refactoring, even smart highlighting, and editors just need to talk to the service, instead of analyzing anything themselves.
https://cronitor.io these guys too 
Given what you're trying to do, I'm not sure you want a hosting provider (or VPS). If you're just debugging a specific project and want to recreate the environment then why not use [Vagrant](http://vagrantup.com)? You can use [puphpet](https://puphpet.com/) configure the virtual machine (os, php version, web server, db, etc). On a side note, what is your project? I also find it odd that an environmental issues would cause problem with you code. ¯\_(ツ)_/¯
Check TypeScript before you check Roslyn, it's simpler and fits the complexity and level of service we need for something like PHP. PHP7 will have an AST in its parser. Ideally any such project like you imagine would hook into that AST instead of reinventing things, because I think the most useful aspect of such a project would be if analyzer and compiler share code, to avoid the constant catch-up and inconsistencies we see today.
The idea is to provide utility that works likes apt-get, rpm or pacman. You just type `phppm install phar-composer` and now you have phar-composer binary. It uses packagist database, so adition a new installable package is very simple for developers 
It's unclear how is this different from composer. It'd help to stress those differences in your page / docs.
It makes system-wide global installation of packages instead of local installation by composer. Even if composer run with "--global" option it does not install package for all users. Also, functionality is not limited to creating system binary file. Packages can describe one or more configuration files stored in system directory which will be saved during update.
It sounds like you've already done a ton of great work, so it's not like you're jumping ship at the first sign of trouble or hard work. In my opinion there is no hard rule of duration for a job. What is more important is whether or not you are leaving them in a bad spot when you leave. And by that, I don't mean "they will have to replace you" but I mean leaving with work half-done or in the middle of a large assignment. If you're in a place where the codebase is stable and nothing you are responsible for is half-finished, then it doesn't matter how long you've been there. It sounds like you don't have a ton of opportunity for growth at this point and if you're genuinely concerned about the financial situation of the company, then I would say start looking for something new. If you are concerned about the "6 months", then get ahead of that and talk to it on your resume.. Under this most recent job description, explain what you were hired to do, what you did, and point out that you accomplished those tasks and more, and now you're looking for a new challenge.. That will count for a lot. This is also related to another piece of advice: I've hired lots of people in my time. When I read resumes I'm not looking for you to describe your job. If I'm hiring a programmer, I know what a programmer does ;-) I am looking for a description of the challenges you faced, the problems you solved and the goals you accomplished.. Good luck, and congrats again on some impressive accomplishments so far.. 
I think I only saw one or two people mention this so far. Your immediate action should be to start saving as much money as possible while they're still paying you. Whether you start looking for another job now or later this is the correct course of action _right now_. If you do this then you'll have an emergency savings buffer such that you won't be at the mercy of the company if they start withholding paychecks and will be in a position of power to say 'no' and walk away. As to whether or not you should start looking for another job, that depends on how soon you think the company will go belly-up. If you think it'll be within the next month then start looking now unless you already have plenty saved up (3-6 months expenses). If it might be the next 3-6 months then you've got plenty of time to save money, see where things go, and start looking in month or two. The intern quitting probably put another month of money in your paycheck but that's still borrowed time on the longer estimate. As for the impact of a 6 month job on your resume: It's a non-issue. Sure, there will be a few companies out there which will look unfavorably on it but the reality is these are also the companies you probably wouldn't want to work for anyway since they'll be very strict on punch-in, punch-out, staying overtime, unreasonable demands, bureaucracy, drinking the koolaid, etc. Most people in the technology sector who aren't involved in the bureaucracy of large stagnant companies will recognize this development pattern and won't make a big deal about it; They're more interested in seeing what you know and what you'll be able to contribute to their company.
So phppm is meant to be run as the root user?
Remember when short array syntax was going to destroy readability in PHP?
PHP is predominantly for web and ad-hoc CLI, so I'm curious what use cases you see for this.
Looks pretty neat! Not sure about using "package.json", however. That's usually well used as npm/node package definition. Perhaps phppm.json to match the name?
why would that? wait what?
A relational db would do this. But it sounds like you are after a noSQL database. Maybe look into things like reddis? Either way you should be able to build an interface to both to run reports. 
I understand that I may be needing noSQL. But I also need some Relational info (like storing employee data, roles, privileges, estimates, orders etc.) Are you suggesting I can completely skip RDBMS ?
I'm sorry but these do not read the same: $x ~&gt; $x * 2 $x ~&gt; { return $x * 2;} ($x) ~&gt; $x * 2 ($x) ~&gt; { return $x * 2; } // this should be the required syntax in all cases. or at least ($x ~&gt; { return $x * 2;}) Why is an arrow operator appropriate here? There must be a less random syntax available.
I've been thinking about your comment for the last few days, and you've convinced me to try again. I'll reply again when I get back to Australia and fire up a few test machines inside AWS
I find it difficult to believe that this code *physically hurts your eyes*, sorry. 
I'm not at my computer at the moment. But will be in an hour or so. Will dig up some info and links. Start looking at the different table types and their pros and cons. MyISAM and innoDB being the mains ones. 
That's a different problem.
How do you configure without editing code?
Constraints can be applied to the json? Even nested elements? That's very impressive if they pulled that off with acceptable performance! It will cover a ton of situations where key/value store (or table) would've been necessary.
Thanks. Had no idea about jsonb. Will check postgres :)
Also check this great [presentation](https://www.youtube.com/watch?v=78A2gJBgL9g). It's 3 hours long, but you'll start off on the right note. You don't need to know about Python either. He barely goes into it. It's all about postgres.
If your elite hacker is in a position to do that, you have a different problem.
It's still a closure even if the value is copied, and still very useful. If you need to change something at a distance, use an object.
The scope you **close over** is not supposed to be **"at a distance"**. That's the whole point of having closures. To be honest, I wish that we had more people who understand closures in this discussion, and not only people who have been Stockholmed into perceiving PHP's mistakes for a benefit.
Yup! One thing the Postgres guys do well is to solve the general problem rather than some arbitrary specific one - so check constraints are just any boolean SQL expression. So any part of a field you can query can be part of a check constraint. Similar rules apply to indices - if you want to index queries of some part of a json document, just go ahead and index the expression you would use to access it. Plus you can write your own functions (even in JS using plv8, which fits nicely with the json theme) if you want arbitrarily complex constraints/indices. And that's without getting into the GIN index, which can blanket cover all keys in a json structure without having to write a specific functional index for each one (see http://www.postgresql.org/docs/9.4/static/datatype-json.html for better explanation on what you can and can't index). Source: unashamed Postgresql fanboy :)
That's really interesting. I wasn't aware this was a mental roadblock some programmers had. Is there any research on this so I can maybe improve how I write shared code? For me the work comes from mentally parsing the code into logic. So making the code shorter but having more rules is a big step backward in efficiency. It's why I *loathe* things like nested ternary operators. They're less characters than if-elseif-else (if you somehow felt compelled to use them in the first place) but far harder for me to turn into logic in my head.
Specifically, it's OmniSharp.net that sits on top of Roslyn providing stdio and http interfaces to Roslyn. Makes it super easy for editors to implement.
If you've missed Iterator classes, you've probably also missed Generators.... can be used to create Traversable objects, but without all the boilerplate code
Thanks, I just installed Postgre on my dev server and will be playing with it in the next few days. Too bad most of my clients are on shared hosting (please don't insult me), I'll have to wait for the next self-hosted customer :). This is very exciting, I have no words to describe how cool this is to me! I can already see the simplified logic going on at the app level if you do not have to rebuild the kv all the time (I'm sure a good ORM would do it, but never as simply and flexible as json will be!).
Based on all the comments here it sounds like they're the way to go, and after signing up and trying them out, I understand why. It's not *exactly* what I was looking for, but I don't think a regular web host offers the granular control that I'm looking for, and I'd have to go with a local vagrant/PuPHPet setup for that.
This does seem like exactly what I'm looking for, and when I have a bit of time I'm going to look into a full vagrant/PuPHPet setup. Thanks for the tip!
I believe you're correct, what I want doesn't exist, at least not with an actual hosting company, and not with the granular level of configuration that I want. It sounds like I would have to go with a local vagrant/PuPHPet setup for *exactly* what I want. And I just want the ability to completely replicate a user's environment if they're having issues that I'm not encountering on my own servers. Basically, I would want to rule the actual software versions out as the cause, so I could focus on other troubleshooting.
I've definitely had proper VPSes, with full root access, but that's not what my question was here. I was trying to find out if there are any hosting companies that offer an extra layer of granular configuration when creating your server, so I could choose my options and come back a little bit later with a fully setup server, ready to go with the exact environment I want. But yeah, after reading through the comments on this thread, if I want the granular control that I mentioned in my original post I may have to go with a local vagrant/PuPHPet setup, which I'm going to investigate further when I have some more time.
I've been trying out DigitalOcean based on the recommendations here, and although it's pretty awesome, it doesn't quite have the granular level of configuration (at server creation time) that I was hoping for. It sounds like my best option would be to have a local vagrant/PuPHPet setup for the level of configuration that I'm looking for.
Yeah, for exactly what I want it sounds like a vagrant/PuPHPet setup is the way to go, so I'm going to investigate that when I have some time. And I just wanted to have my bases covered in case a user reported a problem that I couldn't reproduce. I would want to replicate their exact environment as closely as possible to rule out the environment being the problem, so that I could focus on other troubleshooting. The project is [DomainMOD](http://domainmod.org). And yes, I know the code is, for the most part, awful. I'm not a developer, just a problem solver who needed a better way to bulk manage domains, so I did some reading and starting piecing this together over 10 years ago. And now that it's out in the wild and others are actually using it, it's kind of embarrassing so 2015 is the year of the code cleanup.
Your default example uses XML and that immediately makes me think it isn't focused on modern practices. I'd much rather see a REST service using json:api than an XML example.
I'm asking about choosing the software versions during server creation, not from the command line after the server has already been created, but based on the responses here it sounds like this doesn't exist, and my best option is a local vagrant/PuPHPet setup.
I can really appreciate your desire. Its commendable. But you will never be able to fully replicate users environments. Especially with Linux. Too much customization. Instead just focus on great software and youll be ok. 
Well it's partially about learning new things for myself as well, and making sure the software works on as many software versions as possible. Plus I just like to play around with new technologies. But you're right, it would be impossible to replicate their environments completely, I was just hoping there was a few-click way of at least replicating the major software versions. I'm excited to get in and play with vagrant/PuPHPet, as it sounds like it will do exactly what I'm trying to accomplish here. And if I never need it in order to replicate a user's system, that's ok, at least I had fun playing around with the software.
This looks nice, but I can't really see a use case where composer wouldn't work. I can configure composer to install /vendor anywhere I want.
Can you give a very brief idea how you did this ? I am assuming you used json.
I will check this presentation in sometime. Thank you for sharing :)
Hi, thanks for the suggestion, so the About page contains already some kind of examples but its probably not really clear. I will try to come up with an "Getting started" page which explains shortly what its all about.
Same with Log4PHP and many other logging libraries.
Will there be a documented process for how backwards compatibility and upgrading should be handled between major versions? Like Symfony has their "deprecate legacy features between versions, but only remove them to break BC in major versions. Keep a list of required changes for upgrading between versions"? Having LTS is a great start, but it would be really nice to be sure that you won't just be stuck with a project that can't be upgraded when support does end.
As of right now, there already is such documentation. So I don't think there won't be one in the future. 
Having used a Chromebook, it always seemed like I was trying to work around one thing or another. Why not just get inexpensive netbooks?
This came up recently on hackernews the overwhelming majority said cloud9. I like nitrious.io. It is sleek with the bare essentials.
and run peppermintOS.. and use chromium and have more of everything while all the same stuff. Not sure why people don't do that.
Quite the bloat for something with slim in its name
Majority of frontend are ignorant about security. Majority of web devs are ignorant about security. A lot of backend devs are ignorant about security as well. I see unsanitized queries all over.. Sadly the biggest reason for it being not as seen these days is only because so many people use wordpress etc. If stuff was all still written from scratch, we'd see lots and lots of unsanitized, open, insecure websites all over.
The problem is that XML can never be consistent. Do you use attributes or tags? How do you detect the type of the data? JSON solves both of those problems: 1. there are no attributes, everything is a key/value pair 2. simple data types are built in, not defined by external schema The bottom line is that JSON *is* a better data interchange format in nearly every case (there are always exceptions).
That's all well and good, but I think the default should be JSON, not XML.
What is it with PHP that makes people wanting to release their own framework? 
A warning means "something might be wrong here, but not sure". So that's consistent with the intent. I do realize that in practice you don't want to be drowned in warnings. Maybe address the code style checker you use with a way to silence confirmed false positives in warnings. Alternatively, move your text resources to a separate JSON / text / ini / YAML / etc. file. This is a common practice in many languages.
[Compilr](https://compilr.com/) is similar. 
Really, that bad? I haven't worked on a Drupal project in over a year so I don't really know anything about what's going on in the Drupal community. That sounds like a really rough transition.
I'm using codio atm, haven't tried other options yet though, but am very happy with it.
Now that you mention that, you're right! Another cool feature. I was writing code to return a list of all the terms associated with a particular WordPress post (a funky challenge that involves creating inner joins on three separate tables), and the SQL would have been a mess on one line, haha.
If youre coding in their cloud. Dont they have your source?
I LOLed hard :)
For what it's worth I wrote something very similar: [php-benchmark](https://github.com/scottchiefbaker/php-benchmark) It outputs both an HTML version, and a CLI version. I just added the CLI version last week, so I need to update the docs.
I'm not really sure how that works. I think all your vm instances might be private/encrypted?
I love using language files for this. Drop your message in a constant somewhere out of the way (like a YML file), then display the constant. 
&gt; I'm not really sure how that works. I think all your vm instances might be private/encrypted? I would love to see the technology which offers the possibility to edit the data while it is encrypted. /s And while you store something on a 3rd party server, it is as private as much as you trust the entity which that server belongs to. &amp;nbsp; I do trust my current provider that will do their best to keep my backups available 24/7, but I don't trust them that much in order to not encrypt my backups and throw away the key each month.
Hi, i've not had time to try using it yet, but looking through the documentation and source there were a few things I noticed; 1. Your content negotiation library is pretty nieve and will fail to correctly parse many valid Accept fields - fields like ```foo/bar;baz="q;2,3";q=0.5``` and ```application/type;foo="bar/baz"``` would result in weird results / partial data capture. Content negotiation is a pretty tough problem to handle correctly - have you considered using an existing library, such as [ptlis/conneg](https://github.com/ptlis/conneg) which I maintain? It correctly handles parsing of any valid Accept field and gracefully handles errors for invalid fields. 2. It looks like you're implementing PSR-7 interfaces - but you've bundled a snapshot of them under your own namespace. I would strongly recommend using the interfaces as provided by the package ```psr/http-message``` - by using them from your own namespace you've prevented interoperability with other PSR-7 libraries! Otherwise good job on the framework - it looks like it has good coverage, documentation and (with the exception of the namespacing issue) use of community standards).
I'm not sure I agree with that statement. JSON is de facto standard for modern web. Ruby, Python, Go, PHP, etc all have great support for it. Consuming XML in PHP/JS is fairly easy (except loss of type) but creating XML is not trivial. There are just too many obvious reasons why JSON has replaced XML as the default choice for data exchange.
Encrypted virtual volumes have been around for a while. *If* that's case, the volume would be decrypted by login, similar to how every good password store works.
That is a known fact, so nothing new in what you said, but maybe I'm missing the point in your comment, because I don't see how encryption at FS level could help you to keep your data private from your hosting provider. Which is the reason of my initial (_sarcastic_) comment: &gt; I would love to see the technology which offers the possibility to edit the data while it is encrypted. /s
[*My face when I saw your reply*](http://s3.amazonaws.com/rapgenius/1363228249_mfw%20my%20face%20when%20puking%20rainbows%20meme.jpg). That's *amazing* news. Thank you so much, and Bob Weinand and everyone who are working on this, for shooting for the stars here. This is even better. If I understand you right I suppose that means no redundant ZVAL copies and various other edge cases edge cases triggered by references right? Semantically correct behavior, the patterns... Oh my god, they should have sent a poet! Thank you :D That's even more perfect than I thought we could ever get.
As someone who tried 2 Chromebooks, I agree. 
Looks good to me, but it seems a bit large, not quite sure what everything is doing. You can also consider checking the one I did: https://github.com/lavoiesl/php-benchmark, it has some info about memory usage.
I've got a friend who uses codeanywhere and seems to like it so far.
Thanks. I've never run into the actual number of characters being a determent (language wise) before. I didn't know if this was a general issue some developers had or if it's common with non-native English speakers. It's interesting because it seems to go against the general trend of increased verbosity for clarity (e.g. namespaces, unit test naming). &gt;Also additionally, it is my belief that most people are just terrible at holding multiple function calls in their head, which leads me to utterly detest having more than one piece of functionality on a line at once. I'm with you there. Single-line braceless operations really drives me crazy. The fact you see them so rarely had me assuming most other developers felt the same. The thing is I don't see how short closures are different from those. And that's before the complications of the four different implementations listed in the RFC and the rules for each.
Next thing you know is you have a hard dependency on `symfony/yaml`, but you don't make a big deal of it and go ahead with your project. Then there's a module that needs to be configured upon instantiation, and you resort to yaml because hell, you already have it among your dependencies. Then in the next project you start, you include `symfony/yaml` in your `composer.json` even though you don't need to, because you remember it became useful down the road, and it eventually does, sort of. Then you leave the company, and your bootstrap code is reused as a template/kitchen sink for future projects. And junior developers see this dependency who no one knows what's for, but they're too afraid to remove it because something might break if they do. And this is how `symfony/yaml` becomes a cornerstone of so many projects, when all it does could be done with PHP strings and arrays as well. Source: I'm doing it myself, but I'm already knee deep in yml and doctrine comments to go back now. **edit** I said `symfony/yaml` and then `doctrine/yaml`. My bad, I was always addressing `symfony/yaml` all along 
Nitrous.io is good
Halifax represent!
&gt; If you could run sublimetext But the thing is... you can't. That's the very crux of the problem. I'm also not aware of any Git/SVN/TFS solutions for Chromebooks.
&gt; support said it had just vanished Vanished like a cloud? I'm sorry, that sounds absolutely wretched, I'd drive down to their IT support desk and put my foot up their cloud if it happened to me.
As someone currently coding something that will likely outlive me at this company, I'm doing my best to make it not horrendous to maintain.
That depends on the size of your app. I would say it's easier to keep track of validation if you put them into services, instead of controllers or when your form is posted. You can re-use your sanitizing/validation across different forms. You don't have to use symfony, I was merely giving that link to give you an idea. If you're not using any ORM or models, basic filter_var will work. 
Does anyone else like it when GrahamCampbell admits he made a mistake?
IDEs and text editors such as Sublime, on the other hand, do have that limitation and I believe that Vim does as well.
I have tried to explain just this to so many Ops guys, Project Managers and junior developers. Warnings and notices are NOT errors. Do not refer to them as such.
How's the latency? Is there latency compensation? I really want to setup a cloud IDE. I'm in South Africa though, and latency to US or EU servers might be a problem. I'd be keen to self host on a VPS closer to me if that would help.
What is your biggest criticism of frameworks like Laravel? I'm creating a framework (purely as a learning project) and would like to try and create a point of difference.
lulz - people are downvoting you for pointing out that introducing dependencies just to avoid arbitrary code style violations is bad. This is why I can't take /r/PHP too seriously.
It works fine for me, but I live in the US and generally have stable internet. YMMV.
As the dejour data structure that is repeated ad-nauseum in almost every PHP script and class, there's a statistical benefit to a short array syntax. Making up an alternate syntax for every idiom as a practice, misses the point entirely.
Glad someone else noticed.
My silly question - Is there a good reddit for advertising PHP jobs? I've got 2 full time PHP positions for application developers (not wordpress or digital agency type roles) in Brisbane, Australia. 
More or less. Basically diving into it on day one you have no idea where to begin, but others have all these cool apps. So it's like someone doing a magic trick
Absolutely.
I don't know of one for PHP jobs, but /r/webdev does have a [monthly hiring thread](http://www.reddit.com/r/webdev/comments/34k16v/rwebdev_may_hiring_thread/). There's also these: * /r/ausjobs * /r/web_work * /r/forhire
Rough but much needed too IMHO
I might have considered your argument if we were talking about Symfony's router or security component, but Symfony's YAML component is an EXTREMELY simple one. There is no way you're going down some rabbit hole of complexity by including it. `doctrine/yaml` doesn't even exist. The problems you're having, being "knee deep in yml and doctrine comments", is probably a symptom of poor code management, not simply the inclusion of the dependency.
What libraries did you try? Did you search Packagist? https://packagist.org/search/?q=apn For example: https://github.com/Ph3nol/NotificationPusher https://github.com/duccio/ApnsPHP https://github.com/ZhukV/AppleApnPush
In terms of characters per script, closures take more characters than arrays in my code. I guess it doesn't miss the point entirely after all. We're also hardly in bad company here: 1. JS had verbose closure syntax, added short one in ES6. 2. Java had verbose anon class syntax, added short lambda syntax in Java 8. 3. C# added it (in fact, before Java did AFAIK).
so so so so many truths in this. Nowadays it seems like developing is like being from nintendo - sega in the 90's
&gt; if you want it to be bad it will be bad, if you want to be structured and over-engineered to the extremes its still up to it. I'm not sure I'd quite agree with that statement's phrasing (neither do I consider loose typing bad, nor strict typing over-engineered), although I sort of agree in spirit. Whenever a codebase scales up and contains complicated logic, strict typing &amp; static analysis are great tools to have. You can achieve some of its benefits in PHP with proper tooling, and we'll get even closer with PHP7 (or for those who like that: Facebook's Hack), but it does require extra discipline. But PHP was originally designed as a glue language, meaning, it was supposed to be a "last mile" presentational layer for backend services written in C++ at the time (source: Rasmus Lerdorf). Instead, the community took PHP and ran with it in another direction: PHP today is often used to implement the actual backend services and has a full-blown "template engine in a template engine" compiler for the templating concerns (example: Twig and any other parser-based template system). This is why modern PHP &amp; PHP practices have come to resemble Java instead of its humble C and Perl origins. Those two opposing design goals are the cause of this constant friction between the "PHP should be loose" and "PHP should be strict" lobbies. In a typical "web MVC" app, if architected correctly this duality is reflected in the wildly different styles models and controllers are written in. Controllers are often "sloppy" (by comparison), loose, compact, one-time-use throwaway glue code that is just connecting inputs with services, and service results with templates. In a glue layer it's good to be loose, because you don't care what you work with and if it's correct. You only care that you grab data from one place, and pass it to another place. You don't need to validate as much or ensure "invariants" because it's not your goal, the services you use will check for correctness for you, and if something's wrong (say, invalid input), they'll return errors which you'll just dump them all to the template to show. This is where PHP's loose nature shines, as you save a ton of code not having to describe the type of data whose type you don't care about. Models, in contrast, are often maintained long-term, used in multiple apps, so as a result as strict as possible, and every piece of logic is carefully and verbosely verified and tested, as any mistake might corrupt the domain or lead to security problems. This is where PHP's more recent "strict" features shine, and where new features like PHP7's return types and scalar hints would be great in ensuring correct apps.
Oh definitely, I don't go nuts with it. I just figure that if the text is going to be output to the screen as one sentence, it can be one sentence in the code.
If you think PHP gives you freedom, try playing with Ruby :)
from a business perspective using "parse" might always be the quickest/simplest solutions vs creating an own actuall push messaging service, as parse is insanely cheap (free for most cases)
You should continue. Frameworks like Zend Framework and Symfony are more than happy to fix security issues - they both have security policies, a good team, and dedicate time to security at the drop of a hat. It does get harder after that - we both know Laravel has had a tendency to dismiss reports or fail to disclose them without some level of debate to explain each issue. Beyond the bigger projects, it can get even worse - outright dismissal or disagreement with no consequences. One thing I'm adopting at the moment for open source reports is to start requesting CVE IDs. Never have previously, but this is enabling projects to pretend that there's no problem even when one is reported. At least, having a disclosure and some easy to search for record of it, is better than leaving a legacy of private emails or random open issues nobody remembers. Where people have doubts, they should bring security into the equation of framework selection. There is no such thing as a completely secure framework - too much code, and security evolves over time! - so frameworks without any security vulnerability disclosure are either completely new, not disclosing problems or, worse, ignoring problems. This makes it really hard to tell safe versions from unsafe versions. You can't even then tell if a framework will port fixes back to old versions or not. Personally, I admire all the reporting you've done and I know that it does take a lot of time and effort to follow through on each and every one.
Ruby gives the kind of freedom where you can stare at someone's code and have no clue whatsoever what is going on.
This. It is an indicator of cashflow health. They could be waiting on a cheque or wire transfer that may not come. They may be taking a gamble that it will arrive during the gap between issuing the payment and you depositing the cheque. OP should wait for the cheque to clear even if the bank fronts them the money right away, usually that is about 5-7 days. Plan to spend as little as possible in case they stop paying. Definitely start looking for next gig in any case.
Consultants are a different thing. They are expected to do short stints and typically write their resumes under an umbrella of the company that sent them out, listing each project under that company. The questions you'd get as a consultant switching to a full-time position would be different.
That's definitely not php.
It almost sort of passes until sad().stop();. Is it supposed to be concatenating the results of these two? Why? That being said without that part it still makes absolutely no sense even if it could work.
On the plus side, you can buy it to confuse people =)
Precisely. This is why php got big, its was easy to get something off the ground. believe it or not but to amatuer coders they don't care about what type their variable is, they just want to move some data and make cool shit happen.
&gt; Please try to avoid using your projects as the goalpost. Try putting together (even a highly biased) sample from common packages and come back with some statistically useful evidence. That's a reasonable suggestion, the value to PHP users as a whole should be taken into account when making decisions like those. But I'm not a core PHP developer, so I can only point to experiences I've had during my work as a developer, and things I hear in the corridors at my work. I can honestly say that the current closure syntax is causing me physical pain, even in trivial "non-functional" scenarios like templates: &lt;?php $layout = function($content, $title = '', $head = '', $bodyClass = '') use ($model, $log, $esc, $tag, $render, $import) { ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; ... &lt;/html&gt; &lt;?php } // $layout ?&gt; Versus: &lt;?php $layout = ($content, $title = '', $head = '', $bodyClass = '') ~&gt; { ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; ... &lt;/html&gt; &lt;?php } // $layout ?&gt; &gt; A minority want a short syntax for closures in PHP so that it allows them to write cleaner code in their functional style (less lines, if you chain). That's the nature of this proposed RFC. Apparently it's the same minority that got the same short syntax in C#, JavaScript and Java. Let me ask you, how *exactly* do you judge it's a minority who want them in? Given your inclination towards the rigorous, objective and scientifically accurate, I suppose you've interviewed a representative sample of developers in order to gain a statistically useful evidence? I bet you have. &gt; Serving a potential style not a compelling reason to have a short syntax. If you're just going to support short syntax everywhere, change function to fn and public to pb and private to pv. Some of these gaudy suggestions may actually speak to your sensibilities. That's not just arbitrary as a statement, but also rude.
&gt; Let me ask you, how exactly do you judge it's a minority who want them in? That's a difficult question because I do not have a methodology. What I prefer, is a static analysis of packages like Guzzle Symphony AWS APIs etc (pick your favorites) and an inspection of how such a sampling doesn't just USE closures, but how they could leverage a new syntax. The latter is a lot of work, so generally you can do a once-over of the former in an hour.
Closures are predominantly used in application code for libraries which *accept callables*. As one example, I use a validation library where every class represents a format, and I have plenty of ad-hoc one-time-use formats in application code. This predominant use of ad-hoc formats is accomplished entirely with closures, and the only evidence of this in the library is one single class: class AnonFormat { function __construct(\Closure $apply) {...}} So your statistic analysis that's composed only out of libraries is already useless before you even start. Not that you care, I mean you attitude here is somewhat transparent. 
well... i'm pretty sure an object will cast to to true. he's using ==. if he was using ===, it would always fall into the else blog and beAwasome(). Instead, it's just a err.
== true. Not === true Or something
Hi, I was wondering what is the best way to share code between projects, lets say I have a Time class, and I don't want to be copying and pasting every time I update it in either project that shares it. How would I go about doing that?
Also happens to be a stupid motto. "Hey guys, if your feeling sad... just stop feeling sad!" What are you fucking Marie Antoinette or something?
Just to clarify one more step for anyone reading: ~~The number looks like 0^830400451993494058024219903391 which is obviously 0.~~ Edit: forgot the important part, fixed below 
I haven't dealt with Zend but I have with Symfony, and my experience does reflect your statements. I'm probably going to do the CVE ID thing too. :)
It's slightly subtle though. Use === in the following cases: 1. Comparing two strings. If not sure if they're both strings you can do: (string) $foo === (string) $bar, for string comparison semantics. 2. Checking if a value is null. 3. Checking if a value is boolean false and not just falsey (unfortunately required for many internal functions, it's their "no result" result). 4. Comparing two vars holding objects for identity (i.e. "is it the same object"). Do **not** use === in the following cases: 1. Comparing two numbers, when you're not 100% if they're int, float, or numeric string (get/post input, database input etc., integer converted to float by PHP on 32-bit systems etc.). 2. Ehmm that's it (still, math matters).
Inconsistent tab spacing, what a joke
Incorrect, it looks like 0*10^830400451993494058024219903391
Yep you're totally right. Messing with reddits formatting meant I plumb forgot, heh
I usually start with my sexuality and then go into design patterns.
And when using hashes for passwords in PHP you should be using the passwords hashing api (http://php.net/password) or /u/ircmaxell's password compat library (https://github.com/ircmaxell/password_compat) 
Input Filtering &amp; Validation with Aura.Filter : http://websec.io/2013/12/31/Input-Filtering-Validation-Aura-Filter.html
very sensible，thank you
Hi, thanks, yes thats true the (foo/bar;baz="q;2,3";q=0.5) case gets not handeled correctly. For me this is also a performance issue by not covering this case we can parser the mime much faster and I dont known a common mime attribute which contains an ";". On the other hand handling all the cases correctly would be great ... I will check your library and see how the performance difference is. Regarding the PSR-7 interfaces, unfortunately the PSR is not accepted yet and since this is a stable version I could not depend on an PSR which is not final yet. 
Except the t-shirt says to only be awesome if you're not sad. If you're sad, you should sing(), then the code never allows you to be awesome.
The usual approach is to use a database abstraction layer (or "dbal") in between your application and PDO. You can then have this dbal layer simulate nested transactions with code like this: class DBALConnection { protected $dbc; // The underlying ("raw") connection protected $transactionLevel = 0; public function beginTransaction() { if ($this-&gt;transactionLevel == 0) { $this-&gt;dbc-&gt;beginTransaction(); } $this-&gt;transactionLevel++; } public function commit() { // TODO: Make sure this doesn't go below 0 $this-&gt;transactionLevel--; if ($this-&gt;transactionLevel == 0) { $this-&gt;dbc-&gt;commit(); } } } This is basically the same approach used by Doctrine's DBAL library: https://doctrine-dbal.readthedocs.org/en/latest/reference/transactions.html#transaction-nesting
Aah yes, fair point. I shall update it! :)
Did he mention singing, though?
Yeah, I've used it on several projects and haven't experienced any issues or annoying limitations. I'd definitely recommend it.
This is the way I do it. Each project has a `composer.json`. Each project is in a private remote git repo. If I make a change to the `Time` class (in whichever repo it lives in in github), all I have to do is run: composer update In the repository that needs to have the new `Time` code brought in, and that's it! It also allows you to switch to an experimental development branch of the `Time` class in any other project quickly if you wanted to. 
&gt; I've been all C# lately. Haha what are you, some kind of- oh who am I kidding. I used C# for my bachelor's thesis because Unity.
I like my templates plain and without branching logic or loops. :P
This seems to work for me: $emList = $emXPath-&gt;query("//div[contains(@class, 'lead')]"); foreach($emList as $row){ $name_tag = $emXPath-&gt;query(".//span[contains(@class,'name')]",$row)-&gt;item(0)-&gt;nodeValue; $title_tag = $emXPath-&gt;query(".//span[contains(@class,'title')]",$row)-&gt;item(0)-&gt;nodeValue; echo "$name_tag: $title_tag\n"; } Prints Mark: Sales Associate If you leave out the filter for class=lead: Bob: Sales Associate Jane: Sales Associate Mark: Sales Associate Louis: Sales Associate
in what language does one use `if(boolvar == true)` doesn't one just `if(boolvar)`
 function stop(){ return "php"; } function sad(){ return "I can't even "; }
The object on your face is actually a static proxy to a Goatee Factory that returns an extended Symfony\PlumageFoundation\FacialHair instance.
Why are you even trying to rationalise it? :) I get the impression this sort of t-shirt was made by a hipster trying to appeal to "geek-chic".
Things like post types and markdown are things that can be plugged into a framework like Symfony pretty easily. It may be worth rolling your own.
well, it'll throw an error when it gets to the point where it stops being sad... so I guess that means you can never not be sad.
Fixed.
Wordpress. /s
Thanks! this is exactly what I wanted cleared up.
Is there any PHP based product that can compete with the hype of non-PHP technologies? As bad as it sounds, hype sells in the job market, and people are being told to learn web programming in anything *but* PHP. As someone who has been using the LAMP stack for a few years, I am sometimes genuinely worried about losing my marketability in the programming field.
WordPress XD
how is that even good? That almost seems overkill. I would love to show my teachers just how spaghetti my code can be :)
IMO the best coding standard would be to clamp down the *percentage* of a file's lines which are "too long", because there are always a few places where it makes more sense to leave them than to find a nice way to make it multi-line.
If you don't need interactive stuff like comments, you could use a static site generator.
I'm going to go ahead and play the I'm dumb card. Whats wrong with that?
Heroku only offers AWS, while Modulus offers AWS, Joyent, and Digital Ocean. 
In short, using closing tags leaves the possibility of adding additional newlines where you don't expect them. There are many other answers/opinions, but I'd say the biggest thing for me is that you should be separating your templating code from controller/etc and really shouldn't need to use them. Depending on what style guidelines you use, an extra linebreak at the end of the file could have unintended consequences if it follows a closing `?&gt;`. An example: Imagine a simple controller: &lt;?php ob_start(); include_once($template); header('Content-Type: application/json'); print_r(json_encode($json)); ob_end_flush(); // EOF When loaded with the following template, &lt;?php $json = ['message' =&gt; sprintf('The color of the day is %s.', 'red')]; // EOF This is the result: {"message": "The color of the day is red."} When using this template: &lt;?php $json = ['message' =&gt; sprintf('The color of the day is %s.', 'red')]; ?&gt; // EOF You get \n {"message": "The color of the day is red."} Which is invalid JSON. And if output buffering is removed from our controller, you'll end up with a nice `Cannot modify header information` warning since we're outputing a linebreak in our template before the `header()` call in the controller. Which is just a warning in this case, but you also aren't returning JSON data anymore, since you aren't sending the proper header. This got a bit rambly.
I see, makes sense. Thanks for the details clarification! I've been ending every single file I have every created with ?&gt; :(
Any other reasons? I'm pretty damn happy on the AWS stack.
That was what the "else" was for, beAwesome();
 if ( $sad == true){ $sad = false; sing($catchyTune); beAwesome(); } else { beAwesome(); } Been awhile since I did any PHP, but that makes more sense to me. Albeit kind of simple.
I agree. The Symfony project has an awesome code quality. Have a look at some OpenSource projects built with symfony: - [Sylius](http://sylius.org/) Open Source WebShop - [Piwik](http://piwik.org/) Open Source Web Analytics - [...more Projects built with Symfony](http://symfony.com/projects) 
You didn't do a single commit that you pushed to a central repo? I don't care how small a project is, create a repo and commit often. 
Yes, they can if they are MASSIVE includes (dozens of mb in size) and you don't have caching enabled, as their contents need to get read into memory on each request. Further, those includes need to be read off of a disk, and disk access can impose a performance penalty unless you're on SSD or SAS RAID. The more includes you have, the more of a penalty you face, but you shouldn't notice a penalty until you're including hundreds of files per request. Concerning Wordpress, Wordpress is slow because Wordpress is inefficient, and the more 3rd party plugins you add on to it, the slower it gets. Part of the inefficiency is because it is indeed including dozens and dozens and dozens of files whether they are used or not. It also makes unnecessarily heavy and slow queries, and builds massive query objects and puts them in the global scope. That's what happens when you build a platform that tries to solve a million and one different problems - it gets big, and slow, and heavy and inefficient. Regarding your quick example of 6 or so includes, unless those includes are dozens of MB in size, you shouldn't see any noticeable slow down.
I can't tell the difference anymore between the two anymore. Tell me again how you want to inject your singleton in my repository.
I'm ok with that they wanted it to be immutable. But it's unfortunate they didn't split it into a truly read-only immutable (no withFoo() methods) and a write-only builder (mutable, that can build immutable and use another immutable as a starting point). A builder avoids pointless cloning when you want to do a sequence of small mutations. A builder is also the more suitable option for a server response chain, because, well, you're still building the response, literally. P.S.: Every time I see them vote by posting +1 to a mailing list, I'm reminded of how ironic is that PHP devs didn't think to write a simple PHP app for voting.
Well, that's a well-formed script if you like it or not. Moreover, it's possible to execute it without issuing any errors/warnings nor making modifications.
In... Soviet Russia, PHP supports modulus. (I'm sorry)
You can also look into https://github.com/auraphp and go through the components you need. It is also one of the good readable code.
One weakness of Doctrine is that it doesn't support SAVEPOINT in order to be able to roll back a *nested* transaction. I solve this by using three different contracts for nested transactions: 1. top - should be a real topmost transaction (should be used rarely because it throws exceptions if nested) 2. stored - uses a storepoint so you can roll back if nested. 3. weak - what Doctrine does (nested transactions are only counted, no actual DB action). Doctrine also completely ignores the "transaction isolation level" (there are 4 of them), which is important because you don't want a code that needs SERIALIZABLE to run in a fake nested transaction that's READ UNCOMMITTED. That could cause data corruption. beginTransaction() should accept an isolation level and nested transactions should only accepts same-or-lower isolation levels to be semantically correct. CC: /u/OneMoreShoe/
https://laracasts.com
http://stackoverflow.com/questions/17237021/function-based-on-palindrome-using-php-code -&gt; It's all about recursion :)
https://laracasts.com/series/laravel-5-fundamentals in particular
 while($sad) { fap(); cry(); } eternalHappiness();
Why not just if ( $sad == true){ $sad = false; sing($catchyTune); } beAwesome();
Totally valid PHP, actually.
This solves the problem in context of persistence ignorance. You can manipulate with your entities, put it to repository (or remove from) and flush all changes with single transaction (preferable in front-controller before response). In this case your domain logic will know nothing about database and transactions.
To be fair, it's needed. Drupal 7's codebase is terrible. 
No, I'm trying to disable autocompleting this "&lt;??&gt;" to this "&lt;??&gt;&lt;?php".
Fixed. Thank you!
Take it easy, satan.
So which part of your code opens the transaction?
Also the boundary. No other code is aware of any transactional logic. The front-end just calls the boundary, and the business logic just uses the database/entities and throws an exception to "undo" it's changes.
I've recently started using jenkins to manage cron jobs. I've got a blog post half drafted, will post to reddit when it's live, but essentially having jenkins run the task gives you logging of the output and a vast array of notifications/actions on success/error.
&gt; flush all changes with single transaction (preferable in front-controller before response) As I said: the proper pattern is the Boundary pattern. I don't see why it would be preferable to commit the transaction (= flush the unit-of-work) in the front-end-code. Why should the front-end-code know that the business logic uses a database? 
Sadly, the "magical" typecasting in scenarios like these is one of the travesties within the internals of the language itself. For an even more trivial example: var_dump((0 == 'astring')); =&gt; bool(true); Edit: redundancy
Thanks for the great response. This caching thing. I am familiar with it. I have never used it. Do you use php or html for this?
I started with less complicated frameworks so I understood how PHP worked better, then just used the docs to build up what I needed when I needed it.
Fair question. The API provided by this package is stable, and will not change. If the commands implemented in Disque change upstream, following semantic versioning I will introduce those changes as major version updates.
What if the main aim of this shirt was to annoy us?
I still think ServerRequestInterface badly needs the withAttributes() method that allows replacing all attributes in one go. Adding and removing attributes one by one never happens in real life ( e.g. routers set a bunch of them in one go ). So to replace all attributes you would have to: foreach($toBeRemoved as $attr) { $serverRequest = $serverRequest-&gt;withoutAttribute($attr); } foreach($toBeAdded as $attr =&gt; $value) { $serverRequest = $serverRequest-&gt;withAttribute($attr, $value); } and each of those calls clones the entire ServerRequest instance every time, instead of just $serverRequest-&gt;withAttributes($newAttrs); Some people mentioned that it won't be much of a performance hit, and probably they are right. But I think thinking in that direction adds up in the end to a quite nice overhead. 
Not the author but the reason he returns a new instance instead of $this is to make the class immutable. For example: $command = $builder-&gt;setCommand('foo'); $command2 = $command-&gt;setCommand('bar'); $command !== $command2
I guess you're looking at the [ShellCommandBuilder](https://github.com/ptlis/shell-command/blob/c789d0b58aa1f942306c6764b9c714d6d9b6d5af/src/ShellCommandBuilder.php)? It's interesting you point that out as this is one place that I'm not 100% certain that I've made the right call - indecision on this point (and the lack of Windows support) are the main reasons I've not made a 1.0 release yet. As /u/panzerborn has already said - this is a side-effect of the design decision to make the builder immutable, but I can explain the rationale as to *why* I thought this was worthwhile. Builders are used as an alternative to factories when you still want a single point of creation, but for the average usage only some of the possible arguments are required. They allow us to incrementally build the instance we need while preventing said instance from being in an inconsistent/invalid state. In a language that supports named parameters this class would be redundant - but for us this provides the most clear way to fulfill these needs. Conventional (mutable) builders simply store the configuration (returning $this) but there are a number of undesirable side-effects of this implementation. The root problem is that the builder must provide a method to clear the state, meaning that: 1. The clear method must be updated to account for any new options added 2. In cases where the builder is partially configured but never built the user must themselves call clear. 3. A new builder instance must be used for each place that you need it - lest you 'pollute' the building of one command with the parameters from building another - this can happy in many places where usage is 'interleaved'. The main downside for doing it this way is that in cases where the library consumer is conditionally adding arguments they must explicitly keep track of the returned builder instances, for example: $builder = new ShellCommandBuilder(); $builder = $builder-&gt;setCommand('foo'); if ($awesome) { $builder = $builder-&gt;addArgument('--awesome'); } $command = $builder-&gt;build(); It's an interesting trade-off where I've had to decide where the complexity should lie. In this case I'm leaning towards keeping it as immutable. The main justification for this is that while the above example is uglier than it otherwise would be, incorrect use of the API (forgetting to re-assign $builder) would result in an obvious and easy to debug error. In the case of interleaved code the incorrect use of the API should also result in an obvious error, but it would most likely not be an easy to debug one.
You may never have run into these issues before, but it's a good practice to follow. [PSR2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) bans the use of closing tags in PHP-only files
They slammed PHP for its type system... then they went and programmed stuff in JavaScript.
Minor redundancy, fixed though.
&gt; For me this is also a performance issue [...] That's a reasonable consideration - I would be interested in how large a 'slice' of the request time they would take respectively. There are other (more subtle and more likely) places where your existing implementation would misbehave. I'm thinking specifically around matching precedence - for example: The UA provides an Accept field containing ```*/*,application/*,application/json```. The application can emit responses of types: * ```text/html``` * ```application/json``` * ```application/xml``` In this case the application should always return ```application/json```, but without considering wildcard/matching precedence the negotiation may return any one of these representations (most likely determined by the order of types in the Accept field / provided by the application). &gt; Regarding the PSR-7 interfaces, unfortunately the PSR is not accepted yet and since this is a stable version I could not depend on an PSR which is not final yet. [psr/http-message](https://packagist.org/packages/psr/http-message) has an official packagist entry - just make sure that you restrict the release to the one you're targeting (eg ```"psr/http-message": "~0.10") while we wait for it to be ratified. I've recently done this for a friend's framework, and this is how most people testing PSR-7 have done things - it works!
I flush all changes in front controller. Right before response was created (response object generated also in fron controller) and served. In context of MySQL, which doesn't support transaction levels, there is no difference.
Is there any reason you need to clutter your machine with PHP, MySQL and a webserver other than using it for development? If not I would *strongly* advise you to use a virtual machine. Vagrant is a popular tool to have your code on your local machine but the environment it runs in, in a VM. It is extremely easy to use with vagrant boxes that were made especially for PHP like [Homestead](http://laravel.com/docs/5.0/homestead). It's very easy to set up with the benefit that your stuff will run in an environment that closely resembles that of the Linux webserver where it's ultimately going to run.
Best framework is Symfony 2. Best development company for Symfony is http://stfalcon.com/en/
Do you use EAP builds? I'm using PS-141.690.
https://dev.mysql.com/doc/refman/5.0/en/select.html Ctrl + F "limit"
Yes - I'm on 141.891 - so you are behind. Please see my EDIT.
Thanks. Now if I want to select everything, but the first 5 rows. How do I do that?
WordPress is a mess. But battle-tested mess (and still holes come up now and then, like clockwork). But that's a very tricky question as it hinges entirely on the meaning of your "I am understanding PHP pretty well". Have you thought about XSS, CSRF, input validation, login bruteforce, etc.? Do you believe you have a solid strategy for dealing with those (and if you want, give me the brief and I'll let you know what I think)? Do you understand what I'm saying without googling? If you answer no to any of those questions, I wouldn't do my own production CMS if I were you (don't let me stop you from learning by experimenting though).
I do not see anything about &lt;?php, and anyway Live Templates expands by Tab/Space/etc. But this expands on "&gt;". I'll try to update and turn off some groups of Live Templates, I guess. Anyway, thank you!
I think it's "LIMIT 5" to select all rows from the 6th row on.
If your goal is to learn programming, dont use WP. It is a bloody trashy procedural mess.
Also, if provoked, I'll write and post a "mock" library clocking under 32 (short) lines of code :P
The mysql_* methods have been deprecated for years and will be removed with the next major version of PHP, which will be out in a year or less. In addition, your code is open to a very simple SQL injection attack. Until these issues are fixed, I'm going to recommend against this site as a source of tutorials, as you're teaching people bad practices.
I thought it was the other way around. I thought the first number was how far down and the second was the number to select
Wordpress core, when configured properly on a server, is quite secure. When you start adding dozens of the "My First PHP Project!™" caliber plugins you see in the Wordpress ecosystem, then security becomes questionable. Is core Wordpress more secure than what you'll be able to get on the first try? Probably. Security isn't the easiest thing to get right, but it's important that you know it, so I would definitely go for making your own CMS in a framework to help you learn better. You just have to be open to feedback and criticism (pro tip, other programmers can be dicks, just have to roll with it).
Another point I would make is that the admin interface to your CMS, will probably be far worse than the default Wordpress admin. If you expect non-programmers to interact with your content, usability is important and wordpress has proven fairly good for our uses (at least better than many others we have tried).
 &gt; Just as an FYI. Using a framework prevents you from commiting many of these mistakes. Yes, it prevents you, [except when it doesn't](https://labs.mwrinfosecurity.com/blog/2014/04/11/laravel-cookie-forgery-decryption-and-rce/). Unfortunately there's no shortcut to perfection.
As a second year student, you should do it because its a good learning experience. Until you graduate and have 5+ years of experience deal with a real hacker magnet [due to credit card info or the like], I suspect you'd make many mistakes. So I wouldn't try to sell it for money. If you are an industry veteran responsible for PCI and handling 8 figures in transactions every year via a PHP website, then, yeah...you probably can beat Wordpress's security quality. It really takes real world experience with security before you can confidently say "Yes, I can do better" and a track record to back it. That is what I'm getting at.
Code you write needs to be tested. How else do you know if it's going to work? When you start, it's usually a case of trying out a few different things (if I click this button, does it do the right thing, etc), but that takes a fair amount of effort, and you're probably going to forget to test certain things. So someone invented automated testing. There's different ways to go about doing automated testing, either by unit tests (which generally test individual functions and classes to make sure that, if you give them the right input they'll produce the right output), and acceptance tests (which generally test that when you submit a form it returns the right thing). Or, more likely, a combination of both. But now you've got to run a script that tests all these features, and you've got to run it every time you change everything, and *that's* boring. Why not test things every time you make a change *automatically*? That's what continuous integration does. Generally there'll be some sort of webservice that listens to updates to your code (usually by listening to a version control system like git/GitHub), and, when a change has been made, re-runs all of your tests to see if the code still does what you expect it to do. If it doesn't, the fact that you have tests should make it easier to see which bits are going wrong, and try to fix them.
&gt; Next attempt to solve the problem was to use symlink – we had one symlinked directory as NGINX root, deployed new code to fresh directory and switched symlink to this latest directory. This didn’t work either because PHP’s realpath cache didn’t have up-to-date information where files were. I wonder how Laravel Envoyer overcomes this issue then, since I know it uses symlinks for deploy switching.
IMO, all framework makes you produce a bloody mess because of the nature of the web and MVC in general. Having said that, wordpress is MUCH worse than that. WP actually encourages you to code in a bad way with incredibly bad structure. DRY, SOLID, DP don't exist in the WP universe!
&gt; I am understanding PHP pretty well now PHP is but one component; it's a language you use when building applications. Think of the rest of the application without specifically thinking of them as "PHP", but systems - login, registration, templating, data access, etc. Think of the security aspects of each, the performance of each, etc - then think of how PHP relates to those concerns. IOW, spend time building your own systems, whether they're necessarily CMS or not. Doing this as student is the time to be doing some of this learning, so you're better prepared when you enter the 'real world' in a few years. Make your mistakes now. Look at how WP does stuff - learn from it. Unless you specifically want to build WP plugins or themes or whatever, figuring this stuff out on your own will yield better results long term. That said, looking at how WP does stuff won't hurt, and may give you some ideas. Some of the *features* of WP are interesting/useful, but not always done well. 
Continuous integration simply means don't work long in isolation from the other parts of the project. Merge and test the whole solution regularly (once a day or once a week is good for most projects). Of course, the term has been recently hijacked by cargo cultists who "integrate" (by which they mean they blindly trust a suite of integration tests they run on a server) hundreds of times a day. If we have to be for real, continuous integration for a PHP app is this: 1. Connect with FileZilla to FTP. 2. Select correct local folder, select correct remote folder. 3. Upload "about-us.php" or whatever else you're messing with. 4. Reload browser tab. Did it derp? Mess around with it more, then go to 3. 5. The end. I'm kind of exaggerating but honestly a light workflow is the whole point of PHP. If you will use a Java workflow for PHP, it's not worth using PHP. Use Java.
Oh, hey, look! Someone trolling on /r/PHP. How novel... Edit: Well, at least he updated his comment to be a tiny bit less trolly.
I am not a huge fan of frameworks, but I understand that normally they lead to where I am going faster than writing, debugging, and maintaining my own framework. I feel like this comment if full of hyperbole. Have you used wordpress extensively in the last few years? My experience has been fairly dramatically better than all that (I have been deploying sites with it consistently for 10 years and its been a cornerstone of a reasonably successful business for 6). I feel like I spend significantly less time writing boilerplate and already written things when in wordpress than in other comparable frameworks. Not repeating yourself is available everywhere with functions. Dynamic programming is available everywhere with (global/static) storage. SOLID is a particular model for organizing OO code, which wordpress is not attempting to be (I guess to its fault). The definition of "incredibly bad" for me implies some fundamental brokenness, that I have not experienced. Again, my primary metric for quality here is that it accomplishes what I need with the minimum fuss, which wordpress has done in spades. For me its been the right tool for the right job; deploying small websites with contact forms doesn't get a whole lot easier than wordpress. For reference, I have used or been exposed to Trac (which has a built in framework), web.py, modx, wordpress, ruby on rails, .net nuke, .net MVC, .net WebForms / WebApps, Angular, more I am forgetting and plenty of custom crud built in house by a hundred different people. 
Thanks! :D
&gt; DRY, SOLID, DP don't exist in the WP universe! But any of them can exist. The WordPress core may be a mess, but that doesn't mean you have to write messy code to go along with it when building a site. You can even [use composer](https://roots.io/using-composer-with-wordpress/), which makes WordPress pretty bearable.
If you go to packagist and search, you'll find plenty of stuff. https://packagist.org/search/?q=image%20processing 
Right but I'm saying any PHP example in a README will work inside Laravel exactly as it is. For example [league/commonmark](http://commonmark.thephpleague.com/basic-usage/). Usage in PHP: use League\CommonMark\CommonMarkConverter; $converter = new CommonMarkConverter(); echo $converter-&gt;convertToHtml('# Hello World!'); Usage in Laravel: use League\CommonMark\CommonMarkConverter; $converter = new CommonMarkConverter(); echo $converter-&gt;convertToHtml('# Hello World!'); :)
WordPress is a gigantic security concern. Hell, [take a look at this](http://www-personal.umich.edu/~markmont/awp/), a way to get root access to a server from an insecure WordPress install. The only way to reasonably stay secure with WordPress is to use the most up to date version, as vulnerbilities are found all the time. And using the most current version means that you're limited in what plugins you can use, which is generally the main reason people use WordPress. Basically, WordPress suffers the classic PHP security problem but at a larger scale. If you do it right it's completely fine, but it's so easy to do it wrong. If you want some half-blend of learning and immediately functional, I recommend [OctoberCMS](https://octobercms.com/). I haven't used it, but it's a fully-fledged CMS that uses Laravel and is intended for you to jump in and change things. 
He never said it wasn't a good tool. He said it wasn't a good tool to learn from. I agree.
&gt; I'm thinking I may have to resort to using PHPMailer's built in SMTP functionality to do it, just trying to avoid rewriting code. This is a perfectly sane approach. Consider Swiftmailer as well.
Maybe have a look at [Themosis](http://framework.themosis.com/) - Laravel meets WordPress. Quite neat.
Let's say I try to secure my CMS as much as Wordpress. How long will that take me? So far, most of the time Ive run into security issues, they could be solved within minutes (like adding an AND user = SESSION[user] command to the SQL statement or the password_hash etc). Maybe I am very noob at this though. Could you maybe give a rough estimate?
The caching referred to is a bytecode cache, provided by either ext/opcache in current PHP versions or by ext/apc or other older extensions for older PHP versions.
It could be anything, including your own connection. Use the network monitoring functionality in your browser's developer debug panel to watch response times. If it's really taking a whole second or two to generate a single Wordpress page, then yes, something may be up with your hosting provider.
PHP shorttags http://php.net/manual/en/ini.core.php#ini.short-open-tag
You know if you broke shit every single time anyone commits, regardless of how sober or caffeinated they are.
The problem is that you'll get inconsistencies between switching the symlink and reloading php-fpm. 
I see. Looks like the default Ubuntu LAMP stack installed with tasksel has this disabled, I assume previously this was enabled. Cheers.
Fair enough and thanks again for your input, I think I understand more clearly what you are saying and mostly agree. &gt;... lanscape of plugins ... That's hardly a hit against wordpress, if you add bad code to any codebase, it will behave badly (garbage in / garbage out). I do agree its absurdly easy to add horrendous code to wordpress, and that this *can* be a problem. Cheers!