&gt; A payment gateway with zero tests is not very reassuring. Payum has lot of tests: https://travis-ci.org/Payum/Payum/jobs/90261827
&gt; accepts any value including null That's the point. `null` is a value. An empty, meaningless value, but still, a value. `acceptsNullOrAnything(noUsableReturn());` should throw an E_NOTICE. `null` is a usable return - it's type convertible and typecasting happens automatically in PHP. `void` shouldn't be - specially because `return null;` is prohibited on a `void` function.
Laravel 4,5 are supported. https://github.com/Payum/PayumLaravelPackage Not sure about 5.1
&gt; And that panic was largely my fault. I should've carefully handed things over rather than just disappear and leave others to pick up the pieces Good on you. Sounds like you've learned something about yourself and you've become more mature from this experience. &gt; Though there were some good things to come from it. Arguably, me quitting ensured scalar types' success Facepalm. I really hope you didn't come out of this thinking that quitting or throwing a fit helps you get what you want.
Absolutely no. This is just to discuss. Without knowing the needs of the community, no debate is possible. So I am gathering some data :-).
Thanks!
~~This has already been posted about 6 month ago : [here](https://www.reddit.com/r/PHP/comments/33g9zq/speeding_up_the_web_with_php_7/)~~ Didn't see it was another version for phpconf taiwan, my bad. 
and thankfully for that ;)
&gt; I really hope you didn't come out of this thinking that quitting or throwing a fit helps you get what you want. Not at all. I mean that in *this specific case* quitting actually did help, but that was luck; as I mentioned in the post, if it wasn't for others' heroism, me leaving might have doomed it. Thing is, scalar type hints, prior to me quitting, was quite likely to fail: it wasn't going to secure a majority judging by the voting patterns up to that point (it would oscillate between narrowly meeting and not meeting the pass mark), was running out of new people to vote in favour, and there wasn't anything on the horizon that was going to change its fortunes. It was ironically revitalised by my disappearance, because the RFC had to be relaunched by someone else. But that doesn't mean disappearing in the middle of a controversy like this one is a good idea generally. Fate works in mysterious ways.
I know that it would discourage people from upgrading because it would break BC but... at some point, we need to sort of go through the entire language and clean it up and introduce some consistency!
Yeah I was in the process of something like this solution, full page caching.
Why does your link of 'certain heroes' point to the RFC of 'Reserve even more types'? Shouldnt it be this one 'Reserve more types' instead? They are two different RFCs. https://wiki.php.net/rfc/reserve_more_types_in_php_7
Glad to have you back!
seems you realised that you don't get the same recognition as you were while being a part of internals. :) take it simple, that was just an rfc... so much drama, gosh...
It is hard to put the tests into a separate folder because of the git subtree split.
I did not know you left but +1 for helping so much, contributing to something I love. I've Really wanted scalar types for some time, and rather than try to contribute to the core (I know C, I've compiled extensions, I'm sure I could given time and guidance); I took up learning other new languages (Ruby, strengthened my python, even done some more C for internal business projects, and most shockingly I now do some Node work). The thing is I think we (people, not just the PHP community), often don't realize how much we owe to the often faceless contributors; people spout facts like "In JS everything is an object, and you can hot-patch &amp; prototype, and some other nice things" that a lot of languages (so not just PHP) do not do. I Think this will bring a lot more status to PHP to have the work you've mentioned, and quell some of the less constructive feedback through all the big changes over the past 5 years. So again thank you! Are you back on internals, and if you are, are you going to take a measured approach to help you get to a place where everything is comfortable, and fun, but you don't have to do too much? I was at MozFest over the weekend in London and a lot of developers and IT people were telling me it's not that they don't enjoy certain things, but that the pressures on them are mainly unrealistic expectations, and themselves over-committing, rather than the job(s) not being fun, or the people they work with. 
This really smells like premature optimisation. If your application cannot handle input sanitation there's something seriously wrong with your application or application infrastructure. 
See also https://www.reddit.com/r/PHP/comments/3sae2x/why_was_php_made_with_partial_case_insensitivity/ from 3 hours ago.
I would suggest adding actual functions instead of wrapping php internal functions. Example: ` is_hex() ` 
so instead of just using is_array for example i should use your class and call isArray which simply use the built in function? Good that you want to publish code but it has to actually solve a problem to be useful. 
If we are talking about helper functions like Laravel's array helper functions than of course there is a little difference but if it is functions related to business logic for example than obvious benefits are testebility and code reusability
Literally *any* use of a void function in an expression is broken. The effects of that breakage will vary from nothing to sev1 defect, depending on the context.
I think the point was that most people already know about this.
This is really good news, indeed!! Thanks for taking the time to write that out. Hey, you see what just happened? Now we have you and Anthony back! Sweet!!! Thanks a lot for all you've been doing. PHP needs someone like you!! &gt; Interesting things lie ahead! Glad to have you back and even more glad to read that! :) 
Well, I think that's more because most people use it, and not because people don't know about it. And yes, I realize there are exceptions. I'm not complaining. By the way, also check out PHPCS if this is new to you. It warns you of things like high complexities and tight coupling, and other bad practices present in your code :) 
Heh, yes. But I made the wild assumption that most people on this sub-reddit probably don't remember a submission from four years ago. Maybe everyone else has a much better memory than me. :(
&gt;why did PhP decide Don't you hate it when your code starts to make its own decisions? 
I use `phpcs` and like it quite a lot, but thanks for mentioning it just in case anyone else reading this hasn't tried it before.
The functions naming must follow the same pattern too. Ruby and Python that some OSs relay on heavenly broke the backward compatible just like that (and caused a lot of problems...) while PHP who's been used mainly on web didn't... 
&gt; Are you back on internals Yep. &gt; are you going to take a measured approach to help you get to a place where everything is comfortable, and fun, but you don't have to do too much? That's generally how things are anyway. I do things which interest me when I feel like it. The killer with 7 was the deadline and me doing too much at once.
So its not really library, more of a test suite.
&gt; Both Laravel and Symfony are "high-level" frameworks, meaning they do lots of behind-the-scenes "black-box magic" in stuff like sessions, url-handling, templating, etc. so you end up not learning how php does that stuff I don't think you know the difference between "high level" and "low level". PHP itself is a high-level language. A framework's level has nothing to do with its abstractions or behind-the-scenes work and everything to do with its concerns. Further, PHP doesn't do "url-handling". An HTTP server like Apache or NGINX does, and simply routes unknown requests to an application's entry point (ie: /public/index.php) for further handling. Routing is a low-level concern. Validation is a low-level concern. Templating (Blade, Twig, Plates, etc.) is a high-level concern. Slim, Laravel, and Symfony all handle these low and high-level concerns in largely the same way. The only differences between them is the saturation of low-level vs high-level concerns. &gt; They are also railsesque frameworks in the sense that they force you into their own style of doing things the way Ruby on Rails framework does. "Railsesque" is a colloquialism, and you aren't even using that correctly. "Railsesque" is a lazy way of highlighting a framework's attempt at implementing the Model-View-Controller pattern in a Web Framework. Not how strictly it makes you adhere to its own patterns. Additionally, Rails merely popularized the MVC pattern in the Ruby community. [Spring](https://en.wikipedia.org/wiki/Spring_Framework) was around far longer, and is widely believed to be the first framework that brought MVC (or ADR for the purists) to the web space. &gt; Being a Buddhist, I like the "middle path" offered by Code Igniter. Your religion is irrelevant. Additionally, CodeIgniter (one word) isn't a "middle path". It's just another framework, and a stagnant one at that. It follows no PSR standards. It does not leverage Composer. It follows no modern practices that PHP has seen in the past 3 years. If people expect to adopt modern PHP practices, CodeIgniter is the *last* framework they should touch. &gt; At the same time, CI is just a thin wrapper around php, so you can dig into the code and understand how things are happening pretty easily! You can do that in any framework. Not just CodeIgniter. It's not as if other frameworks are obfuscating their code. &gt; It serves both the purposes of a "high-level" and "low-level" framework. Again, you don't know what "high-level" and "low-level" is. &gt; This is one of the reasons why questions tagged CodeIgniter are most popular on StackOverflow, even more so than symfony and laravel, because people use it more! You're actually using the number of questions on StackOverflow as a metric for popularity? I'm sorry, but that's absurd. Both Laravel and Symfony 2's releases were in 2011. CodeIgniter was released in 2006. There are fewer questions about Laravel and Symfony2 ***because they've been around for less than half as long***. If anything, Laravel and Symfony's rapid rise in its user base is a greater indication of popularity than number of questions asked on StackOverflow.
And how will you detect an hexadecimal value? PHP thinks that the hexadecimal and a binary values a are integers. With regular expressions? In that case, how do you tell to the `isInteger` function to reject that two types?
Just explaining the other guy's comment, I offered no opinion on the matter. Thanks for downvoting!
Serious question: can you definitively tell who has downvoted you? Just something I've wondered before when using Reddit.
No, there's no way of knowing. (For the record, my comment was tongue in cheek.)
Ah ok, thanks. I know some browser plugins exist to enhance use of Reddit, and thought maybe one of them let people see exactly who downvoted them. Thank you for the info!
Interesting, didn't know NetBeans enforced any rules on PHP code, as I've never used NetBeans before---well, for about ten minutes just to try it out once, but that's it.
I stand corrected. :) In 20+ years of RDBMS work, I have never seen 6NF. :) Cheers! =C=
I sometimes feel we're kind of lacking easier, good, modern tutorials. planet-php used to be a lot more about that as well, but as everybody became more experienced, people blog less and about much more specific things.
If you're looking for excuses to drop PHP, this is a pretty obscure one. Why not some of the weird type juggling quirks, inconsistent argument ordering in string and array functions, etc? Either of those are infinitely more likely to have a negative impact on your workflow than case-insensitive functions.
Quite often. Admittedly some of it is even mine. Usually stems from requirements changing but not wanting to remove code incase minds are changed to go back and then it is forgotten about. In terms of other people's work and plugins - still, all the time. 
Multiple people have shown you gaps in your current system. By the time you expand it to a ten thousand line function that actually properly covers all the edge cases, you'll realise you've written something slower than htmlpurifier.
why is the global namespace explicitly used for booleans? 
This reply has been done before, perhaps a few thousand times. We get it.
This is a really good tool, [one of many](http://www.sitepoint.com/8-must-have-php-quality-assurance-tools/). It's a real shame they're so underused, especially in the newbie waters.
nice - now sublime text plugin is missing - anyone to write :) 
I'm working on a large legacy project, and quite frequently it's found that 5-10 files can simply be deleted as while they did work however many years ago, a lazy refactor since then severed them and didn't delete them. They best ones are the ones with fatal errors (missing includes, unknown functions) on the first 5 lines of the file, but haven't been modified in 2 years. Immediately deleted along with all of their orphaned dependencies. I also employ a strategy of leaving tombstones in the path of suspected dead code, then letting that out into production for a couple of releases. The longer the tombstone isn't called, the more certain you can be the code is dead. http://devblog.nestoria.com/post/115930183873/tombstones-for-dead-code Why this stuff wasn't deleted in the first place I don't know. potentially it's sentimentality on the part of a previous developer? I'm always of the mind that we have a history of pull requests and a VCS system. Delete it now, you can always get it back later if you made a mistake. The benefits of a maintainable, readable codebase easily outweight the thought ot "yeah, but we might need that in the future.".
phpcs, phpfmt, phpmd should be in every developer's toolbox
As tank said : legacy projects. I also have been working on an old app and there's tons of stuff that has been removed. So many people have worked on this project, some made it better others made it worse but in the end you always end up with unused methods and files.
You may also be interested in services that provide a similar function like [Scrutinizer](https://scrutinizer-ci.com/) or [Code Climate](https://codeclimate.com/) - both have free options if your project is open source. Oh hey, [as discussed here previously](https://www.reddit.com/r/PHP/comments/2u2g2e/comparison_of_php_code_quality_tools/)
I really identify to the : "I hate my life" commit
I think the best one I have found to date was a code block surrounded in if (false) { ... } When I asked the dev, he answered "I didn't want to delete it in case we used it again the future and I don't really trust git".
at least when i asked a few month ago they said "nope"
Great! congrats for Platinum Medal ;)
Same as todomvc for javascript :) Nice to have same for backend.
Honest question, how is scouring through possibly hundreds of commits to find an old version with the right code better than just commenting out a block of code?
My own approach is to place a function call that essentially invokes trigger_error() with a specific identifier that's easy to search for. Once a week I scan my log files for any deprecated code messages to see if it's actually getting called. Might not be the cleanest, but if I can't tell that code is being called in more comfortable doing that compared to conditioning it out entirely, possibly breaking things in a subtle way that isn't noticed immediately. 
For many people this is a learning experience. Making their creation public also gives a sense of achievement. We all did it at some point or still do it. Either way you never know when one of these projects will become the next Laravel or Slim.
Usage tutorial [here](http://www.sitepoint.com/writing-php-git-hooks-with-static-review/).
Very often. Mostly because when I started working here 8 years ago it was already a legacy project dating some years back. As some of you might remember, PHP projects in the early 2000 weren't specially known for being state of the art kind of code and once in a while I'm still deleting code that haven't been or shouldn't have been executed in a decade.
&gt; Follow up question: how the new guy in 10 years will think of going through hundreds of commits just to see if there have ever been old logic? Why should they? If the particular bit of code is that old, you're probably best off rewriting it from scratch.
If you have a decent IDE, you can quickly scan through commits that affect that particular file. You can even filter the results. Also, it's not "better" than just commenting out. It's just cleaner and helps with manutenability. "better" is highly subjective here. I, for one, have been allocated to rewrite a specific app (originally written for PHP 4), but got in a lot of trouble trying to decide which functions had been used and which hadn't, because there was A LOT of unused code. At some point, we just figured it'd be easier to start from scratch, from requirements to development, because ~60% of code we were reading was garbage. There was a lot of unused links/buttons/reports/cruds in the system too, that someone requested sometime, but whoever it was had left the company a long time ago and nobody had ever used that thing again.
If it's a couple of years down the line, the code around may have changed so much that * the uncommented block might not work in that context anymore * odds are that nobody can remember what the commented out code was for anyway So you might as well delete it If it's not long after that you want the code back, someone should have a good idea when the commit was, so it'll be easy to get it back. 
Awesome work!
No, so you can go crazy with it!
Often, since the creators of my current production system were juniors and university students.
Nice catch! It has to be Padrino. Changed.
Working with corporate, decisions change faster than you'd ever imagine. After cherry picking old commits to re-add some previous functionality that was deemed "never to be needed ever again", I just started wrapping most things in feature flags. Oh, you want that area to be re-enable, but also have that specific change legal needed? Ok, done.
scrutinizer is awesome. and even though the new pricing is better than the old one, for the full benefit you need the large package, which is 200 euros a month, which puts it far away from something you'd want to use for private projects. As for companies, at the moment they are not offering an on-premise solution, which comes with various legal and safety issues. personally i use srutinizer for most of my OSS projects.
If you where to use valid JSON then you could just json_decode($json, true) and then access it as a normal array. $json = '{ "someId":{ "metaData":{ "name":"SomeName", "uid":"someId" }, "videoData":{ "age16":{ "video_01": {"jpg":"url_to_preview.jpg","mp4":"url_to_video.mp4"}, "video_02":{"jpg":"url_to_preview.jpg","mp4":"url_to_video.mp4"}}, "age18":{ "video_01":{"jpg":"url_to_preview.jpg","mp4":"url_to_video.mp4"}, "video_02":{"jpg":"url_to_preview.jpg","mp4":"url_to_video.mp4"} } } }}'; $array = json_decode($json, true); print_r($array);
Yes it is also an option but adding this kind of lib in require-dev have another impact. All the tools code come in your project and your codebase become very huge (but you use only a part of it for application execution). When a project require your lib, he get also the dependencies... I call that dependency hell :) Because when you require a lib you don't want to get all this kind of extra stuff. If the projet require this tools too but in different version it can cause conflict... These are totally useless because we don't care about each lib testing tools... It's a quick way to deal with it and a simple way to integrate with hooks and build.xml but it can inject real problems in the deps tree. Personnaly I use composer script to install phar version. This allow to integrate with all my CI tools easily. It's not ideal, maybe a composer plugin can be a solution... I hope that someday a require-test section will be added in the json or something like that :) We need to never forget that Composer work in "dev" mode as default so if the developer forget to add "--no-dev" option all these CI libs will be installed in prodution too !
You could try something like this -&gt; https://github.com/netresearch/jsonmapper. Should allow you to map the JSON response to a traversable object graph.
I think its better to link to her github account then: https://github.com/sgolemon
(about the site, not the content) Hmm. The `--webkit-font-smoothing: antialiased` seems to make the text more difficult to read. I'm in Chrome on Mac OS X with a retina screen. Essentially it makes the font lose contrast because of the smoothing, and given how thin the font is this makes it hard to read.
It may be that you want to keep that option and instead tweak other things – just up to you. It's mostly the combination of things, I suppose. Edit: in fact, making the smallest fonts on the page ~1.125x their size seems to make things nicer. I think that's better than removing the aliasing.
I would love to see generics in PHP. The [consensus](https://www.reddit.com/r/PHP/comments/3ivm0k/php_rfcgenerics_update_v02/) in previous discussions regarding that RFC was that the proposal itself was sort of half-baked (no implementation provided). If you want to get an RFC seriously considered, including a working patch seems pretty important to the process. That RFC isn't much better than the rest of us saying, "I sure hope somebody adds generics to PHP".
You can get by without a complete implementation. This happened with return types (still needed opcache support at time of voting). However, generics are a much larger feature that would require more changes. It is one of those RFCs that can't get by without any implementation at all. 
Both Laravel and Rails versions use a helper method to get the order_param, the method returns the "ORDER BY" part of the SQL based on $_GET['order'] Rails: https://github.com/komarserjio/notejam/blob/master/rubyonrails/notejam/app/controllers/application_controller.rb#L23 Laravel: https://github.com/komarserjio/notejam/blob/master/laravel/notejam/app/controllers/BaseController.php#L18 RoR is based on Convention over Configuration, which means that you don't need View::make('note/index'), because rails knows the view will be called "note/index", since you're in notes_controller, index action. You can override this behavior, but the idea is that most of the time you don't want to change this, and it brings consistency. Fewer lines don't always mean something is better. But for common operations like listing all the records of a determined model, ~~there is no way i can understand why Simfony is so verbose~~. Update: DoListening provided a much cleaner version for the Symfony controller in the comments below.
And one more time: Do not link tags. Tags are not releases. Tags are preliminary and especially for RCs often retagged. There will be a proper, final release announcement tomorrow.
Implementation notwithstanding, this RFC is simply awfully underspecified. It is little more than the basic idea of "we could have generics". I would expect an RFC for generics to have a scroll bar no larger than 1cm.
&gt; I don't see how that is a reasonable expectation Why wouldn't it be? Usually a variable name means that its value will be substituted. We do this for `$$foo` and `$bar-&gt;$foo`. &gt; the ... operator doesn't support string keys Yes, that was done with named parameters in mind. If added, then it will support string keys.
If someone were to try and implement the RFC they'd have to do a ton of work defining everything themselves.
Nice look. Very very slow :-( .
can do that, only problem would be filtering when displaying. would look into it :)
Why is some of the docs not shown ? Eg : http://piephp.com/guide/firstModule
According to their Twitter, server issues: https://twitter.com/laracasts/status/664435439043018752
[**@laracasts**](https://twitter.com/laracasts/) &gt; [2015-11-11 13:32 UTC](https://twitter.com/laracasts/status/664435439043018752) &gt; Dealing with some server issues this morning. Working on it! Sorry if things are loading slowly. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
You want [jmespath.php](https://github.com/jmespath/jmespath.php), padawan.
&gt; Getting downvoted for whatever reason PHP 7 RC7 isn't released when you say it is. It's released when the PHP team releases it.
Sorry, I am not quite sure what you are asking. Prepared statements are a way of sending data to a database server, you should always be using those.
 if ( false ) { // hundreds of lines of code }
Having the words "RFC" and "generics" in the same title, you made me get my hopes up into thinking we're about to have generics already :(
Coverting it to a dot delimited array might be of use http://stackoverflow.com/questions/10424335/php-convert-multidimensional-array-to-2d-array-with-dot-notation-keys
That's why you mock the database so you're isolating what actually needs to be profiled. Think of it as a unit test, and the unit you're testing is the framework. You need to mock anything that is not part of the framework in order to isolate the system under test. I would try to aggregate several types of real world controllers: CRUD, form processing, validation, view hydration, etc. Then you'd have at least a bit better of an overall picture. You may even discover local deficiencies in the framework, where Lumen performs much better on a particular type of request. All that said, I think you should also bench other frameworks. The results other people publish is often heavily biased and almost always specific to a given environment and set of assumptions.
I have added the files, they are now viewable on the website.
Note: the cakephp code actually looks quite a bit more complicated than it needs to be, but still good effort nonetheless! Big fan of having something like this for multiple frameworks available.
There's a standard for this in JSON too, it's called [JMESpath](http://jmespath.org/).
It supports credit card payments, there is not any problems, what exactly payment gateway are you looking for?
I am making this recommendation without any knowledge of using it personally (beyond a quick test setup). How about Woocommerce? It uses Wordpress as a platform, so it has blogging, multi-lingual plugins, and more. It appears to have gained a lot of popularity in the last few years. Also, you may want to consider asking this in /r/ecommerce (and research there too).
Route #1 WooCommerce: It's a pretty full features eCommerce solution for small businesses, it doesn't take over everything but rather establishes a few pages, leaving you with WordPress to do with what you will. Route #2 Magento. Yeah, it's complicated to get going on, but after you learn it, you can change things relatively easy. Yeah, it can be slow, but you can make it damned fast with proper use of the FPC, Varnish, &amp; server configuration. It's also got plugins for just about damned everything you'd want.
I also strongly recommend [avoiding](https://github.com/opencart/opencart/issues/1534) [OpenCart](https://github.com/opencart/opencart/issues/1594).
That's awesome. Lemme try them out and feedback. Thanks!
WooCommerce itself is widely used - very easy to configure, register, ship, and pay. WordPress on the other hand, since it is so popular, is the target of many exploits - but as long as you patch regularly when they are released, you are pretty safe.
I did several wp exploits and you know it... I agree with you that **WooCommerce itself is widely used - very easy to configure, register, ship, and pay.** But will that be not too difficult if the business got too large in the future, can it easily be exported to other platforms, such as Magento?
What will you change?
Just realize Magento is a security/patch nightmare. However, they are adults and if you pay them enough they'll be nice to you. https://news.ycombinator.com/item?id=9413170 https://ma.ttias.be/magento-ecommerce-php-remote-code-execution/ 
Hey I got an comparison of those e-commerce platforms . the [link](https://en.wikipedia.org/wiki/Comparison_of_shopping_cart_software) Some ideas?
You can scale wordpress just as you can scale magento instances...
If you mean to ask, should you use that to choose? No, don't. Lists and tables like those can be highly deceptive. Prestashop which is my choice can support affiliates as in the table. However one of the popular plugins does this: `$true = 0.25+0.25+0.25+0.25;` Yes, Prestashop supports paypal but the module version I got did not handle checkout properly (locking the cart), didn't handle echecks correctly (marked as completed, didnt even clear yet), had no support for chargebacks/disputes. A table only gets you so far. No matter what option you choose you're going to be coding something.
I see. I did a lookup in WooCommerce and found that it's very complete and yet not cheap. I mean its plugins including payment, shipment, ordering. The budget for that site is not so optimistic. So.. Is there any way that we can use those plugins for free or try before we buy? 
I try not to, but sometimes we want to have some code in for a little bit. What I'll do is comment my code like this, so we can just remove the first slash and change the code block. (This is far from standard practice) //* if ($something) { $a = $b; } /*/ if ($somethingElse) { $a = $c; } //*/ Take that code, put it in your IDE, then remove the very first slash. Pretty neat :)
foreach ($rows as $row) { echo '&lt;input type="checkbox" name="edit[]" value="' . $row['id'] . '"&gt;'; } In a post form itll return each of the checked boxes with values as the row id, in the array $_POST['edit'] Hope that's what you were after!
That may work I will try it out. Setting the name of the checkbox as an array is what I was missing. EDIT: Thank you. It worked. I needed to name my checkboxes as an array. Then on the other page. $checked = $_POST['checkbox']; for($i = 0; $i&lt;count($checked); $i++) { //Do what I need it to here }
&gt; there is no way i can understand why Simfony is so verbose Because it doesn't force you to use a builtin ORM unlike the others, if you need syntax sugar, Laravel is your guy...
As well as if you download the last versions, they usually come with patches installed. So if you get CE/EE 1.(9/14).2.2 then they come with the biggest patches on there. Most aren't nearly as hefty and effort intensive as the recent 6788 patch.
I've never used it sorry. But yeah, as long as you accept you'll have to eat security/patching as a significant time investment Magento is fine. Its just a hidden cost.
I'm planning to use this for some examples for phpserializer.com I'm really thankful for this to be shared! Will keep you posted
I think you are mostly getting good advice here. However you mention the site needing a community aspect, and clients sharing with each other. I think the woocommerce / wp option covers blogging, but for sophisticated community features, you might want to consider using Drupal Commerce and then building the blogging and community features in Drupal. Drupal Commmerce has a lot of payment and adding more is reasonable. Registering with just an email address and password is also possible. However, just as is mentioned with regards to Magento in other comments, Drupal and Drupal Commerce are not small systems and they have learning curves, and involve fairly large investments. I think the investment can be justified but don't take it lightly. The fact that the suggestions here are all large, complex and crufty systems should warn you that building an ecommerce site (especially if it has community, blog, and other content aspects woven into it) is a large, complex, and hairy task.
Please do not use X-cart. I've used it in the past any pretty much any free cart has better features and support. One of my largest gripes is how **terrible** the shipping modules are. USPS issues a notice that they'll be disabling the current API *in a year* or so from the date the notice is sent out. X-cart developers don't have an update until **months** after it's actually disabled. You rely on the community for patches to shipping. The second largest issue I have with X-cart is the developer community is terrible. They use Ioncube to encrypt everything. When you buy a module for $500 you cannot modify anything except for the template. I have no idea what is in the PHP files.
Yes. It's based in Drupal, so you have thousands of free modules at you're disposal, including the CMS.
Definitely a significant step backwards, design wise. There was a very consistent look/feel with the previous design. The series graphics are all different styles and feel more like a hodge podge of stock graphics, than the minimal icon based graphics did before. Not that the site design really matters all that much, in relation to the site content, though.
I also hate ioncube products. It's all sealed inside. It's less updating, i would now consider X-cart at all. I would think about Prestashop or WooCommerce if possible. Thanks for mentioning.
Thanks man. This is really helpful! But it seems that WP does not use ORM (object relationship management) model. Or does it?
&gt; I just can not be an expert PHP developer now Some people here may disagree with me, but I wouldn't try doing this yourself if you don't have the technical knowledge to fix problems. None of the open source ecommerce packages are truly "install and forget." You're going to spend a lot of time trying to get them to work the way you want, getting the plugins to work, getting themes to work correctly, getting APIs to work, dealing with server issues and downtime, managing databases, etc. I know experienced PHP developers who have a lot of trouble with these applications. You are in for a world of hurt if you don't have the technical knowledge to manage a small PHP project, and you're going to end up creating a lousy customer experience. So, in addition to the advice already given, have you considered _not_ setting up your own store? You can set up a store without any technical knowledge using services like www.bigcommerce.com and www.shopify.com, and they're going to take care of most of the problems you're going to run into by doing it yourself, which includes shipping APIs, credit card processing APIs, etc. They also have big marketplaces for plugins to add new stuff to your store, and integrate the store with WordPress, Facebook, Twitter, etc.
Recently decided to not choose opencart for this exact reason. Edit : Has anybody used [Thelia](http://thelia.net/)?
Symfony's index method: public function listAction(Request $request) { $orderBy = $request-&gt;query-&gt;get('order', 'name'); $user = $this-&gt;get('security.context')-&gt;getToken()-&gt;getUser(); $notes = $this-&gt;getDoctrine() -&gt;getRepository('NotejamNoteBundle:Note') -&gt;findBy(array('user' =&gt; $user), $this-&gt;_buildOrderBy($orderBy)); return $this-&gt;render('NotejamNoteBundle:Note:list.html.twig', array( 'notes' =&gt; $notes )); } Laravel index method (note - this is for version 5.1, not 4.1 in the repo): public function index(Request $request) { $notes = auth()-&gt;user()-&gt;notes()-&gt;orderBy( $this-&gt;buildOrderBy($request) )-&gt;get(); return view('notes.list', compact('notes') ); } A pretty dramatic difference.
Almost no one works this way in day to day. They have a bug, they find the source and old, useful, code might be next to the source.
If we have to do this. 1==2 is our goto. Because it is very obvious that it is intended to be a "comment".
I do WordPress and WooCommerce development for private clients, I think I might be able to clear up a couple things. WordPress itself is not vulnerable (the core), it receives audits from private firms and it is maintained by a large community, in the event there is a vulnerability an auto patch will be released within hours and the website will auto update. It can scale, just one large website using WordPress is The New York Times, eBay even at one point used WordPress. WooCommerce is run by WooThemes which was just recently purchased by Automattic, Automattic is run by the founder of WordPress. WooCommerce also receives audits from the team at Sucuri and again has a large backing. The cost is in reality very cheap, nearly every paid plugin has a free version available somewhere you just need to know where to look. When coding for WordPress, it isn't like normal PHP sites you may have worked on. You cant just edit code directly, you will need to learn how to use actions, hooks, filters, etc. and build themes and plugins. WordPress gets a lot of flack for how "different" it is, and thats because it is very different and you will need to take a bit of time to understand how to code for it. Lastly, for the community side of things there is BuddyPress, BBPress can be used for forums, BuddyPress and BBPress also can work together when using the right plugins. For premium themes if you don't want to have a custom one made go to Themeforest: http://themeforest.net/category/wordpress/ecommerce A custom one will run you between $1,000 and $3,500, be cautious of places who take a premium theme and slap their branding on it then change a few parts of the stylesheet, this happens a lot unfortunately and to an untrained eye it is hard to tell when it is the case. For premium plugins go to Codecanyon: http://codecanyon.net/category/wordpress/ecommerce Let me know if you need some plugin recommendations, I can name a few I have previously worked with. 
Suggestion for the title of your future posts: tell us what your library does in the title. If I was just a small amount less motivated to read this already (people fitting that description constitute a large audience) I would skip this post without a thought!
***DO NOT USE MAGENTO.*** This behemoth of an application is an excellent demonstration on how good, simple principles can be abused and misinterpreted to make a program needlessly complex and unpleasant for both developers and users. It is, by far, the slowest widely-used PHP application out there. Here are some highlights of this software engineering disaster: * The application will often, literally, run hundreds of SQL queries for simple tasks. * The abuse of EAV obfuscates the database to the point of confusing some of the most experienced Magento developers. * Want to change the text on a button or some other trivial change? Be prepared to add half a dozen files to your codebase. * Its broken data import will not import data that its export feature exported (yes, [seriously](http://magento.stackexchange.com/questions/29566/magento-products-not-showing-up-after-import)) * Their "templating system" consists of HTML with &lt;?php echo ... ?&gt; all over the place. And let's not forget the best part: their design pattern. I can only describe their attempt at MVC as nonsensical. Some of my favorites: * Often folders named "Controller" and "controllers" cohabit the same feature. Which one do I use? Who knows! :D * All extensions rely on a configuration XML file. All of these files are carefully crammed into one folder. * The "skin" is completely separate from the "design." Like the core code, neither structure is consistent. * Their routing system is completely wrong. Routes should not in an xml file containing extension/module features. * The install directory, which is the most un-MVC thing in Magento, doesn't go away until you manually get rid of it. To compensate for the speed issues in this slow behemoth of an application, caching is an absolute must. Be prepared to shell out hundreds of dollars for hosting for decent equipment to host it. You will also likely need expensive extensions or broken free ones to do tasks that a proper shopping cart system would ordinarily do. It is said that Magento is primarily for large stores. Unfortunately, the bigger your Magento store gets, the slower it gets too. The Magento team is a corporation. They can't even get their own SEO right, as evidenced by the fact that they recently changed their forums but don't redirect their old links to new ones. They run an equally-useless stack exchange site on it, where only basic questions can be answered. Their documentation is, effectively, non-existent. I realize that bad software like Therac-25 kills people, but software like Magento should also be taken into consideration in terms of stress, anger, and frustration that developers experience when working with it. Who knows what health consequences of a person who's had the misfortune of working with Magento has experienced. 
If you're looking for something as simple as possible, especially if you are somewhat new to this, consider a service-based approach like [Shopify](https://www.shopify.ca/). This is my preferred recommendation for smaller/newer outfits now. If you want community aspects you could use something like Drupal (as others have suggested) because it can be built out for that purpose. I develop on Drupal, it is a flexible solution... but it may be overkill depending on your needs.
I was logged in before the change and I would get a 404 modal every time I went to a page, but everything still loaded fine. Just relogged and it was fine. Ive only been using it for 4 days but its been snappy the whole time.
Go for Magento,.You won't regret 
I inherited a big piece of code with a massive function sitting under: if ($username == "gary") { Gary hadn't worked there in 10+ years.
It's also a code nightmare: https://imgur.com/RMxWEgR
While most of your post is true, I'd like to point out a couple of things: &gt; Their "templating system" consists of HTML with &lt;?php echo ... ?&gt; all over the place. This can be subjective. Sure, you have to pay attention to ensure things are escaped properly, but personally I prefer raw PHP templates to template engines which require learning custom markup and are impossible to inspect statically. In a pure PHP template, I can at least get my IDE to tell me if I'm using an undefined variable, in a Twig/Smarty/etc. template I have to wait for the runtime to throw some kind of error (if I'm extra lucky, the engine will just swallow it and replace it with a null). &gt; Often folders named "Controller" and "controllers" cohabit the same feature. Which one do I use? Who knows! :D It's a mess, but there's a certain pattern to it: `controllers` is where the actual invokable controller classes live, they have a custom naming pattern and the autoloader doesn't handle them. `Controller` is part of the regular classname&lt;-&gt;autoloading system, and is generally meant for controller base classes that you want to reuse between actual controllers. E.g.: see the `Mage_Checkout` module: * The `Controller` folder has an `Action.php` file which contains `abstract class Mage_Checkout_Controller_Action extends Mage_Core_Controller_Front_Action` - this is an abstract base shared by some of the checkout controllers. * The `controllers` folder has a `OnepageController.php` file which contains a `class Mage_Checkout_OnepageController extends Mage_Checkout_Controller_Action`, that's an actual controller that can be called upon to handle routes. --- Also, to add to your point: https://imgur.com/RMxWEgR
Not just for static analysis, but also for running under the [optional strict typing mode for function calls](http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration.strict) introduced in PHP7. It's not just hinting, it's actual type checking.
If anyone recommends using wordpress with some plugins, ignore them. Wordpress is not a solid enough foundation for a proper ecommerce site.
I was going to say "Well, that's a bit of hyperbole..." and then I read through the link. Holy crap...
What tool generated this?
It's possible that they may need to persist their entities through a remote API rather than the DB.
Depends on the size of your business and the amount of time you want to invest in the system. I find that Magento has a much bigger learning curve and takes more time at first, however it has much more powerful tools that might be useful if you are making enough sales.
Wow! So you "patch" core functionality with CDATA fields in XML files with actual PHP code in them? Did I understand that correctly? Insane.
Is rocket sled a pbp interpreter? Why does anyone need this?
But even CodeIgniter does this. Except, is isn't query string, but an argument passed to `index.php` such as `/index.php/fooController/barMethod`.
Can you be more specific, please? I use PHPStorm but have never seen anything approaching that UI.
Carbon does not handle microseconds nor milliseconds precision. This library is only to handle very precise timestamps (useful in messaging systems, for example).
You can work around it using the following regex: /^(?:(?:[3-5]|[789])\d{8})$/x 
Edit: Sorry for the formatting! I would probably inject a Setting object (with the same methods of your trait) into the constructor and then apply an interface to the class. interface SettingInterface setSettings getSettings end class Setting implements SettingInterface protected ... setSettings getSettings end class MyClassThatHasSettings implements SettingInterface protected $settings; construct(SettingInterface $settings) setSettings (do stuff on this-&gt;settings object) getSettings (same as above) end $var = new MyClassThatHasSettings(new Setting) $var-&gt;setSettings The great thing here is that you've separated the logic for storing and getting settings into its own class. Secondly, you've enforced a contract between the setting class and any other class that depends on it. This is great because you can now swap out the underlying implementation of your Setting class without touching anything else (so long as your interface stays intact) Thirdly, you can confidently test all behaviours of the setting class. You can't do this with traits as they're not instantiable. If you find that you're repeating the implementation of those two methods in the classes that depend on Setting, you now have a great candidate for a trait: class MyClassThatHasSettings implements SettingsInterface use SettingTrait; construct(SettingInterface $settings) .... end In terms of organisation, it's totally up to you. Personally, I like to group classes by component or service: src/Acme/Components/Setting/Setting.php src/Acme/Components/Setting/SettingInterface.php src/Acme/Components/Setting/SettingTrait.php All of this stuff adheres to the SOLID principle. I'd highly recommend a read online. I believe there's a really good explanation on TutsPlus 
Would you think it is a good idea to create a NoteRepository class to abstract it away from the controller, something like? public function listAction(Request $request, NoteRepository $repository) { $notes = $repository-&gt;findByUser($this-&gt;getUser(), $this-&gt;buildOrderBy($request)); return $this-&gt;render('NotejamNoteBundle:Note:list.html.twig', [ 'notes' =&gt; $notes ]); } I don't know if the injection of NoteRepository would work this way. But you get the idea. And how better you think the code above is compared to: $orderBy = $this-&gt;buildOrderBy($request); $notes = $this-&gt;getUser()-&gt;getNotes($orderBy);
Git tools for this are alright. In practice on a large codebase even with good commit message you end up doing lots of pawing to do what? Reduce cognitive load. Why exactly is this bit of code being read over and over? Why isn't my cognitive load while refactoring the most important part? Cognitive load for code flow is far more difficult than the trivial act of visually parsing commented code. Unless you use a shitty hipster editor without syntax highlighting. They break down easily if you have many small changes and one very important one. I'm not advocating leaving tons of code detritus. There are plenty of instances where just leaving that code commented is far far more useful. You just have to rely on developers being smart, instead of just being dogmatic. I get it. It's a common dogma. I didn't say the concept was wrong, I said the dogma was wrong. It lacks significant nuance and focuses on one aspect of code maintenance while eschewing another. In addition, his focus on "cognitive load" in the article you linked is such a laughable concept. If a developer can't parse out comments then they may need to eat and sleep better to ensure they have a baseline of cognitive function appropriate for their job. In the article you quoted, this is all dogma. *Never* do this. Then he states a few caveats that he glosses over. He completely glosses over a very common activity in code bases that are old and/or regularly refactored: &gt; Q: git history isn’t very discoverable… How do I find the commit that removed the code I want back? A: A very valid question. Removing commented code not only makes it harder to find later, but it also makes it so people in the future don’t know it existed before. For finding the code, there are tools and git commands to help you look at the history of a file. I’ve had to do this before, going back months (even years) in a file was actually quite trivial. As for knowing of its existence, if it’s that important, you could add a comment that explains briefly that something important existed there before and people can find it in the git history. I believe this is an extremely rare case and can’t think of personally ever needing to do this. I'm not advocating for leaving code commented out all over the place just because you changed something small. This recommendation of a quick comment is possibly good, but ultimately it's a poor treasure map where the old code almost certainly would have sufficed. I am saying that the type of refactoring mentioned above is far more common in many code bases than the developer in your article thinks it is. It's also, far more common in older codebases that have been functioning for a while as opposed to very new codebases or libraries that should be maintained a bit differently and where pride drives this dogma ever further. It also completely misses modern development practices that often involve multiple code push and multiple release refactoring. What I am advocating is a more nuanced two phase approach that has worked well with my teams for years. If you are doing heavy refactoring that may live for multiple code pushes then just comment out the old code if you sincerely think that code will help in later debugging or it is a very complex change where seeing the old logic in a later refactor step may help. We then recommend that simple code just be removed. We then let developers just be smart, instead of just following dogma.
Please no, that is horrible... [try this instead](https://github.com/PatrickLouys/no-framework-tutorial/blob/master/README.md)
Here you go: function get_real_type($var) { return is_object($var) ? get_class($var) : gettype($var); } Do we really need to add another function to ext/standard for this?
Codeigniter is a bad example, it uses very outdated practices.
XML parsing has a lot of overhead, with JSON you can simply use two functions and get the data representation to an object/array. Try parsing XML in python or javascript or ruby or any other language, its usually unnecessary, and any solution that requires XML in my opinion, is outdated, or have edge requirements.
As hzmester mentions in the comments, this is a bug in PCRE. PHP already ships the newest libpcre1 version 8.37. As such this will only be fixed once we support building against libpcre2, which is pretty certainly not in scope for PHP 7.0. I would recommend you to modify your regex in such a way as to avoid this PCRE bug.
It's not ready for production use yet. I'd also expect there to be a bit of time before other common tools, libraries, and frameworks are fully compatible. I'm going to play with PHP7, maybe work on some of my own stuff in a contained environment, but otherwise will be sticking with PHP 5.6 for the time being. I couldn't recommend using PHP7 right now, not before it's stable release. Not for day-to-day work. Especially so, given current production projects should all be using PHP &lt; 7 anyway.
Well, *obviously* anybody can write that simple function themselves. But where do you put it? In what namespace/folder? Du you create a Util class? Then you'd have to do that for every single project. Okay, let's put it in a composer package. A composer package for a single function? etc. etc. etc. I just think it would be nice to have it built in to PHP since [it's so ubiquitous](https://github.com/search?p=2&amp;q=language%3Aphp+is_object+get_class+gettype&amp;ref=searchresults&amp;type=Code&amp;utf8=%E2%9C%93).
Just a heads up the beta 1 xdebug with rc6 of php 7 would hang a couple times a day. Not sure if it was xdebug or php 7 causing the hang though. The dev for xdebug recommends trying the latest xdebug from github rather than whats on pecl. I believe opcache has been compatible with php 7 for quite some time. I've been running my dev container on php 7 full time since php 7 was beta so its been pretty reliable.
You can create a simple functions.php or global.php in your project root then add the following to your composer.json: { "require": { //... }, "autoload": { "files": [ "globals.php" ] }, } &gt; Then you'd have to do that for every single project. Okay, let's put it in a composer package. A composer package for a single function? etc. etc. etc. I just think it would be nice to have it built in to PHP since it's so ubiquitous[1] . He was just helping, as this isn't really the place to complain. Put in a RFC and get this in the next version of PHP if you believe it should be built in.
Yeah, I'm not saying don't use it at all, just for day-to-day work (I suppose in hindsight, depending on where you work - if you work for somewhere that maintains an open source PHP project then day-to-day work may well be using PHP7). I'm just coming from the angle that, if you're working for somewhere where all of your production sites are PHP 5.x, you should be using PHP 5.x as your day-today version for development. Depending on how you work, that shouldn't hinder your ability to work with PHP7 as and when required. Otherwise you're more susceptible to introduce bugs that you've not noticed locally.
I want less developing that mostly several clicks can solve my business logic. That's what I want. I checked out the drupal commerce and found that the demos were not too fancy but it definitely matches my demands. 
I think it would make way more sense to make a subclass of `InvalidArgumentException` called `InvalidArgumentTypeException` and put that logic in there. You could save even more typing that way. throw new InvalidArgumentTypeException('arg1', 'string', $arg1);
&gt; Wow do you really think this is good code ? a global auth() ? really ? and where is the data coming from ? magic ? It's just as easy to provide the guard class via dependency injection, I just omitted that particular usage for simplicity's sake: public function __construct(\Illuminate\Contracts\Auth\Guard $auth) { $this-&gt;auth = $auth; } And in the index method: $notes = $this-&gt;auth-&gt;user()-&gt;notes()-&gt;orderBy( $this-&gt;buildOrderBy($request) )-&gt;get(); I'm not a fan of the global functions personally, but I think they're fine for prototyping, which I thought was the point of the demonstration.
Date | Release ---- | ------- Jun 11 2015 | Alpha 1 Jun 25 2015 | Alpha 2 Jul 09 2015 | Beta 1 Jul 23 2015 | Beta 2 Aug 06 2015 | Beta 3 Aug 20 2015 | RC 1 Sep 03 2015 | RC 2 Sep 17 2015 | RC 3 Oct 01 2015 | RC 4 Oct 15 2015 | RC 5 Oct 29 2015 | RC 6 **Nov 12 2015** | **RC 7** Nov 26 2015 | Final
can't say I would recommend anyone use this ... Was a cool flashback though.
[Grum!](https://www.youtube.com/watch?v=ZDGud3o0Nrc)
Is there any reason why a tool such as CodeSniffer wouldn't be better for this? I'm using that at the moment and one of the tests (sniffs) I have in the ruleset.xml is to check for function calls that shouldn't be in production code. If you still want to use your own custom tool, it might also be worth looking at `eval` (this should never be used for anything ever!), all the deprecated `mysql_*` functions, `stripslashes`, `ereg` (and its ilk), and `phpinfo`
That's a brilliant idea!
wow, that's just... wow. Thanks for linking, wrong attitude for security.
Where can i see what this does for example? Like what does it look for? What is bad that can be detected by this?
So what you're saying is now would be a bad time to audit all of the SAPIs and find/disclose remotely exploitable holes? :P
&gt; XML parsing has a lot of overhead, with JSON you can simply use two functions and get the data representation to an object/array. Isn't the whole point of this thread that recursively iterating through trees of objects/arrays is kind of a pain? Sure it's easy to load in to objects/arrays, but actually getting the data OP wants is that hard part and that's super easy with XML and XPath. I agree that JSON is great for populating objects, but XML and XPath makes things super easy if you need to do more complex transforms. 
Etsy is holding a talk w/ Rasmus on PHP 7 deployment practices next week. Heads up.
Contrary opinion here: I've been using it in my laptop since RC1, and no real issues to speak of. But most of what I've been working on recently is just straight PHP that has no reliance on extensions (though the ones I've used have worked fine too)
I think sometimes people get the impression that since a "big company" is behind something, it automatically makes it easy.
I don't think it's settled yet, but the impression I have is that the RMs are leaning towards the 26th right now. (The other option is delaying a week to avoid American Thanksgiving.)
Unless you run your own servers most likely any webhost you are using is going to be using 5.5 or 5.6 for the next 1 - 2 years minimum. 4 for was out for around 8 years before one of my hosts finally dropped it.
Thank you for the answer, I'm installing it right now!
Man, Magento is the best PHP codebase I've ever worked with, possibly with the exception of Symfony 2, which I'm not that experienced with (just played a little). I've learned so much from this clusterfuck of a platform. Lots of "how not to"-s, but many "how to"s as well. Lost my haird, my dog and my sanity, but I'll be damned if I'll go back to a less complex, "better-SEO" (what?) framework. It's all you'd want from an app: * corporate BS? check * sick of micro-, nano-, pico- framework? you've come to the right place. * awesome and practical design patterns in the wild? check * "what is this i don't even" classes? check * not knowing where the hell that string is translated from? check * complex database which just by studying it takes you to the next level? check * TOO MUCH EAV! check * non-existing patching system, having to do it yourself? check * professional people? check * stoopid people? check * own stackexchange forum? you betcha. * the incredible opportunity to _try_ and scale a complex application to 1000 requests per nano-second? check * XML? CHECK. Just by listing Magento's wtfs entitles you to an instant hire. So much head banging happens in mage dev shop you'd think they're watching a slipknot concert. So much sighing you'd think we're asthmatic. So much time wasted with our IDEs reindexing for the nth time those tens of thousands of files you'd think we're compiling shit. All this stuff amounts to an incredible experience for a PHP programmer. Until you get bored. Then Magento 2 appears. Buggier than ever! And the head banging continues, tuned to our inner most suicidal thoughts, to escape... and do some Wordpress.
&gt; You may be able to shave off an extra 0.01 second off each page load Uh… when the total page load time is 40ms, 0.01 seconds is huge.
Well generics help immensely when it comes to reduce code duplication. A good example of its usage is a collection library where all classes have similar methods for traversal, filtering and transformation. Without generics, you would need a class for every type you want to support (e.g.: MapOfString, MapOfIntegers, ListOfBoolean) whereas with generics, you could you to define one class Map&lt;T&gt;, where T can be any type (String, Int, Boolean). Note that it's possible to do what I described above using an Interface, but it's more limited and generally require more boilerplate code. Generics guarantee type safety and they improve the readability of code. 
Would make for a great addition to the blessing before dinner.
I would just very much like a function that prints minimal, yet human readable information about any datatype, e.g. for exceptions. Something along these lines: sprintf("(%s) %s", gettype($var), (is_object($var) ? get_class($var) : is_array($var) ? print_r($var, true) : is_bool($var) ? ($var ? "true" : "false") : @strval($var))) 
Yep the instant those things pop up that's the last time i ever visit that site. 
What an idiot.
I like it.
Why do you need to access single settings from outside of these (possibly many as you are writing a trait) classes. This seems to violate two principles that classes are made for: Responsibility - perhaps the class isn't responsible for these settings? If not, then don't give the setting to the class. Encapsulation - the class does not encapsulate settings but must provide specific settings to other code interacting with the class. If there is a edge case here, you could rather get the settings as array from the object and explore the structure yourself. I just kinda don't think i get your goal yet. To me your code is perfectly fine but nothing i would include into many classes via a trait. Instead i can only think of a specific object that would need this, like a nice session wrapper or a template engine (i actually once built one with a similar loop). Here is a pattern i use often, it's really simple to implement directly but i made it a trait to match your example. * + work with the data in plain php (no ':' syntax sugar) * + set multiple options at runtime (after __construct()) * + data in _options is always complete for the class internally (as you provide defaults), BUT * - don't expect the data from getOptions() to be complete when using it externally where you can't see what was injected or defaulted by the implementation * - it's quite a bit more verbose to set a deeply nested option, but you rarely should need those^[1] ^[1] After all, the options that the class itself needs should be at a flat level, if i'd need to group i'd use under_scores. Nested arrays however would be passed to another object that the class uses. But we drift too much in the dependency injection stuff here. trait OptionzTrait { protected $_options = array(); public function setOptions(array $options) { $this-&gt;_options = array_replace_recursive( $this-&gt;_options, $options ); } public function getOptions() { return $this-&gt;_options; } } class Optionz { use OptionzTrait; protected $_inception; public function __construct($options) { $this-&gt;_options = array( 'fact' =&gt; null, 'inception' =&gt; array( 'options' =&gt; array() ) ); $this-&gt;setOptions($options); } public function stateFact() { echo $this-&gt;_options['fact'] . "\n"; } public function getInception() { if ($this-&gt;_inception === null) { $this-&gt;_inception = new static($this-&gt;_options['inception']['options']); } return $this-&gt;_inception; } public function setInception(Optionz $inception = null) { $this-&gt;_inception = $inception; } } $optionz = new Optionz(array('inception' =&gt; array('options' =&gt; array('fact' =&gt; 'it is known')))); $optionz-&gt;getInception()-&gt;stateFact(); // caveat: nested properties are only propagated initially $optionz-&gt;getInception()-&gt;setOptions(array('fact' =&gt; 'this works')); $optionz-&gt;getInception()-&gt;stateFact(); #$optionz-&gt;setInception(null); // try this $optionz-&gt;setOptions(array('inception' =&gt; array('options' =&gt; array('fact' =&gt; 'this doesnt')))); $optionz-&gt;getInception()-&gt;stateFact();
Upgrading?
PHP 7 isn't a complete replacement for PHP 5.6, it only deprecates a few things, and adds a few new things, but the majority of the language the same. Thus 5.6 will still cover 95% of what will be in PHP 7. So yes, you will most definitely be able to transfer almost all of your knowledge of PHP 5.6 to PHP 7.
You'll probably enjoy Drupal in that case. Sounds like you can manage most of that yourself then. I recommend Pantheon for hosting... it will take care of your backups and having proper dev/test/live environments. When you get to shopping cart stuff, keep your "Rules" configured as simple as possible. If you can understand and master Rules you're good to go.
So Shopify is based in Canada... making the first point of that clearly moot. I don't know enough about the latter half, but if you add complexity all things get expensive. Whether it is your time invested or money you pay to a provider.
11\. Do not make a box pop up asking for my email address while I am on your web site.
I used to use OsCommerce many years ago, that turned into Magento. I've used it a little, but my main job is as a Drupal developer so I've also made some Drupal Ubercart sites and more recently got a little bit into Drupal Commerce. After using Shopify a little bit, and especially after seeing the Point Of Sale software integration Shopify offer absolutely nothing comes close. Shopify have completely revolutionised ecommerce and it's not expensive, it's ridiculously easy to use, incredibly powerful, looks great, gives loads of insight into what people are buying, can be used in a shop as the main till, has heaps of plug ins, they basically won at building the best ecom software and that's that. 
Most of the stuff in PHP5.6 will still work the same in PHP7. So no, it's not bad that you bought the book. 
Haphpy thanksgiving. $this-&gt;gobble
You've got Code academy, Laracasts, NetTuts, TutsPlus and loads of other places. Sounds like a cool company you work for!
I wonder why people want generics so badly. I thought traits are supposed to solve the problems better?
So programming languages are split into several families, and most of the commonly used ones these days (including PHP) are in the procedural family. Within this family, all the basic principles of how variables, loops, if statements, lists, objects, threads etc work are basically the same. Between PHP 5.6 and 7 it'll really be fine. Also, if you decide that you don't like PHP and you want to try something else, Python for example, you'll find all the same basic principles and that will make learning your second language much faster. Basically, don't get to hung up on what to learn first, just learn something! 
Hi, starting a new project. I want - PHP 7 - HTTP 2.0 What Linux distro would you recommend running on the server?
Having had a lot of experience with Discourse lately, this project seems interesting and something I'm hoping to use in the future. For now, however, it's a bit too much in the development for any real use cases. Nevertheless, I'll be following its releases with great interest.
TL;DR: * Use trailing commas in array, because `git blame` * Don't use spaces for inline alignment (docblocks and arrays), because `git blame` * Only use docblocks to add new information, because redundancy * Don't use `Interface` class suffix, because no one cares * Don't use `Exception` class suffix, because it's redundant I agree with some, and disagree with some, but I'm a bit irked about the author's claim of 'rational' approach as if these were the only sensible conclusions.
I've seen you post a few security issues before, I was wondering if you might have written an article about how you go about finding them. Do you just read the code and try random things out? If you have written something before I'd like to read it. 
Thought the exact same thing and then read both the links provided... shocking stuff.
I'm going with: * yes * yes * no * no * maybe
The usage described by @nikic (I wasn't aware of the TypeUtil project) is exactly how we use the tool right now: we convert the code base to PHP7 then run tests in the CI. If tests fail, the PHPDoc is wrong and must be corrected. Using a static analyser leveraging PHPDoc to do type inference like Scrutinizr (before running the converter) can also help to detect a lot of potential bugs (it's how we use the tool right now) but IMO there is no other way than testing to be sure that everything is fine.
Thanks, I'll add the link to the article.
It's a CLI app that opens up into a window (making it on Linux). Would Qt be a good fit for this??
 * Don't use Interface class suffix, because no one cares * Don't use Exception class suffix, because it's redundant Yes exactly! I've been [ranting about this for ages](http://phpixie.com/blog/naming-interfaces-in-php.html). This should also include Traits imho too
After thinking a bit about it I'm leaning towards another no on that last one. 
But honestly, for the sake of argument: * Trailing commas... it's fuuuuugly but the git blame argument makes sense. * Same for the aligning, even so I find it a bit more readable, but I can live without it. * Docblocks: simply no - a docbloc should show all the information, even if it might be redundant. Also: phpstorm creates docblocks for me automatically, I'm not gonna go and edit each one each time by hand. * Interface and exception suffixes: no. If I do "find class" I want to see with a single glance if it is an actual class or an interface or an exception or a trait or an abstract class or whatever else the hell it might be. The naming is for my benefit, so that I have to think less. I'm a lazy programmer and the less I actually have to think while programming, the better.
Given that they still appear to be finding seg-faults, I would highly doubt that we are getting 7 in November.
Array&lt;User&gt;() plz.
just imagine the things you could do when we get new class() { }; xD A whole new vector for bad things lol.
[removed]
I agree with all points expect the last one, class names should be nouns, if you remove the Exception suffix they aren't any more.
I linked to your post in the article ;)
Cool!
But I do. I do care.
Linspire? *kicks self, there are no stupid questions, just stupid answers* You should use a distro you are familiar with using. Getting PHP7 and HTTP2.0 will likely not be "out of the box" no matter what distro you choose for a next few months. Ubuntu may be your best bet as it is widely used and you'll find howtos on setting up both of those packages.
Thank you for the interesting and thorough reply. &gt; - Trailing commas […] I consider this more a problem with non-contextual diff utilities Agreed. If all diff related tool started handling that, I'd care less. Something I didn't mention is the ability to `Ctrl+D` to duplicate the last line. Minor things really, and I don't care that very much about it. &gt; - Value alignment […] Diffs can ignore whitespace Good point. But `git blame` won't IIRC. It doesn't take the pain away of reformatting the code block: even with an IDE I have to select the block to reformat it every time I add a new item (because I don't want to reformat the whole file). +1 on the consistency argument. &gt; - Minimal PHPDoc […] Your problem here is not redundancy, but bad parameter descriptions. If you're giving descriptions … Remember I used Symfony's code as an example. It's not just about me writing bad documentation, even the best of projects have room for improvements on this. Yes "dumb" phpdoc is the problem, but my point is that maybe half of the time you don't need extra documentation *for every method and parameters*. Look at [`EventDispatcherInterface`](https://github.com/symfony/symfony/blob/2.8/src/Symfony/Component/EventDispatcher/EventDispatcherInterface.php) for example: half of the documentation is useless. It's not badly written, it's just useless. In half of them there's just no need for any extra information. It's just noise at that point. Of course, when extra information is needed, then by all mean write it :) &gt; - The "Interface" suffix […] what happens when you run into a situation when you need to implement an interface on an abstract class. The abstract class exists only to share code, just like a trait. So I don't care really how it will be named, since it won't be used directly (it's an implementation detail). The interface is more important because that's what's consumed, that's the public API (at the code level). I don't see a reason to care about `AbstractFoo`.
&gt; For example if UserRepository is an interface, then you are forced to find a more specific name for your implementation. And you come up with DoctrineUserRepository and you realize that there could as well be EloquentUserRepository, PdoUserRepository or InMemoryUserRepository. Interfaces makes much more sense when they are the default. Implementations are secondary. Not a good example. The app should work with `UserRepository` not `PdoUserRepository`. You might have an `SearchableRepository` interface (which implements a method `search`) and you might not need the `Interface` suffix. But I think that the `Interface` suffix makes the code more readable. function searchRepository(SearchableRepositoryInterface $repository, $word) { return $repository-&gt;search($word); } Is more readable with the suffix.
I'd maybe add PHPStorm (or IntellijIDEA) to the IDE part, feels weird to have Aptana brought under the spotlight when it's been an eternity since I've seen anybody use it
&gt; Not a good example. The app should work with UserRepository not PdoUserRepository You are missing the point of this part: it was about better naming of implementations. It's obvious that you should type-hint the interface. However that fact doesn't prevent to find better names for implementations. As for the rest you think that it "is more readable" maybe just because you are used to it. This is a subjective argument. I suggest you to try to put it aside and give it a try. Maybe you'll find that it's not that "more readable".
"user not found exception" and "number out of bounds exception" are nouns?
Disagree with the suffixes. In fact, I mostly disagree with almost anything that's *implied* rather than *explicit*. Time and time again, implied names/code/behavior makes it harder for me to reason about the code and/or file structure. Explicit names, as "redundant" as they may be, communicate explicit intent in different ways in different contexts, reducing cognitive load. For the same reason that you shouldn't condense complex code into a single line just because you *can*, you shouldn't try to "optimize" your file and class names for efficiency at the expense of explicitness and readability. Regarding interfaces specifically, most of the time you have a situation like this: `UserInterface` and `User` (which could be a plain old PHP object, or an ORM model, and you usually have just one implementation. I want to be able to ctrl+p or look for *THE* `User` object, not `EloquentUser` or `POPOUser` or something silly like that. The interface for the user is *secondary* to the meat and potatoes of your code, so it should not occupy the simpler default name.
I think pThreads look great. I am trying though to figure out a real use-case for when/how to use them. Since it is only available via the CLI, how would I utilize pThreads for fulfilling a HTTP request? Supposed the page I was rendering had to get data from different sources and display it on a dashboard. Or, can I use it to speed up the rendering of a page since I can create threads for different areas of the page. Just trying to wrap my head around how it can solve some "real-world" issues. And yes, I have looked at the examples dir in the github repo.
&gt; I understand, it also "would look" overloaded and noise. That's the subjective part of my argument right there I guess. The most important my argument in my opinion, is the readability benefits. Docblocks are not only much easier to read, they also provide more information than a method signature can. Having a consistent format also means that tools can be made simpler, and can work more consistently themselves. If you had a half-complete docblock with the rest of the information in a method signature, you'd get half-complete documentation, or more complex tools (and that'd include IDEs too of course). Realistically, we're talking about something that's designed to make it quick and easier to grasp what's going on in something, and only providing part of that would be counterintuitive, and may indeed only serve to add more cognitive overhead unnecessarily. After all, docblocks are there to make it easier to grasp what's going on, instead of you having to read the code to figure it out; this is something that can make life much easier for people new to projects for example. Also, consider when the code isn't available, for example in documentation generated from docblocks. Things like descriptions are very useful there. --- &gt; As I said in the article, exceptions are used in a very specific context (throw, catch). You don't need to hunt anything, it's right there that you are either throwing or catching an exception. I understand where you're coming from with this, hence my agreement with the -Interface suffix argument. However, the reasoning in that SE link is spot on: &gt; Class names should be nouns. What is an "OutOfMemory"? What is a "FileNotFound"? If you think of "Exception" as the noun, then the descriptor is the adjective specifying it. It's not just any Exception, it's a FileNotFoundException. You shouldn't need to catch an OutOfMemory any more than you'd go to the store to buy a "blue". But when you compare that to something like an interface, as I've stated above, your interface is not a "FooInterface", it's a "Foo". An exception is not an "OutOfMemory", that makes no sense at all, you're not "throwing an out of memory", that also makes no sense, you're "throwing an out of memory exception". Again, compare with the interface example "this method will only accept a vehicle", what doesn't make sense there is "this method will only accept a vehicle interface". It'll only accept an interface? What does that even mean? Now, this won't apply to all exception, but that also applies to the reasoning you specified in your article. Another thing is that the suffix helps avoid naming conflicts. To copy and paste [from SO](http://stackoverflow.com/a/2861304/1185534): &gt; A class named InvalidIndex might be completely valid (e.g. to invalidate database indexes or something like that) and not related to an exception. If you now had an exception for invalid array indices you'd have a naming problem. By suffixing exception classes with Exception, you avoid name conflicts like that. I just don't think you gain anything from losing the suffix over saving 9 characters, but by having the suffix you do gain things, like what I've mentioned above.
Stop writing useless descriptions, and starting writing useful ones then? :P I think the documentation generator argument is a very valid one, given if you didn't specify any description, you'd end up with inconsistent, incomplete documentation. Even if a description seems "useless", the added consistency can aid readability, and make it easier to find things (e.g. searching for things in documentation). The docblocks should contain all of the information necessary to describe what it is documenting.
That would be a different use case entirely. From what I think I'm understanding of what you're trying to do, I'd use asynchronous requests done on the _client side_, like get your data from an internal API and load your dashboard modules as you get your data. This is more for background jobs, queued jobs, scheduled tasks, etc. Those would be run in a CLI SAPI context. I don't know the specifics of why pthreads is discouraged in an HTTP context ([as seen here](https://github.com/krakjoe/pthreads#sapi-support)), I'm just assuming some kind of limitations in PHP or something, as krakjoe seems to mention a lot that pthreads is kind of "bending" PHP to make it support multi-threading.
[removed]
Thank you thank you thank you. 
&gt; It's not badly written, it's just useless. In half of them there's just no need for any extra information. It's just noise at that point. I would disagree. I think the documentation in the cases (I assume) you're referring to is deficient. It's a common problem, and affects most, if not all, projects. They tend to make the assumption that since the code is surrounded by other code and documentation that seems like adequate context to determine the purpose of a parameter, that a good description is not necessary. That's a misconception, though. Consumers of your code are usually not looking at surrounding code within the definition context; they're looking at your description on an IDE tooltip, a docs website, etc. Your descriptions should be self-contained. Stuff like `$listener The listener.` is just Developer laziness - nothing more. &gt; The interface is more important because that's what's consumed, that's the public API (at the code level). I don't see a reason to care about AbstractFoo. This is a compelling argument. However, with both PHP itself and the FIG using the same naming convention, I don't see much of a point in being different simply because one makes more sense to me. It's kind of tabs vs. spaces again. There are subjective reasons people prefer both, but at the end of the day, it only matters that you're consistent. How far you take that consistency is up to you (only within a project, across all your projects, or in line with other entities in the community).
I was just trying to make up some potentially common cases where running multiple threads might be useful. That is kind of what I am thinking too, but it seems to really limit the use-cases where pThreads can actually be used.
I did inherit a GTK PHP project a long time ago. Would not recommend. Talk about forcing a round peg in square hole. That is however, a very valid point. pThreads would allow you to "not block on the render thread" in a GTK app.
Well I agree with you, we do the same thing in a way through React. But this wouldn't be handled by pthreads anyway, see the comment thread above, it's for different kind of tasks.
Huh? By "some website" are you referring to 3v4l.org? That site lets you run your code against basically every version of PHP out there. I've used it a lot and never once find it to be wrong.
Anyone know of a package like symfony/http-foundation for PSR7? Specifically with a method like createFromGlobals(), and then I can work with the request/response objects like I would with http foundation. I'm aware of the bridge, I'm just curious if there is a decent 'native' package.
Thank you, that combined with your other comment were pretty good explanations. I'll keep that in mind, I've only started using that pattern occasionally for a month, I'll see how it turns out in the long term. Until now the benefit I've seen is that it forces me to think of real error reasons, but I get your point on the `throw something something exception`.
This extension used to be experimental, but now its not. I'm so afraid of things like word tearing. Could someone point to PHP's documentation regarding its memory model, so that a phtread user knows what is atomic and what not?
Pretty cool! Why is the &lt;title&gt; tag empty though?
This is really a fantastic introduction into threads. One of the projects I work alongside (but not really on) is full of legacy PHP command line scripts that read in gigabytes of CSVs, do some calculations, get some results from some DBs, and then create a new table. Currently, this process takes around two months, and large part of that is due to some of these scripts which take 8 hours to run failing at 3am at night. While it's not a magic bullet, it seems like threading may cut down on execution time for some of these. I know I'll have to investigate the exact computations though, because right now it's all very procedural and it might be difficult to break apart. Thoughts? Comments?
Unfortunately, it doesn't. Hope the PR gets merged soon.
A bit late, but want to mention that in some situations (Promises/A+ for example) exceptions are instantiated and passed around like normal values. Then thrown if necessary.
This isn't about using threading in PHP for the sake of it or for speed, it's about being able to reuse your domain logic in lieue of switching language and having to reimplement everything which would be a huge code smell. Sure if you're doing a completely one off task that isn't related at all to your codebase go ahead, but my point was if you need to parallelize a task you're currently doing in PHP, be aware that it is possible before recoding everything in Python or .
No netbeans or PHPStorm under IDE?
[removed]
Could you explain what you are getting at a little more? More importantly, could you explain why the results for PHP7 differ like they do? I'm very curious what's going on exactly.
First, I didn't downvote you. Second, While I acknowledge that platform differences could be an issue, they shouldn't be. Third, it looks to be identical to me, but I could be wrong. https://3v4l.org/1j45H
Your logo looks like a dick and balls.
So PSRs?
&gt; Guys stop downvoting just because you disagree. I didn't downvote because I disagree, I downvoted because just saying "Jesus christ don't use this technology" is known as thread shitting. 
&gt; So, the arguments predated PSRs and some found merit then they sought consensus. To act as if there was no rationality, or discussion/arguments, applied is inaccurate. Right my wording wasn't great. &gt; I just don't agree its a counterpoint to PSRs as you've sort of framed it. I didn't mean it that way. Maybe the introduction accidentally hinted that, but I'm a huge fan of PSR-1 and 2, I use them everyday and I'm not arguing that they should be dropped. I specifically chose examples that are not strictly covered by PSRs because that's where it's becoming interesting (I do see the value of "blindly" following PSRs: consistency &amp; etc.).
&gt; Disagree with the suffixes. In fact, I mostly disagree with almost anything that's implied rather than explicit. But is that really what's going on? Those two qualities (is-interface, inherits-from-an-exception) actually **are** explicit, as other hardcoded parts of the type-signature. This means you can reduce cognitive-load *even further* by transferring all that repetitive work over to the computer. Let your IDE do the work of helping you use the right-thing-in-the-right-place, and choosing highlights or icons. Removing the suffixes doesn't actually "lose information" about the codebase, and it also bypasses a failure-case where the the totally-non-binding suffix is lying. That said, I think /u/lepideble had a good point about how the -Exception suffix can be *grammatically* important, so that your exceptions are nouns. (And generally better-understood than -Error, -Problem, -Issue, etc.) &gt; Regarding interfaces specifically, most of the time you have a situation like this: `UserInterface` and `User` I think that's an "unhappy medium". In most of *those* situations, you don't actually need the split *yet*, so you can just have a concrete`User` because YAGNI. Later on you can safely extract the interface when you have a better idea what your needs are... Which also means you'll have a much better idea what to name your concrete class in order to communicate what it does compared to other existing/future concrete classes. Conversely, if you're "planning for the future" with an early interface/class split, then you should also "plan for the future" just a *little* bit more, by giving the good, preferred-name to the interface (people should prefer the interface) and by giving a more-descriptive name to the concrete-class (because you've already implicitly decided that someday there'll be other kinds.) 
Out of curiosity, how do you feel about PHP MVC Frameworks then? They don't combine HTML and PHP in the way you're saying.
And instead of something like `AbstractParser`, you now have `Parser\Implementation`. All you did was shift the affix to a namespace segment and create more organizational busy work for yourself. You also now have an interface named the same as a namespace segment at the same level (`Foo\Parser`), which is needlessly confusing at best.
It's super cool to see other people getting it right, and trying to help other people ... kudos ... It's a bit scary to see people respond with "but what about threading my templates?" ... this is a nonsense use case. There are a few different models of threading, in brief: - 1:1 - where each user thread is an actual kernel thread; This model is able to take full advantage of a multi-core system. - N:1 - where all user threads are executed by a single kernel thread; This model is not able to take advantage of a multi-core system. - M:N - where M user threads can be executed by N kernel threads, a hybrid of the two models above. It's hugely complex to implement, and does take full advantage of multi-core systems, but comes with many pitfalls, the first of which is the complexity of the implementation. Languages like Go (and modern JVM's) have a hybrid M:N model; There is in theory no limit to the number of threads you can create, the scheduler will map as many threads as you create onto as many kernel threads as it can create. There is still a limit on the number of threads you can execute concurrently, imposed by hardware. Early implementations of the JVM used a N:1 threading model, you will hear the term "Green Threads" used to describe this model, some other interpreted languages also use green threads. This is not really threading at all, it just looks like it. pthreads uses a 1:1 model. I'm sure by now, you have spotted the problem ... If your controller instructs the operating system to execute even a reasonable number of threads, let's say 8, and 100 clients come at once, you are asking your hardware to execute 800 kernel threads concurrently, with a *tiny* amount of traffic. The most recent versions of pthreads prohibit execution anywhere but CLI, because it's the only place it makes good sense.
&gt; Conclusion: do not align things with spaces. Shouldn't that be "do not align things at all"? Naming "spaces" specifically makes it sound like tabs are A-OK. Myself, I think the choice should be between: * Not using alignment at all * Using alignment with **soft tabs** First, tabs mean fewer possible alignments, so there are also fewer ways for "false alarms" to occur in your blame. Second, *soft-*tabs improve on that by making your alignment style "portable", further reducing the chances for churn.
I'm a student, and so far I've basically avoided frameworks - except to sorta make my own. I feel a lot of frameworks overcomplicate things to the point of not contributing anything genuinely useful, but then again that might be just for my own purposes (school projects, and a couple personal projects where I have my own database schema that I hand-wrote in SQL). I'm also a bit weird in that I am very strict with how my own HTML output gets formatted, and only my own framework has let me actually format the HTML as well as I like. I can't find any other PHP website (including websites for frameworks) in existence which formats output HTML perfectly.
PHP is not an [evidence based language](http://quorumlanguage.com/). This "logical" analysis is not how evidence is presented. The point of the whole post should be better defined because it seems like the solution proposed is "just talk it out". I can play the opinion game. * Sometimes * No : not appropriate for a standard. * No * Kinda : Exception/Interface/etc Suffix - what? Use an "I" or "E" prefix. eg Imyinterface/EuserNotFound If you want to indicate that an Interface or Exception are constructs that you want to identify, the discussion is circling about which one to use. Using an english noun seems wasteful.
&gt; it's about being able to reuse your domain logic If you need concurrency now you've chosen the wrong technology in the first place. Going now for phtreads can be considered a lack of self reflection. How would you proceed if a desktop GUI is needed? PHP-GTK, so that you can reuse your domain logic?
Actually the examples they give uses the "hacky" option 4 as you suspected. I think I'll try option 1 and see how it goes. If it gets really messy in the service provider then I'll revert to option 4.
&gt; Adding an external/third-party component for doing every tiny little thing I wanted to agree, but ... &gt; such as session handling or encryption ... these are things where you can do a lot of things wrong, it's absolutely right to use a library here.
Regarding template engines: It depends which features are important. Maybe you want to use the same templates on server and client side. Additionally, template engines can be secure by default for printing variables, but that has its negative side as well, because you might think that it's automatically escaped but then you use a variable without further escaping in your inline javascript and BOOM!
You just have a not invented here mindest and you are calling it contrarian. Libraries *are* PHP and the vast majority of commonly used ones have no performance impact but tons of productivity boost. PHP 7 performance is going to give a shot in the arm to frameworks that can feel a bit more bloated, but once you write a major consumer app of some scale (millions of users) you end up with near framework overhead anyway. If you have an internal app then tiny performance improvements are not game changers. No one cares about your app with 10 users being 20 millisecond faster. Not even the users. Under .2 seconds page creation times are about server resources at scale not an individual user. Total page load time is a user metric and is not effected by anything you've mentioned because even the largest framework with proper caching and servers only contributes .067 of the total page load. So, moral of the story. Write the app with productivity enablers and then focus on the post page generation page load improvements. If your app is super popular then you cache, get web frond ends that cost maybe tens of dollars and optimize specific areas you have identified. The current "trend" is overall a good one. I think Composer has introduced some bad habits like not having any version fixation in libraries, but these are good trends for the most part.
Having to use htmlspecialchars on every variable output is a complete PITA. Twig makes things so much easier, and the syntax is cleaner. Namespaces avoid class names clashing - having to prefix your class names is also a PITA. They also help with auto loading. Using third party components means you don't have to reinvent the wheel constantly. I agree that some are unnecessary but most are very useful.
Agreed, I never liked the idea of creating the empty interface just so that I can automatically resolve the correct repository implementation. In that respect, giving the control to the container (option 1) seems a much neater option. If I went with option 1, how would I get around the scenario I mentioned in the OP where I need both a `CarRepository` and a `MachineRepository` in the same class, i.e. `public function __construct (RepositoryInterface $carRepository, RepositoryInterface $MachineRepository)`? I don't think there's a way in Laravel to specify that the first argument should be `$factory-&gt;create(Car::class)` but the second argument should be `$factory-&gt;create(Car::class)`. Happy to be corrected if I'm wrong though. If it isn't possible, is that a limitation of Laravel's DI container or would this also not be possible in other frameworks/container packages as well?
&gt; (and forgetting that php itself is an excellent template engine) PHP is a good templating engine at best. I detest diving into any view file with &lt;? ?&gt; everywhere. 
When they first announced it, they (PyroCMS) lost me (and I imagine others) when they chose an outrageous price for the pro version and no upgrade price for those who had (then) recently purchased the previous pro version. They haven't really helped themselves by taking forever to get this new version ready for production. With them removing all mention of a "pro" version from the website and shutting down their forum, it's also questionable whether or not it's just going to be free, or not. Right now, they seem to be very closed with their plan, so it's hard to feel secure using it. Personally, I've gone on to focus on learning as much about Laravel as possible and develop my own personal CMS/Base application to use for projects.
I'm curious what languages you find to be so superior to PHP? 
Any decent framework gives you 100% control over the output HTML. I held the same opinion when I was new to the field; now I don't care in the slightest how the HTML is formatted. Hell, our front-end guys don't even look at raw JS or CSS anymore. I also disliked frameworks initially, but have found real value in dedicating myself to learning a few. 
Is that the correct/desired behavior though? I'm guessing that maybe ini settings done in the actual ini file will take effect at least? But in any case, that's a *HUGE* change from &lt; PHP7. And I didn't see that called out and explained on the ini settings page.
Also, I don't know if *absolutely everybody* would benefit from Twig, but I would wager that everybody could benefit from parting background logic and foreground presentation. Twig just makes it easier to do so.
&gt; actually are explicit Not when I'm trying to grok a codebase for the first time, and looking through the file structure to figure what is where. &gt; Removing the suffixes doesn't actually "lose information" about the codebase Working with legacy codebase after legacy codebase, I must vehemently disagree with you there.
replaced with what? {{{ something }}} everywhere? 
I think it was rational. Isn't removing redundant code a rational thing to do? How about making git blame (and also just viewing diffs) look better by making the number of line changes proper? I think these are rational arguments? 
So, so many "old style" PHP websites are riddled with security holes. It much easier to build strong code when you have full control over input and output data. If you notice something wrong you often need to change it in only one place. The reason people use libraries instead of rolling their own session handler is usually that the library provides the same features they would implement themselves otherwise. I did not like the old school PHP, and I say that as someone who has been using PHP for 15 years. Almost everything that has happened to the PHP ecosystem in the last few years have made my work much easier. I can now focus on the bigger picture because I know I can trust my interfaces. I do agree that namespaces seem to be used a little bit too much but the feature itself is much needed to make truly modularized libraries.
Its not like aliasing htmlspecialchars to _ or using ob_start; include(file) is that hard or any more verbose than what you'd have to do to invoke the twig equivalents anyway
Well, yeah. * Universal PHP: `&lt;?php echo htmlspecialchars($user['name']); ?&gt;` * Short-tags PHP: `&lt;?= htmlspecialchars($user['name']) ?&gt;` * Twig: `{{user.name}}` Even if in a specific case you don’t want the escaping, the short-tags version is quite a bit more verbose than the Twig version. (Or pretty much any other templating language, really) Also, pure PHP templating is pretty bad for creating custom blocks.
&gt; I've not been a really huge fan of autoloading - it's something that's triggered when a class can't be found (glorified error handling at execution time, really) Wow.
Writing code covered by automated tests is a core component of successful agile methodologies. Without unit tests it's nearly impossible to refactor large, complex applications. It's a poor developer who doesn't budget time up front for the writing of unit tests.
Twig is using **auto**-escaping. So, it is not like manual invoking at all.
Autoloading is not triggered by errors? http://php.net/autoload "may define an __autoload() function which is automatically called in case you are trying to use a class/interface which hasn't been defined yet" What's incorrect about my statement? EDIT: many moon ago "class not defined" (or whatever the specific message was) was an error state. php5 introduced this __autoload which would be called first to give you the ability to load up what you needed. if it wasn't there, it fell through to an error state. Whether it's truly internally still considered to be an 'error' (in the sense that 'trigger_error' may work today) - I'm not 100% sure on wrt the inner workings of the PHP engine. It's definitely a fallback mechanism, and is dealt with similarly to set_error_handler() (you define code you want to run in unexpected situations). The fact that it's not "unexpected" these days is primarily a design approach, but to the PHP engine, it's still unexpected when you try to reference a class that it doesn't yet know about. 
That is where the idea came from. No other php framework has done it this way so I thought I will try and see where it goes.
Even if you don't write tests, having a function that uses ~~super~~global a severely limits how it can be reused or interacted with. It is in a sense *no longer a function* since supplying the same "visible" inputs may not result in the same output.
If you can make money writing non object orientated code then all power to you, unfortunately just working on Wordpress blogs bores the shit out of me and i dont wanna spend the rest of my life doing that.
Like anything else its a bit of a continuum. While many developers would agree on best practices in alot of areas there is still lots of room for disagreement on how the same thing can be accomplished.
This is not a problem itself but rather a symptom of a real problem with your query. In your case `mysql_query()` returned not a result but `FALSE`, which means that query execution failed at mysql side. So, you have to get the error message from mysql to make yourself aware of what went wrong. With `mysql_query()` you are bound to write every call like this $res = mysql_query($query) or trigger_error(mysql_error(). " in ".$query); this way you will be always notified of all mysql errors, as they will be transferred into PHP errors and shown to you usual way. However, mysql extension is about to be removed from PHP, and you shouldn't use its functions. Instead you have to use PDO. I wrote a good article which will help you to learn, [The only proper guide on PDO](http://phpdelusions.net/pdo). Luckily, with PDO you won't have to check every query result, as PDO is able to throw query errors by itself. 
From php.net: $result = mysql_query("SELECT * FROM table1", $link); $num_rows = mysql_num_rows($result); Your query is returning FALSE from an error, then mysql_num_rows() is throwing a second error. Take a look at this: http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers
I evaluated it for work and decided to pass, actually I'm pretty disappointed with the entire spectrum of PHP-based CMS systems available now. They're only slightly less horrific than the .Net CMS systems that I sometimes have to work with. The only CMS I have in production right now that gives me zero problems is ExpressionEngine which is based on the old CodeIgniter platform. It's only major downside is that it (and all the best plugins) aren't free so getting a site up and running can easily cost you close to $500. A big reason why the Pixel &amp; Tonic guys went from writing plugins to building CraftCMS and essentially copying the pricing model. But in terms of templating and creating content channels its dead simple. I'm seriously tempted to see if my company would let me build an EE-style CMS based on Symfony just so I could have it's flexibility and ease of use on a more modern platform.
For better or worse, some of PHP's native functions are problematic and require boilerplate code to use them correctly. Encapsulating that is just common sense. json_decode is a great example -- it returns null without warning if there's an issue with the JSON. Maybe in the future they'll change this to throw an error, but for now, every time you use json_decode, you have to follow it with error handling. $array = json_decode($json, true); if (json_last_error() !== JSON_ERROR_NONE) { throw new \ErrorException(json_last_error_msg(), json_last_error()); }
Where's that from? I'm interested to know because the manual doesn't seem to mention it on either mysql or mysqli pages.
Some projects are not large complex applications.
I agree with your point that prepared statements are better but if you have an application written with mysql_* its simple and more secure to rename to mysqli_*. New projects should really look to pdo or a third party dbal though.
I have to disagree about the trailing commas. What sort of developer finds an array in PHP where the last item has a comma on, and thinks: "hey did Mr X forget to add an item or two?" All developers I have ever met would never think that. They would assume the list is complete and continue modifying whatever it is they were doing. 
You state your argument about developer laziness with `$listener The Listener` but you provide no better alternative. You can't seriously deny that some code is so self documenting that ANY documentation written for it is noise. Take this method call for example: public function getAllUsersByAjax() Should the documentation be "Get all users via AJAX"? How would you improve that? Or how about a method paramater such as: `($userId)`... Would you document it as "The user ID" because that is pretty self explanatory. Or would you describe it as "The database row ID for a user"? It is noise. 
&gt; I'm saying that frameworks in general introduce out of the box an increase below the diminishing return point and have optimizations available to ensure those thresholds above can be met Doctrine being a notable exception for me. The benchmarks for are always miserable, comparative to ad-hoc. Even over 100 lookups. Generally I verify by writing tests using doctrine for the test cases, then writing the exact same cases without and comparing the test runtimes.
&gt; &lt;?php $variableForOutPut = htmlspecialchars($var, ENT_QUOTES, 'UTF-8'); ?&gt; Isn't this done in the controller? 
It is more secure because mysql will be removed soon and you'll tie yourself to an old version of php. My main point of my original post was that OP shouldn't be using mysql_*. I think we're agreed on that. I jumped straight from mysql_* to pdo so only have second hand knowledge of the detail differences between the two. The manual does suggest it's pretty much a drop in replacement.
Doesn't *auto*load means that services are loaded automatically exactly at the time they are called, and never loaded then no call to them happened?
While you're completely welcome to your own opinions on how PHP should be written, I'd be careful being stubborn against change. By thinking this way and not moving with the time, you're only damaging your career opportunities. There's younger, keen developers out there happy to spend their time keeping with the times and it's only a matter of time before they put you out of a job.
Even if you do it in the controller you still do it manually, so it is still possible to forget doing it. My point is that a template engine handles all escaping for you so you don't have to worry about it.
Well, I see. You are recommending a tool you have never used yourself. This habit is ruined Stack Overflow. Wonder if it would happen to Reddit too. Please, refrain from recommending things you have never used yourself. As of the version, as I said above there is no problem with using mysql ext with modern PHP versions. PHP is Open Source, which means anyone is free to use any extension, however removed from the core distribution.
"Could be used directly" and "intended for direct use" are not the same. 
&gt; do you authenticate your encryption ? Could you elaborate what this phrase means please ? Asking from the point of view of a PHP developer who knows basic security principals.
Good point. I think I could try to figure a way to load the items on demand. Currently a service is created by passing a new instance to a service method. The service then may or may not get used.
Currently you have to do that yourself. Since you can place the .ini file in a place of your choosing. I could however attempt to load from a default location and if it's not there don't load a default.
That's interesting. Could you refer me to the frameworks that are worth most looking into?
&gt; Without unit tests it's nearly impossible to refactor large, complex applications. With unit tests is nearly impossible to refactor large complex applications because tests force you to adhere to same interfaces limiting what you can change. Unit tests are best for core components that *don't* change much to ensure bug fixes and performance enhancements don't cause regressions. 
Because your view should handle escaping; it's the only one that should know what the output type is. You could have views that render to plain text, JSON, XML, etc. 
I see.
I'm going to go with the PHP manual and the common sense "the average PHP framework doesn't involve hundreds/thousands of errors per successful request" over a failed attempt at pedantry. Catch is handling an error. Autoloading is loading necessary classes as-needed.
 {{$var}} &lt;?=_($var)?&gt; Looks notably more verbose to me. Using PHP requires a mix of completely different characters. Plus of course you need to remember to add the function to every variable.
Thanks for the explanation! But I didn't really need one ;) your first comment was sufficiently clear. Background: I am used to the require('page.php') in my controller way of doing things. Except for one case where I used mustache to render data from one controller to multiple views - an ajax request and an html page. Don't remember what I did for escaping though
Actually, what I did was highlight a section of the official documentation that OP may not be familiar with.
&gt; I think I could try to figure a way to load the items on demand That's literally what autoloading is
The problem is that nowhere documentation says that transition is as easy as just adding an i to the function names. Nor does it say that this i is the point of all the hassle with deprecation. 
I'm surprised so many people here are using PHP for templating in any sense at all. While it's still perfectly capable of it, it's so much easier to use a front-end framework like React. PHP just spits out some JSON and you call it a day.
&gt; $_GET and $_POST are silly PHP abstractions that don't match HTTP requests well, this is why Symfony has -&gt;query for the Query Params and -&gt;request for the Request Body. Both of which are equally valid on a GET request as a POST request. Sorry, what? They're, at worst, not ideally named - i.e. `$_GET` is still populated on a POST request if there is data in the query string. If they were named $_QUERY and $_BODY but functioned identically to how they do today, there would be no practical difference. The problem the abstractions solve is avoiding dependence on global mutable state. Any function, anywhere, in any library, can put `$_GET['debug'] = "1"` and suddenly everything that looks at the query string will assume that data came from the user. Using the HTTP request abstraction solves that by providing a read-only interface to the same data. It also improves testability of most code, but that's a function of how the underlying code is written and how you'll tend to write it in a better way using the library. E.g. function encodeUsername() { return json_encode($_POST['username'] ?? ''); } would become roughly function encodeUsername(Request $request) { return json_encode($request-&gt;get('username')); } but you can just as easily do that with the superglobals: function encodeUsername(array $request) { // &lt;--- provide $_POST at your call site return json_encode($request['username']); } It's just that nobody does it. The various HTTP libraries provide a far better interface to accessing the data, but in terms of purely avoiding depending on the global state, they're not necessary.
&gt; Having to use htmlspecialchars on every variable output is a complete PITA. Twig makes things so much easier, and the syntax is cleaner. In twig, if autoescape is disabled you get something like: {{ user.name|e }} With autoescape it is {{ user.name }} In PHP, if you define a function alias/wrapper you get something like: &lt;?=e($user-&gt;name)?&gt; I agree that the twig way looks airier and easier to read, and autoescape alone is a worthy feature. But to say that escaping your output without twig is a pita is simply not true.
I think OP is referring to lazy evaluation of data, not class instantiation.
&gt; Having a single point of entry through index.php It's not like this is even new. I've been working this way on various frameworks since 2003.
No. A try...catch will take you *away* from the code that raised the exception - it is not executed, and so you need to handle that by doing something different. When autoloading is running correctly, a statement trying to access a class that is not yet defined, *will* execute to completion. This is nothing like an exception.
Most decent routers have it, could very well be Silex. 
I find it very inconsistent. For example [this block](https://github.com/nilportugues/php_todo_finder/blob/20b552e4ab61b63d9c8fa85c40d532806a25b03b/src/TodoFinder/Command/FinderCommand.php#L114-L130) uses `\true`, `\strtolower`, and `\sprintf`. But at the same time `false`, `is_array`, and `count`.
Some blog posts on this topic: * https://defuse.ca/secure-php-encryption.htm * http://tonyarcieri.com/all-the-crypto-code-youve-ever-written-is-probably-broken * https://paragonie.com/blog/2015/05/using-encryption-and-authentication-correctly 
Completely agreed. Have taken this approach on most PHP projects since 2000, and have seen projects adopting it since around that time (growing, but it's not a 'new' thing).
&gt; Some projects don't have the time or the budget for the extra overhead But I'm sure they have enough budgets to handle the debugging once shipped. And 6 month later. And 2 years later because some bug came back while adding some new functionality. 
At it's core, autoloading is based on a missing dependency. This is an error. Java routing by exception was similarly abused, while PHP (which originally did not "autoload") threw an exception which is just indicative of an error. &gt; A try...catch will take you away from the code that raised the exception Just like a configured autoloader? &gt; When autoloading is running correctly, &gt; This is nothing like an exception. Except in all the ways it's exactly like an exception, because it was designed to throw/catch and be handled from the beginning of the feature. Nowhere in here am I implying it's wrong. It's a brilliant feature, better (because it's runtime) than the java classloader concept.
There's definitely something to be said for 'quick n dirty' php, it can be very effective at just getting stuff done. It just depends what type of app/service you're building. If you want to build something complex, contributed to by 30+ developers over many years, the benefits of more OO code become clearer. For example, in old school php apps the lack of encapsulation is a real killer in terms of maintenance and adding new features. Try debugging some frameworks like OS commerce, and to an extent even WordPress. You need to pick the sweet spot between 'just getting it done' and doing it in a testable, maintainable way, depending on the project in question.
No, @colshrapnel is correct. Services are created like this: $app-&gt;service('myService', new MyService()); The issue is, that not every page request will use that service, which depends on if the developer needs the service or not. If I automatically create the service and the developer doesn't use the service on request A but they do use it on request B, then request A it loaded for no reason using up memory that could have been used for something else.
Do it later, then :) Lazy evaluation of the closure is certainly the best way to solve the problem, and quite possibly the only way. There's really no getting around that. Of course, I'm commenting about a single line of code, so that's probably not helpful without knowing the system as a whole.
I'm more interested in refactoring than a xomplete re-write to be honest, unless R offers an order of magnitude improvement. Plus, what's the interoperability of R and PHP? There are literally thousands of php scripts in this project. 
Well, R goes like this: table1 &lt;- read.csv(file="example.csv",head=TRUE,sep=","); table2 &lt;- sqlQuery(channel, "SELECT * FROM myTable"); and then you can just loop and work through both tables, creating the desired output. The interoperability with php, unfortunately, is only that you can call R as a command line from php, but not running php from an R loop, so yeah, you would need to learn a new language and rework all those scripts. :(
Parsing the csv is the simplest part of the problem . Is that the main benefit you saw from switching to R for this project?
I would work for a day to tune a large website for a few hundredths of a second. A restaurant menu page, not so much.
I mean, your not wrong but still. Damn.
Using `_` would conflict with `gettext`...
Well, I can't say that's the wrong priority because I don't know what your requirements are. Typically there are other more impactful things to spend a day on. What would drive your decision to spend a day to shave 1/50th of a second off a page load?
But why would you disable autoescaping? They, along with the forced restriction on how much logic you can put into your template, is the best thing about twig.
&gt; Now I have pretty much turned down every new concept or feature that exists in PHP That sounds like a recipe for unemployment.
It's a pain because it's very likely to bite you in the ass somewhere down the line when you forget to escape a variable.
You disable autoescaping when you use Twig as a template engine for a web app that doesn't output HTML. For example, let's say you are creating an API that receives HTTP requests and returns back data in plain text, and when I say plain text what I really mean is sending the header `Content-Type: text/plain`, so a web browser wont try to parse it as HTML. In that particular case you don't deal with HTML at all, so there is not reason to escape the HTML special characters from your data. I know my example is not great but I think you get my point.
Yeah, I see what you mean about the community. I've searched high and low for technical reviews and positive feedback but didn't yield any results. The lack of demos, screenshots, ethos etc is a little worrying, too. Right now it seems Bolt is the major contender so I'll probably give it a shot. I come from a Laravel background so I thought Pyro would be a good fit. 
Will target PHP 5.5 by the way.
A web deployment tool, Easy for configuration, Fully functional, Smooth interface, Out of the box. support git/svn Version control system, no matter what language you are, php/java/ruby/python, just as jenkins. you can deploy the code or output to multiple servers easily by walle. 
Plates doesn't support auto-escaping. You have to manually escape everything.
Both PlatesPHP and PHPixie Template have template inheritance and short escaping while still using php for templating
1. The front controller pattern is old as fuck and I've been using it for about 10 years in PHP. 2. Autoloading is more convenient that being forced to load everything yourself. 3. Not true, but many controllers do need at least one view. 4. Shoving your code under `App\` or something means new PHP features can be added on a global level without worrying about conflicts. Namespaces exist for a damn good reason. 5. Who the hell is destroying super globals? I'd rather not. Using HTTP abstractions (like HTTP Foundation or anything PSR-7) are incredibly helpful when you take into consideration how different certain $_SERVER values or other items can be based on your specific PHP setup and server. Especially when building something that's meant to be portable, like a CMS. People have been doing this themselves on every project for years, now we've just got a few more popular tools. 6. People were using Smarty 15 years ago, this is not a new trend. PHP is a templating language, but it's a fairly shitty one when your designer just wants to do some basic loops and use some modifiers. Many people are fine with basic PHP, many are not. This is not a new trend. 7. If PHP does something out of the box and it does it well, then people use it. When PHP doesn't do it out of the box, people install a package or an extension. If PHP does something not so well (like CSV - sorry) then people install a package or extension. This has been done with PECL/PEAR forever and long before Composer. Nothing you've pointed out is new. Maybe you're noticing patterns that seem new, because of the increase in top quality PHP education resources. That's a good thing. :)
I say huge because it means that ini settings changes via code potentially get ignored. I read the migration guide and nothing ever mentioned this behavior change.
Often businesses will target the oldest versions they can to keep their potential customer base as large as possible. But in this case they seemed to have made a wise decision to go with PHP 5.5. Contrast this with Wordpress, for example, which works on PHP 5.2.4+. PHP 5.2 has *long* been unsupported…
Surely you guys are joking. 
The front controller pattern is proven and tested. It works and is not going away. Rasmus has been arguing against it for at least ten years. No one is forcing you to use a front controller, but you cannot tell people that such a proven design pattern is wrong and that they are wrong to use it.
Magento 1.9.1 officially claims PHP 5.4 as the oldest version – this may seem like only a minor step but remember this is a business focused platform, so it's surprising. Also, I want to point out that I am mostly surprised. I'm not saying that Magento is somehow glorious because of this; it's just an interesting thing to note.
do you mean to say that programming is like fashion? get in with the time or... you'll be irrelevant? I've been doing this shit for 20 years, in the days working with HTML/Javascript/CSS for your UI was easy, all you needed was a text editor and a working brain. Today, thanks to progress, you need *this* and *that* and *that* OR *that* OR *that* (the more choices the better, right?). I fail to see where is the benefit for me as a programmer. I can definitely relate to OP, in fact I'm stuck at his first bullet, which is something although I'm forced to use on some projects (teams) I still don't understand why we need, why do we limit ourselves so hard. HTTP is easy.
you only need to escape user input
PHP is also just ugly as a template language. 
We have quite a few developers working on Bolt that come from Laravel background. Bolt happens to have Silex at the core, but we don't really promote it as a "Symfony CMS". It's just PHP. :-)
Fun fact: Magento 2's code references numerous classes, mostly factories, that do not exist in the code base. Their autoloader detects these classes based on their naming convention and *generates them at runtime*. PHPStorm flagged over 400 distinct missing class names. **Edit to add**: when I looked into this, I missed the fact that there's a [command-line compiler meant to generate those classes for you](http://devdocs.magento.com/guides/v2.0/config-guide/cli/config-cli-subcommands-compiler.html). That makes this less horrible, because after you inspect the code for the first time, see 6000 "Undefined class" errors, pick your jaw up, and figure out that they're actually using codegen, you can generate them and make your code analysis useful again. [Codegen autoloader: can the generator handle this missing class?](https://github.com/magento/magento2/blob/2.0.0-rc2/lib/internal/Magento/Framework/Code/Generator/Autoloader.php#L32) [Configuration: If a missing class's name ends with ... , use the generator ... to create it.](https://github.com/magento/magento2/blob/2.0.0-rc2/app/etc/di.xml#L605)
"ugly" is a subjective opinion and thus doesn't count.
Yup. I used to be among them, but the web at large has moved on, like it or not. And it's nice that working with the modern tech isn't nearly as painful. 
&gt; So Magento and over-engineering are still very much synonymous. Noted. I would like to give them the benefit of the doubt here. Maybe this is an approach to phasing out some of the older, badly coded cruft? I say this being a big critic of Magento.
Hmm, while I stand by what I said, on second look, it doesn't reflect your use case, sorry about that. So my advice is to configure your DI container via when...needs...use, and for the cases where you need multiple parameters of the same type, pass a factory closure to the container to use for instantiate the class. Situations like these are why I don't like DI container magic like Laravel's. What's absolutely trivial: having multiple objects of the same type with different config, becomes hard. The factory option is also good, but it depends on how your code is organized. If you have distinct modules, and module X may need either car/machine repository, it's fine to inject all classes of that module with the same factory. In fact, it's preferable that module has a single entry-point where you pass the factory and then the module itself is a factory for the remaining classes (i.e. you'll have very few entry point classes when you code in a modular way). At this point you're managing dependencies at the module level, not the class level, so all module dependencies can be in the factory. The only thing to avoid is having one giant factory for all classes in your project. Try to keep them relatively narrow (again, think "factory for module X, all that module needs"). 
Sites unwilling to update within the *next three years* are just not being serious about their business or their customer's safety, and I don't know what we can do to help. It is simply not possible to make the fundamental framework-level changes and have a clean upgrade path. Challenge of a big, open-source app. 
I've always disliked how OAuth drivers seem to be reinvented over and over, in every app and library that needs authorisation.
Fingers crossed, maybe we'll be able to drop 5.2 soon. We're down to only 11% on 5.2.
Good to see one more container adopt the container-interop interface!
&gt; My only concern with this, that I mentioned in another comment, is that: lets say CarService depends on RepositoryInterface, but it expects that to be a Car version of the repository. This is configured correctly in the container. Throughout the code the CarService will do things such as $carCount = $this-&gt;repository-&gt;count(), which should always be a count of cars. However, it would be entirely possibly to switch out the Car repository binding for a Machine repository binding in the container (as they both implement RepositoryInterface), but then in the service $carCount = $this-&gt;repository-&gt;count() is now actually a count of all Machines, which means the application is probably broken because the service still thinks it's a count of all Cars. &gt; Do you think this a valid concern? I typically don't subtype for such concerns, unless I intend to also add more specific argument/return type hints in the subclass. In other words, when you fetch count() from the repository, it's an integer in both cases, so subclassing won't help you much. Now if you want your repository to be typehinted to return Car objects from certain methods it may be worth it, but you also need to override more methods and do more typing to get that effect. I wish we had generics, then we'd just do Repository&lt;Car&gt;. That would be perfect, but maybe in PHP 7.something, who knows. Your concern that the repository receiver object may be *misconfigured* with a wrong repository is valid, but it's the responsibility of the creator to configure it right. In other words, it's not the responsibility of the configured object to validate the objects passed to the smallest degree, as long as their basic type is met, and the documentation is read and followed by the creator. If you want to create a specific class for every runtime configuration, you'll experience a proliferation of nearly-empty tag classes and interfaces which have no runtime purpose (when the app is configured right, it's configured right). In fact, I'd suggest you use assert() for this. Assertion has been fixed in a big way in PHP7, when you disable it not only doesn't the code run, it doesn't even *produce opcodes*. It's 100% free to add as many assertions as you want. So you can have things like that in your object that accepts a repository: assert($repository-&gt;getClass() === Car::class); And problem solved. I tend to stick to less types, when possible, as specific types for specific configurations limit flexibility significantly. For example, if I want an iterator that returns random integers, I typehint for an Iterator, or if we had generics I'd typehint for Iterator&lt;int&gt;, but I wouldn't create a special interface RandomIntegerIterator. I'd just describe in the documentation "the integers returned by this argument should be crypto-random". This promotes better composability of your code, I'll give an example with your repository: imagine you have a "caching repository" decorator. And you might want to pass *that* in at some point. If you are passing Repository and the decorator implements Repository, you're golden, the decorator "just works". But if you have specific CarRepository and MachineRepository, now you need two caching decorators that do the same thing basically. Not so reusable and composable. Or in the very least you'd need CarRepository and MachineRepository to be interfaces, and you'd need: class CarOrMachineRepository extends CachingRepository implements CarRepository, MachineRepository {} When you start writing lots of empty classes like this, you know something is not right. The caller should be intelligent enough to satisfy not only the type but the documentation, because no matter how many types you create, you can always pass in a wrongly configured object. So a single Repository type + creator intelligence is the default approach in my book ;)
Amazing answer, very insightful, thanks so much!
Now there are many libraries compatible with container-interop but i think PHP-DI is the most amazing one.
A web server knows the following information about a request (virtually all of this information is available in the $_SERVER superglobal): * The IP address and port from which the connection was established (which could be a proxy server or other intermediary) * From this it may be possible to derive the ISP or company who owns the IP and (usually very rough - eg. town level) location of the user. This information should not be considered reliable due to possible use of proxies, VPNs, NAT and inaccuracies in IP-to-location databases. It can be useful for setting a default language / geographic specific site for the user. * Information sent by the client in HTTP headers * UserAgent (the name and version of the client application (web browser)) * "Accepted Languages" - ie. what language the users browser / operating system thinks the user wants pages displayed in * Accepted document formats (HTML, XML, preferred image formats) * The full URL of the page requested (including query string / GET data) * Any form data sent (POST data) * The contents of any cookie data sent by the client (usually determined by the expiration date, domain, path and "HTTPS only" settings on the cookie) * The "referring page" - This is voluntary information sent by the web browser, and often isn't sent for security reasons - browsers used to send this with virtually every request but are a lot more strict about it now. From this you could sometimes determine things like search terms used to find your site, altho I'm not sure how often you can do that now. * Whether or not the connection is SSL/TLS encrypted Web services that want to track users (eg. Google Analytics) will place cookies and additionally use both the above information as well as information obtainable via javascript on the client side (such as what features the browser supports) to create a "fingerprint" that allows them to track users across sites or even if cookies are blocked / deleted. Using javascript and/or CSS it used to be possible to do things like obtain the users browsing history or work out if they'd visited a specific sites, but browsers have locked these down in recent years to prevent this kind of spying.
&gt; We've decided to not support PHP 6.
And `var_dump($_POST);`, `var_dump($_GET);`, `var_dump($_DELETE);`, `var_dump($_PATCH);`, `var_dump($_PUT);`, `var_dump($_HEAD);`, `var_dump($_OPTIONS);`, file_get_contents('php://input');
Nice try.
You can use JavaScript to retrieve visitor's battery persantage, screen resolution etc.
Holy shit, the maintainers of `ls` abandoned it publicly?! /s
Are you maybe thinking of league/container?
What? :) I didn't get that
Well, may be they are sending some malicious posts. This would show whether the visitor is a hacker, for example.
Even with native decorators the idea annotations are helping is highly questionable. The example in PHP-DI 5 is misleading, for example. Chances are even if you don't explicitly inject through the constructor you'll have a constructor as you'll want to set up the object, do some assertions and other quick setup work. So the constructor won't go away. It'll be just one line shorter. And then it looks like this: class Foo class Foo { { private $bar; /** * @Inject public function __construct(Bar $bar) * @var Bar { */ $this-&gt;bar = $bar; private $bar; ... } public function __construct() } { ... } } Not only is the WTF factor higher (you need to look for private members with @Inject instead of naturally following the constructor where the object starts its life), but the amount of magic required to get the example on right going, coupled with the fact it's bulkier in practice aren't exactly flattering about annotations of any kind. I'll take the plain constructor injection any time... I don't mind decorators for some uses cases, say, memoizing results, or running assertions on the arguments. It can be useful. But not for DI.
Dont use Annotation/@inject: 1. PHP annotations are abominations, comments should never affect code. 2. Having field injections rather than constructor injection means your code has hidden dependency, and we know why it is bad. 3. The responsibility of creating/injecting dependency should be from external/client code, not from the class itself. Each of the three reasons alone should be enough to stop people from using Annotation/@inject, and with all of them combined its an extremely bad practice to use annotation for dependency injection in PHP. If you care about your application, stop using Annotation/@inject at any cost. 
I don't mind an autogenerated template renderer, because the rest of the code does not reference it. I do mind an autogenerated factory class, because numerous places in the code reference it and I have to generate all those factories before my IDE can make any sense of the code. Static typing 4ever. In all fairness, Magento does provide a compiler to generate those classes, which I missed the last time I looked into this contraption. I'll add that to my previous comment.
Annotations are pretty useful in PHPUnit tests (functional/integration tests). No spectacular difference with `$container-&gt;get(...)`, but it's nice to use.
They're pretty useful in PHPUnit tests because that's the only interface PHPUnit provides. This is not annotations being useful on merit, but by circumstance. I have not a single annotation in my unit tests and I never felt the need. In fact, one of the most frequent complaints and questions I hear about PHPUnit is "what annotation I need to do X" and it's often for things which are trivial in plain PHP. Annotations are obscure, not intuitive and not composable.
It is subjective if only one or two people think its ugly, but if most people think PHP is an ugly templating language, then it is objective. Yes, PHP is a very ugly templating language, it shouldnt be used for this purpose. 
We just can't support it. I mean, there are like only a couple of books on it, and *no one* is talking about it... (Yes.)
I would call the internet police.
Direct link to the online sample chapters: https://leanpub.com/php7/read#leanpub-auto-part-1---new-features
I, err, wh..where on earth did that come from? My [searches for theleague oauth](https://www.google.co.uk/search?q=theleague+oauth) never came up with anything close. Turns out I needed to add "1" to the end to find it. *Dhoh!* Thanks.
I only found it because I actually [went to the website](http://thephpleague.com). Glad I could help :-)
&gt; This is not annotations being useful on merit, but by circumstance. Agreed, but "so what". Anyway, for me that's enough discussion about a minor (disabled by default) feature of the package.
Thank you!
Then you just need less test coverage.
I remember the same thing happening to me! lol
Well, you can't get backlinks by posting something on reddit all the links here are `nofollow`, but I get your point. On the other hand, I see that their blog is not on a subdomain but on subdirectory instead. That means the search engines will not handle it as a separate website, so all the potential backlinks to their blog will pass pagerank to their domain. Indeed it looks like a blog that its only purpose is to increase the pagerank of the company's website.
&gt; PHP annotations are abominations, comments should never affect code Can you elaborate? What are the problems caused by putting e.g. configuration in comments? Assertions and routes in annotations just seems to make sense.
Hey, is there any ionic developer at here. Stuck at one point &amp; need some help. Here is my Stackoverflow link - http://stackoverflow.com/questions/33719774
Thank you for your efforts in putting this book together, and for the coupon! 
[removed]
[removed]
Nope its not just my opinion, didnt you read all the articles I listed? Yeah you like them because you havent run into the tight coupling issues yet. And each of your point can be easily countered: 1. Code should never depends on comments, to put annotations in docblock comments is a big no no. Comments are meant to be comments, the fact that they exist in other languages has nothing to do with PHP. One basic rule of thumb is not to fight your language, while PHP annotations in docblock comments essentially makes your code unmaintainable and non-reusable. Either way there is absolutely no justification of comments based annotations, until PHP supports annotations natively they should never be used. 2. Field injection does have something to do with annotations, because usually it can only be done with annotations, at least in this case it is relevant to the point of discussion. In other words, its not a direct cause by annotation, but annotations make this bad practice possible and easy to abuse. 3. And thats exactly the where the problem is, you should not couple your class to the metadata. Metadata are application level concerns that should be provided by the client code, not the class itself. The class shouldnt care about how its configured, or you are breaking SRP. 
I know. I don't get it either. It's sooo sad.
&gt; Anyway this trend needs to stop Doctrine lead the way for ORM with v1 (copying from solutions in other languages), and they completely abandoned the AR pattern to rebuild as a data mapper in v2. Annotations survived. Doctrine and Symfony have some of the best engineers in the PHP world, you can't just write that off. &gt;What may appear easy and convenient now, will come back to bite you in future. This is why I asked you for some explanation, but all you did was link to some 3 year old blog posts. This reminds me of when everyone was scared they would have to swap out their DB every other week and coded to handle that non-existant situation.
&gt; didnt you read all the articles I listed The ones from 3 years ago? I read every word. I particularly liked the part where blogger A predicts annotations are a trend (in jan 2013) and I particularly liked blogger 3's complaint that it's hard to obfuscate php code that relies on annotations. It's trivial, I guess, to take these two bloggers as proof that the engineers at doctrine and Symfony, and most of the "leaders" in the php community are all idiots that will realize their mistakes pretty damn soon.
Any reason for not just going with 5.6 from the outset? Someone installing this has no need to stick with 5.5 at all when 5.6 is a very easy upgrade path. I'd say it's for 5.6 but in all likelihood would work with 5.5.
The book looks great Colin. One small note from the sample chapter on scalar type hinting, you have the line "For example, you cannot use numeric strings when a float or int is expected", but the following example is the inverse, a string is expected but you pass it an int. 
By the looks of it, it's a joke. Take a look at how anger and disgust don't like sadness' coding. :)
If they have yaml/xml/php/json/toml metadata somewhere else, yeah, it will.
None of these apply to PHP7 in particular. Also, why not link directly to the original article? https://kinsta.com/blog/10-things-not-to-do-in-php-7/
Sadness is a character of the Pixar movie "Inside Out"
Wow that useless article *again*. Its fallacies has been discussed already, https://www.reddit.com/r/PHP/comments/3sksr0/10_things_not_to_do_in_php_7/
how about appeal to sarcasm?
Use: $this-&gt;setExpectedException(FooBarException::class); see: https://github.com/sebastianbergmann/phpunit/blob/master/src/Framework/TestCase.php#L465
Reddit + annotations… It's just so predictable.
You could try storing the sessions in Memcached (see Elasticache if you're using AWS) or Redis. 
First of all I'd avoid having setters. But I assume it's just simple for example. I'd not pass this in constructor, I'd just pass it ass parameter but I'd type CompanySlugGeneratorInterface instead. Also you may try to extract this logic into another service and just pass generated slug to domain entity in constructor/setter.
Oh yeah, it was 3 years ago, but what the authors said still apply. According to your logic, people should not read books like GOF and POEAA because they were published like more than 10 years ago. Either way you look at it, its ridiculous, total blasphemy. Are you sure you are not just trolling? Its been 3 years, and PHP still hasnt added annotation support. This means that you still have to use comments for annotations, which is still very bad and shouldnt be used. So my argument stands, PHP annotations are bad practices that you should get rid of. And if you really dont know how to search, read this thread on Reddit just 1 month ago, and see how many people are against annotations. Now its time to drop your '3 years ago is too old' nonsense? https://www.reddit.com/r/PHP/comments/3mwevm/symfony2_annotations_php/
I already gave you enough explanation, you didnt read. And now how about reading a thread in which people discussed annotations just a month ago? Or maybe you will say 'A month is too old, you need evidence within the last week'? https://www.reddit.com/r/PHP/comments/3mwevm/symfony2_annotations_php/cvirvw1 https://www.reddit.com/r/PHP/comments/3mwevm/symfony2_annotations_php/cvis63w https://www.reddit.com/r/PHP/comments/3mwevm/symfony2_annotations_php/cvivevm https://www.reddit.com/r/PHP/comments/3mwevm/symfony2_annotations_php/cvixwwl
`PUT` should be `PATCH` and `POST` should be `PUT` instead.
Thank you for catching that! I will make sure that gets corrected.
Hey. Awesome book, bought it and just started reading it. I don't know if you want formation flaws pointed out, but this occured in iBooks on a 13" Retina Macbook pro: [image](http://i.imgur.com/PXUBAN4.jpg) I am unsure as to why the "e" has been escaped. Anyways, awesome book, keep up the good work! :) Edit: alright, so this is almost every time there is a comment. It might be an issue with iBooks. [image nr. two](http://i.imgur.com/c67bfNR.jpg)
&gt; I know where every variable come from on the main "app" I maintain yes No. You don't.
The twitter account is not funny at all
PATCH should be used to modify a resource. PUT / POST can be used for resource creation but PUT should be idempotent. The other difference refers to object location. If you don't know the location of a resource when creating it, you should use a POST and the server instructs you of its location within the API. EDIT: Above is no longer valid as OP has updated his documentation
That's an awesome test for when to use a setter. Thanks!
I'm running a site on a fairly customised copy of PyroCMS 2 and tested 3 not long ago. I won't be using it. It feels like they've not really added anything worth using. The focus on 'streams' seems the completely wrong direction IMO. PyroCMS support for premium members was never amazing, and the community just didn't exist in a big enough way to make it worth considering. In the time it's taken to finally get version 3 done, newer, better CMS systems have come along and have bigger communities around them. That should tell you a fair bit about PyroCMS. 
Nope, I'm PHP guy
It's a discussion of semantics but I disagree with this interpretation. My understanding is that * POST -&gt; Creates resource * PUT -&gt; Replaces resource * PATCH -&gt; Alters part of resource As is noted in the first comment to that blog post, there is nothing ambiguous about (e.g.) a JSON key-value representation of a changeset to be applied &amp; there are bunch of advantages over requiring the full resource being transfered with PUT. 
Ok looks like I'm wrong. I'll update the post as soon as possible. Thanks for the feedback! EDIT: Updated the post!
/r/forhire. Though for $15/hour you might have a tough time finding someone.
Don't get it either
&gt; When I call setName() on a Company object, I want it to generate a slug for itself: This sounds wrong. Why do you need to generate a slug when calling `setName`? Do you really mean, "Later on when I call getSlug(), I want it to be the appropriate slug" ? If so, the appropriate thing to do is move the dependency on CompanySlugGenerator to be wherever it is being used. If not, then I don't think we currently have enough information to answer your question properly.
Crap. I've been using PUT incorrectly since forever
Well since I assume your domain object is a simple VO, like a datamapper/repository entity should be, then you want no logic in it at all, and that means that you'd just have to set the slug with the assumption that it has been already validated. You'd probably have something like a `SlugGenerator::generate(string $value, SluggableRepository $repo): string`, with `SluggableRepository::findBySlug(string $slug)`, and seed the result in your VO constructor or slug setter. If you had heavier domain objects instead, which already abstract some logic like AR ones, than there would be nothing wrong with adding the sluggable behaviour to it, and you could probably do that with a stateless trait that uses the embedded AR api.
sadness is the new sad panda
The huge diffrence is that all things you would ever type hint too have a name without suffix. If you were not using an interface you would just have an abstract Parser, and then Parser\JSON extends Parser
Not following modern standards can often leave behind an incomprehensible mess for future developers to work with
Completely agree with that sentiment, 100%, but just to add: the OP [edit: removed previous reference "chap", stupid brain] isn't even talking about anything new. These are all new versions of things that have been happening for the whole 10-15 years I've been writing PHP. Fighting progress is no good, but fighting established useful processes because of misunderstandings of the benefits (or when they are the right tool vs. when they're not) is even less useful :) 
While this is true, I think many APIs use PUT for both replace &amp; patch operations. If I had to guess the reason it's that a lot of developers may find it confusing that there are two ways to update a resource.
Well, yes, obviously, I agree with that. Unfortunately, the average buyer doesn't know the first thing about Magento or updates, nor should they have to... I Oh that's the biggest problem. 
Don't confuse the lack of interest in templating engines, frameworks and HTTP abstraction with being a poor quality programmer. I've worked on some amazingly well built codebases which use none of those things. Trying to ignore namespace though... it's just like looking a gift horse in it's mouth then kicking it right in the junk.
&gt; I get where you're coming from I'm saying you've fucked up your class design. In the rest of your code where you are calling `getSlug()` you don't have a dependency on `Company`, you have really should have a dependency on LinkableCompany: class LinkableCompany { function __construct(CompanySlugGenerator $csg, Company $company) { $this-&gt;csg = $csg; $this-&gt;company = $company; } function getSlug() { return $this-&gt;csg-&gt;generate($this-&gt;company); } } &gt; I'll be calling getSlug() in many places and I don't think I want to have a CompanySlugGenerator ready whenever I do. In any places where you need to call getSlug(), you should be able to replace the Company dependency with a LinkableCompany dependency. If you're using a dependency injection library this should be trivial. If you're passing objects around by hand, then just create the `LinkableCompany` object where appropriate and just pass that around instead of the Company object. If you really wanted to, you could make LinkableCompany extend Company - but I don't know enough of your code base to recommend that. 
It should also be noted that if you have a custom session handler, and if you aren't handling locking yourself, PHP won't handle it for you. You may have your own session race conditions and not realize it.
A few personal considerations here in response to your question: 1 - A framework is used often because building your own would be expensive and often give the same result in most of the aspects. 2 - Time is money and the more time, the merrier. Crafting is beautiful but is not for every business. 3 - Some frameworks, like Symfony, allows the use of only specific modules, keeping it very clean and lean. There are also micro-frameworks that does just the necessary. 4 - Liability is a thing. Think about major corporations like Target that were recently hacked and imagine how busy is the legal department now. You aren't wrong on your considerations. I have been coding since PHP's 3.2 and there is always a culture change when major releases are out. The new trend about mvc and uses of standards and patterns is not bad, but you got be flexible about it. You seen to have good knowledge about application building and PHP. If you had to create a library set, a framework, to solve the common problems, how would you do it ?
Did OP say they were a chap?
Cool, so three blog rants from 2012 and now a couple of reddit posts. That sure is overwhelming evidence all right.
This looks pretty nice. While I'm a fan of the [League Container](http://container.thephpleague.com/) myself, this seems like it has a lot of flexibility. I'm surprised with the complaints about Annotations. While I dislike annotations for pretty much all the same reasons, [they're disabled by default](http://php-di.org/doc/annotations.html). Autowiring does not depend on the presence of Annotations either. So unless Annotations are explicitly installed and enabled somewhere by a developer, I don't think the Annotation-free camp should have a problem using this.
Thank you good sir! This is exactly what I was looking for. Holes are being plugged.
This is the way I've always used these verbs as well
Sounds like my first PHP job. 'Trial by fire' they called it.
fair one haha 
&gt;Making difficult changes to complex MVC sites as one example(in CodeIgniter, and Laravel (these sites have zero documentation and minimal comments)) Last time I checked, Laravel has really good documentation, and then a good community that you can ask questions too. 
It's your first job. Don't be afraid of failure or not living up to anyone's expectations - they'd be fools for thinking you're there to save them anyway. What do you want out of the job (short term) and out of your career (long term)? Invest time in yourself, use your free time to learn - Both CodeIgniter and Laravel have stupendous documentation, whatever you can't workout you already know where to go - StackOverflow. And yes, it's very much common practice to just sit at a job and not have any help. My first job sounds much like your experience.
heh try to maintain a laravel project where the best practices weren't followed.
&gt; My question is is this a normal way for a graduate to start out as a professional PHP dev? Yes. A junior is often just given google and told go. &gt; Do graduates in your workplace tend to work closely with others in the early stages? No. I do not encourage hand holding. Sink or Swim. I usually say it'll take a junior at least 2x as long to do something or more. An experienced coder in a project has intimate knowledge of it... it's not fair to expect that level of detail to someone new on the project. So I also add a multiplier there as well. Something that would take a maintainer a day to do should take a junior 2-3 weeks to do.
&gt; Especially Ruby on Rails has gained a reputation for being slow and not scaling well Scaling almost always comes down to infrastructure and how you logically split up your code. If you separate out your database, business logic, static assets etc... scaling out horizontally is a relatively painless experience. Sure it's still a difficult thing to do, but you can scale quite far with a little foresight and planning.
Just keep in mind how much you are learning. Every time you solve one of those problems you are becoming more adept at development and more valuable to your current or next employer. If they start giving you trouble about your performance, give them your feedback that they aren't equipping you to succeed and tell them how they can better utilize you. Until then, keep learning and training yourself and it will pay off in the coming months and years!
That seems like a terrible idea. At my job we expect things to take longer but a more senior dev will talk you through the thing you need to do and explain how. Plus there's code reviews. You can't expect someone to get up to speed and not hate their job by dumping them in the ocean.
This is normal for a small web agency: they generally don't have the time or the manpower to properly train you, and are willing to let you take longer and stumble on your own in exchange for the heavily discounted rate they no doubt pay you when compared to a full developer. However, if you don't figure it out on your own quick and you're still stumbling after a few months, you'll likely be let go and they'll just replace you with someone else. In a larger organization that has proper college recruitment set up, this would be completely unacceptable. A junior engineer is brought in precisely to be taught the ropes by more experienced team members so that you learn things properly and aren't the latest "I learned how to be a developer from W3Schools/PHPClasses/hacking WordPress templates" casualty. That type of training/onboarding will usually take the better part of a year. If you're looking for that type of guidance, there are companies out there that do it, and you'll probably be better off for it in the long run. You'll want to find companies that have recruitment programs and generally have more than a dozen engineers on staff.
It's always the same thing, the word "annotations" appears in this subreddit and a few people feels obligated to tell the rest of the world how they feel about it.
Actually a good writeup! Conclusion is subjective and its probably better in /r/webdev than /r/php but interesting nonetheless. 
Well the thing is i know im suppose to build something and i have learned this code but the biggest problem for me is thinking of something and actually making it. 
But stick with it! Once you get past this first somewhat tough part, programming's the best.
You say complex, but you don't specify exactly why it's complex or complicated. Based on what you've written, I don't feel that this seems too outlandish. Perhaps it seems more complex because it's in a language you aren't intimate in. Try thinking about the problems at hand using a language you are familiar with and then adapt that thought pattern to PHP or JavaScript.
There's too little information to come up with any reasonable kind of solution. I'd suggest writing a wrapper around `track`which would throw a custom domain exception because they're easier to catch and handle. I'd move away from the built in event bindings. As you've said you're doing the following three steps 1. create user 2. run `user.create` event listener 3. create user preferences 4. run preferences.create` event listener 5. set credits I'm assuming that step 2 contains has a couple different listeners that could all fail and bork the entire process. As you stated a transaction won't work because it's not entirely in an RDMS. I'd run steps 1, 3, and 5 then fire a domain event called "userCreated". Then rebind all of the `user.create` listeners to listen to my "userCreated" event. With this change you can make sure your database is at least created as some what expected. If track is a requirement to render the post registration page and you can't rely on track 100% uptime. You should make a page that says "We've created you account, however we're temporarily experience server issues. Click here to try to reactivate your account". The wording isn't specific. That link will try to reconnect the user to track. I'd insulate my events from blocking the entire application flow, but that's never pretty unless you have a 1:1 event binding.
While this is somewhat normal, I do want to point out that good employers will *at least* give you some access to a senior developer when you are stuck. You can ask for code reviews from them, etc. I suspect at least a little bit in your case they were hoping you would come up to speed quicker. I'm not sure why they'd think that given that you didn't have PHP experience. Seems like a mismatch of expectations. I recommend talking with whoever is your manager.
Build a reddit clone!
Yes, that was my point exactly. Calling something "ugly" doesn't contribute to the discussion at all. 
Flarum is good example to learn modern php
Thank you so much for that feedback! Would you mind if I quoted this on the e-book's page?
Well compared to the nonsense you are talking about, they surely are overwhelming evidence. Id trust words from those advanced and successful PHP programmers, than the likes of you. 
Laravels docs arent THAT bad. I swear schools don't prepare our young ones for anything. Preserve and your knowledge will tip...oh and don't be stupid.. That helps :p
The best way to learn in coding is by doing the hardest task because in that way you learn more things. And they are doing all things correct in this way you will learn more because when you are on your own you will learn more. I am also in final semester of my graduation in Software Engineering and I have started my career just like you, though I have learned many programming languages on my own like JavaScript, jquery, cordova, html, css and PHP. I have learned lot of programming techniques when I was doing my Final projects of every semester because in that we on our own :P
Start by learning how to implement mysql with your PHP and using MVC create a proper School Management System. Why creating this you will going to learn lot of new things. I will be starting article series for tutorial on mysql at [Cloudways](http://www.cloudways.com/blog/) for beginners. You could use that for your reference.
I have a codeigniter project + web service for android. I would like to host it in amazon cloud so that it will be available for a wider audience and also handle high load. So which plan should i chose in amazon. Also it seems amazon is different from most common cpanel hosting. 
Yes it is normal. You have Google, Stackoverflow and I'm sure within reason can ask your co-workers. However what most people don't realize is that you need to do a hell of a lot self learning on the side. When I started I spent my evenings, nights, weekends, lunch breaks - any moment that I could to read up, learn, write hobby projects for practice. Here is a hint for you in general - you want to succeed in software development you have to code. A lot. All the time. In job and outside. Tired of reading? YouTube is full of useful (or less useful) videos about technology, frameworks, languages, conferences, ...
Are you the only developer in the company? If not, go and ask other devs every time you are stuck or quickly discuss your proposed solution. We hire developers with basic knowledge and expect them to ask when they have questions. If it is a small company, you should have family like culture there, so asking for help from other devs should be more then welcome. If you are the only developer, then I would suggest quiting. There are probably reasons why previous devs have quit and you could just pretty much described them there.
While things are better at other companies, this is how a lot of (smaller) firms work. It will be a huge learning opportunity for your programming skills as well as your general "workplace" skills. Really, when you stop learning at the job it's time to switch. Be sure to start out (way) overestimating the time it will take you to find a fix, and work your way down. If you don't, besides the frustration of learning by error, you'll have to deal with the pressure of missing deadline after deadline. You don't make a lasting good impression with a tight estimation, you do that by meeting them. Some smaller firms with very little development experience can be quite a poisonous environment. They try to treat software development the same as any other department, while the workflow is completely different. This will create a huge amount of tension. For a first job, trying to change the mindset of such a company is a very bad idea. Since you have no other work experience to compare it to, go to developer meetups and talk to people there. You'll know soon enough how your workplace compares.
I wouldn't normally post something that was specific to Laravel here, but the Collection class has earned a bit of notice outside the Laravel community, and the first part of this eBook is about creating ArrayObjects in general, so may be of some interest to people. This is an entirely free contribution so please ignore any "suggested price" stuff from LeanPub. It was just something I wanted to write. Suggestions and advice welcome - Thanks! Jeff
I was in a similar situation when I started my first PHP job half a year ago. I just worked through it (even though it was stressful as hell at times) and now I'm happier than ever - I still don't know wtf I'm doing 60% of the time, however I am able to give everything my best shot and make small wins here and there. These might come in handy, they certainly did for me: https://www.codecademy.com/learn/php http://www.phptherightway.com/ https://www.codecademy.com/learn/learn-sql https://www.codecademy.com/learn/javascript https://www.codecademy.com/learn/jquery https://www.codecademy.com/learn/web https://www.codecademy.com/learn/learn-git
Nice, thanks ! Gotta love those collections !
Exactly. People here keep saying "Oh, yeah, it's normal to be that way. You'll learn OH SO MUCH." Yeah, you will, but, then again, you'll learn FAR better with guidance. Guidance doesn't mean copy-paste from another one's mind. This "being alone is tough, but good" exists in the first place because people think that a person will learn the hard way that it should rely on google and on his or her own mind, not keep asking question left or right, bothering people. That's true, but a senior can also teach that, save the frustration.
All the frameworks you tested where client side javascript, not really r/php.
Take a look at this list and pick something you find interesting and do it: https://github.com/karan/Projects
Agreed, this isn't normal and it's troubling to read of all the other commenters who are in similar situations and are under the assumption that this is the norm. Really the best ways to become a better programmer are: 1) work with people who are more experienced 2) practice, practice, practice. Unfortunately, I suspect OP may work at one of these web design shops who really just masquerade as development shops and most likely don't have any senior devs on staff.
I will certainly look it up,thanks.
Odd, this is what I get (PHP 5.5.9): class DateTime#1 (3) { public $date =&gt; string(19) "2015-11-11 15:00:00" public $timezone_type =&gt; int(3) public $timezone =&gt; string(3) "UTC" } Date timestamp using format(): 1447254000 Date timestamp using getTimestamp(): 1447254000 Changing timezone to CET Date timestamp using format(): 1447254000 NB: This has changed?!?! Date timestamp using getTimestamp(): 1447254000 NB: Now it is back?!?! Date timestamp using format() again: 1447254000 NB: Now it is back?!?!
Output does indeed differ with version: https://3v4l.org/bjd3L
Purchased. Made it through the first two chapters, highly recommend.
Code review is the central point here. I've seen very small agencies who had a great library with current dev books and didn't mind if you spent the day in there learning (even as a senior). Newbies could always talk to the senior developers and ask for a code review.
Yeah - they're concerned about maintaining an interface. How much work and maintenance is involved?
Late to the party but maybe I can offer a different perspective. Because of my history I feel you should probably run away from this place as fast as possible. If I had to guess they probably don't know what the hell they are doing as a whole. The owner or people in charge probably have zero interest in coding standards, code reviews, or furthering your skill set. Do you think if they could hire somebody a buck cheaper do you think they would do it? Just something to consider. You will learn but it won't be great. You'll be too focused on delivering something that works than pushing yourself. Also, the best way to learn is by having somebody smarter than you around. Doesn't sound like you have that. You should really think about where your skills will be in a year. Would you be better off somewhere else? Normal isn't the right word. Common is. It's not normal for you to put somebody on the job with zero experience, zero training, and zero support. You'll get alot of "battle hardened" developers saying how they did it this way and you just need to suck it up. That is incorrect. Now, the flip side is you may not be able to get a job anywhere else with your current skill level. If you can handle the stress then it's mutually beneficial. You get experience and they get work done. Not ideal but you both get something beneficial out of it. 
Thanks. As a minimalist, I love the idea of being able to include exactly what you want in a project and leave out the rest.
I was mislead by that too. The "cost" of a framework on your beefed-up web-server is much less expensive than the technical debt of not using one.
I'm not sure what the issue is (perhaps Daylight Saving time?) but the PHP docs do strongly suggest you [don't use CET](http://php.net/manual/en/timezones.others.php). When you use Europe/Paris or Europe/Berlin the problem disappears.
&gt; We're currently on Cake 2.X. The application was rewritten from ASP -&gt; PHP -&gt; Cake 1.X then upgraded to 2.X. That's 4 rewrites in about 5 years (I wasn't around for most of these rewrites). Now the company is talking about a change to the site that would make us re-architecht the entire code base (it's not 100% yet, but is likely). I'm being moved over to this team to help rebuild. That is insane.
Good talk! 
Find some really good libraries on Packagist and use those. You don't need a framework. Obviously, this presupposes you know what libraries you need (e.g. router, etc). However, insulating yourself from world with 10,000 interfaces, [A.] Doesn't completely insulate you. Interfaces are still a contract and that contract will tend to the path of least resistance. The least resistance path will be to match the interface of the libraries you are consuming, [B.] will take forever to write, [C.] confuse other developers.
Try this, which makes a little more sense in the case where you are using CET twice. I just changed from using the constructor for DateTime's second parameter to using setTimezone() twice. I think something fishy is happening when using the constructor's timezone parameter. &lt;?php $date = new DateTime('2015-11-11 15:00:00'); $date-&gt;setTimezone(new DateTimeZone('CET')); var_dump($date); echo "\n Date timestamp using format(): " . $date-&gt;format('U'); echo "\n Date timestamp using getTimestamp(): " . $date-&gt;getTimestamp(); echo "\nChanging timezone to CET"; $date-&gt;setTimezone(new DateTimeZone('CET')); echo "\n Date timestamp using format(): " . $date-&gt;format('U') . ' NB: This has changed?!?!'; echo "\n Date timestamp using getTimestamp(): " . $date-&gt;getTimestamp() . ' NB: Now it is back?!?!'; echo "\n Date timestamp using format() again: " . $date-&gt;format('U') . ' NB: Now it is back?!?!'; ?&gt; I'm not sure if this is a regression or a fix. Basically, it looks like **format()** is giving you the "timezone view" of a given time. Think about a normal time representation... 2015-11-11 15:00:00 (UTC) is actually 2015-11-11 16:00:00 (CET). **Format()** is saying that this absolute unix epoch timestamp of '1447254000' is actually a different value, '1447257600' as **seen from** the CET timezone, since when you apply the timezone you do the +1 hour adjustment. In other words, unix epoch timestamp '1447254000' converts to 1447257600CET. The UTC timestamp happens to coincide with the unix timestamp, so when you call format in UTC you see the same representation - in other words, 1447254000 unix epoch timestamp is equivalent to 1447254000UTC. Given that the documentation for **format("U")** says it is the "seconds since unix epoch", it seems this might be a bug. --- edit: - Link for an eval of the code above: [here](https://3v4l.org/0j2I5)
I think your dev team should do an AMA here in /r/php prior to the official launch.
They are making the migration really really easy. Companies that act this way should die.. same as companies that refuse securing their stuff in general (i.e. by updating their codebase to work with supported PHP releases). Three years is a lot of time even for a mom and pop shop.
I'm using Zend Framework, I would kill for docs as good as Laravel's.
This should be the top post. ;)
&gt; is this include("/path/to/my/class.php"); $c = new My_Class(); &gt; better than this $c = new My_Class(); You mean __construct(My_Class $c){ } because the DI container takes care of newing up the class. ;)
&gt; it sounds like your company is either into RAD, or doesn't know what it's really doing Heh - and they didn't. The focus has been on stability lately, so I think I have buy-in on a long term goal to make the code long-lasting. &gt; THIS is how you make framework rewrites be less of a pain in the ass. You make as little of your business logic (probably 80-90% of your app) touch the framework as possible, then you just rewrite the thin controllers and basic models when you upgrade the framework or switch to something else. Ah - perfect. This is probably a great compromise. So, PSR-7, business logic in basic classes and framework specific code out of business logic. Thanks for your help. Great advice.
Hence my question :)
From that bug is a link to [this bug](https://bugs.php.net/bug.php?id=68474), which I think is just another phrasing of OP's problem (reading the first comment makes it more explicit). So bug is known about, but obviously not being actively worked on...
It's great that you know you need support, I think you need to talk to your boss. They will probably be supportive, but to be honest, I think they are a saint if you have not even been playing with PHP or JS in your spare time prior to the role. My main concern is are you interested, because if you are, I think you and your boss will work it out and be like two peas in a pod; but it is a very unconventional situation in 2015, which is terrible to say, as I started with no mentor and my code was atrocious. Luckily I was pre-uni and in-school, and through work at the beginning really of the internet I was afforded the opportunity to learn; so I learned what worked for me, and those I worked with. PHP development is so much more than it was in say 2002, but it's also so much easier to get things done now than it ever was.
I agree with some of what you are saying. I find that your arguments are well suited for calling out Full Stack frameworks... but not so much smaller micro frameworks. Slim framework does 1 and 2, but does not enforce 3, 4, 5, 7. 6 is kinda meh, we have both a twig and php template plugin. 
Hey Phil, if I could ask a related question -- if I use Laravel as an example, validation is typically stored within injected FormRequests, stored in the app/http/requests folder. This works nicely, however, it certainly could be argued that validation (and sanitization) are key to the integrity of the business data; thus, should belong in your src directory with your other business logic. You can obviously extend the base validator with your own methods, but this doesn't seem very decoupled. Do you have any thoughts on the best practise here?
I'm not sure I understand the problem &gt; BankAccountCreator, CreditCardCreator, etc So `NullAccountCreator` maybe? as for selection in UI, etc... don't use else, just switch or if on valid results, the fact that nothing shows up, should be an indicator. If there is a default, maybe log that something unexpected has happened so you can monitor... I would caution that data integrity should not be compromised by missing data; but maybe you must provide incentives for entry of the data, and guards to ensure that anything vital is maybe sandboxed from the rest of the data. Or is it that the database has constraints that stop input? If so, remove them and find ways to detect in the app; it's a million times better, because rather than worrying about getting data in, you can focus on de-duplication, reducing data to aggregates and grouped or distinct data...
Hey, one of the CakePHP core contributors here. In my mind, software refactoring and sometimes rewriting is part of the normal lifecycle of any application, so we should not be worried about them but instead embrace that fact. In my present company I have led the refactoring of a very big Cake 2 application into code that is more decoupled, yet still runs on top of Cake 3. This is because it is easier for the rest of the team to have access to something already implemented and very well documented, than to come up with a home-brew solution from scratch. As many others have said here, being framework agnostic does not mean creating your own framework. In any case you will need to think about how good or bad your code will edge as the computing world is ever evolving: new language versions, new database systems, deprecated operating system versions... If you have any questions on how a transition from one version to the other, while gaining some liberty out of the framework, please let me know :)
&gt; i could fork Symfonys Yaml and hack that in, but than i have to keep track of upstream changes Or you could implement it properly, write tests and submit a PR!
Something like resources and transformers per client sounds like what you want: http://fractal.thephpleague.com/resources/ http://fractal.thephpleague.com/transformers/ But applied to validation and not output .... :) In essence sounds like a Schema (versioned) validation callback for a form.
Hey. Thanks for writing this. Two suggestions: 1. Other free publications on leanpub have a direct downloadlink. I actually haven't figured out how to download this except "buying" it (for free). 2. I see why you chose to write an "ePamphlet", but I still think a multi-part blog post ([two](https://mattstauffer.co/blog/series/new-features-in-laravel-5.1) [examples](http://culttt.com/tag/cribbb/)) would have been a better choice and maybe still is. Anyway.. thanks for sharing!
Not before the weekend, there is no time before Saturday morning. But i need it until Friday :) Also i don't like to reinvent the wheel. if i can find something in the next two days, i hack it together (i need it just for one run) and fix it on the weekend and submit a pr. it there is something that does the job, i could do other things in that time.
That sounds like a really cool idea. But: what if I want to be able to change the behavior of `CompanySlugGenerator` in the future? Or what if the name of the company changes? I don't want all my links to be broken. I want to be able to persist the generated slug so that doesn't happen.
not this time, yes, its what i need, thanks. my usual problem with pecl is that pecl modules are wired to install. They need to be compiled, they dont integrate with my package-manager but the don't bring their own sources like npm modules do. But, since this is a one time job, thats it :)
For a newbie, I think Shopify is so great. It is just so full. Business first. But mostly I was worried about is that the data of my clients. Can I export my clients data from Shopify if I do a migration to other platforms, such as Drupal or WooCommerce? Thanks!
no, this isn't really normal... usually, you have coworkers, that are able to help you (at least i would not hire a junior as the only dev). are you really the only dev?
Thanks for sharing. I would have pulled hair out somewhere if I used Magento... :$
&gt; I would more go down the line of explaining Hexagonal Architecture and DDD. This. I recommend reading Domain Driven Development by Eric Evans http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215 and most things by Martin Fowler. Split your application into modules/bundles (e.g. UserBundle, ProductBundle). I also recommend using Symfony2 rather than a really opinionated framework like Laravel, Yii, etc.
Interesting. I've used Fractal to convert DB results into a format suitable for a CSV export, but didn't think to use that for importing too. Thanks for the idea.
One thing I would *love* collections to adopt is [Lazy.js](http://danieltao.com/lazy.js/) style 'deferred' looping.... so it will only create one array and do all the processing where necessary. Would massively improve performance on large collections.
I just ment a similar design pattern between classes -- I dont think it will do it outright.
Thanks I would take that into consideration. I have several servers those are not used. So I might think about taking use of them. Somebody says http://thelia.net/ is a good opition. What you think?
I am going to give it a go today. Drupal commerce. My friend is building a site using it. It looks neat. What about the security of Drupal Commerce? 
`Traversable` is an actual interface and not a pseudo-type. An `array` is not an object at all, and therefore cannot implement any interfaces. I'm not sure what the impact would be if we made `Traversable` a pseudo-type that an array will pass. Personally I would go about it a different way and add generalized union types in PHP. This would permit `array|Traversable` in the type declaration which allows the user to pass an `array` or an object which implements `Traversable`.
...but it's not out yet. Why would you do that? :(
&gt; but it most certainly CAN be tested How exactly would you test a scenario like this? Am I supposed to write tests for my external package dependencies too? &gt; but basically, by wrapping it instead of using a property, the code can be written to return a valid value 100% of the time Those are relations provided by Laravel, and I'm unsure how it would end up when I get polymorphic relations. I can do getCredits() since it is a single relation, but what if I need to do: $user-&gt;site-&gt;campaign-&gt;advertisement Let's say campaign is missing for some reason. Then I need to write different getters. Site.php getCampaigns() { null check; } Advertisement.php getCampaign() { null check; } Basically it's the null object pattern, but I don't personally like it. It makes my data inconsistent, and I would need to reapply that logic everywhere. (e.g a future developer may user $user-&gt;sites because Laravel docs shows that, but I have to block the access to properties in favor of custom getters, which will change most of the underlying structure.) I can move those to terminatable middleware but race conditions will occur. What if I need to use the data returned by the curl call for the credits logic. (e.g if it returns x, give him more initial credits for example) Moving it to the destructor won't solve anything in an ever enhancing codebase.
The article mentions: &gt; `foreach` operates on a copy of the array. So if you modify the array while iterating over it, those changes will not be available inside that loop anymore. As far as I know that's always been the behavior. Am I missing something?
I'm surprised that WordPress didn't give more trouble, I'm cautiously optimistic.
You have to define security. That's too broad. DC is built to be PCI compliant, but you have to supply your SSL and such. 
It's right there in the manual: http://php.net/manual/en/migration70.incompatible.php
I had free time now, and idk if I'll have as much free time when &amp; actually comes out. So I decided to upgrade to the RC already and just update it when stable release ships. As the devs already noted the last RC is pretty much whats going to be in the stable version. Afaik they just want to wait out since there were still some bugs between last RCs
eBay no longer uses WordPress, but when they started they did. I am not sure what you mean by this so please clarify: &gt; I am doubting that can people make some money just running a news (Not selling things) website like one of those? Can they gain what they paid back? I would think that is a thing about business model.
&gt; The PHP community is so fragmented So true. I too really like PHP but have been diving more into Python because of this. 
[TOO LATE :-)](http://magento.com/blog/magento-news/new-era-commerce-innovation) Would it make sense to do an engineering AmA here or over at /r/Magento ?
Reason #4080 why I love our community: [They've already done it.](https://www.magereport.com/)
I'm not sure I'd characterize it as "easy," but we're trying to help as much as we can.
&gt; 2003 Hahaha that was just yesterda.... *checks calendar* HOLY SHIT! I feel old :C
The manual says: &gt; When used in the default by-value mode, foreach will now operate on a copy of the array being iterated rather than the array itself. This means that changes to the array made during iteration will not affect the values that are iterated. But I don't understand either, arrays were also copied in PHP 5 and couldn't be modified during iteration (other than by reference). The following code prints 1 2 3 4 in both PHP 5 and PHP 7: $array = [1, 2, 3 ,4]; foreach($array as $item) { $array[0] = 'hello!'; $array[1] = 'hello!'; $array[2] = 'hello!'; $array[3] = 'hello!'; echo $item, PHP_EOL; }
The article says: &gt;Keep in mind that not all your PHP extensions may support PHP 7 yet, sadly I can no longer use the excellent XCache opcode cacher that worked perfectly for me for so many years. You might want to mention that [PHP has a bundled OP Cache since 5.5](http://php.net/manual/en/book.opcache.php) and that it is further improved in PHP 7. For example [PHP 7's OP Cache brings a file backend](http://talks.php.net/froscon15#/php7pcache1) that will accelerate even CGI and CLI scripts and applications that couldn't fit in shared memory.
 Okay I mean there are so many sites out there. Not all sites are selling things. Many of them are only about information. I am wondering how those sites make money if they do not sell things. It has to be something about business model. Can you list some business models of them?
Okay. The security is about 1) SQL injection 2) DDoS [ Or this has nothing to do with DC] 3) password brute forcing cracking [ mostly about the defending efficiency ] 4) etc. if you add
I can't figure out what it's referring to, either, but I think the key is this: &gt; When used in the default by-value mode, foreach will now operate on a copy of the array being iterated rather than the array itself. This means that changes to the array made during iteration **will not affect the values that are iterated**. In other words, I *think* this might mean there are some cases where you can modify the array during the foreach and that would affect what happens to the loop variables? But I tried a bunch of cases of modifying the array during the loop to see if would affect what gets looped over, and it didn't seem to affect anything. I don't know, I wish they had given an example.
Which part is giving you trouble? Accessing other sites? Knowing which sites to connect to? Knowing what to do when you get there? There aren't tutorials for everything. An important skill to develop is knowing how to break a problem down and then to put the pieces together.
Well from the first day you learn programming, you know that comments are supposed to be comments, they are not supposed to affect code. A comment should be changed and removed without breaking your code. PHP's docblock comment style annotations break this very basic principle of programming, do I need anymore reasons? 
I'm having a hard time seeing the utility of JWT as opposed to traditional "state-based" authentication via a token. "Because then the server doesn't need to maintain state to authenticate a user" is not a sufficient argument. Here's why: Authentication is only part of a request authorization. In reality, you're always going to be hitting the database to validate the request and do additional authorization anyway. This is state. Data stored in a database is state. An authentication token stored in a database is also state. It's nothing special. There's nothing inherently more "unscalable" about the state of an authentication token vs the state of anything else in the database - state that will be accessed just as frequently as an auth token. So why is it that doing a token lookup in a database for authentication is considered a problem that JWT solves, but doing all sorts of other request and authorization lookups, not a problem? Thus, what do you *actually* solve by letting a token tell the server that you are authenticated, instead of just providing a unique token that you verify in a database? For that matter, how would you invalidate a JWT without doing a DB lookup *anyway*? If you ban a user or revoke a user's admin or moderation privileges, they won't get a new JWT until they log out and log back in again, meaning they retain elevated permissions until the token arbitrarily expires. But even when it *does* expire, you still need to query the database to get any claims to give to the JWT you send back to them. So either way, the JWT can only be safely invalidated by tracking it in the database. So if you're going to do that, why not skip all of the complexity (and potential security problems) of claims and hashes and just use unique tokens? 
http://fideloper.com/hexagonal-architecture
&gt; about maintaining an interface What do you mean? Interfaces usually not changing so frequently.
What do you consider to be a bot? To me, a bot would be a long-running script that sits and waits (or listens) for commands, then performs an action. This is almost the same as any website application, except the long-running part. For example, if you write an application on top of Symfony2, your app is simply sitting, waiting for a command (from the webserver). It then performs actions related to the command, ie the router decides what controller action to call which then runs code and spits out a result to your browser. Take an IRC bot written in PHP (https://www.phergie.org/). This is a long-running script that maintains an open connection to IRC and sits and listens in on channels for commands like `!twitter {username}` or `!beer`, then it performs actions related to the commands it picks up. So when you say &gt; having it access websites and login What you're really saying is you want a long-running script that can use curl to POST information to an endpoint and create a session.
That's using a reference, that's a different deal and will work.
Not very clear, is it? I looked for the RFC and found the case they're referring to: $a = array(1,2,3); $b = &amp;$a; foreach($a as $v) { echo "$v\n"; unset($a[1]); } Different output between 5 and 7. 5: 1 3 7: 1 2 3 This is a weird edge case and I have only encountered it once in my career.
&gt; As far as I know that's always been the behavior. Am I missing something? Foreach had some edge cases where modifying *your* copy of the array (such as deleting items) could affect *enumeration* of the remaining items. Those edge cases have been rectified in PHP7, so foreach is now consistent in all situations. This could indeed affect some (badly written) code, but breaks like this are part of progress and making PHP a better language.
That. Thanks! As I mentioned somewhere else, I will just separate the slug stuff from the company and give it its own repository.
Which sites specifically aren't selling things that I listed?
You have written about passing slug every time. I assumed that you mean passing it in constructor. Because I don't know when would you like to pass it again and again? 
I'm getting the distinct impression that the sheer numbers of regressions caught them off guard, and they're not taking any chances. I suspect that if they need to delay again, they will.
 &gt; TL;DR: Make your classes always final, if they implement an interface, and no other public methods are defined [S**O**LID](https://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29)
I think that the TL;DR; should be: Make your classes always final, if they implement an interface, no other public methods are defined and these classes are a collection of functions. The sample of bad inheritance is really bad architecture but what do you think about: class Db { /* ... */ } class Core { /* ... */ } class User { /* ... */ } class Admin extends User { /* ... */ } class Bot extends Admin { /* ... */ } class BotTypeA extends Bot { /* ... */ } class BotTypeB extends Bot { /* ... */ } class BotTypeAPlus extends BotTypeA { /* ... */ } Then we need to inject to the constructor the SpecialThings that we need always. __construct(Db $db, Core, $core) 
It can be daunting at first but once you get your head around it, it can be a very powerful ecommerce system 
&gt; Extending a class breaks encapsulation, and can lead to unforeseen consequences and/or BC breaks: think twice before using the extends keyword, or better, make your classes final and avoid others from having to think about it. How can it break encapsulation if everything is `private` in the parent class (or rather, nothing is `protected`)? I think I'm missing something obvious :/
That's not a very good reason, and I doubt even a truthful one. I can't think of a single time I've been troubled by not being able to delete comments. The only issue you may have is with a parser stripping comments before the annotations are compiled, but this has obviously been solved. If I had to argue against them it would be because of coupling. But a little coupling as a trade off for productivity is OK with me. At any rate, you can do what you want, you don't need any reasons other than you want to.
Yes I agree with you there were teachers and others to help me out but in my experience is that person learns a lot when he is on his own. ;)
Once you've created your interface and implemented it, you will likely never need to change it unless: - The framework/library you used to implement the interface changes its method signatures or functionality (eg. you bump its major version) - You decide you want to change to a different implementation for some other reason And in both of these cases you'd be glad you've got the interface there and only 1 reference to the old implementation to change Edit: bullet formatting
You studied programming at university and still call it "Java Script"? Wishing you had paid attention in class now, aren't you?
Thnx
`DateTimeImmutable` is supposed to be the immutable version of the `DateTime` object since PHP5.5. Both objects even share the same interface for getter methods. I'm wondering why the constants that are attached to the `DateTime` class where not also attached to the `DateTimeImmutable` class or moved from the `DateTime` class to the `DateTimeInterface` interface so that we could write something like $date = (new DateTimeImmutable('-1 WEEK 3 DAYS'))-&gt;format(DateTimeImmutable::ATOM); instead of $date = (new DateTimeImmutable('-1 WEEK 3 DAYS'))-&gt;format(DateTime::ATOM); which seems odd.
I was looking for something like this a while ago. I found few and it took me some time. Can't give you any opinion though. http://www.opendocman.com http://www.logicaldoc.com http://www.openkm.com http://www.kimios.com http://kordil.net 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [Strange DateTime behaviour in PHP](https://np.reddit.com/r/lolphp/comments/3ta3ql/strange_datetime_behaviour_in_php/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
maybe your OSX or java is not compatible with PHPStrom 10. Try another version of the IDE. Maybe #9. Or try to update Java. P.S. Your OSX version is pretty old actually. 
&gt; And from what I’ve seen so far, trying out every release candidate as it was released, it is definitely safe to start using PHP 7 as soon as it is out. I never had an unexpected behavior, a random segmentation fault, or anything that was not my fault. This is not good advice. If you're lucky there will be no issues. But there have been several severe bugs fixed in different RCs, and any minor or major version upgrade is a risk. /u/dracony was lucky because they didn't have a configuration affected by the bugs. Test, test, test. Deploy 7 only if it absolutely works and there's no anomalous behaviour when running it for a while. People have had horror stories when upgrading between minors in the 5.x series, let alone a major version jump. That's not to say you're guaranteed to run into stability issues. Most users probably will be fine. But be cautious.
Did you install the Java JDK yourself ? Try the PHPStorm install package without bundled JDK: http://download.jetbrains.com/webide/PhpStorm-10.0.1.dmg
If you're willing to pay $40/month why do you want shared hosting?! Get a Linode or Digital Ocean VPS, they are easy to set up. Patching is as simple as logging in and running `apt-get upgrade`. If you really do want managed, try a VPS from Media Temple: https://mediatemple.net/webhosting/vps/
more specifically final breaks the open/closed principle...
thats what i thought also, but then an interesting reply, and--deleted. 
It really shouldn't matter what webserver you're using if you use PHP-FPM. Just get PHP-FPM running and set up Nginx to proxy the requests to PHP-FPM just like all the tutorials tell you to do. The version of PHP doesn't change the setup for the webserver. 
I agree with u/ebonwumon Out of context, this doesn't seem as bad as you're making it out to be.
I raise you sir with, https://gist.github.com/geggleto/dd076d71f3c01875d92e
I may not speak for everyone, but I immediately back-peddle when I visit a random repo with no documentation on the structure of the app or its purpose
I'm gonna go with 'never'. Mostly because the "average" developer isn't a good enough designer to get it right the first time and I will likely require the ability to override his mistakes. Occasionally that isn't true and so I might go with 'final' if a solid attempt at providing customizing delegates (like in Cocoa) is provided. But very few developers I know work with that much foresight.
&gt; with no documentation on the structure of the app or its purpose There is no need for documentation, directory structure already exposes all needed information (Domain layer, Application layer, UI layer, Infrastructure layer)
Wow, the best example of symfony app that I've seen on the github. Greate job!
Is this getting rid of the community edition?
I'm sure I could find some other worse stuff... the codebase was written for php 4 and then hacked to work with 5.3.3. I can't move it past 5.3 :/
Yeah, "scalar objects" would definitely be nice. As for the `array` acting like `\Traversable` (or, implementing it), do you think there would be a BC break regarding this or would this be possible without any BC breaks?
Am I the only one who can't scroll on that site?
Yeah WordPress core is an entirely different story than the 5,000 crappy plugins out there...
Test it! Collect a sample of of your API responses, compress them at various levels, collect the time spend &amp; compression achieved. Also, don't forget about gzip_min_length. The default (20) is way too small.
Don't try to guess ahead of time what interfaces/methods you're going to need - just build interfaces/abstractions as you need them.
Not really: use composition to extend the features of a component.
Is there a way to see the source without signing up? (community edition)
The java comments are all good places to look into, but you may want to run File &gt; Invalidate Caches and Restart, just to see if there's some corrupt cache file.
Is "infrastructure" the new fancy term for "library"? What purpose does it serve to put all your shared components in one namespace and call it something? There are dozens of layers that make the simplest Hello World app possible on any platform today, so how you see your app in terms of "N layers" is more a matter of perspective, rather than an absolute fact of architecture.
&gt; There is no need for documentation, directory structure already exposes all needed information (Domain layer, Application layer, UI layer, Infrastructure layer) And so what's the insight here? "Don't have 3 directories full of stuff. Have 4 directories full of stuff." 
Well if it's for a small project it seems that this script should do the job, but is there a specific reason you wrote it in PHP? I mean why all those `system` commands when you can just create a bash script with them? Also, I don't understand why you put everything in a function and then call that function instead of just putting the commands directly in the file. Lastly, you should be aware that running a `chown` command needs root privileges and I don't think running a deployment script as root is a very good idea.
It's not enough to define a name. It's important to say *why* you define it. You use "infrastructure" in PHP the moment you launch the script. The distinction is meaningless, unless you can put meaning into it through treating "infrastructure" code different than "non-infrastructure" code, in which case, I'm willing to hear it.
This quote from the post is way too anecdotal and should be dropped. To say "it is definitely safe to start using PHP 7 as soon as it is out" based on individual testing on a personal server stack is absurd. There are no doubt an endless variety of hardware and system configurations that will be running PHP 7. It is shocking that anyone would upgrade mission critical servers to PHP 7 on a whim at this point.
~~I'd just avoid this repo entirely. The author already blatantly expressed that "you don't need documentation, you just know!" like something a particular Asian father wondering why you didn't get an A+ would say.~~ ~~Just because YOU understand YOUR code, doesn't mean the rest of us are going to take the hours to crawl through it to gain the same understanding that you have. This is what documentation is for. To bridge that gap.~~ ~~Not trying to bash the guy, because let's be honest, writing documentation sucks. But you don't just jump off the spectrum by saying "you don't need documentation." You always NEED documentation. Because I guaran-fucking-tee unless you're working on this project daily, you'll come back a year later and ask yourself who the fuck wrote this.~~ ~~And on top of that, if you're wanting to share it with the community, documentation becomes a lot more important than if you were just writing it for personal use.~~ Mistook the guy defending the lack of documentation as an author. Honest mistake.
I'd recommend [Adminer](https://www.adminer.org/) as PhpMyAdmin alternative: It's fast, no installation required (single file) and covers all the common tasks. The extensions are neat too. Otherwise, just try running `mysql -u username -p localhost` in a shell. It will ask for the password and connect to localhost. Now you can run commands interactively: `use dbname; CREATE USER .. ;`
I tried Adminer but am unsure of the Mysql database name, tried 'root' and 'mysql' so far and it returns 'No connection could be made because the target machine actively refused it.' Is there a way to see what databases are setup so far? Guessing I should look up mysql commands instead of asking you&gt;&lt; Edit: I think I got it, thanks amigo!
Well I didn't even have it installed and didn't quite grasp that phpmyadmin is actually just a web frontend for Mysql commands. I'm starting to understand a little more now though. 
Eh, they wanted someone to read their very short and almost pointless list so they gave it a clickbait title.
Phpstorm expensive
One of the few times I feel good spending money. 
Guys! Four layer architecture! Fuck off.
No. /u/shittywebdesign
How are you handling clean up of old releases? We have a similar deployment process. We have a small application that has endpoints for each application that are triggered from CI builds. We are only keep one previous release right now.
Off topic.
Unfortunately, I'm not very familiar with Windows so I can't help if you have problems with your SSH client (I guess you are using Putty). But I highly recommend try solving that issue as soon as possible, just using a password instead of a private/public key pair is not very safe. About Plesk, unfortunately I'm also not familiar with it as I administer all my servers directly through SSH. So if you have issues with it, I can't help you with that either. If you have though root SSH access to your server I can help you. What I suggest is to use a bare git repository with a post receive hook to deploy. Basically, you use a script similar to what you already wrote which is executed after git receives that code and that script does the deployment. By doing it this way you will be able to deploy by running a simple `git push prod master` command. But to been able to do that you need first o fix the private/public key authentication issue you have with your client, otherwise every time you do a deploy git is going to ask for your password.
Only if you value your time at zero.
If you want to keep old releases for some time but want to get them removed automatically, you can also do this with a simple cronjob. For example if you need to keep the last 10 releases you can create a cronjob that deletes all the old ones and keep only the 10 latest.
Ouch, this doesn't https://github.com/magento/magento2/blob/077584c99ebb8007cad176c3b9a0144a05c259cd/app/code/Magento/User/Helper/Data.php#L52 look good combined with https://github.com/magento/magento2/blob/develop/lib/internal/Magento/Framework/Math/Random.php#L73 Maybe I'm missing something, but such randomness handling looks to beg for big trouble.
Sounds interesting, I'll have a look at this tomorrow! So am I right that `git push prod master` would auto-update my server?
Yes that's right, by running `git push prod master` you will push to the bare repository on your production server and after git receives the push it will automatically run the `post-receive` script inside the `hooks` directory (if it exists of course) which will handle the deployment.
Actually, now that I think a little better of it there is no need for a cronjob, you can simply add this in your deploy script. But on the other hand if you add it as a cronjob this can also work as a failsafe mechanism. For example, if that cronjob only runs once a week and you made a mistake deploying, the old releases won't get deleted the exact moment you deploy so you have some more time to act.
Well, I always have the old releases on Github, so there is like no way to lose them completely :) I updated my Gist, it now deletes all releases except the current and the last one.
Pretty irrelevant given that PHPStorm is an IDE, Visual Studio Code is just a code editor.
Hi, this is very interesting because I love Visual Studio. Do you know if it is possible to make x-debug work with it? I currently use Netbeans with x-debug and it works very well. Thanks!
thanks - I do a lot of blogging on shorter subjects at http://codebyjeff.com/blog. I thought this felt better as a single "package" folks could grab and read/reference as they wanted. Plus I got to learn a little about publishing an eBook, which I was curious about
The comments do not load because of HTTPS, switching to HTTP may also solve the scrolling? (I can scroll fine in both cases so I can't test for you).
Like correct spelling when you are a programmer... 
Make sure that the userid associated with the session exists in the database.
&gt; How can it break encapsulation if everything is private in the parent class (or rather, nothing is protected)? I think I'm missing something obvious :/ Well if everything is private, yes. But this means nothing is protected... and nothing is **public**. You missed that. :-)
Here's some food for thought. I have defined a `Stack` with the following methods and implemented in the usual way: * `push($value)` * `pop()` I did not make `Stack` final. Let's say I extend `Stack` and modify `push` to push to the bottom instead of the top (which turns it into a `Queue`). This `Queue` will be accepted anywhere `Stack` is but *will break the `Stack`'s semantics* in every case where the `Stack` was previously used. In other words this breaks the Liskov Substitution Principle (the L in SOLID). There is nothing wrong with the behavior of a `Stack` or the behavior with a `Queue`; what's wrong is the relationship I picked. A `Queue` is not a `Stack`. Now, you may be saying "Yeah, but that's a Stack. Nobody would ever do something so stupid with other code." Well… when people do this (direct citing from the article)… class Db { /* ... */ } class Core extends Db { /* ... */ } class User extends Core { /* ... */ } class Admin extends User { /* ... */ } class Bot extends Admin { /* ... */ } class BotThatDoesSpecialThings extends Bot { /* ... */ } class PatchedBot extends BotThatDoesSpecialThings { /* ... */ } …they are essentially doing the same thing. We can prevent this madness with `final`. It is my experience as well that `final` *should* be the default. Classes need to be *designed* to be extended.
I did!
 1. Check the session variable when the request is made. 2. Figure out which user that session corresponds to. 3. Check your user database, text file, or whatever to see if the current user exists. 4. If they don't exist, then unset the session, and maybe redirect to the login page. 5. If they do exist, then don't do anything because that user still exists and wants to use your website.
Kudoz 4lyfe breh 🕶 . What am I saying.
Way cheaper for me but then I also use pycharm and a bunch of their other stuff, 20 quid a month is batshit value for money considering I spend more on that in the local coffee shack.
"Kudos for life, bro!"
It was rhetorical, but yes. I think the dankest of memes that do infest Reddit affect my thought processes.
Backend web dev here, FWIW would make the blog in plaintext if it wasn't that not only robots read it (huge fan of http://motherfuckingwebsite.com/ ) https://github.com/Ocramius/ocramius.github.com/issues please :-) I mostly tested in firefox, chrome, firefox (android) and chrome (android). [EDIT] Oh, wow, Safari is indeed behaving weirdly :D No idea why btw, so if anyone has ideas just shoot me a hint (not going to fix it unless it becomes a relevant audience)
What else could be used on my case apart from CBP? I would like to hear.
VS Code isn't very much like VS. But it's good in its own right.
The OCP is not about inheritance, and actually, we are "closing for modification" the parent here, reducing bugs caused by extension, while allowing modification depending on input/output. That's the point of the OCP: an old system works even when a new system is introduced, and adding components to a new system won't cause new bugs in the old system (due to inheritance and protected access). You built it, now it must remain stable and closed from others fiddling with its internals. Much like with a mechanical clock, you may let someone read the clock dial, but not with the internal gears (operation which may cause a change in how time is measured, even just by adding some unintentional friction somewhere). 
If the TL;DR; isn't clear enough, send a PR to https://github.com/Ocramius/ocramius.github.com - maybe my wording wasn't clear enough :-)
It's not rare to have an internal coding standard, nor is it rare for that internal coding standard to be something externally defined. Before the modern era, many places followed the PEAR coding standard, as an example. PSR-1 is very simple and straightforward, and I'd imagine that most modern code ends up following it by accident. PSR-2, though, is divisive, because it forces conventions that are not universally accepted, like curly brace placement. At work, it happens that our internal coding standard is very similar to PSR-2, only with additional rules for alignment of SQL strings, and with the curlies in the right places. Other deviations include rules for naming of globals and constants, and we do this thing where comments get to live on the previous indent level. These rules are enforced during the mandatory code review that all commits go through. So, no, you should not be surprised *at all* by coding standards existing in workplaces, and the fact that this is mentioned up front is *probably* a sign that they take code quality seriously. This is a good thing.
To be fair, I don't believe our recent job listing for a developer mentioned PSR-2 coding standards, despite the fact we try to be fairly strict in enforcing it.
That's like wondering wether correct spelling and grammar are mandatory. Modern software can enforce that, and no, it isn't explicitly said in job listings, but by all means, do consider them mandatory.
You're right - the core problem is not one of AR, but it tends to exacerbate the need to do stuff like null object. The nested relations you call out are insanely easy to create with AR, and eventually become incredibly hard to manage and maintain. If you absolutely need atomicity, database transactions are your only practical option. But by designing your application in certain ways, you can often reduce if not eliminate the need for it. While I don't know your app, I'd generally assume that a hard dependency on tracker data for anything other than an analytics tool is a design problem. &gt; So I wonder, what if you used a class if it is designed to throw exceptions during the 10 second countdown to the new year? How would you know it and write tests early? Well, if it's *designed* to do that, it's fairly obvious that it's a scenario I should handle. But generally speaking, good-quality libraries and SDKs will indicate which methods can throw an exception, and what type of exception should be thrown. If use that code is in my critical path, I'll write tests for handling the positive and negative cases. If its not super important, I'll make the call if it's worth the time trade-off. Anything that uses the network can fail, so it's a pretty good bet that it will throw an exception on network failure even if it's not explicitly documented. Worst case, use `grep` on the library for `throw` As a concrete example, I used to work on financial software, where bank holidays always add fun into the mix. The tests started off with a dataprovider of known bank holidays (literally grabbed from the federal reserve bank holiday calendar) for the next few years, and simulated running on those days to ensure it behaved as expected. Back to your case - looking at the source code and analyzing the logic a bit may have made it clear that only half the code running could cause a fatal error down the line. Or maybe it would't have been clear at all; it really depends how much knowledge and context the person reviewing it has.
Sorry for the late reply, It just used the database to keep track of when the templates were lasted edited and what padding was used to determine if they need re-compiled.
Flarum is a good one
It's a bit weird but PHP allows `;` instead of `:`. It's just how it is.
It's rare to see someone who doesn't use anything close to PSR-1 and 2 for me. I used PSR-1 and 2 before they existed, because, they were *designed* to match the existing styling preferences of most developers and align them even better. There are around 5-10% of the rules I have different (tabs vs spaces etc.) but it's still much easier to write in our internal styling guide "we use PSR formatting, except for..." than describe everything.
You know, my formatting style is 95% matching the PSR-s, and even I'm put off by the use of "mandatory" here. Things have to be mandated if you don't trust the other party to understand, and the other party doesn't care to think.
such a useful comment. thanks!
The codebase for Laravel.io can be found at https://github.com/laravelio/laravel.io. I learned heaps from looking at it. An invaluable resource for learning Laravel devs.
Pretty cool content for getting into drupal, easy to understand, good speaker. Not that I'll use drupal for anything in the near future, pretty good content nevertheless.
Is this a joke or is it a feature of some ide? I have not ran into that command before.
 -&gt; show databases; The leading `-&gt;` tells me that you entered the command over multiple lines. Just try again.
In PhpStorm it's *Code | Reformat Code*. It applies the code format you've defined in your project settings.
 $shouldRecompile = filemtime("compiled/[..].cache") &lt; filemtime("templates/[..].html.php"); no?
Concrete5 has nothing to do with Laravel from what I can see. It's about 6 years older than Laravel too.
Thank you for your answer
concrete5 isn't a good example for a laravel project, it only uses some laravel components!
I've been working on this in my free time, you can check it out: https://github.com/angelov/eestec-platform
Hopefully possible without.
Could you explain why this doesn't look good? I'm not an expert on this subject and would like to know more about it.
just add a code style sniffer in your continuous integration pipeline and let that enforce whatever style you want. it's just an internal detail, it doesn't matter if it's mentioned in job listings or not, it's just good habit.
Yep, but I wouldn't say they're using Laravel *"the framework"*. They're using a mix and match of Laravel, Symfony2 and Zend components (and many others). But that makes it even more interesting to look at.
Not to mention that in practice, your function will probably end up using some build-in array functions that work on a copy anyway - which due to the way the zval structure handles refcounting, copies and references, means that your clever "optimisation" (which would never have sped anything up anyway) will actually force a memcpy and slow things down. Plus being a terrible idea from a semantic standpoint as /u/WishCow pointed out. Not only because the function signature lies, but because an innocent modification to the function can inadvertently change values in the caller's scope. I hate this pattern so much.
There's only ~31 bits of "good entropy" in the process. This 31 bit number is combined with microtime and uniqid and hashed with MD5. While microtime and uniqid makes the attacker's work a bit more complex, this construction is not safe overall. There's some good material about attacking randomness: https://phpsecurity.readthedocs.org/en/latest/Insufficient-Entropy-For-Random-Values.html The user whose account is being attacked _may_ stay safe if the attacker can't execute the attack fast enough (the token expires), but in general, I'd not consider ~31+ bits of randomness enough in this kind of situations.
Who are you? You sure sound pretty crazy. Surely online bullying and cowardly slander is something we can all stand against. If you have some crazy accusation about me, say it with your real name attached, you coward(s). 
I wrote something similar for ZF2 btw: https://github.com/BinaryKitten/ZeffMu No, I'm not hijacking the topic, it's just that this "in between" is actually about being able to use the micro-framework semantics (expressiveness in a single file, most of the times) together with the features of a full-stack framework. As /u/javiereguiluz points out, the main strength point is that this approach allows you to enable existing bundles/modules/plugins/extensions, which would otherwise only be available in a full-stack setup.
Me with PHPStorm 10.0.2... on El Capitan 10.11.1
Very nice! I imagine this might also make it easier for people new to the framework to learn things gradually, instead of the more usual "everything at once" way.
Yes, I think it is kind of simplified version of Symfony with very basic component to get it works, and quite different from Silex
Well, at least I don't insult strangers. Look at your comment.
There are many processes in PHP which aren't dependent upon just your processing speed, like network requests. Your system can handle hundreds of them at the same time, but synchronous PHP can only do one at a time. If you have an asynchronous function to do so (like multi-curl), then you can increase the number of requests drastically.
PHP'd
even if this is true its bad programming. It says nothing about what is being changed. Are you sorting, or changing the structure? Adding or unsetting? You never know and thus it is bad.
1150+ failed tests on travis
My company doesn't officially use PSR-2, but our app development team is 2 people (including myself), and I do 80-90% of the coding, so we've "unofficially" adopted PSR-2.
Does symfony 3 will be LTS? I don't understand how those use the version numbers. Ah And why just don't use Slim instead to this ?
No, 2.7 and 2.8 will be LTS, 3.3 wil be the next LTS. [Source](http://symfony.com/doc/current/contributing/community/releases.html#schedule) The advantage over something like Slim is you get to leverage the Symfony ecosystem. The advantage over something like Silex is it's probably easier to switch to the full-stack framework if/when necessary (not entirely sure about this, though).
If you are doing everything synchronously you are doing it wrong. Eg: sending emails, processing images, etc.
Starred. ;)
It means that each statement has to finish before the next statement executes, and when the last statement in the page executes the page is returned to the client. For example, getting the contents of a file: &lt;?php $homepage = file_get_contents('index.html'); echo $homepage; ?&gt; Pretty easy to follow, first the contents of the file are read into a variable, then rendered to the client. Compare an asynchronous implementation in node.js: server.get('/', function(req, res) { fs.readFile('index.html', function(err, page) { res.writeHead(200, {'Content-Type': 'text/html'}); res.write(page); res.end(); }); }); server.get will return immediately, if we were using the PHP execution model the page would render immediately. But what happens here is that the anonymous function(req, res){} gets called whenever a request comes in. Similarly fs.readFile returns immediately, but it doesn't return the contents of the file. Instead, it calls the function(err,page){} anonymous function when file has been read, putting the file contents into the "page" variable. Only when res.end() is called is the response returned to the client. Likewise, in PHP you can call sleep(5) to sleep for 5 seconds. That blocks the entire PHP process for 5 seconds, other processes will continue to serve clients. But if you were to call sleep in node.js (I believe there is a module to provide this functionality), it would block all requests currently in progress, and no other callbacks would be fired until the sleep finishes. That's why you typically use setInterval/setTimeout instead of sleep.
So, like [Aura v2](https://github.com/auraphp/Aura.Web_Project), then.
&gt; All the incredible Symfony features and bundles are ready to use in case you need them as your application grows.
Where I work there is no debate. You use PSR2. But we walk a very reasonable line with it. You have to use it but you don't have to follow it 100%. Another example is WordPress. Technically, we are supposed to use the WordPress coding standards but if you follow PSR2 nobody will really care. When we get our code reviews some things are mentioned if they see it over and over again but most one-offs or personal preference will win as long as it's consistent. The developer has an incentive as well. We are a cross-discipline shop that does client work. Nobody ever wants to be the developer that leaves a mess for somebody so most people try and follow. It's not about what standard you use just as long as you use it.
&gt; the tech lead preferred tabs The **former** tech lead.
This is a great explanation. I stumbled a bit on the [first graphic](http://beta.docs.hhvm.com/images/async/async-dependency.png) -- I think it should be flipped vertically, with the "render page" on the bottom, instead of the top, and the arrows going the other way. Reading it from top-to-bottom (as-is) was a bit confusing.
And if they don't use an interface - you're fucked. You can't sub your class for the original one - plus the difficulty of getting your class constructed if you don't have access to the point where 'new' is called.
Yeah, that could be because you are used to PHP way of thinking. Now, think about someone like me who has used `python` before (btw, `python` don't use dollars and nor do most other web scripting languages)? I'm not used to see "dollars" behind each variable. For me, it just adds one more character to type It also makes you app clunky: If you have a thousand variables in your app, that means thousand extra dollar signs: - `1024000` ~~bytes~~ bits of space entirely wasted!
the php source is definitely an interesting read... i am quite amazed it works lol.
There's no reason to be in doubt. They have [a pretty clear list](http://symfony.com/doc/current/contributing/community/releases.html) (with nice drawings and all) showing development, release and support end dates (months, at least) of a bunch of the coming versions. If you want to know about a specific version, all you need is to input the number and press the button [here](http://symfony.com/roadmap) :-)
 $x-3; $y = 3; $x-$y In both of those cases you've not assigned the expressions anywhere. The following would work: $x = $x - 3; $y = 3; $x = $x - $y; /* or even */ $x -= 3; //shorthand for $x = $x - 3; The reason `$x--` worked is that pre and post increment operators directly modify the variable when called (with pre doing it before the variable is used and post doing it after)
The resulting microframework really is nothing like Symfony2 itself. You can sort of get a feel of the components, but the gist of working with symfony is knowing all the configurations which this approach avoids entirly
I don't know your code base or how you do your routing....so it's really hard to answer your questions with specific answers. &gt; what if the name of the company changes? I don't want all my links to be broken. The first question to ask is a business/domain one - what is going to be the 'thing' that is persistent in the future that ties links generated now, to company entity in the future? If it's a company's name, then you'll need to have something like a 'HistoricNamesForCompany' entity that allows you to map from links generated with the current company name, to the new company names. That sounds like a separate thing to the Company entity. If each company is going to have a single ID number that doesn't change in the future, then that sounds like it could be part of the Company entity. With either of those things you'd need to write the appropriate code in your routing layer to handle them. &gt; what if I want to be able to change the behavior of CompanySlugGenerator in the future? Generating a different set of links is easy....just extract an interface like `SlugGenerator`, and make both `CompanySlugGenerator` and `NewAndImprovedCompanySlugGenerator` implement it, and use the appropriate class to generate links. In the Auryn DIC, this is really easy to control by creating a delegate function. function createSlugGenerator(Foo $foo) { if ($foo-&gt;someCondition()) { return new CompanySlugGenerator(); } else { return NewAndImprovedCompanySlugGenerator(); } } $injector-&gt;delegate('SlugGenerator', 'createSlugGenerator'); i.e. when an object asks for a `SlugGenerator` object, the createSlugGenerator function will be called, and you can put arbitrary logic in there. The delegate functions also have their dependencies injected....so you really can put anything in there. For example, you could decide by date, or whether a user was logged in and belonged to a particular company....literally anything.
&gt; PDI: An Autoloading PHP Dependency Injection Container package The PDI package is more of a service provider... class Car extends \PDI { } Please stop. If your code even knows about what DIC is being used, you have done something that isn't pure DI. If you have to extend a farjing 'Container' to use it, you have done something bad and should feel bad. PHP already has many adequate DIC's please use any of them. I personally recommend [Auryn](https://github.com/rdlowrey/auryn) as it has a few powerful features that the other ones don't have. (I realise that just telling people to stop is not a nice thing to do.....but to be using code like the above, when there are so much better alternatives out there is not a productive use of anyone's time, including the author of this article. 
You might want to switch to a for loop, it is specifically made for cases like this. for($x = 100; $x &gt; 0; $x -= 3) { echo $x . "&lt;br /&gt;"; } The "." in the echo statement is the string concatenation parameter in PHP. It basically tells the server to put output the variable and the result.
I use Gearman or Beanstalkd to do background processing and after setting it up, it works like a breeze. I too feel that it doesn't make sense to send an email o make heavy computation tasks in foreground. Page load latency is for sure one of the things to consider, but also, you make you application more resilient to internal/external failures. The bonus of executing these tasks in background is the ability to catch errors and retry the background job later. This approach makes a lot of sense in certain situations, like when you need to run a task that works with a third party service/API that you don't control. I had great success with this method in a few occasions where the application was querying an unreliable api, and it all worked like a charm.
So, you don't think that it can be learned gradually? 
Because `$x++`, `++$x` (and the minus-versions) are special shortcuts inherited from older programming languages. To oversimplify, `$x++;` is the same as `$x = $x+1;`, it both calculates a new value, and also stores the value back into the same variable. By comparison, `$x+1` simply calculates a number which is bigger by one, and doesn't (alone) do anything with it.
Almost every application uses I/O because of database queries and maybe some RPCs. You'll gain most when you're using something like [Aerys](https://github.com/amphp/aerys), but that's mostly due to removed bootstrapping costs. But those solutions require all I/O to be async to work properly and performant. The HYPE exists, because libraries supporting async I/O can always be used in synchronous contexts, but not the other way round.
 class DBManager extends \PDI { public function __construct() { } public function contains_error( $param ) { return (count($param) &lt; 1) ? false: true; } public function query( $queryString ) { $result = retrieve( $queryString ); if (contains_error( $result )) { $this-&gt;ExceptionManager::exceptionID = 1; $this-&gt;DateTime-&gt;log(time()); } } } Seriously, this is literally not even dependency injection. At all. Mods, can we maybe ban links to phpclasses.org? 
Er, yeah. Typed it out rather fast, so glad that's the only mistake :P
The code coverage seems way low... it doesn't matter how many tests you have tbh.
&gt; I was wondering what a normal amount of tests for a PHP application is. As many that are necessary is probably the best answer, here.
0, yes i am ashamed
&gt; I'd say that sounds fairly typical. When you measure code coverage, though, what exactly does that metric mean? We use cloverphp but it's not configured correctly (because nobody's cared enough to fix it :P) so controller classes are included in the missing coverage, even though most of our controller logic will never have phpunit coverage for obvious reasons. Why would you exclude the controller from your unit tests?
PHP_EOL != "&lt;br /&gt;" br formats HTML output, while PHP_EOL is just for the text output. Also, please don't concatenate without spaces. Ugly.
Probably because if you have a lot of unit tests for your controllers, it means you've managed to get business logic there that really should live in the model. :) Edit: This might be a slightly controversial statement.
It's hard to take anything on there seriously! 
Deploying with our fingers crossed and in our ears, are we? :) edit: my counter is also 0
&gt; PHP_EOL != "&lt;br /&gt;" PHP_EOL is entirely platform independent and let's PHP decide which EOL method is best to use. Obviously this would be the correct choice for convention's sake. &gt; Also, please don't concatenate without spaces. Ugly. Entirely a preference. I believe it's ugly _without_ and ideally would have written this as: for($x=100;$x&gt;0;$x-=3){ echo $x.PHP_EOL; } There's absolutely no real reason for those spaces. Any common IDE could unfurl if you found it difficult to read, too--so arguing the merit of white space here is pretty weird... Additionally, I stand by my statement. `PHP_EOL` is even defined by php.net as the correct EOL symbol for PHP: &gt; PHP\_EOL (string) The __correct__ 'End Of Line' symbol for this platform. Available since PHP 5.0.2
That growth curve on Javascript, though. Lies, Damn Lies, and Bad Metrics.
Since the other comments have already suggested why this is not a good idea I figured I would ask a question to you instead: where did you get the idea that this would be more efficient? Is it your background in some other language such as C? Was it some phrasing in the manual or tutorial online? Basically I'd like to know the source of the confusion.
I am with you friend. Lets stand up to these spacers.
constants come in 2 forms... define() and the use of the const keyword in classes.
&gt; There's nothing inherently more "unscalable" about the state of an authentication token vs the state of anything else in the database - state that will be accessed just as frequently as an auth token. Well, there's higher contention for tokens, because every read, every write, everything you do across your entire system needs auth, so it'll be fetching tokens from one central place, which is the first part of a system under load that will start glowing in orange under load. While if you have 10 services for 10 different entities, they're only reading from their local storage, they don't depend on a central storage that everyone else is also accessing. JWT is not the only way to solve the problem, but it's one valid approach. Another is to bind a user to a specific server which holds the session state. Yet another is for every service to have a local proxy for the identity service, which may be reading from another proxy etc. until it goes to the identity service, so most token read requests will, in fact, be served from proxies. All those stateful decisions require more work, managing proxies, binding users through cookies (and you risk one server suddenly becoming a hotspot and you can't rebalance, because users are bound to it). This is why stateless solutions are so much fun. You solve the problem of managing state by not having it. Not many complex systems are 100% stateless, sure, but the less you have of it, the easier it becomes.
These results are easily replicable inversely, too: λ php -f test.php 100&lt;br /&gt;97&lt;br /&gt;94&lt;br /&gt;91&lt;br /&gt;88&lt;br /&gt;85&lt;br /&gt;[...] λ php -f test.php 100 97 94 91 88 85 [...] I mean, you're testing them in a web browser which processes HTML while PHP_EOL does not output HTML. So it's comparing apples to oranges, here... What about literally every other situation which doesn't involve a web browser? My position (and that of php.net) stands firm. `PHP_EOL` is still the best convention here.
OP: &gt; down to 1 (in the browser) Please, just stop.
&gt; You are very, very mistaken here if you think a PHP interpreter on any platform will have PHP_EOL="&lt;br \&gt;". Absolutely no idea where anyone is getting this from. Not only have none of my posts even remotely suggested this the only one to mention this has been Jake_Jeremy who incorrectly surmised that I somehow believed that. Most likely as a quick rib to insult my intelligence without anything to stand on. &gt; For the example that OP is giving, you have to explicitly use the markup If this were true, then my example would not work anywhere. Obviously that's incorrect. &gt; if you really, really want to use that constant, you'd have to wrap in nl2br (a function that by it's very existence proves you're wrong). If you reread OPs original post you'd see nothing about his script being displayed in a browser or otherwise. It's entirely prudent to assume that both may be used, even if not exclusively. Of which, your examples are just as correct or incorrect as mine as markup will be printed in a CLI and not formatted while mine will be formatted, inversely, in a browser mine will not be formatted and yours will.
I'd say that's "ideal", but certainly not "normal" ;)
I would hate finding that in somebody's source. People tend to mess up operator precedence in ternary operators.
You can. &lt;?php $a = 1; $b = null; $c = false; $d = 0; $e = 'e'; var_dump($a ?: $b); // int 1 var_dump($b ?: $c ?: $d); // int 0 var_dump($c ?: $d ?: $e); // string 'e' (length=1)
&gt;If you reread OPs original post you'd see nothing about his script being displayed in a browser or otherwise. From OPs original post (my emphasis added) &gt; So my question: &gt; My end result needs to look like this: &gt; 100 &gt; 97 &gt; 94 &gt; 91 &gt; down to 1 **(in the browser)** Also, all of his sample code was wrapped in markup. Your suggestion to use PHP_EOL is wrong in this situation. Are we done with this stupid argument yet? 
Actually, I was referring to your appeal to authority ("as someone whose standard is 95% similar to PSRs ...") and pointing out how the similarity of your standard to the PSRs is irrelevant, because standard compliance is binary. You either follow it or you don't, and if you don't, the extent to which you *almost* follow it is pretty meaningless. You seemed to be using it as if to say "because my standard is so close to PSRs, what I'm about to say should matter more..."
Welcome to the world of coding! Great to hear your programs are being requested. You can quite easily check for users IPs on login the problem here is that most users will not have a static IP and so their IP will change every now and again meaning they won't then be able to login. If you were solely in charge of accounts - no register option - this would mean that only those that you want to have access will have access though, or have I misunderstood what you're going for here?
Thank you Mate Managed to do it that way
I'd hate to maintain code that uses those kinds of constructs.
Definitely +1. I would never recommend that someone use that syntax, and probably should've clarified as much.
I used to love that syntax as well. After spending many years maintaining other people's code, I've come to the conclusion that, in the long run, clarity is better than brevity. I'd rather you type it out with proper comments and documentation, rather than make it tight and clever. What is blatantly obvious to you now, when your head it totally in the problem space, suddenly isn't a year later when someone else is trying to figure it out.
*Interesting* as in *hard to read*. :-)
&gt; Get it? *uh huh*
Unless the comment you're replying to is incorrect, PHP's shorthand ternary behaves correctly.
Oh fuck yes, I didn't know this was coming! I love the shorthand but hate repeating the variable just because I need to do an isset check.
More practical example: &lt;?php switch($_GET['action'] ?? 'home') { case 'home': outputHomepage(); break; case 'edit': // ... }
Neither me nor /u/evertrooftop were talking about the shorthand when mentioning precedence. I would have to agree with them though, I would not want to come across a code base with many expressions like that. This sort of thing is a code smell because of its high cyclomatic complexity.
I wish they'd fixed this for PHP7. I guess no one cared enough to write a patch.
Because he had a questionable colon?
&gt; This is one of the major reasons why nodeJS and Golang have gotten a lot of steam over the last few years. We have more and more threads on our servers and having language defaults that are synchronous and blocking in nature brings a negative view on a language. Not arguing anything you said, I just want to throw my 2¢ in in this topic. IMO, this is a non-issue. There is nothing negative about PHP only using one synchronous thread. The idea that asynchronous and multi-threaded is faster doesn't apply in most normal PHP applications. A webserver is multi-threaded by default since it will be serving up multiple requests at once and most available threads and cores are utilized (unless it's a very unpopular one). Yes, if you are looking at running a very heavy process in PHP it will help to use something like asynchronous workers (my opinion of the best approach for this). Going full blow multi-threaded is over the top and effort would be better spent writing the process in a fully compiled language instead. 
&gt; For me when I see a $ I can instantly know it is a variable. BUT THINK OF ALL THE TIME THAT WOULD BE SAVED BY NOT HAVING TO TYPE THAT EXTRA DOLLAR CHARACTER!!!111!!ONE! I SAVE TIME BY ONLY USING CAPITAL LETTERS! SEE! MY SENTENCES ARE PERFECTLY UNDERSTANDABLE AND CERTAINLY NOT HARD ON THE EYES AT ALL!!! /S 
What's the point of it? Are you just making it as an excercise, or are you trying to add something none of the other templating engines do?
I considered doing shallow checkouts, but I've been using this for dev and have been doing things like bisects to find bugs in libcurl. Also, this is not the _best_ application of Docker, it should ideally be two docker containers, one to run `nghttpd` and a second linked one to run the PHP script against it. You might find some useful info in my slides, [here](https://speakerdeck.com/dshafik/truenorth-php-2015-deploy-anything-control-everything-scale-effortlessly-deis) (about the first half anyway — though you may enjoy checking out Deis too).
Programs as in the software you're building for your fitness center, or programs as in fitness training programs? If it's the software, the best thing to do is make it software-as-a-service (SaaS), and your own company would be nothing more than a client of its own SaaS application. Then you can allow other fitness centers access to the same software and charge them however you see fit. This would be a multi-tenancy application that you have 100% control over, and therefor nobody could ever re-sell it. Examples of SaaS products: * https://www.firebase.com/ * https://basecamp.com/ * https://invisionapp.com * https://envoyer.io/ * https://forge.laravel.com/ And many, many, many more.
I find it more clear to be frank, I hate when it takes multiple lines to say something, it keeps less of the logic in my immediate vision. $image = $localCopy ?: $this-&gt;fetch(); or $refresh = $override :? $this-&gt;checkAge(); Perhaps its just the style I've gotten used to, but to me those seem very concise and all the relevant information is condensed and visible.
Of course showing multiple null coalesces to use values via heirarchy is the best way to show the power of the feature &lt;?php $value = ( $mostspecific ?? $secondmostspecific ?? $thirdmostspecific ?? $default ); ### The value You could now more tersely express without loops and checks cascading values in nested objects, making multi-faceted content, simpler **Usage:** to adjust pricing for example where size-specific price is possible using fallbacks for non-differential prices $price = $size-&gt;price ?? $colour-&gt;price ?? style-&gt;price; 
No, since if action isn't in the array it won't go through the switch at all. 
$b would equal true (the result of isset()), instead of the value contained in $array['three'].
That's not the issue. Writing a patch would be easy and AFAIR this has even been discussed on the internals list. The problem with making that change is that you would break a ton of existing code in a very subtle way if you changed operator precedence like that. That train unfortunately has left the station and we'll never see this fixed
Thnx, here good features are available only on paid versions
I prefer not having to memorize precedence tables that change from language to language but maybe that's just me.
I'ts useful, but why didn't they just go with short-circuiting? $x = $y || $z; edit: Removed something that already worked.
I'd rather use some OOP layer that insulates you from relying on super-global-state... and most of those already let you easily specify a default, e.g.: switch($request-&gt;param('action','home')){ ... }
I thought it was the only way to avoid making a copy of the array. Since arrays are pass by value. I didn't know they were also copy-on-write.
Yes it is easy and quite useful. You should first make the database for your fitness centre once you have done this than all things will be peace of cake. The first hurdle which occurs is when you are creating your database tables once you have done this everything will be easy.
The performance hit of a single page load doesn't matter, right. But it matters under high load, where you would have a lot of threads otherwise, each using quite some memory.
You create your own language in which you can declare your variable what ever style you want. You just have to write regex for your variable deceleration. And need to learn Compiler Construction for it :)
Exactly. The toothpaste simply cannot go back into the tube on this one.
but this is not consistent at all. it should then go as $this-&gt;$someVariable instead of $this-&gt;someVariable, while first one has a whole different meaning.
"The conclusion is that it doesn’t matter which server you are going to chose."
Are you seeing the graphs in the article ? http://systemsarchitect.net/wp-content/uploads/2013/03/chart_4-300x185.png &lt;- broken https://systemsarchitectdotnet.files.wordpress.com/2013/03/chart_2.png &lt;- 200 OK
A well made controller is a simple adapter between view (template) and model (service layer). It's a few lines of boring glue code that doesn't affect the business logic or domain integrity in any way. It gets covered when you test the UI, which for us is a combination of Selenium tests and manual QA work.
That did the trick! Thank you! Forgot how much I love phpstorm when working with drupal :) 
&gt; which due to the way the zval structure handles refcounting, copies and references, means that your clever "optimisation" (which would never have sped anything up anyway) will actually force a memcpy and slow things down. This is true in PHP 5.x, but has been fixed in PHP 7.x.
What you're looking for is how to write a simple TCP socket server. Have a look [here](http://php.net/manual/en/sockets.examples.php). I know that you're not planning to write a full webserver here, but keep in mind that PHP is single-threaded, so if you do a lot of work for every inbound connection (and thus take some time before accepting the next connection) some inbound connections may time out while waiting for the server to accept the connection. I would focus on making sure that it's actually GitHub (or whatever) that is sending the POST before you run the deployment. Good luck!
If you're talking about low traffic (and it sounds like you are) then don't bother writing the socket handling code yourself. `man xinetd` And if you need encryption or authentication: `man stunnel` xinetd is a daemon that listens on a port, and when it receives a connection it starts your cli script with stdin and stdout connected to the socket. You write your script just as easily as if it were being run locally. stunnel is a kind of middleware that handles SSL. Point xinetd at stunnel, and point stunnel at your script. Your script would look identical to the non-stunnel implementation (because again, it just communicates over stdin/stdout). Obviously this would make you responsible for the actual communication protocol, though (but that would be true of any implementation that didn't go through a web server).
No. But the article is from 2013... so... 
Very true. Any time there's some mystical peformance improver out there, a lot of inexperienced devs try to make use it for every use case. Though, with the hype, I hope there are some major improvements to threading in PHP overall, including the wxPHP project, so pre-existing PHP projects can become desktop apps.
Yes, I'd forgotten about that! Though clearly if the called function modifies the copy then the value will still need to duplicated. Reference for anyone interested in such things: https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html
Nginx is *very* easy to setup though. It takes all of 5 minutes and requires very limited resources. You will spend more time on trying to do it in PHP than just taking the time to do a quick install of nginx.
&gt; You can achieve it by setting Allow Overwrite to none. It's [AllowOverride](https://httpd.apache.org/docs/2.4/mod/core.html#allowoverride).
apache is for dinosaurs 
I'm not too sure what makes this harder to read, the font or the terrible grammar. Also, wrong subreddit, self promotion etc
The install guide is incomplete. 
&gt; Yes, I'd forgotten about that! Though clearly if the called function modifies the copy then the value will still need to duplicated. Only if there are non-reference variables with the same value (where the variable used to pass by reference also counts as a reference). I have to say, PHP 7 is making references a lot more practical, and they can actually help with better performance in some edge cases (despite they represent an added level of ZVAL indirection in PHP7). I use references in the plugin structure of my Data Mapper for example, where a set of plugins can cooperate to build a complex structure together. The alternative without references was tested to be *over twice slower* in benchmarks, and it causes a lot more ZVAL churn (and hence higher CPU and RAM usage), by creating structures that get immediately discarded after merging in output. References are a good optimization sometimes. In particular, this scenario, as preferable it may be from a conceptual perspective, is very wasteful: $foo = return_modified_foo($foo); Variable $foo will be copied when it gets modified in the function, because the version outside still exists with its old state, but the moment the output is returned, the old version is discarded. The reference version here *avoids* the copy, instead of causing one (as long as there are no more non-ref variables holding $foo's value): modify_foo_in_place($foo); // Takes by ref.
I'd like to see some evidence for that. I've never seen anyone use nested ternary operators without parentheses. It doesn't even make logical sense, I don't see how anyone can be relying on the result of nested ternaries. Major versions are for breaking stuff. I don't see how this is any different to `$foo-&gt;$bar['baz']` changing - both are rarely used, and when they are used it is with brackets to avoid ambiguity.
&gt; I know that php-cli can run PHP scripts as executable files, but they have no web server functionality. `php -S &lt;addr&gt;:&lt;port&gt;`
Pretty ignorant Symfonly user is here (the OP of the SO question). Yet, as far as I can tell, the error is misleading. When there is no firewall entry, ther error is okay, but then firewal is okay, there should be another response - a sort of 405 HTTP error instead of RuntimeError thrown. If I am right, what should I do - overewrite the UserBundle\Controller oof my own or create an issue for Symfony? 
[Elvis ? Oh yeah.](https://www.youtube.com/watch?v=ujIJFEsOrX4) But more on topic, [it's quite well-known.](https://en.wikipedia.org/wiki/Elvis_operator)
My only recommendation is to hire a professional team.
What is the default action is a configurable option? What if you want the default to toss a 404 since they are asking for something specific that does not exist?
Just to be a pedant, in this case it's not actually a ternary operator. It's a binary operator. :) https://en.wikipedia.org/wiki/%3F: https://en.wikipedia.org/wiki/Elvis_operator
Again as I said. Store the Actually user information in MySQL or whatever RDBMS you want. but store the actual connection relationships in another format. Facebook does not use MySQL to query this information https://www.facebook.com/notes/facebook-engineering/tao-the-power-of-the-graph/10151525983993920 The difference is I just assumed that since the OP asked how this is suppose to work he does not have an army of engineers to develop his own custom Graph Database solution like TAO. Which is why I said for him to put that information in Neo4j, or OrientDB, though if he already has the User information in a RDBMS then Neo4j would probably be better for him since OrientDB is a multi-system Graph Database that also is a Document Database, a all in one solution if you will. Simply Facebook from that article I link does not do their Graph related queries from MySQL. The data is not stored in the same MySQL or in MySQL at all. They use a Graph API on top of a custom Graph DB that they engineered from the ground up. Most people can not do this which is why I suggested to look up Neo4j or OrientDB to supplement the creation of a custom Graph DB
Then don't depend on implicit operator ~~order~~ associativity. Use parenthesis and you'll never have to guess about operator ~~precedence order~~ associativity again. And, as a bonus, people will be able to reason about your code better with the explicit groupings.
Default is just the case that runs if no other case did, it could do any or all of those things
The number of tests you have is quite irrelevant. Code coverage and test quality are what you should be thinking about. * Code coverage above 80% should be a goal for every project. Your code coverage (45%) is quite low. * Test quality is harder to judge. Humbug (https://github.com/padraic/humbug) can help you a little with this. Test code review is by far the best way to increase test quality.
So there's no point in mocking your services? 
Symfony is the most slow framework in tech empower reviews. 
In the example given they are saying, "If no action is given, then assume the action is 'home'." What I was pointing out is that using the default of the switch could be for a case where an invalid action was given. Also, if each of the switch cases was a different action and you wanted to allow the default action to be configurable and *not* duplicate code, then you'd want to set the default action to trigger the correct switch case. Using your suggestion you lose all of that capability.
commit third party libraries to companies source code vcs
"$x = $y ?: $z" is a general case, so a general statement is fitting. Had the user presented a specific case with appropriate context, it might or might not have been unclear or too clever. In general though, I stand by my opinion based on far too many years maintaining other people's code.
&gt; it could check something unique to the user Any reason that an email and password is not good enough? There are plenty of pre written libraries that have solved this problem. If you're looking to build it all yourself, you may be better off with a something like Wordpress and some plugins. But if this is for your business and meant to create revenue, then do it properly and get a pro.
I'm sorry you had to maintain bad code, but that doesn't mean we should discard all language elements that can be misused or abused. Pretty often, brevity makes things clearer, and reasonably tight code can be neat and tidy.
Typically when I write out my unit tests I'm creating mock objects which set expected behavior. Here's an example of a controller method which "glues" http requests to the service layer: $request = $this-&gt;getMockBuilder(UpdateIssueRequest::class) -&gt;disableOriginalConstructor() -&gt;getMock(); $request-&gt;expects($this-&gt;atLeast(5)) -&gt;method('get') -&gt;will($this-&gt;returnCallback(function($key) use ($issueTitle, $issueDescription, $issuePriorityId, $componentIds, $customFields) { switch($key) { case 'title': return $issueTitle; case 'description': return $issueDescription; case 'issuePriorityId': return $issuePriorityId; case 'components': return $componentIds; case 'customfields': return $customFields; } })); $issue = $this-&gt;getMockBuilder(App\Entities\Issue::class) -&gt;disableOriginalConstructor() -&gt;getMock(); $this-&gt;service-&gt;expects($this-&gt;once()) -&gt;method('update') -&gt;with($issueId, $issueTitle, $issueDescription, $issuePriorityId, $componentIds, $customFields) -&gt;willReturn($issue); $this-&gt;controller-&gt;update($projectId, $issueId, $request, $this-&gt;service); We may also need to redirect the user which would require yet another mock object.
I'm saying make a habit of not using elements that encourage bad practices or confusing code, and your code will get better. The ?: operator is one of them. It has it's place, but people seem to use it where much clearer constructs would work better, especially year later when trying to debug or maintain the code.
Nope. Don't like it. Makes the code harder to read and removes aspects of self documentation. You better be commenting the shit out of this when you use it.
Ironic, no?
I can't even understand what is being tested here, everything is a mock. If you enjoy writing all this stuff, by all means keep doing it, but the way I perceive it, it's a workaround to a problem somewhere. When I want to unit-test a service, I just pass input to it, and get output. It may need a data fixture, and I may choose to isolate it from calling other services, but I mock nothing except for intercepting outgoing API calls.
DateTimeImmutable implements DateTimeInterface instead of extending DateTime (not sure why). Those constants are defined in DateTime so DateTimeImmutable doesn't inherit them.
I have a Linode VPS for $20/mo and they're really good.
Rasmus has said before that PHP has the $ so that the syntax is the same for string interpolation and regular variables.
You can use the const keyword [outside of classes since PHP 5.3](http://php.net/manual/en/language.constants.syntax.php#example-127).
You would query your service layer to return the contents for that order by passing to the service layer relevant information. A Controller uses Inputs to Query a Service and then passes the output to your view for rendering... I can't see how the orchestrator pattern fits in a PHP world except for maybe in an Async package like React. Orchestrator is used in other languages where there is tight coupling with the environment, like in ASP sites. A controller gets inputs from the ASP run-time then passes them to an "Orchestrator" which then queries your service layer. This abstraction step makes it easier to test ASP sites, but is not needed in PHP.
Hello Broken_duck – I’m doing an open source web app for online reservation of services. This is not just a module but a full app. This has been baking since January, and is starting to get ready. I've currently done a simple date-business-service booking flow with some email notifications and business dashboard. This implies that I’ll get something practical within a few months, and any suggestions are welcome, as well as joining the development team if you want to :) https://github.com/alariva/timegrid 
If you use the null coalesce operator, a notice is not thrown, as the third example demonstrates.
&gt; You would query your service layer to return the contents for that order by passing to the service layer relevant information. A Controller uses Inputs to Query a Service and then passes the output to your view for rendering... So in the example provided by ebonwumon. I'm curious as to how you would approach this problem by introducing a service layer. Would you have a single OrderService which also returns employees, available trucks, etc? Or would you have multiple services which all return some specific collection of entities/DTOs?
&gt; PHP since version 5.3 (released 14 Aug 2014). I don't know where you got that date but PHP 5.3 was [released in 2009](http://php.net/ChangeLog-5.php#5.3.0).
A demo / screenshots would be a handy thing to put on the site IMO :)
Usually it's best to link to the github page vs the frontend page since, y'know, we're developers first :) Link: https://github.com/morfy-cms/morfy
I think I can see what you're trying to do - basically you want to be able to "push" updates to a user's existing install of your application? I think it's feasible, but I think having a separate service listen to it is unnecessary. Is your application web-facing or does it have a public folder visible to the internet?
Valid complaint. But anybody chaining ternary operators, especially without parenthesis, should be put to death.
Sadly standard for open-source software. Everyone wants to work on the cool stuff. No one wants to worry about pesky things like the basics.
Functioning, as intended. Good job, game changing comma!
Makes sense. I guess what I meant to say was, why didn't they make ?: handle non-existent variables? Instead I'd have to do something like $x = $_GET['value'] ?? false ?: 'Default' Would that even work?
&gt; With stupid I was referring to multi pass vs one pass compiling. I don't actually know how much passes php needs but I remember that they wanted to keep with it's current form. You don't need more than one pass to understand variables without $ or a great many other constructs. You need more passes to apply more involved optimizations, which PHP doesn't do because then it throws them away at the end of the request. Additional passes however can be applied when you use an opcache. There are some optimizations various opcode cachers have implemented, but it's been somewhat rudimentary. With PHP 7 and a materialized AST, this will change (that's the plan at least). &gt; Also in you explanation above magic constants seem to have an extra handling? Syntactically they're constants, so the parser just sees constants. At runtime if it's one of the magic names, it's resolved differently. This is how it works in 5.x, I'm unsure if this has changed in 7.0 (probably not), but point is, it's not in the parser.
while Symfony is my jam and I agree with your statement, this is apples and oranges here.. I mean the D is a CMS with so many moving parts it makes my head spin, so the documentation takes a back seat. Symfony is designed strictly to be a toolkit and as such Documentation is a first class citizen. One thing I've learned though, is that even though you see "Posted *8* years ago" some of the tips and tricks posted around the Drupal site will still work and is valid for even the latest D7 lol I.. can't quite decide what that's supposed to say about the state of Drupal tho..
Awesome! I'll check it out.
Love this. My typical approach has been the laravel way; a bunch of view composers organized by a service provider. This is great because it keeps your data binding in the controllers. Less files to deal with which leads to greater clarity, in my opinion. Both approaches work, but this keeps you from having to create a MyNewViewComposer.php and then register it with the service provider. Really interesting, thanks for sharing.
&gt; $x = $_GET['value'] ?? false ?: 'Default' which would be equivalent to $x = $_GET['value'] ?? 'Default'
This doesn't actually test anything. You just recreated your controller implementation in your test. You need to use an integration test here and do something actually "real".
You can (google Reactphp), but you don't want. No multithreading is non-issue, but language and ecosystem certainly is. First - language. Due to execution times counted in miliseconds, garbage collection is really imperfect. You will have to manualy time GC cycles, and memory profiling is not easy when script is running for hours. Then ecosystem. You want logging, and logging beneath file_put_contents(...) needs logger such as Monolog, which, by design is one big memory leak. Then database interaction. I'm not sure about other tools, but Doctrine is totally unable to gracefuly reload after problems. So, and so, and so. Almost no components in PHP are prepared (and tested) in long-runtime environment. Just do yourself a favor, and use almost anything else. If you are considering PHP, you probably know some frontend technologies, including Javascript. Creating service in Node.js and managing it in PM2 will be minor leap from your comfort zone, and you will save countless hours of tracing strange memory leaks, execution halts, and smoking cigs by volume while deciding, if you have to rewrite this component from scratch in Node.
In the case of having something like a greeting (or anything that makes use of the current logged-in user's name/details/etc.), wouldn't it make more sense to use something like `Auth::user()-&gt;name`?
That's an interesting approach. I'm wondering, is it fundamentally different from using Laravel 5.1's new 'Service Injection' functionality? To me, the new inject directive is pretty similar to the method listed in that link. It also has the added benefit, IMHO, of making a bit more clear how variables are being introduced into the view. If you aren't familiar with the Blade Service Injection functionality, it is here: http://laravel.com/docs/5.1/blade#service-injection
I use it so when I am looping over an array or something and a condition isn't met, I just `continue` it. Cleaner code and it doesn't have to keep working. 
I use it all the time with guard clauses. Much nicer than nesting. I think this is generally considered better practise.
That's very useful! sure beats the hell out of writing those "array_get" methods.
Thanks, I was unaware of the new Service Injection functionality. It appears as though it would be very handy for use cases in which you need some business logic to produce one and only one variable for your view.
1. Robin Nixon's Learning PHP, MySQL, JavaScript, CSS &amp; HTML5. 2. Modern PHP by Josh Lockhart. 3. [PHP Official docs](http://php.net/manual/en) (Most Important)
I don't know anyone who is against using `continue` in any language.. All I can say is that I prefer `continue` to be used as early in the loop as possible, rather than having to hunt for 30 different potential paths where it might be used. Nested conditionals can be a pain, especially if you're doing something like: foreach ($x as $y) { if ($condition) { // something, something, something if ($anothercondition) { } } } It's much more clear (to me, at least), if you just skip anything !$condition and !$anothercondition in one flat level.
I have to agree with both points. I don't think there is a specific good/bad statement on this topic. I personally don't use much continue commands in my code as I do like to have a single exit point for my code. But, at the same, I have used them occasionally when working with another programmer who preferred them. I think it comes down to whether or not you like to use it or not and if you need to save an extra 1 microsecond on some task or not as continue does just skip the rest of the execution for the next evaluation statement. But is it really worth it?!?!? :) Enjoy fellas.
It's easy to make up numbers and put them in an image, so this really doesn't hold any weight unless the benchmarking method is also published/linked.
This and this alone is enough to make me go to PHP 7 as a former C# developer who was so used to utilizing ??
Many flat file CMS platforms include an admin interface out of the box, such as Statamic: http://statamic.com/learn/control-panel/what-it-is
and what ? Statmic is not opensource cms
Seems unnecessary to point out now that even 5.4 has reached end of life. Who writes NEW scripts for unsupported branches?
I'm just trying to figure out what it is. No need to yell. Still don't 100% know. What does it really do?
This. Adminer is light, fast, easy to install, and does just about everything you need. I tell everyone about it everywhere I go.
This comment is being upvoted, but the similar [comment](https://www.reddit.com/r/PHP/comments/3thn7i/til_x_y_z_and_i_love_it/cx67w68) below is being downvoted. I feel like I'm missing something. I understand that ?? is preferred to ?: because it runs an internal isset() check, but is there something else? Edit: the other comment is using this code: $x = $y ?: $z ?: $a ?: $b;
I have already answered on this question, I may repeat. You can MANAGE YOUR CONTENT ANY WAY YOU WANT. You may even store it on GitHub as I do for Official Morfy Website or you may use Morfy Admin Panel - https://github.com/nakome/morfy-admin-panel or you can create your one application based on Morfy to manage your content.
I'll certainly have a look at it, thanks!
Compliance with a standard is always binary. Your only choices are comply or don't comply. Any variation of partial compliance is non-compliance, by definition. This is why RFC 2119 is a thing: when a standard says MUST, you must. If you don't, you're non-compliant. It's not open to interpretation.
I feel like the admin panel *should* be _the_ CMS. The rest is just the framework, no? But yea if anything I would recommend improving the front page a bit to expand on what problem it does and does not solve. Very unclear to me =)
&gt;You can MANAGE YOUR CONTENT ANY WAY YOU WANT **CMS** &gt; Content **Management** System. That is where the confusion comes from. Most content management systems usually include a system to manage content. 
Yes there will available such Morfy Packages Soon: 1. Morfy 2. Morfy + Admin Panel 
I had a similar problem with a different database web interface a few months ago. It was caused by it automatically running count(*) on a large table to generate meta data. Have a look in the mysql query log and see if the query you entered is the only one running per page load.
I have heard rumours that web pages can contain words as well as videos: &gt; Integrated tests are a scam. You’re probably writing 2-5% of the integrated tests you need to test thoroughly. You’re probably duplicating unit tests all over the place. Your integrated tests probably duplicate each other all over the place. When an integrated test fails, who knows what’s broken? Integrated tests probably do you more harm than good. Learn the two-pronged attack that solves the problem: collaboration tests and contract tests Have a bonus blog post as well: http://blog.thecodewhisperer.com/2010/10/16/integrated-tests-are-a-scam/
Another suggestion - make sure you are not running iis and wamp at the same time.
&gt; This is true in PHP 5.x, but has been fixed in PHP 7.x. That's cool and all but PHP 7 hasn't been released yet and even when it does, there will still be lots of apps still running PHP 5.x
`continue;` is fine. `continue 2;` or any other multi-level continue-ing is not as fine, https://3v4l.org/l3ekI for ($x=0; $x&lt;5;$x++) { for ($y=0; $y&lt;5; $y++) { if (($x + $y) % 3 == 0) { continue 2; } echo "x $x y $y\n"; } } 
No, it's not. If $_GET['value'] evaluates to false then you get 'Default' instead. Since ?: cannot handle a missing variable, you use ?? which can. Since ?? only checks if it's set and not null, you use the ?: to check truthiness.
Isn't that the point I was getting at?
True, moreso its just useful if you have pre-existing libraries and scripts in PHP, but want a GUI with them instead of a bulky command line.
How did you install your LAMP stack? Are you using a VM?
Larry Ullman
And?
Coverage is a heuristic, you can cover your codebase twice over with unit tests and still have a highly buggy system at the unit level, and even buggier system when integrated. Complaints that integration tests take a lot of work are just as valid as saying testing requires work. They do, but "don't do them" is not exactly a mature solution. Aside from the fact coverage is an imperfect metric, large systems have emergent properties that no unit in the system has. This is why integrated testing is still needed.
Adminer looks decent, but I highly recommend checking out [0xDBE](https://www.jetbrains.com/dbe/) It's still in development so you can use it for free, it's pretty great.
Named params would be nice here....
I know :/ I really wish PHP had them.
Does the CLI connect fast?
[removed]
I don't think there is enough information provided to give you a concrete response. Based on the information you provided in the last example, I think your actual problem is putting to much responsibility in a single method and/or class. Here's the approach that I take, as a series of steps: 1. early authorization checks, ensuring that the current actor (user) is allowed to perform a given command 2. preparation of the command, ensuring that all input for a given command is collected 3. execution of the command, ensures that the input is valid for the command (assume authorization is okay) 4. persistence of data, ensures that that the command is recorded in the overall application 5. output of result, either a success or failure response Whenever I feel like the logic is no longer testable in isolation, I split the function/method/class to ensure that it is.
Async PHP can have some crazy high requests per second: http://marcjschmidt.de/blog/2014/02/08/php-high-performance.html
Definitely. Everyone should know a few.
Is it even possible to use PHP effectively without knowing the client tier of HTML/CSS/JS? That is another language right there.
Suggest a hybrid. Create a request object. Specify properties of that object. Your api should take one argument. An instance of that object. The reason for this is api version issues. You can easily add a new property to an object and not break an API. However you can't just change the endpoint definition. Some clients have issues especially if your endpoint supports say both Rest and SOAP. 
Each language has it's own ideas and methodologies, they're own techniques and features. The more you learn, the broader range of skills you have and the better you can apply them to any one language.
It's a provocative title, but its less of a rant and more of a lesson in when and how it's appropriate to do them. Essentially unit tests between all the layers of code you understand, and integration tests only with things you cannot control (the big bad outside world). Actually a fairly entertaining watch. Goes through the common pitfalls associated with heavy emphasis on integrated tests.
Oh, I am so sorry for having an opinion on this topic. The error message is not vague, it is exactly as exact as it needs to be. You want one type, you have another. Going more specific is not necessary. If you want to know why the error happens, you can always use the backtrace functions.
Thank you, but the error is somewhere else since it keeps loading on both PMA and adminer
I already have IIS disabled 
I'm not using VPN :/
Sometimes in 90% accurate English.
Sorry but where can I see this? 
How do you use php on nginx without fpm?
Just out of curiosity you're saying the if/else is less clear to you? For me it's so much more obvious than this language specifc operator.
I uprooted because you are technically right but following this reasoning english is also language. And technically I'm writing in PHP and english. Since it was not asked directly "do you write in another programming language" you are obviously right. But HTML and CSS are not turing complete so in contradiction to PHP, Java, Brainfuck you cannot do a lot of programming using those. TBH I've read somewhere that in HTML5 and CSS3 "Rule 110 automaton" was implemented what points that this combo is turing complete but I've never seen something like quick sort implemented i HTML and CSS.
Surely your app has logic, right? It's not just a composer file and then some code to glue this thing to that, right? This is something I've seen time-and-time again -- mostly in Python and then only because I'm mostly a Python guys these days -- and someone will post something, "How do I unit test this?" and it's a fifty line function that has eight different database calls, a webform, sessions, etc. And the answer is, "You can't. At least not like that, you can't." But you can totally [unit test things like logging in](http://justanr.github.io/exploring-code-architecture) by being smart about how you put code together. Yes, at some point you'll need to actually write the test for "Does it actually log in the user?" But you're only testing a single UI thing at a very high level, rather than trying to test the different use cases through the UI. Or maybe you'll write a few tests that assure that when the credentials are correct, the user's logged in; and then one for when the credentials are incorrect the user is notified about that; and maybe one for when the wrong credentials are entered X times in Y period the page is redirected to a "temporary lock out" page.
Yes. But the blog post is 9 years old ...
CSS is actually Turing complete, so yeah it kinda is.
Because ain't nobody got time for that.
Video of the talk?
And sometimes it produces significant confusion.
Thanks for the tldr!
But from a PHP Freelancer's perspective, Drupal is still the biggest money earner, isn't it?
what he meant to say was "not a programming language", which is correct, as they are markup languages. He just abbreviated unnecessarily. 
For me it is Magento, less jobs but at a higher rate so it more than makes up for it. Then the odd easy wordpress site because...who can't build a quick WP site?
Because lower expectations
Did anyone else have a hard time reading this?
It's not just a PHP operator. You find it in many languages. If you don't know the operator it is less clear. If you *do* know the operator it is much clearer for simple cases like the one I listed. You condense a very simple check and assignment to a single, simple line. The other way it is spread across multiple lines and the cognitive load becomes slightly higher. It's like vocabulary. If I have a word that expresses my thoughts better and allows me to use a single sentence versus using simpler words and needing multiple sentences, which is better? Am I writing for the average Joe or a professional that should have the same technical vocabulary?
See the issue being that I already have Magento as my main driver for income. If I want a quick buck WP is really easy to pickup and get out the door where as if I was going for a Drupal project I would be better off just picking up another Magento project. It's not that I find WP better than Drupal, it is simply that it's a much smaller time investment for what I get back. If I have the time to dedicate then I would pick a Mage project, its as simple as that for me. 
Yup that's it.
while indeed true that this is what capistrano does essentially, it's also worth pointing out the amount of work involved in setting up capistrano (and all its dependencies) is ridiculously high versus using envoy. that reason, plus knowing that you'll be running deploys ONLY with PHP are big reasons enough to consider this. if you don't have a deployment pipeline set up yet, this is a great way of doing things.
Larry Ullman's books are really good too. Lots of exercises to get you started.
I should've tested out the `$x &amp;&amp; doSomething();` first, obviously. Anyway; I agree that using it for failed operations (false on first) is cruddy. Using fallback assignment through OR is a common pattern in Javascript, though, and as long as it's just `A = B || C;` and you know what to expect from `B` it's not really frowned upon afaik. (I completely accept that it won't be implemented, I just think that `A = B || C;` makes sense and it's used in other loosely typed languages)
&gt; The answer isn't integration tests, but rather contract/collaboration tests - as he calls them - which are basically do these two layers communicate properly. Doesn't this suffer from the same 'exponentially increasing number of tests' problem?
So proper integration testing is *not* a scam? Sounds like we're all in agreement that unit testing doesn't cover everything, end-to-end testing is pretty much shit, and there is some middle ground. We're just arguing semantics.
I wasn't trying to imply you had a bad design. If you have a CRUD app and it works, then keep at it. :) There's no point in exhaustively testing what amounts to data entry.
It does if you don't use dependency injection. I have to admit when I tell people that DI is the answer feels like I'm selling snake oil. But it really, really makes this much easier. Instead of having to construct half your application to test authentication, you can construct your authenticator and then give it a fake database that blows up or gives back the desired result. 
You can get somebody to set your capistrano up for 30$ in upwork ( actually even way way cheaper, since a person who had solid experience with it can do it blind in 10 minutes)
"Sun, on the other hand, failed to make Java accessible to amateurs" - If it takes effort, it's not worth it.
It was always accessible in the sense that you could download the Java SDK/JDK and Eclipse and start coding. But it was not accessible because of the layers upon layers of components one had to stack upon Servlets to produce even a simple *HelloWorld* web app, that it just didn't paid to write web apps in Java. Even to this day it doesn't pay to write web apps in Java in terms of developer efficiency. The corporations who hire Java devs are those who are unfortunately very much locked-in and dependent on Java technology. Any new development undertaken by a sanity-loving decision maker will involve either php or python.
Predominantly CRUD (i/o) app - php runs in megabytes (high throughput), scales easily (compared to java). Php is a scripting language and (mostly) abstracts away complex tasks like concurrency, system IO, and more. Highly specialized apps that don't simply access a database, but process data or otherwise compute in some way - Java gives you robust and granular concurrency resources (latch, barrier, semaphore, synchronized, threadlocal) which can be tough to grasp in their entirety, especially if you don't have formal training in computer science. Java runs in gigabytes, and doesn't necessarily scale seamlessly. As an architect, you need to leverage its API to eventually scale ln your architecture. An example that highlights the strengths of each: a highly distributed PHP API that processes some commands itself (eg user registration, auth), but forwards other calls to a Java microservice that handles video processing operations remotely (e.g. youtube, netflix - not 100% like this, but you get the idea). One's a hammer, one's a saw. Usage depends entirely on your use cases. 
Thank you I will give this a try when back home and update.
&gt; amount of work involved in setting up capistrano (and all its dependencies) is ridiculously high A lot of people seem to think that anything more complex than "just upload it with FTP" is too difficult. Like any tool, Capistrano has a learning curve. But once you learn it, you can make good use of it. By your logic, nobody should ever drive because the "amount of work involved" in driving is "ridiculously high" (training, exams, paperwork, insurance, taxes, health risk etc.). Why learn how to drive when you can walk just fine, right? &gt; you'll be running deploys ONLY with PHP I don't get this either. PHP, like any other language, is not the best tool for *every* job. Don't try to push a square peg through a round hole, use the best tool that exist for the job.
PHP
Ya, my experience tells me that it's always relative - your first experience with something can often determine what you think of it for all time. Java is a fun and simple language, but the ecosystem of tools can get overwhelming, if people (like your job) just throw you into it. Meanwhile, a simple php script will run out of the box ... assuming you have a proper web server running, which is often easy, and sometimes (if you have any kind of custom needs) super difficult. 
&gt; you spend hours searching for a bug with this error message, and no stack trace called in /in/HgpGj on line 15 There's all the caller location information you need, no? You can dump the stack trace manually from there, define a break point, or simply fix the error if it's local.
OP did not specify. Just "language" could apply to programming, style, and markup languages.
Actually, HTML5 and CSS3 are turing complete.
9 years old...
Great point. The question still remains after 9 years. Although I am probably unable to answer this (or anyone..) heres something short answer: java sucks. php sucks. hack with what ever you can. less short answer: AT THE CURRENT MOMENT, php is licensed a lot better than java. I'd rather not run java at all. Not flash either. Java is nice for developing android apps only because it is necessary. With it you can make an app that connects to your server (like instagram does). PHP is good for developing web apps because its free and free. With it you can make the API that your java android app connects to.
continue is a great way to clean code and reduce cognitive load. It's much better to do this: foreach ($list as $listItem) { if ($listItem-&gt;getVariable() == "Not what you want") { continue; } //rest of the code } so that you eliminate things you need to remember in your head when you reach the rest of the code, rather than foreach ($list as $listItem) { if ($listItem-&gt;getVariable() != "Not what you want") { //rest of the code } } (especially if there's nested loops in the second example.)
many large, sophisticated companies
Check: $item-&gt;image['@list'] . What type is root($image) variable? Do you can show me full var dump? 
`DateTimeImmutable` does not extend `DateTime` because it would violate Liskov Substitution Principle.
 Unable to use "Check: $item-&gt;image['@list']" .. Error: Cannot use object of type stdClass as array 
I would prefer "instance of Weasel" too. The more information (and easily understandable) the error message provides, the better, IMHO. Also it would be consistent with function x(Bar $b) {} x(new Foo); Which gives `Argument 1 passed to x() must be an instance of Bar, instance of Foo given` as error.
http://pastebin.com/g1wFKrCN
&gt; The corporations who hire Java devs are those who are unfortunately very much locked-in and dependent on Java technology. Sounds like a good way for Java programmers to ensure job security. XD
If every "service class" is one action, then it's also the command. Which means no extra classes. // only the most common params in constructor, optionally. $createUser = CreateUserAction('John', 'Doe'); // the rest can be setter methods. $createUser -&gt;age(23) -&gt;role($createUser::ROLE_ADMIN) -&gt;email('foo@bar.baz'); // passing the command to a domain allows the command to be executed on a domain of a given context, with injected config etc. $domain-&gt;execute($createUser); // OR... you can do this instead, if you don't need a configurable domain, if it's statically determined. $createUser-&gt;execute();
Noted. Would you mind [filing an issue](https://github.com/magento/magento2/issues), or I can do it if you prefer?
I'm going to show this to the team. That's... awesome. 
Just do: $item-&gt;image-&gt;{'@list'}
No problem, it happens. :)
04.28.2006 ? Seriously ?
I do not write, I copy and paste. I have written my own functions, but they are baseline. I have never written a class. Although I am more adept at C#, but that still is not saying much.
As far as I see this doesn't account for database changes either (depending on the setup). I also believe that you can refresh opcache with service php5-fpm reload or the equivalent which would make for a near zero downtime I believe.
so $item = (array) $item; $item['image']['@list'] - bcuz i don't know what is type of root variable :) 
Always nice to see someone that even knows about Silverstripe! I don't think it gets enough credit for being a CMS framework that's actually done fairly right. Granted, it is slow as hell though and without some minor problems like having to ?flush constantly.
Usage of continue is too inconsequential to have any deep thoughts about. Things like that begin to matter only if your methods tend to become very large and convoluted. Keep methods short and whether you use continue or not, it'll be fine.
Learning other languages helps you to be a better programmer. This is especially true for ones of a different paradigm. Most of the popular languages are ALGOL-derived and thus very similar (C, C++, C#, Java, PHP, Perl, JavaScript, Python, Swift, Pascal...). It's worth learning something from a different family, such as Lisp, Haskell or one of the MLs (OCaml?).
Or ICQ
Oh, the nostalgia.
Or its designated successor, Skype
&gt; Debugging isn't as easy (in my opinion) nor is using an IDE to figure out things like return types and doing reflection. You should try setting up xdebug and your IDE. Once you stop using var_dump and switch to breakpoints in your code everything becomes easier to debug. I agree about return types (but this should change with php 7). Only thing which will be missing is being able to specify a callable's signature when using one as a parameter or return type.
[removed]
There is only one language. All hail the one true language ...
The primary issue with Gitter still is that it must be tied to a GitHub repository. 😕
The main point of prevention is making sure that whatever is passed into the query cannot begin another query. If your ProductID's are numbers, you can simply do $_GET["link"] = (int)$_GET["link"]; As casting it as an int will just change it to 0 if someone tries to pass something malicious in. So you can then use your value in the query, however, if it's a string, you should look into PDO - http://php.net/manual/en/ref.pdo-mysql.php - basically it would have you change your queries to something like $Statement = $db-&gt;prepare("SELECT * FROM Products WHERE ProductID=?"); $Statement-&gt;execute(array($_GET['link'])); $rows = $Statement-&gt;fetchAll(PDO::FETCH_ASSOC); The ? is replaced with your value, in a way that is secure. PDO is a small change in the way you likely think about things, but makes it much easier to be secure, and you'll likely wonder how you lived without it after a few hours of using it.
I wrote an article that (beside other things) describes essentially what an SQL injection is, [The Hitchhiker's Guide to SQL Injection protection](http://phpdelusions.net/sql_injection). In a nutshell, SQL injection is but a consequence of improperly formatted query. And to protect, you have to let your database driver to format *dynamically added query parts*, instead of formatting them manually. And to achieve that, instead of adding the data in the query directly, you have represent it with some sort of marker. While actual data have to be sent separately, to be added to the query later, after being properly formatted by the driver. And for practical measures regarding protection, I have another article, about API you have to use instead of obsoleted `mysql_*` functions, [The only proper guide on PDO](http://phpdelusions.net/pdo). The latter is not entirely focused on the protection, because PDO is great no only for it, but you will get the full reasoning in the former one. Beside other things, it explains, why **manual formatting** (casting to int mentioned in the other answer) **is bad** - don't be lured by the seeming easiness of the method. As a further step, I have a [tool that simplifies PDO usage for the former `mysql_query()` users](http://phpdelusions.net/pdo/pdo_wrapper). With it you will get your product data in but one line: $product = DB::run("SELECT * FROM Products WHERE ProductID=?", $_GET['link'])-&gt;fetch(); As you can see, it is more concise than your former code, but with full protection PDO offers. Feel free to ask any questions regarding the information above. 
Why PHP and not Java? Because I need the data in seconds, not minutes.
I think you misunderstood the parent: when set up properly, and combined with an IDE like PHPStorm, you can do proper debugging, with break points, stepping into code, running things line by line, mucking with values of variables if need be. It's glorious, and most likely something people are used to having in other stacks, like Java. 
Seriously, its hard to come up with a reason not to use nginx over apache for a new project. It just works so well.
&gt; I'm having a hard time seeing the utility of JWT as opposed to traditional "state-based" authentication via a token. Here's another problem: Historically, very few developers who decided to go this route did so without introducing vulnerabilities into their project.
If you want a fast but easy to learn Framework, you can have a look at https://nette.org/ What I love about it the most: - really nice debugger - autowiring (yeah, I know, symfony has it now as well, but nette has it for like 4 years or so already) - nice template system with context-aware escaping - quality community-made packages (ie. for doctrine integration, for symfony console integration, redis integration, ...); ofc you don't need a package to integrate something, but it's easier when you have it :) - it's really fast Also, it's AFAIK the most used FW in Czech Republic and tested on dozens of commercial projects (even big ones), so you don't have to be worried about stability or so. The only downside I can think of is that the documentation isn't as great as it could be, but people are willing to help with your questions at https://gitter.im/nette/nette :)
Sounds like you need to hire an actual developer
That wasn't even up for debate.
Just that it has nothing to do with PHP. :-D
Might be worth nothing that "it should not be used on a public network" according to [manual](http://php.net/manual/en/features.commandline.webserver.php) and this is not a non-blocking server. So not only it should not be used on his clients' servers but also there is high possibility of request timeout from git server while his server will be busy fulfilling earlier request.
Probably posted to the wrong sub by OP, yeah. But I do think that the PHP community should learn about Let's Encrypt and tell the world to embrace it. Hopefully it'll be included by default in many LAMP stacks, just like PHP. For those interested, here's how it works: https://letsencrypt.org/howitworks/
Sure thing, but learning about Let's Encrypt is what the post is really about.
Most people don't want the "index.php" part showing up in their URLs at all (whether it be for purely cosmetic reasons, or because getting people to type "example.com/index.php/deals" is harder than getting them to write "example.com/deals") A dependency on mod_rewrite isn't a big deal because it's usually enabled by default and frequently also used for other reasons (for example, redirecting URLs from a previous site version to the most appropriate page on the current site). Without bothering to check, it's probably possible to use Drupal in exactly the same way (by using index.php in the URL rather than URL rewriting) - it's just not considered desirable by the vast majority.
- Version upgrade is irrelevant to the problem - Using mysqli doesn't protect your data just by itself - Mysqli shouldn't be used as is. Instead, some abstraction library have to be used. PDO is a least acceptable choice.
This is a bad advise. Although this particular example is safe, it could fail the OP in different circumstances. Besides, one should never format their data manually but use prepared statements instead. 
&gt;However, I happen to know from using code igniter that it uses a much better way of managing clean urls: /index.php/node/1234/whatever. And since index.php is the default page, you may as well write just /node/1234/whatever. This way, dependency on mod_php is no longer there! I'm pretty sure this won't work, example.tld/index.php/node/1234/whatever is routing the entire request through index.php since it's explicitly being requested, CI just parses the requesting URL and separates the path, processes it etc. However if you request example.tld/node/1234/whatever, the http server is going to treat that as a request for node/1234/whatever directory or file and return a 404. Drupal (or anyone else for that matter) requires mod_rewrite to avoid the 404 and reroute all such requests to index.php.
&gt; CAs issuing DV certificates should do their job and validate if the requester is in control of a domain. That's the only thing they should do. It might not be obvious for you, but usually I prefer to control my server and not let any third party, especially no CA, control it.