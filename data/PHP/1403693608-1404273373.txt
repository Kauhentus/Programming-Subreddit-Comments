Not every function can magically handle every input given to it, especially when they were never designed or intended to receive that input, and it's especially annoying when the results match perfectly with what the PHP manual / PHP.net says you should expect to happen. People these days just expect miracles to happen when they throw shit together and save it as a .php file, then complain that it should work when it actually shouldn't. I don't know if there have been many times where I've seen someone complain about something in ANY language that has been a genuine bug of the language. In a lot of ways there is some seriously cool and dark magick going-on when compiling or interpreting code, but on the other hand there is a level of simple basic actions that are being repeated over and over a million times, and if any of that was actually broken then that would reveal itself in MOST programs, not just these tricky-dicky potato-mash code special circumstances. Usually it's shit like in the link where they are tossing around objects and references to objects and then dumping that through a foreach... and then at the end it all falls-apart and they sit there going "hurr php brokun!" Like I said, people are usually being too cute with their code using language shortcuts like foreach and then getting unexpected results, or doing fun things with type coercion and then moaning that a call to something like is_array or whatever isn't "working right". Functions are meant to be called. Shortcuts are meant to be used. But not to the extent that people expect everything to "just work". This is a language with typing looser than a crackwhore and objects passed around by a type of reference. Expect weird shit to happen if you don't account for those fundamental aspects of the language and start being cute with your code. It's just that simple. If you are writing something that doesn't look quite similar to something you would write in a strongly typed language then it's best to tread carefully and really consider what the code is meant to be doing because you could be shooting yourself in the foot. PHP might be loose / weak / whatever, but that affords a flexibility that also requires responsibility. Getting too busy with PHP-specific functions / features is a recipe for the types of disasters we are constantly shown next to the php hammer.
Thanks, I like qio and xral!
A few days ago.
&gt; Usually it's shit like in the link where they are tossing around objects and references to objects and then dumping that through a foreach... and then at the end it all falls-apart And in a proper language it would *never* fall apart. It would either: - Give a compile time error (for compiled languages, e.g Java) - Raise an exception (for all languages, e.g Ruby, Python) - Return an error (for langauges with multiple returns, e.g Go) Don't believe me? Try the examples in the link in Python, Ruby, Go etc. and try to get the same horrible behaviour. I'll wait. &gt; Getting too busy with PHP-specific functions / features is a recipe for the types of disasters we are constantly shown next to the php hammer. Yeah, getting busy with PHP-specific functions when writing PHP is just bad. /s &gt; This is a language with typing looser than a crackwhore and objects passed around by a type of reference. Expect weird shit to happen if you don't account for those fundamental aspects of the language and start being cute with your code. It's just that simple. So it's *my* fault for getting "cute with my code", but not the languages fault for having laughably poor object passing semantics and a completely crap type system? Seriously?? I mean, type comparisons aren't even transitive. The only languages that do something so outrageous are PHP and JavaScript. There is a reason both are reviled by anyone with a solid CS background.
That looks like it's exactly what I was looking for. Thanks very much.
You can argue until you are blue in the face that the language should have more errors / exceptions / whatever other bits and pieces you want, but the simple fact is that they aren't there. At least not yet. Maybe not ever. I don't know the future of PHP. If you pass a function something it isn't meant to receive and you get back erroneous data or false, well yeah it'd be nice if something somewhere caught that and pointed it out to you, but that's just not what PHP is or meant to do. Garbage in, garbage out. PHP isn't a beautiful swan. It's an ugly dog that can usually be prettied-up quite well. Sometimes it smells a little funny, too. But if you don't do anything stupid the dog will behave itself. If you go into PHP with the mindset that you get out what you deserve, not what you expect, then you'll be better-off. If you give it garbage and you get the wrong result then that's on you, not on the language. The language gives no fucks, and when you use that in your favor all goes well and you can spend less time writing error handling code and dealing with a bunch of shit. I... I really don't know what you want from PHP. It's like you are eating an orange complaining that it doesn't taste like an apple. I'm probably missing something obvious and not seeing what the problem is. To me it seems you use the right tool for the job. That goes for the language, and the functions and features used within that language. Use the wrong thing at the wrong time and you'll get drama. That hubbub that facebook is doing with hhvm is probably stepping in the right direction, but whatever. I think what a lot of people are not getting is that "not all things are possible with a flick of a function call or feature". Some stuff you just have to get down and dirty and write the code yourself. People start using things they shouldn't in ways they were never intended, because they don't want to have to do anything themselves and write more code than they feel they should have to. Or, that's my impression and my impression is wrong.
&gt; I... I really don't know what you want from PHP. I don't want anything from PHP, really. PHP is a tool that gets me most of my paycheck. The fact that I use it daily doesn't make it any less of an abortion of a language. What I am *really* against is the PHP fanboys who rise up to defend PHP and attack the critics anytime someone dares to criticize it, no matter how valid the points are. &gt; If you give it garbage and you get the wrong result then that's on you, not on the language. Again, PHP is unique in this regard and I hope we can agree on at least that. &gt; That hubbub that facebook is doing with hhvm is probably stepping in the right direction, but whatever. Yes. With Hack, they are adding strong typing semantics, unified return values etc. and they are also removing some of the bigger warts of PHP, like variable variables. All the power to them. 
October CMS is a CMS written in Laravel. I've never used it but at first glance it looks quite neat and has many of those CMS-style features you might need. http://octobercms.com *It hasn't been around very long so I can't say for certain how mature the project is at this stage.
Yeah, I am with you. 95%. The 5% I'm not with you is where you characterize defense of PHP as fanboyism. Like I said earlier, I don't think I've seen too many (if any) situations where something is purely wrong and busted, and it always seems to come down to the wrong data being moved around incorrectly and resulting in garbage out. I didn't dig-through all of this particular threads link to see if every single problem listed was actually a problem or just an abuse of the language. What I did glimpse in this link, and in any other "lolphp" or "loljavascript" situations are people giving reasoned logical explanations for why someone got the results they received after trying to do something tricky. There always seems to be a logical answer, and if there's a logical answer how can anyone blame the language for doing precisely what it was meant to do? That's not a broken language, that's the misuse of a language. It's just ignorance of coders being presented as shortcoming, or flat-out bugs, of a language. That's simply unfair and incorrect. If you want the features and philosophy of another language then you simply have to use that language. If you use PHP as it was intended and expect it to give no fucks when you write broken code then you'll be less frustrated. There's a lot of growing-pains to be experienced when moving from other languages to PHP, and I've had those and moved past them. I think a lot of people haven't quite gotten through that part yet. Maybe my code is just too simple and boring for me to find ways to break shit in "lolphp" ways, and that's a privilege reserved for coders greater than I.
"Objects with __toString() are not strings" In what world would that ever be an issue? 
phpwtf.org - objects are not strings. lol.
Yeah this is stupid. Any place where a string (and only a string) is expected, it works fine, for example `strlen($foo)` in that example. That one about type hinting is completely bogus, everything there works exactly as expected (an array can only be an array or null, it can't be false).
Wow people are sure getting defensive in the comments. The blog is in the same tradition as [RubyWTF](http://rubywtf.com/) and [JS WTF](http://wtfjs.com/) I don't see the developer (who's a PHP developer, btw) necessarily dismissing PHP as a language. He's simply compiling collection of strange and unexpected behaviours in PHP. I think it's a pretty good resource. Telling someone to "write a patch and just shut up" is not constructive at all. Not everyone has time to patch the PHP core, but putting time to expose odd behaviours is still a value to the community and the writer should definitely not be told to shut up.
You don't pass the container around, that's bad design. You use the properties of the container as arguments to the constructor. Containers should only every be passed into controllers and factories, and even then sparingly.
I agree that not everyone has time to patch. I am wondering, I have not checked, if the creator posted big reports. Compiling unexpected behaviors is beneficial though. 
Fair enough :)
Who said anything about BC breaks? Deprecate all the weird/broken stuff *now* (with maybe an E_STRICT) and remove them in PHP N+1. Isn't this what most projects do?
It looks sort of life they forked the entire Laravel framework? This looks like less of a module and more like a replacement.
I just wanted to point out a key thing in [ifreelanceAsia](http://reddit.comhttp://www.reddit.com/user/ifreelanceAsia)'s example, the use of `session_regenerate_id`. Anytime you're changing the access level of a user - higher or lower (logout is "lower") you should *always* regenerate the session. This can help prevent any kind of issues where the session still exists and the user might have done a MITM attack and picked out the session ID from the headers. Be sure to set that parameter to `true` too, otherwise the old session file is still sitting around until whatever cleanup process the system has removes it. This *does not* destroy the session data already in the session, though, so you still need to clear out what you don't want.
I don't think PHP is dying. At all. I don't think it deserves to either. But when the author is listing all these nice new things PHP has nowadays I can't help but think "Yeah, but none of those ideas came from within the PHP community". * The innovation on web frameworks happened in other languages (Python, Ruby and even Java) * git was already huge when the PHP community finally started adopting it * composer is great but doesn't do anything similar tools for other languages weren't already doing * same goes for PHPUnit The use of PHP isn't dying, it's being used more rather than less. So I don't think we need to worry about that. The fact that none of the major innovations happened in the PHP community however, does concern me. It means the innovators have left the community for other languages. I shouldn't care. Their ideas will eventually make it to PHP. It's like booking a flight on a plane which is flying perfectly, has an excellent safety record, passed all its tests and certifications. You know it's unlikely to crash. But when you hear the safety inspectors avoid the airline when booking their own holidays, you're seriously going to consider cancelling as they must be flying different airlines for a reason. "They must know something I don't." But I guess you could flip that around and say the people in the PHP community like tried and tested technology. Let others (*cough* nodejs *cough*) make the mistakes and deal with the fall-out, and we'll use the ideas that actually worked. I guess being where the innovation is or being where the reliable stuff is, is a matter of personal preference.
How did you come to this conclusion?
But one of the biggest benefits of PHP is the BC. My company uses php because we can be assured that what we write will still work 5 years down the road with only minimal changes. That's a HUGE plus. Besides, there is a big push for newer more "sane" function and classes in the php engine, but they don't necessarily need to deprecate the old version, just make a note on the manual that there are better options out there. The older functions don't necessarily stop working when new ones are created, and often they use the same backend so they can both be maintained easily (eg. the date functions and the datetime classes). Plus, with PHP having grown the way it has, there are a VERY wide variety of coding styles. One of the systems i work on is pretty much purely functional and was originally written in early php 4 times. We have maintained it and added tons of new features, but at this point if PHP were to start deprecating those functions for removal, it would probably be easier for my company to fork the php source and continue maintaining the old branch ourselves rather than try to rewrite the application to confirm to some guys view of the future. Also, PHP is deprecating the bad stuff. magic quotes, tons of globals work, and a bunch of other things have been removed due to security issues and maintainability problems. Last, I didn't know i had a reputation as a Googler now, cool! (I don't actually work for Google, i just contribute a ton of code to many of their projects)
They reimplemented all the artisan commands, they have a zip or git clone installer, not composer. Lastly I saw on their bugtracker that they override all laravel routes and you have to use October routes instead of Laravel.
`$url = 'http://www.pathofexile.com/ladder/export-csv/league/' . urlencode('1 Hour Lethal Party (S08F081)');`
PHP WTF Moments &gt; Powered by Drupal. The irony.
Did you not see the bit that said &gt; This site was born out of a DrupalCon presentation to educate people of PHP's quirks. **If you want to use this material to bash PHP you are in the wrong place.**
Sorry, I revised my example to reflect the proper way to get the URL. Only the latter part needed encoding.
A reference of elegant code, no. A reference of code actually being used, yes. Drupal has grown together with the PHP ecosystem, and this shows in how the code is used. Before GoPHP5 Drupal had to be compatible with PHP4 (Drupal 5 for example) Drupal 6 has minor problems with PHP 5.3 because of changes on the PHP side. Drupal 7 requires PHP 5.2.5 and recommends 5.3 Drupal 8 just plainly requires PHP 5.4 You have to account for the lowest common denominator and all later versions and their bugs. You can't use a new language function without either raising the minimum required version, or providing a backward compatible layer if even possible. --- Also, please point me to some code that you consider garbage.
Yeah, his tone seems pretty unbiased in the postings and he includes links to bug reports/etc sometimes.
You might want to have a look at http://url.thephpleague.com/
I didn't bother looking into most of them, but this one stood out: print "a".2; Makes sense that it would be confused, why should the language assume that its meant to be a 2 instead of a 0.2?
&gt; This site was born out of a DrupalCon presentation to educate people of PHP's quirks. If you want to use this material to bash PHP you are in the wrong place.
Because print "a" .2; is meaningless? Edit: Just a suggestion. I'm not saying it makes necessarily sense.
Using this scheme, how would you suggest that I replace the templating engine with another one easily? The reason instantiated objects are used is mostly for Dependency Injection purposes. This allows objects to be chosen and instantiated at runtime. Then, I can use a configuration file to say I want Twig instead of Smarty. I suppose you could get around this with some crazy autoloading scheme, but that would be rather hackish (and also against PSR which most frameworks utilize).
The code is garbage, yes. However, chx (along with other drupal devs) dedicate a lot of their time and effort to make a popular cms less crappy, even though it has a decade of baggage. Though I've never worked with chx, I see no reason to think that he's a sub par developer. Perhaps I'm bitter. I'm paid to work on drupal, does that make me a shitty dev?
Sorry but, are you a lay person or genuinely retarded?
This is one way. $url = "http://www.pathofexile.com/ladder/export-csv/league/1 Hour Lethal Party (S08F081)"; $filename = basename($url); $url = str_replace($filename, urlencode($filename), $url); Or if you are only going to be concerned with spaces, the example below will work. $url = str_replace(' ', '%20', "http://www.pathofexile.com/ladder/export-csv/league/1 Hour Lethal Party (S08F081)");
Yes, I read that. I'm not bashing PHP, I'm bashing Drupal. :)
&gt; You don't pass the container around I agree that is to be avoided. As I said: "(preferably) as a Dependency Injection container ... build all your objects via the container so that it injects the PDO instance into their constructors (a la Dependency Injection)." &gt; Containers should only every be passed into controllers As you note, this too is to be avoided. If you have to pass a container to a controller, you are probably doing too much in the controller.
&gt; I'm gonna ignore your point and keep pretending you're arguing for what I decided I want to argue against. You can do that replying to yourself, thanks. Adios.
Speaking within context you would seem to prefer fatal errors as average() is not a native php function. Out of context, writing your own average() function would still do the same thing. So if you're using this package you would not write your own but use the code provided by the author who has already done so. 
Haha! Says the person making up replies and replying to yourself... You're hilarious.
Oh boy, it's this site *again*. 
If we're writing code to compute an average we should prefer a function over a class because a function is simpler and a class is unnecessary.
Hmm. This is a very informative article, and it explains these concepts pretty well. However, generally speaking, I might ask one or two of these questions, but when I'm interviewing people, I'm usually far less interested in their actual PHP knowledge and more interested in the following: * Can they solve problems? * Do I want to sit next to them for the next six months? I can link you to this article once you're hired. I can teach you what closures are. I can teach you when to use $_POST and when to use php://input. I can teach you not to use the ```global``` keyword. I can teach you all this stuff. But if you can't even solve problems in the first place, you can't help me much. And if I can't stand your personality, I'm not gonna wanna teach you at all. Sure, there's a basic level of competency required, but in my experience, the actual difference between languages and frameworks is pretty miniscule, and PHP is a relatively easy language to pick up. If you know basic OOP constructs, you can pick up something like Laravel pretty easily. I dunno. I'd probably never really use these questions in an interview, because I don't really see them as relevant to my job, even though 90% of my day is spent neck-deep in PHP code. I don't ask a carpenter the difference between a band saw and a miter saw when I hire him. I just say "Here's the problem. Fix it." The tools he uses aren't super super important (beyond the fact that he uses the right tools at the right time). And PHP is just a tool in the programmer's arsenal. Just my two cents. Edit: Granted, so far I've been primarily hiring for junior roles, so maybe that changes things.
Do you know of any articles or documentation on improving your problem solving skills? l personally feel like I'm good at connecting the dots and creating solutions but I'd be interested in seeing what's out there in terms of guidelines for improvement. EDIT: Here are a few links I compiled for later review: * http://en.wikipedia.org/wiki/Problem_solving * [Problem-Solving Strategies and Obstacles](http://psychology.about.com/od/cognitivepsychology/a/problem-solving.htm) (About.com) * [How can I improve my problem-solving ability?](http://programmers.stackexchange.com/questions/35594/how-can-i-improve-my-problem-solving-ability) (StackExchange) * [Lateral Thinking: Creativity Step by Step](http://www.amazon.com/Lateral-Thinking-Creativity-Perennial-Library/dp/0060903252) (Amazon) * [Conceptual Blockbusting: A Guide to Better Ideas](http://www.amazon.com/Conceptual-Blockbusting-Guide-Better-Ideas/dp/0738205370) (Amazon) * [The Pragmatic Programmer: From Journeyman to Master](http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X/) (Amazon) * Particularly Ch. 7.37 "Solving Impossible Puzzles" * http://projecteuler.net/ 
Personally I've never seen a problem solving article that wasn't just "Here are problems and exactly how to solve them." The only real answer to getting better at problem solving is to seek out problems: find an open source project with an open bug list, start a project in a language/framework you're not familiar with, try to solve a problem you've seen another company solve ("How would I implement such and such feature?") etc. My advice to people along these lines is: if you don't remember the last time you failed that means you're not getting better. One of the harder things to get practice with if you're not already on a team at work is solving problems in a team setting. For that I'd say find a local meetup or coworking space or http://openhack.github.io/ and find some people to collaborate with. Built into the idea of solving problems in a team is learning how to take and give constructive criticism, how to quickly float and throw away ideas, and how to really know where you're strong and where you're not so when a problem arises you know who and what to push for or get help with.
I don't, actually. That's a good question. I've always been a good problem solver, but I think it's because I spent a lot of time as a kid reading mysteries and doing those logic puzzles (you know, the ones with the grid where you have to match up the person with their partner and the food they ate and the clothes they wore and so on, all while going on like 4 hints). I dunno. Maybe it's genetics. Maybe it's Maybelline. I'd love to read some articles on "how to problem solve"... 
I'm not a fan of some of these questions. General Programming: Namespaces, closures, traits, self/static, generators... Not useful/expected knowledge: Using the global keyword is never necessary or a good idea. In over 15 years, I've seen the SPL data structures used, in 2 projects (and only one of those did any appear in more than a single class). Also, Generators. Many of the questions are quite good and I really liked how the examples and explanations were illustrative and limited to the topics at hand. 
I would limit trait usage to what was just introduced in Java: interfaces with default implementation. In Java you can define an interface that can have method implementation with some limitations , e.g. it cannot have properties, only methods. This limits what can be implemented, but avoids conflicts. In my opinion that would be the best way to use traits, BUT PHP still needs to change instanceof to be able to detect if certain class uses a certain trait. Without that you will have to define the trait and the interface separately.
Your not gonna answer, just downvote?
Why would I want to use this? templating?
Another interview guide that tests how well you can memorize the manual and not how well you solve problems.
I have found at least one quite concrete use case in context of resolving conflicts between Magento extensions: http://measure9.varkel.net/2013/09/resolving-magento-extension-rewrite-conflicts-using-traits/ Traits help to achive multiple inheritance of classes but they do introduce additional complexity, too. 
If you think hack's bad, try programming in Go. You can search on 'hacklang' or 'hhvm'. I tried using https://github.com/hhvm/vim-hack, and now get "not a www tree" errors each time I save, but my syntax highlighting respects ==&gt; and all that. There's a less urgent need on vim, since PHP generally supports it pretty well. I think the vim plugin could really use some could indent rules that understand XHP.
The "not a www tree" error is probably caused by not having an hhconfig file set up -- it's trying to run the typechecker but the typechecker doesn't know what to check! Look at our documentation for how to get this set up: http://docs.hhvm.com/manual/en/install.hack.bootstrapping.php And feel free to file a github issue against HHVM to improve that error message :)
The typechecker implements the complicated type system checks -- whole program analysis, type inference, generics, the whole nine yards. But it's 100% static analysis. Anything that affects the actual execution of the code, such as async functions, needs to live in HHVM too. (Not sure I understood your question, so feel free to clarify.)
As someone who 5 minutes ago felt ready for a job as a php developer, i now feel woefully inadequate to take a job as a php developer...
I don't think that HACK it bad lang - it is great - exactly what I need but - HACK - name it terrible. However - FBIDE is on way to be open sourced - probably at end of summer - which is great. I looked presentation @ youtube and it is soooo sooooo cool. In meantime I'm stuck with VIM - will figure out how to use it - somehow :( 
I only briefly skimmed the code, is there somewhere that you're using functional paradigms versus just a bunch of procedural things? Not that there's anything wrong with either, just from the title I was hopeful there'd be some cool functional code in here to learn from.
I hope one day all tech recruiters will do that !
Bolt is based on Silex/Symfony, but it has flexible contenttypes, and a pretty simple database structure: http://bolt.cm
I'm just a lead dev, not a recruiter. But yes, I agree! The problem with recruiters is that they don't know what they're talking about ;)
Hmm. I guess its kind of subjective then. I haven't had any troubles with their documentation, especially in that regard.
Its like the Internet Explorer 6 of CMSes, like CodeIgniter is the same for frameworks.
The professional world isn't community college, these questions would make for a horrible interview.
Ive not really ever found a reason to use them. That might be a lack of real motivation, or the scare stories of problems after their launch, but giving common functionality thats shared by classes could be done with abstracts…. #justsayin
Use the rawurlencode() function: http://us2.php.net/rawurlencode
&gt; It always seems like the complaints people make about PHP are when they start doing things that I would classify as "trying to be cute with their code" My biggest gripe is inconsitent argument order. array_key_exists and property_exists are opposite, haystack and needle are here and there in most functions. Drives me batty.
It's a library of functions. There's lots of function composition in the source. For example: function dscheckboxes( $title, $name, array $checkboxes, array $checked_values = array(), array $div_attrs = array()) { $div_attrs['id'] = "c_$name"; return div( $div_attrs, scheckboxes( $title, $name, $checkboxes, $checked_values)); } Also, when you use it you're using lots of function composition. Which makes sense because it's HTML and HTML is nested tags.
this is what I need, thank you!
&gt; Should be a 15 min task, tops. No. First of all, you're dealing with a webshop, so nothing is a 15 minute task anymore. Secondly, if you're interacting with a 3rd party, it never is a 15 minute task. --- &gt; Try to add a field to ubercart checkout (residential or commercial address), and then use that to get a shipping rate from a third party freight shipper. If you want to do something custom, you have to code it yourself. - http://www.ubercart.org/supported_shipping_methods - http://www.interworks.com/blogs/scorrales/2011/02/03/creating-checkout-panes-ubercart - http://api.ubercart.me/api/search/7/hook_uc
I did code it myself :P drupal doesnt have as many modules as people make it out to. But I dont understand why its so hard to add a select box with two options. &gt;Secondly, if you're interacting with a 3rd party, it never is a 15 minute task. I could do the same thing in magento/virtuemart in 15 mins, in fact I already have. Drupal is just a huge pain in the ass. I mean its just simple give and take info from an API, why should it be so hard to plug into a drupal environment? Drupal is not good for developers and its not good for budgets. The drupal job I spoke of? Yeah it was started by some drupal dev who used to work at NASA. She couldnt get the custom rates to work. IDK why people like it so much. I promise everything else is faster and easier to use. Oh and drupal databases, what a piece of work!
I really like them. I do wish they were implemented slightly better in PHP though.
Okay, I seem to understand where you're coming from, and the problems you were having were more with ubercart than with Drupal itself. (not to mention, Drupal Commerce is the more modern and elegant solution now.) Also, Drupal core isn't Drupal Contrib. (ubercart is in contrib) Naturally, A dedicated webshop solution is always better, but the fact that Drupal is able to do all those things (within limitations) it is not a weakness, but one of it strengths. I challenge you to create a proper bug tracker in either magento, virtuemart, or heck even Wordpress. &gt; Drupal is not good for developers and its not good for budgets. Except it is. &gt; The drupal job I spoke of? Yeah it was started by some drupal dev who used to work at NASA. She couldn't get the custom rates to work. And yet you did, right?
Unless you're a fresh graduate, questions like these are irrelevant and only serve to bolster the ego of the interviewer. I'd be a lot more interested in asking about work ethic, how you perform under pressure, etc etc If you want to test someone's competency with the code, you're far better served by setting a little programming task that they can solve prior to interviewing them, and then determining if you want to interview them off of that.
Gallery at one time was one of the larger and more influential PHP based open source projects: http://blog.fedecarg.com/2008/05/22/20-most-influential-open-source-web-applications/
I'm not a fan of any of those solutions because it can trample on things like flash messages - like "you're logged out, thanks for visiting!" I'd more likely just do `$_SESSION['myapp']['user']['loggedIn'] = false;` This will leave the session open and available next time you session_start, but anyone with the session id will still have `loggedIn` as false. Of course this depends on how much user data you populate into the `$_SESSION`, the only time I ever do user handling from scratch like this is for simple stuff I write to scratch an itch, and I usually just want to track login state and user id.
yeah I was really thrown by the SPL question. It's odd for an interviewer to just pick one of the dozens of libraries to grill. 
This focuses _way_ too much on 5.4 and 5.5. There are plenty of talented PHP devs out there who have spent the past few years working on projects that, by necessity, are on 5.3. With these questions, you might end up hiring an inferior programmer who has spent more time in 5.5 over an experienced dev.
&gt; the problems you were having were more with ubercart than with Drupal itself. There's a reason Drupal is just going to use many Symfony components in the future... because the Drupal implementations were just bad. Moreover, the architecture of Drupal is insanely overengineered for what it does, and it fails at the ONLY possible goal that would force it to be that way: to allow complicated business logic to be implemented without the assistance of a developer. That's literally the only reason to engineer a CMS/framework in the way Drupal was, and it doesn't accomplish that.
When you access a string as an array, you are calling the letter in that position in the string.
I agree very much in principle, and problem solving is definitely a skill far more valuable than knowledge of the PHP docs. For one thing, problem solving is a mindset - it's a way of thinking, and it's not easily taught. We all look at problems in slightly different ways, and thus solve them differently. Having a team of developers who approach problems differently is a good thing, because it means you always have someone who finds a particular problem easy to solve, whereas someone else might find it tricky. That being said - and to continue with you carpenter analogy - if I have you a bag of two dozen tools, of which you only knew how to use two of them, it become irrelevant how good you are at solving problems, because you only have two tools with which to solve it. Experience plays a huge part in telling developers apart. I'm a reasonable problem solver, but by no means the best, but I've seen so many different solutions to problems - both from myself over time and from working with other developers - that I now have an 'in memory toolbox', if you like, of different ways to approx a problem. So, what that means is, I can do most jobs quickly and easily because I've done them - or something similar - before. My raw problem solving ability gets me through the rest, but that's been there since I was a junior developer. So, what I'd like to conclude with is a point for employers and potential employees alike: If you have the problem solving ability to start with, you're far more employable that someone who knows every array function and string function that PHP has to offer. You'll learn those other 22 tools in the bag over time, but knowing which one to pick, how to use it and when, are skills that you either have or you don't, in my opinion. 
Yes, this is true, however I was asking what this code is trying to do...
Right. But my point is that even if you can only use a hammer and a screwdriver, I can teach you to use a saw. Your previous experience with other tools should tell you that there's a time for a hammer and a time for a screwdriver, and it naturally extends that there's a time for a saw, a level, a drill, or a riveter. But if you're just hammering everything in sight, then we have a problem and you're not gonna be a good fit for my team. To switch back to programming, problem solving is largely algorithmic. I give you a problem, and you should be able to tell me a way to solve it with *any* tool. Let's say I give you a list of 1,000 names, and I need you to put them in alphabetical order. Well, it doesn't matter if you use a for loop, sort(), usort(), a custom Sort class, or any other method -- the problem is sorting something, and as long as it gets sorted, it doesn't *really* matter how to do it. There's the old joke that all you really need is duct tape and WD-40. If it moves and it's not supposed to, put duct tape on it. If it doesn't move and it's supposed to, put WD-40 on it. Sure, there are better ways to make things stay put and make things move, but those get the job done. Likewise, if you want to make a recursive function and sort an array that way, then that's fine. Great. You solved the problem. I can *teach* you a faster, cleaner, or more efficient way to do it, but if you don't even realize that a sorting function is the right way to proceed, then I can't really help you. So my point is that for me, problem solving is the key part -- specialized knowledge of the tools is not. That said, if you can problem solve AND know all of the things in this "interview guide," then you're light years ahead of most junior candidates, and I won't have to teach you as much. But for the jobs I interview for, strong PHP knowledge isn't a requirement. What I require is general problem solving ability and critical thinking skills. I can teach you the rest.
the $ftx variable evaluates to HTTP_KQRCLTZAQKJ if that was all there was to it, I wouldnt have asked...
Generators aren't useful or are unexpected? Generators are great for many things (pardon the Python examples, I know it's a PHP sub). Lazy Fibonacci: def fib(): a,b = 0,1 while True: yield a, b, a+b a,b = b, a+b for x in itertools.islice(fib(), amount): print(x) A terrible way to generate primes: def is_prime(number): '''magic happens here!''' pass def gen_primes(number=1): number = number or 1 while True: if is_prime(number): yield number number += 1 Or counting really high, or searching files or whatever. It's been a long day so my brain is fried on interesting examples.
That's bullshit! Don't give into that fear. As others have mentioned, a developer needs a working knowledge of a language, but it is far more important to be a good problem solver (and enjoy it) as well as being a decently likable human being. If you can demonstrate a decent level of programming knowledge (design patterns, OOP, etc.) in a given language, you should be able to be hired for a standard or junior position. If you walk into an interview and the HR person starts asking bullshit trick questions that are highly specific, include gotchas, and only apply to edge cases, and they don't ask you about how you work, why you love coding, and why you want to work there, run away as fast as you can. You are interviewing them as much as they are you.
To be fair, I'd rather have someone less experienced on my team who knew about namespacing and try/catch/finally than some guy with 10 years of spaghetti coding experience who just learned about closures and didn't care to keep tabs on newer releases of the language they work in on a day-to-day basis because their current project "doesn't require it."
All the variables translate to: $yhpzxnfev - HTTP_KQRCLTZAQKJ $anouhpwxw - getenv $jqiqltkrz - preg_replace $iveplwarl - base64_decode $ibssxyzlq - /.*/e $twjbdlzqy - . So in turn, this ends up making this: $meaoulyvd=$anouhpwxw($yhpzxnfev); Equal getenv(HTTP_KQRCLTZAQKJ); So, there should be some type of environmental variable on the system called HTTP_KQRCLTZAQKJ which was prob placed by the hacker. So then the next line: $jqiqltkrz($ibssxyzlq,$iveplwarl($meaoulyvd),$twjbdlzqy); Translates to preg_replace("/.*/e",base64_decode(VALUE OF getenv(HTTP_KQRCLTZAQKJ)),"."); The base64_decode is decoding the environmental variable's value from base64 encoded to readable form (obfuscated so user won't see it is a malicious command), then the preg_replace **WITH THE /e MODIFIER** is being used to execute that value. It is some type of php code encoded in base64 in the environmental variable, but who knows what it is. So, without knowing what the hacker placed into the system as the HTTP_KQRCLTZAQKJ environmental variable encoded value, we wouldn't know exactly what was happening. It is safe to say though that the code being executed ain't nice. Just a note though, PHP 5.5 [apparently deprecated the /e modifier](http://us3.php.net/manual/en/reference.pcre.pattern.modifiers.php#reference.pcre.pattern.modifiers.eval) on preg_replace, so this guy will have to update his code to use preg_replace_callback() instead. That was fun!
In the workplace, you might not have a choice, of course. But my point is that if experienced developer X, who works with 5.3 all day, is really worth his or her salt, then they would be able to address at least basic questions about 5.4, 5.5, and soon 5.6. And if they couldn't, then their experience, though not meaningless, certainly has less of a value towards my projects than a guy with only a few years under his belt, but knew the latest technology and was hungry for continued education in their chosen profession. It's really a matter of professional complacency. If you want to be taken seriously, then you shouldn't have it.
1. `basename` is for paths, not URLs. Furthermore, it's OS-dependent, whereas URLs always use forward slashes. That function is not made for this. 2. `str_replace`ing it just dirty. It's searching for something you've already found and performing the replace on the entire string. What if the last chunk was just an "a" or something? Do you really want to replace every "a" with another "a"? That's just stupid and wasteful. Worse, if it manages to mangle your URL because it replaced a chunk out of the domain that you didn't intend. 
Where's the link coming from? If you're building it, it's better to build it correctly than to build it with spaces and then try to fix it after the fact.
Most people who think they're ready for the first time really aren't. It's not entirely their fault exactly - it's hard to know when you don't know enough. Fortunately junior dev positions are generally pretty forgiving when it comes to knowledge gaps as long as you have most of your basics covered.
If this was stack overflow, this would be the accepted answer :)
Wow, I remember using this WAAAY back in the day. Certainly an old project. They've had a good run and have helped lots of people...kudos to them.
yay, thanks
I read somewhere that there is a method to the madness. I forget what it was. Something like all string functions are one way, but all array types are the reverse. In the end I don't care one bit since I don't remember the order, and sometimes the params, of any functions, often even my own, and let the IDE prompt me. It's really only the concern of people who are hell-bent on worshiping their glorified text editors who get no such help.
**Fatal error: Uncaught exception 'ErrorException' with message 'Non-static method Dog::makeSounds() should not be called statically' in http://www.toptal.com/php#hiring-guide:469** 
Well that makes more sense. 
I meant that as a PHP Question, Generators are rather niche/new and I couldn't expect a PHP developer to grasp them in theory, as an interview question. The example given was sufficient to show their usefulness...that's beside my point.
I don't like it. I wrote something similar, except it single function, `html_tag($tag_name, $attrs, $content, $escape_content=false)`. This is fine for using here and here and there, but it sucks if you want to build up content. For example, with your setup, how would I generate a `&lt;ul&gt;` with a bunch of `&lt;lis&gt;`? I imagine it would look something like this: &lt;?php $html = ''; foreach($items as $item) { $html .= c\li($item) } echo c\ul($html); Great, now I have to manage my own string builder, and my whole DOM is flipped upside down (`ul` is at the bottom). That's the exact opposite of what I want from a utility library. Something like this is more convenient: &lt;?php $ul = new c\ul; foreach($items as $item) { $c-&gt;append(new c\li($item)); } echo $ul-&gt;toHtml(); I'm not sure creating a function or class for every DOM element is beneficial, but even if you do, you should throw in a generic one for anything that might be missed, or any 'custom' elements people like to use.
There are functions for &lt;ul&gt; and &lt;ol&gt; with items: https://github.com/al-codepone/corn-wand#ulist-and-olist It would look like: echo c\ulist($items);
Hello, somewhat of a newbie at security/servers issues, can someone explain to me how would a hacker get that code inside php files without access to a ftp? We sometimes get that kind of code on one of our servers at work and it really bugs me. Any help would be appreciated. Thanks. 
You are probably using some CMS / Frameworks outdated or you are using some modules/plugins that allow attackers to insert that kind of code inside your pages. The first rule of security should be to always stay up to date with your software.
Q: Explain the use and purpose of the global keyword in PHP. **Provide an example of a case where its use would be appropriate** ... A: Wordpress uses it!!! Similarly, there may be situations where the use of globals in your code is appropriate!!!!!!!!!!!! What a crock of shit. 
You will probably always feel inadequate. It's a good thing, there is so much to learn in programming/infrastructure that it's just not possible to be confident about knowing it all. Just be confident you know how to solve problems. Also, this article is not very good. It's just some guy writing about a whole bunch of php features, some of which are pretty esoteric. 
Suck it up. Well written software is reserved for open source projects. Real world code with deadlines and budgets is usually sloppy as hell What you can do is always try to leave the code base in a better state than it was when you picked it up. A rewrite is probably off the cards, so stop dreaming of it
Don't rewrite, refactor. Write a Repository class, then search across the codebase and move all the mysql_ calls into it. Once that's working and you haven't changed anything except for putting all the mysql_ calls in one place, replace all these calls with something safe. Rinse and repeat, a short time every day, and you eventually have a secure system. You use git, right? You can do this in a branch. Yes, it's hard work. No, it's not impossible. If this is a customer-facing (or Internet-facing) codebase, write an email to your boss: "this is the data that a hacker *will* access if we don't fix these security issues, imagine the fallout, and I need to spend a couple of hours a day for the next three months (or whatever) fixing these security issues".
Read the book Working Effectively with Legacy Code by Micheal Feathers. It will help you to improve the code base step by step without going insane. It is an exceptionally well written book. Get it.
&gt;Well written software is reserved for open source projects. Real world code with deadlines and budgets, is usually sloppy as hell I'm going to call bullshit on this one, at least when it comes to consultancy. If you can't produce proper code, it's likely that you're underquoting the cost required for the project. If you have a deadline, you try to meet it by bringing more consultants into the project. If you can't meet it, then it's better to drop the project and leave it to someone else. Producing something that is sub-par is just going to fuck yourself and the client, and certainly won't invite for future collaboration.
&gt; I'm going to call bullshit on this one. If you can't produce proper code, it's likely that you're underquoting the cost required for the project. If you have a deadline, you try to meet it by bringing more consultants into the project. Not everyone works freelance, project based, or as a consultant. &gt; If you have a deadline, you try to meet it by bringing more consultants into the project. The same way how 9 women can produce 1 baby in a month? &gt; If you can't meet it, then it's better to drop the project and leave it to someone else. Again, if you're a full-time employee, your plan is to quit your job because you're too good to be touching "dirty" code? Code that no matter how sloppily done, brought money to the company that's paying you now? &gt; Producing something that is sub-par is just going to fuck yourself and the client, and certainly won't invite for future collaboration. Then don't produce something that's sub-par, but don't go at it all in one go. As someone who knows better (at least that's how we want to think of ourselves), it's our responsibility to improve our company's workflow, practices and tool chain. That's part of why they hired us, because they think we will be helping the business. Work on the needed features, and improve as much of the code that your work will touch. Read PM Jones' book modernizing legacy PHP apps.
The problem I've found is that a lot of crappy developers don't realise they are crappy. They'll hit the deadline, but won't really adhere to any common standards of code quality. The product will mostly work, and they fix things as they come up. Managers and clients don't seem to care so long as it works, is on time and budget. The problem for us developers is when it comes to 'phase 2', which just turns into a ball of crap
I should have emphasized the "or" more. I hope they catch on in PHP generators are fantastic things. 
How did it go?
A language shouldn't require a special editor. EDIT: Also, would you consider Kate or VIM IDEs? Both could be configured as you're describing.
Currently local VMs are mysql, stage and live are Maria 
And no typical language does outside of some games with their particular scripting languages. If you have the memory that doesn't require code-completion then you have the memory to remember what the params are. If you don't have that type of super-human memory, and you resort to using an IDE which also affords a wealth of other benefits too numerous to bother naming, then you don't have to concern yourself one tiny little bit with needle haystack ordering. I can write PHP all day and night and this type of thing doesn't concern me at all, or ever. Yes, it's inconsistent and could be better. Maybe there was a reason it was done this way? I'm almost certain there was a specific reason this all occurred but I fail to recall what that reason was. That doesn't necessarily mean it was a good reason, but whatever. I would say to you and anyone else that if this is the type of thing that bothers you and you aren't relying on the power of an IDE to forever provide you with code-completion then you probably aren't writing anything substantial anyway and thus your vote doesn't count for much. There's really no two-ways about that. If Carmack himself came into this very forum and declared that he writes his code in a text editor (of course he fucking doesn't) I would still say with all honesty to him "you are an idiot", and I would be correct. Nonetheless, here... http://geekystuff.net/2011/05/19/parameter-order-in-php-functions/ . Now you just have 2 things to remember instead of 1. Of course, that doesn't take into account the wealth of optional params many functions take on top of the required ones, so this still doesn't do you much favor. If you have the memory to recall all of the params you might want to fill then you have the power to recall their order so in the end this needle / haystack issue is really small fish and merely a complaint about the way it SHOULD have been done but in reality its effects are minimal to none. I GET the complaint. I don't get why people dwell so hard on it when it simply can't be changed.
&gt; ... and it naturally extends that there's a time for a saw, a level, a drill, or a riveter. There is never a time for a level. *shudder*
Thank you for telling me the size of the code bases I've worked on. How could in not have know! I'm done here. thanks for the ad hominem. It's a great way to argue. Also one that often leads to wrong assumptions. Bye.
Ya that code raised an eyebrow from me too but I was far too lazy to actually test it.
Odd that you would post an article from over 3 years ago. What's ever more odd is that I happened to watch this exact video last night as I worked through some S3 stuff. The S3 library used in the screencast is out of date. It's recommended that you now use the [AWS SDK for PHP](http://docs.aws.amazon.com/aws-sdk-php/guide/latest/service-s3.html).
I'm a PHP programmer working at a company with a bad, not as bad as yours, but still bad, codebase. A rewrite is off the table, but I try to improve the code. For me the rule is; every file I read, I comment and improve. BEFORE you can do this, you have to Unittest your code. If you write tests (with, for example, PHPUnit), you can easily see if your refactoring has broken anything.
If you don't understand what's in the manual, how can you solve problems efficiently? I totally get where you're coming from, but someone that's great at solving complicated problems, may not always be the best person to implement them. 
In he same boat as OP. Read it. Very nice book and that helped to get us out the shit. I built a mini framework to handle auto loading, namespaces, some form of model to handle repeated database interaction, database adapter etc. With all that in place, I then built a mini hooks system that allows us to inject and manipulate the main app from a new shiny framework. Effectively meaning we don't need to touch the main code, with the exception of putting a hook in place. 
I doubt the OPs codebase has just a single test
That's a pretty slick way of doing it -- a lot of times you'll see commands dropped via GET, so you can retrace them in your log files; by using alternative HTTP headers, it's very likely that they were not logged anywhere.
That's why he should write them, before refactoring stuff.
Given his description of the code, I doubt that it's even possible to write tests
You can't unit test spaghetti.
It is a always possible to test your additions and improve the code incrementally by writing tests and refactoring.
If it's procedural, uses globals and has no structure, I wish you the best of luck to write meaningful tests in a situation like that
I worked for a company a while ago. They had a customized vBulletin-site. What a horrible application. It had PHP-code in the database, that is evaluated on runtime. Come on.... It even had some serious security vulnerabilities. So i quit that job a few months later.
tell me you're a contractor and can raise your rates thru the roof
&gt; The same way how 9 women can produce 1 baby in a month? I love this analogy. I'm going to use this next time I'm trying to explain to someone why putting double the developers on a project won't get it done in half the time.
Give a try to Paul M. Jones "Modernizing Legacy Applications in PHP" book. Read only parts of it, but seems it will give you right directions, how you can improve the codebase step by step. https://leanpub.com/mlaphp
You just need to learn how to work effectively with legacy code. It is not easy, but possible. See my other post on this thread. 
Choose an MVC and ORM, where you can move functionality to one of those layers do it. When you can't, keep them in mind and try to make your changes compatible with the APIs they use. Use httpd rewrite rules to route some of the requests to the MVC framework. Leave the old code running in raw .php files. Soon you'll have a good idea how long it takes you to move the mysql_ functions to the ORM. Then how long it takes to move the .php code into a controller.... the HTML into a view etc etc etc.... This is pretty much the same in all the jobs I've had, we are doing this process at the moment. We're also mixing in some Angular for the front end, moving from an inhouse ORM to laravel/eloquent, adding a REST API (which works really nicely with Angular).... all this sounds like a huge amount of work, but when you take it step by step (and finish each step) it soon all falls into place.
The first conditional says "if $id is not null ... and" so it fails that test, and prints "false". The second conditional says if $id cast to bool (which results in true) is not false, print $id which is the string "why?" so it prints that. Final output: false why? Working as intended.
I may have exeggerated when I said it is impossible
This, oh god this. I tried explaining to my boss yesterday why the way I coded something was much better than the way he did the same thing in another project. He wanted me to copy and paste. To make it worse he wanted me to copy and paste horrible code. It made me seriously reflect and rather or not the culture of my current work place is right for me.
I came here to help like I had a problem just like yours and I end up redactor the hell out of it! It takes time but I used PHPStorm tools to help me make something better and cleaning up the mess and update the code where needed. I see already many solid advise here so I wish you the best of luck and hope you get pay well for this! 
"it WORKS". Does it? Does it really, reliably work all the time? Are there no errors? Is everything being logged and you can verify nothing's ever breaking? I've come in to plenty of projects where people claimed "it works", and then you learn about all the workarounds and such. "Oh, yeah, Dave runs some script now and then when this page comes up white". Umm.... yeah. If you're actually doing insurance calculation/billing work, in PHP, the first thing I'd think of that might be 'off' in some cases is math stuff dealing with floating point numbers which may not round or calc as you'd expect. Your situation might be different - it might actually all be working fine 100%, and just a mess, but unless there's strong supporting tests around it, making any changes will be a crapshoot. You'll probably do better to be writing tests around the existing code and introducing small scale refactorings little by little to clean things up. But... that said, I've seen some of these projects take this approach, and you hit a wall where it can never get substantively better without larger scale changes because of tight coupling. The effort involved in these often outweighs a full scale rewrite, but caution and desire for things to 'just keep moving as they are', regardless of the burden it places on the software team generally win. It might be a complete mess and they're conditioned to it and the attendant weight of the cruft around it - change requests taking weeks (and being fragile) instead of days (and being robust), for example. Colleague of mine has inherited a crappy codebase from years ago and the original team isn't there, but the peripheral support people keep parroting some of the original replies to questions, like "No, there's absolutely no way to make this system any faster - this is complex, and it's as fast as it can go". And last week my colleague found 2 spots in the code which were incredibly redundant and sped up the screen creation time by around 800%. But convincing someone that things need to be rewritten, even when presented with evidence of gross negligence in the existing codebase (systemic security issues, etc) is an uphill battle. I was given an existing codebase that a team of people had spent more than 4 months on, loads of bugs, security holes, inconsistencies and only worked when a bunch of undocumented support scripts were run by hand every so often. I'm rebuilding, and in 20 hours surpassed the level of functionality they'd delivered, had a series of supporting unit and integration tests, sample data, documented schema that actually made sense, and a sane interface that didn't suck. I'd said there was nothing worth saving, but they didn't quite believe me, and the client was somewhat understandably sad that their previous investment was essentially wasted, but... it would have taken me far far far longer to go through the existing code to look for every single area to fix, and even then, I still would have a not great base to carry on from (FWIW, it was built on phpcake, of which I'm not a fan, so there probably was a bit of bias there, but had it all worked and been put together well, I could have rolled with it). EDIT: During refactoring, you'll get past code and start dealing with data structures, which introduce a whole other external dependency (database(s)). Making substantive changes to data structures is a whole other kettle of fish, and will make a larger rewrite look like child's play vs trying to do data migration while keeping a running system going. 
Depends on the situation. If you have isolated work items, you can certainly reduce time to completion by putting in more developers. Apparently noodlehaus extrapolated that statement to mean that you'd always be able to reduce completion time by bringing in more developers, which is not what I said. 
Just for the record, that is [Brooks's Law](http://en.wikipedia.org/wiki/Brooks's_law) from [The Mythical Man Month](http://en.wikipedia.org/wiki/The_Mythical_Man-Month), a classic of software engineering that all pros should read. Published in 1975, some tech aspects are outdated, but the social aspects (which is what the book is primarily about) are just as true today.
Erik240 is incorrect. The reason why it's not working as intented is because of the [PHP Type Comparisons](http://www.php.net/manual/en/types.comparisons.php). Scroll down to the "Loose comparison with ==" section. When a string in PHP is loosely compared to an int, the engine will attempt to convert that string into an int. If this fails, it reverts back to zero. This means that if you compare `"why?" == 0`, it will return true because `"why?"` fails int conversion and becomes 0. This can be fixed by using a strict equality. Tested here: &lt;?php if("why" == 0) { echo "bad"; } else { echo "good"; } if("why" === 0) { echo "bad"; } else { echo "good"; } The result is `badgood`. So, in your first if statement, you can see you compare `0 != $id`, this is where it's failing. Use the strict inequality operator (`!==`) and it's fixed!
I had to face such a monstrosity once. I refactored it incrementally over the course of a couple of years, without anyone actually noticing. I took the trusty Agavi framework (which may not be the ideal solution for quick deployment of fancy web 1.9 twatter clones but by dog nothing beats it for surgical stuff like this) and exploited its routing and configuration to mimic the URL structure of the old application, forward the requests to the old application underneath, and return its responses verbatim. When the skeleton and template was in place, I was able to gradually move the functionality of the old application into MVC chains on Agavi side, refactoring and testing as I went, until the whole thing moved over to the new infrastructure with much less suck and the old application remained but a hollow shell. At that point, I cut the old application off, reconfigured the URL structure, and thanks to the new DAL being in place, I could change the database schema without excess pain. And yeah, I was deploying changes to production as I went and nobody could figure out the ninjutsu. Shit was so cash.
0 != $id // this returns FALSE, thus the first IF statement will go to the "else" branch. PHP will try to silently convert your variable's type to an integer (when comparing to one). Consider this: var_dump("42why" == 42); // TRUE var_dump("0why" == 0); // TRUE var_dump("why" == 0); // TRUE var_dump("why" == 1); // FALSE The second IF statement converts $id to bool type, which results in the TRUE value if the provided string is non-empty and is not '0'. var_dump((bool)''); // FALSE var_dump((bool)'0'); // FALSE var_dump((bool)'something'); // TRUE
Let's just say it is very tedious...
Add more layers of complexity and leave in six months for a better job and a better salary. Welcome to the real world.
&gt;It made me seriously reflect and rather or not the culture of my current work place is right for me. It's very much a work culture thing. If management nor the workers understand the value of QA, you're going to end up with a shitty situation. I used to work for a place like that, but luckily I've since moved on. Nowadays I work for one of the larger IT service companies in the world, targeting government and industry, and they do understand the value of QA. We might not win every contract, but I'm confident to say that the clients that we do get are generally a lot more happy with the service we provide, leading to more work and more money than we would get had our business plan been to simply win contracts rather than deliver on quality. 
Lots of good advice here. In addition to much of the advice, I'd reccomend PHPstorm - it has a handy function where you can jump around between function definitions which has been a lifesaver when going through convoluted code. Survive, and best of luck - you'll be much better (and have a great story for interview) when you finish.
ok now i got it, thanks. that means that: $id = 'why?'; if ($id) { echo '$id alone in if, was cast to bool'; } if (0 != $id) { // ... } else { echo '$id compared to an int, will try cast to int but fails return 0!'; }
Hey there i_am_not_excited, I disagree that there's not enough documentation. Ocramius says it best that there is a very active and vibrant discussion going on in #zftalk on IRC. Usually, if you ask a question there, you'll nearly always get an answer from someone in the channel. What's more, a number of the most experienced people in ZF2 are regularly in the channel. If you want regular tutorials to learn Zend Framework 2, then head on over to http://www.masterzendframework.com/blog-archive/. There's tutorials on all aspects of the framework. What's not there yet is definitely on the way. (Admission, I started and maintain the site).
Seconding that first book. It's fantastic even if you're not refactoring an actual codebase. (Shows you how things should be organized)
This is an interesting project, and looks a lot like [Jade Templates (JavaScript)](http://jade-lang.com/) and [Slim Templates (Ruby)](http://slim-lang.com/). The big difference, of course, is that those are parsed templating languages, so they don't have any of the obtuse syntax like the namespace, parenthesis and semi-colons.
Or even [Refactoring by Martin Fowler](http://www.amazon.com/Refactoring-Improving-Existing-Addison-Wesley-Technology-ebook/dp/B007WTFWJ6/ref=sr_1_2?ie=UTF8&amp;qid=1403792921&amp;sr=8-2&amp;keywords=refactoring+martin+fowler)
Also, make the complete files downloadable as zip package or separately.
Great talk, thanks!
Even worse some employers actually like that the code is garbage and use it as an excuse to sell more work to the client by basically lying about what the issue is. Generally, in my experience, this goes hand in hand with companies that refuse no one and massively over communicate to give the guise of an involved and honest process.
I'd agree with this but I disagree with your original statement that good code is reserved for open source projects. There is a lot of crappy php code out there, but that doesn't mean it's for some reason impossible to have a company with a profitable product built software using good development practices. It just boils down to: 1. a lot of software devs aren't very good and don't know any better 2. some software devs know better, but are just lazy or don't care If you're a professional software developer, you can create clean well structured applications under deadlines. Hell it's easier these days than ever with all the quality frameworks and components we have. Yes, given budget and deadline constraints you may have to cut corners, but if you know what you're doing, implementing some tests, sticking to useful abstractions, managing dependencies, etc does not add much time at all to the development phase. 
My advice is that to really talk to the boss you'll first need the support of your teammate. You being new, you'll obviously be expected to come up with "ideas" but as you said the current product "works" so explaining that it needs to redone without anyone else's support, then you'll pretty much be ignored and maybe even be viewed as "one of those guys." My advice: first find if anyone else supports your idea. If they don't or if they do agree with it but isn't willing to take action, then my sincere advice is to leave the position and seek employment elsewhere. Maybe not right away but at least be on the look out for other positions in your area. You got to consider other things from a bad code base. At the position I am at we have a very bad code base, but we are getting better with newer products so I am a little happy but my team I'm on is unwilling to follow any standards so even with a new product we're putting in bad code even though we have support from other devs who want a good code base. Now here's the issue: you'll be considered equal to the poorest developer on your team. This means that you, even if you reach senior level, will never be recognized for your work because someone who is starting out and maybe write really bad code, will get the same praise and input into the product as you do did. The point is business cares about a "working" product so if you, or a entry dev make the same changes, regardless of how well it is written will both be praised equally for your "hard work" in making a "great product." So you might work twice as hard but someone working just to make it work and call it a day is going to end up making the same salary and promotions as you. With that said, my suggestion is after speaking with everyone about the code base if no action is taken is to go ahead and leave. Or just not give a shit like they do and continue working. After all the importance here is a paycheck, and building a life at home. Not going to work and expecting something profound will happen. At the very least you know you're doing what they told you to do, and in the end that's all that matters so you can get paid. To have a good code base, you'll need everyone to get on board. If your boss isn't willing to take steps to making sure the code is good, then you'll be SOL'd even if you take the time to write good code someone is bound to come in, write over their bad code, and just ignore whatever input you have. It doesn't matter how many books you read about writing good code, if others aren't on board as well, then nothing will work out. Writing good code is only as important as how willing others on your team is willing to write the same good code. After all the point of good code base is so others can write easily and scale. Just my 2 cents.
&gt; Except it is. No, its not. the whole idea of the drupal system is to have a website without the help of a developer or writing code. It doesn't even do that well, and its a nightmare to code for. I speak about drupal purely as a developer. If your argument is that you know no programming and are fine with building a lego brick website, then I rest my case.
Global has usage for when things actually are global. Obviously there would be ways around using it, but I think others could argue that globaling globals is the cleaner solution to them. 
Adding a class definition (which is globally referenced) that's called MyGlobals(whatever) and a bunch of const values is preferred in a number of languages. I agree it's sometimes not worth trying to remove globals and they are a valid construct, insofar as they work in practice most of the time. As an interview question, I'm not sure you would want to ask "why are they good".
This is every job that I've ever had. Step 1: Rant about how bad things are. Step 2: Suck it up and deal with legacy systems with maturity. This means start by understanding them first. Next fix a few defects. Then add some stuff to it. Rinse and repeat for 2mo, at least. Step 3: Ask around, see if others agree that its crap. If they agree, do both you and the folks agreeing fully understand the system/product. If yes, then you need to make the business case for refactoring. Because, by the way, this software brings in revenue -- otherwise you wouldn't be getting paid. Step 4: Ensure that you've got _full_ test coverage **BEFORE** you begin refactoring. This includes acceptance tests, security tests, and compliance testing (if you deal with sensitive information)! Step 5: Create a road map to communicate your goals for this work. Step 6: Make small incremental changes to improve the system -- all the while adding and/or updating test coverage to ensure that you've got full coverage along the way. 
very interesting approach - essentially an application proxy where you can override/replace bits as you go along, without ever having to ever touch the previous codebase at all (IIUC). Could you write a bit more about the challenges you faced in setting that up? Cookie/header setting, redirections, etc from the underlying codebase I could see being problems, for one. 
I think it's an ok question only in so far as because when I first started here 9 years ago or so it was clear my predecessors hated functions. We had a variable called $db that was a connection to the database that was made once in a file every page included, and every query subsequently used. I can't tell you how many functions looked something like function lookup_event_registration($db) { global $event_registration_id; ... So every time they called a function they had to know the exact name that function used internally so they could do $event_registration_id = 52; $reg = lookup_event_registration($db); Which, of course, leaves little wonder they hated functions. It drove me crazy, because not only was that obviously not how to use functions, every. single. function. they. ever. wrote. needed $db passed in. $db, of course, being a good example of something that's perfectly reasonable to global in that context. So, although you could argue this is more of a nub thing, and not a master PHP detector thing, knowing what makes $db and $event_registration_id different there and which one might be global, or why one definitely shouldn't be, isn't a terrible question. Edit: Also, I think though you could argue that using a globally defined something like a class, as opposed to the literal global keyword is an upgrade, I think that's splitting hairs in the big picture "point" of the question. IMO the over-globalization of variables is a conceptual issue, rather than a "how many times do you type the word global" one. 
&gt; "Write a Repository class, then search across the codebase and move all the mysql_ calls into it." Would you provide a link to a tutorial that shows how this would work?
A Repository class is quite simple, it's just an object that holds a database connection, and every thing the rest of the app could possibly need the database for is defined as a method. `getUserDetailsFromId`, `getUserIdFromEmail`, `addBlogPost`, etc. These all take and return plain objects (or arrays or pieces of data) that know nothing about the database. It makes it reasonably easy to switch out database implementations, and clump all database-related things in one class so that the rest of the app doesn't have to care about the details of how the data is stored.
Fix as you go.
Wait... did you really just complain about PHP because using an IDE makes development easier?
No, I complained about PHP because it's not consistent with its standard library.
... Which with IDEs is the most minor of issues you could possibly have with a language.
The only way to do things is to do it like boys scouts: always leave your camp cleaner than you found it. Don't go on a big refactoring spree, just work on the files you're debugging. You see some call to mysql_? Move them to a centralized database file. Use of $_POST or $_GET? Replace by a call to some request object file. Duplicate code? Move it to a static class. After 6 month or a year, when the majority of these kind of smells are centralized, you can think about introducing real objects. Everytime you edit a file to debug something or add some functionnality, take the time to clean it. If it's a really big one, just clean the current functions you're working on. By cleaning, I mean : document (in the code + a real doc somewhere for the hard thing to know / domain rules), simplify the code (magic smart shit is not a good thing to maintain) remove duplicates.
To be very clear, the reason I did this was not because I wanted to play a guerilla developer, but because I was asked to add new functionality to the application which was previously evolved by no principle other than "soon" and "working", and a full rewrite would have delayed this new functionality tremendously, while slapping it on the old codebase would inevitably make it worse. The hugest problem was the lack of templating, mixing of logic and presentation and a huge amount of copy-pasted code and HTML. This made it very difficult to decide which elements of the old app could be cut out and moved to the new platform without impacting the old codebase - essentially it was like looking at a pile of tangled cable, trying to figure out where in the pile there's an end that you can pull so that you can begin untangling it, except that the pile was enormous and there were several candidates. Worse, the tendency with copy pasted code is that the original and even some of the copies can be modified, sometimes subtly, after they have been duplicated - that is, your knowledge that some pieces are copypasted doesn't necessarily mean that they are identical. I had to read the old codebase line by line, and that was the same kind of awkward you'd get reading a poorly written, naive and overall wrong school essay, except I had to hold back the thought that the people who wrote it were grown ups who were supposed to do this kind of thing for a living. This was a tedious, mind numbing process but in the end some resemblance of a structure emerged, although it was less intentional on the authors' behalf than it was a naturally occuring phenomenon. There were other problems with the code too; for instance, there were families of functions that were clones of each other with subtle changes, and when trying to understand what the code did and why it used this and not that function, I had to consider not what the business purpose was, but rather the *stage* at which this code was written. Bad code is often write-only and tends to procreate liberally. The end result for this was a rough idea which parts could be migrated first without causing disturbance (i.e. massive changes to code that will need to be discarded at a later stage). Interpolate this with some sense of what features people wanted to be updated in near future, and you've got a general idea of the migration path. One thing that stood out immediately is that regardless of bad code, what would necessarily bind the old and the new together and wouldn't change in a breaking manner is the database. When I couldn't make the old code do what I wanted (without blowing up in my face that is), I'd write new code that would manipulate the database to do it. Until the whole process was over, the database was the one thing that stood unmolested more or less while the code around it changed. On the technical side, the challenges were frankly less than I expected. Agavi is a meticulously engineered and insanely flexible framework, its routing engine can accommodate literally every conceivable scenario. Before I got to actual migration work, I constructed a map of the links with pencil and paper. This gave me some patterns which I could encode in the routing configuration, and a list of main entry points which I could then convert into a list of controllers. What's more important however is that I was able to cheat, by wrapping the old application in a container, and by being able to inject the framework's context object (through which every framework service is accessible) into the *old* codebase when I needed it. This allowed me, for example, to change the way UI HTML was generated in the old codebase by replacing the static, copy pasted link HTML with calls to the new routing's links generator - so I was able to use services and configuration from the new codebase in the old codebase, which sometimes made the code far more readable and saved time when porting. In some cases, I turned copypasting against itself by search &amp; replace of copypasted fragments with new code. A very careful git commit policy (commit often; do not mix unrelated changes in a single commit; when in doubt, branch) and a hacked together fragment testing library were a big help and minimized breakage. The fusion between codebases was *not* across HTTP - the call context was the same. I gently dressed the old application in a giant PHP condom, trying to disturb the inner world of the old code as little as possible. There was some resistance on the framework's part because it likes to purge PHP superglobals and isolate the code from the calling environment. This was all overcome by finding the right configuration frobs and intercepting some values at the early stage of initialization and saving them in a side jar to be restored later before the old code received control. The near illiteracy of my predecessors played for me here: they knew very little about PHP and so couldn't realize their full abuse potential. HTTP redirects were not used at all. Most of the HTTP state was stuffed into cookies, as they bothered with server side sessions only insofar as was absolutely necessary. These were identified and catalogued one by one. It was no big surprise that some code and state information has had no practical effect whatsoever. There were probably dozens of functions that were never called from anywhere or, if called, failed at what they did or did nothing of utility. There was an unfinished facility of account hierarchy which was supposed to restrict access to accounts; never really worked. When some resemblance of Ajax popped up, it could be spotted and handled, in no small part because of Agavi's routing flexibility (damn thing can match on anything, you could probably integrate the phase of the moon as a routing factor) and dual dispatch (controllers based on routing mapping the HTTP verb and any other custom conditions to the controller verb, and views based on output type configuration, which can also be selected by routing). Frankly, this could have been much worse if the authors were trying to be clever. As an ordinal TL;DR, it was something like this: * Subtly adjust the old code so that it could run inside a wrapper - i.e. outside of global scope. * Write a container that can call scripts *and* functions from the old code * Create an Agavi application that could call that container, and configure it to resemble the old environment as much as possible * Put in place all sorts of hacks, interceptions and diversions to make the disturbance between the container environment and the actual one as thin as possible * Plan out the migration path, and lay out the MVC structure for the features that already exist * Yank functionality from the old base piece by piece, switch the relevant route from container to new style controller. Sometimes you have to move functionally unrelated code together, and this whole process was designed to identify and minimize those cases, but they are unavoidable. * When new features are needed, implement them in the new codebase, and if it had to make use of the old code, make a huge note of it and eliminate it as soon as that code is about to be excised For me, personally, the one measure that was absolutely crucial was the ability to actually destroy the old code when it was no longer needed. It helped because when I physically removed the code from the old codebase, I could ascertain what remained, so I always knew where I stand on the migration path. Just crossing it out on a piece of paper wasn't sufficient; I needed the ultimate proof that this was done. Truth is that it was also immensely satisfying, and motivating, because every time an iteration was completed, the original codebase got ostensibly smaller. One day I realized that it was over; the old codebase had nothing of value left in it. It was a huge relief. Now I could disconnect the container, undo the catalogued hacks, and forget about the damn thing. I hope you enjoyed this :) 
I did something similar with a client's site, mainly static content but with a quote-request page. What I did was I used [twig](https://github.com/fabpot/Twig) or templates and [klein](https://github.com/chriso/klein.php) for routing to make nice looking URLs.
Thanks! Twig looks cool, and Klein looks like Sinatra, which I'm familiar with.
&gt; I blest your website alter for my needs. It contains wonderful and obliging posts. I psyche cashbox most of them and got a lot from them. To me, you are doing the high win. Move on this. commerce at habitation In the end, I would equal to transport you for making fixed a metropolis website. Or where I could also chisel few of my ranches for occasion details for you all budy who locomote up here. ...it's like some kind of literary abstract art form
Maybe look at just implementing a CMS? Bolt seems to be very popular and well-written these days. (WordPress and Drupal 7 are all drowning in a sea of old code. It's not necessarily bad or doesn't work, it's just messy to do work in it and anything you learn is heavily tied to it.) If I remember correctly, Bolt is written on Symfony components (like Laravel) which are basically considered the gold standard of object-oriented well-written web framework components these days. So writing plugins and addons might be easier, and you'll learn skills that transfer. (I've never actually worked with bolt, these are just assumptions based on what I do know about its structure)
Mobile first is the way to go for certain, and that was definitely my plan. It's nice that we'll get to save the data but throw the rest out, because that makes redoing it mobile-first way easier.
It's always possible. If nothing else, you write feature/integration tests for the critical user workflows in your application. These let you know that at least the important stuff works when you change something. Over time you add more, so any area of the code you're working on or refactoring you write a test for. Yes it's hard to write unit tests for a mess of code but you can get a long way with full stack integration testing. They'll be slow and hard to deal with if you have many branches in your possible execution paths, but they're a lot better than just giving up because testing is too hard.
An upvote for this guy. I did the same thing albeit with a different framework; every time functionality / feature X needs a change, port it to the new app, add test coverage, extend it. A lot of the changes you need to make, even in real mess, often come down to plumbing. Where does the data come from and go to? The logic can often be almost exactly the same lines of code, copypastad into the new framework and then tested and refactored from there at any time if needed. Meanwhile non-ported functionality is left alone in the "old" app. You'll find a surprising number of bugs pop up in the "working" code once it's unit tested. You can log and fix these to make your approach obviously beneficial to management. The main advantage I found here is that code with a lot of churn gets ported asap. Features being changed today are likely to change again in the near future so *you* can see almost immediate improvements in working conditions in the short to mid term. The features that are left alone are probably stable as hell even in the spaghetti, so nothing to keep you awake at night.
Even if OP puts all of these into procedural function calls, it is a step in teh right direction. Am working on a similar problem except that the customers do not have or want to spend money on what they consider needless work. I've learned to accept procedural, and have slowly moved things around and wrote things similar to your repository class idea to make life easier. 
As an experienced dev of bad code bases, Leave it alone. Refactoring the database calls on Day 5 is a recipe for disaster. Yes the code is bad, but it works. If you go changing critical things that then break in unexpected ways, you're in for a lot of pain for minor gain. At the end of the day, the company is clearly fine with "good enough" (or bad enough but it works). No need to strain yourself to fix the mess they created. You'd be better off putting your energy into learning new things than trying to be the hero no one asked for. 
Well it certainly does more than syntax highlighting. It also has code completion, syntax error detection, uninitialized variable detection, unused variables detection, ctrl+click to go to class/method/function, debugging, testing, etc. Furthermore, their git and svn plugins are great for handling merges, commits, etc. Performance has been constantly improving and I haven't had the sluggish indexing that I had in the past. Overall I'm pretty satisfied with it given that it is free.
&gt; So why bother with writing the best code when you just need a working product? Job security. If you can sell the added time/resources then you have more work, maybe a longer contract or promotion of some kind. Most companies are running tight budgets are care more about end results than how you got there. Every application is not the same. Some are around for a long time with few changes for a good reason. 
True but I mean assuming you HAVE job security, then what does it matter? You can bs other aspects of it if the business only cares about the end product and not the actual code base. Point is doing it right is always a great idea. Assuming that you are the only dev and you have control, then great you should implement the best coding scheme you can. By the sounds of the TC, it sounds like he's at a steady job but only issue is nobody gives a crap about the code because only a working product matters. On top of that his manager doesn't sound like he's technical so he's not going to sell it to him being the only new guy being vocal about it. Assuming nobody else on the team cares, why should you waste time subtracting years from your life when all you need to do is get by? If you're on a team that cares about coding standards and everyone is on board, then pitching ideas around and stuff and reading book is a great idea. Until you can convince everyone to follow you, then you'll just be the odd man out. Even having a great team you're still just doing what needs to be done to get by. I guess what I'm saying is that it probably isn't a great idea to fight the mentality of whatever place you're at. What works, works. It's a better idea to go with the flow unless you can see a chance to get everyone on board.
Post as much of it to /r/lolphp as you can.
This advice.. this advice right here.. did I mention.. use this advice.. my first php job I was such a noob and poorly documented everything. . Not thinking about the future. .. looking back I cared very little about the job itself.. moving on.. having to go back 3 years later and do some updates.. oh man.. i had to do this.. slowly update the code.. no one to blame but myselfm. But his advice is about what I did.. a little each day.. the code to say was better then yesterdays.. that's all I could do.. all you can do.. solve.. improve..
Rejoice in the fact that you have now joined a club, those that have started a job where the codebase sucks, that includes... well, everybody.
I would look at a micro framework like [Silex](http://silex.sensiolabs.org) or [SlimFramework](http://www.slimframework.com) to allow for quick build sites. Use composer for your dependancy management &amp; you can install [twig](twig.sensiolabs.org) or [Plates](http://platesphp.com) for native PHP templates and then whatever other PHP package you want? You can do it all in one index.php page or a simple MVC approach, whilst at the same time having a lightweight website which is easy to manage/improve/refactor. Hope it helps...
why does "why?" fail int conversion?
https://github.com/LaravelIO/laravel.io/blob/master/app/Lio/Articles/ArticleRepository.php
little late but paragraphs added :)
Apart from organizing the code in a sane manner, you should try and cover your ass from liability in the event the application is hacked. Go through it and identify as many bad practices as you can. Focus on the OWASP 10. https://www.owasp.org/index.php/Top_10_2013-Table_of_Contents Cut and paste the bad bits from the code base into a list and try to explain to your manager that there a vulnerabilities and if you do not spend time fixing them they are open to being hacked and it will not be YOUR fault. Non-technical managers are often happy when you are honest and up front with them and back your points up with examples.
This is the best post I have ever read. Thanks! Edit: I wrote a 5,000-page website with a custom CMS, all in procedural code. I was the only person who fully understood the system, although I documented it and commented the code reasonably well. This is a lesson to me.
Brilliant read, thank you. Sounds pretty similar to what we are doing (s/agavi/symfony2), so it's really nice to see we're not crazy in what we're attempting.
If you go any direction with dynamic data, I recommend using SQLite instead of MySQL. Much less overhead and doesn't sound like you need the bother of MySQL setup in such a small project. My guess is you will want some interaction, if nothing else something the client can manage himself. Unless you're into changing every little thing and charging them an hour of work to correct spelling mistakes. If it grows and you've used a framework, migration "should" be simple. Secondly, whatever framework you want and utilize caching.
I would like to kick me in the nuts for my first PHP job. &amp;nbsp; Documentation? *Nah..* Classes? *I heard that's slower so fuck that shit!* git? *Meh, I'm the only one working on this so why bother?* tests? *Oh cmon!! I do things right from the first try!* global vars? *Yeah! How awesome is that?!!*
I like it just because of the name.
I started writing a simple abstraction layer for PDO off of one someone wrote for mysqli a few weeks ago. This hasn't been tested or even checked for typos, nor have I finished the comments, but I think it's the kind of thing you're looking for. &lt;? class Database { /** @var $dbh PDO */ private $dbh; private $error; /** @var $stmt PDOStatement */ private $stmt; /** * Constructor * Initiates the Database class and starts a PDO connection with the MySQL Server * Accepts database connection details as params, if not set, defaults to config-defined details * * @param $host String : Database hostname * @param $dbname String : Database name * @param $user String : Database user name * @param $pass String : Database user password */ public function __construct($host = DB_HOST, $dbname = DB_NAME, $user = DB_USER, $pass = DB_PASS){ $this-&gt;connect($host,$dbname,$user,$pass); } /** * connect() * Build PDO Connection string and init PDO class * * @param $host String : Database hostname * @param $dbname String : Database name * @param $user String : Database user name * @param $pass String : Database user password * * @throws PDOException $this-&gt;error On failure to init PDO Class * */ private function connect($host,$dbname,$user,$pass) { // Set DSN $dsn = 'mysql:host=' . $host . ';dbname=' . $dbname; // Set options $options = array( PDO::ATTR_PERSISTENT =&gt; true, PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION ); // Create a new PDO instanace try{ $this-&gt;dbh = new PDO($dsn, $user, $pass, $options); } // Catch any errors catch(PDOException $e){ $this-&gt;error = $e-&gt;getMessage(); } } public function query($query){ $this-&gt;stmt = $this-&gt;dbh-&gt;prepare($query); } /** * bind() * Binds variable to PDO statement * Infers type, optional type can be forced * * @param $param String : Statement placeholder * @param $value Mixed : Content to Insert * @param $type Int : Optional type to force - PDO::PARAM_INT, PDO::PARAM_BOOL, * PDO::PARAM_NULL, PDO::PARAM_STR */ public function bind($param, $value, $type = null){ if (is_null($type)) { switch (true) { case is_int($value): $type = PDO::PARAM_INT; break; case is_bool($value): $type = PDO::PARAM_BOOL; break; case is_null($value): $type = PDO::PARAM_NULL; break; default: $type = PDO::PARAM_STR; } } $this-&gt;stmt-&gt;bindValue($param, $value, $type); } public function execute(){ return $this-&gt;stmt-&gt;execute(); } public function resultset(){ $this-&gt;execute(); return $this-&gt;stmt-&gt;fetchAll(PDO::FETCH_ASSOC); } /** * objectResultSet() * Fetches the result set for the statement into classes * * @param $class String : name of class to fetch results into * @param $construct Bool : Default true - If false, fire constructor before fetching results into class * * @return Array : Array of data objects */ public function objectResultSet($class, $construct = true) { $this-&gt;execute(); // If we want the class constructor to fire, execute standard fetch class functionality if($construct === true) { return $this-&gt;stmt-&gt;fetchAll(PDO::FETCH_CLASS, $class); } // Otherwise, fetch properties after the class constructor has fired return $this-&gt;stmt-&gt;fetchAll(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, $class); } public function single(){ $this-&gt;execute(); return $this-&gt;stmt-&gt;fetch(PDO::FETCH_ASSOC); } /** * objectSingle() * Fetches the result set for the statement into classes * * @param $class String : name of class to fetch results into * @param $construct Bool : Default true - If false, fire constructor before fetching results into class * * @return Mixed : False is returned on failure, otherwise a data object is returned */ public function objectSingle($class, $construct = true) { $this-&gt;execute(); // If we want the class constructor to fire, execute standard fetch class functionality if($construct === true) { return $this-&gt;stmt-&gt;fetch(PDO::FETCH_CLASS, $class); } // Otherwise, fetch properties after the class constructor has fired return $this-&gt;stmt-&gt;fetch(PDO::FETCH_CLASS | PDO::FETCH_PROPS_LATE, $class); } /** * rowCount() * Returns an integer value of how many rows were updated with the last statement * @return Int : Count of rows affected by last Update/Insert/Delete */ public function rowCount(){ return $this-&gt;stmt-&gt;rowCount(); } public function lastInsertId(){ return $this-&gt;dbh-&gt;lastInsertId(); } public function beginTransaction(){ return $this-&gt;dbh-&gt;beginTransaction(); } public function endTransaction(){ return $this-&gt;dbh-&gt;commit(); } public function cancelTransaction(){ return $this-&gt;dbh-&gt;rollBack(); } public function debugDumpParams(){ return $this-&gt;stmt-&gt;debugDumpParams(); } } 
&gt; a chance to get everyone on board. My office can't afford to buy basic supplies half the time. It's not a matter of desire or getting people on board with using new tech. It's that the existing legacy app, written procedurally, works well, and the previous developers were very secure if the code is sometimes messy and sprawling. If procedural code was costing people money to run, you'd have a business case. If a procedural app is somewhat well documented and organized, it's going to continue being utilized nad updated. As I add on to the app I'm working on, I do so with the long range goal of refactoring. But there's no money or desire, frankly, to update the code base just because. It kills me that companies cheap out so much, but that's how it goes... the money flows up to the boards and CEOs, never gets used for things that matter.
Ah! So you define the db credentials as constants and use them in the constructor of a Db object
If you do not refactor the code, and try to add existing features on top of a rats nest you are likely to run into problems and your boss would not understand that it really isn't your fault. Sometimes code touches areas of apps that you don't even think to test and especially in a small start up culture you don't really have time to test, even if you as the developer would like to. Its even worse if the managers don't really understand how important testing is. 
Yeah, I made this in mind of having a config file with defines for the "default" or fallback db credentials, with the option of specifying others when needed.
Careful, they might start attacking you based on some strawman.
I mean.. No one is stopping you. 
You said the code base is protected and understood. That is opposite of what the tc said. The tc is not saying procedural development is bad but that the one implemented where he is at is horribly written with no set design structure. When nobody else is willing to make standards or a good base then it doesn't matter what points you bring up because nobody got your back on it. You need a team and a single new person is working there and will look like he doesn't know what he's doing if he says everything sucks and nobody can back up his claims and they got a working product.
Hire me.
So this was my exact position about a month and a half ago. Mentally, it was frustrating to look at and hard to understand, and for me, personally it was a new experience. I had never worked on legacy code before. So in my head, I'm wondering how this even got to this point. Why are there functions that are 50+ lines long? Why is this javascript full of global variables? And for fucks sake, why is there javascript mixed into php mixed into html? Why is there no documentation? Truthfully, I found it a lot easier once I just relaxed and focused on my tasks. Follow the boy scout rule and leave the code you touch better than it was when you got there. Like me, you probably learned web dev in a different time than those who came before you. If your company is anything like mine, they're not going to worry too much about updating the entire codebase as best practices change. It's a waste of money and developer time/resources. There are obviously exceptions to this when it comes to security holes, but for the most part the people up the chain probably don't care too much about whether or not the javascript is a mess or nicely formed modules. They would rather you spend your time improving or adding new features or fixing bugs that are potentially causing them to lose money. Documentation is one of those things that a lot of developers just aren't given time to do. It takes time that dev and product managers would rather have you spend implementing something else. It sucks, but you just do the best you can. I take a lot of pride in my work. I don't like things being a mess or being broken or buggy. I'm obsessive about it, but I've come to realize that I can only do my best with the tasks I'm given and the rest of it just has to be in the background until I'm told that I need to do something with it. I'm much happier now. Make recommendations to your managers, improve things whenever you can and just realize too that at some point in the future, some new developer is going to come along and think your code is shit too.
Align the quality goals with the business reality. The worst thing you can do is attempt to get it all cleaned up when the business is dying and won't survive another 5 years without some big new features. Let management know how bad it is. Tell them we're talking about months of reworking and clean up, but the end goal will be stable, auto-tested code that will keep the company solid for years down the road. If they are like, "screw that, we're gonna go bankrupt if we try to do that" then reality is reality. Hack it fast as they need to, so the business keeps running. Ugly as it needs to be. People complain about bugs, management complains about bugs, and every bug can "feel like a fire" but in reality, most are not. So that means introducing bugs (if it's written crappy, it will happen). The code has no use if the business dies. No matter how much you clean it up. Get management 100% behind the plan before you execute. You don't want it YOU vs Management, you want YOU WITH Management. 
That's a bit better. I still prefer an OOPy solution though. It's more flexible.
Welcome to every new job. I once found a source file with 4 different variables all using 4 different misspellings of the same word. That was an amazing job. 
Get use to it. Unfortunately most of the code bases you come across will probably be like this. All you can do is try and leave the it in a better place than when you started.
Write a function.
Keep in mind that mobile first is not just looks it's also about content. Look at what users want to do when they hit the site and let them get the info/do the action straight away. If the current site has a few paragraphs about the business I would cut it and use a single sentence tag line. This is not a mission statement either, there's a difference. The first page needs a call to action, which would be a button or something to do that gets them started on why they came to the site. A hotel hire site might have a button with "Check availability" or "Book now" with a strong contrasting color to the rest of the site. In your case I would say an online booking system would be the call to action. You could write a little system that stores availability and allows people to book appointments. If opening times and phone numbers are the reason people hit the site so I would guess they should be front and center. This is probably all stuff that your designer will account for but it's just something to think about. 
Define your types as hashes with the key as the item name and the value as the count. Write functions that can be passed a reference to one of your collections that spits out totals and another that does percentages.
 $balls = array( 'blue' =&gt; 5, 'red' =&gt; 3, 'yellow =&gt; 5, ); $total = array_sum($balls); foreach ( $balls as $color =&gt; $color_count ) { $percent = $color_count / $total * 100; } even better.. $balls = array( 'blue' =&gt; array( 'count' =&gt; 5, 'percent' =&gt; null, // to be determined / set... don't actually need to define here ), ); // etc **Edit:** Even more academic: [class Balls](http://www.reddit.com/r/PHP/comments/29768q/is_there_a_more_efficient_way_to_do_this/cii5hyw)
So what's the point? Is this running on a site or command line? What are the inputs and expected outputs? If you're manually writing all values why not just precompute the values? 
This seems awfully homeworky. Hopefully, this should point you in the correct direction rather than just giving you the answer. /u/foo13 is correct that you should do this in a function. You should think about the problem not as balls, pencils, cats, or dogs but just as "items", you'll be better off. In your example you're given a **list** of 3 types of items and the number of each item in that type, 5 blue items, 3 red items, 7 yellow items. You then **sum** the values of each type of item in the list. Then **for each** item in the list you divide the number of items of that type but the total number of items and then multiply by 100. From that explanation it seems rather straightforward, at least to me, what you should do, but then I wrote the explanation. The key points you should consider in your code are in bold. 
somehow I don't think this helps /** * OP's code wrapped in function */ function do_stuff() { $ballsBlue = 5; $ballsRed = 3; $ballsYellow = 7; $ballsTotal = $ballsBlue + $ballsRed + $ballsYellow; $ballsBluePercent = ($ballsBlue/$ballsTotal)*100; $ballsRedPercent = ($ballsRed/$ballsTotal)*100; $ballsYellowPercent = ($ballsYellow/$ballsTotal)*100; } 
&gt; This seems awfully homeworky except we're in /r/php, not /r/pascal
If this is a homework assignment: class Balls { private $_colors = array(); private $_total = null; function getPercent($color) { $p = isset($this-&gt;_colors[$color]) ? $this-&gt;_colors[$color]['count'] / $this-&gt;getTotal() * 100 : 0; return round($p, 2); } function getTotal($useCache=true) { if ( $useCache &amp;&amp; isset($this-&gt;_total) ) return $this-&gt;_total; $this-&gt;_total = 0; foreach ( $this-&gt;_colors as $color =&gt; $color_info ) { $this-&gt;_total += $color_info['count']; } return $this-&gt;_total; } function setCount($color, $count) { $this-&gt;_colors[$color]['count'] = $count; //$this-&gt;_total = $this-&gt;getTotal(false); $this-&gt;_total = null; // invalidate cache } } $balls = new Balls(); $balls-&gt;setCount('blue', 5); $balls-&gt;setCount('red', 3); $balls-&gt;setCount('yellow', 5); $balls-&gt;getPercent('blue'); // returns 38.46 $balls-&gt;getPercent('green'); // returns 0 **Edit** removed typo semi-colon... added $useCache param **Edit2** simply invalidate the total cache in setCount()
No, that's a pretty useless function. Why not just wrap the percentage calculation in a function? function percentage($numerator, $denominator) { return ($numerator / $denominator) * 100; }
Note that having a single repository is often a code smell since it ends up being a huge god class if you have lots of entities or queries. You should have multiple repositories that roughly correlate to areas of your app. 
Arrays! I forgot they existed. Going to take a look at your code and arrays in general. It's not homework, at least not for class anyway. It's more personal homework as I want to learn PHP while using it for a project.
This is actually great advice. My one comment would be to be careful with Step 1. You don't want to be overly emotional, you don't want to piss people off, and you don't want to come across like some kind of dick. Step 5 is kind of important too. There is something to be said about just refactoring old code to save yourself headaches, but a big part of this is managing perceptions and expectations of those people who pay you. I'd talk to your manager about problems with the code, why spaghetti code is bad, how you can improve all of it without costing the company much more, etc. Roadmap, milestones, improved security, etc. Get his blessing, spin the whole thing to make yourself look like a hero.
This is good advice too. It may not be the best for every situation, but there is something to be said for this. Worst thing a dev can do within the first month is say 'This code is shit.' Try to refactor, break things and completely fuck stuff up. Essentially, you are sticking your neck out.
How is an OO solution more flexible? I see it as more boilerplatey.
Dem periods
Um, no. Closures can carry state. That is one of the defining characteristics of closures (excepting implementations in purely functional languages). Even PHP's closures can do this. Like so: function makeAdder($x) { return function($y) use (&amp;$x) { $x += $y; return $x; }; } $adder = makeAdder(5); echo $adder(1); echo $adder(4);
Says the man who's screen name is a pun on the same movie as my screen name.
Make sure error reporting is turned on. 
Because you can add stuff to it after you create the element. And you can return it from a function and then add stuff to the innards which you can't do with a string.
For sure. I guess I should've suggested something like "Rant about how bad things are _over one or more pints of your favorite beer at your local pub_". 
Is there any output buffering wrapping the code? Also check to make sure the query and connection are good. It could be failing once it's tries to bind (make sure error_reporting is maxed out or logs are enabled).
\&gt;.&lt; "Arrays" are your lifebread. Love them. Cherish them. Also note that "arrays" in PHP aren't real arrays. They're some crazy hybrid dictionary/list/set class that tries to do way more than they should. They get the job done, but don't expect them to behave the same as they do in any other language.
this is based on bkdotcom's solution. $balls = array( 'blue' =&gt; 5, 'red' =&gt; 3, 'yellow' =&gt; 5 ); array_walk($balls, function (&amp;$count, $name, $total) { $count = array( 'count' =&gt; $count, 'rating' =&gt; $count / $total * 100 ); }, array_sum(array_values($balls))); var_dump($balls); 
There is no output buffering. I hadn't thought about checking the query/connection, didn't know that when it binds it is communicating with the database. Will check, thank you!
OOP knowledge and Framework knowledge are separate concepts. You can use a Framework and write sloppy "OOP" code, or you can write elegant, flexible, readable, maintainable, testable OO code without a framework. So given that, you can start learning a framework any time, provided you ALSO keep learning how to write good OO code. If you choose to learn Laravel and spend some money on Laracasts, you will get the bonus of learning BOTH good OOP practices, within Laravel's framework context. That said, take the time to truly learn the framework. It's easy to Rambo code in any framework, but I strongly recommend reading through the docs of whatever framework you choose, before writing a single line of code in it. This helps give you an overview of topics and features of the framework so that you're taking advantage of the framework, rather than doing hard work the framework might already have done for you.
I don't know if it communicates to the database or not upon bind, I haven't used mysqli much. But from the code you posted, the syntax and usage is correct, so that tells me it's failing somewhere in bind_param() for non-syntax reasons, which can only be related to the database connection and possibly the query itself (table might not exist or what have you). It's usually worth wrapping your initial database connection definition in a try/catch and exception handling to catch a database connection error as early as possible.
What you are saying makes a lot of sense. I liked how you used logic to debug the code (syntax is correct therefore it has to be query/connection). I'm just starting out and I need to develop these kinds of skills. The initial database connection is wrapped in a try/catch so the connection is good, maybe the query is wrong... Thanks for your help!
You don't have errors muted/logging to file in php.ini? There could be an error being thrown on line #5 - even though your syntax does look solid.
i would use a static site generator like jekyll. loading static content from the database on every request seems like overkill. static sites are waaaay faster.
This is the error it shows. Line 188 corresponds to line 5 (as you said). *[27-Jun-2014 07:58:06 Europe/Berlin] PHP Fatal error: Call to a member function bind_param() on a non-object in /Applications/MAMP/htdocs/ejde/inc/page.php on line 188*
I can't help it. It is certainly the way I talk in real life.
I am starting a new gig after summer and I am going to work primarily on refactoring an old code base. The code base i question has been developed for about 15 years by 30% full time staff, the rest has been consultants. The code is so bad you will have nightmares; the vulnerabilities, the horrible performance the list can be made so long. Parts of the system are written in ASP, not the fancy .Net stuff either, old school ASP. Some parts of the backend uses an Oracle db most of the code uses MS SQL Server. So will this be horrible? No way, this is the sweetest gig ever. I get to redesign stuff all day long, in cutting edge tech. I will make that shit so dope that the next guy that works on it will fall in love with me. I have a time frame of three years to refactor one part of the whole echo system. 
&gt; Due to SEO reasons (according to client) a blog should not link to another blog if they are hosted on the same server. It should also not link to the same host twice. Lastly, if a blog links to another blog, than that blog cannot link back to the first. Meaning, if blog A links to blogs B and C, then B and C cannot link black to A. I know this is not very constructive, but I feel that a book about "How SEO does not work" would've been cheaper than your hourly rate. ;-)
This might be a dumb question, but is it possible you're using PDO here? The syntax you have is right for mysqli_, but not for PDO. (In which case it should be bindParam, as well as a few other issues.)
You should note as well, that arrays are require quite a lot of memory, so when you get into large arrays of data, especially for things where you know exactly how many items the array will hold, you could start to use some of the SPL’s functionality, such as SPL Fixed Array http://www.php.net/manual/en/class.splfixedarray.php
This reminds me of the Keeler's Theorem, Check out this paper: https://math.ucsd.edu/programs/undergraduate/1112_honors_presentations/Lihua_Huang_Honors_Thesis.pdf Or you could just watch the "The Prisoner of Benda" episode from Futurama ;).
Give me an example where a class is better than a function for generating HTML. My function will beat your class every time. Because there's no state - it's always just convert this data into HTML. Data in via function arguments and HTML out via the function return value.
there are a lot of widgets for the analytics api. in essence view counters are not difficult to implement except the part where you care about performence and concurrency issues, which is usually dealth with by using buckets to store views. if you can live with the "cons" of the analtytics api [which is mainly you either get live data for "now" or data that is some hours old] then analytics is fine theres also php tools like piwik who you could modify or use its tables
But in the case where you're "stuck without an IDE", how much power do you need? Nano has a very shallow learning curve and there is much less potential for messing up your code because you can't remember the commands in vim. 
This is just a random selection of PHP topics masquerading as interview material because it's currently a hot topic.
Don't forget Joomla. Surely that validates it.
The correct solution would be to keep the config in a directory not web-accessible, yes?
by the way, am I the only one who think this google api is really difficult to use? both authentication part and call api part ...
Yup.
I always give eclipse a chance when a new version is released but it always fails on my expectations. This is 2014 and even if I respect the effort of the community I prefer paying a lettuce to get a decent app than using the old fella. Ide is not only about the set of language features, it's responsiveness, it's user experience, it's ease of use... I switched to the dark theme and I started laughing! The result is so crap than I prefer to use an html textarea for editor! Anyway like I always say if something's getting old you have to say, this is it, we have to re-write it.
dude the point reinink is trying to make is that its outdated and S3 have updated the PHP SDK with better methods which give more flexibility and options. No doubt the older one *maybe* working but its just not recommended 
Why is it still not down voted to death?
Yuck. Clearly it's someone trying to bypass anti-spam SEO techniques.
You don't have short tags enabled. I would highly recommend against using short tags (&lt;?) and instead just use the full tag (&lt;?php). Short tags are not enabled by default and the server put your code on may not allow them. See this answer on stackoverflow on how to enable them if you wish - http://stackoverflow.com/a/2185331/2704386 **edit:** So apparently short tags are enabled by default on PHP 5.4 onwards, but I'd still recommend against using them.
Oh, I actually used the short tags to try it the second time to see if my results changed, originally the textbook told me &lt;?php which still outputs the same result. 
Because it's the most upvoted answer on the page? That's the funny thing.
It looks like it's actively being updated as part of some sort of troll phenomenon. Edit: Looking at the Wayback machine, it was still the most popular answer even before being trolled.
Sorry yeah I didn't notice you were just loading the .php file directly. See /u/warhuhn's answer
One golden rule about handling legacy code : don't, ever, touch it. Work your way around it, isolate as much as possible, edit only when strictly necessary. Don't _ever_ fix bugs on your own, those bugs may actually be features.
This is just my programming OCD kicking in, but that **else** in **getTotal()** has got to go.
What OS are you on? I'm on Ubuntu and OpenJDK was very sluggish for me, but since using Oracle Java 7 JDK I haven't found it slow at all. As for the dark theme, I use the [Moonrise UI](http://guari.github.io/eclipse-ui-theme/) dark theme. I have yet to try the one that comes stock with Luna
Well, it wasn't hard. At first i got questions like "What difference between private, protected and public methods". I was going to ask question "On what position, are you actually considering me" :), but then i got something more interesting about patterns and typical situations like "client claims, website runs slow, what you will do". I guess, i did pretty well, so wating now for next interview stage.
I've learned php using this book too. I think it was 2007. Good memories.
Thank you! I will try this when I get back home.
what is the data you want to translate consisting of? for example: verbatim commenting and notes or a list of states or... what?
Are you wanting this done on the fly or is this a one time translation you are needing?
Like I said in the post, if it can be done on the fly then that's great. If not then a one time translation into another column is great too.
Don't use another column. Add a languageid to the table, and then store spanish or english as separate rows. 
Lol the $useCache is kind of unnecessary, especially since it invalidates itself internally when necessary.
You can translate it on the fly using the Google Translate API https://developers.google.com/translate/ . But I can't really think of a good reason why you would take the performance hit (and pay the fee). I doubt it's likely that the translation of a specific string is going to change any time soon, so might as well store the translation for later use. And of course, most of the time, an automatic translation won't beat a translation done by a human who knows both languages, and the context of your text.
Smth like this: $doc = new DOMDocument(); $doc-&gt;loadXML('the_xml'); $entry = $this-&gt;dom-&gt;getElementsByTagName("entry")-&gt;item(0); $email = $entry-&gt;getElementsByTagNameNS( 'http://schemas.google.com/g/2005', 'email' ); // Need to add some checks &amp; loops, of course
This is actually exactly what [elefant CMS](https://github.com/jbroadway/elefant/blob/master/apps/admin/conf/acl.php) does.
Just remember next time, if you have similar [php] questions, you should ask in http://stackoverflow.com/questions/tagged/php https://forums.digitalpoint.com/forums/php.37/ http://www.daniweb.com/web-development/php/17 You will find more help there. 
I didn't even realize that was the problem they were trying to solve. It's painful to see that some people don't know security exists outside the codebase.
The proper way to do it would be the one described here : http://www.php.net/manual/en/function.parse-ini-file.php#99036 Still moronic, but less.
I was about to say that the rest of the code is pretty well written and documented but then I saw this : https://github.com/jbroadway/elefant/blob/master/lib/Functions.php#L297-L299 function fetch_url ($url) { if (extension_loaded ('curl')) { $ch = curl_init (); curl_setopt ($ch, CURLOPT_HEADER, 0); curl_setopt ($ch, CURLOPT_VERBOSE, 0); curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt ($ch, CURLOPT_SSL_VERIFYPEER, 0); curl_setopt ($ch, CURLOPT_SSL_VERIFYHOST, 0); curl_setopt ($ch, CURLOPT_FAILONERROR, 0); curl_setopt ($ch, CURLOPT_URL, $url); $res = curl_exec ($ch); curl_close ($ch); return $res; } return file_get_contents ($url); } 
PDO starts in "silent" error mode. You may wish to call `setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION)` after creating the connection; that will make the errors (if any) very obvious.
This is the most absurd one: http://www.php.net/manual/en/language.oop5.final.php#113843
You gave me the idea to look for api services and Microsoft offers up to 2,000,000 characters / month translated for free. Thanks.
Sounds like a problem you could describe in a prolog script, insert the data and get a decent solution out of it. You would just to describe the problem in predicate logic. Out if such you may just implement the algorithm prolog uses (backtracking depth search or so) and fiddle the predicate rules describing you problem right into the backtracking algorithm. (You may lookup my github account, I did implement the backtracking in JS for a project in my study using nodejs). But maybe i just did not got the basic problem and just thought the wrong way. 
Have you looked into OctoberCMS? http://octobercms.com/ It's built off of Laravel 4. It's still in beta but has been great so far.
The code would be much easier to follow (and analyse) if you use OOP. Host ------- * name * blogs * ip * etc... Blog ------- * host * links * etc... Host objects can contain many Blog objects, and every Blog has a Host. Each Blog can contain many Blogs in its links property. Now, Blog can have an addLink(Blog) method that knows the rules of wether a link can be established or not. In this way, after instantiating the blogs and hosts, you can simply iterate through each blog and try to add all other blogs to it. foreach (blogs as blog) { foreach (blogs as link) { blog-&gt;addLink(link) } } The addLink method can now contain your logic, and it will be much easier to read and maintain the code. You might even find a better/cleaner algorithm because its much easier to read and work with. Each blog would have methods that implement these domain rules you describe. The addLink method is only concerned with adding that single link to itself and nothing more, as opposed to having to track all of the other blogs. function addLink(blog) { // rules if (blog === $this) return; if (blog-&gt;hostEquals($this-&gt;host) return; if (blog-&gt;hasLinkLimit($this-&gt;host)) return; // etc $this-&gt;links-&gt;add(blog); } even better is to use a tool like phpspec to help specify these object behaviours. bonus points for making the business rules objects themselves. **EDIT** fixed a bit of formatting
What does your DB connection look like? Are you using PDO or mysqli?
Honestly, what exactly is final useful for? By which I mean, in what situation would it be important to prevent a method being overridden?
Are you using it in a production site currently? What do you like about it compared to other CMS systems you've used? We are considering it for certain projects and I'd be interested in your feedback if you had a few moments. Thanks.
Go with option 2. Based on your comments you will be extremely frustrated with Wordpress in the long run as well for all the same reasons. Best to build something from scratch that you know inside and out and can easily extend as needed. I like and use Pyro often, but it's a "right tool for the right job" kind of thing. I would never consider customizing Pyro as extensively as you have just to use it, and rewriting most of the admin area UI seems like a big time sink. I have happy clients using Pyro for fairly complex sites without much issue and I've never had to go to the lengths you have had to. Quirks? Sure, any CMS has them.
 class User { [...] final private function getPassword() { throw new Exception('No, you can\'t have the password of the User'); } [...] }
There are many useful and valid use cases for the final keyword. In object-oriented design, sometimes you want your classes to be [open for extension but closed for inheritance](http://verraes.net/2014/05/final-classes-in-php/).
Even if they were web accessible, why would they be run through the PHP parser?
That's exactly why I recommended the Jeeeyul's Eclipse Themes plugin. If you aren't satisfied with the overall design you can write your own css to have it perfectly fit your needs. That way design isn't an issue. Anyway, the visual design of an IDE is the least important part, it's the functionality and performance. And with 4.4 and PDT 3.3, Eclipse delivers. There is also an Emacs and VIM wrapper in the PDT extension repository I linked as well, giving you the familiarity you're used to if you use those systems. As far as compoaring it to other IDE's, I don't think there is a feature it lacks that others have, all basic controls and PHP features are there as listed in another comment. If you'd read any of the project plans, lots of core components have been rewritten. this update was focused on improving performance and their efforts paid off, this is a much faster, more stable eclipse since any other release in the 4.x series.
Looks very good! It's kinda like Laravel's queue stuff, but with less magic and framework tie in. One minor point though: You should use [predis](https://github.com/nrk/predis) instead of the PECL extension. Predis works without any extensions but also optionally supports the [phpiredis](https://github.com/nrk/phpiredis) extension for increased performance. You can achieve much broader compatibility this way and I'm sure people on shared hosts / strict environments would appreciate it.
i had to do this recently, using the separate database columns approach. we had a bunch of items in english, but needed a quick way to get the spanish translations. i ended up exporting the table as a csv, importing it into google spreadsheets, and using this bit of magic seen here: https://dl.dropboxusercontent.com/u/55195/translate.gif then just export the spreadsheet as a csv and re-import to the db.
you forgot to mention the date column name in your INSERT query Also, you probably want date("Y-m-d"), not "Y-d-m" when inserting a date into MySQL.
Thank you for your input, but the date column is still recorded as 0000-00-00
Looks like a pretty standard cURL function. I've got many similar functions in different projects. What am I missing?
forgive my incompetence, but I'm not sure I'm seeing what's wrong here.... Isn't it just fetching a url from CURL if it's available and falling back on file_get_contents?
Have you tried a lower bit depth? I'd do that before re sampling that low. Depending on what you're working on you'll definitely have issues with that low of a sample rate, particularly with higher frequencies. Have you tried other forms of compression like ogg? Flac can be pretty good as well.
perhaps in the context of the original question.. the class is total overkill getPercent()'s calls to getTotal() pulls the cached value and any external call to getTotal would use the cached value does/will getTotal get called more internally or externally if anything, setCount should only invalidate the cache, but not recalculate the total there. (changed) 
Yeah, I turned on error reporting on mysqli and that helped a lot.
Thanks everybody for all your help and suggestions. I have another question now: this server is shared hosting. Have any of you guys had luck with deploying things like Laravel, Twig, or Jekyll to shared hosting? The Jekyll suggestion made me look into it and the server actually supports Ruby as well, so I may go that route too. 
If you place a config.ini file with sensitive information in a web accessible directory, the contents are visible to the public. This "trick" makes the file "empty" to the public.
The only time I've used `final` recently is on my `Enum` class. https://github.com/titon/framework/blob/master/src/Titon/Type/Enum.php
Your date format is wrong, it should be Y-m-d. Your code is wrong, you need to escape your data or use bound variables (preferably the latter). You might be better off using PDO: $pdo-&gt;prepare('INSERT INTO … VALUES (:date)')-&gt;execute(['date' =&gt; date('Y-m-d')]);
This. First step when a query doesn't go as planed, see what the exact query being run is. With that you would most likely have noticed the lack of quotes. (Second step if that looks good, try manually running the command against the database.) An alternative if you want just want the current TS, you can use the mySQL function NOW(): $sql = "INSERT INTO stats (shiftEarnings, hours, wage) VALUES ($shiftEarnings, $hours, $wage, NOW() )";
That is awesome!
Have you fixed this yet? When you're specifying the columns to insert into, you don't specify the "date" column. You have 3 columns specified and 4 values. Surprised that isn't giving you an error really.
Also, if adding quotes to '$date' doesn't work, try printing out the SQL you are trying to insert and showing that. just do an echo $sql then try adding that to mysql manually and play around with it until you get it working.
Not really a PHP question, but I'll bite. What is your target size for the audio, and how long are the songs/sounds/whatever?
That doesn't make any sense.
But what does it matter if I override those? If I have a good reason to change a bit of functionality, why shouldn't I?
nothing wrong there, alot of times ssl verification causes issues during curl connecting to a none standard ssl where u dont have the proper bundles on your server.
it was good. I used it since the very beginning. I think I still do, somewhere 
We're working on audio books. We used to have about 50 audio files per project, but because of mobile limitations we're converting the 50 files into one sprite. I've got a 5 minute mp3 sprite file, mono at 24000Hz. It's about 3.8 mb. Any ideas on getting it down?
Use variable bitrate with a low maximum bitrate (might be able to get away with max 96kbps or even less). 
Because in this case, an enum should work a single way. That's the whole concept behind enumerables, they should be constant.
http://bolt.cm
This, I tend to offload anything the DB can do to the DB even if it's something as simple as NOW() and also as mentioned below you have not specified the 'date' column in your INSERT statement and it SHOULD be returning an error. Instead it seems it using DEFAULT NULL? If this is a "last modified" type of column there is an another option to keep you from having to include a timestamp in your insert. SQL Command: ALTER TABLE stats MODIFY last_modified timestamp default current_timestamp on update current_timestamp not null This will automatically populate the date field for you on INSERT and on UPDATE once you have modified the date column you are working with. 
Before you start refactoring as many suggest (and myself): Take one or two days to analyse calmly what kind of weaknesses you see already now and why they are bad, what could happen. Write a small thesis. You will need this soon so you don't need to explain again and again what the problem is - and, most important: You need to explain what exactly you will be spending months of time upon. Don't have empty hands when someone asks WTF you are doing since months.. Make Paragraphs like: - "Situation": What is the case, nothing else - What servers, what software etc. - "Analysis": What are the problems (list) - "Goal": What should be done 1. at least 2. the long shots - "Next steps": What you suggest, as far as you can see already. Say that more problems might show up. - "Best practice": What you think the standards are after everything will be accomplished. (You'll find suitable better English words..) 
If you're not terribly worried about quality, apply a filter to get rid of certain frequencies. Audiobooks only use a certain range since it's just one person speaking, so reducing unimportant highs and lows will help with compression. Other than that, like recommended, use a lower bit depth, since accuracy of the frequencies is not that important for audio books.
&gt; Step 1: Rant about how bad things are. Bad idea. This will just make the OP look like an asshole. &gt; Step 6: Make small incremental changes to improve the system -- all the while adding and/or updating test coverage to ensure that you've got full coverage along the way. Good idea. Before I'd change anything, I'd want to learn as much about who wrote the code as possible: * who wrote the code? * do they still work in my department, or even at the company? * what was there background? Did they have extensive coding experience? * who in my department knew them? Are they still friendly? * is my boss someone who doesn't like change? (i.e. "if it ain't broke don't fix it") Learn your work environment before you start asking for change. If you piss off the wrong person, your job can quickly become a lousy environment for you, which may cause stress and may lead you to writing procedural, verbose, unorganized, undocumented, no structure, and just horribly written code. If it turns out the authors were excellent coders and yet they produced lousy work, it may be an indication of their happiness at the organization. See anecdote below. **ANECDOTE** At my current job (I'm a web developer), the first thing I noticed is how bad the code base was. The web developer who wrote it still worked with me at the time and although he was talented, his code was awful. I wondered why, but after a few months on the job I got my answer; it was my boss's fault. My boss, although very smart (he has a computer science degree from MIT), does not trust anyone and changes his mind constantly causing his employees to rework projects over and over and over, while keeping the original deadline. Each iteration of the rework phase caused the quality to suffer, until we ended up with a shit codebase. EDIT Added more bullet points and an anecdote
I doubt FLAC is going to make things smaller.... But I've found OGG is really good for low bitrate stuff, if OP is allowed to switch formats, that is.
That's why it's called config.ini.php If it was just config.ini, it would not be parsed by php.
Neat library, thanks for the recommendation. However... it seems like you took a pretty standard 15 lines and bloated it into hundreds of lines of library code. Is there a reason the quoted 15 lines are poor practice? Is relying on a wrapper library for cURL better practice? I'm honestly curious here, I just don't see the issues with the cURL function aside from the eyestrain of seeing the same function called 8 times in a row.
Not that I know of.
Thanks for your feedback! Regarding your suggestion, I chose phpredis because it's more performant than predis. Moreover it's also quite popular and well supported. But I agree that it's not always possible to install/use a C extension (hhvm comes to mind here). It should not be hard to implement a PredisQueue, but I need to receive more requests before going forward with it.
Thanks! Give it a try :)
Why not have it run the local PHP dev server instead of needing an entire web stack?
&gt; WordPress does not have horrible coding standards Either you're [ignorant](https://core.trac.wordpress.org/browser/trunk/src/wp-includes/query.php#L89) or you're [lying](https://core.trac.wordpress.org/browser/tags/3.9.1/src/wp-includes/plugin.php#L401). Wordpress' codebase is awful, bloated, and does NOT follow standard conventions at all. Have you seen the sheer number of [globals](http://codex.wordpress.org/Global_Variables) it defines throughout the application? I'm actually shocked I haven't seen a goto statement yet. Take a look at [how Wordpress handles errors](https://core.trac.wordpress.org/browser/tags/3.9.1/src/wp-includes/class-wp-error.php#L0) instead of simply throwing an exception like a sane application. There is NO excuse for this. "But it makes things more readable and Exceptions might be confusing to other dev-" ###[NO](http://www.meemes.com/sites/default/files/styles/galleria_zoom-copy/public/PerfectlyTimedPhotos27.jpg?itok=_-vBtotD) On a large enough scale, it actually makes things less readable and less maintainable. It's the application's responsibility to let the developer know that they dun goofed, and then it's up to the developer to handle their code that makes everything shit the bed. Code like this is on par with the application wrapping everything in a try-catch block on behalf of the developer, and now the developer is stuck trying to figure out which function/method didn't return properly instead of just simply being told by the application. There's nothing wrong with being a good Wordpress Developer. Hell, there's nothing wrong with USING Wordpress. But there is certainly something wrong with confusing Wordpress standards with good programming practices, and it's a serious disservice to allow young aspiring developers to believe that Wordpress is the de facto standard in good web development. &gt; but even so, you are not required to work with or within those standards Then you may as well simply not use the core at all. What's the point in taking the VERY significant performance hit by installing Wordpress when there's no intention of working within its confines? I'm not even a fan of PyroCMS simply because it's [still built on top of CodeIgniter](https://www.pyrocms.com/blog/2014/06/important-pyrocms-225-security-release). That's not saying I don't like CodeIgniter - I do - but it's no longer being maintained and should not be used in Production environments. With all that aside, what it boils down to is time. Is this for a client that doesn't have the budget for a longer project? Go with Wordpress. Is this for yourself, or does your client have deep pockets? Go with Laravel. Quite honestly, I would keep PyroCMS 3 in the back of your mind. Porting everything over to Laravel may make for an easier transition when PyroCMS 3 comes out. Look into [Repositories](http://ryantablada.com/post/the-repository-pattern-in-action) to handle the separation of business logic from your models and controllers.
Are you talking about connection handle? I don't think you need a new one every time. Can you give more details?
Creating one DB handle would be the better way to go and is perfectly compatible with try/catch blocks. The efficiency you get from using PDO comes from using the query prepare() function. This allows you to loop through executing those queries while PDO handles buffering/caching/etc and improves performance.
Google "graph data structure" http://www.codediesel.com/algorithms/building-a-graph-data-structure-in-php/
Thanks for the reply. For convenience, I've been conforming to the pattern of the original code (not mine). This may've been a bad choice. In any case, where a mysqli call appears, I've been replacing it with a PDO call in a try/catch construction per the following: try { $sql='QUERY LANGUAGE'; $dbh = new PDO("mysql:host=$dbhost;dbname=$dbname", $dbuser, $dbpass); $dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $sth = $dbh-&gt;prepare($sql); $sth-&gt;execute(); $dbh = null; $sth-&gt;setFetchMode(PDO::FETCH_ASSOC); $result = $sth-&gt;fetchAll(); // in most cases, print HTML-formatted query results here } catch (PDOException $e) { echo "Error: " . $e-&gt;getMessage(); } This is showing up multiple times per page. Unwieldy, I realize, but I'm treading new waters here. I'd much appreciate any guidance on improving code.
I can see the use. I already have a full web stack running for development. If I want to quickly grab phpinfo, I need to make a new file for it somewhere in my current project, stick phpinfo into it, try and get the page loaded in the browser (because no doubt, I've forgotten the path already), then hope that I don't forget to delete that tiny testing file before I commit it to the repo, sending it live. Here I just have a virtualhost already running with this project in it. Hit the bookmark, type in what I want, and get the result. It's a very small issue that I'm sure most people don't have, and saves only a couple of seconds, but I'd definitely use something like this.
Thanks for replying. I'm sure you're right, but I'm not clear on the best way to achieve this. Could you describe a style for creating and reusing a DB handle, or otherwise point to resources for guidance?
The only reason I'd ever recommend moving to WordPress is because you're familiar with it. I've worked with WordPress almost exclusively for two years, and every day I'm frustrated with its idiosyncrasies. WordPress would also be a poor choice because it sounds like you have a lot of structured data, something WordPress isn't very good at. In fact recently I decided against WordPress and in favor of Laravel specifically because the project called for a lot of many-to-many relationships. That all being said, sometimes you don't really want to rebuild an entire Administrative interface, in which case either Drupal 8 or October (both still in beta) would be good options.
Another option would be to use something like craft. It's in the same ballpark as expression engine, which I rather enjoy. There's also process wire which I'm less familiar with. There's def other cms-ish options you could go to that aren't as custom as laravel or restricted as Wordpress. 
The best answer is honestly "it depends." I can't be entirely sure what your needs are from one post, but it does sound like you're doing a lot of customization, so I'd say probably use laravel. When I first started my current project, the "alpha" version was written in Joomla. I tries to start modding it, but every new feature I added made it harder to add new features, harder to understand, and clunkier for the end user. So I scrapped it and rewrote it in laravel. Its taken 6 months but it's so much smoother and adding new features is a breeze. Wordpress/Joomla are great for getting a site with some basic functionality up quickly, and it's not that tough to extend them a little bit. But if you're doing a lot of custom functionality you should probably be using a more developer-oriented framework
Are you sure about that? This is well known as fact in big SEO firms (black hat or white hat). The idea is to prevent link farms. A firm we worked with was generating several new sites a day on the same servers and inter-linking them, and Panda absolutely destroyed them. The only real authority on SEO is Matt Cutts or personal experience, or both. If google says something outright, then fine, but if you have seen black hats get hammered (as I have) for trying to manipulate the system (and rightfully so) first-hand, there is no other evidence needed. His client is 100% correct in my opinion, as his client is most likely a black hat SEO who has gotten hit for doing this exact thing.
The main problem it solves is: what happens when suddenly you stop passing the url to FPM when you screw up a config, or someone finds a way to get nginx to try_files the config, or your Apache's mod_php comes unstuck during a package upgrade? Well, all of a sudden your file will be served as plain text. You'll have to change every password and API key in your config, given you were serving them openly for the whole web to see. These things don't happen normally, sure. But they do happen, and have a disastrous effect if they do. Plus, the argument with security contexts is: always use the *least* amount of privilege you need. If you don't need to actually serve a file via HTTP (if, instead, you *only* plan to execute it with PHP), it doesn't belong in your document root. Use a single front controller in the document root, and be done with any risk (apart from regular old directory traversal exploits).
Having request and response objects is pretty important for reuse and testing. How is your unit test going to test the function that talks to the remote API without *actually* making the request? (And remember: setting up tests against a remote sandbox account on the actual API only results in your builds failing whenever the remote service is down; very annoying) You have to mock a wrapper object around the curl resource (or, hell, any of the HTTP retrieval methods provided in PHP, for example, `fopen`). Using an environment branch condition, like an `if ($env == 'test')`, will only result in no coverage over the actual branch that runs in production. Youch. As far as I know, it's not like you can directly mock `curl_exec` - it's provided by an extension, so wrapping it is going to be messy, and you just flat out can't redefine a function. But mocking `GuzzleHttp\Client` to return the faked out message that the API usually gives? Easy!
Sniperino is pointing out that if you can (in nginx) bypass the `fastcgi_pass`, or find an unprotected `try_files`, or (in apache) `mod_php` is unloaded by mistake, then the file *won't* be interpreted by PHP, file extension or no. Tricks in the file just won't work, and the file will be served as plain text. These problems are inherent in the web server configuration. Which is yet another reason why shared hosting is shit. They're not necessarily persistent vulnerabilities, but breakage of mod_php could happen on any old `apt-get upgrade`. So, if you never want to serve the contents of a file over plain old HTTP, uninterpreted, then it doesn't belong in the document root.
Thank you, the NOW() function works perfectly
Reusing an answer I gave [here](http://www.reddit.com/r/PHP/comments/28z9bs/non_global_and_nonrepetitive_pdo_usage/cifvtp7): What you want is a container, used either as a Service Locator or (preferably) as a Dependency Injection container. You place the PDO instance in the container. Then you either pass the container around so that objects can extract the PDO instance (a la Service Locator) or you build all your objects via the container so that it injects the PDO instance into their constructors (a la Dependency Injection). As the project lead I suggest [Aura.Di](https://github.com/auraphp/Aura.Di) but there are other reasonably-good container systems out there too.
Jeffrey Way, Shawn McCool, and Chris Fidao all talk about it in each one of their talks. Those are the only ones i have watched thus far too
My guess is that the side by side view in the web interface is more approachable to some people who are familiar with services like JSBin/Codepen/JSFiddle etc. With that said, I'm sure either one would perform the job.
This is really nice. I love the proxying from Gists feature, very handy. If you ever want to turn it into a public service, let me know - I built and run http://tehplayground.com/ which is kinda the same thing, just getting a bit long in the tooth now as I don't really have the time to update it (it does need some love). I learnt a lot about PHP security and the like while setting it up, and it was a fun experience getting Reddit to have a crack at breaking it as well!
I started a project that was exactly like this: all manual testing, nothing automated, no staging area. I didn't know any better. Then we started growing, adding more people, and actually getting clients. As a company we started enforcing a few rules: 1. New functionality *must* have tests. 2. Bug fixes get test cases written to expose them and are then fixed. 3. Touch a piece of untested code in any way and you *must* write tests for it. 4. Any extra free time not working on bugs or new features should be spent writing tests. 5. The business guys, who wrote the requirements, do QA on a staging site to ensure they're getting what they expected. The point here is that there's always something that can be done, even if fixing just a few [broken windows](http://en.wikipedia.org/wiki/Broken_windows_theory).
&gt; and access to a ton of handy plugins "handy" should be taken with a grain of salt here. If the business rules of your site are flexible and can adapt to what a plugin can and can't do, then plugins are handy. If however, your business rules are inflexible and plugins don't quite match the business rules, then plugins go from being handy to festering piles of technical debt inherited from another coder. And every plugin is coded differently, so to modify or extend each plugin to fit the business rules, requires its own mini learning curve. Further, do you NEED flexibility with your data? Do you NEED complex relationships between your data? If so, then Wordpress will quickly get in your way. Wordpress is ideal for when your business rules are flexible, and can adapt to whatever a plugin can do out of the box. But if those rules are inflexible, then I recommend building a cohesive application from a lower level framework like Laravel.
&gt; My function will beat your class every time. Because there's no state That doesn't even make sense. I gave it a `__toString` method. You can can concat them, echo them, do whatever you want with them just like a string, but you can add children at any point until you render them.
Feel free to use this. http://i.imgur.com/6zozRbE.png
$_SESSION will only ever have the session of the user who loaded the web page. 
That's exactly the problem it *doesn't* solve. As long as FPM continues to work and that file is interpreted as PHP they will see a blank page. If they screw up their config and that file is served as plain text then they *can* see the entire INI.
When I say beat I mean come up with a less verbose, more productive and simpler solution. Having to instantiate an object and call instance and static methods is unnecessary boilerplate because there is no state to maintain. Again it's just converting data to HTML. The data is the function arguments and the HTML is the function return value. Introducing OO concepts just makes things more complicated with no benefit.
I use a straight-to-HTML function for simple cases. I only used the the classes when I want to build it up. You end up creating all these intermediate arrays otherwise to hold your LIs or TDs or whatever. You're doing the same damn shit the class already takes care of for you.
Thank you very much! You help me recognize those tags! I also found another way to get json format response! This is my final solution: $url = 'https://www.google.com/m8/feeds/contacts/default/full'; $query = array( 'v' =&gt; '3.0', 'access_token' =&gt; $this-&gt;getAccessToken(), 'alt' =&gt; 'json' ); $result = file_get_contents($url . '?' . http_build_query($query)); $temp = json_decode($result,true); foreach($temp['feed']['entry'] as $cnt) { // You think all entry has email address? Wrong! // Goodle doesn't check this for us. So sad :((( if ( !array_key_exists('gd$email', $cnt) ){ continue; } $this-&gt;contacts[] = array( 'name' =&gt; $cnt['title']['$t'], 'address' =&gt; $cnt['gd$email']['0']['address'] ); } return $this-&gt;contacts; I will release a open source library for this. Wish others don't need to spend their time like me to look into the details of the document. :)))))
I haven't seen/heard the talks and definitely would try to reach out to the speakers to try to get clarification from them. With that aside, this sounds like an odd use for a message bus. Usually a bus exists for several different applications to communicate with each other without being directly tied to each other. Are you sure the bus isn't a separate process or something? I can understand the same idea being applied within an application where the different subsystems communicate with it, but that sounds a lot like an event system... so I'm not really sure. 
i totally get that. i don't get this concept at all or when it would ever be useful though
just sent them tweets pointing to the thread. We'll see what happens
The point of testing code in isolation is to eliminate outside anomalies. And, no, you can't have passing unit tests for code that suddenly breaks when you use a real connection unless you wrote the tests incorrectly. The whole point of mocking the connection is to say "okay, assuming the database itself works as advertised, will my code also work?"
Mostly it's going to depend on the structure of your application and how/where you're accessing the database. That being said, you'll want to create the database connection/handle separately from all of the database query logic. I'd suggest some sort of singleton class or function for creating the handle and then pass (inject) it along to all of the places it's needed. If you've got lot's of queries that you need to make in one block of logic, you'll want to set up/create as many of the prepared queries as you can before calling the execute function. Doing so will allow PDO to run all of the queries together saving database calls/requests. Another part of figuring out the best way to handle this is figuring out how to group those queries in the best way so that you call the execute function as few times as possible.
Hmm, would you be willing to accept a pull request for it? :) 
Think you need to read the context again; I said the same thing you said. forgetfulcoder was asking what does "keep the config in a directory not web-accessible" solve.
There were a few comments on twitter back and forth between Jeff and Shawn, and possibly Chris, a couple of months ago. Jeff was just learning it, iirc. He did a recent laracasts series on the commandbus thing. Nice to see something a bit more advanced that validators or how to send an email, but it does seem overkill for pretty much anything I can think of.
This is quite a common pattern when implementing DDD/CQRS, though it usually carries slightly stricter conventions in those cases. I do this and it works well for me. I find it creates a suitable boundary between the application and the ui and doubles as a job queue.
Yep, Started without tests. but after a while *features* were popping up here and there. Started writing test's then (90% code-coverage btw for mine..). Its better to write tests. Otherwise you'll get unexpected features *every now and then*.
Yes, definitely. Though this breaks down when people don't use SemVer, which is quite often.
Thanks for the detailed reply. Your Hobgoblins talk at PHPNW got me into DDD &amp; CQRS. One question: how is a CommandBus different from a Kernel (eg Symfony's HTTP Kernel)? They both resolve a Command / Request and pass it to a single Handler / Controller, using events along the way.
"What am I missing with this whole command bus craze?" The entire concept it seems.
Oh...you mean moving the config file outside of a web-accessible directory solves that problem. Then yes, you're correct. 
Seems like a Command is actually an abstraction on top of controller actions (the whole MVC concept doesn't make sense on a request-response environment anyway). So instead of having the logic for creating a user in `AdminUsersController::createUser()` and `AccountController::register()` you have it in the `CreateUserCommand` which is responsible for sanitizing the data, saving the model, triggering events etc. The differences between events is that inside the CreateUserCommand invocation you can have events like `before_registration`, `after_registration`. With events is harder to prevent the normal flow of the app. You can't make an event listener for `before_registration` to stop the actual creation of the user. You need AOP for that, or command decorators or just writing the proper logic (eg: if an event listener throws a `PreventUserCreation` exception) in the command itself. On the other hand I do understand the problem because usually when you have user data you have forms that validate and some of the validations are not related to the model/business logic (eg: CAPTCHA validation, CSRF) so you may end up with a command like `CreateUserFromRegistrationForm` which is a 1:1 map of the controller action.
Its really common. Most of the time its a problem of getting the MVP (minimum viable product) into production s quickly as possible. Budgets are ALWAYS squeezed, developerer time is pressured, so the first thing sacrificed is the extra time it would take to write tests. 
To me it makes more sense to just have a RegisterMemberCommand and then handle the collection and validation of the data in web forms in the controller. This way, your application still doesn't know about or care about the web nature of your application and the layers are separated.
What can be done to prevent the boss doind ths kind of stuff? I had similar experience. May be usng a version control and writing tests will prevent?
I would recommend [ProcessWire](http://processwire.com/). It's based on custom fields, and you have a complete freedom on the frontend part.
And here's where I begin to wonder "Do we work at the same place?"
Ah, yeah, we call it herd instinct.
If your database is anomaly you do something wrong. The issue here is the code designed to work with specific database schema. Assuming that insert record will work without connecting to real database gives you nothing, as you may try to access column that does not exist. Database is not a 3rd party service. It is essential part of web app.
 &gt; And, no, you can't have passing unit tests for code that suddenly breaks when you use a real connection unless you wrote the tests incorrectly. Quite easy. Your code may be perfect but you didn't run the migration to update db schema.
Please be aware of the low quality of translation! Google Translate often makes pretty bad translations into Spanish and can be quite incomprehensible!
Well as somebody who has worked on extensively on projects that provide and consume APIs, scrape and spider websites I can tell you that elegantly and asynchronously consuming data from multiple sources takes far more than 15 lines of code. And if it's anything super simple, I'd probably just use file_get_contents($url); anyway.
Check out userfrosting.com it's got a lot on improvements over usercake.
Generically is sounds like they are similar. For the HTTP kernel specifically, the intent is very different. The HTTP kernel is for HTTP requests. Your application might handle more than HTTP requests (CLI requests, AMQP messages, API calls that aren't purely from HTTP). 
I answered the same question in a [Laracasts video](https://laracasts.com/series/commands-and-domain-events/episodes/5) thread also. Here's what I said: The intent for Commands and Events are very different. **Commands:** Commands are a way to separate your application from external libraries (framework + libs). It provides a boundary between your framework "layer" and your application "layer". See ["Use Cases And The Application Boundary" here](http://alistair.cockburn.us/Hexagonal+architecture) for a bit more explanation on that. Commands act as a way for the outside world to interact with your application. They give your application an explicit way to say "this is the way you can use me". This can prevent application mis-use, provide clarity to developers working on a project, and (most importantly) allow a decoupling from other layers (framework, etc), giving you a way to more easily test your application (don't need the framework loaded with your tests necessarily) and not tie it to specific implementations (You can use commands in a CLI call just as you can in an HTTP router). That last one was an important point: You can re-use commands in browser requests, api requests, CLI commands, event listeners (!), job workers and any other way your application may be communicated with. The code in each context there can then center around gathering inputs that need to be entered for the Command to fulfill its duties (rather than having to worry about how to accomplish its goal as well). **Events:** Events are "past tense". They are a way of saying "This happened". Multiple listeners can be tied to an event and respond accordingly. The intent of an event is to allow multiple interested, but not directly related, actors respond to an event (e.g. UserRegistered, PlanUpgraded). While events say "this happened" and can spawn a lot of non-specific behavior, Commands are the way to make things happen. Commands are not the result of another action, but rather are the way to perform an initial action on your application.
so why not call the handlers directly? I think a big part of what I'm not understanding is the "bus" part... the command part I kind of get.
Gapi is a simple but useful PHP library for Google Analytics. Just be sure to locally cache the results, as there's an API limit of around 10,000 requests a day.
One example could be cryptographic algorithms. You may want to make some functionality available but prevent the user from being able to overwrite it. 
+1. Some patterns are really similar (even at the UML level) but differ mostly in intent. Both Command Bus and the HTTP Kernel are similar to , say, a Chain of Responsibility. Patterns are awesome but they're really just a set of labels and often multiple names apply, overlap or are even the same. :)
The database *is* a source of anomalies for your DBAL code, just like any other dependency. What happens if someone removes a column? What happens if someone deletes your test data while the tests are running? What happens if a constraint is disabled from another process? What happens if... There are too many things that can go wrong when you don't isolate your system under test. That's the whole reason behind isolation and mocking.
That's not broken code. That's lack of coffee. In all seriousness, though, this scenario is covered with acceptance or integration tests, *not* unit tests.
A Google search is your friend here, it will turn up literally millions of results for those things.
&gt; a blog should not link to another blog if they are hosted on the same server. It should also not link to the same host twice. - The maximum amount of links per blog always equals the amount of other servers. --- Also, your linking strategy in the example is not the optimal linking strategy. The optimal linking strategy is: A links to D,G,J B links to E,H,K C links to F,I,L D links to B,G,J E links to **C**,H,K F links to A,I,L G links to **B**,E,J H links to C,**F**,K I links to **A**,D,L J links to B,**E**,H K links to **C**,F,**I** L links to A,**D**,G Which gives all blogs an equal number of incoming links, and the shortest loop distance is larger too Tabled: ||1|2|3|4| |---|---|---|---|---| | A links to || D | G | J | | B links to || E | H | K | | C links to || F | I | L | | D links to | B || G |J | | E links to | **C** || H| K | | F links to | A || I | L | | G links to | **B** | E || J | | H links to | C | **F** || K | | I links to | **A** | D || L | | J links to | B | **E** | H || | K links to | **C** | F | **I** || | L links to | A | **D** | G || 
Model validation is business logic and should be in the business layer. You can have input validation on the controller level as well but that would repeating yourself. That's why I said it's difficult to understand the usefulness of the Command pattern in this case.
You could use [a header](http://www.php.net/manual/en/function.header.php) &lt;?php header('Location: http://ex.am.ple');
Yes it will and you can do some processing before the header if you want to redirect with the URI etc.
Thanks for the heads up but I have a process whereby people can submit suggested corrections.
We do that as well. Should've made the list!
Awesome, thanks! Will give it a shot right away.
Works like a charm. Thanks!!!
No, that's the whole reason behind *not* using isolation and mocking. if someone changes your database you need to know right away.
&gt; PHP + MySQL What for? You haven't decided what your even doing yet. Maybe HTML + JS is all you need? Take a step back and ask what the website actually wants to do. I'd do this on a different group than /r/php - by definition we're more likely to jump straight to "let's code something!" instead of thinking "do we need to code something?" I'd go and find a group of people who might use massage therapy and ask them what they're looking for - market research basically.
Before you go learning from the many bad examples out there, you should check out [PHP: The Right Way](http://www.phptherightway.com).
Oh shut up
Yes, the technical debt is a big concern for me, and I definitively want to make sure it's under control - not that I associate that technical debt with myself. I view it as the company's technical debt, which they took on when they decided against safeguards. I think eventually we'll start testing, but it might take a few "disasters" to force them to allocate the resources.
IMO, traits should be used if and only if: * They don't rely on any implementation, properties or methods of the class that uses them. * They contain minimal logic, all they do is proxy to other objects. Eg logging (a good use case for traits, as it's a cross-cutting concern): * Concrete class has a Logger injected and uses LoggingTrait * Concrete class calls the trait's setLogger() * Concrete class calls the trait's log() * Trait calls method on Logger For the trait to know nothing about the concrete class, the concrete class has to know about how the trait is setup, which isn't ideal. Traits can be useful but I'd nearly always favour composition (eg a decorator).
Kind of a personal choice. I like having suffixes on things like `View` because it makes code a bit more readable and adds some context to the class name: &lt;?php use Acme\Example\View\TemplateView; // 100 lines later, it's easily apparent what this class is/does return new TemplateView('templatename'); I don't like having a suffix on models or any other true domain objects. Name them something that makes sense for the domain. An ecommerce platform might have models like `Product`, `ProductVariation`, `ShoppingCart`, and `Invoice`. A suffix doesn't really add any context to those names: `ProductModel`, `ProductVariationModel`, etc.
I never understood `define()` myself, and why so many people use it so regularly. I'm a huge supporter of `json` but not really for dealing with something like this. As a general rule of thumb you should never use a plain text language for any configuration data up to and including passwords. You can __easily__ [make a PHP based class to handle your configurations.](https://github.com/Xanza/php-configure) No real reason to "choose" between two languages. Use `PHP` to handle sensitive data, and `json` for the rest.
You don't unit test your database. Testing database software is the vendor's job (and I assure you that they do a better job of it than you or I). So, yes; it's a very good assumption. But that's not really the point, is it? Isolation is about making sure that if a unit test fails, you know exactly what was responsible for the failure. It's incredibly trivial to break a unit test that doesn't mock a database even when your code is flawless. This is the same premise behind mocking *anything*.
Unit tests are not for testing your schema. They're for testing the code that operates on the data coming out of the database. The scenarios you're referring to are the responsibility of acceptance and/or integration testing - *not* unit testing.
That's entirely true. I made that class for myself for large projects as the construct is easier for me to remember. But, in my opinion, even if it's overkill if it works best for you...then... Ya'know?
When in doubt, go with the third option: Use the same structure you would have used with JSON, but specify it as plain PHP. JSON is not a good configuration format for numerous reasons - the most obvious being that it does not support comments. Defines are not a good configuration format either. The data they can hold is limited (e.g. no arrays) and they are globally visible. Unless there is strong incentive to use a DSL for something, don't use one. For configs such an incentive does not *typically* exist, as such I would always recommend to write them in PHP. (Unless you need to share the config with another language, of course.)
Anyone know of any other in depth articles about DDD related software architecture?
You sound excessively concerned over unnecessary optimizations. You should be validating your configuration data -- which is the purpose of getters and setters, and the purpose of using a class based configuration. You're sacrificing system monitoring in order to save a few CPU cycles. That's like removing the heavy safety equipment from your car in order to drive 2mph faster. Even if having cross-platform configuration was your only concern there are better ways of implementing it. Nice benchmark though. At least your testing your theories instead of making assumptions.
A PR or an issue would be much appreciated. I just want to make sure that there are any other devs interested in adding predis support.
For unit testing I usually have another config file, and depending if I'm testing or not, I include one or another.
I would say no. Hungarian notation is quite useful, but only if your prefix/suffix has actual *meaning* behind it--not just the type. You can and should be able to infer the type.
The lack of comments is a good point. However, for small projects, property names are usually self-explanative, for example, by looking at `"DB_USER" : "mysql_username"` you can easily guess that the username for the database is "mysql_username". Also, properties' keys are free and have (theoretically) no character limit :P
Good job. :)
X-Lang compatibility notwithstanding (rarely necessary), I still don't get why you'd want to use JSON. In plain PHP you'd write `"DB_USER" =&gt; "mysql_username"`, which is practically the same as JSON. But you also have the ability to write comments and use all other PHP functionality for that matter. Like, you could also write `"enc_key" =&gt; base64_decode("...")` or something. Why limit yourself to - and introduce the additional overhead of - JSON?
I would assume it has something to do with: plublic function getPostsTitle(){ I have this kind of stuff happen when syntax immediately after my problem is breaking.
Change plublic to public on declaration of your first method
I agree with some of the other posters - this is *not* unit testing, this is functional/integration testing. The whole point of unit testing is to evaluate the isolated *code units* for correct handling and manipulation of the data you give it. You should never be calling an actual database in a unit test, it should be mocked out and sample data returned. If you can turn off your database instance and your tests still pass, you're on the right track. If you're depending on a state of the database (record exists, updated value, etc) you're doing it wrong.
Because json is *the* trending standard for configuration and properties files.
Awesome, thanks for putting so much effort into this. :) For the one handler per command thing, I agree with Jeffery: most of the things you'd want to do in a separate handler are possible and probably easier with the decorator. Ultimately, having multiple handlers is about having a sequence of operations before, in or after your "main" operation. If the operation is part of or related to the "main" operation, then it's easiest to have that in one place. If you want it before or after, then a decorator is just as easy and you never have to worry ugly priority chains. The very fact that there is a "main" operation is kind of an indicator that there's something singular about that operation. Also, events have value beyond just triggering other code (see Event Sourcing, for example). That said, the event triggering is usually for unique things that need to happen but just aren't related to the main code. For example, if you have a 3rd party user management system but need to update a separate shipping system when a user changes their address, that's an operation that needs to be triggered but doesn't belong to the User system. This should be triggered after the "main" operation but it doesn't have to happen right away, it could be off in a job queue or be part of a batch job, whatever. Using an event to trigger a separate "main" operation rather than falling through to another handler will arguably make more consistent and flexible code because it gives you an extra step to play around with. The events that get fired, btw, don't belong to the service layer/command bus. They're typically part of the domain, they're just dispatched by the service layer. So, there's a difference in layer there as well. Anyways, that said, patterns evolve by people trying different things so you won't know unless you try. If you do, then please let me know how it turns out afterwards, for good or ill. If you go far enough to already build a command bus, I'd already consider that a win in architecture, even if your handler handling differs from mine. :) As for the talk, I appreciate any feedback. The video is from the first time I did the talk, so some things have changed since. Still, feedback: - Repository cache: Valid point, I've gotten this one a few times and agree. The general point was showing that the service layer could own interaction between other services if necessary, though these days I'm wondering if a domain service is a better option. - addTask(): I thought the same thing too but in practice, it hasn't happened much. Often, lots of individual params might be a smell for merging grouped data into value objects. If I still have lots of parameters, maybe I actually have multiple operations that should be separate methods. Again, I can't identify the actual reason why but it hasn't been an issue yet. - TooAmbitiousEvent: Sorry, maybe I should clarify this next time. It's not intended to be an error, it's more the type of thing that would appear in an audit log or cause the TodoList to appear highlighted in red to the user. It's an interesting event to the user but it's not an error. - Public properties on commands: In the grand scheme of things, we can agree to disagree on this one. Most of the time, my commands are bound to form objects or deserialized. In these cases, getters/setters are less useful and maybe even just line noise. Immutability is awesome but maybe/maybe not relevant here? No biggie. Either way, thanks again for the feedback and reading this far. Lotta time in the train today.
Cleaver ;) thanks 
First, I didn't say security. I said validation. Second, you're not using your getters/setters correctly. Instead of this: $config["base_url"] = "http://site.com"; you could do this: public function setBaseUrl($url) { if (!parse_url($url)) { throw new ConfigurationException( "Base URL is not valid. Did you forget the 'http://' scheme?" ); } $this-&gt;values["base_url"] = $url; return $this; } You no doubt understand the need to validate user input, but you don't seem to understand you need to validate your own input as well so you can easily catch, debug, and find your own mistakes.
I posted that simple getter because it is the code one of the parent replies mentioned (https://github.com/Xanza/php-configure). Of course it *could* be some situations on which a wrapper class like this would be neccesary, but none come to my mind where, if there were an error, it could not be instantly detected, either by the whole code crashing, the links being broken, etc. Again, it COULD be useful in some projects where very sensitive data is being entered (a custom pseudo language like awk created by yourself, or something as complex as that), but definetly I would not write a specific setter/getter and a validator for each entry of my config file on my normal projects.
Work in NYC? Know java? PM me.
&gt; if there were an error, it could not be instantly detected, either by the whole code crashing, the links being broken, etc. If that's true, then where do bugs come from? Why does every piece of software ever written have bugs? Why didn't the developer catch the bug when their app crashed, or their website had broken links? Real bugs don't crash your site or have any obvious side effect. They go unnoticed for months. Consider the following code: if ($foo = 2) { // ... Do something here ... } This very common mistake wouldn't crash your site, and 99 times out of 100 everything about your software would appear to be operating correctly. Consider the "base_url" configuration value. Setting it to "http://site.com" instead of the correct "http://site.com/" isn't going to crash your site, but some where, on some page in your site, something isn't going to be rendered correctly because you forgot the trailing slash, and it *will* go unnoticed for a while until you chance upon it, or one of your users finally sends you an email. A correctly written setter method could prevent that mistake, but more importantly the setter **would** crash your site by throwing an exception so you can quickly spot the mistake.
Because if you want to change the service that sends the mail, you don't have to change your code that is requesting to send a mail.
Yet again, if the user wants to override it that's their prerogative, and they know the repercussions. Not to mention there is nothing stopping them copy-pasting the class and removing 'final' if they really want to.
I partially agree. 100% of written software has bugs, yes, but how many of them come frome miswritten configs or values? 2% Also, a wrapper class definetly won't protect you from syntax typos like if ($a = $b). IDEs are the ones who care about them. To clarify, you are right, bugs happen, programmers make mistakes. But wrapper classes for config files with specific setters and getters are overkilling and a pain in the ass to write. (Copypaste, replied on the wrong place.)
&gt; Not to mention there is nothing stopping them copy-pasting the class and removing 'final' if they really want to. If you think this is a viable option for development then I don't think it makes sense to discuss the pros and cons of `final` any further. It's exactly the same argument with all ways of encapsulation.
I doubt your drive to remove reasonable safety checks in order to save 2 microseconds in performance stops at configuration files. Also one could say benchmarking PHP defines vs JSON is overkill, but that didn't stop you from doing it. The time spend doing that could have been spent writing a class, and then you wouldn't have to worry about that 2%. Again, my comment isn't about configuration formats. It's about sacrificing good programming practices in order to squeeze out an infinitesimal amount of performance.
Exactly. Your application should define its own interface such as "Mailer". And in its concrete implementation, inject the third-party library's mailer you wish to use. If you switch to another third-party library or swap in your own, you create a new concrete class that fulfills the same "Mailer" interface your app expects. This is one of the main advantages of OOP and doesn't require an event-based architecture to implement.
We agree on that, but some practices are worth the performance loose, others don't. In this case I think it doesn't.
well said. I'll stew on this for a bit. I've come up with my own kind of pattern for developing apps. I need to blog about it soon and get some feedback. I'd like to ping you to take a look and get your opinions when i get to writing it up if you've got the time
A solid point. I will ask other places! However, I have some responses to those sentiments. It's entirely possible the website just needs to be HTML and JS, and it may very well end up being just that. I'm not married to the idea that it's gotta be one thing or another. But I looked at this as an opportunity to learn and try out something new using technologies I already understand, and I figured this was the place to ask. I'm sure if I asked in /r/rails, they'd have a list of gems 10 miles long for me!
I've implemented this, and it works perfectly. I'm going to explore other suggestions in this thread, but I believe this solves my problem. Thanks very much for the advice.
Thanks for the guidance and the link to Aura.Di -- sounds like a very elegant solution. Exploring this over the weekend.
Very useful advice -- thanks for the response. I have no experience writing singleton classes, so first step is to find an example. I'll look further into grouping SQL queries, though this may have to be second-round shoring up of code -- time to relaunch closing fast. Again, many thanks!
this gives me the feeling of the over-engineering era of Java and J2EE all over again.
for complex configurations, JSON or PHP, you'll want to cache them explicitly. if you're using PHP-based config though, you'll have the benefit of the opcache/apc working for the PHP-based configuration.
I think the whole 1st paragraph of post was intended to explain why this topic was named this way. I hope you read it. 
Hey if thryll sponsor a guy with ten years pkus in the IT field with no degree...im down. Ill give it a go.
While there is a good argument for using other testing frameworks I still enjoy using the built-in for Laravel, PHPUnit. This package will be useful for others who also wish to test with PHPUnit. It also ties in with [watson/validating](https://github.com/dwightwatson/validating) for testing the validations of your models. I built this in response to [Laravel-Test-Helpers](https://github.com/JeffreyWay/Laravel-Test-Helpers) no longer being maintained, along with the plethora of PRs to fix issues that never got merged in. I've tried to credit all the incoming code that never made it into that package.
Any advice on picking one?
I did read it and stand by my comments. What they've titled as "unit tests" are not. They're integration or functional tests. Unit testing is about testing *units of code* not anything that interfaces with them. Their example of model class unit tests not providing any value is invalid. Depending on the kind of model you prefer, it's entirely possible that there's additional processing happening in other methods that are not getters and setters that needs to be tested.
heh, that was my question over at Laracasts. funny.
You could have just said you don't use version control and ended it there. +1 on the whole "you need a new job thing"
its personal preference.. but its a good idea to keep model/view suffix on class names.
Latest version of Cygnite allows you to build form as component and you can make use of it where ever needed. You may have a look at sample form shipped with cygnite skeleton application. https://github.com/cygnite/cygnite-application/blob/master/apps/components/form/Registration.php
You don't complain about the code. You can secretly judge all you want, but outwardly expressing that to superiors and even co-workers is a bad idea. You offer solutions to make it better, if you have the time and a good enough reason. Otherwise, you work with what you have and make sure anything new that you add on is clean and works well.
Yep - this is the way I do it - take advantage of the OPCache since it's a pure PHP file. With short array syntax in later PHP versions you can get "more JSON" like.
I personally don't do this anymore since namespaces came along. The namespacing implies the model/view/controller type.
I have a similar question. I get how the command bus design differs from events, but my question is: why use the command bus when you can just call on a service object to perform the command? So, for example, instead of a command like 'registerNewUser', you could just ask the user service to register the new user. $userService-&gt;registerNewUser(...) Why go through the extra work of the command bus system?
&gt; and I assure you that they do a better job of it than you or I Then why are you worried about 'anomalies'? If it has already been tested better than you could possible do yourself then you should be able to trust it just as you trust your compiler and other tools.
The goal of testing is to find problems, not excuses to ignore them. 
Any chance of you sharing that tutorial? :)
Be respectful. At some point it'll be someone looking at YOUR code. Face-palm secretly, treat them like you'd want to be treated publicly. :-P It's OK to suggest better ways to do something, but berating someone for a coding decision they made is unlikely to help them, and can burn bridges.
because one should try and prevent people fucking up
And the list of things wrong with that is infinite.
Why don't you use POPO? Using plain text format for configuration has advantages in compiled languages, but for php I can't see any reason not to use a class with public properties. It's easy to override, extend, it offer great autocomplete and is cached by opcode caches. The argument of messing up a config, does not convince me - every format can be broken. Interchanging config data between different systems is not so common, and even then serializing your object to Json is just one call to json_encode.
Lot's of good answers here. Here is my story: during random office hours I often mention articles on PHP that I've read, mostly my team say things like "You read about programming in your free time? WTF?!" so remember that the latest new interesting useful thing you read that will improve productivity 200% is unknown to most people you work with. So all the re-inventing the wheel is 'inventing something new' to most coders. Think about how close they got to a really good solution. I find that when you point out the flaws in their design they are usually aware of them.
It looks like your using a library - mailer/class.phpmailer.php - to send the email, and you haven't specified what that is or where to get it.
In fairness, mailer/class.phpmailer.php might handle that. We don't know. Tho the fact that the script invites the user to enter a email address then sends the email to that means it will *def* be abused by spammers.
It's very easy to judge someone else through the code they've handed over. Although be wary of what you don't see: scope creep, time pressures, u-turns and other factors that contribute to the code you're looking at. The old rule applies: "you can have it quickly, cheaply or done properly. Choose two"
I'm in the process of gutting and rewriting a package I maintain and inherited from someone else. I've been looking after it for about a year and I've noticed enough little things that probably shouldn't be done and I wanted to rewrite it. I wouldn't do this unless I was the only maintainer because the old code was pretty useful - I just struggled to maintain it.
&gt; A style sheet for example is always inherently readable, but very difficult to organize well. I recommend using LESS or SASS to write your stylesheets, if you don't already. It can really help with things like that.
Did you try with the official documentation? There are various blogposts/cookbooks in there as well, see http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/index.html#id3 I also have an old/rusty tutorial for it at http://marco-pivetta.com/doctrine2-orm-tutorial/. I used it only for teaching the ORM to some co-workers, but it still gets some basics straight.
Planning to go, hopefully for longer than 2 days this time. It's like fishing for OSS contributors :P
I'm getting the feeling he's really referring to this article penned two years ago. http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/ It's the only article I've seen referenced when someone says PHP is dying or should die.
I'm not going to continue this conversation, because you don't seem to have a firm grasp on *why* we isolate for unit tests. "Problems" within your database schema are neither database software issues nor application code issues. If you do not mock the database, then you are not testing your code in isolation, and schema related problems will then pollute your code's uni test results, even if your code is fine. Please read up more on the subject to get a better explanation.
I started with your tutorial and continued with the official docs. Worked pretty well for me. Thanks a lot btw :)
I have a few articles about it at http://ihaveabackup.net/tag/doctrine2/
I'm super wary of anybody who comes in to a project and immediately starts badmouthing the existing/old code. Anybody with experience should know that there are a million possible reasons things could have been done a certain way, and until you have a full grasp of the project and all of its history, you can't really make a fair judgement. Plus, you never know if that code you're crapping on was written by the person you're complaining to. Obviously this is beyond the basic level of just being competent. If there are major security holes, definitely bring that up right away (though still best not to assign blame, just point out that the problem exists). What I see far too often is people who are trying to justify their position, or gunning for advancement, who use this tactic. The problem is that it can be effective fairly often, especially if management is not particularly code-savvy. Which has a tendency to encourage the continuation of this practice. I try to view the whole thing the same way I treat freelance clients. If I'm trying to sell somebody on buying a new website from me, I'm not going to lead off by telling them their old site is crap. You get a lot of closed doors that way. I'll start by telling them all the things we can do better, point out benefits the new code can bring. From there it may transition in to explanations of why certain old things should be done a different way. Again its not explicitly saying the old way was wrong, just that this new way is better. Eventually, if there is stubbornness or enough established rapport, I may go in to details about why certain old things are actually bad. But truth is, I almost never get to that last step, at least not with management.
I'd be interested in this as well. However, most of the time, the DBAL just wraps PDO so I'd say the penalty is negligible when using a PDO driver with Doctrine DBAL. Really, what it comes down to is this: you should use the DBAL if you appreciate the features it provides. Do you need to interact with multiple database platforms? PDO can handle that just about as well as Doctrine DBAL. But if you want things like the DBAL's QueryBuilder API and object-oriented Schema model, then you should use Doctrine DBAL and not worry about performance until you have a reason to. Unless there is some super major performance penalty in using Doctrine DBAL (which I doubt exists but would love to be proven wrong) then you may be micro-optimizing before your project has even begun.
Last employer to suggest i take one of these was asked to kindly fuck off. They made an offer on the spot. /truestory
The performance of virtually any proper DBAL is going to be on par with PDO, simply because DBALs don't do much (though, what they do is very useful in saving developer time, which is why they exist). The extra abstraction has a negligible performance impact, like any extra code will, but making a decision based on this would be the very definition of micro-optimization. The better question to ask yourself would be: "which solution will save me more development time?" And the answer to that is definitely a DBAL.
The reason that I suffix my models and views is because it allows to autoload them from PSR standards. 
It's basically taking the layered architecture diagram and making it explicit that there are multiple interfaces to your app, each perhaps requiring separate layering.
considering the performance implications of the Data Access technology you're using for your Data Access is considered a micro-optimization? Or did you just use that word because you seem to be under the misguided idea that any consideration of performance is unnecessary, or that the consideration of the performance for something as large and cross-cutting as your data access is a micro-optimization? - you have no idea what constraints I'm working under - you have no idea what my level of experience as a developer is You flat do not have the information necessary to reasonably tell me my information collection efforts are premature optimization (much less micro-optimization!).
Hey, thanks for that. I had come across that link previously, but it seemed to be the only resource I could find. I was hoping there was more information that my google-fu just wasn't finding :) If you do find any more information, please let me know.
You said you don't care about the ORM part, but now you mention DQL. Are you sure you understand what Doctrine DBAL and Doctrine ORM is?
They're not exactly going to say that last year's conference was better, are they? I submitted some talks, waiting to hear back whether they got rejected or not.
It won't matter.
Not only is it normal, but automated testing is so much farther from being a de facto practice in the real world than the internet would lead you to believe.
I had gotten the impression that DBal is able to hydrate directly to objects. I assumed that implied some form of DQL can also be used with DBal, is that not the case? If so, then I would be more likely to just use raw SQL and restrict usage of the QueryBuilder to those times when I truly needed dynamic queries.
"This could have a negative impact of I ever need to use my old supervisor or his client as a reference." It might, but it's more likely it'll have a negative impact on that new person who's bitching about your code. I've bitched about enough code - others' and my own - that I don't do it much anymore *except* when I'm in a position of being directly and solely responsible for dealing with it. If I'm expected to keep it running - fine. If I'm expected to make large changes and be responsible for those changes, I'll point out the issues I'm going to face, and prepare everyone involved for things taking longer than expected, and to be prepared to deal with issues we're not aware of. If I'm expected to make large changes and will be involved for a while *and* the system is still not a core part of a business, or can be rebuilt with a minimum of impact to the existing business operations (rewriting with long term benefit for little short term downside), I'll propose that. If it's something extremely large and impactful, I may still lobby for a rebuild, depending on the players. "Refactor" is what is often argued for, but... I had a situation where I was brought in as a consultant on a large system handling a lot of work, but it was still new (only about 5 clients out of 100+ had been transitioned to the new system). After 2 years of building it with their own custom templating systems and what not, the original team of 6 all left within a month. I was brought in and helped keep things running and we hired some new people, but they had to learn the language and framework as well as what the code was doing. For several months we were learning the business operations and what the code was supposedly doing at the same time, as well as figuring out how to identify discrepancies between the two. Is X not working because it's broken, or does it work differently in different situations, or did some business unit decide that it needed to work differently in the future? The "refactor things slowly" mantra makes sense when you have a team of people who have some long-term knowledge about why things are the way they are. Taking over an established codebase that's running everything also can make sense. In this case it was a barely launched system that was not yet entrenched with a new team and *no* deep knowledge of the business or industry or codebase. We *should* have rebuilt. The previous team had been very 'clever' with their code, trying to optimize everything for a js-heavy site, dealing with microsecond issues, but had stopped doing logical unit tests and functional tests the year before, so there was nothing outside of their brains that had any real benefit to the new team (and the previous brains had gone).
DBAL is capable of hydrating to objects (I think it does this to date fields -&gt; DateTime by default), but it has nothing to with DQL.
Oh fuck this guy. PHP arrays are powerful and flexible and simple to create and use. They just get the job done. That's what PHP does, it just fucking gets the job done. That's what has made it so popular and that is why this guy is completely wrong.
Agrred, Where's my pitch fork, I just had it....
Welcome to normal. Best practices become standards of operation when people like you look this situation in the face and rather than fall into line with what exists, set an example that others can follow. There is no other way typically. Gold sinks and shit floats, and without some effort, you can pretty safely assume what will reach the top first. 
I would have appreciated more examples of an array turned in to an object. The example he used were more or less psuedo code and didn't implement what he said it could. I use arrays a lot, probably too much, so I'd love concrete examples for everyday problems. 
They're easy and useful. This guy needs to stuff it.
Even for very large projects? I can understand for small to medium sized projects, but I can't see how a sufficiently large (and stable) project can exist without safeguards. If it is possible, then what is that allowed the project to continue to work and grow? Does it come down solely to the skill of the individual programmers?
I guess Lerdorf's talk about OO being slow had made a huge impression on PHP users. 
What this man is advocating is essentially replicating that same structure, but putting a load of classes on top of it to make it _more_ complicated. At a very primitive level, "abusing" arrays in the article's example is simpler and less time consuming than this method. Only in large applications is it worth going to the extreme of creating a collection / iterator class per "dimension" of the array... and at that point, a good programmer would consider alternatives to managing so much data at once, anyway. In fact, in a way, this article is a bit of a straw man - doesn't this gigantic array look more like a JSON document to you? Something you'd get back from an API, perhaps? Hmm.
&gt; Implying commenters read the article 
And with more and more JSON data out there that you have to consume, multidimensional array use is increasing.
Guys in their teens are wannabe hackers - the more unreadable my code the better. Guys in their 30's are seasoned pros - keep everything simple a retard can read &amp; maintain it. 20's - middle ground, pattern over-engineering, pimp-my-github phase. 
What do you mean by "Host static site generator" ?
TLDR: Arrays are evil, let me show you how to use Iterators!! That return an ArrayIterator...
Rather use namespaces to separate different types of classes.
No, I've implemented a few apps that make use of Facebook's SDK. He wasn't asking a specific question so I can't give him an answer any more specific than RTFM.
I don't disagree with *everything* he said but I feel an extremely strong desire to read an article on all the ridiculous instances of cramming array data into an object for oops sake.
&gt; it just fucking gets the job done. How very short term that sounds, you are part of the problem and why PHP and it's devs have a bad name. The entire point of this article is to realise you'll be maintaining this code for years. 'Just getting it done' does not cut it for professional long term development.
&gt; My problem here is that arrays are *always* used where objects should be! Stopped reading the article at that point.
"Arrays are not evil but should only be used when a collection of data has no associated behaviour." On the other hand `$user-&gt;getName()` is not a behaviour. The reason people use objects when they can use arrays is that the IDE's autocompletion makes it so you don't need to memorize the structure of the array.
Just because a tool is powerful, flexible and simple doesn't preclude it from abuse. Getting the job done doesn't imply engineering best practices. Often times, for the flexibility gained, important things like maintainability and testability are sacrificed. Not to mention you lose the power of encapsulation (arrays have no way of expressing behavior) and polymorphism (arrays are of type array) which is essential for quality OOP. Don't get me wrong, when used in the right context arrays are a perfectly valid tool, especially in PHP. The examples highlighted in the OP's article are commonly found in PHP and it's a shame. It makes the community look like amateurs. This is especially a shame for the folks in the symfony/laravel/hhvm communities working hard to make the community a better place.
ITT: PHP script kiddies complaining about someone bad mouthing their arrays.
Dern you and your reasonable response :) I can agree that it's all situational. No problem. I'm not going to use or not use a data structure based on how it "makes the community look like amateurs" though.
Stuff like Jekyll in php
It's not just simpler and less time consuming, a simple multidimensional array is also much more efficient than a set of objects and a collection both in terms of memory and performance. This rarely makes a significant difference unless the data is huge, but still.
It usually comes from sheer manpower. And trial and error. Most testing, where there is formal testing, is still done by hand (mostly) by QA teams in large organizations.
a "shed load" of data? ha
That's interesting thanks for the comments.
Exactly!
Any application sufficiently large for that to actually make a performance difference needs to be well-structured, which probably means not using massive multidimensional arrays, right? Also, I'm pretty sure performance is incredibly inexpensive these days. Certainly cheaper than spending engineering time maintaining something poorly structured.
[Sculpin](http://sculpin.io) has been around for awhile too
Sculpin (as mentioned by another user) is what you're looking for.
Spress: http://spress.yosymfony.com is another option
Shitty developers will talk shit about previous developers to buy them some time to figure out what the fuck they are doing. Good developers will just do the fucking work. 
Pretty much this. Real programmers who have been out there and doing real work dont care so much for patterns and the latest buzz word, we just get it done. Arrays are useful, we use them. Objects are useful, we use them too. Theres no point getting so emotional about it all.
&gt; Just because a tool is powerful, flexible and simple doesn't preclude it from abuse. Quite the opposite actually. "I have such a good hammer! And look at all these nails!"
This is the opposite of the point of OO, which is why your "pinch of salt" doesn't work. The point isn't that you "use a class for storing data". It's that you store your data in a format and structure that you can access it with a logical and readable way, that doesn't get absurd when your data gets bigger. The point isn't that you need "A class just for a method without related data" it's that you want all the functionality to be in discrete blocks that can be tested and maintained in one place. Globals are not your friend. 
I agree that cyclomatic complexity and other static analysis tools are mostly good for finding refactor targets, but I think you're undervaluing the correlation between cc and readability. Heavy branching, for example, vastly increases cc and also decreases readability. I think it's quite reasonable to conflate the two.
I read a nice article about this a while ago, that made a good point. This is that when we look at someone's code we look at how it is now, and we have no idea how it got to this point. I once wrote a B2B industry intermessaging system using an open source auction system as its core. So it had a bunch of dumb legacy code to support highest bids, etc. On a site that didn't even have any bidding. Because when I started it, it **was** an auction site. Requirements had changed organically, and so had the code. This is common in projects, though that's an extreme example. It's possible that "dumb" solutions were necessary for reasons that are no longer clear. Although, it's often the case that they're just really dumb. It's easy to judge other people's code with hindsight. Another point is that code other people have written is in past tense. I know I am still learning and code I wrote 6 months or a year ago is often slightly embarrassing. The person who wrote this herpaderp may well be the same. [Here's the article](https://medium.com/@shamoons/why-your-previous-developer-was-terrible-506a06ae35ea), by the way. 
I work at a major ecommerce provider, for example, and we dont' have any baked in automated testing on either of our platforms despite having a 10% market share. And that's the norm. It's sad but true, but business people, not developers and software architects, make all the decisions, and it shows. It's probably why so many small niche software shops started by devs and run by devs do so well (until they cash out and hand it over to business people).
&gt; What this man is advocating is essentially replicating that same structure, but putting a load of classes on top of it to make it more complicated. &gt; Only in large applications is it worth going to the extreme of creating a collection / iterator class per "dimension" of the array To expand: In a simple, narrow view, all this extra code is more complicated. Implementing it takes time, a not-small bit of extra code, and is a more advanced topic. That said, when your codes base starts getting larger, having clear interfaces/methods on collections (and ultimately getters/setters on the returned instances) is far easier for a larger team to develop upon. Basically, there's very little room for error -- if you call a wrong `method()` PHP will fatal you. If you call a bad `$array['thing']` you get a plain notice which, sadly, can be pretty easy to, well, _not_ notice). And, of course, if you have an IDE you get full code completion which makes is bloody obvious that you've made a code error (red squiggle underlines) and even easier down the road if you, god forbid, ever need to refactor your data objects. _(IE: Have fun searching for that array key of "config" throughout a codebase.)_ For your small home grown project, butcher arrays as deep as you want. If you want multiple people to work on a codebase day in and out, put better structure behind your data objects -- don't make me have to alt tab to the magic list of what's in the array every time I can't recall what library 56 of 738 wants me to call `person` value. _(Was that `person`? Or `user`? Hrm, maybe `userInfo`? Ugh...)_
I started skimming at this point. To sum up my thoughts: if you are dumping JSON from a database then use arrays and json_encode them; else *consider* using classes.
No, I am agreeing, saying it does the opposite of precluding. It makes it even more likely. *Useful* and powerful tools are more likely to be abused.
&gt; PHP arrays are powerful and flexible and simple to create and use. Simple to create and use, yes. Flexible, sure. Not powerful though. By definition they are behavior-less packages of data. It's silly to use an array as a data container when you should be using an object to get TRUE power and flexibility out of it. I can't count the number of arrays like this that I've refactored out into objects to drastically simplify working with the data that they contain. There are plenty of situations where using an array is fine, but not when it makes your code harder to maintain or makes you repeat yourself a lot. Passing an array of data into a method or other class as an argument makes it impossible to validate for integrity. Properly using objects saves you from that problem. If I have some client code that wants to consume data that represents a comment, passing that data through as a Comment object instead of an array will allow me to guarantee that the data is complete and safe to work with, rather than a bunch of isset() or null checks.
I had a project two years ago that stopped me from badmouthing developers. The reality of the situation was that although the parts of what we were doing were not new, the arrangements of those parts had not been done. That led to what many would call 'bad' code. However, it actually was brilliant-- the prior team had come up with a system that 'worked'. After I had started over, I realized what they had accomplished and had more respect for that team even if I would have done a few of the little things differently.
Yes lets take a simple data model and make it needlessly more complicated by adding layers to it. Know what the learning curve is of an array? Zip. None. Look at it and you know it. You're going to spend more time writing up your classes than you will building a simple function to parse arguments into an existing structure. Plus littering your code with objects will only serve to lengthen your already short time with educating new developers on your code. Arrays are meant to be "abused" because that's one of PHP's greatest features. There is a time and place for arrays and objects of course, its subjective, but one should not conduct a witch hunt on every array in existence to justify itself.
&gt; Don't over-comment your code (if your methods are simple and readable, your code is more or less self-documenting - in fact if you find yourself using // comments inside of a method, it's a hint there's a code smell that your code is complicated enough you find yourself having to explain it step by step). I couldn't possibly disagree more with this. The only time "over commenting" is an issue is when people just put in comments telling what code literally does, which is useless. There is no such thing as "self documenting code" beyond the trivial level. Comments should inform the reader what the purpose of the code is, and/or the context of what it does, and/or a short description of the goal of the section. One of my pet peeves is that so few people know how to write effective comments. They are absolutely crucial to code quality. If you're more often than not writing methods without a single comment within the logic, then I respectfully suggest that you should reevaluate your coding standards and research comment best practices.
Wow. So, a few things here: * Don't put words in my mouth. I never said performance of your data access layer doesn't matter. I said the difference between PDO and a DBAL doesn't matter. * I qualified my statements (which you seem to have ignored completely while flying off he handle into some weird ultra-defensive mode) by saying that the differences are negligible, and making a decision based on negligible performance implications would be micro-optimization. * Your needs, scenario, environment, etc. are all non-factors. The level of performance differences between PDO and a DBAL are so trivially small that if it still mattered, then 1) you shouldn't be using either, and 2) you most likely shouldn't even be using PHP.
Being able to enforce an interface is a good enough reason for me. I couldn't care less about IDE sorcery.
Didn't think Sculpin was complicated at all. Did you try posting an issue?
The fact that this is the top comment speaks *volumes* about the average PHP developer...
Isn't CI's Helper model the most analogous to DDD's service object?
Because it requires code at google.com. 
The downvotes you are getting confirms your point. 
Recaptcha is the best. Although I do like KeyCAPTCHA because it looks cool (solving puzzles).
I have recaptcha installed on several form on several website, but sometimes spam comment can break through it. seems that spammer technology also improved
One of the requirements, if it was my project I would have used recaptcha. 
This is the hare-argument to OP's tortoise-argument.
If you're using prepared statements, you're already safe from injection. (In 99% of cases.) The idea behind injection is that if you're running user submitted variables like "insert name='$value' " as SQL queries, someone can submit their value as " ' ; drop table users". So the database would see your query as "Insert name=' ' ; drop table students". (So the user's submission closes the quote, starts a new command with the semicolon, and then they have full access to your db). When you use prepared statements, you tell the database *exactly* what the query and what the data is. So even if there's a quote and a semicolon in there, it'll just get saved as raw data to the field in the db. The other 1% of cases is something called secondary SQL injection. And that's if they manage to store a semicolon/command in your db the first time, but then get your application to retrieve that data, and execute it again as "safe" (instead of properly parameterizing or escaping it). But it requires a very intimate knowledge of your database and application to execute, and you'd probably get compromised in other ways before it happens.
I'm not familiar with service objects but I thought it's treat certain services as objects. So we implement service class and initiate them to execute certain tasks. CI's helper only contains some functions. you mean we could implement the services in functions? But is that OOP?
&gt; it may allow attackers to potentially execute arbitrary PHP scripts on the server How does that even happen? Are you eval'ing stuff?
Have a look at http://code.google.com/p/cool-php-captcha/ The name is a little silly and the code breaks several best practices. But the results are pretty good. The images are usually very easy to read for humans but surprisingly hard to read for machines.
That is so fucked up XD
While SQL Injection is a specific mode of attack, there are "injection-like" attacks on a variety of platforms, such as mass assignment vulnerabilities that existed on Ruby on Rails platforms and potentially are implementable on something like Laravel as well. While you don't necessarily need to be overly concerned about that specific vector, you do well to remember the key point: **Never trust user data.** 
Its even harder when you are judging your own code from a few years or a few versions earlier. Then I like to rip it to pieces, ask what this idiot was thinking and wonder aloud if the author was on drugs when he added this specific piece of logic. Or daft comment. Or inconsistency. Or lack of defensive coding/missing logic branch/raneg check or whatever I find. As gracious as I am to others, I dont afford myself the same comfort. I almost always write better code the second time round, which means the first time I just was not good enough for my own standards. Then of course, the third time round I see how bad the second time was... 
`call_user_func_array` using input data, by the looks of it.
Explicitly, you also need to be verifying the *submitted* values against that whitelist, because it's trivial to add values to select lists etc in the web inspector. 
Or adding a ' or 1=1' clause to a login, granting them admin rights or access to another user's account.
Evaluation is used in a lot of places in the framework, [for example](https://github.com/yiisoft/yii/blob/1.1.15/framework/base/CComponent.php#L607) . Anonymous functions work so much better, but most tutorials still go with the eval approach. That said, the specific issue being fixed here does not come from the specific snippet I linked above. You of course know that once you have `$func = 'function_name';` or `$func = ['class_name', 'method_name'];`, PHP allows function calls through `call_user_func($func);` or, in the first case, even `$func()`. `CDetailView` is a widget to display an object as a list of "key: value" pairs (maybe as a `&lt;dl&gt;` or a two-column table). For each property you want to display, you provide a `$func` as the renderer. It can be an anonymous function that formats the value as currency, it can be a literal string, or something else. Here, the framework tried to be helpful and handle function callbacks given as string/array literals. In that case the question is "should `$func` be evaluated as a function call or returned as-is?" - unless `$func` is a `Closure`, there are arguments for both choices. Made so much more entertaining by PHP's polluted default namespace.
&gt;If I'm trying to sell somebody on buying a new website from me, I'm not going to lead off by telling them their old site is crap. You get a lot of closed doors that way. So true. Did this several times and doors were closed :( I'm idiot
Integrate the Symfony2 DIC and be done with your worries. That's what I've had to do with a legacy Symfony1.4 project too; there's simply no good alternative to *some sort* of container other than lots of boilerplate instantiation code.
Generally, no. I think what you're asking is if you can run something *like* jekyll, but using your shared hosting provider. The static generator typically requires a shell/terminal access of some kind to run the program that mashes all your markdown/template/css/etc into the "static" site. (Which you would then upload somewhere else). Most shared hosting providers will not provide this. That said, install VirtualBox, toss a quick Ubuntu/CentOS on there, and `yum|apt-get install php` to run your own.
Why do you need virtual box for that? Windows will do just fine, I think..
&gt; "Insert name=' ' ; drop table students". Try doing this with any PHP database library. It doesn't work in the way you think it does making it the worst example of SQL injection in a PHP context.
For the php one, I suppose. However, you'll start playing with [static site generators a-plenty](http://staticsitegenerators.net/) and quickly come to the conclusion that installing php/node/ruby/etc on windows is not fun.
You *can* use pdo's variable parameters to insert the order by parameter. You just need to tell pdo to treat it as an int instead of a string. 
Documentation can be here: http://hoa-project.net/Literature/Hack/Eventsource.html.
Why would you ever host something like this on a PHP shared host? Use S3 and Cloudfront. That's VERY fast and VERY cheap hosting for static sites. And most static site generators will have an S3 deployment option. Just not PHP because why in the world would you use PHP for a static site generator?
Exactly what I was asking , thanks :) got it.
because lamp stacks are a pain on windows?
Well duh?
I generally use a framework like Symfony for work-dev stuff, so its baked into Doctrine. Buf if its custom stuff thats outside of PDO, then I’d try and remember to do it within whatever DB adapter im doing. 
This comment is NSFW.
How does it work?
Ya, I thought it was.
Nah, you should never bother. What domains do you admin by the way?
Are the differences between PDO and DBAL so trivially small? You've actually tested them, and/or read over the documentation others have put out with respect to the performance differences between the two? You can tell me roughly what the performance cost of, say, using the QueryBuilder to build a fairly simple query is, and the difference between using it with a CacheProvider and without? wow, that's great, that means you have the sort of information I was looking for when I made this post, __how about you fucking respond with that to begin with__? And I feel like dsimcha said it best in this stack overflow response http://stackoverflow.com/questions/3470990/is-micro-optimization-worth-the-time _As the cliche goes, micro-optimization is generally worth the time only in the smallest, most performance-critical hotspots of your code, only after you've proven that's where the bottleneck is_. [snip] _1. **This doesn't mean that performance should not be considered at all upfront**. I define micro-optimization as optimizations based on low-level details of the compiler/interpreter, the hardware, etc. By definition, a micro-optimization does not affect big-O complexity. Macro-optimizations should be considered upfront, especially when they have a major impact on high-level design. For example, it's pretty safe to say that if you have a large, frequently accessed data structure, an O(N) linear search isn't going to cut it. Even things that are only constant terms but have a large and obvious overhead might be worth considering upfront_. --- The reason I reacted the way I did is quite simple. I knew I was going to get at least 1 person who responded the way you did. Luckily, it was only 1 person, __YOU__. I did not ask if I should be doing this, I asked for more information on the performance implications of a specific part of a technology stack so I could better understand how things could potentially scale going into the future. You chose not to answer the question. Next time, just answer the question that was asked please, not the one that was unasked.
switch statements being the obvious degenerate example. The various metric engines for CC can't even decide if you should, or shouldn't treat switch statements as if statements.
&gt; I tend to solve issues like that by using hard-coded whitelists, so the user's input is used to pick from a set of pre-written field names. This is the best solution. You already know all the possible field names and they will always be limited. Also, even if you could "parameterize" field names, users could easily submit incorrect field names and cause queries to fail.
&gt; There is no such thing as "self documenting code" Also couldn't possibly disagree with this more, IF the code is written well with sensible variable and method names, and if methods aren't miles long with triple nested control structures. I guess maybe I have an easier time knowing what code does than most people, because to me, comments in logic is always analogous to telling me what code "literally does". Again, unless your have awful variable and method names, or you're a one-line hero, there's no reason to have in-method comments telling me what code does. Any methods long enough that you need comments to help keep track of what's going on, can be broken up into multiple simpler methods.
This one looks the best . It's safe, very customizable, and I've never had any problems with it. Most importantly it is also never hard to read. https://code.google.com/p/cool-php-captcha/
Took me a while to find that to. http://cleantalk.org/faq#blacklists
It's not a syntax change.
Since you came in with a chip on your shoulder, and seem wholly intent on fighting someone/thing, to the extent of disregarding what they actually said in favor of what you seem to have hoped they would say, I'm going to leave you to your rage now. Good luck to you.
similar to mechanical turk?
php in html? I mean, bussiness logic inside presentation layer?
Looks cool. I'm going to check this out later today!
Either way - be consistent.
&gt; I know there are quick fixes - like prepared statements Parameterized/prepared statements are not a "quick fix", they are simply the correct way to do it. When used, SQL injection ceases to be something you need to think about.
Completely procedural PHP code in the same documents that render HTML? Without even using functions? You should be reading tutorials, not writing them.
You have to cache the content yourself I suggest you look up a PHP cacheing library and configure it with memcache on your server. Most full stack frameworks include a cache class
Can't you use a static site generator?
For clarification, since I don't see anyone mentioning it, is mysql_real_escape_string() thorough enough for parsing user data before executing a query? This was the case 5-10 years ago, but I may be out of practice now. Are there additional steps that should be taken?
Done, PR sent :)
I started playing blackjack a few months ago at the local gambling joint, after losing over 20$, I decided to write a PHP program that simulates casino blackjack. I have an object called 'BlackJackPlayer' where I enter my strategy, this way I can test different counting systems and blackjack strategies on thousands of rounds without betting a penny. Someone introduced me to sudoku a few years ago, after completing 3-4 "puzzles" I got bored. So I wrote a script that will solve any sudoku.
Thanks!
Yeah, but the punch is sooooo gooooood
I can post my script on github if you want. It's pretty boring.
The sudoku script? I'd love that actually. I stopped mine after trying to add some checks for more difficult puzzles (which ended up breaking all puzzles). When I tried to rework it I just broke it further and further. Would be interesting to see someone else's take on it.
I like you.
I like the idea of avoiding the use of arrays as data types. I usually turn these into objects. Otherwise, I use Dictionary, Enum, Collections and Tuple classes in PHP when appropriate. It's a little more overhead, but it's easier code to maintain.
Yeah, it works for me on my computer too. I think it's an issue with Alien Blue!
Nginx also has some content caching ability if your goal is to have largely static content. Have a look here: http://nginx.com/resources/admin-guide/caching/.
Use PHP output buffering to create the static pages or components, then serve the static components instead of querying the database. Update the static components every time a page is changed, and use a cron job to update them daily or more often. I did this with a site and it resulted in a 10,000% increase in performance. http://www.php.net/manual/en/book.outcontrol.php
A windows desktop configuration management and software installation framework based on PHP-CLI for windows, now running on north of 3000 machines
Impressive! Is it "compiled" in some way, or does it require a native php install? Only reason I ask is because that seems to be the biggest hurdle in using php locally on a large number of desktop machines.
I just have a copy of PHP in with the rest of the files; when you take out the web stuff and the extensions you're not using, it's not very big at all. 
As always, very impressive. The small recurring thing that keeps bugging me though (like in other Hoa projects) is the use of magic properties (or other magic stuff) that prevent code completion and refactoring support in PhpStorm. But that's really a minor point.
Very nice.
Not sure if you could consider it obscure, but it was a template system that was certainly inferior to what was already out there, but was necessary to achieve what my then-employer required: * Allow our designers to create PHP templates from full-page static HTML files without having to learn PHP and other template systems/languages (so Twig, Smarty, etc. was pretty much out of the window.) * The clients should be able to look at these said template files through their browser and it should just work as if it was just an HTML file. So I wrote a templating system that parses HTML comment tags to define blocks, dynamic HTML components (banners, sliders, sections, etc), template variables and stuff. I thought it was a very interesting thing at that time, but a few months down the road I pretty much just ignored it and didn't bother porting it to be usable outside our close-sourced, home-grown CMS. I learned a lot writing that one, though. 
ok. I'll upload my blackjack scripts and sudoku scripts tomorrow( holiday here ) and post the link.
This also wouldn't help if the injection was working with a numerical attribute. Consider 'SELECT * WHERE int_att = ' . $value $value = 1 OR 1=1 Escaping the string won't help here.
Wow, that's really cool.
the caching strategy that you'll use depends on how dynamic your page is, and how up-to-date you want its contents to be. 1. generate static pages (for blogs, or pages that don't change) 2. cache page sections or modules (for pages that have parts that change) 3. cache just the data (for API responses) 4. slap varnish in front of your server Depending on which one (or which ones) you use, just remember the need to invalidate stale data.
Treat all users as hackers - meaning never trust any user input whether it's from a form ($_POST) or url ($_GET).
didn't the mysql_real_escape_string prevent parsing '=' ? Also, in the code itself wouldn't you express it as "SELECT * WHERE int_att = '$value' " So they would need their own closing ', which would get caught by the escape?
ITT: People with no sense of humour. Also, infidels who will learn the True Way or die.
Select injections can be used to dump the entire database with the right tools and conditions though, so still very serious. 
1. mysql_real_escape_string does not escape '=' 2. No, a numerical value does not need to be enclosed in quotes with SQL.
What if you wanted to order by (a,b,c), as well as (a,b), (a), (b,a), (c,b,a), etc where a, b, and c are tables?
Since when can you order by ints?
Escaping works fine with numerical attributes. SELECT * FROM table WHERE int_att = '50' If int_att is an integer, all the SQL engines I know of will convert the string into a number. So things like: $id = $_REQUEST['id']; $stmt = "SELECT * FROM table WHERE id = " . PDO::quote($id); ...work fine and are safe.
LOGO interpreter.
Yes, that would get messy very quick. I'm really only referring to simple situations. I can see how this would clearly not work for more complex situations like the one you mentioned.
It doesn't need it, but wouldn't that be best practice? I mean, escape or no escape, having it expressed the way you showed seems sketchy.
I don't think prepared statements can return sets, I think views can though.
Custom Arduino firmware client.
I'm confused. I thought firmware had to be written in ASM?
that could be a possibility, but i think, that they send it to one of their sites, for example a porn site where a real human wants to watch a video, but they put a captcha in front of it.
I think everyone in the early 2000s wrote an IRC bot in whatever language they were learning. Raw sockets what whaaaattt.
It's true. At one point I made a Ruby IRC client that relied on one connected user for output, and another for input, so I could put the windows one above the other and use it like a standard IRC client.
What, I didn't get any punch. This is horseshit, TAYYYYLOORRR!
"There are no images in your location." :( That's what I get for living in BFE.
Yeah, it was made for personal use so outside of one or two random people that have found the site, the only images there are those I've uploaded myself. I never did tap into an bigger database.
En/decrypter for data files of an old required school program because there was a corrupted lesson (or, rather, a typo in markup slipped past QA) I ran out of ACT practice test forms, so I quickly made one in phu with an embedded timer. Http://jceggbert5.net/lolact.php Edit: the link does not render well on a display smaller than 1080p 
**Security** -Any actions that modify data go behind a CSRF key - whether as submit buttons and hidden fields in a form, or key appended to the request URI. Almost ANY web app has a form of some kind, so CSRF is almost always used. Beyond that, it depends. If I have user-submitted content (comments, articles etc) that gets displayed somewhere, I escape the output. If I have image uploading, I make sure to move the uploaded file to a non-web accessible directory, give it a random name, and then use gd2 methods to re-save it in a proper location with a proper name. **Speed** Make sure queries aren't being looped, and that you're not working with arrays of thousands of elements at any one time. That's the only thing you should always be mindful of in every PHP application. All other micro optimizations don't matter much - it's always looping through HUGE data sets, and looping queries (especially complex queries) that can kill you.
I use this on my site and it catches about 95% of toxic emails and IPs: http://stopforumspam.com/ I'm working on a library that allows you to integrate all kinds of blacklist APIs, so I'll be adding one for this as well.
Test scalability. Load your db with a whole bunch of fake data (users/pages/logs/etc/etc). Waaaaay more then you ever anticipate. This will show the weak points. Some queries that are fast with 10 entries can get exponentially slower with more rows to join in and stuff. We have a web app that is supposed to support thousands of users.. but no one ever tested with more then a few hundred. Slowdowns were countered with throwing more ram and cpu. When I loaded the system with 50k users some pages wouldn't even load. Either from lack of memory or query timeouts (which was set to 15min btw). The culprits were just a few bad algorithms... fixed those up over a few days and now we are actually scalable... ish.
I have found the honey pot method as the easiest and most reliable technique... not sure about blacklists and the likes. Can anyone describe what this is with more detail... as the website appears to act like they offer some sort of black magic service. .
[Relevant Creed Bratton](http://i.imgur.com/b5ac5VX.gif)
If you're unclear about what these are, have a look at [Octopress](http://octopress.org/) (based on Jekyll, Ruby) or [Sculpin](https://sculpin.io/) (php).
If you're writing short, simple functions, like you should, the method name should explain to the caller precisely what it does. If it doesn't, there's a problem that isn't going to be solved by comments. External integration documentation is a separate thing - Markdown files that explain how to do certain things with your code, or application architecture, or business requirements and the sections of code that fulfil them, etc, that's all good. Documenting individual functions or classes is generally useless unless you're intending to release a closed-source library.
I wanted to write my own someday, too. Would definitely be interesting to see another person's perspective.
Are you saying that prepared statements can only return single values?
I actually wrote a Sudoku script over the last few days because I was bored: https://github.com/Brammm/Sudoku It's missing some things but it can solve the basic version in the demo. I'll update the README soon^^TM, but here's some basics: - The sudoku is represented in a [Grid](https://github.com/Brammm/Sudoku/blob/master/src/Sudoku/Grid/Grid.php), Grid contains [Cells](https://github.com/Brammm/Sudoku/blob/master/src/Sudoku/Grid/Cell.php). You can get [Collections](https://github.com/Brammm/Sudoku/blob/master/src/Sudoku/Grid/Collection.php) from the grid (Rows or Columns, no subgrids yet). - Every cell has a x and y coordinate and a value (which can be changed) and a reference back to the Grid (so you can get the column, row or subgrid a Cell belongs to). Have a look at the basic [SingleCell strategy](https://github.com/Brammm/Sudoku/blob/master/src/Sudoku/Strategy/SingleCell.php) how it's all used. The idea is that more strategies get added to solve more complicated sudoku's. It also needs some more ways to navigate the sudoku (get subgrids from the grid), validation if a sudoku is correct/complete. Currently thinking what would the fastest/best way to check if the puzzle is complete and valid.
I don't believe quotes around numerical values are supported in most syntax's.
I wrote a script to automate my betting on Betfair(betting exchange). I sadly counldnt get it to win consistently.
Here are my sudoku and blackjack programs : I wrote Sudoku back in 2007. I wrote blackjack in April. https://github.com/davidtek/ If you want to improve on my code, let me know and I'll give you write access to git hub.
https://github.com/davidtek/
I don't see your point...? quote is not the same thing as mysql_real_escape_string().
Whoops I was thinking of stored procedures. My bad.
It's a pretty long list. I've written these up at [http://docforge.com/wiki/Web_application/Security](http://docforge.com/wiki/Web_application/Security) and [http://docforge.com/wiki/Web_application#Performance](http://docforge.com/wiki/Web_application#Performance).
The easiest way to do this is to have wget crawl your site and make a static snapshot of the php-generated output, then upload those files to your host. wget -mk http://www.example.com/ See [Fosswire](http://fosswire.com/post/2008/04/create-a-mirror-of-a-website-with-wget/) to get started.
Laravel is the best cult I have ever been in. Now that being a full stack developer means eating the shit sandwich that is responsive web design I'm happy to have less work shifted off the back-end.
Sure did. Made a simple IRC bot that would use the dcc to download files. I would then run it on random servers via XSS vulnerability and download the files over HTTP
Stop words extractor for my language (Albanian). Since there was no stop words list anywhere to be downloaded, I took to download as many articles in Albanian and feed it to the tiny PHP program, which would store them in an array as "word"=&gt;usage count. After a good afternoon of feeding it copy-pasted text, I sorted the array and got a pretty decent list. After that I reversed each of the words and sorted them alphabetically, and ended up with a list of somehow safe to remove suffixes. The result was a crude but efficient stemming algorithm.
You can talk to an arduino over serial. On linux, it will show up as device: /dev/ttyUSB0. It's the same with anything with a serial link, gps units, etc
Sweet, thanks.
I used to get a kick out of sending emails to other employees that appeared to have come from the boss- telling them to do silly things at work. Just changed the mail($to, $subject, $message, $headers) headers to make the 'from' parameter the boss's email address. Stuff like asking the receptionist to test the new 'voice activated printer'.
&gt; Wordpress' codebase is awful, bloated, and does NOT follow standard conventions at all. Have you seen the sheer number of globals it defines throughout the application? Ever heard of [procedural programming](http://en.wikipedia.org/wiki/Procedural_programming) and [backwards compatibility](http://en.wikipedia.org/wiki/Backwards_compatibility)? What you call awful and bloated, I call incremental and strategic. There's a reason the code base is the way it is. WordPress came out 10 years ago and still offers an upgrade path from older, major versions to the latest. Quite astounding, and part of why WordPress has come to dominate the CMS market: flexibility + longevity. In 2004 MVC didn't matter; developers built sites without the patterns you seem to require. Maybe these developers could improvise their own patterns they were comfortable with, because the unsophisticated procedural nature of the code base allowed for it. WordPress code is similar to HTML in its flexibility and does not impose on how you should build a site/app. Unlike an amateur or architectural astronaut, scrapping &amp; re-writing the code base every week/month/year is not part of the WordPress philosophy. This avoids alienating legacy versions and those users, offering a sure upgrade path that helps maintain site integrity and mitigate security issues. You don't belong in the core code base anyhow; something tells me *you're doing it wrong™*. Use hooks and filters, build your functionality into the theme or a separate plugin, don't hack it into the core! Globals avoid pattern bloat and overzealous coding standards. They get shit done, quickly. If your brain sees a Global and goes BSOD, it's not everyone's problem. Like I said, the brick wall is due to your own limitations. You're [limiting yourself](http://www.satisfice.com/blog/archives/27) if you think that there is some kind of best standard or pattern. &gt; But there is certainly something wrong with confusing Wordpress standards with good programming practices, and it's a serious disservice to allow young aspiring developers to believe that Wordpress is the de facto standard in good web development. Nobody said it was the de facto standard. I do however rebuke the claim that WordPress has horrible standards/practices. Disservice would be allowing aspiring developers to develop a naive and biased attitude. I also don't think our OP is an "aspiring developer" anyway. &gt; Then you may as well simply not use the core at all. What's the point in taking the VERY significant performance hit by installing Wordpress when there's no intention of working within its confines? The point is to use WordPress for what it offers so you don't have to re-create the wheel. What it offers is a highly functional/modular backend with good UI/UX where users can register, delegate, publish, categorize and manage content using a WYSIWYG editor without ever having to touch code or markup. It offers a "click-once" ability to quickly and efficiently change the design or extend functionality via plugins and themes. It does these things extremely well. You can build out your site/app however you want. For example, a single page app would have very little performance hit if you're just requesting data from WordPress and returning it to the client in JSON format. WordPress posts/pages still provide the actual content to the SPA, so you don't lose all that out-of-box publishing functionality. I just don't see how WordPress is the bottleneck. &gt; Is this for a client that doesn't have the budget for a longer project? Go with Wordpress. &gt; Is this for yourself, or does your client have deep pockets? Go with Laravel. At least you recommend WordPress :) *It has a chilling effect on our progress as an intellectual craft when people pretend that a best practice exists. Best practice blather becomes a substitute for the more difficult, less glamorous, but ultimately more powerful idea of learning how to do your job. By “learning” I mean practicing the skills of identifying and solving patterns of problems we encounter...When you say that something is a “best practice”, you may impress the uninitiated, or intimidate the inexperienced, but you just look foolish to people who believe in the possibility of excellence. Excellence in an intellectual craft simply cannot be attained by ignorantly copying what other people say that they do. Yet, the notion of a best practice is really just an invitation to be an ignorant pawn in someone else’s game of process manners – or it’s a trick to make people pawns in your own game. -James Bach*
&gt; If you're writing short, simple functions, like you should, the method name should explain to the caller precisely what it does. If it doesn't, there's a problem that isn't going to be solved by comments. Method names tell you what it does. It doesn't tell you the subtleties of how it does it, or why it was done that way rather than a different way, or externally why it was called at that particular point in the greater context of the task. Proper comments should allow a programmer to get in the mind of the original writer to know why something was done. They should allow a programmer to skim at the 10,000 foot level of the code to get a sense of what something does and how it does it, without having to dive into the details. Proper commenting is a validation check that something is doing what it was intended to do. If you've had any experience at all reading someone else's code, no doubt that you've read something and wondered, "Is that what he *really* wanted to do here? Or did he really intend something else?" With professional comments, no one wonders, because the intent is *right there*. And if the intent documented in the comments doesn't match what the code actually does, you know it's a red flag to check it out. Unfortunately, programmers are notoriously lazy about writing comments, and many have invented a whole justification for that not only are comments mostly useless, but they're actually harmful! It's ludicrous and dangerous. If you don't have comments in your code, you don't have quality code.
awww man, beat me to it. I bought steganify.com just for this purpose. we should talk once you get it where you want it. 
dude- repackage that with a Raspberry PI and you've made the perfect mousetrap.
Oh shit I think you just prompted the guy to write a 5 page article on why SOAP is the shit and JSON is for 15 year olds.
&gt; quote is not the same thing as mysql_real_escape_string(). They're intended for the same purpose, escaping SQL data to prevent SQL-injection attacks. $stmt = "SELECT * FROM table WHERE id = " . PDO::quote($id); $stmt = "SELECT * FROM table WHERE id = '" . mysql_real_escape_string($id). "'"; Unless there's some subtlety I don't know about, the two statements above are equivalent.
Oh, that reminds me of another one from my highschool days. Before windows messenger service was patched, you could send an alert popup to any other computer on the network. I made a nice little loop that sent every computer in the school the same windows alert over and over again. I didn't realize it would stack the alerts, so they had to restart every computer in the school or click "Okay" hundreds of times. I was given a warning, as I had been more white-hatted in most of my other network findings.
YOUYOUYOUYOUYOUYOU'VE GOT MA-YOUYOUYOU'VE GOT MAIL I can see it now, must have been glorious.
&gt; They should allow a programmer to skim at the 10,000 foot level of the code to get a sense of what something does and how it does it Documentation embedded as a comment and attached to one specific function is a pretty terrible way of doing this, though. 10,000 foot views should be separate documents in the docs folder, as they can then delve into architectural documentation spanning large amounts of the codebase, and explain business requirements in detail. There shouldn't be any subtleties of how a function does something if you're coding your code correctly. A function should not have side effects unless it's obvious from the method name that it does, and then it should have as few side effects as possible.
No, that's correct. The quotes make a difference, though, and I don't believe quotes work for numerical values in all syntax's.
I think the problem in Lerdorf's talk was that he was trying big frameworks. And profiled and optimized the absolute shit out of it. Including tracing Apache httpd. 
yeah, I won't argue there. But I've seen people saying that because that doesn't work, you shouldn't worry about SQLi :-) I know you're not. But that doesn't mean others won't...
&gt; There shouldn't be any subtleties of how a function does something if you're coding your code correctly. That's a bit naive. Code of any complexity has subtleties of how things are done. If all you're writing is, say, [CRUD apps](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete), then yes, there probably isn't much subtlety there.
Highly debatable comment considering prepared statements don't work in every situation.
[Binary Encoder](http://en.wikipedia.org/wiki/Enhanced_TV_Binary_Interchange_Format) for eTV apps
We had a bunch of customers who wanted to accept paypal transactions in our software but didn't want to pay the monthly charges for service or high transaction fees. In the end we ended up having our payment screen send the customer paypal transaction details to our server. Then a service that would wait for the transactions to come in and parse the data. These would be processed and saved with the data sent back to the client machine. Once the customer finished their session a final tally of usage would be calculated and the process would happen again with a final paypal charge occurring. It was far more complicated then it should be thanks to how paypal handles transactions but I was happy to find a way to screw over paypal and their ridiculous transaction charges and fees.
I develop real-time multi-user web applications across multiple languages, and no, subtleties in individual functions are incredibly rare to the point of being nearly non-existent. *Shrugs.*
You haven't paid enough to learn about the souls of COBOL programmers dumped into the volcano...
It'll generate the page itself every time. Set some sensible cache headers and set up Varnish
You mean netsend? I loved that. Back then my me and my brother were getting into computers and I found out about that little command. Sent it to my parents computer saying that I was wanted by the FBI and to not flee. My dad immediately yelled at my brother. Trololo.
This is a talk I gave at an internal work conference; please ignore the many errors in the slides, but feedback would be gratefully received. Thanks
Sounds like it might be overkill but this is pretty much what [Varnish](http://en.wikipedia.org/wiki/Varnish_%28software%29) is for.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Varnish (software)**](https://en.wikipedia.org/wiki/Varnish%20%28software%29): [](#sfw) --- &gt; &gt;__Varnish__ is an [HTTP accelerator](https://en.wikipedia.org/wiki/HTTP_accelerator) designed for content-heavy [dynamic web sites](https://en.wikipedia.org/wiki/Dynamic_web_site). In contrast to other [web accelerators](https://en.wikipedia.org/wiki/Web_accelerator), such as [Squid](https://en.wikipedia.org/wiki/Squid_(software\)), which began life as a client-side cache, or [Apache](https://en.wikipedia.org/wiki/Apache_HTTP_server) and [nginx](https://en.wikipedia.org/wiki/Nginx), which are primarily origin servers, Varnish was designed as an HTTP accelerator. Varnish is focused exclusively on [HTTP](https://en.wikipedia.org/wiki/HTTP), unlike other [proxy servers](https://en.wikipedia.org/wiki/Proxy_server) that often support [FTP](https://en.wikipedia.org/wiki/FTP), [SMTP](https://en.wikipedia.org/wiki/SMTP) and other [network protocols](https://en.wikipedia.org/wiki/Network_protocol). &gt; --- ^Interesting: [^Web ^cache](https://en.wikipedia.org/wiki/Web_cache) ^| [^List ^of ^commercial ^open-source ^applications ^and ^services](https://en.wikipedia.org/wiki/List_of_commercial_open-source_applications_and_services) ^| [^Proxy ^server](https://en.wikipedia.org/wiki/Proxy_server) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cil0u3y) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cil0u3y)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I take this further and don't trust any data, so basically what you just said but also validate data retrieved from the database and AJAX requests.
Sort of agree but I wouldn't consider thousands to be huge but certainly it is pretty easy for the thousands you are planning for during the initial design phase can become exponentially greater at some point in the future. 
Your line of code is causing an error and you have errors hidden. If you are in a development environment, turn on the errors. Otherwise, check the IIS/Apache error logs. If your code works in one place, but not another, maybe you have a namespace problem or something you are including on one page is not on the other.
That's amazing. If I had automated lighting I would definitely try doing something like this.
Artificial neural network. Was just experimenting, I couldn't make it fast enough at the time though, to do anything useful with it
Point of Sale software, using (the now dead?) PHP-GTK bindings. We supported about a dozen of the most common thermal receipt printers, as well as several verities of customer displays. [This thread](http://www.reddit.com/r/opensource/comments/xqiet/what_open_source_projects_dont_exist_but_should/c5ow1r7) has a rough breakdown of the rationale &amp; features we supported and [here](http://imgur.com/a/OwkYO) are some screenshots of the application running. Though it sounds kinda horrible it was actually a really awesome piece of software - my only regret is that the PHP-GTK project appears to be dead. If I was in a similar position again i'd write the frontend in python consuming web-services written in PHP.
Sources? Everything I find about quoting numeric values on stack overflow says not to do it. I also highly doubt arithmetic would work but I can't test it because I am not on my personal computer.
I wrote an IRC bot in JS that posts the results of my (and a few friends) DOTA matches into our chat channel. It's pretty shitty code (I haven't refactored it to be better) but it works pretty good. Also sends push notifications to an OS X and iOS app I made (with the same data, which opens the DOTABUFF page for the match if you open the notification). I haven't gotten motivated to add more functionality, like the ability to query the bot for info about tournaments or other useful stuff.
You fit my definition of a programmer. &gt; Programmer: Spends 1 hour programming to save 1 repetitious second.
Or [Redis](http://stackoverflow.com/questions/10558465/memcache-vs-redis). Easy to get started with composer and [predis](https://github.com/nrk/predis). "predis/predis": "~0.8.5"
&gt; Sources? Lots of people make lots of claims that escaping data is not safe from SQL injection attacks, but oddly they never actually give an example of how that can happen. The whole point of escape is that it produces valid string data that can be used in a SQL statement. Hence, SQL injection is impossible. That said, it is generally *preferable* to use prepared statements, but sometimes a simpler statement is easier to read. Welcome to the MySQL monitor. Commands end with ; or \g. Your MySQL connection id is 2384435 Server version: 5.1.73 Source distribution Copyright (c) 2000, 2013, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\h' for help. Type '\c' to clear the current input statement. mysql&gt; select '10' + 20; +-----------+ | '10' + 20 | +-----------+ | 30 | +-----------+ 1 row in set (0.00 sec) mysql&gt; select '20' + '30'; +-------------+ | '20' + '30' | +-------------+ | 50 | +-------------+ 1 row in set (0.00 sec) mysql&gt; select '1.1' + '2.2'; +---------------+ | '1.1' + '2.2' | +---------------+ | 3.3 | +---------------+ 1 row in set (0.01 sec) Standard SQL generally does implicit numeric conversions.
From the article: &gt; A Design Pattern is a named canonical form for a combination of software structures and procedures that have proven to be useful over the years. &gt; &gt; ... &gt; &gt; Yes, every Design Pattern has a name and a canonical form. Professional software designers use those names and forms to communicate with each other. When they see the name of a pattern in software, or if they recognize the form, then they immediately know the designer's intent. This is one reason why [naming things properly](http://paul-m-jones.com/archives/5952) is so important. If you think I'm talking about your favorite project, you're right.
How are you connected to your lights?
[SiteAnalyzer](https://github.com/citizenjosh/SiteAnalyzer) goes to each page in a site map looking for artifacts related to a [LivePerson](http://LivePerson.com) chat implementation. I created it to see if company clients had improperly installed the product.
Haha. Some friends and I used to play a game where we would create a channel and make it so that anyone who joined got op (either through channel permissions or a bot). We'd then make bots that would immediately kick/ban/de-op anyone but ourselves, and fight over who controls the channel. Whoever was faster/trickier won. I started out with a bot in mIRC, then PHP, then Perl. The guy who held it the longest wrote his in C, but didn't check all his bounds properly so was dethroned by an overflow. Fun times.
Thanks for the suggestion I forgot a stupid ';' terminating character... 
Should have called it *Straw Man: The Article*.
I wrote a program that simulates natural gas shipper behaviour depending on the price difference between yearly contracts vs seasons vs months vs weeks vs days and calculates the maximum profit depending on multiplier amounts, within EU regulations. I worked at a gas company for a short time...
If you don't have easy access to the error log try adding this to a globally included file during development: ini_set('display_startup_errors', 1); ini_set('display_errors', 1); error_reporting(-1);
Haha...man, I'm not doubting your abilities or anything but I'm sure companies like that have *teams* of PhD wielding mathematicians and programmers specifically to stop people abusing the system to make any money. Just out of interest though, how did it work? i.e how did you at least expect to make money?
Yes! netsend!
Read this, love this, learn this and then come back to /r/php asking for advice: http://www.phptherightway.com/ Good luck! May the PHP force be with you.
Just out of interest, was there a specific exploit if it *wasn't* installed properly?
That is awesome. But seriously, don't you feel the Hue's are incredibly expensive?
Thanks you very such kind sir
[relevant xkcd](http://xkcd.com/1205/)
Compared to what? Everything else I've seen with that feature set is at least as expensive. Now, you could ask whether the feature set is worth the price. You'd be in happy agreement with my wife, if you did that. Fortunately we've both got good jobs and she indulges my gadget-dorkery.
Lol I doubt my own abilities so no offence taken. In a nutshell I was trying to play both sides of the market in horse races with the aim being to guarantee a win or break even as a last resort. Remember that Betfair is an exchange so you are betting against other punters not just the really smart buggers. I would examine the conditions of each event, how much money got traded, the runners etc and then make the decisions based on that and adjust during the race. I tested it for like a month or 2 but didn't end up gaining any significant cash. I didnt lost cash either though which is a positive. I suspect their were variables that I didn't factor for. Betfair has an API that you can bet with btw.
What is your development setup like? You generally wouldn't run Jekyll where your site is being hosted. You would develop the site in Jekyll and "build" the site and upload all the html, css, js to your shared hosting server site directory.
I indeed seem to read this everywhere. Cross-scripting.
Thanks looks pretty good. I'm certainly going to give it a good read and do some research on that.
Pretty extensive answer!
Just out of curiousity, but how does one add thousands of entries to a database. Just create a fake table and hook it up to your app?
Thank you for the response! I will look into laravel, I knew I had to get into frameworks at some point. Might as well be now. I am slightly discouraged from oop so I steered away from MVC. Your right though I should probably face that head on. Thanks again for the advice.
That was what I noticed too. I expected a guide to setting the proper headers yourself, or a guide to use the smtp-server offered by either mandrill, Google, or mail gun... 
The very first AJAX thingy I wrote just after reading an article about how GET requests were only 1 trip to the server and POST requests were 2. I thought sweet i'll be super efficient and use GET for all the things! Fortunately the widget I wrote was only on our Intranet, unfortunately it was an LDAP authentication widget. My mentor (who I was most fortunate to have) asked me later that day why I was transmitting everyone's username and password in the clear...
That wouldn't be in the input though. If we simply had SELECT * FROM accounts WHERE idnum = '1 + 2' would it not treat this as a string? If the users input is 10 + 20, the sql method wouldn't know to put the quotes around the 10 and the 20, the whole thing would be bound in quotes. Also, this isn't even what I'm talking about, I said that I don't think this syntax would work for all systems. Look at the dangers of quoting numeric values on stack overflow, it's pointless to argue about the topic when there is ample data out there.
Out of interest, as I do not know - in what instances don't they work? 
&gt; If the users input is 10 + 20, the sql method wouldn't know to put the quotes around the 10 and the 20, the whole thing would be bound in quotes. You misunderstood, I was talking about implicit conversions from string to numbers, not somehow evaluating an expression within a string. &gt; Look at the dangers of quoting numeric values on stack overflow, it's pointless to argue about the topic when there is ample data out there. I took a quick glance through all the "data". Not one actual example of an issue (as usual). But lots and lots of Just Plain Wrong information with people talking out of their ass. Like "it won't use an index if you do this!" (intrinsically wrong by the nature of optimizers, which only care about the type of the column involved), "it will round floats to integers in MySQL!" (no, it won't), etc, etc. But by all means, if you can find someone who posted an actual *demonstration* of an issue, I would love to see it. You won't, because it's all people screaming "JUST DON'T DO IT" (but don't ask me why). There is actually a reason why this works, and it goes back to the very beginning of databases. "In the beginning," all data was typically fixed-length char fields stored in fixed-length records. And when you imported data (from, say, punch cards), the data was ALL character based. The idea of implicit conversions from character to integer, float or fixed point was a natural, common and expected occurrence.
I don't see a problem in looking up into database. Why do you so scared in touching the database? Esecially if it is essential part of your web application
From what I saw, they've done a pretty good job of security. The developers are pretty good. The most I did was to have a company's chat work on a 3rd party website. I implemented this with a few lines of JavaScript. The financial institution that I alpha tested on was very pleased.
For a period of time in my younger years I was writing irc services in php. I gave up when I couldn't figure out why nameserv kept allowing anyone to authenticate to any name. Years later I realized it was using only one equal sign 
Spent 4 or 5 years of my career maintaining a PHP-GTK2 app &lt;shudder&gt; It was a piece of sales software with tens of thousands of lines of code and a userbase of several hundred, and the only really interesting feature that I got to add to it was adding chip and PIN support via PHP sockets. Eventually management gave the go-ahead to rewrite it from scratch as a web app using Symfony, and I couldn't be happier to see the back of PHP-GTK2.
Man, that story is messed up. That hosting provider must have gotten some complaints that day. "For ALL AJAX calls I have adopted the practice of passing a hash of a session variable that I set in the page that made the call, very first thing I do in the AJAX rpc is to validate that token. If it isn't valid I know it wasn't one of my web apps making the call and just exit out immediately without returning any data." How does one do that exactly? How do you validate that token? 
Not on company time.
While this is true, on the flip side you shouldn't write really dumb code without thinking at all about performance. If you write some slow code in one place it will probably be negligible; if you always write code like that it will add up. Keep performance at the back of your mind, but don't forget it.
Off the top of my head it can be something as simple as passing the hashed session id, so in your javascript ajax call you would pass it as another name value pair: $.ajax ({ type: "POST", url: "rpc.php", dataType: "json", data: "key=&lt;?php echo hash_hmac(sha256, session_id(), date('YFD'));?&gt;&amp;someField="+someFieldValue, success: function(transport) { //some successful stuff } }); Then in your rpc.php your first bit of validation looks like: &lt;?php if ($_SERVER['REQUEST_METHOD'] == "POST" &amp;&amp; isset($_POST['key']) &amp;&amp; $_POST['key'] == hash_hmac(sha256, session_id(), date('YFD'))) { //do your ajaxy stuff } else { //do nothing exit; } ?&gt; In the past I have done some more complex things like check if a user is logged in or create a session array of allowed values that the rpc can handle and verified that as well. The problem with my above example is it becomes a bit more complicated when trying to stay within the "javascript only allowed in includes" best practice since you don't normally echo out &lt;?php echo hash_hmac(sha256, session_id(), date('YFD'));?&gt; in a .js file. Most of my apps require a user to be logged in so I can just check the $_SESSION data for some sort of user is allowed to do this AJAXY stuff setting and not worry about the token. 
Grave photo request auto-reserve. Lol. There is a site, findagrave.com where people can post requests for other users to take a photo of a certain gravestone. My mother in law likes to take a few photos for people on weekends, but the ones in her area were getting reserved quickly. I wrote a script that hits the site every half hour and automatically finds/reserves any photo requests within 10 miles of her house. 
A while back I made a shuffler for a bunch of podcasts from Roosterteeth. 
I whole heartedly agree with the top comment, but to throw in my two cents, I would take a look at Yii framework. I have to learn it for my new job, and it seems very overwhelming at first, but its actually very easy. Picked it up a lot faster than Zend Framework, and its astounding how fast you can make a complex site in it.
Wrote a roulette script? Was it rand(1, 36)? :P
It sounds like you're looking for data to confirm you're making the right decision. It sounds like the guy you're responding to already has and is giving you the pure conclusions. I don't understand why you're upset by that. The cases where it is better to spend development time on your own implementation of PDO instead of using a DBAL to save time/money is very, very, very narrow.
You are awesome!, i wanna be like you someday.
Use E_ALL for error_reporting, translate all errors, failed assertions, and shutdown errors into exceptions. Log the exceptions. Set display_errors = 0. I toggle `display_errors` and a few other settings at runtime using `auto_prepend_file` but however you do it - avoid showing any server information including error messages (even notices) to clients. I am a big fan of `auto_prepend_file` even though it doesn't get much love, you can do a lot of runtime configuration with it. Other things to consider based on my own practices: `display_startup_errors` - on in dev, off in production. `date.timezone = "UTC"` - UTC is most compatible and it you'll get notices using any date functions if it's not set, might as well set it in php.ini. Some extra settings for session security: session.entropy_length = 32 session.entropy_file = "/dev/urandom" session.use_only_cookies = 1 session.use_strict_mode = 1 session.hash_function = "whirlpool" session.hash_bits_per_character = 6 session.cookie_httponly = 1 session.name = "something other than PHPSESSID" Note you will need a very recent PHP version (I think 5.5+) to take advantage of the built-in session fixation prevention provided by `session.use_strict_mode`. I additionally set `session.cookie_secure` at runtime depending whether I expect all traffic over HTTPS or not. Speaking of HTTPS, I've seen so many scripts get it wrong that I now take it into my own hands: if (isset($_SERVER['HTTPS'])) { $on = filter_var($_SERVER['HTTPS'], FILTER_VALIDATE_BOOLEAN); $_SERVER['HTTPS'] = $on ? 1 : null; } else { $_SERVER['HTTPS'] = null; } Per the PHP manual, HTTPS is "Set to a non-empty value if the script was queried through the HTTPS protocol. Note: Note that when using ISAPI with IIS, the value will be off if the request was not made through the HTTPS protocol." `FILTER_VALIDATE_BOOLEAN` will return `false` for any non-true value, where 'true' includes the strings 'on', 'yes', '1', and 'true'. Setting it to `null` will cause any future `isset` checks to return false, and `1` gives it a non-empty value which passes loose comparison checks. I also disable xdebug in production for both security and speed reasons. If I need to do some diagnosis on a live site I usually do something like: if (isset($_COOKIE['8jrdogjdiojgrega'])) { ini_set('display_errors', 1); xdebug_enable(); } Then I manually set myself a cookie with that name.
Ooh ooh I want to do this for XBMC. That is an amazing idea! Be right back! Edit: Found [this post](http://forum.xbmc.org/showthread.php?tid=67546) on the XBMC forums on how to plug into the Python API to react to events and cobbled together a quick `autoexec.py` script that brightens and dims my Hue lights when I pause/play. Seems to not work consistently yet, but nice proof-of-concept! Edit 2: Realized that this doesn't really have to do with PHP specifically... But I am brightening and dimming the Hue lights through a secondary REST API I built in PHP to provide a responsive web interface to my lights with "scenes" that set all lights to presets. So I guess it's a little bit PHP related.
Hue is rather expensive, yes, but no other system even remotely in the Hue's price range has an actual REST API that makes sense. I used to use an X10 system with a PC-connected "firecracker" controller, but those are only one-way so the most you could do is fire off a signal and hope that it worked. The Hue API lets you ask the system, or even individual lights, what their current status is, and the lights form a wireless mesh network among them so even though there is a central base station that serves the API, you can spread the lights throughout your house without issue. Edit: Totally meant to reply to /u/TheBigB86 below but for some reason clicked reply on your post. Whoops!
Always sanitize inputs. Make it impossible to get to $_GET data past a certain point, so that inputs have to be explicitly defined and validated (for security, not your business rules).
Logo was the first programming language I was introduced to as a child. It holds my fondest memories. Did you implement the turtle also?
&gt; Run a test on your company. I did. I logged in as my CTO using a basic SQL injection hack. They let me fix *that* specific issue pretty quickly, but I haven't convinced them that the other 9000 security issues are important too.
Don't forget 0 and 00.
Fair enough, but why would the renderer `$func` ever come from end-user input?
Great idea. I'm getting a few HuE's when I'm finishes with this month's travelling and this is a nice idea. I guess it would be trivial to integrate with vlc also :) might give it a try when I'm back!
Your password hashing is being done incorrectly: https://github.com/svolpe43/finance/blob/master/public/register.php#L29 You are just running `crypt()` without providing a secure algorithm or salt, so it's defaulting to weakly salted MD5. I recommend reading the [docs on crypt](http://www.php.net/manual/en/function.crypt.php) and using the blowfish algorithm, or look into using [password compat](https://github.com/ircmaxell/password_compat) (or if you're using PHP 5.5, you can just use the new [password API](http://www.php.net/manual/en/ref.password.php))
I have way too many to remember, but here are some: a ncruses based cli 'media player' that interfaced lamemp3 or mplayer. It would read through my mp3 folder and randomize, I could press different keys on the keyboard to ff,rw,play,stop,next,previous. Reason I did this was back in the day I had a home linux server, I wanted a media player that I could just run from this already running computer, but they were all GUI based (that had what I was looking for) and this was strictly cli (old, slow machine). had a simple usb numberpad on my desk, wired to my hackjob stereo. one time after seeing that in order to do billing our secretary would have to go do every client's record on the billing system and download a pdf. I built a PHP-GTK script that would interface with the billing system, list all the clients and she could just select which clients to create/print invoices. What would take almost all day was turned into 2-3 minutes + making sure the printer had paper. When I ran a game server hosting business I created a web based portal to manage gameserver settings (custom profiles, start/stop functions etc.) this talked to another php script on the actual gameserver that would sudo the start/stop commands and upload/download configuration files to the webserver. 
Haha, I did build a PHP IRC Bot at some point, it was somewhat object oriented (PHP4 era), tho it was modular, you could create modules and extend the 'core' via 'events' (which mirrored IRC Events) 
I respect the hell out of you, and at the same time wish I never read this comment. I want to do this now
I did something similar to test a dice method: http://studios.gameslayer.org/projects/satoshi/simulator.php
SQL Injections are usually one of the things I'm thinking about when doing code reviews (my company requires all commits be code reviewed by a peer before being merged into the trunk) I've seen some programmers slip up, usually do to lazyness, and do stuff like name="$name" because they think the query they're writing will be internal only and thus it wont get fed raw data. And I have turned around and told them "You know that API you're writing is only scheduled to be internal for now right? It is planned on eventually being a public api, so that is fully injectable"
&gt; &gt; &gt; If you think I'm talking about your favorite project, you're right. absolutely, codeiginiter's facades :D
Play Minecraft pocket over the internet. 
I'm on my phone so I can't really criticize a lot. But I read a few files, and I must say, your code is a breeze to read. I understand what you're doing from top to bottom. And that's sadly a very rare skill in most development companies. So good job! 
Since you are using Nginx with PHP-FPM you could even start with fastcgi caching within Nginx itself. Have had good success with this on a few sluggish WordPress blogs. If the bulk of your site is static built pages it can give you pretty quick wins rather easily. http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html#fastcgi_cache
Doing obvious things like not calling in_array 10000 times is important.
Whoops library is nice.
Echo using commas instead of concatenation. It's literally billionths of a second faster.
I'm not trying to confirm anything, I'm simply looking for information so I have realistic expectations when considering my options both in the short term and the long term. And I specifically requested 'documentation', not conclusions. I'm not upset so much as I don't suffer fools lightly. I haven't even nailed down what datastore I'm going to be using yet, there is a lot that's up in the air. I'm planning on making an informed decision, this post is simply 1 of my efforts to gather information. But there's always that 1 guy... premature - evil - yada yada yada... 
* I was running a campaign of the RPG traveler, and I wanted to map out a galactic sector I could run. I found a tool called [sec2pdf](http://dotclue.org/t20/), which would generate the sector map based off a dump format, but I needed the actual dump of planet information (atmosphere, population, resources, etc), so I wrote up a bunch of scripts to randomly generate it for me. I still have it up [here](http://joeterranova.net/code/parsec.zip), and you can generate a parsec just by running traveler.php * My ex needed a dump of her deviant art work for her website at one point, but deviant art didn't have an RSS feed. [I made one](http://www.joeterranova.net/blog/2008/02/11/rss-feed-generator-for-deviantart/) using a JSON script they used to power the previous/next links on their site. I used to host a copy myself, but I'd get thousands of hits a day for it so I eventually took it down. * At one point I started up an IRC game for Vampire the Requiem. I made a PHP-Nuke module to handle character sheets and downtimes, and an IRC bot that could tap into the character sheets in the database, do dice rolls, etc. For someone that didn't know how to do MySQL joins or use associative arrays, it was pretty ambitious. [It's still up on Source Forge](http://sourceforge.net/projects/vampman/)
And you will never make that mistake again.
I don't understand.
A text-and-pictures adventure game based on the 8-bit Lord of the Rings game from 1986. Written in Symfony2 and jQuery.
[$29.95 ea](http://www.superbrightleds.com/moreinfo/led-globe/wifi-compatible-variable-color-temperature-led-bulb,-6w-w-rf-remote/1798/4276/). ([Extra Bulbs](http://www.superbrightleds.com/moreinfo/led-household-bulbs/smartphone-or-tablet-wifi-compatible-e27-vct-led,-6w/1797/4281/)) So a 3 bulb set would cost you `$49.90` for a savings of `$150.05` or you can simply purchase `9.5 bulbs` for the price of the Philips Hue. I'm sure the API, if any exists is pretty terrible. But for me, `Savings &gt; Convenience` just about every time.
Agreed - I think you would be surprised how far a simple SQLite database will go in production. If your write to read ratio is low it could be more than enough. Worst case (as above suggests) write everything in a nice DAL layer - stick to basic SQL and you can swap it out later for something more industrial down the line.
I was talking about Code Igniter's Active Record implementation which is just a query builder.
Automation for the win...
Laravel is nice, however if you need speed I would look towards using phalcon php. Phalcon has a C extension for php that stores the framework in memory as opposed to it being generated on every request. For a fast templating engine Twig also has a C extension for caching the templates. Using phalcon and twig together would make a buttery webapp. I know you are new so laravel would probably be a better start for you. In any case... I HIGHLY suggest installing composer, it's a neatly wrapped package manager for php. For example I use swiftmailer, Facebook and Google auth. I can't tell you how much composer has saved me time in projects.
1. find all the words 2. count how often they are used 3. sort by use count descending The words at the top of the list are the most frequently used ones and therefore have the highest chance of being "filler" words like "the", "it", "of" amd so on. 4. Curate the list manually just to be safe. 5. Use the resulting list to strip words off any text in order to make searches in it more meaningful.
Never just sit down and write code. Always have a plan. 90% of the time this is the best way to write clean code. What I normally do is utilize SCRUM planning--even for relatively small projects (unless it's only going to take an hour or two). Divide the project into items, and let SCRUM do its magic. Start each module or section by taking a few minutes and mapping out your thoughts (mind mapping is great for this, especially class/function association) and you'll be able to visually see what you're doing wrong right from the planning stage. I worked with a genius level programmer once that gave me some of the best advice I've ever received: "_Always operate under three assumptions. One, your server has already been compromised. Two, all of your users are idiots. Three, all of your users are hackers that are out to get you._" Once you learn to do it this way you'll really feel the PHP love. Guaranteed. 
Custom customer/inventory system for a Wig and Breast Forms place (for people that have cancer and whatnot). They had an ancient program written in (I think) FoxPro. Had to have the client buy a converter so I could finagle their data into MySQL, then I wrote a frontend around it.
Especially with GTK getting so many improvements the last few years. I'm also disappointed the PHP win32 API extension seems abandoned. PHP developers just don't like Windows, it seems.
In any case, as long as he picks a framework and sticks with it he won't have any problems. They all have their plus and minus. For me I like prefer speed over major support that's why I use Phalcon. Yii looks nice but I think the support is lacking over Laravel, which he might need.
It is, I think it handles everything I do like sending json errors and translating errors into ErrorExceptions. When I can though, I use xdebug and its own exception traces since it is able to provide more information as a C extension rather than a runtime script.
Oh. Well, that's much more understandable.
your commit messages are less informative and more worrying. don't exhaust yourself... the project seems okay. maybe use a framework next time. also, name your documentation files *.md, so we can see that it's markdown.
Back when Facebook offered public RSS feeds of a user's "news feed" (I forget what it was called back then) I wrote a little application that allowed you to sign up for an account and pull your Facebook RSS feed into the site and then spit it out to a Twitter account you could then follow. The idea was to allow you to see the text updates your friends posted on Facebook but on twitter. It would poll the RSS feeds every 5-10 minutes or so and you could choose the people you wanted to see updates from. It was my first dabble into social media and Ajax stuff. I thought it was pretty cool when it hit 500 or so users--that is until my hosing provided laid a smack down on me about MySQL indexing and then Twitter banned my server's IP address for posting too many requests an hour. I think they've lifted the ban since then... Of course, when Facebook pulled the RSS feed stuff, it killed my app altogether. Though the idea still sits in my mind on how I could bring the site back.
Thanks, that's a really solid idea!
Yup. \^_^ I don't think I still have this somewhere though. It was ages ago.
Never thought of a construction like that for bug checking. The way I'm doing it now is just turning error reporting on for a short period and hoping no client sees them.
Man, I'm going to keep that in mind as well.
have you heard about namespaces?
 Here is my quick (and non-personal) code review of index.php: - no file header/comment explaining what system I am looking at, who wrote it, last modification, description etc. - WTF is a variable called $dummy doing in this code - at least give me a comment to have a clue what it is. - $rows = query(....) - what if $_SESSION['id'] is not defined - does the code just crash or still work or return some random thing? - if (condition) blah else { blah } - please always use the curly braces around the blah, even if the blah is only one line. Always.... - I'd prefer the get_positions logic to be in a function (or method) so the logic can be unit tested with a test script. - $user = query(' SELECT * FROM.... ) - never SELECT * as when the db changes it can cause havoc - always explicitly name every column you want to get back from the SELECT. Also what happens if SESSION['id'] is undefined? - if (cond || cond) blah - use braces round blah - if ($rows == - what the heck is $rows - use a more descriptive variable name ($portfolio_rows) - I prefer the companies stuff to go into a function/method so the logic can be unit tested with a test script - sometimes you use == in an if and sometimes === - this is inconsistent. Be consistent. - in the template stuff at the bottom why not a comment to say what the files are if it is not obvious (i.e. I figured the header file is probably the header but what is in the default file?) - whats the point of $count, $SessionId and $username variable - are they used somewhere - what for? Add a comment, or if they are not used why are you defining them. Having a cursory look through some of the other files: - it looks like you have multiple update statements but they are not in a database transaction - this is not good as it can lead to data corruptions. For example, in the buy function you do an insert, an update and another insert but if the second or last update/insert fails you just show the apologize screen and leave your db half updated. - I am not sure if you do any validation on the input (for example in buy.php what if amount is not a number), what if the query for usercash fails or gets a null value?. You might validate using javascript on the client, but you need to do so on the server in the PHP code as well. - when things do fail your error messages are very generic so how will you debug the system (try running it on your own server and just randomly stopping mysql or apache half way through a buy transaction and see what happens). Seeing a very non-descriptive or generic error makes a system very difficult to debug. Consider using distinct error numbers in your apology message Error E1023 - msg so you have a clue what went wrong when users start calling you. To be honest, for 3 months experience in PHP what you have done is excellent. Keep learning - keep reading about best practices. Keep reaching out to more experienced developers and asking for code reviews/constructive feedback. 
You probably will find this old post useful: http://stackoverflow.com/a/11369679/727208
fetch output, put into memcache, fetch from memecache. its basically less than 10 lines
amazon gift codes on demand .. nothing more obscure then that, the documentation documents something, just not the api itself.
Yes but that doesn't change my point. For example: use News\Models\News; use News\Controllers\NewsController; use News\Views\NewsView; Then you can use and identify the threes classes easily.
bitcoin represent.
The same could be said for any best practice. The goals are 1) communication ("I can't extend that class, maybe the author had a good reason for that?"), and 2) exposing upfuckery, eg when reviewing pull requests ("Somebody removed the final keyword here, is this warranted or is it a hack?") Instead of forcing the reader of the code to deduce intent, the burden is on the author to express intent. It's nice to have at least some features in the language to help enforce this principle.
Yes, I did. However not all the frameworks use namespaces in that way. 
Friend and I used to do exactly the same in high school. We even managed to put looping netsend batch scripts in other students' startups, so that every time they log in the whole school network would be useless.
Yay for the Symfony!
Looks like an ad for some proprietary system... It doesn't really talk about Symphony at all. 
I had to implement a FAT32 corrupted image reader and recovery system in PHP. In 6 hours. And it works!
Quick comment on top of everything else said by others * Use transactions * Don't defer termination into a function, always exit() explicitly in the caller source code * Do away with nested ifs * Get rid of the habit of committing partially and if you can't, rebase then push
Did you try doing this on a sport where there was only two participants, of which there was always a winner? E.g. tennis, snooker, etc... I've used bet bots before, and those were always the best.
I tried it something similar with football scores. I cant remember the exact logic of it but it was automated score arbitrage in essence. It worked better when the markets had more betters actively backing it as opposed to less active markets at that time for example Liverpool vs Manchester United would produce better results than a a match in the Brazilian second division.
I like Symfony, it made a big leap in the last versions and is getting better and better.
I wrote one to prove to my friend that none of his *winning* systems where in any way profitable. 
Can you give me an example?
Like how slow is Laravel are we talking? Cause I have been looking at it and I'm really liking the syntax and clarity of the documentation. 
Men. No magic here.
That's something to avoid. You lose readability and simplicity for the sake of avoiding parentheses (which are meaningful by the way). Also, consistency: return $firstName . ' ' . $lastName; […] return "$lastName, $firstName"; What here justifies using two different ways of concatenating strings? public function __get($name) { if ($name == 'fullName') Once you go that way, you're screwed. The only way to stay sane using PHP is to avoid using dynamic identifiers at all costs. You're putting meaningful *code* data inside a *string*, it *should* bother you. And the code is untested, missing a lot of `$this-&gt;` to access properties. 
Feature-set-wise, that's not even remotely comparable.
Thanks for the feedback. It's my first blog post, and I appreciate it! Glad to see someone read my article. About string concatenation, just something I missed while reviewing my post. Talking about consistency: having some properties on your object being accessed without parentheses, while others need them, that's an inconsistency right there. Let's say you're building a simple DTO that will be used for some kind of report. You can save yourself the hassle of populating every single property by computing some of them through a function, but then the next guy that uses that DTO will be confused as to when he should call a method, or simply access a property. It seems like you didn't make it until the end of the post, where I refactor that string comparison outside of the __get function in order to have something more maintainable. Anyway that's just some fun use of the dynamic stuff that PHP offers us, and I wanted to explore it. Nothing too serious here.
http://pastebin.com/s7ewHwUx Something like that should work. It's untested though. Basically you had both the "if($row)" and "if(post['password'] == $row['pass'])" wrapped around the login_ok and else conditions, meaning the else condition will never be executed when an invalid password is given. I wouldn't consider that code production ready either, make sure you look into password hashing. 
Deep web crawler for a niche search engine
I don't think OP really understands the concepts he's talking about. Passing a variable to a function by reference is not "reference mismatch" (whatever that is). That is how pass-by-reference works - this allows you to modify the variable within the function. Example: `function byRef (&amp;amp;$var) { $var .= " test"; } $x = "my"; byRef($x); print $x; // outputs "my test"` Using pass-by-reference when you only intend to read from a variable is generally bad practice. Using it unnecessarily will make your code more complicated and difficult to debug - also could lead to unintended consequences (ie. modify a variable erroneously). TL;DR a function with a reference argument (eg. function test (&amp;amp;$var) {}) does not require you to pass a reference (eg. $a = &amp;amp;$b) to it. The variable is passed by reference regardless. Refer to the documentation - http://us3.php.net/manual/en/language.references.pass.php
Men. They're called *magic* methods for a reason!
NP. Make sure you read up on http://www.phptherightway.com
I know about the mic and I am going to buy a new one :). As for the quality, is it really so bad? I have no problem reading it.
maybe if you use a large enough font when coding, only seen the preview so far.
will do, thank you
"Use a library. Whether it be password hashing, CSRF protection" I found this for CSRF protection: http://bkcore.com/blog/code/nocsrf-php-class.html But they don't protect against CSRF at all, do they? Because it uses a session var and that can be hijacked by a hacker and used to generate the token himself, right?
Aside from the things the others said, you have an error in [this line] (https://github.com/svolpe43/finance/blob/master/includes/functions.php#L8) and [this line] (https://github.com/svolpe43/finance/blob/master/includes/config.php#L13). constant.php does not exists :). For 3 months of PHP the code aint bad (I've seen worse from professionals), it's just not up to my standards. 
You're right, that's something I completely missed. Having a second pair of eyes passing over my stuff is very helpful. I'll adapt my code to throw an exception if the identifier is invalid, and explain that in the post. Thanks!
Don't take this as harsh please, I'm just fixing some mistakes (happens to everyone). Disclaimer: I don't know CI, I'm just trying to answer the things that doesnt need CI knowledge. &gt; Domain Driven Development Domain Driven **Design** &gt; models like repositories or factories Also known as the DAO (**D**ata **A**ccess **O**bject) Pattern. In DDD you have the Repository Pattern. &gt; Service Object With Service Object you mean a Service Locator or an object of a Service? &gt; Using Codeigniter definitely will cause a lot of fat models? fat models and thin controllers is your goal. This only applies if you talk about the M in MVC and not the entity itself. &gt; I know I can load classes in some hard-core way, but it seems violate the idea of using a framework. Is this the restriction of Codeigniter or I'm figuring it in a wrong way? you overthink this. Injecting does not equal loading. The autoloader loads the class (use composer, its one of the best tools), the IoC Container injects it in to your object. &gt; Using frameworks always come with some restrictions? Always, but the more decoupled the framework is, the less. 
I tried something like this a while ago - the only issue I had was IDE stopped assisting in code completion. For small code base, I did not care, but when the code base grew large, it became annoying at times. But then I guess IDE needs to improve! 
I agree, it is slower than other frameworks but I doubt OP would notice the difference for what he's doing.
Yeah that's one of the downsides as well. Anyway most people I know of use some kind of text editor without super intelligent code completion.
we did the same in our probability class.
I worked on a system that used a genetic algorithm to predict the traffic of people departing from an airport, and using that to determine the optimal way to get them through customs and into the duty free area. It wound up being more accurate than the cameras, the proximity sensors, and the customs officers that logged everyone going through (they get it more wrong than you'd think!), months/years in advance. Why it was PHP is beyond me...
I'm torn by this. While the C#/Ruby way of obscuring the distinction between methods and properties is obviously better for encapsulation, the PHP implementation leaves a lot to be desired. I would love to have real [property accessors](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2).
I know about encapsulation, obviously. I should have made it clear in the post, and I will edit it to add some precision, but the main use case of this is with DTOs. When all you want is a plain data structure that only holds data, without any special behavior, this is very helpful. In any other case, I would be reluctant to use something like this.
Yes, I believe it is safe to say! I've tested the login, register, and email forms.
what do you mean?
on laravel only when they use `Input::all();` which should not be used for inserting/updating in to databases.
Well, yes. Like I said "potentially are implementable". 
That's a pretty terrible library, but there's no problem with using a session variable to store the CSRF token. PHP sessions are stored server-side, and are inaccessible to attackers. If anything, the real problems with this library are: * Not using a cryptographically-secure random generator * Not checking the Referer and Origin headers (although this is really optional; the token is good enough, I just think it's always better to do extra checking) * Not using a timing-attack-safe string comparison on the token Now that I think about it, I really don't know any general CSRF libraries, other than ones that are integrated into a framework. So you may just have to do that one yourself, but it's really not that difficult (unlike password hashing).
It was not a critic, don't get me wrong :) Just for the people that thought *how* since Laravel has guarded and fillable implemented.
As a fan of PHPStorm I did not know about this. Very useful, thanks!
I think one thing to remember is that when the average person pays a freelancer, they probably couldn't tell you 5 things about your code. Sure it might not be the neatest code and maybe you didn't use a framework (only your loss) but your site works - for the most part. The only thing I have negative to say is that it needs more features. When you buy stocks, having to calculate the number you can buy rather than just entering how much you want to spend is tedious. Also if you enter invalid numbers it just throws an error and it could be confusing for users. Overall great application of your skills, how long did this project take from start to finish?
you know your columns and what they expect, generate a big ass array with values and insert them in to your database. I normaly test from 10k - 80k rows of data. 
Shout out to [Phrozn](http://phrozn.info/en/).
Symfony is a great framework for many reasons, but I find it hardly convenient to use.. So much configuration, so many lines for simple tasks, not fun.. but yeah, it's professional. I'm fine with using some of their libraries, but eh, the full-strack framework, not for me.
I've never built a project in the symfony2 framework, but I also rarely go a day without using one or more of its components. Much respect and gratitude to the folks at Sensio as well as the thousands of volunteer contributors who maintain this project!
that's one of the biggest advantages of symfony. Thanks to the bundling system there are *several* excellent bundles that are developed in a way that you can replace/configure parts to behave exactly as you like. The configuration is daunting at first but oh so powerful. 
Why, because it doesn't come stock with pretty colors? Get a soldering iron and a cheap $5 multi-led diode and create the controller yourself. Not that hard, man.
I'm just glad that on this project there aren't any user files, just six avatars they can choose from. "A solid database will form the core of your application, and in many cases its structure and requirements will dictate the shape and function of your application. Understand how it works and treat like what it is - in the vast majority of web applications it is the entire point of this whole thing." This is one thing that I didn't consider to be honest. How do you make sure you're working with a indexed and normalised database?
The nice thing about Symfony is that if you go with the full-stack version – aka the Standard Edition –, you get to work a lot more with convention over configuration and develop really, really fast – especially if you use something like [Rad](http://rad.knplabs.com/).
I find it very cumbersome to customize an application through the configuration files rather that through some lines of codes (for which I can rely on the API). Always having to manipulate the YAML files really frustrates me. They might have improved since I tried the last time though.
Rad looks nice. That's an issue I had with Symfony too. A lake of convention/opinions (which may be a good thing for others).. hence a lot of initialization code before you can get started on what you need to do. Edit: actually look at the examples, it perfectly illustrates the issues I have with symfony. On the left, some annoying over-complicated code, which does exactly what the code on the right does more simply. Good that this bundle exists, but that doesn't change the perception I have of the Symfony framework itself. It's a kind of low-level code. Sure it's powerful and you can do anything you want, but when it comes to do a common task, it takes so much effort..
Well for Github I thought it would be bad if I displayed my database usernames and passwords so I didn't include it. Should I have done something else?
I work with Symony full-stack every day. I can say that the vast majority of my time is spent writing code, not configuring. The learning curve with Symfony full-stack is larger than any other framework I've used, but the framework is more flexible/powerful than any other I've used as well. Yaml is optional, I have worked on Symfony full-stack projects that use pure php for all configuration (and routing). While the framework seems huge and dauting at first, it's really quite simple and elegant once you understand all the pieces.
environment dependent variables. in .gitignore ignore the production files.
This is a surprisingly solid article. I was expecting a lot of half-baked buzzfeed style blogspam and was pleasantly surprised. Kudos to the author.
#4: Performing queries in a loop There are times when this is a requirement, but agreed that it's often an inefficient pattern that is simply copied from other places without an understanding of the implication. 
this calculation has a significant flaw: the more you automate the more experience you gain which results in massively speeding up future task automation. So it might not be worth to automate the task now but in the longterm it'll be worth having spent the time... so: just automate everything that's boring to do manually
Just curious, how would you test it without knowing what my code looked like? Or could you only test it after seeing my code?
Ohh that's what that little annoying file that always appears is for. I'm really new to Github thanks for the info.
Well done article, but GOD DAMMIT they threw up a popup modal. 
With the exception of populating `$_POST` manually^1, this was a nice article. ^1 `$_POST` is for form data only. For everything else, there is `php://input`. 
I found #6 the most interesting but what the hell is with that site's javascript? Turning JS on made the page incredibly slugish to scroll.
Common mistake #4's solution is not a good one. Definitely use the "in" SQL operand, but you still need to escape the input or parameterize the query. EDIT: Also, for #5 doesn't PDO support scrollable cursors with MySQL?
 echo strtoupper($list[rand(0, count($list) - 1]); Zero offset array will have keys of 0 and 1, but a count of 2. Key 2 will not exist, so need to make sure you offset the count.
Ah true, forgot that. Edited my post.
A "php mistakes" page that advocates the use of mysql_* functions is hard to take seriously.
#11: Using `mysql_*` functions.
&gt; There are times when this is a requirement Do you have an example?
Thank you! All it tought me about rand() is the syntax. I'll punch it in and see if thats what the site is looking for. I thought it was weird that they said I needed count() but now it makes sense! I know I don't need to use array_push but in this assignment it is a requirement. Thank you again!! Edit: It wasn't what the program was looking for. Keeps pulling up errors about an unexpected ']'.
When you've got a very large piece of data in the loop to be processed (large binary blob, for example). Pulling all of those in to memory (whether the db server's memory or the web server's) at once may not be an option.
That isn't true at all. And, even if it were, forms can use whatever encoding the developer wants to, including `application/json` - making it still "form data" (air quotes, because HTTP doesn't have any such things as forms or form data). The author got it right; PHP doesn't preparse other encoded POST data simply because it was not very useful back then.
Why is this getting downvoted? If you want to automate this, you could do this via a build script, or as part of cron, or any number of solutions. Requires less infrastructure than adding varnish, redis, or memcache to the mix.
It's the example #5 from the article.
In all fairness, it used both mysql and mysqli, as well as talking about mysqlnd, and the best practices of using it over mysql, so it was probably just a slip?
I had to edit my comment too. I plugged in the code you suggested but all it does is pop up with the error message: Parse error: syntax error, unexpected ']' on line 19 Obviously line 19 is where I have print strtoupper($list[rand(0, count($list) - 1)]); So it isn't exactly what the program is looking for in response. Edit: I did miss the closing parenthesis on rand() here but that was not the case in my actual code. Sorry for any confusion.
#1. Why would you loop by reference? #2. This is skirting around the problem. If you want to unset something, you should use unset() not set it NULL. #4. While I understand the gist of the tip, the solution of passing in a massive imploded array as a WHERE IN clause is only slightly less terrible. Anyone that's done any kind of mysql optimization will know that this forces mysql to do a comparison with each member of the IN array. If he's really putting in 1000 id's into the array, then mysql would effectively have to do 1000 comparison for each and every row in the database table!! The more rational solution is to rewrite the logic and use more rational search parameters.
There is a small syntax error in my post, I forgot to close the parenthesis for rand(). (You could have also seen this yourself)
Then the interpreter probably isn't running PHP 5.4+. So the first line would be written $list = array(); You can still use the [] syntax to add items to the end of the array though.
I was all enjoying my article when.. FREE T-SHIRT!!
That wasn't the problem I think, see http://www.reddit.com/r/PHP/comments/29km6d/having_difficulties_creating_a_code_that_randomly/cilunw0
Honestly, I feel like any best practices for php should include the use of PDO.
Thank you very much
I did notice the error and even if I rectify it, it comes back with "Fatal error: Function name must be a string on line 19"
Look at your opening and closing characters. You are opening the rand function, and opening the count function, but you're only closing the count function. You need to add another closing paren. It should be: strtoupper($list[rand(0, count($list) -1)]);
Responded to that comment.
I know I can add more items to the array this way but my biggest issue right now is getting it to understand I am not looking for a random number between 0 and however many items I have in my list but that I am looking for it to print a random string from the list.
Post the code that you now have ;). Everything should be fine now.
Yes. All the database code in the article is from the previous decade.
It is. I went back and double checked the code I am inputting. Here is the code exactly and I still get the same error: // Create an array and push on the names // of your closest family and friends $list = array(); array_push($list, "Kris"); array_push($list, "Chris"); array_push($list, "Joe"); array_push($list, "Heather"); array_push($list, "Ian"); // Sort the list $sort = sort($list); // Randomly select a winner! // Print the winner's name in ALL CAPS print strtoupper($list(rand(0, count($list) -1)));
Your last line is incorrect for sure. You access array indeces with [] syntax, not () syntax. So it isn't `$list(rand(0, count($list) -1)));` it is print strtoupper($list[rand(0, count($list) -1)]);
You are using $list() instead of $list[]
When you get provided with a list of pre-defined "sanctioned" queries in your specification. Or requesting a new one to be added would involved a handfull of people and a tons of a red tape. This is actually more common that you would think in bigger projects, and not limited to PHP. 
You are welcome. Any time. Unfortunately assumptions like you made re the id are what sometimes get us developers in trouble, especially in larger systems. It might be in a later version a programmer allows you to get to this page without the id being set. It may be a sysadmin deletes the tmpfile on the server holding the session details, or even a disk full situation stopping the session from being updated. Or maybe the session just times out and is destroyed by the garbage collector. You always want to have defensive coding in place and a plan for what to do when your assertions fail. 
That last bit worked! Thanks a lot! That is what I was missing and the answer had been under my nose. The code I input was: // Create an array and push on the names // of your closest family and friends $list = array(); array_push($list, "Kris"); array_push($list, "Chris"); array_push($list, "Joe"); array_push($list, "Heather"); array_push($list, "Ian"); // Sort the list $sort = sort($list); // Randomly select a winner! $rand = rand(0, count($list) -1); // Print the winner's name in ALL CAPS print strtoupper($list[$rand]); Thank you again!
It didn't but I found what the problem was. This is the code I put in that worked: // Create an array and push on the names // of your closest family and friends $list = array(); array_push($list, "Kris"); array_push($list, "Chris"); array_push($list, "Joe"); array_push($list, "Heather"); array_push($list, "Ian"); // Sort the list $sort = sort($list); // Randomly select a winner! $rand = rand(0, count($list) -1); // Print the winner's name in ALL CAPS print strtoupper($list[$rand]); Thank you for your help!
Sometimes it really helps visualize things like this to break it up like you've done here. When you're nesting 4 or 5 function calls, it's easy to get lost.
You were calling the array with () while you should call an array with []. (see: http://www.reddit.com/r/PHP/comments/29km6d/having_difficulties_creating_a_code_that_randomly/cilvrw6)
That would be one of the issues I was having but if I kept the [] there then I would get an error back saying that there was an unexpected ']' in my code. It was weird.
This article ironically does under *Common Mistake #4*: $result = mysql_query("SELECT `x`,`y` FROM `values` WHERE `value`=" . mysql_real_escape_string($inputValue));
I saw it there, but I have not been seeing mysql_* function in "new" or modernized code for years now. What I usually see is basically, mysqli, pdo or framework specific calls.
Coming from someone who spends way too much time on StackOverflow I can promise you that *a lot* of people still use the `mysql_` functions. Even in new code. They read a 10 year old tutorial and fill their code with `mysql_` and SQL injections all over.
That sucks... I guess I should consider myself lucky for not having to handle mysql.
The worst part is the typical "*yeah I don't care, not that many people use the system, so I'll just fix it later*" only to never get around to it.
I use Symfony for many things, and I agree with you. It's not for every project or every developer. That's why the author of the original post says that Symfony is the new standard "for mid-sized or big teams". The major advantage you have in Symfony is knowing that you can make it do anything. If you are developing a project which will need to be extended in unknown ways in the future, then Symfony is perfect because you can configure it however you want. That configuration takes time, though, so if you are doing a one-and-done project with specific and common functionality, then it's probably not the right choice.
I remember a couple of years ago inheriting a legacy project that was dependent on php3, that was the last time I saw mysql_*. The worst part was that there was no documentation, only the code which as you might imagine was riddled with includes and requires and was a basically a clusterfuck of globals. 
I think @ is the biggest mistake of all
PDO and Prepared Statements are your last line of defense - but if the wrong data is making it into your data layer, you already have a problem. You *know* (or should know, if you have any idea what you're doing) what type of data you expect from the user. You need to make sure that type of data is exactly what you're getting long before you even send it into your model, let alone before it gets through your abstraction layer ready to be sent to the database. The wrong data can cause undesired operation of your script levels above SQL Injection. **tl;dr - Always check user input against a whitelist.**
At least they will eventually start breaking.
That's not really a requirement as it is bad planning on the part of whoever wrote the original specification. /u/mgkimsal's scenario above is really the only requirement for it.
Nobody will once PHP remove it. Their documentation already says it's going to be removed in a future release.
OAuth is almost definitely overkill here. OAuth is best used if you want your users to be able to log into other systems. If you are just using it locally, it would take less time to write a simple CAS system
Tell us more about how amazing your computer is. Edit: And how my laptop, that had no problems using that site, isn't as good.
The [Martingale betting system](https://en.wikipedia.org/wiki/Martingale_%28betting_system%29) technically works given infinite wealth and no upper table limits. I actually developed this strategy on my own, before finding out later that it had a name. I eventually realized the flaw is that no one has infinite wealth and casinos generally implement an upper limit on bets specifically to avoid this.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Martingale (betting system)**](https://en.wikipedia.org/wiki/Martingale%20%28betting%20system%29): [](#sfw) --- &gt;A __martingale__ is any of a class of [betting strategies](https://en.wikipedia.org/wiki/Betting_strategy) that originated from and were popular in 18th century [France](https://en.wikipedia.org/wiki/France). The simplest of these strategies was designed for a game in which the gambler wins his stake if a coin comes up heads and loses it if the coin comes up tails. The strategy had the gambler double his bet after every loss, so that the first win would recover all previous losses plus win a profit equal to the original stake. The martingale strategy has been applied to [roulette](https://en.wikipedia.org/wiki/Roulette) as well, as the probability of hitting either red or black is close to 50%. &gt; --- ^Interesting: [^St. ^Petersburg ^paradox](https://en.wikipedia.org/wiki/St._Petersburg_paradox) ^| [^Roulette](https://en.wikipedia.org/wiki/Roulette) ^| [^Betting ^strategy](https://en.wikipedia.org/wiki/Betting_strategy) ^| [^Martingale ^\(probability ^theory)](https://en.wikipedia.org/wiki/Martingale_\(probability_theory\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cim0444) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cim0444)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt;Not sure what the word for 'non-agency' work is? You mean freelance?
Yea, sure. Well its actually a computer from 30 years in the future. So you can guess how awesome it is. 
I mean like, working for a company, potentially as part of a team - but one that is not an agency. Though, having freelance in the discussion wouldn't hurt.
In-house development? 
I agree that it is bad planning, but there is not much I do **can** about it. **Edit:** Accidentally dropped a word.
Beginner?ok, laravel, wut? Maybe rephrase your title.
Updated the article, though it is not something #4 is all about. This was actually just a portion of code I discovered in one of projects I participated in and I was lazy enough to rewrite it. Nevertheless, thanks for pointing it out :)
Yeah, that makes more sense. :)
Using cursors does not solve the problem unfortunately. According to MySQL docs (http://dev.mysql.com/doc/refman/5.6/en/cursor-restrictions.html) MySQL creates a temporary in-memory table for cursors, or stores data on disk using MyISAM. Good thing now is that the script won't crash if there's at least enough space on disk. Bad thing is that now we may fall into using the disk, which is much slower than memory. Yet MyISAM is not quite the fastest storage engine ever :) You will profit from using cursors the most if you have DB on separate server with enough RAM. Still, you will have resources used and not indicated by `memory_get_peak_usage()`, which is important to understand. Yet such solution will not be any scalable. UPD.: Escaping input / parameterizing query is absolutely required in production code, especially when you are not sure what can come as parameter. Here we discuss a certain problem and I give solution for this specific problem. It is safe to assume I have an array of only integers in this case :)
aha, ok --&gt; I am new to this :)
The choice between mysqli and PDO is not that obvious as for me :) For instance, you can benefit from non-blocking queries with mysqli+mysqlnd a lot.
&gt;No, I'm not insecure. Then.. &gt; I know for a fact that my main desktop would make your little "12 core Xeon desktop" look like a Pentium fucking II. Lol. You're either an idiot or you have no concept of irony. &gt;If you think i tried just one computer, you must be out of your goddamn mind. I wonder where I got that impression from.... hmmm... "*And how my laptop, that had no problems using that site, isn't as good.*" -aequasi08 &gt;On the three computers I tried, from two different geo locations, with internet explorer, firefox, chrome, and safari, the site has a small start up lag, for about 3 seconds, and then runs fine for the rest of the session. Maybe you should clean your computer up. Oh, you're just an idiot. ok.
All clever replies. Thank you for giving up on your argument.
Take a look at my other comments. I called you out for waving your supercomputer at everyone, that's all. If you feel you need to show off about your "12 core Xeon desktop"... So be it, but I'm gonna keep calling you out for it.
While that's true, you can still implement asynchronous querying with curl and/or crontab/at scripts. It's a bit more of a hassle I admit, but asynchronous querying/processing is a complex enough problem that I feel mysqli doesn't really save me all that much work, and PDO's Statement support is much nicer IMO, especially with named Sql parameters. 
Have been using their various powerfull components, but never use it as full-stack framework. maybe next time when I get some big project 
Looks like your question got answered: http://www.reddit.com/r/PHP/comments/29a6qz/what_am_i_missing_with_this_whole_command_bus/cij9xh9
You should probably add something about [Yoda conditionals](http://en.wikipedia.org/wiki/Yoda_conditions). A common bug I have seen is when people accidentally turn their condition into an assignment by forgetting an "=". Such as: if ($var = 'expected value') { // do something } A good practice is to reverse the condition and your IDE will pick it up as an error. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Yoda conditions**](https://en.wikipedia.org/wiki/Yoda%20conditions): [](#sfw) --- &gt; &gt;In [programming](https://en.wikipedia.org/wiki/Computer_programming) [jargon](https://en.wikipedia.org/wiki/Jargon), __Yoda conditions__ (also called *Yoda notation*) is a [programming style](https://en.wikipedia.org/wiki/Programming_style) where the two parts of an expression are reversed from the typical order in a [conditional statement](https://en.wikipedia.org/wiki/Conditional_(computer_programming\)). A yoda condition places the constant portion of the expression on the left side of the conditional statement. The name for this programming style is derived from the *[Star Wars](https://en.wikipedia.org/wiki/Star_Wars)* character named [Yoda](https://en.wikipedia.org/wiki/Yoda), who spoke English with non-standard syntax. &gt; --- ^Interesting: [^Conditional ^\(computer ^programming)](https://en.wikipedia.org/wiki/Conditional_\(computer_programming\)) ^| [^Torin's ^Passage](https://en.wikipedia.org/wiki/Torin%27s_Passage) ^| [^Mace ^Windu](https://en.wikipedia.org/wiki/Mace_Windu) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cim7fsg) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cim7fsg)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Best practice for MySQL interaction in PHP is basically just "don't use the `mysql` extension." Anything else beyond that is okay in my book.
Thank you! So you check the input against a whitelist AND use prepared statements? Is this not overkill? Sure you should know the type of data you expect but sometimes you WANT to give them the freedom to use quotes etc, correct?
1. If you wanted to change the content of the items, it is possible to do it this way. Saves worrying about keys
Frankly, that's a vastly more common PHP mistake than anything mentioned in that article. When was the last time you foreached through an array by reference, really?
By knowing what those things are, and making sure that you're doing them. Essentially they come down to everything having a primary key (usually called `id`that autoincrements), by having an index on anything that might be searchable or retrievable, like slugs, and by making sure that you always keep repeated data in an external table. This is normalisation. For example, you wouldn't store the country as "United Kingdom". Because you'd end up with the words "United Kingdom", "USA", or "Canada" repeated over and over in your database. You'd instead store country_id, which would link to a corresponding countries table, and get the country from that. You wouldn't store the customer data for each order a person made, you'd store the "customer_id" in the orders table, and get it from that. You wouldn't store the number of orders a customer has made, because you can just get that by counting them. That sort of thing. Achieving this will get you what's known as the [third normal form](http://en.wikipedia.org/wiki/Third_normal_form), though the [fourth normal form](http://en.wikipedia.org/wiki/Fourth_normal_form) is a useful higher standard. The point is to reduce or eliminate possibilities for error through redundant information.
Yeah, that's how I got 32,341 comment karma, by being a *troll*.
It was relevant to my point. I have a high end desktop, a simple blog should not have lag.
Purely anecdotal here but I have gained most of my experience through trying to implement a certain feature. Coming from Java you should be fully aware of common patterns and the like. You can generally fumble your way through recreating patterns in PHP as a good learning exercise. Alternatively you could spend the time and invest it into learning a framework. That takes you from being able to code to being able to deliver higher quality products/projects which is why you're probably here. Once you've got some grounding you can branch out and start to work on that big idea that gave you the inspiration in the first place. Intermediate and advanced resources are around but most come in the form of books. I have read some really advanced stuff about PHP and how to tune it for performance but very little has come across into my day to day programming. My personal projects have never hit loads that a micro AWS instance can't handle so I'm of the mindset of dealing with it if it becomes an issue down the track. Make sure you spend some time in raw PHP as well. Many developers can become one trick ponies if they spend too much time in a given framework. If you plan on working in the field you will come across some interesting code bases. 
Try looking up specifically what your doing. For example, don't search "Php database", instead use "Php PDO prepared statements". You tend to get less beginner tutorials. Also if you understand java object orientation, just imagine the dot (.) similear to arrow thing (-&gt;). Mainly you won't need a tutorial, but rather a crash course in syntax. Also keep in mind that netbeans has php support and code completion. The Alt-Space is amazing for finding what you can do to objects you are just learning about.
Given that you have access to all sites, you could give each site a private key, and send a hash of the log in credentials and private key to sign all requests. If the hash doesn't match, discard or reject the request.
Thank you for point this out! I refactor it with abstract class, and it really reduces the duplicate code! I also add some comments. Thank you very much :D I'll make it better and support for more services!
Thanks for introducing me the design pattern! I'll try to understand it! Many thanks! :)
I wrote a Hold Em' 7 card generator that resulted in a fairly large database of all hands (not suited for storage reasons) This allowed me to query any given round to determine A. How good my hand was against all possible hands B. Given the cards on the table, How many hands could be made that were better than mine. I learned quickly that just knowing the odds in hold em is not the key to success and knowing the right time to bluff and raise are extremely important. 
One of the problems I have with that series is that the entire pattern is predicated on sticking to Open/Closed and SRP, YET, after all that anemic code, we still end up with having to do this with our listeners: ReportListener-&gt;whenJobWasPosted() ReportListener-&gt;whenJobWasFilled() ReportListener-&gt;whenJobWasRelisted() ReportListener-&gt;whenJobWasRemoved() ReportListener-&gt;whenEmployeeQuits() ReportListener-&gt;whenEmployeeHasOneYearAnniversary() etc... I'm sure there's a better way to handle it, but writing a bunch of anemic code just to kick the SOLID violation can down the road some more doesn't make much sense. And at least according to those videos, the commands themselves do NOTHING other than fire events. Seems like an awful lot of code just to fire and dispatch some events.
You couldve just said you had a high end desktop, instead of sounding like a tool.
trolls love company