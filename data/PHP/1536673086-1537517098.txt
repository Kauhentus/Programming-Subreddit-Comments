Makes sense for people that develop libraries to encourage people not to change the behavior by extending some classes, but adds a layer of responsibility : you force people to use composition even if it is not needed.
I agree, but your common sense as a trained and/or experienced developer is not the same as a mediocre dev's
Can't really help you there then. I'm afraid this is one of those things which has to be described as self-evident. 
Because it doesn't only effect public properties. It affects children classes from changing it incorrectly, and the class its self. I could have an int property and change it internally to a string and nothing would stop me. Now then, we can prevent this with getters and setters as of now, but that isn't gonna help you when modifying a property internally. Also in some cases, like hydration from the DB, its nice to just make everything public, and hydrate it. Though that's a minor case.
I've been wanting to try C#. Is there a "Laravel" feature-equivalent for C#? 
Thanks. I guess my misunderstanding comes from my style of coding: I never change the value of an object property once the constructor has done its job, this situation did not even come to my mind.
I'm thinking the same like 3 project each month, the last one CMS that will cover a lot or some E-commerce
Id say type hints, typed properties and typed arrays/generics are all nice to have features. It enforces type safety and encourages more appropriate application design, allowing developers to discover coding errors as quickly as they can. The only exception is typed local variables, at least explicit declarations, which PHP does not need absolutely. 
If you want to try C#, you should use the ASP.NET MVC framework. Its not exactly like laravel, Id say more close to how Symfony works, but you will like it. 
Is there a difference between MVC and Core?
They mean totally different things and can be used together. MVC is a web framework, while the Core is new version of .NET ecosystem that can run on cross-platform machines(so you dont have to use windows webhosts). Try ASP.NET Core MVC 2 if you can, try to skip the ASP.NET MVC 5/6 without Core in the name as these are outdated and only runs on Windows servers. 
Excellent, thank you.
Docblocks don’t enforce anything, and even with the help of static analysis tools (which are not perfect) you can still put the wrong value somewhere that it wasn’t intended. With this change, you can completely prevent that. 
Think of how many exciting things you'll get to learn about, though! :) First step to solving a problem is realizing their is one. You understanding your code has room for improvement and making an effort to improve it already probably makes you a better programmer than the ones who wrote the above. But, in case my code wasn't clear enough, I'd love to highlight some of the things they did wrong and link you to some more info on them, if you're curious. The first thing that should be addressed before anything else is plaintext passwords. Passwords in their raw state (i.e. the string the user has directly typed) should ideally 1. never be logged anywhere in any system(s) you have and especially 2. be stored anywhere in a database, even temporarily. Plaintext passwords immediately and fully compromise every single one of your users if any part of the table were to be breached or leaked. Addressing #2 first, you should absolutely be using PHP's [`password_hash`](http://www.php.net/manual/en/function.password-hash.php) and [`password_verify`](http://www.php.net/manual/en/function.password-verify.php) functions. By default, PHP uses a hashing algorithm called Bcrypt, which is one of the industry standards, if not the most popular. You should only ever be storing the output of `password_hash` in your database. **NEVER** the raw string from the user. Also, if you're using `md5` or `sha1/2`, stop immediately. They are broken hash algorithms and can also almost immediately compromise your users if the table storing those passwords is leaked. `md5` and `sha1` are fine if you need to hash something just for the sake of hashing something, but not _cryptographically_ hashing something. Bcrypt, Scrypt, or Argon2 are going to be your winners. Bycript is the one that ships standard with PHP and is still perfectly acceptable. Second thing to touch on, briefly, is for logging, make sure you never expose the user's raw password. If a stacktrace gets printed or logged you should make sure that due to how your code is written it's not possible for the raw password to get in there. That's another vector that an attacker can use to capture and expose the plaintext passwords of the users. Ideally, don't log almost anything related to the actual password strings if you can avoid it. _Only_ log what you need to debug; and you absolutely never need a user's raw password string to debug. Second thing to touch on would by the `mysqli` class. `mysqli` is the replacement to the `mysql` class of functions in PHP. For the most part, you can pretty much just swap any usage of `mysql` with `mysqli` and it _should_ work; there are exceptions of course. One of the most important things to do whenever you're querying a database is make sure you sanitize user input when formulating a query. The famous [xkcd 'Exploits of a Mom'](https://xkcd.com/327/) covers SQL Injection which an attacker can use to execute arbitrary SQL on your database. Allowing arbitrary SQL to run allows attackers to potentially delete data, dump data (make a backup), insert data, or, in some cases, bypass additional checks that are baked into the query to prevent malicious use such as `WHERE` clauses. Example of this I've seen: "SELECT username FROM users WHERE password='$_POST['password']'" . If I as an attacker supply `' OR 1=1 LIMIT 1; --\n` as my password, that string becomes "SELECT username FROM users WHERE password='' OR 1=1 LIMIT 1; --\n" Congrats. Now the first username in the table will be automatically retrieved which, a large chunk of the time, happens to be a full-permission admin user. :) A solid way to guard against SQL Injection is to use ["Prepared Statements"](https://secure.php.net/manual/en/mysqli.quickstart.prepared-statements.php). Prepared statements allow you to create a 'template' query (for lack of a better phrase) and then provide the values for the variables in that template. The prepared statements will process the user input as input specifically to those variables. After you write your 'template' query, you bind variables to the parameters in your template string. Then MySQL does the job of escaping your input and making sure it's properly formatted once it actually runs on the database. Last thing the code the OP gave was the lack of a `WHERE` clause in the `UPDATE` SQL statement. That's just a straight bug but shows that this code probably wasn't fully tested. Something like that would be caught the second your table has more than one user and one tries to change the password. Make sure to test your code thoroughly and, ideally, write unit _and_ integration tests. In a dynamic, weak-typed language like PHP tests can only guarantee so much so they're not a simple path to perfect code, but they absolutely can help catch the blatant stuff and prevent new code from having side effects on other systems/flows. To wrap up as well, most of my changes were mostly stylistic. I'd say it's pretty important to have some consistent code style; preferably one that is pretty standard or common so that someone taking over your project one day wont have to struggle to read it. The [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md) is going to be one of the most commonly adhered to. But consistency above all else is the most important factor there. Other things would be [`abstract` classes](http://www.php.net/manual/en/language.oop5.abstract.php) (which allow you to build nice, reusable util classes, even though some may argue against util classes). There's also [sessions](http://www.php.net/manual/en/session.examples.basic.php) which allow you to persist information across requests so you can store/retrieve things like a User ID or username. I also threw in [namespaces](https://secure.php.net/manual/en/language.namespaces.rationale.php) there which help you organize your code in much more clear ways. Sorry for the wall of text. If you have any other questions, feel free to hit me up or post on the sub. I also didn't start where I am. I work for a pretty big company and have some really great engineers scrutinizing my code each and every day. But I've been writing PHP and Hack for years and still have plenty of room for improvement. You learn it by doing and by asking the kinds of questions you asked. Keep at it. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php-fig/fig-standards/.../**PSR-2-coding-style-guide.md** (master → 34722c6)](https://github.com/php-fig/fig-standards/blob/34722c6fa45d82cdfdc95b6b166d0b8c3ecaa300/accepted/PSR-2-coding-style-guide.md) ---- 
I've never used them. If I need to differentiate different types of exception without creating a new exception, I simply use a different message.
Say no more : \[The PHP Practitionner by Laracast\]([https://laracasts.com/series/php-for-beginners](https://laracasts.com/series/php-for-beginners)) has all you need! Even a nice introduction to frameworks (... aaaaaand Laravel quite a bit, which I guarantee is gonna be preciously stored in your PHP developper tool belt).
Some classes are simply data. There aren't really any "methods" of value. It's just data. With this change we can now use types on that data *without* using getter/setter methods.
Thanks buddy I wish you code without bugs
I never said any of the above situations lead to good code. I'm a big fan of immutability, but the unfortunate fact of web apps is that somewhere you're going to have some statefulness and state change. But I mean at the end of the day, this enables better defensive programming which is the biggest benefit of declaring types really, to protect from the idiot using your library or the other idiots on your team.
I'm gonna take a wild stab.... Hostgator?
Same here, I differenciate exceptions by class instance. There is also a problem when you want to differenciate MySQL constraints failure exception message... I never found a reliable way to tackle this.
It can prevent a lot of bugs simply through being strict. Even if your type annotations fail at some point, the property type checking won't and slap you with an error. It has no disadvantages for those not using them (they are optional) and many advantages for those using them (increased stability, possible performance improvements as less dynamic type coercion is needed, public properties can be used in quite a few more cases than annotation classes etc.)
&gt; especially given the reputation of offshore work I think carpet grouping the term offshore is far fetched. We are based in the UK and often outsource 'offshore' to the US, Germany and a few Eastern European countries with zero issues. After seeing one of your other comments this 'offshore' is India. It's very well documented about the extremely poor code they produce as a nation (that is a majority, I have heard of a handful of success stories) so your company gets what they deserve unfortunately. Not your fault I know and I feel for you having to clean up the mess. As a whole they have zero standards and care little about the absolute crap they pump out, literally no shame or pride. On the other hand it makes me lots of money trying to sort out the absolutely diabolical high school level 'codes' these 'LAMP experts' have vomited into the keyboard. &amp;#x200B;
&gt;Cheap was, and usually is, the whole reason for offshore work. Not at all :) we can't get the high standards of developers we need in our local catchment area so often higher 'offshore' to jump in when the workload overflows.
The Core versions are open-source. That's the most important thing. They also run on all platforms (afaik), via the dotnet executable. ASP.NET MVC is the cleanest MVC framework you will find among all languages that exist. Not only because of the way the libraries itself are designed, but also because of C# and .NET generally, which are extremely mighty and extremely clean. Try working with C#, there's a slight possibility you don't want to switch back or suddenly realize what has been lacking in your programming life all this time. Static extensions per context (you can extend inbuilt classes with own methods without overwriting anything), events, delegates, a clean enum/struct/class model including the fact that structs are immutable, async/await and proper multithreading, thread-pools and things like [Parallel.ForEach](https://www.c-sharpcorner.com/UploadFile/efa3cf/parallel-foreach-vs-foreach-loop-in-C-Sharp/) which make multi-threaded applications childs-play, annotations (called Attributes in C#), C# has it all. Then take a look at the Entity Framework (also available as EF Core) and LINQ and I am 100% sure you'll be sold. It's like programming porn. In my opinion, there is no cleaner programming language than C# and there is no cleaner framework than .NET and the libraries around it. It's one of the things Microsoft got **right**. 
&gt;he actually didn't pay anything for it Well, that is the answer to all your problems. I hope your code review was paid for. :)
Wow I'm very excited now. Is there a Laracasts screen-cast equivalent for getting into this or what would you recommend for training?
Or a better Java clone. The fact you have to use the flawed Java type system, is not a feature.
 # Sorry Because of its privacy settings, this video cannot be played here. &amp;#x200B;
Sounds weird, try this link? [https://laracasts.com/series/php-for-beginners/episodes/1](https://laracasts.com/series/php-for-beginners/episodes/1)
echo "Thanks";
Personally I never read too much about it, I just made things. That's the best way to learn it. I got initial information from here http://openbook.rheinwerk-verlag.de/visual_csharp_2012/ (It's a german book), but basically just flew over it, skipped like 7 parts to get directly to the GUI, wrote some GUI applications. And then it's things like: You write your windows app, you have a loading bar for something in a separate window, you let it load something, your application hangs. Hmpf, damn, google it. Ah, multi-threading solves this. Start multi-threading. Access exception, access exception, access exception. Google it, ah damn, you need to lock things or work with Mutex. wtf is a Mutex. Google it, google it. I could use one of those event things, how do I make own ones. Google it, find it, implement it, get errors, implement it again, get errors, implement it again, understand it, it works. Exactly that, multiply it by like at least 500 and you end up knowing C# well. This is how I learned any language, for that matter. Go download Visual Studio, imagine a cool application you'd like to write (maybe start with a Console application, then go and build a GUI application and _then_ start doing things for/in the web) and write it, without having a plan what you're doing. The plan will come, line by line you write in C#. Or as Shia LaBeouf would say: Just do it!
Typescript uses `readonly` and they do it really elegantly IMO: class User { constructor( readonly id: number, readonly name: string ) } Done. No need to define/initialize the properties. No need to set them in the constructor. The tooling automatically recognizes that the constructor's `readonly` keywords means those are public properties and it both initializes them and sets them behind the scenes. Makes defining immutable classes quite streamlined. When you got to use an instance of `User`, it gives you type completion like any other language's class. It's just awesome. I really like TypeScript, I just *hate* that it requires a compile step. PHP's ability to define types like this, without a manual compile step, is just awesome. 
I know it's a matter of preference whether strong typing is better than weak typing, but I'm hugely in the strong typing camp, so when I see unhinted PHP code I cry0 especially because I'm working on a large code base that was written by many authors. Or worse, when I see that some function returns `mixed` or `array`. It's like a box of chocolates. I would take Java's flawed type system any day over PHP thinking that `"0"` is falsey or over dealing with PHP's insane `Array`.
PDOException uses the exception code to store the SQLSTATE, for example.
I read this in a singing voice. ...just like the ones we used to knowwww
The spec so far is going to be some user authentication, with communication between users (messaging), an admin panel to manage various features of the system (such as authorising user actions), recurring monthly payments, email notifications, and various search functionality to find entries in the database.
&gt; I've read that it's bad practice for a function to return mixed types Who told you that? "Bad" is according to the style you're working to, not the language you're working in. Reserving a single value for "something went wrong" is very common in procedural programming. Throwing an Exception is very common in OO programming. If you wanted to write an OO shim over the array functions, array_key_last() wouldn't even exist.
Considering the scope of your project (from the comment) it most definitely needs a framework. Anything bigger than a single page script should probably be in a framework and the bigger the project, the more advantage you will see. There might be a bit of a learning curve as you get up to speed on it, but you will get whatever tools the framework offers (like user auth, etc) and in the long run your code will be more maintainable both by you, and by any other developer that steps into it. I personally use CodeIgniter, (which I love) because I'm old-school, but a lot of people tend towards Laravel on this sub. If I was starting from scratch, I'd probably pick up Laravel first.
I'd say check out slim or lumen to help w/ some of the typical things like routing and authentication and building out the API to talk to the front end. Laravel has a lot of features but it is also bloated, so using some awesome packages that you can load using composer will help you with your project.
I'm thinking about creating a Library of Keys and Tokens; For Profiling each of the User registered on the Website. If Possible using Single Sign On Credentials like using only a Mobile Number and other things.
Appreciate the input - thanks very much. I'll do some research in between the time I have an when the project is due to start.
Thank you!
Thanks very much mate!
Personally, I'm a huge fan of laravel, and although it is developer-friendly it has a lot of features and it takes some reading to learn how to properly build stuff. If you don't fell comfortable with using it on a production project (and you have root access to the server that will host your project), try phalcon: [https://phalconphp.com/en/](https://phalconphp.com/en/) It's delivered as a php extension, so you can structure it in any way you want (but won't have the out-of-the-box features that laravel offers).
It seems like Laravel is everywhere these days! I think it may be worth me having a look into it, as I hear nothing but good news from it.
Frameworks make life easier , and of course you don't have to worry about certain aspects of the problem , but it can also affect performance of your code. Coding in vanilla php can get you "faster code" but it can also make your code spaghetti style ! companies prefer to work on frameworks because it can be more easy to develop , but you give in performance and optimization . &amp;#x200B; Conclusion : yes work on a framework , simfony is a good choice . Because is a experience , you don't lose from trying something new.
First of all, I am only referring to explicit local variable type declaration. For implicit local variable typing using var or let, I don’t mind. Why I don’t like explicit type declaration for local variables, ‘Cause it is overrated and not useful. In most cases, you ain’t supposed to care about the type of a local variable, they are temporary and short lived. In some cases that you actually care, the variable name or method name should be good enough to infer what type it is. At least, you and your team should have a naming convention that the variable name and method return type isnt ambiguous. If you use $a or strangemethod() for variable or method names, it means you ain’t naming them properly in the first place. I’ve done programming with C# myself, and I always use ‘var’ for implicit typing. When you find explicit typing for local variables necessary to identify the variable types, it indicates that you have poor naming convention and you need to rename your variables/methods or refactor your code. If it comes from a third party library, then it’s questionable whether you should be using such a library that can confuse people. 
iirc, C++'s const doesn't mean the data is immutable, only that shallow mutation isn't allowed through that reference.
I'd be inclined to go for symfony 4/flex, which is what they EOL'd Silex in favour of. You end up only installing the components you need to use, and have more flexibility in what you use how over Laravel. That said, if you need to get something out fast, then sometimes having the more opinionated framework is a benefit, as you don't need to make those architecture decisions.
Old PHP was terrible. PHP 7 and modern frameworks have really made the development process better.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Here you go: https://www.reddit.com/r/PHP/search?q=hate+php&amp;restrict_sr=on&amp;sort=relevance&amp;t=all 
What do you mean? What would be non-shallow mutation? If I have a class: class Foo final { const int baz = 1; const Bar bar = new Bar(); } Then I can not set `foo.baz` to anything and I cannot call non-const methods of `foo.bar`.
Thanks for explaining, I appreciate it.
I agree, I dislike explicit getter/setters. I rather like how C# handles it.
Starting to develop PHP and finding a web host which supports PHP is relatively easy compared to other languages. I met with a lot of people who claimed to be a PHP developer but they did not know anything about CSRF, XSS, SQL injection and so on they just figured out how they can save a form unsafely into a database or even worst into a file. I think other languages has a more steep learning curve and because of this you have to dive into them deeper until you can make a web application. But I have to admit I have seen horrible C#, Java and Python code from people who shamed PHP. I would say it is just a trend which stuck with PHP and will stuck with it for years.
I am very curious about the thought process you used to get to this code style. The random whitelines and inconsistent indenting in fetch.php, mixing html and php, echo'ing entire html elements instead of only the php variables. The way this foreach loop is formatted: foreach ($json['rates'] as $key =&gt; $value) { $currency[$i]=$key; $rate[$i]=$value; $i=$i+1; } How does it end up like that? And what made you decide to share this with us?
ur welcome, though as I said implicit local variable type declaration can be nice to have. I am thinking about the syntax, could be toss up between 'var' or 'let'. 
if you do not want your object properties to be set by outside sources then mark them protected or private instead. they are public explicitly because you want them modifiable from outside.
Because it was hacked together by many people with no coherent design, resulting in a very messy and inconsistent thing compared to pretty much every other major language. This is still true to a good extent, but it has been improved a bit.
'cause PHP used to be a very bad programming language to begin with, and the bad reputation is very difficult to shake off. Also I have to say that PHP being a weakly typed scripting language makes it very easy for bad coders to write 'working' code, the low barrier of entry is a bless for the language's popularity, but unfortunately it further hurts PHP's reputation. PHP as a language does have several shortcomings, but its not as bad as the haters portrait it to be. With all being said, slowness is NOT a problem for PHP, it is actually faster than Python and Ruby. 
I don't do a lot of C++ but from what I recall that does not apply to pointers.
If we ever add generics then `type?` is problematic because all PHP code is enclosed in `&lt;?php ?&gt;`, and with generics we get things like `new Box&lt;int?&gt;`. It's not necessarily a show-stopper, but that's why it was chosen.
I'll throw in for Phalcon. It's really great.
I haven't done C++ in a few years, but I'm fairly sure you're incorrect. The only thing that breaks constness in C++ is `const_cast`. https://stackoverflow.com/questions/1143262/what-is-the-difference-between-const-int-const-int-const-and-int-const
PHP has always been a language which is easy to get started. You can see output with 1 line of code. This means a lot of people with very little experience can use it.. btw, Python was used in universities for some years before it became mainstream. It's a well-designed language.
Going through this at the moment. I'm spending so much time managing i could had done it myself. Outsourcing is just so hit or miss. 
This is dumb.
Luckily PHP got your most important point right: non-nullable types by default.
Union types are not necessarily a bad thing. If the built in functions were written today my guess is that many would use optional (nullable) return types. `preg_match` would for example return `?Result`.
Its not quite the full thing but you could try building in Umbraco. Its a nice and easy to use CMS but you can expand on it quite well for all sorts of things. I love working in it as a PHP dev, especially as its so easy to pick up at first and then easy to expand. 
read the symfony docs, cookbook, ....
This isn't r/sql, go spam your crap elsewhere
Problem: People extend your classes so your changes can break their code. Solution: Create hard contract (interface) where even tiniest change will definitely break the consumer. Hopefully you see what's wrong. You don't want to maintain bc in your class, so solution is to maintain even stricter bc in interfaces? Doesn't make sense. Also, most people will create abstractions wrong. It's hard to create correct abstraction without having a need for separate implementation at hand. And argument that it's easy to remove final later just does not work in practice. If you make a PR with such change, most maintainers will argue with you to the blood that it will stay there. It will stay there forever. Meanwhile, you were supposed to ship the feature yesterday, instead you are arguing with author for months.
Great improvements! I feel like callable type should just ensure that the property is a callable and forget about what's it's returning when called. If you want to ensure your callable return a certain type then it's the responsability of the callable itself to be typed. Or am I missing something? 
Should be fun. I'll be there!
Cool! See you then.
Language-hate is often uttered by insecure developers. PHP has its place, so does Python. People are ignorant about the great community, the many improvements PHP 7+ brings and the quality-minded direction PHP projects are heading. Performance can be an argument if you have defined requirements. Python has a nice standard library and a decent (dynamic) type system, but installing third party modules per project is still horrible and the community is filled with novice coders who write single-file scripts. Also, Python's fear of defense-in-depth (look before you leap) and its lack of true interfaces make it prone to poorly thought-out solutions. Oh, and the names in the standard library: a hodge-podge of weird abbreviated names and inconsistent casing. That being said, it is an easy language to learn (especially as a first language) and it is used in interesting domains.
The post that finally convinced me to use final: https://ocramius.github.io/blog/when-to-declare-classes-final/
Wow. Haven't they heard the two things you should never code yourself? A auth library and a encryption library. Unless you are an expert of course, which you are probably not.
As something of a noob to this level of "architecting" (but currently grappling with it out of necessity!), i dont get it. If you want to encourage/force future devs to use composition not inheritance to build on functionally in your classes, why would you put that functionality into `final` classes rather than write them as traits? Cheers in advance for any enlightenment
In addition to the great points discussed: PHP was not originally intended to be a programming language. It was meant to be a templating language, with logic done in compiled code. (For the peanut gallery: You can still do this in PHP today; look up how to create PHP modules) Source: The creator of PHP himself, Rasmus Lerdorf in a talk on the status of PHP in 2018 [https://www.youtube.com/watch?v=umxGUWYmiSw](https://www.youtube.com/watch?v=umxGUWYmiSw) Lerdorf fought turning PHP into a general purpose language for quite a long time, so it makes sense to me that until the core team developing PHP got on board with making a robust general purpose language, progress couldn't be made to actually improving it, instead of just adding extraneous features haphazardly. The first point where things turned around was PHP4, where the old template-specific design gave way to having an OOP system that many professional non-PHP developers would recognize, first dropping much that was incompatible with PHP3's way, then iterating in new features until we had a clear path to PHP5 where we again made huge backwards incompatible changes, iterated new features, and now we're at PHP7, which brought in a few BC breaking changes (though not as many as in the past), adding some MUCH needed optimizations, and a firm type system that I've been wishing for ever since the PHP3 days. (That is, I like that I can typecast a string to an int using type hints in the function parameters, unlike what I'd have to do in C, and unlike what I'd run into in PHP3-5 when I had to explicitly cast to the type I expected.) And, of course, with PHP being one of the easiest languages to get started in for web development, it's also the language with the highest number of people who I wouldn't deign to call junior developers, but who contribute to the ecosystem regardless. There is a LOT of scary code that is very easy to find. There are a LOT of scary tutorials. While the ecosystem has a great backbone, some very mature libraries and frameworks... it also has people who honestly think that Laravel is MVC, despite the fact that they've never once touched the original Appletalk MVC whitepaper.
&gt;People extend your classes so your changes can break their code. If they were final to begin with they could never have extended them in the first place.
Some object properties need to be validated when set, others do not. Moreover, if you know that the variable may be dirty, you know you need to perform the validation at use time. The programmer can make public variables and assume them to be dirty. A phone number set needs to be formatted before loading into a database, for example. The comment has already been made about classes as data types, which this now allows. Still the application has to validate its data.
[removed]
Definitely use a framework. The obvious choices are laravel and symfony. Don't do vanilla php in 2018. Unless your total code won't be more than 20 lines. For anything more complex than that, use the experience of the community, I. E. A well established framework. 
 - strpos could just return int - preg_match with flags could be just replaced to different functions - `&lt;T&gt;array_key_last(T[] $arr): T` - fill the power of parametrized polymorphism. 
in my case each exception just has it's own code. It's just easier to grep in logs by this error code and have some meaningful statistics. Also since I mostly write APIs this codes are great for dealing with errors on client side. Anything bigger than few endpoints will have a need of more specialized error code system than just relying on HTTP status codes.
Curious why you think Laravel is MVVM when the view doesn’t have any direct communication with the (view)Model? Would like to hear you explanation of the difference between the two architectures, maybe I don’t understand myself.
It's the same syntax Hack uses, and I find it to be OK.
Use a framework. It will take care of basics that you don't want to stuff up, like security. And it will give you a general architecture layout to start with, and maybe even encourage some modern design patterns that you would not otherwise use. Also setting up automated testing is generally easier or out-of-the-box with a framework. Use Laravel. As a first framework its perfect. Some might advocate Symfony which is also a great framework, but I think the more opinionated nature of Laravel would be more beneficial considering you are jumping into a production project early on. That being said, do some small Laravel projects first to get some familiarity. The Laracasts tutorials are the best place to start IMO.
Precisely because the view doesn't talk to the model. 
Will give a longer explanation later, am not near a decent keyboard. 
I've been looking to be *sold* on a new programming language to experiment around with and I just want to say that I really enjoyed your perspective on C#, .NET and how much you enjoyed learning it. Do you have any experience in the Java ecosystem to give a similar "review"?
First, let me clarify that many of my customers are those shops that just ship ship ship until more than half of what they shipped starts falling apart "on its own" (their words, and they are SO wrong). &gt; In reality, most code isn't designed well You can't finalize code that wasn't "designed" at all without running into problems, but extending it makes things even worse: 1. Code that isn't well designed is very likely not even designed to support inheritance 2. Code that isn't well designed will lead to downstream issues in child classes, especially when it has to change (due to it not following the OCP) 3. Marking squishy code as `final` will prevent you from running into those dead spots that make it so hard to change anything at all 4. Marking squishy code as `final` will prevent you from mocking it, and that is **good**, because if you cannot easily extract the behaviour of a complex component into simple steps in your mind, you also cannot easily configure a mock that emulates its observed behaviour. This leads to integration tests, because unit tests are not really a good idea on legacy code: this is also a wiser decision in such scenarios. &gt; (often due to time restraints). Developers should always evaluate maintenance and development efforts. If you are at the point where you must maintain a piece of complex code that was under-designed, then you are already working on top of a component where the maintenance estimate was done incorrectly multiple times. This means that the design work was not done, while it should have been (component is not a throwaway weekend hack), and the customer should just have received a different estimate, or a delay. Yes, this is OK to say "NO", the customer is not king, the engineering work needs to be done. Once we've established that a mistake was already done, let's try estimating the amount of work to be done in order to bring things back from "chaotic" into "complex" or "complicated" (see cynefin): refactoring needs to be planned before further work lands in, because the more chaotic, the more time will be burnt. &gt; Many libraries come with few/no interfaces, huge classes (with dozens of methods) Interfaces take literally seconds to write, once it is clear what you want a component to do. Once code has been written, they can be extracted (even automatically): they will be terrible interfaces, but they will help us identifying leaky abstractions, non-atomic business transactions and possible misunderstanding in what the business interaction names actually mean (I call it "archaeology work"). &gt; Use composition with `__call` and lose many static checking/auto-completion. Please don't do this: it just adds more accidental complexity to everything, making all your problems much bigger. &gt; Does the assumption of 'you can always just change it' seem too optimistic One piece of advice I can give you is to optimise how you write code for rewrite rather than for changing. Adding a simple `if` condition in very core business logic can cause chaos, because you were not the original author of the code, or because that condition is actually part of a different decision, to be taken by a different component. Splitting everything into bits can be annoying, but it makes it easy to delete and rewrite bits that no longer match the ever-changing business requirements, and it is still easy to rewrite them from scratch. A rule such as "compute shipment costs" can be isolated and interfaced for easy replacement once you start getting more obscure or complex requirements such as "shipment costs are free over 50$+ orders". Again: complex, not chaotic - chaotic is very hard to manage (or unmanageable). &gt; in a world where we use libraries? I use libraries all the time, and I still don't see a need to extend them: composition works, and if the library is a masterpiece of chaos, I isolate it behind an adapter, and I treat it as if it was radioactive: chaos stays behind the adapter, while the behaviour that I need is abstracted by the interface of said adapter. To complete: `final` has nothing to do with producing chaos, but it is a powerful tool to aid in preventing it. By declaring that a component is `final` you may be signaling to your future self or co-workers: 1. That this component is too squishy to be mocked or extended 2. That this component is rather designed to be replaced by a different implementation than extended 3. That composition may be used (interface must exist). `final` is a code design tool that (together with the diligence of following OCP rather than just "modifying the existing system") will get you to a better position.
Thanks for the advice. Will incorporate the ideas into the next version. I think my approach would be to add new methods to the Invoker for new way(s) to invoke the hooks.
You don’t want to work with traits. There is no dependency injection - no constructor, and they can be really misused a lot. You can try to look at it in a way of visibility scope for your class properties. I mean, you could declare everything in your class as public because eventually somebody could use it, right? That’s the same logic as non-final classes.
to framework.
Just curious, anyone here use PeachPie at all?
Would this be optional? I guess it would have to be for BC right?
 Sure, I can do that API for you, read-only file system, acts according to the content-type HTTP header received, supports both JSON / XML, real-time updates, redis, etc. Might take me a little more than 3 days as I'm quite busy at the moment, plus would probably want to use a Graphs database instead of mySQL, as it seems better suited for this project, specially considering the volume that you're implying. If you'd like, feel free to e-mail me full specs to matt@envrin.com. In exchange, I need you to do a project for me. Is that a deal? I need an ad network within the bitcoin industry. Here's the specs: 1. ADMINISTRATION PANEL - Quality Bootstrap 4 theme, inbox / alerts drop-down menus in top-right corner of screen. - Multiple administrators, with in-house privilege system to show / hide menus and functionality depending on the administrator. - Home page of admin panel must be customizable with different widgets, depending on the administrator's role and personal preference. For example, the financial person will see a list of pending withdrawals, the support guys will see a list of pending tickets assigned to their department, the CEO will see overall volumn, revenue, user activity, etc. - Must allow for automated backups to AWS, another remote server, or Tarsnap. Backups must support both, database dumps only or full file system. - Must have support for both, hot swaps, plus database eplication and partitioning. - Admin definable e-mail messages with merge fields that are automatically triggered and sent as necessary. 2. USER MANAGEMENT - Administrator abilities to create, manage, and delete users easily. - Full session logging of user activity - Customizable user profile fields, definable by administration. - Multiple user groups, defineably by administrator - Multiple verification levels, definable by administrator. Must allow admin to define the daily, weekly, monthly, and yearly max limits users can deposit and withdrawal, and what documentation must be submitted to obtain that verification. Must have full support for submission within the member's area, and processing within the admin panel. - Naturally, never permanently delete user account data, so upon deletion ensure there's an archival process to recover deleted user data in case of dispute. - Public profiles viewable at the /user/USERNAME URI of the software. Include photos, tagline, about me, rating system, feedback, and so on. - Allow registration via HTML form, or via Google and Facebook login / APIs. 3. USER SECURITY - Upon registration, force goot passwords, and show a passort meter showing the strnegth as they type their password. - Require e-mail verification of new accounts - Optionally, allow admin to require phone verification of new accounts via Nexmo API. - Allow 2FA authentication via both, e-mail and phone via Nexmo API. - Allow users to define IP restrictions for their accounts if desired. - Allow administrator to optionally force user's to change their passwords every X days. - Deactivate and flag account after X number of simultaneous failed login attemps. - Ensure to protect against session hacking, and other basic security measures. 4. FINANCIAL / TRANSACTION - Allow admin to define the various fiat payment processors they support. At the very least, must include support for credit card via Moneris Solusions, Stripe, PayPal, Western Union, MoneyPak, cash / check / money order, wire transfer, and so on. When user submits a deposit, must be automated if possible (eg. PayPal), but if manual processing required (eg. Western Union), the user must get the necessary information as to where to send the deposit. Once sent, the user must be able to visit the pending deposits menu, manage the deposit they initiated, and enter the appropriate information (eg. MTCN#, sender name and country, etc.). Obviously, there must be fully processing of pending deposits in the admin panel, proper notifications all around, etc. - Same as above, but also for withdrawals. Users need to be able to request withdrawals using any available payment methods which the administrator defines. - Must also support bitcoin and ethereum deposits / withdrawals. The bitcoin payments should be a watch-only wallet, and naturally, no private keys online. Withdrawals need to go through 2FA via e-mail and/or phone, then be queued for batch processing by administration. Must support offline signing of transactions for greater security. Naturally, use BIP32 wallets so only the public key needs to reside online, which allows for the generation of 2.1 billion unique payment addresses. Watch out for BIP66, as that "high S value" error can sneak up on you. - Of course, never reuse deposit bitcoin / eth payment addresses, as address reuse is simply not good. Always generate a new payment address for every deposit. - Must be fully support for transaction reconciliation and summaries and searching. 5. SUPPORT CENTER - Full support ticketing system where users can submit tickets, and manage them upon login. - Incoming e-mail to support@domain.com must also be piped into the system, and processed accordingly. If the from e-mail is a registered member, assign the ticket to the general department at medium priority to the user account. Otherwise, just put it in the public pool of support tickets. - Must support multiple support cateogries, departments, priorities, and technicians - Admin defineable knowledgebase, with auto-complete search as users are typeing / asking a question. - Live chat support bot. 6. AD NETWORK - Two users groups, Publishers and Webmasters. Both are free to register, but each get a different set of menus / functionality within the member's area. - Publishers can create and manage their campaigns. Each campaigns consists of one URL, plus various ads in different sizes / types (defineable by admin). - All campaigns must go through an approval process before becoming live. - Must include targeting by country, language, region, and category (admin defineable categories) - Must include white/black list functionality so publishers can specify exactly which site(s) within the network they wish to advertise on. - Webmasters can join and create / manage a list of sites they own, and wish to place ads on. Sites must be approved by administration. - Webmasters will get some HTML / Javascript code snippets to place on their sites, which are replaced by the appropriate ads servved by the ad network. - Must track views / impressions, clicks, and subsequent joins and purchases. - Upon serving an ad, must GeoIP the user and serve the appropriate ad to them. - Admin can define the different fees charged to advertisers in CPM, CPV, CPA, etc. - Must be processes in place to prevent click bait, plus red flag webmaster accounts for suspicious activity. - Freeze pending earning to webmasters for X days, but on a user-defined basis with admin defineably rules. For example, new users have 100% of their funds frozen for 14 days before they can withdraw, but after $XXX and XXX days, those restrictions are lifed. Admin can manually define / lift restrictions on a per-user basis. 7. AFFILIATE PROGRMA - Users can also become affiliates, create their own campaign URLs, and anyone who registers via their URLs is tracked within their downline. - Affiliates earn commission based on revenue generated from any publishers / webmasters they refer - Full campaign reporting so affiliates can track their statistics - Same withdrawal methods / restrictions apply same as for webmasters. I know I'm forgetting some things, but that's good enough for now. How long would it take you to get that done? Once Apex is finalized, it would take me about 5 days to deploy a quality and secure solution that supports the above requirements. Or I could do it right now on my existing software platform, but it's quite outdated, so won't bother. I have no idea what type of specs you guys deal wwith on a daily basis, but above is an example of a typical, every day project that comes across my desk / inbox. This is how I pay my bills, and this is what provides my family a good life. What do you say? I'll do your API for you, if you do my ad network for me. Is it a deal? 
Not sure if this helps but when I do an SPA I always use a separate project for the front end and back end. I would never try to use Vue-cli (or Angular cli) within the constraints of laravel. Keep them totally decoupled. I also use Laravel Passport and this works fine for me. It sounds like your problem is you used the Passport blade templates that come with it and that sent you down the combined vue/laravel project path. I just abandoned those views and wrote my own. If your project has an API only back end there is no reason why the Auth should be in Blade templates as far as I can see.
So, let me start off by clarifying something: when I mention most code being bad-design, it's generally code that _someone else_ is responsible for: say, another company. They may have fixes underway, they may post-poning all "feature requests" until their coming-soon API, they may just be waiting for the agile/scrum sprint to end. As an example: I recently used an API I that returned several details in every API request: fields describing the status of their system. In particular: timestamps and statistics). The API has a library to intergrate with it: no need to reimplement authentication logic, parsing logic (not JSON or XML), query-building logic (custom query language), or all sorts of other things. Long story short, we needed the timestamps and statistics returned with every request. In _their_ infinite wisdom, the library was never designed to give out the timestamps or the statistics. It made a request, parsed it, and discarded some of the information we wanted. They didn't provide a way to change the parser (or much of anything). The request was parsed with a public method on the class. The simplest solution was to extend the class, the method, and store the timestamp and stats. A better-designed solution would have the parser be its own class, but if the author of _this_ third-party library had declared their class `final`-- a solution would be much more complicated to find-- especially in a larger library (~15K lines of code), with many API methods, and many people working on it. What's your solution here? Using composition or a utility class doesn't make the information they discarded magically come back. -- I bring this up, because, in my humble opinion: the use of final is built on the assumption that the creator knows every way their system should be used, and builds on a "you should not reuse this code because I didn't think you should" mentality. You _don't_ need to design something to support (just like you don't need to design it to be composed). That's a property of these OOP systems. Even i they violate OCP, its the way they are. Yes, an update can break it later-- but for the situation above: the cost of maintaining that inheritence hack is lower than nearly every available solution. Would it be nice to properly fix the library to use interfaces, composition, and OCP? Yes. Is that the decision of my organization? Most likely, not-- unless we want to take on yet another library created/maintained by someone else. In theory, they just go 'oh yeah' and fix it. The more likely situation is that we submit the request/information, it goes through _their_ development process of review/design/code/qa-- and a few weeks/months later they tell us that they have an update that may be available soon. -- Still. The word that seems repeated is "design" "design" "design." As if developers should think of everything when they're designing things. More often than not, these designs are limited, lead to more code-repetation as people copy/paste these final classes that library-authors thought were designed, and now we have a much worse problem than inhertience with 1 overriden method. 
The whole notion of MVC/MVVM as applied to a request/response lifecycle is dubious to begin with. Those patterns you describe imply a kind of "live" statefulness that simply doesn't exist in a stateless request/response architecture of pretty much any PHP application. They are, quite frankly, bizarre abstractions around the reality of an HTTP request/response lifecycle and should probably never have been appropriated by the server-side web development "field" in the first place. The reality is simple: 1. An HTTP request comes in. 2. The request is routed to the appropriate handler. 3. The handler invokes some business logic based on the incoming request (either on its own, or delegates to another layer) 4. The handler also assembles the output of the business logic into a response (either a template, or JSON data structure etc). 5. Once the response is either echoed or returned to some other mechanism that echos it, that request is done. There is no view. There is no model. Nothing with state that needs updating or reacting. It's now HTML in the browser, and the server has killed the process. The notion of "MV*" patterns as they apply to modern frameworks is just weird. It only loosely describes a higher level notion of separation of concerns, but getting down into the semantics of what it means is just going to be an exercise in futility. 
I'd be fine with it, but it should be opt in and should require you to strongly type your variables. Obligatory "you can already do this". 
https://github.com/nikic/scalar_objects
Quite true. Especially the last paragraph. That's why I tried to be specific with saying MVC web frameworks, to differentiate between actual MVC design patterns. But honestly, the only way to be pedantic enough to be technically correct is to say that no web frameworks are actually MV\* because of the statelessness of the web. (Well, WebSockets comes to mind, but if someone can't figure their way around various MV\* web frameworks, I strongly encourage that they keep playing and keep learning before exploring open TCP/IP sockets made firewall and browser friendly.) When the rest of the programming community outside of PHP talk of web-MVC, though, they are talking about the system where the view gets data directly from the model, though. (And the model is more than just an over-obfuscated, under-engineered, over-abstracted, under-performing DB abstraction layer...)(And on that note: While I won't say that Laravel is bad, just that it isn't MVC, I will definitely say that Doctrine is bad... ;-) )
&gt; (And the model is more than just an over-obfuscated, under-engineered, over-abstracted, under-performing DB abstraction layer...) Well, the framework doesn't prescribe what the model is, though the way a lot of novices tend to use frameworks makes it appear that way. But even frameworks like .Net use the same basic request/response pattern that PHP frameworks do. Request comes in, gets routed to a handler (which semantically is called a Controller), which reaches into the domain model, gets or updates some data, and returns a response. The structure of a .Net request/response cycle is virtually identical to Laravel. Same is true of Express in Node and other frameworks I've used. I've never really seen a view hold a direct reference to the model. Everything is always mediated by the request/response handler (aka Controller) I'm sure there are some frameworks that do that, I've just not seen one in production. 
Base 2. 1 kilobyte is always 1024 bytes.
 &gt; edit: ok, wait, but if `RegistrationServiceInterface` has 20 methods and `FooRegistrationService` only needs to monkey with one of them, the rest I just want to work as before, does that then mean I need 19 boilerplate [...] declarations? Yes, that would be annoying but true. That's another one of the SOLID principles though, the ISP (interface segregation principle) that needs to be applied: how many of those 20 methods fit a single interface? If you are using a library, as I commented elsewhere in this thread, consider using an adapter that just exposes (to your own code) only the bits that you really need, and treat the library as "bad" or "radioactive", keep it out of the way, hidden.
Traits are compiler-aided copy-paste, so the fact that privates are available is 100% correct, although traits are generally problematic and mostly static methods hidden in instance logic.
Probably could just do &lt;?php declare(strict_types=**2**); or something
Yes, even before 7.0 it was good. There's always ways to optimize and cache.
Not sure why you got downvoted. I guess /r/PHP skews younger or something.
 &gt; They didn't provide a way to change the parser (or much of anything). The request was parsed with a public method on the class. The simplest solution was to extend the class, the method, and store the timestamp and stats. There are a few things that the implementor of the original library did wrong, from what I read from your frustration, but on the other side you were also relying on it directly, rather than isolating it away after determining that it is sub-standard. If I assume correctly, the library did something like following: final /* note: no interface */ class SomeClient { public function doSomething(SomeRequestDetails $request) : SomeResponseDetails { /... snip ... } // maybe another gazillion methods? } It is extremely problematic to couple your code against `SomeClient` directly, because it is: 1. not interfaced 2. under the control by a separate entity, with no way to influence development (according to their "sprints") 3. it will become a blocker for local dev work Here's what should be done: 1. make your own interface for what YOU expect the system to give you 2. implement an adapter that implements that interface 3. use (reads: couple to) `SomeClient` in the adapter, or use something else if `SomeClient` is crap In this way you: 1. gain the ability to work around whatever the external team is doing 2. get a clean API matching your own expectations 3. get a clean point of failure if your adapter misunderstands what comes from the external `SomeClient` or API &gt; What's your solution here? Using composition or a utility class doesn't make the information they discarded magically come back. If it got discarded in `private` scope, obviously no way to avoid that, and the correct solution is to rip off `SomeClient` and actually fix it instead of extending it: yes, rewriting is better than extending there! Yes, I said it, you can re-read it. And yes, if this hinders your work, do talk to somebody that affects both your and the other team's work: communicate with each other, it will help both. &gt; the use of final is built on the assumption that the creator knows every way their system should be used No, creators do not know each use of their API, but they can declare what they are willing to support and what not. Not declaring clear boundaries is problematic, as it increases the compatibility surface tenfold, disallowing future changes as any observable usage of the system becomes a BC boundary (plus all other problems of inheritance, but BC is the biggest one). Yes, it is OK to set hard/unavoidable boundaries on what is allowed, and it is OK to re-discuss those with the people responsible for maintenance, but it is not OK to hack around them (like you did). The fact that the `SomeClient` produced results that didn't match your expectations means that you need a different `SomeClient`, not that you should hack into the existing one via inheritance: that would never have passed a review on my end, and it would have become a chat, patch and fix with the other team instead, because they may even decide to break BC on the actual payload instead. Heck, even sending a code patch to the original `SomeClient` directly would be fine: is there a communication company with the other team? &gt; Even i they violate OCP, its the way they are. Yes, an update can break it later-- but for the situation above: the cost of maintaining that inheritence hack is lower than nearly every available solution. No, this is not an OK solution, it is something that you understand and solve on spot, and then lives on until it randomly breaks years later in unexpected ways. I say this from personal experience, not just theory: each of these hacks is fine for temporary solutions, but needs to be followed up with a correct and prompt fix, as otherwise it rots and becomes an unknown maintenance piece of work. &gt; Still. The word that seems repeated is "design" "design" "design." As if developers should think of everything when they're designing things. That's our job. &gt; More often than not, these designs are limited, lead to more code-repetation as people copy/paste these final classes that library-authors thought were designed, and now we have a much worse problem than inhertience with 1 overriden method. Copy-paste is fine when you also port over the tests and *add* (careful: not "change") your scenarios: your slightly different copy-pasted variation of a class should match your use-case. For your "quickfix", copy-pasting the entire adapter and using `class_alias()` or such to remove the original one from existence would have been fine and a more explicit and documented bugfix and mitigation. The worse (less?) the code structure is designed, the worse the problems with copy-paste and hacking around stuff become, hence why composition is advisable over inheritance in the vast majority of scenarios.
Haha okay. :)
That would be so awesome
Yes, my workload is mostly I/O and DB bound, so even if PHP magically got 10 times faster it wouldn't change a lot for me, I'd still need to read and write 4GB XML files to the disk and wait for MySQL to read/write. I have never encountered a situation where I thought "I wish PHP was faster". When something is slow it's usually a problem with our code or database structure.
I figured it out. 1M = 2^20B
Take a look at *post_max_size* and *upload_max_filesize*, I think all you need is to increase those. I don't think you'll hit the memory limit, but (use set_time_limit())[http://php.net/manual/en/function.set-time-limit.php] if you hit the time limit.
Uploaded files aren't loaded into memory, but written into a temporary file before the script is executed (in standard ISAPI, such as Apache or CGI).
Also see https://www.reddit.com/r/PHP/comments/99xtpn/i_have_developed_a_realtime_currency_converter/?st=JLYQ8QP8&amp;sh=50e2bf1a. 
Obviously. That's what I'm saying. Final classes are used as a solution to not break people code who extend it, as they won't be able to extend it in the first place.
Have you tried swoole?
I’m less impressed than I used to be, although it could be at least partially related to the runtime environment. Part is also a completely unfair comparison to compiled languages. The speed gains I’ve seen from dropping FPM in favor of something like ReactPHP are mind blowing (to the point I was sure something was wrong), but there are some pretty scary and unpleasant downsides that can make a real mess that you’ll just never encounter with FPM. What I’d really like to see is a first-party tool that bridges the gap: drop the FCGI to avoid the extra round of parsing in favor of straight HTTP, and do *something* to persistently warm up the worker pool in a way that APC just isn’t covering. The latency I see before my routes actually run is stupid, and I’ve done some fairly deep profiling to try solving it. Maybe APC just doesn’t work right in Docker. Who knows? The numbers don’t make sense. 
@adrianmiu On a second thought, you can already provide your own `$carry` to your module with the current library: ```php $request = GuzzleHttp\Psr7\ServerRequest::fromGlobals(); $result = $invoker-&gt;reduce( YourApp\Awesome\HookInterface::class, function ($carry, YourApp\Awesome\HookInterface::class $module) use ($request) { return $module-&gt;process($carry, $request); }, [] ); ```
There are a few replies mentioning that it's base 2 but since nobody provided a citation for you: https://secure.php.net/manual/en/faq.using.php#faq.using.shorthandbytes &gt; 1M equals one Megabyte or 1048576 bytes. 1K equals one Kilobyte or 1024 bytes
Have you checked if all important files actually cached?
Pretty much this. Most of the time you optimize database queries and that stuff doesn't change with the platform. 
Let’s be clear here, I surely won’t have the time to _actually_ make this project (and I didn’t think you would, I have work to do) to have a nice direct comparison, but there’s a bundle for almost every feature you presented and it would probably take like 5 days, too, hard to calculate quickly, give or take 2 days. The points you listed pretty much sounds like _the_ Standard case you can represent with your framework, but once you try to break out of it, it will get in your way. I’d love to see where in your framework you’d hook an extensive messaging system and where you’d e.g. replace all caching with redis, without modifying the framework itself, obviously. Then you’re talking of “quality and secure solution”, my friend, the last time you presented your framework here I tried your admin panel and was greeted with raw, echoed PHP errors. There is no quality (you don’t even really have unit tests, what exactly do you think is “quality” in that) and the framework is also not secure based on the ease required to trigger errors in it. You use abstract classes like interfaces, static classes all over, DI is non-existent (more in my first comment), don’t tell me you have quality software there, you don’t understand basic OOP concepts. I explained, it detail, why your framework will never be a competitor in the PHP world in my initial comment in this thread and I pretty much stick to that. You might not believe me, obviously only time will tell, and I know what time will tell already. You will just see that you wasted your time on trying to make it enter the current library ecosystem of PHP that contains better and more stable resources for every single task you listed. If it feeds your family and you are happy with it, I will surely not tell you to stop programming or anything. As I stated, I have respect for you coming here and getting this feedback. But when you state things like “I am sure it will make a dent in software industry”, really, it sounds like you are absolutely delusional and don’t even understand the PHP ecosystem. The requirements for my application are the most common requirements you find today in halfway big applications. Now, it’s not like Symfony or eg Laravel can only handle these cases, you can use them for the smallest blog up to the biggest platform. When I want an admin panel in Symfony, I install EasyAdmin or Sonata, write exactly one single YAML file and I have it, fully with a neat, clean design, theme support, the possibility to override single templates, form fields or add completely own, unrelated pages etc. Your framework doesn’t bring anything new to the ecosystem with that. I am really sure, if you’d just invest your time in writing a good bundle for Symfony that implements your requirements and use that along with the Symfony ecosystem to write your software, you’d not only be faster, but also more safe and you wouldn’t lie to your customers when you tell them they get quality software.
Yes, outsource them to extensions.
Scalar objects are bad idea, first the performance cost with all the unboxing but also is does not really solve anything that can't be solved better with pipes, pipes can handle custom functions, not only object methods. And my guess this will just create the nuisance of Int vs int. 
My wish list. * Scalar objects * Enums * Generics * Typed properties Do that and I'll never leave you, baby.
[https://github.com/esminis/php\_pecl\_id3](https://github.com/esminis/php_pecl_id3) 
IMHO the main problem is NULL. Imagine you fetch a value from a database and this value could be a string or null. This would work: $name = 'Matt'; var_dump($name-&gt;length()); // int(4) But this would fail: $name = null; var_dump($name-&gt;length()); // error
Stop with marketing shitposting already. Downvoted
Typed properties are highly likely to land with PHP 7.4; the RFC vote is 42-0 in favor. Generics/enums have some support with PECL/user land.
hmm but null isn't string, why would we want to treat it as a string? also can we not do `($name ?? '')-&gt;length()`?
OH I'm sorry I didn't realize I was in the presence of le super smart """"REDDITOR"""" :\^)
It's almost as if actually doing a thing has more value than trying to stir up a shitstorm on Twatter and trying to petition the Internet to do what you want on your blog.
You would of course have to check the variable before doing a normal function calls as well, however the deeper problem here is either methods needs to return a NullObject or we have to introduce Optional.
because every php dev could implement this by himself....
&gt; read and write 4GB XML please accept my condolences
In my case, I would suggest outsource to Crystal if PHP consumes lots memory and you want as good as Go performance.
The patch is backwards compatible yes, and typed properties are optional.
"If you pay peanuts, you get monkeys" 
[From the docs](http://php.net/manual/en/function.empty.php): empty() does not generate a warning if the variable does not exist.
I just wish function names followed a standard so non-PHP devs would shut up about them...
Well, if they tried....
I know about that, what I'm wondering is the reason why a notice causes a file to be downloaded since I didn't notice any Content-Disposition header in the server's response. Must be some weird configuration fuckery.
https://i.imgur.com/DK1ckG8.png
I've been using it in production for 2 years without issue. Development isn't a fucking meme. Using the best tool that is right for the job is just smart development--for you to unilaterally decide that there are no situations in which Phalcon should be used tells me that you're not a very good developer. Them's the breaks, kid.
"Scalar objects" is understood to not involve boxing.
Couldn't they have called it *anything* else? Is this some kind of SJW-friendly library?
4 is where its at.
Ok, looked at your repo, it is one level of indirection . So not that expensive. &amp;#x200B; However pipes are still far superior than scalar objects. Scalar objects does not really solve anything substantial in the language that can't be done with userland code. &amp;#x200B; Much better to focus on functionality that can't be solved in user land.
That's not what the OP is talking about, they mentioned mixed types, not mixed return values, which are very uncommon considering most languages are strictly typed.
So... basically Laravel Dusk? 
I've not done a deep dive yet, but I'd expect it plays a lot nicer outside of a Symfony app than Dusk does outside of Laravel
What makes you think they don't follow a standard? In fact, they follow several standards.
[Relevant XKCD](https://xkcd.com/927/)
yeah how dare they make a friendly introduction article more user friendly by adding smileys, a concept so literally fucking old that it existed before the internet, the scoundrels
I know we shouldn't feed the trolls, but I cant help but wonder: What the hell is wrong about the name "Panther" that it rustles your jimmies like this?
I've been using scalar objects myself in production actually, never noticed any performance issues with it. Apparently Nikita Popov's implementation is efficient enough, it will be even better if the handlers are written in C instead of userland PHP code. I've been attempting to create a C extension for scalar objects handlers myself, it will be useful for websites with heavy traffic in production. Also as the author himself pointed out, theres no such thing called boxing involved, you need to do your homework before making a comment. 
There are many ways to solve this problem. One solution is to define a __callStatic() method for Null Object Handler, which returns Null. Another solution is Null Safe Call, like other languages such as C# and Swift have attempted. See this RFC for details of how Null Safe Call works. https://wiki.php.net/rfc/nullsafe_calls
Also, this: [https://www.reddit.com/r/lolphp](https://www.reddit.com/r/lolphp)
Do you use class constants of your exception classes for the different messages? Otherwise it seems rewording a message (e.g. to fix a typo) would be painful.
you're fumbeling around in a php extension which you can't step in with a debugger, for no real performance gains at all. I've also used it in production, to my regret.
Not really, it's just a string that you have to change somewhere. It doesn't matter if that string is created and passed immediately to the constructor of an exception or whether it resides against a constant. If you have multiple places that can throw an exception with the same message then that sounds like it could be a code smell. You either need to refactor the code that can throw an exception into a function or method, or alternatively created a dedicated exception at that point. It's difficult to say without seeing the code.
Sounds about right.
(Finite) Union types are awesome. The problem is only that `mixed` means "lol. This could be anything. Good luck". Union types usually behave as containers, so you can't just assume you got one type or another.
&gt;Part is also a completely unfair comparison to compiled languages. Why? Are you banned from running a compiler when you write software? I never understand why we're not allowed to compare interpreted languages' speeds to compiled languages'. &amp;#x200B; E.g., I'm writing a backend app. Languages with lots of web backend frameworks/libraries include : PHP, Go, Java, Python, Javascript. If I care about speed I'm going to use Java or Go. Nobody forced PHP and Python to give themselves a speed disadvantage by being interpreted.
Oh I see what you mean. No, I never test the message in the code. As you say, the messages are front end human descriptions of what went wrong. If I need to do different things with an exception I create a new exception class and catch that.
It lets you use the existing Symfony browser kit API to drive browser automation. So broadly similar to Dusk, Mink, Codeception and whatnot, useful for Symfony devs who know that API
If you want to use this for unit testing, it's a waste of time. Webdriver / Selenium is huge and panther(e) is trying to put some of its functionality into an incompatible interface just to be backwards compatible while not bothering to interface all the other really useful stuff. Panther does not add many new functions that make selenium functions easier to access / use so you're going to be using selenium writeups for your questions and accessing the webdriver objects natively for anything other than click here and click there. You'd honestly be better off using webdriver natively and getting to grips with it.
As pointed in the blog post, the main inspiration are NightwatchJS and Goutte. As both Panther and Dusk are basically tiny wrappers around Facebook's PHP WebDriver (itself a tiny wrapper on top of the Selenium/W3C spec), yes Laravel Dusk, Codeception, Nightwatch, Perl Selenium Remote Driver... and actually all tools using WebDriver are somewhat similar. One of the main difference between Dusk and Panther is that Panther implement **exactly** BrowserKit's public API: thanks to this, every existing Goutte scripts and Symfony functional tests (WebTestCase) can now be run in real browsers thanks to Panther. Also, Panther as been designed has been designed from the ground as a standalone library, that plays well with non-SF apps (Laravel, raw PHP...) and the experimental bra
The nice part of scalar objects is that it has been implemented by a PHP internal, so the C code is there and all we need to do is to show interests, advocate for it, and of course find a possible way for it to merge with PHP core. For Generics however, all I've seen is an RFC in which the creator did not even include a patch for it. Its effectively just a feature request, the creator was begging for others to do it for him. I am not optimistic that Generics as a language feature will be available anytime soon, maybe not even PHP 8 if all they can do is to make a feature request instead of actually writing the underlying C code. 
If a fair benchmark exist that would be great, guessing performance does not really say anything, even though we now the theoretical cost.
I think strict typing should gradually become the standard. A good idea is that in PHP 8 strict typing is enable by default, with option to disable it per file. Throughout the minor releases it becomes deprecated and a notice error is thrown if not using strict typing. In PHP 9 strict typing will become the only option, thus weak typing will be completely removed. 
Panther is not designed for unit testing but for e2e and browser testing, as well as web scraping. And yes, as you can see, I contributed in PHP Webdriver directly everything that can fit in it (checkboxes manipulation, Geckodriver support...). The BrowserKit API is higher level (and so easier to manipulate for simple things) than the PHP WebDriver one. With Panther, depending if your tests require JS support or not, you can choose to execute the same scenario, using the same API, in the browser (with WebDriver), with Goutte (HTTP client and HTML parser in pure PHP, without JS support, but super fast), or directly with the Symfony Kernel (no network connection, pure PHP, lightning fast). For browser specific features, you can access the PHP Webdriver API directly (I think it's better to improve this library when possible, like I've done regarding checkboxes interaction, than adding a new one on top of it). Then, ofc, the test will not run in Goutte or WebTestCase anymore (you can also skip WebDriver specific part of the test using conditional execution, as done in Panther's test suite). Also, Panther brings high level convenient features not available in PHP Webdriver directly: * it detects the project structure, if it can guess it (Symfony Flex only for now), it exposes a local web server that can be queried by the browser. You can configure Panther to run the webserver for any project structure if you don't use SF. * it is shipped with ChromeDriver (and Geckodriver for the experimental branch) and it uses it to find the local installation of the browser, starts it in headless mode, and allow to run the tests without having nothing to install or configure. 
And you acting like you are in a position to rant about downvoting when you just downvoted my comment, what a hypocrite. 
What is your so-called theoretical cost? Scalar Objects are an excellent workaround for the lack of scalars as first class types in PHP. An ideal solution would be to make every scalar types true objects themselves, but that will incur significant performance penalty, as well as a full rewrite of Zend engine. The Scalar Objects are the syntactic sugar, scalars are still not true objects, but its more practically plausible given the nature of PHP. 
If you *want* to shoot yourself into your own feet, you are still allowed to do so. But it shouldn't happen in subtle ways, only explicitly. (And it's not like you would be _accidentally_ unset()'ting a public property.)
Yeah so what? You are crying because you got downvoted, which had nothing to do with technical arguments or not. I did not downvote you, and I aint responsible for you getting downvoted by whoever did it. The problem here is, you complain about others downvoting you, when you are downvoting them as well. See what makes you a hypocrite? Its like a fake animal activist telling others not to kill wild animals, and then go to hunt animals himself. 
Sure, that can all be true that I'm a hypocrite. However the "must have scalar object"-argument has raged on this forum for a long time and it has a semi-religious tendency to it, similar to redesigning the PHP std lib. It is from that perspective I made that comment. Proponents of scalar objects rarely solves the problem with custom scalar object methods. Thats why I prefer pipes. Performance was not the main part of my comment, it was that scalar object does not really solve anything fundamental in PHP that I can't handle myself.
2 heures du mat' sur l'parking d'Auchan, faudrait qu'on s'voie
&gt; Much better to focus on functionality that can't be solved in user land. A consistent API can't be achieved in user land.
You don't really want scalar objects. You think that you want it because this is the most familiar thing which solves some of your problems and introduces new one. In reality what you want is to ability to chain function calls and consistent function names/signatures. Scalar objects is not the only way to do this, and it has many downsides (it's not scalable without monkey patching, which is bad idea). There are also other options like pipe operator, which allows you to chain regular functions. 
why not?
I suppose it still lands on the technically possible list, but after 15+ years of widespread use it still hasn't happened.
Consistent API is achievable on user land (just no one really made one), the problem is how to enforce devs to use it. You could start from providing rulset for php-cs-fixer or similar tool to automate transition. Without it, just forget about quick migration path. 
&gt; You'd honestly be better off using webdriver natively and getting to grips with it. If it implements WebDriver, it is WebDriver: https://github.com/symfony/panther/blob/1390bf88ac9d72f53da4d5d258adeb5463d96f3f/src/Client.php#L36
Why do `BasicDocument::addFooter` makes a copy of the passed array? As `$p` is an array and is not passed by reference you could simply add the footer to the `$p` variable and the `return $p;`. Same happens with `BasicDocument::addHeader`, you should simply use `array_unshift` and problem solved. I will take a deepre look at it when I get home and the fill an issue or make a Pull Request.
Yes! Pull Requests are appreciated and this feature will be very welcome: https://github.com/symfony/panther
This is a very good read regarding this topic IMO - [https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/](https://www.troyhunt.com/your-api-versioning-is-wrong-which-is/)
So... basically ~~Laravel Dusk~~ another web-driver?\*
Oh, then sorry. I did not know that KATA means refactoring challenge.
Excuse my ignorance. But with this change, are getters/setters (with private pros) not recommended? The preferred way would be to make the props public, as PHP would kick off if I pass a string to something declared as an int?
&gt;11 comments WPengine or Flywheel... blink twice if I'm right :D
Some people like you on reddit are discouraging the coders in a significant manner. I am very curious about why you have emerged yourself in discouraging others. I will recommend you to discuss on what are the mistakes I have done in my codes. Will really appreciate your suggestions. But the way you have commented here I am really surprised. and the last line **" what made you decide to share this with us ? " .** This is a free source code and free tutorial for the beginners to learn some basic scripts. And the fixer io API will not let you convert currency free of cost. And I have done that conversion with a logic. Maybe you are a great coder, But please at first try to be a human. Don't take it personally . Have a great day
None of this is correct. Anything you say after this is just pure dog shit.
I interpreted that as `@returns bool|int`
\&gt; Panther is not designed for unit testing but for e2e and browser testing So, if you were to test your application, you'd want it to run as it should using a real server, not using the php server. This will help detect server-side issues. &amp;#x200B; There's no benefit to being backwards compatible with goutte / browserkit. this does very different things. do one thing and do it well. &amp;#x200B; only checkbox interaction is not good enough as for anything beyond the basic, you're going to be dipping into the native webdriver, and your tests look weird and not easy to read using half of one unfinished implementation, and the native interface. you may as well use the interface as it is. if you're going to wrap features around webdriver, do it all. dusk is actually pretty good in this respect. &amp;#x200B;
Imo we desperately want something like `?-&gt;` for normal objects anyway, the fact they'd obviate _odan's gotcha for scalar objects is a mere bonus!
Registered for 2 days, made 96 comments. Jesus Christ, you're putting way too much time and effort into a low quality troll account.
Separate repos for SPAs is definitely a best practice. This allows you to serve your front end over a CDN and it allows for much easier server side rendering should the time ever come. However, it does have caveats - you get less help from laravel for auth and testing, and all of your views must be handled by your SPA. I personally prefer to go down the hybrid route (Laravel handles auth with traditional sessions / cookies) for smaller / mid size projects as the burden of project set up and maintenance doesn't outweigh the performance gains you get. Maybe just stick with Laravel Mix OP :).
I highly recommend checking out the original article by Robert C. Martin: [Principles of OOD](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod). These principles can also be found described/referenced in his Clean Code series of Books (Clean Code, The Clean Coder, Clean Architecture).
If you want things to change, you're the only one responsible for it. Otherwise, you can only ask, wait and hope someone does it for you.
&gt; Why? Are you banned from running a compiler when you write software? Nope, I'm not! Although a lot of people effectively will be due to existing infrastructure. I regularly see compiled and interpreted languages compared against each other - it's unfair in the sense that interpreted languages don't really stand a chance, not that the metrics aren't meaningful. But to demonstrate how comically bad "recommended" setup (nginx+php-fpm) is: I have a simple best-case route in my application, which just responds with an empty `200 OK` for a health check. No database, no auth, etc - effectively a test of application startup and routing. Reasonably-tuned PHP-FPM+Nginx: 160-200ms ReactPHP: 2ms On a real endpoint involving multiple DB roundtrips, I see a drop from ~500ms to ~40ms. About 20ms is DB in both cases. That's just plain stupid. Admittedly, my settings may be sub-optimal, but that's not for a lack of trying to optimize them.
Since more and more people leave Farcebook, in time HHVM will be unsupported and irrelevant. So, switch to PHP 7.
I can’t speak for the OP, but You have completely missed the point why so many developers want scalar ohjects including myself. I don’t need the ability to chain function calls, what I need is that scalar types are first class objects like Python, Ruby and Javascript. Unfortunately in PHP it won’t happen, so the scalar objects serve as syntactic sugar to make scalar types behave like objects. It may be a lessor alternative from pure OOP’s point of view, but it does mitigate possible performance issues if scalar types are turned into objects. Also there is already a C implementation and it looks promising. It may have flaws, but it can be improved further. 
Just for clarification, old definitions floating around like that are why I said "always". If you see it anywhere in 2018 it's always going to be 1024.
I've read the book and IMHO the **first half**, covering *class/package/dependency/architectural principles*, contains the **more important/useful** information. Also the Appendix contains some interesting anecdotes and insights as well.
 &gt; it should using a real server, not using the php server. This will help detect server-side issues I agree, and it's exactly why you can pass the URL of the real webserver (like the one you have configured in your Docker setup) as first parameter of `PantherTestCaseTrait::createPantherClient()` and `Client::__construct()`. However, it's convenient to be able to run tests without having to install and configure a web server (when Docker isn't used, or when contributing to an open source project for instance). Also, sometimes you don't know which server will be used in the early stages of the project, sometime you don't even know it at all (open source project, project running on several servers...). Type "phpunit" and that's all. Onboarding matters a lot. &gt; There's no benefit to being backwards compatible with goutte / browserkit There are big benefits: - you can super easily adapt existing tests and script very easily to use real browsers (it's actually why I started this project in the first time, most of my new projects are React Progressive Web Apps consuming an API, so my e2e tests are written with Nightwatch) - most Symfony devs and any PHP devs are already used to the BrowserKit API, they can use Panther right now, they already know it - the BrowserKit API **is** convenient and well thought, it has been designed for browser testing &gt; this does very different things &gt; Goutte is a screen scraping and web crawling library for PHP. Goutte provides a nice API to crawl websites and extract data from the HTML/XML responses. &gt; Panther is a convenient standalone library to scrape websites and to run end-to-end tests using real browsers. &gt; The BrowserKit component simulates the behavior of a web browser, allowing you to make requests, click on links and submit forms programmatically. Well, BrowserKit simulates a browser, while Panther delegates to a browser. There is no fundamental difference. BrowserKit is a (very basic) web browser written in PHP. Chrome Headless is a (very powerful) web browser library written in C++. The same high level API could be used regardless of the engine, it's what Panther achieves. &gt; if you're going to wrap features around webdriver, do it all. dusk is actually pretty good in this respect. Every new helper added to Panther but not to BrowserKit dig the hole between the two tools. The main benefit of Panther over Dusk and similar tools is to implement the BrowserKit API. Methods for new features (such as file download) should be added to BrowserKit first, then in Panther. When dealing with "visual" features (screenshot etc), or low level features (injecting JS for instance), that cannot be implemented in BrowserKit, it's IMO better to use the `WebDriver` interface directly. PHP WebDriver is thin layer around the protocol. Being close from the protocol allows to easily find resources (blog posts, stackoverflow questions...) from other bindings (Java, Python, Go...) because the method's names are exactly the same. I don't think that it's a good idea to alias all existing WebDriver methods because we find a "coolest" name, if we find a better name, we should propose the change to the W3C (yes... harder). &gt; Your tests look weird and not easy to read using half of one goutte interface, and the native interface Did you looked at tests written with Panther? It's rare, and when it happens, I think it looks very natural.
Sure, but my point is in comparing PHP's type system to Java's. The claim was that PHP having non-null types by default is better than Java's approach. I would agree, on the face of it, however PHP's type system is no more helpful than Java's nullable types. I can take your defense of PHP's type system and apply the exact same logic to a Java method that says it returns a `Foo`, but sometimes returns `null`. It will blow up on first access, so it's easy to track down. It only happens if you explicitly return a null instead of the thing you're supposed to, etc. So, while PHP made the right choice in non-nullable type hints, it actually doesn't matter at all whether it chose nullable or non-nullable due to the way classes work in the language.
I remember when HHVM &amp; Hack were first announced/released. I **WANTED** IT! The performance! I never got around to switching because I'm a lazy piece of crap. Finally my laziness has paid off!
Does any even use HHVM to care? The only thing it had going for it was its speed executing PHP and now they drop support for php. 
Off topic, but I scrolled through your comment history and all of the posts I saw had Gold attributed to them. Did you just stockpile on Reddit Gold or is some super friendly Redditor stalking you?
Nah, in Java it blows up upon first dereference. And it's also impossible to assign null to a non-nullable typed property here. In Java however you can store the value and pass it forward many times, just to discover, that it was set to null somewhere, when actually accessing the value. So it matters as in that the error is much earlier than in Java.
Shows what I know. I thought HHVM was (at one time) just a faster PHP processing engine.
It pretty much was. HHVM was the second PHP engine that Facebook made too. This time though they eventually developed their own subset of PHP analogous to Typescript for JS. After the release of PHP7+ though the benefits of HHVM over native PHP became less impactful. So now, because most the PHP specific improvements are in core, Facebook is removing PHP support from HHVM.
1.x: PHP to C++ transpiler 2.x: PHP VM + JIT 3.x: PHP and Hack VM + JIT 4.x: Hack VM + JIT 5.x: ???
To install the other lib I can just do pecl install id3.... how we ups I install this?
Ah, yes. You're right.
Good luck! Facebook's certainly large enough to sustain such an effort internally. I just hope it's benevolent enough to sustain the developer outreach as well, once the time comes, in the way Microsoft has with TypeScript.
Surprised? Maybe not, but come on - even if a client never told me any of that, there’s no way I’d write that garbage, and I’ll bet you wouldn’t either. That kind of code says more about the dev(s) who wrote it than it does about a failure in management. 
This mentality is so, so sad.
I am a big fan of Laravel and make good money working with it, but fuck the hell off with comments like this and Taylor's "imitation is the sincerest form of flattery" tweet. So much pretentious shit in the community.
&gt; We expect support for real-world PHP code to break rapidly [...] one possibility is that we will move to releases every 4 weeks [...] Facebook’s Hack libraries and tools on GitHub will only target the latest release, not LTS versions What they're saying is anyone who uses HHVM ~~may~~ will have costly upgrade cycles every time a new version is released and will likely need to spend a few days every month to stay up to date. There are times I wish features in PHP moved a little faster, but that's taking it another extreme.
&gt; The difference between kB (kilobyte, so 1000 bytes) and KiB (kibibyte, so 1024 bytes) has been long forgotten as far as I understand it. It absolutely definitely has not. RAM, CPU caches, etc uses KiB, MiB, GiB, defined as 1024^1, 1024^2, 1024^3, etc, and by convention these are also KB, MB, GB. HDDs (even SSDs) use KB, MB, GB, defined as 1000^1, 1000^2, 1000^3, etc. The difference matters and will never go away.
nope, I'm french and yes it's not so easy to write post in english.
Wish this was available before I wrote a suite of [PHPUnit-Selenium](https://github.com/giorgiosironi/phpunit-selenium) tests, it works, but a bit clunky for sure. This looks more elegant.
Which of those can he put into memory_limit ?
5.x: VM + JIT 6.x: JIT 7.0: ??
Hard to distinguish input from code. It would be more clear if the expected output generating examples in `index.php` were separated from input array (independent from one another, starting with the same data array). I'd also move that to README describing what output should be and example of current code that produces it.
What.....what are you talking about? 
Didn't wikipedia moved to HHVM? Anyway it was never going to work to PHP's over reliance on C extensions. 
Pas la peine d'en rajouter mec, tu passes pour un con la.
Why so many people keep asking that question? But if you want my answer, the fundamental issue with this language is that it is badly designed. Of course, if you only know PHP you won't notice.
I want structs passed on the stack.
AKA "uniform method call" like Ada where you can do bar(foo,baz) or foo.bar(baz) in certain conditions.
Any serious codebase that seriously does solid?
Facebook is dropping PHP?!?! 
A few big companies with massive code bases moved to HHVM a couple of years before they announced they were dropping PHP support. It was in that HHVM heyday period right before PHP7 was released. Before we all realised that the gap between HHVM/Hack and PHP was going to close so fast. Slack is the one that comes to mind for me. As mentioned Wikipedia is on that list too. Just goes to show, don't be so quick to jump on to the next greatest thing. I imagine the guys at Slack are kicking themselves now.
Sorry for the late answer, I was travelling. &gt;I was thinking how to reply to this, as it did get me down a little. That was not the goal, but a needed displeasing effect. &gt;I start second guessing myself, and thinking maybe I really don't know what I'm doing. That was the point, and I am sure that you don't know what you are doing. &gt;Thankfully for me though I have this absolutely amazing spouse, we've both been through some rough times in life, but we have some absolutely amazing plans for the future. No sarcasm here, I wish the best to both of you. Glad you find someone to go through life's shit. Mad respect for the will to go at it again while being blind too. I hope I would too. That being said ... &gt;In order for those plans to materialize, I have to stay strong, so I will do just that. Be strong by all means, but here you are delusionnal. Do you really think you can, alone, be smarter than years of hundred of the best php programmers working together ? Even so, when everyone tells you you are miles behind, and you had so may things very wrong on the first reddit thread already ? Ever heard of the [dunning-kruger](https://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect) effect ? &gt;So here's my answer to you. If you're so confident that Apex is a pile of garbage, then you're more than welcome to show me up, and you will have that chance in the near future. I have to take a couple weeks off to concentrate on another project, then will come back to Apex and finish it. Once completed, I fully intend to cause some controversy online, with hopes of sparking a developer competition. There's a good chance I'll be able to get some sponsors to provide cash awards via bitcoin. Say $2000 USD via bitcoin to the winner, or similar. I doubt everyone would sponsor that unless they are either dumb or ill-advised, the only controversy you'll spark is on /r/lolphp and the likes, and bitcoins, really ? By next week it will have fallen by 20% again. I hope you are not one of those *I put everything I own in bitcoins.* &gt;Individual entrants only, we'll somehow get some judges everyone is comfortable with and knows are unbiased. They will come up with some project specs, we will all get them at the same time, and have 24 hours to complete the project using whatever language / framework we want. May the best person win. &gt; What do you say? 24 hours of your time, a nice say $2000 USD payday, plus you get to showcase your skills and show everyone on the internet how much of an idiot and novice I am. Who knows, maybe Apex will get slaughtered, but only one way to find out. Up for it? I would have no pleasure destroying your last year's work, believe me on that. I'm just trying to make you cut your losses and move on. The competition you are proposing will be either biased to apex side (no test needed, only a set of apex already existing features, no security concern, ...) or a complete loss on your side. You are speaking of fighting against the whole internet here, be it contestant or composer packages for anything. Again I don't believe you'd get those 2000 anywhere except your own pocket. Even if I applied, it wouldn't prove anything about Apex anyway, only that I, with tool I know is better or worse than you, on tool you know, on a specific example. Let's compare Symfony with Apex, the day more than 100 people are doing meaningfull work with it. --- I tried to make you see your shortcomings. I won't engage on that subject any longer. Good day and good luck, and mad respect for not acting crippled by blindness.
Thanks for the recommendation- I'll reach out to them.
The platform compatibility is definitely a huge selling point. I'm going to do some experimentation with everything myself! Thanks for all the input.
FYI, MacOS uses base 2 for KB and MB, but then switches to base 10 for GB. If you try to make a file 2^40 B in size, file explorer will say it is bigger than 1 GB. I assume this is because base 10 GB is used for RAM and HDD sizes (to make them seem bigger). So...no, it's not always. It's very confusing, and I required precision for my problem.
Pretty sure they did ages ago.. that's why they developed https://docs.hhvm.com. Anyways.. it's biggest advantage over current versions of php is built in async, and templates. This basically allowed them to transition much of their symantics of php into a fully compliant language which now just gained probably millions of lines of code.
8.0: PROFIT
As much as I hate Facebook, I highly doubt HHVM is harvesting your data.
For security, these guys come up on here occassionally: https://www.ripstech.com/ For performance a company I used to work for used this service: https://newrelic.com/php I was tasked with fixing the performance issues it pointed out. Surprisingly I found large amounts of notices and warnings are costly, at least according to New Relic, 6 years ago, and on PHP 5.6. More costly than doing isset or always defining a variable, who knows?
Thanks for the recommendations- I've actually worked with both of those services before but never in much detail. I might have to check them out again.
I like that you linked to an issue by Hall of Famer himself.
Hey, thank you for your reply. I've known this `League/CSV`. Actually I concern about that why the PHP does not support the CSV functions completely. The Python CSV module also supports this well.
Hello JavaScript and every JavaScript library ever made by any one alive. How are you?
iirc many basic things (eg gettext) were unsupported which made it unusable for us back then.
I don't think a language should provide functions to read/write csv's, as there are hundreds of different file formats, file types,... If they have a file read/write, the community can create a writer (like League\\CSV).
You shouldn't trust my code because I'm not that good PHP and I honestly have really blurry view of what you're trying to do there, but I think this does the same thing. $url = $this-&gt;apiUrl . '/' . preg\_replace\_callback('/\[A-Z\]|\[0-9\]+/', function($matches) { foreach ($matches as $match) { return '/' . strtolower($match); 
They did, but they're [moving back](https://www.mediawiki.org/wiki/HHVM): &gt; In September 2017, Facebook announced that HHVM would not aim for PHP compatibility in the future.[1] After discussion[2] WMF adopted a plan to migrate the WMF production cluster to PHP 7. Once that's done, HHVM support will be dropped from MediaWiki
I think the question was just right, because it resulted in a good answer. I am not sure though that SOLID allows pragmatism. A "principle" is a first class citizens in design, at least thinking about it is not optional and maybe contradicting is is plain wrong. Maybe it is just the word "principle" which makes things too unflexibel or the lack of rules which result in pragmatic code that can easily evolve. 
I never said it did.
I never said it did.
*facepalm*
&gt; Facebook is removing PHP support from HHVM Do I understand things correctly?: HHVM was originally created to make PHP run faster, than Hack was created as a better language that runs on HHVM, and now HHVM + Hack are moving away from PHP entirely.
According to Google, this is a rough translation from Russian article based on the original works of Martin Fowler. Not sure if this double translation really worth reading.
Here are my headers: $headers .= "MIME-Version: 1.0\r\n"; $headers .= "Content-Type: text/html; charset=UTF-8\r\nContent-Transfer-Encoding: 8bit\r\n"; &amp;#x200B;
&gt;/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). So is the content actually valid UTF-8? Doesn't matter that you set UTF-8 as the charset if you're actually using a different encoding. Also make sure that the header is what you expect it to be on the inbox side - display the raw content of the email and compare it to what you expect.
Interesting! I only skimmed the code but it looks like your are pooling up to X clients per process, and forking when there are too many clients. Am I correct? I wonder if Laravel Echo Server will be changing over to this to avoid running NodeJS. Have you done any benchmarks?
Ok thanks &amp;#x200B;
I do believe that file_get_contents() emits an error which can be easily converted into exception by a site-wide handler and thus do not require such an elaborate effort.
I agree with you. I liked especially the metrics he defined for components. It would be interesting to see how well they work in practice.
Exceptions. Are. Exceptional. :(
Did you read the article? This is about fixing php functions that return false instead of throwing an exception when they fail... So it is talking about exceptional cases. 
See example given [here](https://secure.php.net/manual/en/class.errorexception.php#errorexception.examples) 
Well, the CSV functions in internal PHP seems to lack one feature. I know it's not possible to implement many file type reader/writer inside PHP functions. But the related csv functions in internal PHP just miss one. That's why I concern about that :-).
By the time we get to "or the disk could be damaged" I feel like it doesn't really matter what else the code may do, it should probably just full stop. I agree with /u/colshrapnel, use a single site-wide handler and be done with it. There are more important things to be doing than trying to put rubber padding on every possible edge case. Unless you're coding internal software for a medical device. Then by all means go nuts on tightening every possible scenario down. :)
I did. The first example used is `file_get_contents()`. Reading past the end of the file is not exceptional - it's normal, boring, mundane.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
# [A PHP fpm heathcheck, writen as POSIX shell script](https://github.com/renatomefi/php-fpm-healthcheck) Previously at work we had Docker containers containing both php-fpm and Nginx processes, while they were managed by another process being [Supervisord](http://supervisord.org/) or [s6 overlay](https://github.com/just-containers/s6-overlay) for instance. One good example is [this image from Ric Harvey](https://gitlab.com/ric_harvey/nginx-php-fpm) It works really well, but I wanted to achieve a few other things like using the official images and its release cycle, logs belonging to their own processes, not mixed, I didn't like to rely on Supervisord since I had bad experiences in the past with it, and other things related to the ["Docker way"](https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/), I'm not saying it's perfect but I wanted some of those things. Now comes the php-fpm healthcheck part, while having in place a healthcheck which requested an url in the application asking if it was alive, it was indirectly testing the whole chain, Nginx -&gt; php-fpm -&gt; application , and now I had the chance to test still the whole chain via nginx but also monitor how busy and stable is php-fpm , if you [check its /status page](https://brandonwamboldt.ca/understanding-the-php-fpm-status-page-1603/) it has quite some useful information, so why not monitor on it? For instance you could make a container unhealthy after a certain amount of requests, or if the queue is too long and even slow requests, and that's what this script tries to achieve! Good news is that you can still do it even using the mixed container approach, but I wanted to take a time to explain why I came to do it like this now! The advantage in my opinion is that having separate containers you have a better grasp on where the problem is laying and you can restart only what's failing, not the whole, also avoiding Supervisord to restart it for you since you are already behind a container orchestration tool.
https://github.com/iota-php/client A PHP client for the IOTA cryptocurrency. Was abandoned for some time and could need some contributors (docs, tests, optimization) to get it in a release worthy state. Have fun!
Sorry but I strongly disagree. The `file_get_contents()` function is only one case among others. If you get a look to the library (maybe you haven't), you'll see that **most of the functions return** `FALSE` **without triggering any error** in which case you cannot handle the issue globally. There fore this lib allows you to detect possible errors, and have a clean error reporting. Take `base64_decode()` for instance, I'd better see that I must handle a potential Exception than getting unclear message triggered afterwards like 'expecting string a but a boolean was passed'. &amp;#x200B; Thank you [u/moufmouf](https://www.reddit.com/user/moufmouf) for your work. TMO this package is pushing in the right direction for cleaner code.
I think they meant that if Facebook dies, it's unlikely that HHVM/Hack development will continue
\&gt; Reading past the end of the file is not exceptional - it's normal, boring, mundane. I honestly don't know what this means. How do you read past the end of a file using \`file\_get\_contents\`? I've never ran into this failure mode, and I can't find any reference into the article. One common case where \`file\_get\_contents\` returns fail instead of throwing an exception it's when the file doesn't exist. And if trying to open a file that doesn't exist it's not exceptional to you... then I don't know what it is. \&gt; Changing the interface of a standard PHP function is just bloody stupid, to be honest - you're essentially breaking the PHP docs I'm not defending the library, I agree with you here. But that's not what your original comment was about.
Absolutely! Converting errors into exceptions is definitely the right thing to do. I'm actually talking about it in the blog article at the "Using strict error handling" chapter. And I most definitely think you should always use strict error handling, with all errors converted to exceptions and error_reporting=E_ALL. But I see 2 cases where "safe" is bringing an improvement: 1. There are situations where you are not in control of error handling. If you are writing a PHP library, you don't know what error handler your user is using. Also, most error handlers will be sensitive to the "error_reporting" setting. Hence, depending on the environment, your program may behave in different ways. On the other end, an exception is always thrown the same way. This brings predictability. 2. "safe" is really useful for advanced static analysis tools since the functions you are calling cannot return false in the eyes of the tool.
Surely you have already found some legit examples. Please kindly share them.
# [A PHP fpm heathcheck, writen as POSIX shell script](https://github.com/renatomefi/php-fpm-healthcheck) Previously at work we had Docker containers containing both php-fpm and Nginx processes, while they were managed by another process being [Supervisord](http://supervisord.org/) or [s6 overlay](https://github.com/just-containers/s6-overlay) for instance. One good example is [this image from Ric Harvey](https://gitlab.com/ric_harvey/nginx-php-fpm) It works really well, but I wanted to achieve a few other things like using the official images and its release cycle, logs belonging to their own processes, not mixed, I didn't like to rely on Supervisord since I had bad experiences in the past with it, and other things related to the ["Docker way"](https://docs.docker.com/v17.09/engine/userguide/eng-image/dockerfile_best-practices/), I'm not saying it's perfect but I wanted some of those things. Now comes the php-fpm healthcheck part, while having in place a healthcheck which requested an url in the application asking if it was alive, it was indirectly testing the whole chain, Nginx -&gt; php-fpm -&gt; application, and now I had the chance to test still the whole chain via nginx but also monitor how busy and stable is php-fpm, if you [check its /status page](https://brandonwamboldt.ca/understanding-the-php-fpm-status-page-1603/) it has quite some useful information, so why not monitor on it? For instance you could make a container unhealthy after a certain amount of requests, or if the queue is too long and even slow requests, and that's what this script tries to achieve! Good news is that you can still do it even using the mixed container approach, but I wanted to take a time to explain why I came to do it like this now! The advantage in my opinion is that having separate containers you have a better grasp on where the problem is laying and you can restart only what's failing, not the whole, also avoiding Supervisord to restart it for you since you are already behind a container orchestration tool.
Until you use a library that relies on looking for errors internally, then the exceptions blow it up. Had that with the MS Office file generator. What a mess *that* was to wade through to find that.
Go to 4chan and brag about how you site has "the latest hacker protection". If it's still up in 8 hours - you have passed the audit.
 Infowind Technologies is a leading PHP development company in India offers PHP website development, PHP application development services &amp; more entire the world.
mods, please report this account to be site wide banned
Have to looked at rachet? 
Shh I'm ranting and I'm on a roll.
Changelog: Core: * Fixed bug #[76754](https://bugs.php.net/bug.php?id=76754) (parent private constant in extends class memory leak). * Fixed bug #[72443](https://bugs.php.net/bug.php?id=72443) (Generate enabled extension). * Fixed bug #[75797](https://bugs.php.net/bug.php?id=75797] (Memory leak when using class_alias() in non-debug mode). Apache2: * Fixed bug #[76582](https://bugs.php.net/bug.php?id=76582) (Apache bucket brigade sometimes becomes invalid). Bz2: * Fixed arginfo for bzcompress. gettext: * Fixed bug #[76517](https://bugs.php.net/bug.php?id=76517) (incorrect restoring of LDFLAGS). iconv: * Fixed bug #[68180](https://bugs.php.net/bug.php?id=68180) (iconv_mime_decode can return extra characters in a header). * Fixed bug #[63839](https://bugs.php.net/bug.php?id=63839) (iconv_mime_decode_headers function is skipping headers). * Fixed bug #[60494](https://bugs.php.net/bug.php?id=60494) (iconv_mime_decode does ignore special characters). * Fixed bug #[55146](https://bugs.php.net/bug.php?id=55146) (iconv_mime_decode_headers() skips some headers). intl: * Fixed bug #[74484](https://bugs.php.net/bug.php?id=74484) (MessageFormatter::formatMessage memory corruption with 11+ named placeholders). libxml: * Fixed bug #[76777](https://bugs.php.net/bug.php?id=76777) ("public id" parameter of libxml_set_external_entity_loader callback undefined). mbstring: * Fixed bug #[76704](https://bugs.php.net/bug.php?id=76704) (mb_detect_order return value varies based on argument type). Opcache: * Fixed bug #[76747](https://bugs.php.net/bug.php?id=76747) (Opcache treats path containing "test.pharma.tld" as a phar file). OpenSSL: * Fixed bug #[76705](https://bugs.php.net/bug.php?id=76705) (unusable ssl =&gt; peer_fingerprint in stream_context_create()). phpdbg: * Fixed bug #[76595](https://bugs.php.net/bug.php?id=76595) (phpdbg man page contains outdated information). SPL: * Fixed bug #[68825](https://bugs.php.net/bug.php?id=68825) (Exception in DirectoryIterator::getLinkTarget()). * Fixed bug #[68175](https://bugs.php.net/bug.php?id=68175) (RegexIterator pregFlags are NULL instead of 0). Standard: * Fixed bug #[76778](https://bugs.php.net/bug.php?id=76778) (array_reduce leaks memory if callback throws exception). zlib: * Fixed bug #[65988](https://bugs.php.net/bug.php?id=65988) (Zlib version check fails when an include/zlib/ style dir is passed to the --with-zlib configure option). * Fixed bug #[76709](https://bugs.php.net/bug.php?id=76709) (Minimal required zlib library is 1.2.0.4).
Updates for this release: [https://github.com/php/php-src/blob/php-7.3.0RC1/NEWS](https://github.com/php/php-src/blob/php-7.3.0RC1/NEWS)
Pretty nice, and the PHPStan extension is a nice touch!
I highly recommend https://blackfire.io - it's going to give you in-depth performance optimization tips, and the usal things a profiler does. And it's available for Windows.
as usual
1. https://i.imgur.com/DK1ckG8.png 2. I doubt there is a software that compares the configuration *screens*
This is obviously not possible unless the backend provides an API for it. Think about it. Otherwise everybody could get their hands on the configuration of the server. That's bad m'kay.
The problem is that PHP primitive types are not objects and do not behave like objects. For instance, *"mystring" instanceof string* evaluates to true in programming languages in which primitive types are objects, but in PHP gives an error 'instanceof expects an object instance, constant given'. Also method calls on scalar types gives error 'call member function on non-object'. Scalar Objects cannot solve the first problem as it wont magically converts PHP scalars into objects, but it does at least solve the problem in my second example. Ideally primitive types are objects themselves, but realistically it wont happen in PHP or at least, wont be anytime soon. Scalar Objects are a workaround, not a perfect solution but it helps. OOP is about 2 things: 1. Everything is an Object, 2. The OO design approach. The latter can be achieved with PHP if you follow good OO design principles, the former cannot be done with PHP since there are many things that are not yet objects. You say you cant replace type with object, but what if type itself is an object? In a pure OO language like smalltalk and ruby, classes are objects themselves. In such languages, all variables are references to objects. You dont hear discussions on pass by value versus pass by reference, since such concepts do not exists and have no reason to exist. Scalar/Primitive types are basically immutable objects, and its not weird if you try to get out of your pass by value/reference mindset. I suggest you read this answer on stackoverflow and you will understand some things better: https://stackoverflow.com/questions/1872110/is-ruby-pass-by-reference-or-by-value
What do you mean by "configuration screens"? The php.ini files? The output of phpinfo() from the various servers? 
Correct
The problem with PHP built-in functions is that they are designed with procedural approach. In OO world, you throw exception, but returning false, 0 or null is exactly what procedural functions do. The best solution is to provide OO API for these old procedural functions. For the file_get_contents() example, you rewrite this way(taken from SplFileObject::fread method documentation page): $filename = "/usr/local/something.txt"; $file = new SplFileObject($filename, "r"); $content = $file-&gt;fread($file-&gt;getSize()); It throws RuntimeException if the file does not exist or cannot be opened. You may also extend SplFileObject class to add your own methods to it if you need functionality from php file functions that are missing from this class. 
No thank you. Im fine with what I have.
You think making the manual a liar is a *good* idea?
I bet it's configuration screens of CPanel or similar hosting control panel
I definitely agree! If there is an "OO" oriented alternative to using the procedural approach, it is a good idea to use the objects. But even with the objects, some methods are returning false instead of throwing exceptions... like [DateTime::createFromFormat](http://php.net/manual/en/datetime.createfromformat.php) The more I think about it, the more I wonder if what we really need is not a PHPStan or PHP-CS-Fixer extension that forbids using some "unsafe" PHP methods and that promotes instead proper OO alternatives. Meanwhile, a thin wrapper like "safe" has the advantage of the simplicity. No need to learn anything new for the developer, it works like the PHP core functions.
You have several moving parts. You have PHP, the web server per se, the database and other software you might be running. The configuration files are text only, a simple `diff` should give you the information you want. If you don't have access to the configuration files, you are going to need to talk with someone who can. Worst case scenario, the person will tell you what is configured. 
Neither `array_key_exists` nor `in_array` nor `array_search` return false in case of error. So they fall out of the scope of "safe". But you are right there are a number of undocumented use cases. I'm not sure I should handle those. What we do is that I'm type-hinting the arguments if I can. Like here: https://github.com/thecodingmachine/safe/blob/master/generated/array.php#L103 So a call to a function passing "null" where an array is expected (according to the documentation) would be caught by PHP. 
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [thecodingmachine/safe/.../**array.php#L103** (master → 416647d)](https://github.com/thecodingmachine/safe/blob/416647dd34155a6366e26946d9a53b4a92a9543f/generated/array.php#L103) ---- 
Actually, DateTime::createFromFormat() is not OO at all, it is procedural. Static methods may look like OOP, but in nature they are nothing more than namespaced functions. Now try to write a function createFromFormat() in the namespace DateTime, you'd call it with DateTime\createFromFormat(), and you notice this stunning similarity as using static methods. This approach puts a procedural programmer back to his comfort zone, he is effectively writing procedural code masquerading as objects. It does not surprise me at all that the static method DateTime::createFromFormat() is not following standard OO practices, since it is not really OOP at all. 
The flavor of the month here on reddit seems to be to bash on SOLID. I don't get it. Using SOLID as a guide for how I write code has always turned out to be a solid choice for me. :)
These are both great frameworks but neither are really appropriate to the OP's description of requirements.
So yeah, lately I redid some PHP which I haven't touched for years, forgetting that stmt-&gt;exec didn't throw !!! Just used the `X OR throw` pattern which is OK I guess.
Also Europe here. I think this is the software recommendation equivalent to "my girlfriend who lives in Canada/goes to another school".
Exception == not expected
Wow! Chrome is 7 versions ahead of Firefox? I don't know why people still use Firefox - it's clearly outdated!
&gt; You don't expect a file not to exist I do. Rule of thumb: if you can catch it and do something meaningful with it, it wasn't an Exception it was normal program flow. Out of memory? We are *so* fucked, can't recover from that. (From the responses and downvotes I'm getting, I'm getting a bit worried about the state of the average PHP programmer. If anyone wants a non-sarcastic take on the debate, google "Exceptions are Exceptional" and see what you get).
Woo! Sensible response! Have an upvote. And a hug.
It's been un-marked as private now. I think there was a delay between release announcement and someone un-marking it.
In general you are correct. Avoid using static methods when anything that manages state is involved. However ::createFromFormat() is nothing more than a factory method. It does not involve or manage state, but simply builds and returns a DateTime object. It‘s fine for factory methods to be static and return an instance of whatever the factory is meant to build. If you have a factory method that returns an instance of itself, it would make absolutely no sense to not make it static.
There is also https://tideways.com. 
Fair enough, if the scope of "safe" is set of functions which return FALSE on errors, and not a bigger set of functions which return something specific on errors (in case of those mentioned array functions, that "something" is NULL, not FALSE).
I have no idea. We need more information.
It would be nice to have a builtin `str_putcsv`, even if for no reason other than consistency with `str_getcsv`. That said, it's trivial to make to implement it, so there's not a huge need for it: https://3v4l.org/k9iCa
If we are talking about actual configuration for the application displayed in some kind of web UI then you could just use javascript in the dev console to give you a map of each one and then compare them. Of course the time it takes to figure out how to do that accurately might crazy compared to just writing it down on paper, or manually filling out a spreadsheet and then comparing.
I always thought that we have agreed on that exceptions are not the right solution to do error handling. Result Objects like in Rust or optional in C++.
&gt; “OO” oriented Object-oriented oriented 
[As long as you don't prefer assembly](https://en.wikipedia.org/wiki/Therac-25)
&gt; No thank you. Im fine with what I have. What? Why would anybody outside of you, use it? How would anybody know it works or trust? It could be full of bugs, that doesn't show itself until it's put in use. You have nothing to backup anything you say it does, beside you saying it. At least get some type of automated test setup.
&gt; Anyway it was never going to work because of PHP's over reliance on C extensions. HHVM used to have a [ext_zend_compat layer](https://github.com/facebook/hhvm/tree/1068af40ba2f15f678676ad8a5e946d35280be67/hphp/runtime/ext_zend_compat) so that custom C extensions would work with HHVM without much extra work - a Wikimedia developer helped write it and we used it for our PHP extension that allowed users to write templates in Lua instead of having to port that over to an HHVM extension.
Poor Wikipedia will need to migrate back to php7 runtime which still could be complex despite of language compatibility. 
The problem is that [CSV is not a standard](https://chriswarrick.com/blog/2017/04/07/csv-is-not-a-standard/). 
 declare(strict_types=1); json_decode(false); Done.
Admirable effort but some functions such as strpos() should behave as they already do IMO. Like if I want to check if a substring is contained by a string and it doesn't, I wouldn't want an exception thrown thank you very much.
In order to make a difference between functions that return false "on failure" and functions that return a boolean (like in_array, array_key_exists...), I parsed the PHP documentation for the term "return FALSE on failure". So it should behave correctly. For instance, `strpos` is out of scope of "safe". However, the lib is still in the very early stages of development, so there might be some false positive that slipped under the radar.
We have a model class that's 3000 lines long (getters and setters). With this change, we'd probably fit in 150
&gt; I have used file_put_contents() in a conditional statement that includes an else in case of failure. This is simple and straightforward. How would using exceptions improve on this This is simple, and if you think about putting all the functions that can return `false` in a conditional statement, this does the job. But it puts the burden on the developer to *think* about doing the error handling correctly. And it is very easy to forget doing the error handling. Also, it is kind of hard to do error handling in a state-of-the-art way anywhere in your code. For instance: ```php if (!mkdir('somedir))) { // Maybe I should return a proper 500 HTML page, instead of dying here. // But if this code is in a service layer, is it ok to print HTML here? die; } ``` Compare this to throwing an exception: ```php if (!mkdir('somedir))) { throw new MyException('Unable to create directory somedir'); } ``` The exception will halt the execution of the current function. It will jump to the "catch" statement if there is a catch statement. If there is no catch statement, it will return to the calling function. Is there a catch statement? Go to catch statement. No catch statement? Go to calling function... and so on. Assuming there is no try catch statement in your application, the exception is identical to a "die" (with the added benefit that you get a "stacktrace" telling you where the exception occurred). And if you want to explicitly handle the exception (maybe because you have a plan B in case an error happens), then you can "catch" the exception. So to put it in simple terms, when you application throws an exception, it will "die" unless you specifically decide to handle the error. Compare this to returning false. If a function returns false, your application will continue unless you tell it to die. I really prefer having a process that dies by default when an error occurs, than an application that hides the dust under the carpet. Most OO languages have exception support and it is very similar in PHP, Java, C# or C++. Other languages like Go or ElmJS have different approaches (like forcing you to handle the returned values of the functions) but these are not the approaches chosen for PHP.
I recommend blackfire for profiling out the data. If you need app monitoring as a whole - you may look into this list on : https://stackify.com/application-performance-management-tools/
What do you use in php for distributed / XA transactions? The mysqlnd\_ms-1.6.0 pecl plugin? I'm also aware of this port to php 7.x: [https://github.com/sergiotabanelli/mysqlnd\_ms](https://github.com/sergiotabanelli/mysqlnd_ms) but I'm not sure how stable it is - the documentation says not to use in production - but then what else is there?
This sort of sucks: &gt; Note &gt; The following extensions have to be disabled to use Swoole Coroutine: &gt; &gt; xdebug &gt; phptrace &gt; aop &gt; molten &gt; xhprof
I'm not sure about what would be possible and haven't looked into things in the package. But what yous said here: &gt; Laravel Echo Server will be changing ... to avoid running NodeJS. Is pretty much my dream. I really wish I could build a single app with Laravel that supports both traditional HTTP connections and Websockets!
return Obj|null - i don't understand the fear of mixed return types. In a dynamically typed language, a mixed type return is a half-step away from mapping to magical constants which is considered commonplace.
Under water here... please help. &amp;#x200B; I moved a site for a client who hired an SEO agency who hired a web dev to create a section of custom code the pulls in MLS real estate listings for the client. But after the migration, I'm getting errors like... &amp;#x200B; Warning: in\_array() expects parameter 2 to be array, boolean given in /srv/users/cd-staging-2/apps/lhspaces/public/wp-content/themes/lhspaces/parts/listing-box.php on line 2 &amp;#x200B; Warning: in\_array() expects parameter 2 to be array, boolean given in /srv/users/cd-staging-2/apps/lhspaces/public/wp-content/themes/lhspaces/single-listing.php on line 3 &amp;#x200B; I knew part of it was the BS plugins from WPengine, so I FTP'd into those (after backing up the site of course) and deleted anything WPengine related. But even still, other errors exist on pages and I'm trying to fix it. &amp;#x200B; My father is a web developer but doesn't know PHP, so he can't help me too much. &amp;#x200B; The lines in reference (line 2) is $favorited = in\_array( get\_the\_id(), get\_user\_meta( $current\_user-&gt;ID, 'favorites', true ) ); ?&gt; &amp;#x200B; Line 3 (different file) $favorited = in\_array( get\_the\_id(), get\_user\_meta( $current\_user-&gt;ID, 'favorites', true ) ); &amp;#x200B; So I know that there is some type of function error with either the ID or the Meta, but I don't know what it is and I don't know how to fix it. Can anyone provide me any pointers?
These are warnings, not errors. It's commendable that you are trying to fix crappy code, and you should keep trying, but your old server was probably configured to hide warnings. When developing, do: `error_reporting(E_ALL | E_STRICT); // Development` When hosting, do: `error_reporting(E_ALL ^ E_NOTICE ^ E_WARNING); // Hosting` More info: http://php.net/manual/en/function.error-reporting.php 
Does this hide warnings from the front end of the site? Would I put this at the top of the file or somewhere else?
Okay, that is also what I was assuming, but I couldn't find the function in any of the other files. I'll keep looking
get_user_meta can sometimes return false: https://codex.wordpress.org/Function_Reference/get_user_meta The developer that implemented this functionality Did It Wrong (tm) The code should look like: $favorited = false; $foo = get_user_meta('...'); if(is_array($foo)) { $favorited = in_array( get_the_id(), $foo ); } Though, as /u/wtf_is_codeigniter said, turning error reporting off is the right thing to do **on production servers**. Leaving error reporting on can lead to security issues, broken ajax requests, etc. Here's the right way to turn off error reporting in WordPress (again for production systems only): https://www.wpbeginner.com/wp-tutorials/how-to-turn-off-php-errors-in-wordpress/
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
Im fine. If someone does not trust it, then that is fine. &amp;#x200B; However though, if you look at my library build script, it does have automatic testing incorporated into it. Checkout this: &amp;#x200B; [https://github.com/ThreeLetters/SuperSQL/blob/master/builder.js](https://github.com/ThreeLetters/SuperSQL/blob/master/builder.js) &amp;#x200B; It will build the library and run some basic tests, and find performance as well. Although not a set complete tests that cover everything, I think it is effective enough. &amp;#x200B; Besides, I do not think lots of PHP libraries have auto testing anyway. Look at Medoo, for example which does the same thing. It does not have it and has lots of users. Such tools are probably best put to use for other things, such as client code (EG: with javascript) which has a large audience. &amp;#x200B; In addition, automatic testing with databases is a pain in the \*\*\*.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [ThreeLetters/SuperSQL/.../**builder.js** (master → 013a3b5)](https://github.com/ThreeLetters/SuperSQL/blob/013a3b59c4e30526fcecd5f729d363f50c1efd7b/builder.js) ---- 
This is exactly what went through my head when I read that tweet and figured out what it's about. The community is such a huge part of what makes frameworks valuable and recently I've felt a turn toward the fanboyish and that's just not a super attractive quality. And same here, I make literally all my money on Laravel apps and I really like the framework. I don't want to be in a position where I feel like I need to tell people that it's a great framework... just ignore the community.
Hey, you're right!
I’m not the OP but I just wanted to say thank you for taking the time to explain your methodology. Sometimes this subreddit can be so hostile it’s really refreshing to see a reply like yours. 
In comparison with Ratchet (and Aerys), this appears to infinite loop to accept new connections and messages. It is blocking, in that sense.
Don't see the code to compare with the callback version. 
&gt; what I need is that scalar types are first class objects like Python, Ruby and Javascript. What does that mean?
[https://github.com/adsr/phpspy](https://github.com/adsr/phpspy) &amp;#x200B; Zero-setup, low-overhead sampling profiler for PHP 7 (non-ZTS, 64-bit Linux only). Useful for finding perf bottlenecks, making flame graphs, general debugging.
No cargo cult code in this sub please. When developing do `error_reporting(E_ALL)`. When hosting do `error_reporting(E_ALL)`. 
/u/wtf_is_codeigniter said a complete rubbish. Will you guys ever learn to tell error reporting from displaying errors? A link you posted never says to turn off error reporting. Go figure.
It might not be the perfect way to handle errors, but if I have a choice I'd much rather have json_decode() throw an exception than silently return null.
&gt; This article begins with the assumption that throwing exceptions is better than returning false, but it doesn't explain why this should be so. It might not be a very good reason, but for me exceptions are better because there are a lot of cases where _false_ is actually a valid result and not an error. So there's no easy way to differentiate between the two.
&gt; Create .htaccess file in the public folder of your project or framework. WAT?! Come on, shut down this repository, it's a shame to display such a level of ignorance. 
The problem is that not EVERYTHING is an object because `null` is not an object in PHP. This fact detroys the (good) idea of "scalar objects". Even in Java and C# you can/must check a variable against null like this: Java ``` String foo = null; if (foo == null) { // is null } ``` C# ``` string foo = null; if (foo == null) { // is null } ``` Maybe just doing better `Exception handling` would be more transparent and doesn't require (not so pretty) language deformation.
That's indeed an awkward nginx setup. ;)
&gt;If you are using a library,..., consider using an adapter that just exposes (to your own code) only the bits that you really need, and treat the library as "bad" or "radioactive", keep it out of the way, hidden. imho, this entire tread can be summed up to this valid argument. The rest is just fluff and can safely be ignored. 
https://github.com/thecodingmachine/safe/
Oh, I see! But in your examples, you are passing an invalid argument (null instead of array). This can be caught if you use "strict types": https://3v4l.org/06OiE 
Reddit doesn't support Github-style code blocks. In other words, this: ``` int foo(int x) { return x; } ``` Turns into: ``` int foo(int x) { return x; } ``` And in case you're using a mobile app that does erroneously support Github-style markdown, the above is rendered identically to this on the actual website: `int foo(int x) { return x; }` Instead, in order to format a code block you have to add 4 spaces to the start of each line, like this: int foo(int x) { return x; }
While I look forwards to having typed properties in the language, I'd have been more enthusiastic about [introducing a ValueObject construct](https://www.entropywins.wtf/blog/2016/02/03/missing-in-php7-value-objects/). The main gain with typed fields is that instead of having a getter and a setter, you can just have a public field. Most of the time there is no reason to allow for mutation, so in well designed code you won't see this benefit often. At the same time people might start making fields public now, since they no longer need a getter to make the type clear, and in doing so introduce harmful mutability. Let's hope not.
Yes, you're right. Not needed then.
&gt; if they can make the code more readable and easier to follow/use/reuse, why not use them? Yeah, performance is a red herring. I think the Against argument can be summed up as "Exceptions are labelled gotos". They take the handling of the error far (sometimes very far) away from where the error was raised, and that's for your readability metrics. Now you're gonna say "well just don't use them that way", but that's the pro-goto argument of two generations before - sure, you can use gotos to write structured, well-laid-out code, but over time no codebase stays like that. Once you let them in, over time they leak all over your codebase and you don't know where the hell the error's going to get handled.
&gt; The problem is that PHP primitive types are not objects and do not behave like objects. This isn't a problem. Scalars is not objects. If you dig into phrase "everything is object" you may find that the whole point of this was "objects is only thing that matters" and "objects" in this interpretation is more like process with isolated memory rather that instance of class. &gt; evaluates to true in programming languages in which primitive types are objects In javascript for example you can't use `instanceof` to check some of the scalar types: 42 instanceof Number // false Number(42) instanceof Number // true And in fact in javascript scalars is not true objects. So problem that you are talking about is more about inconsistencies, because there should be no problems to use `instanceof` to check that some string is not insctance of some type. &gt; but in PHP gives an error 'instanceof expects an object instance, constant given' $foo = 'bar'; /** @var Foo|string $foo */ if ($foo instanceof Foo || "string" === gettype($foo)) { } No errors. So again, not sure what the problem is. &gt; Also method calls on scalar types gives error 'call member function on non-object'. So you want to see "call to undefined method". Ok. &gt; In a pure OO language like smalltalk In pure OO language like smalltalk there were two key differences: - Smalltalk had no main routine, which means that all "objects" acts like processes, decentralized system. - Control structures like `if` or `while` where messages, not syntax constructs.
&gt; but to me $foo instanceof string is much better than I just not understand why. I don't see difference between `'string' === gettype($foo)` and `$foo instanceof 'string'`. Even more, I see problem in intention to use this kind of checks (polymorphism and stuff, whole value concept). From semantics point of view, it can't be instance of, it's just value. It doesn't passed by reference (if it is, you must make everything immutable and change semantics of some of operators like `+=`). &gt; In Python, Ruby and Smalltalk they are objects So use Ruby or python. And please, do not compare Smalltalk to Python/Ruby/Java, because things that you talking about is not as important as other differences. &gt; but using global variables or public properties wont give you any errors either Don't know how you came up with global variables and public properties. Scalar objects doesn't affect coupling, usage of global variables introduces global coupling. And I don't see any problems with public properties (unless we are talking about DTO and you respect information hiding). But yes, it would be nice to have by-value structures in php. Right now we only have arrays which acts this way (and I ok with it if language will provide a way to describe structures, something like in Typescript for example) &gt; whats the point you are trying to make? My point is that you don't need scalar objects, because costs of this feature exceeds all of the benefits that you will have. Again, just try to think about all of the implications that it brings. From by ref/by value question to extensibility, when I just need to add new function which should work with strings. &gt; lol you dont need to teach me how smalltalk works under the hood, I know it very well and its not part of the discussion anyway. Lol so you just don't get the difference between classical structural programming and OO which PARC team was playing with in 70s.
&gt; In Python, Ruby and Smalltalk they are objects, and exactly what I want to see. So again, you just proof my point. You don't need scalar objects, you just familiar with this concept and this is the only reason why you want it in php. But this solution doesn't have anything about your problems.
would rephrase it as exception instead of null, the million dollar mistake :|
Well that’s what you get for relying on Facebook.
I like to use static methods for certain things. /u/deronlinebanker already mentioned factory functions. Another trick I like to do is to create a "closed enum" type of thing. E.g., final class HttpMethod { private $method; public static function get(): self { return new self('get'); } public static function post(): self { return new self('post'); } // ... etc public __toString { return $this-&gt;method; } private function __construct(string $method) { $this-&gt;method = $method; } } &amp;#x200B;
Thanks, forgot to update it from my project, made the correct changes.
lol damn, im not a real developer because I haven't read some bullshit whitepaper. 
I wonder what happens if you turn them on?
If that's what you think I said, then sure. The topic is why the rest of the programming community has such a low opinion of PHP. Not who is a decent developer or not. But if you want to turn that back on your own abilities, then go right ahead. 
&gt; people who I wouldn't deign to call junior developers k
some points: \- Your test names suck! \`test\_areaOfSquare\_WhenCalledWithLength6\_Return36\` be consistent with either underscores as separators or caps. \`--testdox\` will convert this into a readable checklist \- I haven't read the other articles but by part 3 I'd expect to read about mocking! Your style is very very verbose.
I think you should create a portfolio of your work. I have never really done freelance myself but I would imagine this is crucial if you are to advertise your standards and abilities. Many people claim they are excellent freelancers and it is usually a race to the bottom price wise but if you can prove you can create a quality, working product, that might give you the edge. Good luck
thanks men, I will give it a try
&gt;Assuming there is no try catch statement in your application, the exception is identical to a "die" (with the added benefit that you get a "stacktrace" telling you where the exception occurred). I understand the benefit of tracing where a function was called. With that in mind, I looked up how I could do this in PHP, and I included the line **error_log (json_encode(debug_backtrace()));** in a function. It then told me where the function had been called from, which led me to debug the script that was calling the function with unexpected data. &gt; So to put it in simple terms, when you application throws an exception, it will "die" unless you specifically decide to handle the error. Compare this to returning false. If a function returns false, your application will continue unless you tell it to die. So, if all core functions in PHP were modified to throw exceptions, there would be the danger of scripts suddenly stopping when they would have otherwise continued. While this might be desirable for some scripts, it could also cripple scripts that were otherwise functioning well-enough. Also, failure is sometimes to be expected, and I wouldn't want a function like strpos to end the script because the search string couldn't be found in the searched string. This leaves me wary of making the core PHP functions all act this way.
First of all, instanceof is an operator, its faster than gettype() as a function. Second, instanceof is much more elegant to use than gettype(). Third, with future introduction of Union types you can write *$foo instanceof string|Foo*, which is far better and more concise than your way of using || operator to treat string and Foo differently. The idea is that string will be a class just like Foo, so $foo can be an instance of string class, hence why instanceof works on string. Again you are talking about passing by value/reference, I already explained to you that in a pure OO language it doesnt matter. Did you even read the answers on stackoverflow link at all? If not, go back to read it again. Oh yeah, this 'go use another language' nonsense, I knew for sure that you would talk like that once you start to lose the argument. Why are we even trying to improve PHP as a language? Just use another language, problem solved, such funny logic. I used the global variable example simply because you said the current PHP way of handling primitive types wont give you error, and its a perfect counter-argument. All the bad or outdated language features wont give you errors if you use them correctly, does that mean you should be using them, and doesnt mean PHP shouldnt introduce newer and better alternatives. And my point is that scalar objects benefit exceeds the cost. First of all, you dont have to use it, you are free to write old-fashioned procedural code. Second, they make primitive types behave like objects, PHP will be moving one step closer to a better OO language. Moreover, they offer a nice opportunity to clean up the mess and inconsistency in PHP internal functions. You cant just replace these functions, instead by introducing a new way of handling primivite types they can be phased out. Legacy code will still work peacefully, and new code will be written in a much better style. I understand the performance penalty and other imperfections with the current scalar objects implementation, but these can all be improved on later. Its not like scalar objects will be going on voting phase anytime soon, the key is to bring it up to attention, so we can identify and fix the flaws it currently has. What is wrong with this? And you mention pipe operators again, for me its not useful since I dont write orphan functions, only instance methods. Though I am not like you, I will be gladly welcoming the arrival of pipe operator even if its not useful to me. lol you are making stupid assumptions again. Of course its a very different OO model, everything is an object, object communicates by sending messages using selectors, control/iterations are messages passed to boolean/number objects instead of language construct. But again, this is not part of the discussion. Id definitely love to see PHP adopting smalltalk's OO model, but that will be a different topic. 
E_STRICT became part of E_ALL in PHP 5.4.0. You must explicitly set the error reporting level to include E_STRICT in order to see these messages in versions prior. No one should be using anything below PHP 7 now-a-days but we're trying to help someone with their WordPress code, up until recently, proudly compatible with PHP 5.2.4. Good times.
To let you know, your changes are far from being correct. You apparently don't understand what all these commands do. it is not that bad by itself, we all learn every day, but it means that you should refrain from writing instructions for a while
Thanks for the reply. \- all underscore seems more unreadable for me. I care about the method itself being readable since I work with the code much more than any other display format \- this is a beginner series, I want it to be easy to grasp, without throwing in too much new stuff in a single episode. Mocks are coming on the next one :)
Both of you: * Use * Reddit * Markdown :P
That's a fairly standard naming convention for tests and has been for a long time. https://dzone.com/articles/7-popular-unit-test-naming
Consistency is generally considered more readable. Ideally, your tests are written in the same style that you're using in your project. Laravel, and PSR, dictate that camelcase should be used.
There's a doctrine command you can use to generate entity metadata files from an existing database. It's lossy and unsupported, and you'll probably have to tweak things, but it's there: https://symfony.com/doc/current/doctrine/reverse_engineering.html https://gist.github.com/tawfekov/4079388 My suggestion would be: - Generate a Doctrine entity set, clean it up + start using it. - Do not allow people to commit new code that uses Propel. - If you need to make a DB change, you'll have to go through and remove any Propel query/object instances for those tables **at that point**. - Slowly wean yourself off of Propel. This assumes you have an anemic domain model and don't have a ton of business logic in your Propel classes. If you do, the story gets more complicated. &gt; Maybe there is a way to create an "abstraction layer of an abstraction layer" and abstract Propel to Doctrine, or the other way around. I imagine you'd get 90-95% with this and then discover a major reason that it can't work + hate yourself.
I am not sara and I can’t speak for her, but I may have some insights from I heard in an earlier comment she made regarding the choice of PHP’s short closure syntax. Sara objected to the idea of using *==&gt;* as the symbol for PHP short closures, since it was used by Hacklang already. It seems that Sara does not want PHP to use the same syntax as Hacklang for some unknown reasons. So my speculation here is that she doesn’t like the syntax chosen for declaring typed properties in PHP, since it seems to be the same as Hacklang’s.
If you're switching, you may wish to consider [Atlas](http://atlasphp.io) (if you have not done so already). Generating the basic persistence classes from the existing tables is straightforward, though you will need to add relationships manually.
I'm having module rewrite issues with the .htaccess files with Nginx, but other than that the code seems to work fine for running a localhost on a LEMP stack with PHP 7.2 on Ubuntu 18.04. There are a lot of bugs with the LAMP server on Ubuntu 16.04 and up from what I see. Just putting it out there to try to help others at least get to development, you can create a pull request and make it better if you like as well. It's my understanding that's what the open source community is for. I put it out there, I got criticism, but it clearly states it's not finished code. 
Would you mind expanding on this a bit? How do they share the same connection?
I need this bad!
A function where you pass an array of arrays of fields and it would: 1. escape any double quotes inside field values 2. double-quote all field values including empty ones 3. encode the whole thing as UTF8 4. save it That would bring you pretty far. The only thing remaining then is how to handle decimal values, but the main problem of CSVs disappears when you treat all CSV fields as text. Then there is no risk of having a file being read as 2 columns on one system and 4 columns on another.
A poor Dunning-Kruger effect's victim...
Here is a link for OP: https://www.nginx.com/resources/wiki/start/topics/examples/likeapache-htaccess/
Same underlying PDO connection.
&gt; Dunning-Kruger effect' So I see, I see you make snide comments on everyone's posts, yet post no real code of your own. Nobody on this end thinks they know anything. I'm like the other dumbasses out there learning and searching through dozens of websites for information. Not to mention it's the basic example.com server setup given in the documentation for Nginx, updated config files to use PHP-FPM7.2 instead of PHP-FPM5.0, applied a widely voted on consensus with the www-data command on stackexchange. I know very little to be honest, all I know is that everything on that list is what I had to do to get the development environment working for me on my setup. If you've got better information, put your Github link up or help with the project. All you do is troll noobies to PHP, why don't you put some of your code up and show us how it's done.
 You nailed it. C# is designed very clean. Its like night and day compared to PHP. Been eyeing for F# too lately. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
If you only used the primitives, type casting would be a non-issue.
Except in cases like these.... `$dateObj = DateTime::createFromFormat('U', strval(strtotime($unknownDateString)));`
Can you link this? I not finding this 42-0 vote.
I have been working on this for strings: [https://twine.phlak.net](https://twine.phlak.net/)
Just like you cannot walk through a door that isn't open, you can't embrace something with your arms crossed :p
For just sending mails, this looks good. You use TLS and SMTPAuth, everything on your end is properly authenticated and secured. Sending HTML and text body is also a good practice. The other things you mentioned, server side validation for mails and error handling don't have anything to do with this and shouldn't be coupled to it. In a professional setting, depending on the amount of mails this will send, some kind of queue or asynchronous service should probably be used, as in this state it will wait for the mail to be sent via smarthost (worst case: dns, tcp connection, ssl handshake, smtp auth, smtp content, cleanup) and could probably just wait for some seconds.
I'm not sure how modern PHPmailer works, but it has a long history of being old and bad and popular because it's in wordpress. A look at packagist shows 7m downloads for phpmailer and 86m for swiftmailer, despite phpmailer being older. Swiftmailer seems to be the de-facto library for modern code. Now that that's out of the way: You have hardcoded recipients and messages. You'll need to take them from user input eventually, and the user input will need to be validated and/or sanitized. You'll also want a system to IP block automatically if they send too many emails, or your server will turn into a spam sender overnight. Once you've gotten your fundamental security stuff down, all of this code should be moved to a function, preferably a controller. You *really* don't want to be running a big long file, or includes with side effects like sending mail.
Personally, I don't like the creation of stuff outside the vendor folder. I just use a local path to pull in the package in the composer.json file during development. If I'm done developing the package and it's on packagist, it's just a matter of removing that local path and running composer update.
Anyone know how he prevents updating a resource that has since been updated by someone else? I assume he passes the `created_at` property that was fetched with the resource (on the index/show page) *back* to the update method and checks that it isn't less than the current DateTime?
I'm a huge fan of coroutines, but I'm not a fan of this. Real coroutines are amazing - the whole `async`/`await` syntax in ecma isn't really as necessary as many think, since you can easily wrap a coroutine method around a generator instead. Say you have a coroutine method defined as `P::co`, you can easily wrap a function to make it read top-down but non blocking. P::co(function (): Generator { $a = syncMethod(); $b = yield asyncMethod(); [$c, $d] = yield P::all(multiple(), promisesInParallel()); return $a + $b + $c + $d; }); This article seems like some very vendor specific syntax that I wouldn't want to see put into a standard. 
Awesome! Glad that it is helpful. I will bring out next one soon enough. If you have any questions, please feel free to ask :)
Hm
Thank you.
It's 60-1 now, Sara voted against (someone had to -1, right?). Poll is at the end of the page https://wiki.php.net/rfc/typed_properties_v2
&gt; I am an OO purist There's not practical benefits to be OO purist. I understand, if someone sad that he is all about pure functions, immutability, type checking and isolation of side effects. That he studied church-turing thesis, that he understand concepts of timeless programming and so on. I don't really know, but from what you told I can make assumptions that you really don't understand what OO is about. Or at least what was initial intentions. Again, if to you OO is about instances of classes - then OK, but this is just useless concept. It doesn't add anything on top of good old structural design.
&gt; Why are we even trying to improve PHP as a language? You ignored my question for second time: - Will your scalar objects be passed by value? with copy-on-write semantics. Or will it be just immutable? Then what will you do with operators like `+=`. - What if I need to add additional function to work with strings. I can't just extend from `String` and I also don't want to "patch" string type (again, this will be inconsistent with other types).
Solid advice right here. For the popularity, phpmailer was a single file library that you just (grossly) include(). This kind of sites don't use composer, hence the low usage numbers. For new sites, I recommend Swiftmailer. It's more intuitive to use and handles errors nicely. 
 $mail-&gt;Password = 'secret'; is a little insecure because, if someone were to get hold of your PHP code they could see the password. Not necessarily a major issue here, but it can be. Especially for database passwords. Put the passwords in a separate PHP file ($password="secret" etc etc etc) , and put that file in a directory that's above wwwroot/html-docs in the tree. It will therefore not be web-accessible. In your code, include() the file, use the password to make the connection to the database or whatever, then unset it when you no longer need it. If someone does a dump\_defined\_vars() they won't be able to see it. &amp;#x200B;
Hey, thank you for your reply. I'm sad because the function is done in your dead virtual machine.
There are multiple possible solutions similar to EAV, and they all will depend on development style, degree of setup and maintenance, and what your application actually requires. Document stores like MongoDB that don’t have a set structure are options. Similarly, key/value stores can have a fit also. Relational databases now have a native JSON column type, which can suffice for basic app requirements. EAV itself in a relational database is always an option, also. There just aren’t many out of the box systems that make it easy to work with.
You are absolutly right in "application-specific" characteristic. I imagine it this way: There is tiny database with predefined common data (user, countries, languages...) For the test "tiny database" always exists and has actual state (I mean migrations). Each test case should apply fixtures, run test. After what, I suppose, fixtures should be removed (with data generated during test). Do I think the right way and how can the last problems be solved? &amp;#x200B; &amp;#x200B; &amp;#x200B;
TDD destroyed every promising project. Don't do it. Unit test is helpful, though.
You could export your prepared state in an SQL file, complete with DROP TABLE etc, and run the script prior to each task.
Hell, just go to /new on this subreddit and 60% of the first 30 posts will be people posting their own “how to do x in PHP” blogspam. Of course, none of these people actually have a fucking clue how to write modern or secure PHP, but Dunning-Kruger abides 
I search solutions for fast drop changes in database between test cases run
Yeah planning ahead on how to structure your code and writing the expectations before you start coding is obviously a bad idea... /s
I tried it and 2 days later... it's in production :) My codebase is not a small one: I had 200 functions in my code like that and I was too lazy to change it manually. So I prepared this Rector + style set to do this for me: https://github.com/Symplify/Symplify/pull/1102/files#diff-e092eaafdc2fd4e0ef6aebcafdeddb21 For anyone who don't want to do this manually :)
Start a transaction before the test, rollback after.
Agreed
There is. In a perfect script/program, everything is an object. You cant be perfect, but you can get as close as you can. This is why I support the idea of scalar objects despite the fact that, the primitive types are still not truly objects. It does at least make the primitive types behave like objects, as you are calling methods on the primitive types. In a short run, PHP cannot rewrite zend engine to make its primitive types into objects like Python and Ruby. But in a long run its actually possible, and scalar objects will ensure a smooth transition as when it does happen, your 2-&gt;abs() and "my string"-&gt;toUpper() methods will have been working for a while. The intention is that developers will start to write their code with OO syntax for primitive types, the old procedural syntax will remain available but will be gradually phased out, leaving only old legacy code written with it. You keep making stupid assumptions again and again, impressive. I understand what OO is about, I read Alan Kay's idea and the smalltalk's OO Model is the pure OO way. Instances of classes are part of OO, but not the entirety about OO. Think I dont want to see message passing in PHP? I am a purist but also pragmatist, I cant count on PHP to implement Alan Kay's OO Model completely. However, making primitive types(and in future functions and classes) into objects will be an acceptable compromise to make. The old structural design is bad because it was designed with procedural mindset, hence why they ended up with non-object primitive types, arrays, and heck even resources. All these must eventually become objects, at least thats the ultimate goal in a long run. 
I did not answer your first question since you are talking about pass by value/reference in a traditional way that a C++ programmer talks about this concept. In this mindset, non-object types are passed by value, objects are passed by reference, which raises a question of how scalar objects should be passed by value or reference. But in a better OO language, this problem wont ever exist. For instance, in ruby everything is an object, and every variable points to the reference of an object. Ruby is passed by value, but all values are references. Read the stackoverflow page to understand this concept better if it is not clear enough for you. And $a +=1 is just a shortcut for $a = $a + 1, what is your problem with it? https://stackoverflow.com/questions/22827566/ruby-parameters-by-reference-or-by-value/22827949#22827949 For your second question, of course you wont extend String Class. With Nikita Popov's Scalar Objects idea, it will be possible to improve the system into C#'s extension methods like feature. If the primitive types are real objects, you can patch it the Ruby Way. If you really dont like the 'patching' way, just create a decorator class that wraps string and do what you want with it. I dont understand what is your beef with 'patching' string anyway, it has been done in other languages. https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods https://stackoverflow.com/questions/7490680/in-rails-how-to-add-a-new-method-to-string-class
Ironically PHP had value objects in the past. PHP 4 classes had value object semantics... But yeah, I fully agree - I'd love to see them in PHP. My main concern though is being able to distinguish them well enough when reading code. You don't want to be surprised at the result. Type declarations of functions and properties need to highlight the difference between a value object type and a "real" object type. I.e. there are quite some considerations to have and finding the best solutions to them. It's sadly not that straightforward as one might think...
EAV was never a good model. Use a graph database, document store or "nosql" database instead.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I found this cronjob 09,39 \* \* \* \* root \[ -x /usr/lib/php5/maxlifetime \] &amp;&amp; \[ -x /usr/lib/php5/sessionclean \] &amp;&amp; \[ -d /var/lib/php5 \] &amp;&amp; /usr/lib/php5/sessionclean /var/lib/php5 $(/usr/lib/php5/maxlifetime) Would someone please explain the -d and the last part? I can see that the -x option is for executing a script. And at the end, it is passing the value in maxlifetime as parameter. but still can't understand what are the -d options and the paths with no flag such as &amp;&amp; /usr/lib/php5/sessionclean
Not that I don't support TDD (I do, it's a good methodology), but in recent projects of mine what I've been doing was what I called "Doc Driven Development" - Which means, write the full documentation, including both the explanation of what it does, what each argument means and does, what it returns, and anything else; Then, implement it accordingly. So far, it hasn't failed me, and is quite a bit faster than TDD. It would probably fail if you don't plan your functions/classes to be modular enough to begin with, but that's something you should do in the first place.
EAV is total shit, it was barely a reasonable choice 10 years ago. Document stores or jsonb data fields are a much better choice. 
&gt; what is your problem with it? The problem is that it has different semantics if all of your variables now contains references. &gt; C#'s extension methods like feature This would require significant changes in type system. &gt; I dont understand what is your beef with 'patching' string anyway You have two modules, one adds method to all strings, and another one wants to add same method with different implementation. Your language should resolve all uncertainties on this point (or you ended up with problems like in Ruby). So again, scalar objects (done right) looks to me as extremely complicated feature which easily brings more inconsistencies and additional complexity into language without clear benefits. If you know how such feature would work to stay consistent, without additional complexity and without huge breaking changes in OO model - I would love to read RFC or at least draft of it.
I would not argue for *always* using TDD. A well written Test is among the best documentation you can have though. And it is always up to date, or it will notify you by failing.
Please use JSON or equivalent types on engines that support it (Postgres being the flagship here) instead.
Oh, I first read it as "..but always [use TDD] when writing tests", to which I'd actually agree in 95% of the cases. When you're gonna write the tests anyway, might as well write them first unless this specific function/module/whatever is very time sensitive and need to be complete ASAP. What I don't agree on is always writing tests. In many cases (recently, in all of them) I'd write a "test mode" for each function (you can call it mock/virtual mode, where it runs but doesn't modify the state of any data, but rather returns what it *would* have modified), then instead of writing tests for it just quickly test it manually (in some file called "test.cpp" or "test.php") to make sure it works correctly in a few corner cases. Obviously those tests wont be saved. It saves a lot of time, but you might wonder - wont I be paying that time back every time I have to rewrite tests for those functions? This is where the modular design I talked about in the previous comment comes in. If the system is properly designed from the start, each ~~function~~ method usually does a... specific function for a class. If that class needs other functionality, you add more methods. If it needs functionality that is very similar to an existing function, sure, you need to modify it and test the new corner cases again - but in this case, you'd need to write new tests for those new cases anyway. And if the system is designed properly, such "expansions" of methods should only happen once or twice at most per method, and usually zero times, so overall the time you save is far greater than the time you'd otherwise wasted writing full fledged tests for them. This post somehow got a bit long, so I'll just sum it with that TDD, IMO, is actually the way to go when writing tests - but writing (automated) tests is not always the way to go if you value your development time.
Can someone educate me and give me a real world example of what this thread is about?
You can't do this if the application itself uses transactions. Transactions cannot be nested.
Entity Attribute Value (EAV) is a relational data storage technique for handling arbitrary field / attribute storage on entities without (in theory) requiring schema changes, most notably used by Magento commerce. In practice the entities grow to such complexity that they can no longer be hydrated in anything close to a performant manner, so Magento uses the EAV structure to build traditional flat database schema dynamically that it can actually query in real time (among other fairly shoddy band aids). Basically EAV doesn't actually work right in practice at any sort of scale. 
 * delete propel stuff * write new stuff with doctrine * vomit all day long * delete doctrine stuff * write stuff with pdo * done
I only have had experienced on EAV and it was with Magento , so not a good experience. Having worked with JSON on PostgreSQL was miles away
What makes you say that? Which projects? And what were the downsides? We can't have a discussion with just "TDD destroyed my project". I'm guessing you are in the DHH camp, check out the "Is TDD dead?" series. [https://martinfowler.com/articles/is-tdd-dead/](https://martinfowler.com/articles/is-tdd-dead/)
Magento.
"Doesn't work right at any scale" !== "I haven't seen it work right at any scale" Just because there are no good examples doesn't mean it can't be done.
As others have said, EAV is a way to add attributes to objects, representing the DB schema like this: http://www.divisionlab.com/solvingmagento/wp-content/uploads/2013/01/attribute_options_table_relationships.png It's used by many products where a) data model needs to be very flexible and allow new attributes without schema changes, or b) a typical entity has a large number of possible attributes that may or may not be set for all entities ("sparse" attributes). WordPress uses this to store post metadata, Magento uses this to store product attributes and most of other data, Drupal uses a variation of this to store all the posts and other content you create, etc. It's pretty nasty to work with, especially with Magento.
If you want to "unit test" the database, to me that means you want to test the functionality of individual queries. Not queries in the context of your application logic. For each query (or set of queries) you want to make sure that you start your test in a known state. If this means resetting the schema, so be it. Just make sure you don't end up in a random state. Database testing is slow. Don't make it part of your day to day development flow, i.e. that when you run tests in dev that you don't always run the database tests, just your business logic. In the end, your database tests are integration tests, run them as part of pushing to stage. 
\_/ &lt;- cry here, africa needs water and node js still pays better 😂
Unit test is for test your actual code. If you want to test if your code works using doctrine or the DB that's integration tests. &amp;#x200B;
What about [this](http://php.net/manual/ru/pdo.begintransaction.php#116669)? Doesn't this script support nested transactions? Though it is innoDB-specific.
This is huge! I was wondering how to automate the process of switching to safe functions. I had heard about Rector but never spent time to learn it. Wow! I'm already auto-generating the Safe functions. Maybe I could try to generate the "Rector" file too? (with the complete list of all functions replaced...)
I love mocks, it still blows my mind today when people have unit tests that require a db connection or access to S3, get those over to your e2e please! Mocks make life so much easier. I am not a huge fan of TDD because half the time I'm fixing legacy and I don't even know how the legacy works to even begin thinking how I would plan my implementation. A lot of times I need to do concepts just to see what is possible in "X Legacy System". But for all barebone, self-contained new code I always go TDD. It means i don't have to care about a lot of stuff, like a MySQL response :P
Mainly, yes. I stumbled across the EAV model using Magento, and the first few days I was like "Woah! This is great", then the next 4 months I wanted to quit, move out to the countryside and become a farmer.
i second swiftmailer especially as it has transports for some popular SMTP Providers like Sendgrid or mailgun
Basically, yes
&gt; sort of Why not write, *makes it completely unusable?*
async/await is far more elegant. PHP needs it, too.
If you ever have to make serious changes in a code base that is tested using mocks you will learn to hate them. Nothing wrong with integration tests. If you absolutely need to switch out some component for a test, put an interface in front of it and write a stub implementation.
Yeah, it looks like that would work.
And EAV makes for some truly terrible code and abstraction. Getting the data you want, even hydrating/seeding data you want, or doing migrations is a fucking dumpster fire.
JSON columns. The peformance issues where fixed so there's no reason for EAV anymore \- postgresql has efficient indexing on JSON properties [http://coussej.github.io/2016/01/14/Replacing-EAV-with-JSONB-in-PostgreSQL/](http://coussej.github.io/2016/01/14/Replacing-EAV-with-JSONB-in-PostgreSQL/) \- mysql has the ability to create virtual columns generated from JSON properties and index them [https://mysqlserverteam.com/indexing-json-documents-via-virtual-columns/](https://mysqlserverteam.com/indexing-json-documents-via-virtual-columns/)
I also do not like the db connections or any external dependencies for unit tests. Testing the domain logic itself and nothing else is a great thing to have. But more often than not, people merge unit and integration together, making it way harder to maintain it in the long run. Indeed, TDD is only good for new code. For old ones, there's no choice but to write tests one by one and then maintain them. 
[removed]
You can always mock the interfaces too, if you need them so. Having said that, you're correct in a way. I also do not write unit tests for classes that interact with external dependencies. I instead do integration tests on my Repositories( for connection to db) and Adapters (for connection to external APIs). I mostly do not use interfaces for internal dependencies, unless there's a good reason for it. For those kind of classes with just internal dependencies, I'd rather do unit tests with mocks. But if you're constantly changing the implementation, an interface is absolutely necessary. And also integration tests instead of unit for those classes.
If it's my own code I'd much rather use interfaces and DI rather than mocks. You create simple, side-effects free implementations of the required interfaces and suddenly your whole code becomes more robust and you don't have to rely on any mocking library.
Exactly we use a pdo connection provider service which is used for both ORMs
I work with PHP professionals for many years and the change is slow but steady. Debugging and profiling uses to be cumbersome, but I don’t believe it is now. Today, having a clean setup, setting up xdebug is as simple as pressing one button in a browser (to set the cookie automatically) and enabling debugging in PHPStorm. How can it be simpler really? Rewriting xdebug, which is mature and works well, is IMHO pointless.
Slack moved from JSON data storage to EAV. [https://slack.engineering/re-architecting-slacks-workspace-preferences-how-to-move-to-an-eav-model-to-support-scalability-d480a7c5c655](https://slack.engineering/re-architecting-slacks-workspace-preferences-how-to-move-to-an-eav-model-to-support-scalability-d480a7c5c655) So there's still some kind of issue with that particular storage mechanism.
Agree. Remote debugging with xdebug is a solved problem. 
In my experience Vagrant and Docker have made it much more difficult than before, which is too bad. I wish we could make that simpler.
I’m in the same situation as you and have the same thoughts. 
They aren't evil but they definitely have downsides. The main issues is that you can't easily replace them and, in a similar vein, you can't mock them in tests. If you use dependency injection then you can, if you wish, replace a dependency with another - as long as it extends the original / implements the same interface. Similarly within a unit test you can replace a dependency with a mock. You can't do these things (easily) with static method calls.
Static methods are basically just global functions with a state "bucket" available as static properties. Class instantiation is never (realistically) a bottleneck in an application. 
It’s all about the tools. Sure, manual configuration if you don’t know the architecture, is hard but there are tools for this. If I want to debug with vagrant or xdebug I just click one button in my IDE.
It’s actually not hard at all. I’ve setup countless Vagrant VMs and Docker containers with support for remote xdebug, including debugging CLI scripts. Once you know what to do it only takes a couple of minutes.
&gt; A static method call doesn’t need to have its class instantiated and therefore runs faster. Any performance gain here is at the micro-optimization level. This is not a good reason to prefer using static methods when better patterns are available to you. I would define static methods as a "code smell". They're not always bad, but they frequently indicate bad architecture (and often a lack of understanding of the "message passing" concepts that are the core of OOP). Related reading: * Clean Code (Robert Martin) - G18 (p. 296) Inappropriate use of static * https://martinfowler.com/bliki/StaticSubstitution.html * http://verraes.net/2014/06/when-to-use-static-methods-in-php/ * https://stackoverflow.com/questions/4002201/why-arent-static-methods-considered-good-oo-practice * https://nikic.github.io/2011/12/27/Dont-be-STUPID-GRASP-SOLID.html
There's no performance benefit. Static methods are just namespaced global functions. Use them when you know you won't need to mock something.
Static methods are not evil if if the method is "deterministic". Deterministic means it returns the same value every time it is called with the same arguments. &amp;#x200B; For example: strtolower('string') will always return the same value. Therefore, it is perfectly fine for it to be a static method as it's output is entirely predictable and simple to account for during testing.
Sounds about right.
In times of flexibility with docker and standardization across languages - is this still an important debate? In general though: try not to stick to only with one language throughout your career...
He doesn't know. He just expects """the future of PHP""" to magically make things better somehow.
As many developers have pointed out, static methods are just namespaced global functions in disguise. The presence of static methods however, usually is an indication inappropriate class design or an incorrect understanding of OOP. In my application I do not use static methods at all, every method is instance method. I dont see a need to use them, though some may argue that its okay to define static factory methods instead of writing specialized factory classes. But anyway, other than the debatable use case for static factories, there should be no other reason to use static methods. Stay away from them and finding a different approach to solve your problem, will lead to a better class design, and of course easier unit testing and other benefits. 
I kind of hinted at my issue in the thread regarding the tedious process for setting cookies in a browser. That's probably the biggest one. Thanks for the hyperbolic response though, I don't sit on reddit 24/7 trying to prepare to respond lol. I kind of wanted the thread to blossom into a discussion amongst the subreddit and see if others had opinions on the matter like Idk, bundling xdebug or something with an official release so we can just enable or disable it from config. This discussion can go anywhere if you truly want it to 😌
Oh the same 'node.js will kill PHP' crap again, seems that every now and then we see such a question/post and it never fails to amuse me how misinformed developers fall for such nonsense. 
I expect event driven alternatives will become more and more stable for production and thus a viable contender to NodeJS. Not exactly in the same playfield but if you've enough business logic to make it worthwhile and reactphp/swoole/etc. are good enough then it's there. 
They don’t use composer, I am working with them to setup a gitlab repository, start using composer, namespacing, githooks with phpunit/phpcodesniffer. They are mainly using the static method on DAO classes. Which, correct if I am wrong, is probably the worst use case for it. Especially since they have multiple clients using the application sharing a single database. I am not really sure how to break this to them, they agreed with everything I had to contribute but the static methods they seemed very passionate about.
I've set it up a few times. And each time is a bit of a struggle.
Do you have a blog post or something on it? &amp;#x200B;
I almost exclusively use static methods as a way to autoload pure functions. If PHP added support for proper function autoloading, I could eliminate most of the static methods in my code.
Why do you consider it tedious to set a cookie in the browser? Every major browser has a one-click addon for it.
Btw, Sara stated that she’s only doing that to troll and will vote yes after some time has to passed.
What do you think about overusing mocks? &lt;a href="jttps://www.tomasvotruba.cz/blog/2018/08/30/ways-i-fucked-up-open-source-code-mock-everything-and-test-units/"&gt;Ways I Fucked Up Open Source Code: Mock Everything and Test Units&lt;/a&gt;
I've been doing Magento arch / dev projects (off and on) for almost 10 years (since v1.2). Sometimes I like to think of myself like Sgt. Elias, fighting the good fight in a meaningless war to save my own soul. [Realistically though...](https://www.youtube.com/watch?v=RbbIrIGpyf0)
I do think Node is the new PHP but perhaps not in the way that its advocates think. Back in the day if someone said they were a full-stack programmer and listed "HTML, CSS, Js, Java..." you'd think "ok then", but if someone said "HTML, CSS, Js, PHP..." you'd have this little bit of scepticism, "are you really trained and experienced at 'proper' back-end development, or are you more of 'webmaster' who's reached into PHP for the odd `&lt;? include(menu.html) ?&gt;` or `copyright &lt;?= $year ?&gt;` shortcut?" (If that sounds super snobby, bear in mind I was totally in that category myself) These days I get the same vibe with Node, its a kind of ubiquitous presence on resumes that leaves me unsure if this person has actually devoted any real thought to back-end coding &amp; architecture or is just vaguely capable of `npm install`ing enough scaffolding to support their basically-does-everything-in-front-end-js SPA. Basically I see a pyramid shaped pool of labour with a disproportionately broad base of well-I-sorta-know-it-enough-to-claim-I-know-it candidates. Much like the PHP universe had/has an oversupply well-I-can-make-wordpress-themes candidates. Speaking of wordpress, how anybody can believe PHP is in danger of death, as long as wordpress runs a ridiculous percentage of the web, is completely beyond me. It's not even about wordpress being technically good or bad (no prizes for my opinion), in fact it's a prime example of how a vast chunk of the time, the choice of language/platform has nothing to do with technical aspects at all. When it comes to that decision, whether PHP or Node (or $platform...) is slightly faster or has generics or whatever, are specks of dust compared to the weight of "does it fit on top of / alongside everything else we've already got", "can we find affordable support for it", "will we still be able to in 10 years time". Anyway, Wordpress alone kinda sells this point imo, but add in Drupal, phpBB/vBB, MediaWiki and Moodle if you like, the combined userbase inertia is absolutely enormous, how on earth do people think the entire section of the economy build aruond these type of CMS and CRM products will just vanish or rapidly all migrate is quite beyond me. If you mean for custom enterprise development then sure PHP faces plenty of competition and changes in fashion these days but then the same is true for Node. It will actually be interesting imo to see whether Node maintains its current mindshare/marketshare over years/decades without equivalent juggernaut products like Wordpress as 'anchor tenants' (to borrow a retail metaphor).
In VScode you can tell it to listen to a specific port and IP. In your remote simply set up xcode, enable debugging, and make sure the port is open. Should work just fine.
Static methods are bad if you're using them as a way to get around the lack of proper handling function autoloading. If you shove a bunch of static functions into a \`Util\` class then you're not doing OOP, you're using that class because class autoloading just works. &amp;#x200B; As with all things, static functions have their place in code, if you use them in a meaningful way. I disagree with certain linters (I think it's PHP CodeSniffer) which by default will scream at you if you use a static function. Named constructors are perfectly fine, for instance. &amp;#x200B; The performance argument is bullshit, by the way. Static functions used to perform marginally better in the past, but even if this is still the case (which I'm not sure), realistically that is never cause for concerns. It's one of those micro-optimizations (like using single vs double quotes) which won't ever make your application truly faster in real world usage.
Yeah this is basically what I'm saying too; if it doesn't use the class state or mutate class static vars or something, it might be ok 
"pure" function &gt; "deterministic" function for terminology I think
Hmm when you say on the dao layer are they doing something like eloquent/illuminate/laravel's `Entity::all()` syntax? I know that's just a shortcut for an oop method so it might not be too bad. As for breaking it to them, simply standing up a test suite should quickly show how untestable it is. Maybe that'd convince them
A static method that doesn’t use state is just a function with a different name. Absolutely nothing wrong with that. 
For sure. I think that's where it makes sense
Never listen to advice that says "at all costs". Engineering is about understanding the exact tradeoffs (pros and cons) of every solution, so you can apply it correctly. Static methods will probably hold less than 10% of the code in a well-factored codebase, but they do have their place, particularly for simple stateless functionality that is often needed around the code without the complexity and overhead of instantiating an object just to call a method on it. The only thing to try and avoid is static state. That also has some edge case applications, but in most situations static state, just like global state, is bad news for the flexibility and maintainability of your code, as it means state will change from random places in your code in often unexpected ways, causing hard to track down bugs, or inability to isolate parts of your app from one another, as they share static state.
This is indeed called a pure function, as it doesn't have any side-effects (doesn't modify state).
You don't need to be a language developer to offer a solution at the highest level. You're not offering anything at all here - you're not even explaining *why* it's an issue. As many people have said... it's just one button. Why is that difficult or wrong? What would you rather see?
&gt; that are the core of OOP That WERE the core of OOP. OOP is now about resuability, which is the whole point of the inheritance tree for better or worse. It's rare that Message Passing and OOP are comingled for the last 20 years (unless you're working with a functional language which might have some hand waving about how it applies).
Memory thrashing is a thing. Cached static methods, are better than littering various definitions with common transforms (or worse anonymous ones!). Business logic utility classes are useful just as much as those found in the standard library.
As a visual learner, I’d love to see a horrible example of a static method and then that same example done using proper OOP. 😀
Biggest con is actually global state and testing hardships are just an side effect of this. 
Cookies? I don't bother with them, because I use private VMs/containers for testing. So I can simply set up Xdebug to always connect outwards to my IDE. That means I can catches *all* PHP activity, including indirectly scheduled operations like cronjobs or stuff launched in a separate process.
If you go down the OOP route you will eventually realize that interfaces have become an core concept. Interfaces apply to instances and static does only apply to classes. In the sense of OOP it is an contradiction. I've never looked at it but I guess Java invented it that way because it doesn't have functions. In any language that has proper closures static is just redundant.
Just imply that something is dead and hope others believe it.
Xdebug is a pain in the ass. I seriously still use print_r(), var_dump() and die() in my code.
Disagree: that is only if you accept to have xdebug all the time but there is a lot of cases where it's painfully slow with it and you want to disable it.
No. People who say things like this rarely know what they are talking about. Understand the tool, then use properly.
node be the php 2 of the front end 
&gt; As many people have said... it's just one button. Why is that difficult or wrong? What would you rather see? We're going in circles, I responded to that question [here](https://www.reddit.com/r/PHP/comments/9gc827/does_the_future_of_php_plan_to_make_remote/e63cpz7/) in the second part of my response.
If it works? Nope, it's an angelic piece of heavenly perfection. PHP is, at it's best, about using an Irish screwdriver to Scotty it together half the time. Personally, I think whoever told you that is a pretentious tool. 
You can configure xdebug to listen to remote connections. But if you mean debugging on production, I wouldn't advise having xdebug installed in that environment, and that's not just a PHP thing. 
Node and php are two completely different things. They can’t be compared. Node is a run time environment and php is an interpreted language.
You could also have a “pure” function that is static which is fine. This would be a function that does not mutate any of the data within the object instantiated by the class. A static method might be filtering an array that is passed thru a parameter. The method belongs in the class, because that is where it’s relevant but it doesn’t need to mutate the object directly. This could also realistically be done in an object oriented matter depending on the use case. On the other hand, think of a model class, This wouldn’t make sense to have a ton of static methods because you are dealing with an modeled object and either reading or mutating it’s data directly. One isn’t better than the other, it’s all about when you use them because they have different purposes. I would compare it to design patterns. Knowing one design pattern is cool, but reusing it everywhere is not. Each design pattern has its own purposes and should be used accordingly. 
Where abouts? I was wondering about the -1 myself.
https://twitter.com/SaraMG/status/1040583020108034050
Haha, so she did. Thanks!
How about writing tests?
&gt; Deterministic means it returns the same value every time it is called with the same arguments. That's idempotent, not deterministic. A deterministic method can return different values for the same input, it just has to be non-random
There is a difference between the two. A pure function will only ever rely on on the input given to it and return a value based on that, where as a deterministic one can do more such as writing to storage. In other words, a pure function is also a deterministic function, but a deterministic function might not be pure.
&gt; Considering the fact that many existing PHP developers are shifting to node.js and new people aren't showing much interest in learning it Pics or it didn't happen, in other words, where the proof? &gt; what do you think about the future of PHP? How long would you think it'll survive? Would you guys still recommend anyone to learn PHP? If so, why? I think the state of node js frameworks for the web isn't as mature, IMO and from what I have professionally worked with, as they are in PHP.
The distinction is definitely important in functional-style code, for any state (not just persistent store). 
This is a small, fast and extensible PHP &gt;= 5.6 library that handles the generation of HTML tags, their attributes and content. I tried to follow the best development practices to make it as most usable as possible for any projects. &amp;#x200B; Let me know what you think!
## HTMLTag I just published *HTMLTag*, a fast and extensible library helper for creating tags and their attributes. Find it here: [https://github.com/drupol/htmltag](https://github.com/drupol/htmltag) Feedback is more than welcome.
To each his own. I still prefer being able to know which part of the code is still running and which is not. Isolation is the best thing that unit test offers with mocks. With integration tests, you get failures and still have to pinpoint the issue. That's where unit tests come in and help you isolate the problem easily. Having said that, both unit and integration run once through a class is better than one or the other.
So then are you suggesting that static variables are necessarily evil?
Are there any examples where you can not test a static method or where it hard to test it? Not sure if it matters, some additional information. They are using static methods for database calls. book_finder::get_books([‘author’ =&gt; ‘John Doe’], [‘limit’ =&gt; 25]); P.S. the database is HUGE.
Nice article. Yes, if things drastically change, as such in your case, it will be very hard for tests to give you the confidence you need. I'd say your case is an extreme one, where you need to change the PHP version itself. That caused you to have to make changes both to the code and to the tests significantly. Yes, with tests, at first it's extra work when refactoring, but it pays in the longer run. Now that you have upgraded it, it should serve you well if you have those tests working. Having said that, I think for a normal person who has the luxury to stick with his PHP version and dependencies, unit + integration + feature tests combined will do wonders for them. Thanks for the input. Cheers.
My first thought is... why? I'm reading these examples and not seeing why this was written. For example: $paragraph-&gt;attr('class')-&gt;remove('section')-&gt;replace('paragraph', 'description'); Why would I ever do that? Just write it the correct way to begin with? My second thought is... does this do any proper context-aware escaping? As far as I can tell it does not. 
Well, if you look at the docs for xdebug, it's really easy to skip the cookie option and have it connect to your IDE always.
This might actually be helpful working with a a certain shitty old XML api I have to deal with, thanks.
But when people (no, not you) say these things and then provide no example showing static method and same example showing proper OOP... it’s difficult to ever “understand”.
I’d personally like to see a can/can’t list of things they can or can’t do that the other can. What I will say, as the web is becoming more and more “reactive”, I’m personally using PHP for endpoints and that’s about it, purely due to not wanting to get into learning how existing PHP endpoints would be coded otherwise.
What's wrong with SSHing into the production servers and editing files by hand in vim? \`var\_dump($x); die();\` is your friend! &amp;#x200B; This is how the pros do it. Trust me.
Obviously there are exceptions to this rule. 99.9% of projects won't have this scalability problem
Just for the factories, nothing else. 
By definition 'evil' code is not something you should never use, but should be wary of not to misuse. I think in that way using static methods can be seen as 'evil' because it can be a trap (global state/testing issues) of you don't think about the consequences. It's also something you should usually avoid.
&gt; They are using static methods for database calls. That would be the go to example. When people say "can't test" or "hard to test" it generally means unit testing or some level of integration testing where you need to mock things. public function getFooBooks() { // this needs a working DB set up in a known state in order to test Book::get_books(); } public function getBarBooks(DB $db) { // you can pass in a mock db that returns whatever you want // and it's in memory so it's fast $db-&gt;getBooks(); } ```
The difficulty is in the global state. If your static method neither mutates nor keeps state, then it should be possible to test. Consider a trivial example where a global counter is incremented on each static method call. If you expect your tests to run in a certain order, you might be able to verify a predictable outcome, but it’d be tough and super prone to breakage if anything changes. The reason is that the tests aren’t isolated - the outcome of one test is affecting another one. And that’s just the testing side of it - it’s scarier in real code because unfamiliar developers may not realize the side effects. In traditional OOP code, it’s expected that the output will be the same for a given input, regardless of how many times it is called. As for your specific example, I’ve seen this pattern before (in regards to databases) and it’s not the worst thing in the world, assuming it’s just abstracting some basic boilerplate database querying. I’d still prefer instantiating the object and calling an instance method on it, though, if for no other reason than it will allow you mock it. There isn’t really a downside to it being an instance method, IMO, but there are some to it being static. I won’t say never make static methods, but I will say there are few reasons to do so. Even singletons are considered an anti-pattern, especially due to the shared-nothing architecture of PHP.
Static variables are effectively glorified global variables, so yes they are evil and you should avoid them as much as you can. 
This makes another question, why the example provided on your page is something that no one would do that in real code? Is there any *real life* example? Does it solve real problems? Or just imaginary ones? And what about escaping for the content?
It's just to show the API, the method chaining and the possibilities that are available to the user. I do agree that it would be better to have a better documentation. Regarding the content escaping, the Tag object doesn't modify the content items at all. As I'm not responsible for the data that are added in the content, I prefer to not alter them. Do you have a better suggestion?
It is not about the better documentation. It is about the better idea why this library. Do you have any real life world example that solves the real world problem? &gt; Do you have a better suggestion? Yes. I have. XSS is in OWASP Top 10 web vulnerabilities. &gt; I'm not responsible for the data that are added in the content And who is going to be responsible for the *HTML* escaping? A database? 
Node is very fragmented and inconsistent, the're some interesting frameworks, but they're not really that popular, or falling apart like Meteor, which makes it difficult for small businesses to hire freelancers, and freelancers finding node jobs. It's more interesting for well funded startups and companies who can hire full time and train their staff on their custom stack. This means that popular PHP frameworks are easier for bootstrapped startups who can't afford to hire full time developers, basically most non VC funded ones and small businesses. My impression is that indie startup hackers love PHP for those business reasons, good structures to get started, full stack ownership, and easy to hire. PHP might not be an ideal solution for carreer devs anymore, but it's interesting for people who have their own projects, and work part time for others and hire other freelancers to work on their projects. I think that PHP could become more popular if more people getting into webdev would be aware of this business value of popular PHP frameworks.
I find it amusing that people think this way. Seems to me to be a case of own side bias, and some weird forms of tribalism. Developer moves from PHP to node.js and enjoys it, concludes that everyone must be moving from PHP to node.js and enjoying it. Concludes PHP doesn't have long to live. PHP have survived reports of it's demise for as long as I can remember, and yet it keeps on proving the doubters wrong, being relevant and useful, and powering a not-insignificant portion of the web. Even if the conclusion that "new people aren't showing much interest in learning it", the future is bright when you think of the sheer amount of production PHP code that businesses rely on that is out there in the wild. It needs to be maintained and improved upon. Few businesses will stomach changing their core technology over unless there are incredibly compelling reasons to do so. So how long will it survive? Who knows - but I'd be surprised if it's survival isn't measured in a time scale of decades. Would I still recommend people learn it? absolutely - even if the doom and gloom is right (and I don't think it is) there will be plenty of well paid jobs maintaining the mountains of production code out there.
At first I did not want to alter the data and let it be handled by the user, by any means. But ok, you convinced me and I updated the Tag class to handle this. Let me know if it's better. Thanks. 
Although they are a good way of converting random numbers and values to a meaningful name. E.g. in a class for cars, 1 could be mapped to cars::type_saloon, which saves you having to remember what 1 is equal to later in the code
This is a great move by Symfony, having official video-based tutorials is a must to adapt to a market which expects it.
Thanks !
&gt; Reasonably-tuned PHP-FPM+Nginx: 160-200ms Something is wrong. For the same type of health check request using nginx+fpm &amp; php 7.1 in docker/kubernetes I'm getting &lt; 40ms from the office to aws.
By APC do you mean [OPCache](http://php.net/manual/en/book.opcache.php) or actually [APC](http://php.net/manual/en/intro.apc.php)? Because APC is dead.
It's funny how we went from "PHP is too easy so it sucks for beginners" to "PHP is too hard so it sucks for beginners" in just a few years.
So according to your definition, this code is evil? `$flights = App\Flight::all();` (taken from the [laravel documentation](https://laravel.com/docs/5.7/eloquent)) &amp;#x200B;
Ditto. If the code is stateless and relates more to the class than to an instance object of the class then it is a candidate to be static.
I’m waiting when Otwell start to cry about copying, even he wasn’t first ^_^
The best thing is they still distribute the tutorial text for free if you can’t afford for premium and get to watch video :)
PHP can survive thanks to the same recipe that made it so ubiquitous in the first place: \- The big giant open source solutions (Wordpress, Drupal, Magento, ...) \- The frameworks (Laravel, Symfony, ...) \- Noob friendly for small-middle size website development \- Large community (very helpful even if this reddit doesn't look like it, it actually is) &amp;#x200B; Node is better suited for modern projects because now it's all about modern progressive web app, and they are written primarily in JS/TS. This way you can port can from the backend to the frontend and vice versa easily. You can also share common design pattern and business logic better. Talking between React and a PHP API serializing JSON is not an ideal scenario. But it's a legacy one. I've been using Symfony 10 years and there's a still some stuff that it does better than the npm ecosystem. But there's also lots of fancy new stuff that the npm ecosystem does better than the Symfony/Laravel/composer ecosystem.
You can always make it configurable. But even this way Twig will be more usable with its filters where you cana change the escaping method for each variable. But still, what is the idea behind this library? Why it exists? What problem intended to solve?
I will probably update it. I guess twig offers more flexibility as it is using templates where you can apply filters and stuff, but HTMLTag is not meant to replace twig at all. It has been created to: * Learn the basics of variadics variables, how to handle them and how it can be useful. * Learn the basics of factories objects and how to use them for DI. * Integrate the library into a Drupal theme (only to handle the attributes, not the tags) and remove the previous stuff and tests that was done in the theme. We will rely now on HTMLTag for that. * It helped me find and understand how to optimize the library for having the best performance. * The need to increase my knowledge with array\_map(), array\_reduce() and all of these functions.
Is that just a facade and behind the scenes it is a non-static method that is called? So you can change the facade to something else, e.g. during testing. &amp;#x200B; &amp;#x200B;
Yep, this may be bad. If you have a class that uses this static method, you will not be able to unit test that class, because it's not a dependency that you can replace with a mock; that's pretty bad for a piece of code that does I/O. &amp;#x200B; OTOH, Laravel circumvents this with a facade, but in my opinion it's a solution for a problem that you could avoid entirely to start with, so I don't like it.
If you can change it, it's not deterministic. And it's definitely not a \[facade\]([https://en.wikipedia.org/wiki/Facade\_pattern](https://en.wikipedia.org/wiki/Facade_pattern)) according to the pattern.
static functions dont necessarily use global state, just like any other function. they are simply more likey to do so.
This is so cool! KnpUniversity is plain awesome (funny, interesting and really well done content).
It's still KNP University from 2011~2018 so it's not the official casts website in that period. I was primarily referring to having an official casts website where it follows in the footsteps
Correct it is not a true facade, it is a "Laravel facade", i.e. a proxy. It is deterministic that it will call the proxy ;-) &amp;#x200B; Now, I'm not the one you asked the question to, but imho I do dislike how Laravel uses static methods, almost evil, prefer an interface to achieve the same result. &amp;#x200B;
Yes, you are right about that. Cheers!
Yes, that is why I put an ironic smiley on my answer, I don't disagree on the definition on deterministic, and that is why I call it almost evil.
However a call to a database would never be deterministic anyway. So are database calls evil? Oh..
MySQL 8 provides better JSON support. You should give it a try.
your example code is terrible. The developer can easily set the member $foo to private and therefor the unset call will not work... &amp;#x200B;
Hey, ddarrko, just a quick heads-up: **therefor** is actually spelled **therefore**. You can remember it by **ends with -fore**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
They are not evil, they are just not object oriented. You can just use functions instead.
&gt; Setting up xdebug to work with PHPStorm is definitely not one clic So much this. I don't even know what makes the browser extension work or not. Eventually it just starts working and I dare not to touch it again after a clean installation.
PHP version changes every year, so does the framework. Symfony itself 2 releases per year. Yes, you can stick with the old version, but in time you can either upgrade it or rewrite it or leave. I prefer small gradual upgrades rather than any other costly changes. I already tried the "I stick with old versions for now" approach. It led to very expensive 3-years rewrite. Now I prefer small gradual jumps every year. One way or another, tests should be written in a way that make upgrading and maintaining piece of cake. Not a reason to stop upgrading. IMO :)
Awesome! I'll do my best to help :) I'm already subscribed to issue. Feel free to ping me on Github anytime, it's my "Facebook".
Exactly don’t know from who those - goes 
&gt; Considering the fact that many existing PHP developers are shifting to node.js Where exactly are you basing this "fact" on?
Serenity now...
Knp is great but kinda expensive as compared to other casts
After reading through the comments, I see that you've got some answers about the general case of whether static methods are bad. There are a few specific things you have mentioned, that I'd like to address directly. They don't use namespaces. To me, static methods are namespaced functions when you don't have access to namespaces. Now, you \*shouldn't\* need to do static methods in a language that has namespaces, but I've also been in a codebase that didn't use namespaces, so any free functions I would write, I'd attach to a (`final` with private constructor) class. As long as the static methods are **pure**, this is okay. They use static methods for database calls. That's bad. These are not pure functions, which means the results of calling them can always be different, even if called with the same inputs. Anything that alters state (global or not) should not be a free function or static method. I always wrap my database calls into a class that implements an interface. Then the rest of your code can accept that interface as input. This makes it very easy to test all of your code without needing a real database. Their code will be a pain in the ass to test.
Named constructors are an excellent example of where static methods are quite suitable.
Well if you're intentionally writing bad code it's pretty pointless to blame the language ... PHP provides private, protected etc for a reason 
You are probably looking for `xdebug.remote_autostart=1`
Behave.
Because of the way you formulate your post. 
I was going to post this joke, but after the downvotes you received, I'm glad I didn't!
So, first of all, it's not even about writing bad code. In C++ or Java or Swift or Rust or OTHER_LANG, I can write code like: class Foo { public int x; } And be perfectly happy to have a class with a mutable field called "x" that is always an int. PHP's type system is poor, so I cannot write the above code. I **have to** use getters and setters because the language is bad and I don't want someone else to write code that will screw up my objects' public fields. Not only that, but what if I"m not the one writing the class? What if there's a third party library that has classes with public fields? PHP's type system is flawed such that it's now a code smell to have public fields. Good grief.
&gt;It's great to keep a consistent naming schema. I question the assertion that the naming convention is consistent. The C in SymfonyCasts is uppercase while it is lowercase in the other two. Clearly a code review failure.
In theory, yes. It all looks great on paper. Use the right tool for the job, etc. But in practice, there are other considerations. For example, there are 10 Javascript developers for every PHP developer on the job marked I’m hiring in. 9/10 of those JS devs are straight out of a bootcamp, with little to no commercial experience, have no CS background, and so on. They can’t make a mid to large application with decent quality, but they do get hired, they get their experience and more skills. And that was happening for a couple of years now. In the last 3 years my team went from 50% PHP 50% JS/CSS members to 25% / 75%. Why? Because there is more demand for the client side work, and while you have your JS dev team, they might as well do some backend stuff. Because why would a React dev want to work with some „legacy” REST API if they can code their own GraphQL endpoint? You are also paid better as a React developer in my city. About 20-30% easily. This makes people switch. It’s harder to get on the job market with PHP as well. There are very little bootcamps and trainings for PHP devs, while there are numerous FE/React ones. This has nothing to do with what those languages are capable of or how the community has matured. I too believe that you could do much more with much higher quality with PHP in many situations, but we don’t always have the choice to use the best tool for the job.
Almost. PHP only allows a single constructor, so static methods can be useful as alternate constructors or as type "factory" methods. I also sometimes use a bunch of static methods and a private constructor to make sure a class is only ever instantiated with some small set of pre-determined values.
Holy shit, that's expensive.
But Laracasts is Jeffrey Way, not Taylor Otwell, you imbecil.
Repost... [https://www.reddit.com/r/PHP/comments/7ctq7z/7\_frameworks\_for\_automated\_php\_testing/](https://www.reddit.com/r/PHP/comments/7ctq7z/7_frameworks_for_automated_php_testing/)
What a substantial claim. Have any sources to back it up?
This reminds me of \[Aura.Html\](r/https://github.com/auraphp/Aura.Html), which was really useful for building \[forms\]([https://github.com/auraphp/Aura.Html/blob/2.x/README-FORMS.md](https://github.com/auraphp/Aura.Html/blob/2.x/README-FORMS.md)).
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [auraphp/Aura.Html/.../**README-FORMS.md** (2.x → eda14b4)](https://github.com/auraphp/Aura.Html/blob/eda14b491f45fe2e1d1fec3364b1c783d7b7da31/README-FORMS.md) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply e64q09w.)
If they are creating problems when testing or maintaining your application, sure. Everything needs to be grounded in reality and actual code. It's hard to broad sweep a certain concept as "evil" when the concept is divorced from any actual codebase.
Ah, ok! Thanks!
If you wanted to test this in isolation you would need to put it behind a repository and fake / mock it - just like Doctrine. As far as testing goes, there is literally no differences between the patterns - both require repositories.
PHP will survive just fine for a long time simply because the amount of stuff already built on it and that for a lot of sites you don't really get the benefits of something like Node.JS. Just as Node,JS will survive despite people / companies move from that to Golang, Elixir, .net, etc when they need better performance, a better concurrency model, etc. The only part of your question that has some validity is why learn PHP at this point, I think the only real reason to pick PHP over anything else these days is if someone wants to work as a freelance developer, because in that area PHP is good due to things like Wordpress, Magneto, etc, provide the sort of work a solo dev can manage. But that aside there is no compelling reason to learn PHP nowadays, pretty much every other language offers additional reasons to learn them beyond simply being able to create a website, be it performance, proper concurrency features, mobile dev, machine learning, etc.
&gt;Oh the same 'node.js will kill PHP' crap again, seems that every now and then we see such a question/post and it never fails to amuse me how misinformed developers fall for such nonsense. From what I have seen it's not nonsense but maybe an exaggeration. Back when I learnt web development you would be taught (or self learn) HTML and CSS, you would then move onto Javascript to make the pages interactive and then move onto a server side language such as PHP, C#, Python, Ruby etc. More often than not that would be PHP as it had the lowest barrier to entry and hosting could be picked up for dollars (not an issue anymore with the price of VPS coming down to the levels they have). I've been in a position of hiring at my last 4 jobs over the previous 15years and I can say with certainty in junior positions Node is without a doubt outstripping PHP/C#/Python. People generally learn JS before a server side language and if they can use that server side and the barrier to entry is even lower when learning something else? Even more so as a beginner? I'm not saying PHP or the others are going away anytime soon (PHP even more so than the others) but there is definitely a shift in the younger/new developer market towards node. It won't happen overnight but in time I can see JS being the dominant player the same way PHP took on huge might market share of Perl/JAVA in the early internet days.
This blog constantly spams it's copy and paste, crappy, posts here can we just not ban any links to this URL?
I hope they change it to have more speed, but for the other part(s), I glad there is such a thing as debugging (with xdebug), which guides me to a lot of information that is otherwaise a burden to debug with var_dumps and stuff like that. I even saw a guy who made an extension that you can step back while debugging. So if the breakpoint is set to late, you can step back from there. Which is very modern!
You may say that node.js will be a good alternative to PHP in future, but it is nonsense to say that node.js will kill PHP, it will not. I dont understand why you mentioned Java here, do you honestly think PHP killed Java? How about checking TIOBE index and see which programming language is in top 3? Node.js is best suited for certain type of web applications, and hence why some companies/developers are shifting towards it. But Node.js is not the silver bullet for EVERY web application, and it never will. It will never completely replace PHP in the same way as PHP did to Perl. 
/u/NotFromReddit found a recent tutorial on getting it setup. For php7 you'd just do php7.2-xdebug. I may write a more updated version using symfony 4 flex as an example. https://blog.theodo.fr/2016/08/configure-xdebug-phpstorm-vagrant/ 
Yup guys are so serious here
Too bad you can’t read and abuse ppl for no reason. If you would follow his twitter you would know why ppl do jokes about it 
Thanks. Saved. 
Indeed, Aura could use HTMLTag in the background actually :-)
[removed]
Also to disable you can run `sudo phpdismod -s fpm xdebug` for instance or `phpenmod` to enable it. 
As noted elsewhere: Every tutorial/cast has the script available with example code blocks. So all of the content is available, just not in video form.
built an API on silex last year and a different one on slim this year - i'm liking slim a lot.
how can node kill php if ruby already killed php in 2004?
As long as they dont get rid of written cookbook/tutorial articles. I can't stand video.
Why would they? It took quite a bit of effort to get all that content in place, who'd remove it just because?
Still way expensive
&gt; I’m waiting when Otwell start to cry about copying, even he wasn’t first \_\^ I get that it was a joke (a really bad one at that) but you probably hitting the down votes for just being totally and completely factually incorrect. &amp;#x200B;
&gt; *Never* listen to advice that says "at all costs" Waaaaait a minute, I'm not falling for that one. But yeah, jokes aside I completely agree with the principle of this - there's no such thing as a "law" in programming, but there are some good "rules" - in the "rule of thumb" sense. Instead of taking those "don't do xyz" and "always do zyx" rules as law, instead take them as breakpoints. Don't avoid them, but instead take them as opportunities to stop and think. They're what's sometimes called "code smells" and should be an indication that you *might* be doing something wrong. That doesn't mean you are doing something wrong, just that you should stop and think about what you're doing, and decide why you're doing it. Everything is about tradeoffs, and a good code smell is about making sure you don't accidentally walk into a bad trade. It's the equivalent of the "Are you sure you want to delete this?" box. Most of the time I hit a code smell, I think about it and decide I still want to go down the path I was heading down, because I had a good reason to do so: but on more than one occasion it's saved me from a bad decision where I was just defaulting to an easy option (or what I did last time) rather than making an informed choice. There are no rules, there are only guidelines: but when breaking a guideline you should have a good reason to dos o.
I wasn't clear... I didn't mean getting rid of existing content. Cleary the existing stuff isn't going anywhere, and the official technical docs will always exists. It's future tutorial/cookbook type content I worry about if the creators of it choose to move towards video instead of creating text based stuff or taking the time to do both beyond accompanying code snippets.
I wasn't clear... I didn't mean getting rid of existing content. Cleary the existing stuff isn't going anywhere, and the official technical docs will always exists. It's future tutorial/cookbook type content I worry about if the creators of it choose to move towards video instead of creating text based stuff or taking the time to do both beyond accompanying code snippets.
&gt; In general though: try not to stick to only with one language throughout your career... This is always the biggest thing for me I learned PHP as a teenager building hobby stuff, I learned Pascal and VB in college, Java and C in University, and I've worked mostly with C# and JS in the working world. Don't learn a language, learn to program. Once you do that, switching languages/ecosystems is a matter of a week of learning the syntax/stylistic differences, and a couple of months of learning the ecosystem (libraries etc)
&gt; So it's not exactly true that Symfony is following Laravel's footsteps :) I would argue railscast is obscure (first time I have heard of it) and Laracasts/Laravel is much more recognizable. &amp;#x200B;
Their documentation budget is not unlimited. As the product matures, existing cookbooks and text-based documentation might be seen as a cost center. It is a very common mistake in business to not see the indirect value of cost centers. In this case, if they instead deploy documentation resources to their new profit-center of video tutorials instead, text-based documentation might suffer, killing the open-source community that they actually rely on.
Check your server logs to determine what the generated error is. You may need to adjust the error\_reporting and display\_errors ini settings.
You should examine the php error log (usually errors are logged into the Web server error log). Double check that PEAR in installed
The initialization doesn't run again after the first time. Try thinking like it is a global variable. You'd be doing something like this: ``` Function step() { Global $i; If(isset($i)) $i = 0; $i++; } ``` (I'm on mobile, so the above may look wonky.)
&gt; funny Oh, man... Ryan has the most cringe worthy dad jokes. They're awful and I love them.
Eh, I've done the 1 month membership twice now, and gotten through most of the things I wanted to. I'm signed up for Coursera courses that are more expensive.
This PHP code is probably older than this user account (or the dev should be taken out and educated!) and was probably made for PHP 5.2 or earlier (no short-array syntax introduced in PHP 5.4.0 on 12 June 2012). It is also using PEAR. Whenever I see PEAR, I run for the hills. Burn it!
Apparently I can't make a post body, so here's my situation. I'm on a legacy application, and I have to use some service I know nothing about. I've got documentation, and I may need to write a library on top of it. I'm wondering what I should use to do the actual sending and receiving data. 
Took so long
[Guzzle](http://docs.guzzlephp.org/en/stable/) is a widely used HTTP client library. I'd recommend wrapping some of your own logic around it.
This definitely needs more context/information. Assuming we are talking about remove service communicating via HTTP it would still be important to know a couple things: \- Are the endpoints known (eg. official documentation)? \- What format (json, xml, csv, yaml, ...) is expected / returned? \- Is there an Authentication/Authorisation layer (HTTP Basic, JWT, OAuth, ...)? \- Does the API follow any known Standard/Convention/Protocol (REST, SOAP, ...)? It also **strongly** depends on your **actual needs**. Depending on that you could start with something as simple as good old [file\_get\_contents](http://php.net/manual/en/function.file-get-contents.php) (maybe in combination with [stream\_context\_create](https://php.net/manual/en/function.stream-context-create.php)). You could aslo go with [cURL](http://php.net/manual/en/book.curl.php) if prefer that or need something more specific. If you want to work on a higher leverl of abstraction then I'd recommend using a HTTP Client library like [Requests](https://packagist.org/packages/rmccue/requests) or [Guzzle](https://packagist.org/packages/guzzlehttp/guzzle). This list is neither exhaustive nor complete but should give you an idea on what to think about further (endpoints, auth, format, convention) and what tools to pick for sending requests/handling responses depending on your specific needs.
My guess is that you don't have the PEAR Mail class installed on your server. The 500 error would just be telling you that the class doesn't exist. Check your logs; if you don't have any, set log_errors = On in your php.ini file, and set error_log to the path you want to log errors.
You're right about all your points, but you answered my question anyways. I didn't know about Requests, so I'm taking a look at that in addition to Guzzle. Thanks.
Cool. I wasn't sure if Guzzle was still the go to. I'm glad to PHP has some libraries that are really sticking around. Thanks for the response.
There's also [HelloWorld Enterprise Edition](https://github.com/DQNEO/php-HelloWorldEnterpriseEdition) and [FizzBuzz Enterprise Edition](https://github.com/DQNEO/php-FizzBuzzEnterpriseEdition).
thank you elbucho. :) 
Wordpress does this with its post data, too. The difference is that Wordpress sites usually don't get as big as Magento sites so you don't notice the performance hit.
Static methods are not bad per se. Static states are. If you can change your states with static methods, you are all wrong. That's why static methods / properties are not the right solution 95% of the time. Factory methods are part of the 5% left. 
Don't care about those that much - still, yea it was a joke and maybe my kind of humor is more selected one :) Next time will keep it for myself to avoid such comments and relive other users their pain :)
I liked static methods in context when they are useful. The problem is it can get out very slowly out of control and hit you back. Here are my 2 cents of experience: &lt;a href="https://www.tomasvotruba.cz/blog/2018/04/26/how-i-got-into-static-trap-and-made-fool-of-myself/"&gt;How I Got into Static Trap and Made Fool of Myself&lt;/a&gt; I suggest try it out and find the line yourself. I see you're already critically thinking about this topic, so there is little chance it will go wrong. A chance called experience ;)
Even if they do not modify global/static states, these 'pure' static methods still have one problem that they are placed in classes that they do not rightfully belong to. As a consequence, the class is now responsible for what it is designed for, plus a new responsibility of managing its creation methods. This violation of SRP is no different from how Singleton classes violate SRP, though not as bad as Singleton it is still not a good practice. So where do factory methods belong? In PHP, you write factory classes and instantiate factory objects to manage creation of objects when the logic gets complex, as many design pattern books have demonstrated that. In a purer OO language like Python/Ruby, classes themselves are objects, so the classes are the factories for their corresponding objects. Its way more elegant as the factory methods fall into the metaclass of factories, as you can see from the examples below: PHP Factory Class: class Date{ // The date class that we want to create objects for } class DateFactory{ public function createFromTimestamp(int $timestamp){ // create Date object from timestamp } public function createFromFormat(string $format){ // create Date object from formatted string } } $dateFactory = new DateFactory(); $date = $dateFactory-&gt;createFromFormat($format); $date2 = $dateFactory-&gt;createFromFormat($format); Python Metaclass: class Date(Object): __metaclass__ = DateClass class DateClass(type): def createFromTimestamp(self, timestamp): // create Date object from timestamp def createFromFormat(self, format): // create Date object from formatted string date = Date.createFromTimestamp(timestamp) date2 = Date.createFromFormat(format) As you can see, the responsibility of managing creation of Date object is now on the factory class or metaclass, which is how it is supposed to be done in OO. 
SLIM
Hey y'all - I'm running into a bit of an issue with PHPStorm. I'm trying to work with Cassandra in my project, and I'm integrating it into PHP with a plugin that I built on my development computer (Mac OS X 10.11). The plugin builds ok, and it's properly added into the php.ini file (when I do a phpinfo(), it shows info about the plugin), but PHPStorm won't give me any autocomplete info for the Cassandra class. It doesn't even recognize that as being a valid class. I've invalidated the caches and restarted, but that didn't get me anything. I've made sure that the interpreter it's using is the right version installed with homebrew (7.1.22), and the php.ini file it's using for configuration is the correct one (contains the line to include cassandra.so), but PHPStorm is still completely unaware of this plugin's existence. Has anybody run into this before? Anybody have any ideas about what I can do to fix it? For those curious, here's the github for the cassandra plugin: https://github.com/datastax/php-driver
But what's the difference of doing that instead of using a mock library for that? The only advantage (if you want to call it that way) is that your tests won't depend on a library. The object that's returned by the mocking library/framework is also an implementation of the dependency used for testing and it can be injected too to the object that will be tested. I don't see why would I prefer to write the fake object manually instead of using a mocking library that will allow me to add method implementations easily to the fake object, check how the fake object behaves during the execution, etc.
yes, like people say, use JSON types if available. There is absolutely no reason to use EAV anymore when Postgres,Mysql and Sqlite all support JSON types.
EAV is basically schemaless data in a RDBMS. The problem of EAV is that your data end up being untyped, requiring crazy queries to fetch attributes ...
$250 a month is a lot of money... I pay $99/mo here in salt lake city and really enjoy it. Great for work-life separation and i've met a lot of cool people. The biggest value is the community that easily goes missing when you're a lone wolf. 
exactly, same thought here. Seems like a lot of extra work for the same thing in the end.
I believe(d) so strongly in HHVM, HackLang and the (compelled) motivation they put on ZendCorp and later RogueWave to *actually* maintain and innovate the PHP language (virtually *everything* since 5.5 has been a direct copy of HackLang) that I not only had my corporation migrate all of our internal projects to HHVM throughout 2014-2015, but also had all of my guys + girls and myself port virtually all of our clients' sites to it as well throughout the years. Hell, we'd even give them discounts if they let us work in pure HackLang, which just worked, because we could pretty effortlessly still use composer and frameworks for everything... I remember the day in late 2016 when I effectively did `/etc/init.d/php7-fpm stop` on our servers and was able to rid ourselves of ZendCore internally (whom never have really treated me nicely, vs Facebook who has cut me over 5 digits in unsolicited checks for all the security bugs + fixes i reported on HHVM in the early days). Then I remember when Laravel discontinued support for HHVM in early August 2016 and I was like, "oh crap!" and soon everyone from Symfony to MongoDB followed suit. At that moment of Laravel dropping support, I saw the future and I immediately had everything ported back to PHP7 (which was ridiculously easy. 10% as difficult as going from PHP7 to HHVM) and sadly, I feel stuck on it to this day. Only my math-intensive stock analysis app and my cryptocurrency HFT trading bots still run on HHVM, in pure HackLang, of course.
My biggest blocker was the lack of support for gearmand and postgres! I contributed several pieces of code to both repos. Fortunately, HHVM extensions are in pure HackLang, not C.
Thank you for all of your civility and good graces over at HHVM's repo on GitHub back in the 2014-2016 period. You were one of the main reasons we ever went full-on HHVM over Zend Core.
Thus it went from one of the primary motivations for improvement in the PHP world *EVER* to the de facto state of slow show-nothings we experienced between PHP 5.2/5.3 (2006/2009) and PHP 5.5 in 2015. I pray that won't be the case now, but you'll notice a substantial decrease in momentum of the language's development since HHVM basically unofficially threw in the towel circa August 2016. The new additions since have been a joke! I bet all the typers lose virtually every battle from here out. Good luck ever getting structs or enums now :-/ much less proper collections.
Yeah that's the situation we're in. Using PHP libs via composer for HackLang apps, where the ecosystem is close to nothing.
If you're going to either blindly write static methods, are blindly *avoid* writing static methods, the second option is much much better! And it's a good rule to pass along to any junior devs you happen to be mentoring. However, not all static methods are a problem, and in some cases may be the correct thing to do. Global logic is not a problem; global *state* is, and static methods can represent logic, state, or both. If you want a magic `json_decode` method that handles comments, or has different error handling semantics than the normal method, there's nothing inherently wrong with writing a `JsonMangler` class with a static `::decode()` method. If you then go on to add an `::addItem()` method and an `::renderCollection()` method, and you then add items all over your code base, and then spit the entire thing out as a string when needed, then clearly someone hurt you very badly once, and I hope you come to terms with it, but in the meantime please stop committing code. :) &gt; PROS - perfomance. Runtime performance isn't the issue; class instantiation is very fast, and if you were going to be doing heavy lifting in the constructor (like creating a database connection) then you'll need to do it anyhow in the static methods, so... The pro is basically "making it faster to write code" and the con is "making it harder to debug, test, and maintain code". For very basic code that gets called a lot, and doesn't have much to go wrong (because, say, it has no state) that *could* be a good tradeoff.
Does petting camels in New Zealand make you a better painter than owning several 90’s era Fiats? 1.) How do you feel about lipstick? 2.) Do 1860’s ideas about women’s rights make sense in today’s spacecraft? 3.) Are these questions more or less random than OP’s? 
At least his questions are relevant to development. Downvote and move on. 
I'm curious now, are you from NZ or just a brilliant example?
No they are not. OPs post looks like it was generated with markov chains or something :D
You need a server to run PHP
All your questions are very leading and show that you already made up your mind. &gt; 1) Is the JS ecosystem like React for example, in front of the curve compared to Php, C#, Ruby, Java etc in term of features, speed or users experience it can create ? React is a frontend view library. Php and Ruby are languages usually used on the backend for a web service. Java and C# are languages commonly used both for web backends and general purpose programming like desktop apps and other things. There simply is no way of comparing them. &gt; 2) What you prefer in the current web stack your working with to the JS alternative like React, Angular, Ember, Node etc ? Saner dependency chains. Also, "React, Angular, Ember" do not belong in the same place as "Node". That is like me saying "Why do you like Windows instead of C-based alternatives like Adobe Acrobat, Linux, BSD, etc?". Just because they all use or run a common language do not mean they are alternatives to the same thing. &gt; 3) Do you feel that web programming as a whole is slowly becoming more functional and dynamic and that the old OO programming concept of the 90's matter less (C++, C# etc) or you favor a strongly typed language over flexibility in a weakly typed language like JS ? Typing has it's place, dynamic languages have their place. I'd prefer my bank to use a typed language for their backend, but I like not using a typed language for something less crucial.
Hey Aredin\_the\_sheep I'm working on the live server and don't know what type error occurred. So thank you for your advise. Have a nice day :) 
Good luck
Not from this error. This is IIS reporting that PHP died. Somewhere on the server is hopefully a log with the error. If you can upload files to the server, upload a file with: &lt;?php phpinfo(); In it and load that file. Search for “log” in the page that is displayed.
Odds are that you have to pay for the domain name, it is easier to find free hosting, but those rarely allow domain names without a cost attributed to that. 
\+1 for guzzlehttp
That's not what their doing there though, but the very opposite: cookbooks and the like are powered by the community, and with this move they also decided to sponsor Ryan one day a week to work on that: &gt;But wait, there's more! SymfonyCasts will sponsor [Ryan Weaver](https://connect.sensiolabs.com/profile/weaverryan) to work on the official Symfony documentation each Friday for (at least) the rest of 2018.
&gt;Flexibility. Python - a high one, PHP - has not. Such arguments, wow statements. Just another spammy post from India?
HHVM should probably be taken off the list as an implementation, and PHP isn't always embedded in a web server. May be things after these, but I haven't read them.
You can enable log\_error in your php.ini or show PHP errors instead of the IIS error page by changing some settings: [https://stackoverflow.com/a/27777574](https://stackoverflow.com/a/27777574) Make sure that you turn display\_errors back to off for your productive environment.
 Probably you didn't read properly. So you used spam word for this article. 
This post is so bad, if it's only support, no support why not a pricing table with check mark ?
From the sidebar: /r/PHP is not a support subreddit. Please visit /r/phphelp for help
If, like me, you're thinking of giving the article the benefit of the doubt in lieu of the comments in this thread, don't bother. It is literally the worst.
What has this become? Why are we getting these posts? Fuck off OP. Post this shit somewhere else. 
It is spam and a really unfair and stupid "comparision". The only better part you're granting php is the existance of constants.... If I could grant you negative gold I would probably do xD
Even this bot is more useful than your complete post :-)
[removed]
Thanks for including ALL steps! I finally got it working for my environment.
Out of curiosity, why would you not want to be tied to guzzle?
Post this there? Feels slightly inappropriate to be posting this here at this stage...
A lot of subreddits have automoderator filters to remove posts from newly created accounts or accounts with low karma because they are often associated with spam. Given that you have only 4 karma, this is probably what happened. 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/netbeans] [How to run Netbeans 9 with PHP support • r\/PHP](https://www.reddit.com/r/netbeans/comments/9gtcat/how_to_run_netbeans_9_with_php_support_rphp/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
I don’t mind, it works fine for me. Using the abstraction, though, helps avoiding potential conflicts with existing dependencies. Any implementation of an HTTP client will work, then, given that an adapter is provided. 
It is a whine because you ask a question which no one can answer as you do not provide any details, and you immediately complain about the cost. Dashboard shows metrics, and there is a portion of the documentation which describes how to add those. Now, if you want to modify the basic functionality of the dashboard, you should provide the details so someone could actually answer your question.
It is a whine because you ask a question which no one can answer as you do not provide any details, and you immediately complain about the cost. Dashboard shows metrics, and there is a portion of the documentation which describes how to add those. Now, if you want to modify the basic functionality of the dashboard, you should provide the details so someone could actually answer your question.
&gt; I'd guess is that it was removed because your submission is more of a whine then a question When you pay for something you buy the right to complain especially when you need to ask basic things. 
When you pay for support maybe. If you pay for software you are just paying for software
&gt;When you pay for something you buy the right to complain especially when you need to ask basic things. Yeah, I know. You really do need to ask basic things. Like for example ["how to write a complaint"](https://www.wikihow.com/Write-a-Complaint-Letter-to-a-Company). This is not a complaint, this is a whine as there is no way to actually help the person as no one has any idea what he is trying to modify. Perhaps what he is trying to do is outside the scope of the project. Perhaps there are other ways of doing what he is trying to do. Or perhaps the is indeed a problem with documentation and it needs to be sorted... Who knows...
As far as I know Apache Netbeans is exclusively for java development?
Singleton is also considered an anti-pattern.
Here's a sneak peek of /r/australia using the [top posts](https://np.reddit.com/r/australia/top/?sort=top&amp;t=year) of the year! \#1: [Australia votes yes to legalise Same Sex Marriage](https://marriagesurvey.abs.gov.au/results) | [5531 comments](https://np.reddit.com/r/australia/comments/7czmsv/australia_votes_yes_to_legalise_same_sex_marriage/) \#2: [Same-sex marriage is now legal in Australia!](http://www.theage.com.au/federal-politics/the-pulse-live/politics-live-parliament-prepares-to-pass-samesex-marriage-laws-debate-citizenship-on-last-sitting-day-of-2017-20171206-h009k2.html) | [2671 comments](https://np.reddit.com/r/australia/comments/7i4nci/samesex_marriage_is_now_legal_in_australia/) \#3: [Prime Minister John Howard, in 1996 wearing a bullet-proof vest under his suit for his address to Australian gun owners after banning guns in the wake of the Port Arthur massacre; Australia's final mass shooting.](https://i.imgur.com/gMmlPfB.jpg) | [4108 comments](https://np.reddit.com/r/australia/comments/7za65a/prime_minister_john_howard_in_1996_wearing_a/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/8wfgsm/blacklist/)
I've been running a nightly dev build for some time. It's had PHP7.1 support for a while. Not sure about 7.2 though. I highly recommend just using the dev build - netbeans 8.2 is really outdated now.
Yeah my bad. I have no idea how I got your post to be about how you couldn't get the plugins to work. My eyes saw something entirely different the first time I read the post, maybe I should go talk with that "sleep" person everyone says I need so much.
Terrible article. There is no valid comparison since PHP &amp; Python aren’t even designed to compete or be compared.
Yes, it creates something of a chicken or the egg problem especially on subreddits that enforce a minimum karma limit to participate.
This is the correct answer. Believe me.... if they deleted all the naysayers comments on /r/Laravel the number would shrink by half.
You modify the Nova dashboard in the NovaServiceProvider. It’s in the docs. 
/r/PHP is not a support subreddit. Please visit /r/phphelp for help
That's useful, thanks. I can't find that info in the docs however. 
Spam is used to describe your articles and pots because that is what they are 
It's hard to understand who your target audience are, but I'm sure its possible to be... Better than this. 
https://nova.laravel.com/docs/1.0/metrics/registering-metrics.html#dashboard-metrics Took me all of two seconds to find and I don't even use Nova. There's a search feature in the docs, I typed "dashboard". Voila.
I stand corrected, thank you.
&gt;As far as I know Apache Netbeans is exclusively for java development? What do you mean? Netbeans has not been just a JAVA IDE for as long as I can remember? The official release (like the Jetbrains family) is based around a JAVA IDE but has plugins to support other languages, obviously Jetbrains has branched these plugins out to make the JAVA IDE into dedicated IDE for languages x, y or z. Nevertheless it's still plugins on top of IntelliJ IDEA, Netbeans takes a similar position but doesn't separate the plugins out into separate IDEs, it keeps them under one product. &gt; And I bet the API has changed too much if you don't get the 8.2 plugin to work. No. Version 9 is simply a first release under Apache with mostly updates to the licensing structure and file headers. So I wouldn't 'bet' anything on that assumption. &amp;#x200B;
&gt;It's had PHP7.1 support for a while. Not sure about 7.2 though. I've not used it in the past few weeks (I use Storm at work) but it didn't have 7.2 support, however it did have 7.1 support.
1: Go to https://www.jetbrains.com/phpstorm/ and download 2: Install 
Python is used for machine learning, devop/sys admin, web development. Php is used for web development. &amp;#x200B; I don't know python but i will bet that for the rest they are more on the same level.
For the 8.2 release, one could download the right bundle (Java, PHP, JS, etc) from the website. For 9.0, they seem to have dropped that - if there are any NetBeans or Apache Incubator folks reading, please bring that back `:=)`. 
\&gt; Is the JS ecosystem like React for example, in front of the curve compared to Php, C#, Ruby, Java etc in term of features, speed or users experience it can create ? &amp;#x200B; Yes, I would even say it's ahead in terms of modernity with stuff like Typescript, GraphQL or Rxjs. There's tons of pretty advanced and impressive npm modules. The Symfony Bundles look like grandpa tech. Most of them have only one remaining maintainer. &amp;#x200B; \&gt; What you prefer in the current web stack your working with to the JS alternative like React, Angular, Ember, Node etc ? &amp;#x200B; I prefer the JS ecosystem to the PHP ecosystem. However, when you have a legacy system whether it's a CMS or Framework based solution, you just have to keep it up to date and end up maintaining third party stuff yourself, forking abandoned bundles and so on... you feel more lonely in the PHP world compared to the JS world. &amp;#x200B; \&gt; Do you feel that web programming as a whole is slowly becoming more functional and dynamic and that the old OO programming concept of the 90's matter less (C++, C# etc) or you favor a strongly typed language over flexibility in a weakly typed language like JS ? &amp;#x200B; I agree with Mpj on this topic, it's been same old same old since the 90', we still use overall the same compilers and design patterns in terms of programming. No revolution at all. &amp;#x200B; JS is dead for me. I use TS for both backend and frontend. There's no looking back.
This post and the article are spam, Mr. admin00001
I found [a this little tip](https://blogs.apache.org/netbeans/entry/what-s-happened-to-my#comment-1534413059000) that might help: &gt; If you need PHP 7.1 support, you can add the Latest Development Build catalog url, and update the plugins: &gt; http://bits.netbeans.org/dev/nbms-and-javadoc/lastSuccessfulBuild/artifact/nbbuild/nbms/updates.xml.gz
And not just this article alone, I checked all the post you made on Reddit and all of them were spams. Perhaps you should learn how not to spam Reddit, its not very nice. 
Yes it is evil, the correct way to write this code is: $flights = FlightRepository-&gt;findAll();
This is quite literally the best example of why it's difficult to find good information on the Internet, at times. Because this useless spam article exists and pollutes our search engines. It doesn't compare anything.
If you need the knowledge of what methods are being called in the implementation then you’re not even unit testing. By the very definition. You’re testing that some method is getting called internally (that’s what your describing). You shouldn’t be testing that because the internal implementation shouldn’t matter at all.
Any significant improvements in 9? Better tab drag and drop for example? Anything to justify the hassle? If not I'll just wait for 9.1 with PHP support
Maybe don't spam your shit?
I don't use Netbeans at all, haven't done that for the past 5 years. All I hear about Netbeans is rumors and that's why I said as far as I know, which implies what I've been told by others that use Netbeans. Netbeans itself have had support for multiple languages, including PHP, for a very long time in their product builds on their website. I know this because I used to use Netbeans. Unlike for instance Android development which required some plugins not maintained by Netbeans, i.e nbAndroid. Now, from what **I know**, all information I had was that "Apache Netbeans" had no official support for PHP. &gt; Netbeans has not been just a JAVA IDE for as long as I can remember? No, I was referring to Apache Netbeans.
Maybe that's why it got removed.
You can run the EAP for free.
Wow. I feel really bad that you had to go through so much!
It's bad but good for SEO :)
Search Engines are his audience.
Had that experience on Stackoverflow...been lurking there for decades until one day I actually had an answer to a question myself...tried to post it, was rejected due to low „stackoverflow karma“...never bothered answering anything again...
I‘m not involved in the development, but [Tobias Nyholm](https://github.com/Nyholm) is - maintainer of `php-http/httplug` - editor of [PSR-18 HTTP Client](https://github.com/php-fig/fig-standards/tree/master/proposed/http-client/), as you can see [here](https://www.php-fig.org/psr/). When the PSR gets adopted, then the package might eventually become the default implementation. 
Both.
Seriously this. I've been using PHPStorm for \~5 years now, never looked back to the monster called netbeans. There are free versions for students and OSS projects, also some other discounts: [https://www.jetbrains.com/phpstorm/buy/#edition=discounts](https://www.jetbrains.com/phpstorm/buy/#edition=discounts) &amp;#x200B; And then there is the EAP (beta) branch which is also free: [https://www.jetbrains.com/phpstorm/eap/](https://www.jetbrains.com/phpstorm/eap/) &amp;#x200B;
That would be too easy to get a real answer. Asking a random public will mostly only give you an educated guess. Unless a moderator from the correct subreddit responds, at which point, you were better off just asking the moderators directly. But I guess it's better to get an outrage train rolling as soon as possible. Why wait for more evidence when you can post an accusatory title with only a single (and possibly self-inflicted) blunder?
1) SPAs aren't well suited for all use cases and even have lots of problems even if they fit the use cases. Add progressive enhancement back to the table. (Yes that is poopy html, no JS required, but JS can improve things if feasible.) This is also - still - the apex technology if you want raw speed without faking everything or requiring huge initial downloads. So React is simply an option, not the best option you have. And if problems won't get solved, the whole front end ecosystem will endure another major ovehaul. 2) They all require node. Node as a platform wants to be on the backend and the frontend. I think that is a huge mistake to commit yourself so much to a single platform. There is a huge variety of options on the backend and many projects are already commited. The frontend just has node at least as a basic toolchain. I find that very ill minded. 3) You want to talk about religion? Believe in your god, but remain open minded to apostasy. Everything you noted has been there since the 60ies, there is barely anything new just few consultants that want to sell you stuff. At its heart programming is heavily bound to processing power and latencies of peripherals. If we improve these things by let's say factor 1000 without increasing power consumption, that will really change programming. But all you ask for is quite minor and just a matter of taste.
The preference was already visible in the image. He picked the python logo and made the php one up. -.-
Can you take a screenshot of the error message? Or at least paste it as is?
fucking hate that sort of thing.... makes it difficult to enter a community 
If you pronounce swoole in german, it sounds a lot like "gay".
Honestly in a *really* well factored code base static or global state can be absent. They are usually a pragmatic way to carry state through the whole application. IoC/DI can do a lot on this one but sometimes pragmatism is just easier.
They're planning it for a later release, but the 8.2 builds work fine. :)
Nice, thanks for the details 👍
Great, nice to hear. Thanks for the post. 
I keep meaning to try that, but the challenge of moving is not always cost. There's a certain amount of inertia in getting used to a new platform for coding - especially with the old IDE having become almost invisible and "comfortable". Learning the new dock system, UI and shortcuts can take a bit of time, but devs often want to be productive _now_. I took a look at Storm a couple of years ago, and it looked pretty good. My one bugbear was a projects organiser - in NB, one can have collections of projects (e.g. work and home, or collections for different clients) and I found it very useful to be able to switch contexts. It's called Project Groups. It's a trivial thing, but at the time, it was not featured in Storm. Do you happen to know if that's been added? 
In this case what does being open-source mean to the majority of people? More complicated setup, less features, delayed support, etc. I'm not going to fiddle with the source code and, let's be honest, almost no one else is either. If that is the case, then the only it has going for it is that you're getting it for free off the time and work of someone else. Personally, I'd rather pay a fair price for something that works fabulously right out of the box. Does the mantra "Use the right tools for the job" only apply to the software you are writing and not the tools you use to write that software?
With pleasure!
I agree. I don't use static methods for factories either (I don't see the point) but it doesn't shock me if I see it. Of course if the factory is totally bloated with static methods, this is another story.
Being open-source was not my main point (that's why parentheses). My point was: more choice we have can only be better for developers. Sure, some tools are better than others, but just pushing one without discussion is bad for competition and in this case off-topic and disrespectful to OP. That's like if you wrote something cool about PHP on r/programming and someone else just says: Go to [https://www.microsoft.com/net](https://www.microsoft.com/net) and download. Install...
I believe that not even I, in my strongest stage of being drunk, could ever write a code so bad like this one.
I don't see why it should be better than phpdoc
Does it still work? Yes? Great, keep using it. Want a replacement? Fork it. If you want a replacement, let us know what features you are looking for. Or search for replacements. Here are a few: https://github.com/ziadoz/awesome-php#documentation We can't read your mind to know what you want or how you used Sami.
I do quite often. You know, to give them valuable feedback on new features 
&gt; Does petting camels in New Zealand make you a better painter than owning several 90’s era Fiats? Yes. Petting a camel can help strengthen the forearm which is a key muscle in painting. Owning that many fiats doesn't help at all (though one could argue that aggressively driving with one hand on the wheel could be just as much as a benefit as camel petting). &gt; How do you feel about lipstick? Looks better than it tastes. &gt; Do 1860’s ideas about women’s rights make sense in today’s spacecraft? I need more context but generally speaking, no. &gt; Are these questions more or less random than OP’s? Yes, as well as more fun to answer. 
I appreciate the heads up, hopefully it helps someone. That said, I honestly can't imagine using Netbeans as your PHP Editor/IDE in 2018. Is it just that you really, really like Netbeans? Is there some agency forcing it's developers to use Netbeans? Given the numerous alternatives, both open source and commercial, that are vastly superior to Netbeans for PHP development (and web development in general), why Netbeans? Not trying to be a dick, genuinely curious.
How did you not find that... it's the first thing that pops ups when you type dashboard in the search...... and then you even complain about the docs...
Afaik you can add folders to your current project. I think they are called "content root" or something similar. The settings are searchable, so that would be a starting point I guess.
I agree with the choice. The problem is that while Netbeans, Eclipse, Vim and Emacs with a ton of plugins might be adding to the choice, they're in a completely different ballpark from Jetbrains products. Unfortunately, because I don't like that it's what it is. At the end of the day, when it comes to paying for the rent, I can't afford to use tools that don't make me productive. A little bit less would be ok to tolerate, but there's no comparison.
I see you point about the original reply being somewhat rude. But netbeans not being actively maintained (at least for PHP) definitely is a strong negative point. Waiting months (or longer?) for support for the current stable PHP version just isn't feasible if you aren't working on legacy projects only. There are other great alternatives already mentioned here, like sublime and even visual studio. Phpstorm just is the closest comparison to netbeans - by being a fully fledged IDE - and therefore a pretty good advice. Learning a new IDE isn't that hard if you've worked with an IDE before.
I lived in Salt Lake most my life until moving out to Richmond this year. What co-working space are you working out of there?
I'm with you. I'm still on NetBeans. It's a resource hog, but I have so much work to do and I have tailored NB to my needs. I even built my own custom theme. The idea of starting over is not enticing.
It's actually an excellent IDE. Works great, allows me to customize the formatting way better than and IDE I've used. The auto-complete functionality works perfectly. 
&gt; Given the numerous alternatives, both open source and commercial, that are vastly superior to Netbeans for PHP development (and web development in general), why Netbeans? &gt; &gt; I'm curious, what IDEs are "vastly superior" and why?
&gt; In this case what does being open-source mean to the majority of people? Couldn't this be said for the majority of open-source projects?
I wouldn't do it. While maybe not being actively maintained, Propel is still very stable software and its probably easier to just fork it and do the small necessary adjustments if needed than embarking in a month or yearlong refactoring. It obviously depends on the context, size of your Propel code base, buy in from management, personal resources.
That's respectful. Try well-respected professional...
[http://i.imgur.com/YO9YFgc.gifv](http://i.imgur.com/YO9YFgc.gifv)
Silver lining: https://secure.php.net/manual/en/mbstring.overload.php &gt; **Warning** This feature has been DEPRECATED as of PHP 7.2.0. Relying on this feature is highly discouraged.
Good. It looks like it is off by default on my server running 7.2
I'm curious what part of this post makes you think there's trolling involved?
&gt;If you need the knowledge of what methods are being called in the implementation then you’re not even unit testing. By the very definition. What? Behavior verification is a an old concept (I think it's being more than 10+ years since Fowler wrote that popular article about test doubles and they are even older than that) and it's still unit testing because you are verifying that the unit is interacting with the dependency correctly. That's how the mock concept was introduced.
You are, and will forever be, the security troll.
You didn't answer my question. This sounds like an off-topic personal attack (of the variety that the subreddit moderators have clearly stated are not welcome on /r/php, to boot) based on... what exactly?
Sorry for the hyperbole, it wasn't the best word choice. 
Thank you!
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [\[\/r\/PHP X-POST\] strlen() shenanigans](https://www.reddit.com/r/lolphp/comments/9h0jfj/rphp_xpost_strlen_shenanigans/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
[removed]
I didn't deny that it was superior. I asked why. I am honestly curious. I used it once or twice and while I found it's UI cumbersome, I was able to use it. I just didn't see anything it did that other mature also didn't do just as well. &gt; but you’d have a hard time making and argument it’s not the best PHP IDE available Instead of your defensive rant, I'd honestly like to hear that argument. &gt;I think VSCode is probably as good as netbeans. I'd question how much experience you have in either then.
&gt; strlen() does not get the length of the characters in a string, it gets the length of bytes in a string That's fucking stupid.
Unfortunately, the mb\_\* functions don't consistently follow Unicode best practices when it comes to dealing with invalid byte sequences. Let's take the sequence "\\xe8\\x80\\\\" for example. This sequence is invalid, because the first byte indicates a three-byte sequence, but the third byte is an ASCII backslash instead of a continuation byte. When a UTF-8 parser reads the first byte, it thinks, "Okay, this'll be a three-byte sequence. Codepoint bits: 1000. Looks good so far." Then, it would read the second byte and think, "Okay, continuation byte. Additional codepoint bits: 00000000. Looks good so far." It then reads the third byte and thinks, "Uh oh, this was supposed to be a continuation byte, but it isn't. This is invalid." At this point, a parser following best practices should take the first byte of the sequence, as well as any subsequent bytes that are "valid so far", and interpret that sequence as if it were a Unicode Replacement Character (U+FFFD, or �), and then behave as if the next byte begins a new sequence. In this case, the three-byte string above would be interpreted as a � followed by a backslash. Two characters long. PHP's mb\_\* functions don't do this consistently. The behavior seems to depend on which function you're using. For example, when mb\_strlen() encounters an error anywhere in a three-byte sequence, it seems to behave as if **all three bytes** were replaced with a replacement character. So, mb\_strlen() says the string is only one character long, because it wiped out the backslash. Similarly, mb\_strlen("\xf0\xf0\xf0\xf0\xf0\xf0\xf0\xf0") returns 2, whereas a parser following best practices would return 8. There's a reason I used a backslash character in my first example: Carelessly wiping out bytes like this can have security ramifications. That's exactly why the best practices are defined as they are in the Unicode standard. And then there's this kind of inconsistent behavior: mb_strpos("a\xe8ab", 'b', 0, 'utf-8') === 3 mb_strpos("a\xe8\x80ab", 'b', 0, 'utf-8') === 3 mb_strpos("a\xe8\x80\x80ab", 'b', 0, 'utf-8') === 3 mb_strpos("a\xe8\x80\x80\x80ab", 'b', 0, 'utf-8') === 3 mb_strpos("a\xe8\x80\x80\x80\x80ab", 'b', 0, 'utf-8') === 3 mb_substr("a\xe8\x80\x80\x80\x80ab", 3, 1, 'utf-8') === "\x80" mb_substr("a\xe8\x80\x80\x80\x80ab", 5, 1, 'utf-8') === 'b' wat. It looks like mb\_strpos() isn't even trying to parse the data. It's just counting the number of non-continuation bytes before the first match of the string. I'm sure that's more efficient, but I sure hope nobody is using this stuff on anything that hasn't already been properly scrubbed of invalid sequences in advance.
Why? It states exactly how the function works in the documentation. 
This is exactly the designed behaviour. Look at the main page at [ http://php.net/manual/en/ref.strings.php ]. It states “For working with multibyte character encodings, take a look at the Multibyte String functions.” NONE of the string (str) functions are multi-byte safe. Anyone using them as such is using a function improperly and while it might “work” (ie: if strlen($string) &gt; 0 or if strlen($string)==0), it is still wrong. 
Anything is possible however data migration is not a black and white issue. Also, instead of reinventing the wheel, does the POS system manufacturer have any extensions/modules/addons that provide web functionality? You will need to figure out how the POS system stores it's data: Does it include a DBMS or is the data stored in files? If stored in a database, is it accessible or is the username/password locked out? If stored in files, are they binary files? Does the POS system have export functionality? If the client wants the ability to write to the system (create sales, modify, etc), this will dramatically make the implementation more complex. 
Code is meant to be read by humans. A language's core functions should be intuitive to use and not require constantly checking documentation.
I didn’t actually look at the repo and figured it was an alternative HTTP library, ow that I know it’s a PSR-7 abstraction it makes a lot more sense
This is why people hate PHP.
No, it's not. A developer working in PHP should understand that the language has a history of acting as a super-layer over C, and that many of the functions were strictly wrappers over their C equivalents. So [http://php.net/manual/en/function.strlen.php](http://php.net/manual/en/function.strlen.php) is emulating [http://pubs.opengroup.org/onlinepubs/9699919799/functions/strlen.html](http://pubs.opengroup.org/onlinepubs/9699919799/functions/strlen.html) note: per the IEEE standard for POSIX C, strlen "shall compute the number of bytes in the string" This is exactly what PHP developers expect and has worked \_consistently\_ since PHPv1
I don’t know why you got downvoted, this is the best comment in here.
&gt; I sure hope nobody is using this stuff on anything that hasn’t already been properly scrubbed of invalid sequences in advance. Hold on, you want me to put *effort* into my work? No no no, you’ve got this all wrong. /s
Yup, that’s why I figured this would be a nice PSA, it wasn’t apparent to me when I first learned and I again just encountered someone who had no clue.
Doesn’t C have string functions of the same name as some of the php string functions that act the exact same? This seems more like a problem with the coders not understanding the language, rather than the language itself...
There was once a time when byte count did pretty much equal string length. This is one of those functions from way back then. To change the behavior of such a commonly-used function would break a lot of stuff. I'm sure there's an effort to deprecate `strlen` or it's result, but also think there is some wisdom in doling out such breaking changes over time rather than all at once with the release of PHP7 for example. It would have slowed upgrading, which was hard to convince people to do in the first place. I have hope some of this might get resolved by PHP 8.
Hardly a surprise worthy of a PSA, although good to know. That of course screams ASCII encoding which is one byte to a character and it was far and away the standard for a long, long time. It wasn't until the mid to late 90s that unicode was a thing at all and in fact Unicode and related stuff was partly behind Python 3. In any case these days you'd expect to be dealing mostly with UTF-8 or UTF-16. The former is very, vet common and basically compatible with ASCII anyway. 
Ha ha ha...
Presumably to behave otherwise would require implied awareness of other character encodings and auto detection inside what ideally is a nice static function of sorts...
I mean, the most reasons I get are: relatively it's slow, the community is not great (in regards to a lot of poor practices suggested), there's not very good support for asynchronicity, and the whole language was built on top of something it was never meant to be. The language it self is not usually what people complain about, but I also feel like most people complaining are people who love their language(s) of choice so much they don't really look past the "Why PHP is bad" blog posts.
When I say literally , it's not figuratively , it's literally over a decade old piece of criticism. Joel spolsky has specifically cited this issue and it's been discussed over and over Ill link a SO post that links to several of those, so to save you from going through Joel's verbiage https://stackoverflow.com/q/571694/408729 Personally I found out about this years after got used to using MB functions, for me it's more a piece of interesting literature. Its not like I'm going to attach this to a quote and my client is going to pay me to Port all their codebases to python or go because it's so much cooler 
 I got this part time gig fixing/overhauling a company's website. I am primarily a C/C++/Assembly programmer, and don't know any scripting langues. Their website built on wordpress, and it seems to have been entirely mis-managed \[excessive plugins, unused/outdated/empty pages, etc\]. In order to clean the website, I pretty much am trying to figure out if I should learn a scripting langue which works well with wordpress \[from my research It seems to be PHP\], which I don't have a problem with. Basically I just wanted to put my situation out there and see what you guys think. Any advice would be greatly appreciated. 
 I got this part time gig fixing/overhauling a company's website. I am primarily a C/C++/Assembly programmer, and don't know any scripting langues. Their website built on wordpress, and it seems to have been entirely mis-managed \[excessive plugins, unused/outdated/empty pages, etc\]. In order to clean the website, I pretty much am trying to figure out if I should learn a scripting langue which works well with wordpress \[from my research It seems to be PHP\], which I don't have a problem with. Basically I just wanted to put my situation out there and see what you guys think. Any advice would be greatly appreciated. 
Netbeans is actually a fine IDE to use. It works consistently on all platforms and the only 2 bad things about it is that it's not frequently updated and requires Java. I've yet to find an open source alternative that is as complete as Netbeans, if you have one, please share. easily working with Git, multiple open projects at the same time, refactoring, etc. PHPStorm is, in my opinion, on par with the feature set but costs money. I've checked multiple "Top IDE lists" and Netbeans is usually in the top 5 for PHP editors. And it's by far the most feature-rich one for free.
Likewise, none of the mb\_\* functions are binary-safe, unless you use '8bit' as the encoding, in which case it's just like using the regular string functions and is no longer UTF-8 safe. There are use cases for looking at a string as a sequence of bytes, and use cases for looking at a string as a sequence of Unicode characters. Every programmer needs to understand this distinction, or else you WILL screw something up. This is why mbstring.func_overload was such a bad idea and why I'm thankful it's being removed from the language.
Thank you, I will also check out VSC
I'm not up-to-date on Netbeans, I have not used it seriously since the 6.x series, when I used it full time for a couple years as it was what the team I was on used back then. It was perfectly fine and I'm sure it's still a good IDE. If you enjoy the setup more power to you. I appreciate the response and am most certainly not trying to start a my IDE can beat up your IDE battle. For the record, I am primarily a .NET Core and JavaScript/TypeScript developer right now and just do the odd PHP job (typically WordPress, Magento, or Laravel) on the side or as personal projects. I use VSCode for all of that. The plugin ecosystem for VSCode is staggering. The debugging for PHP projects is just as good as any IDE I have ever used, including PhpStorm. Add the xdebug plugin, edit the 2/3 settings it has, and you are good to go. I even debug remotely into my Docker containers without issue. The only things I am missing from PhpStorm (I used the intellij platform for like 5 years) are the deep integrations with frameworks like Laravel and Symphony and all their respective packages. If I were a full time PHP dev, I'd almost certainly be using PhpStorm for that reason. Though for all I know, someone already made a plugin in VSCode for that :) VSCode is open source and on an extremely aggressive release cycle getting big improvements every month. The ecosystem around plugins is second to none right now. Something worth checking out, anyhow.
PHP is a lot of things, but I would not call it slow. And speed has only increased with the 7.x versions.
Probably depends on your programming history. The length of a string to me is the byte count so it does what it says to me. It's not called char\_count. I'm sure people would complain that it doesn't work properly if they were using it in a HTTP Content-Length header and it was returning character count instead of byte length.
Yeah, I'm looking at it now. :) The only thing I *don't* like in VSCode so far is it doesn't have support for multiple workspaces, it appears.
Exactly the kind of shit that attracts negativity towards an otherwise decent tool. If you're curious about another one: &gt;checking if an key exists inside an array using **isset()** is wrong, **array\_key\_exists()** should be used instead Another case can be made that arrays in PHP are not exactly arrays, since they support both string keys, and integer keys simultaneously. &amp;#x200B;
PHPDocumentor is amazing. I just have two .bat files that I run before each push to repo - one generates html docs, the other - single-page md doc. Both are simple oneliners. Be aware, though, that there might be conflicts if you're using Twine in your project, and install PHPdoc to it. It requires Twine 1.3, support for 2.X is in the PHPdoc 3 milestones. 
The mb_ functions are a PHP-specific implementation of unicode, instead of being built on top of a standard unicode library like libicu. To the credit of the developers that wrote mbstring, at the time it was written there were no such libraries to build on top of. You have these options for UTF-8 aware string processing: * mbstring extension / mb_*: no external dependencies, but has compliance issues * iconv extension / iconv_*: depends on libiconv, limited set of functions, broader charset support than mbstring. * intl extension / grapheme_*: depends on libicu, does not measure length in code points but in graphemes (¨ + o = 2 code points and 1 grapheme), but is a reference implementation of unicode. You want length in code points because that's how db's measure character length, so this isn't really an option. In short, every way of handling unicode in PHP has issues, but mbstring is still your best bet since it has no external dependencies and its failure modes are of the sort that usually don't matter in practice. If you want to make sure you have a valid unicode string you can use intl's normalizer. Also, most db's have broken unicode implementations anyway, so you're bumping into unicode bugs one way or another. 
But don't use this to test for length before inserting in a database, since databases measure length in code points.
It's more stable than the nightly and (thanks to the tip below) 7.1 PHP support is in there too.
Awesome! I've added it to the guide.
I'd look into https://github.com/alefragnani/vscode-project-manager 
I'll look into it. The other thing I'm missing is "Include Paths".
&gt;This is exactly the designed behaviour. I mean, you're right, it's the *documented* behaviour, but I'd argue that the method name implies fairly strongly that's it's not the *originally intented* behaviour. ie the nature of strings changed before they had a chance to change the method, and now they can't change it so they did the PHP thing of adding another method instead. PHP, man \_shakes head\_
Just to add to this, it may also be worth running a malware search on the server (if possible) just in case it's already been hacked/backdoored. There's an open source program, [maldet](https://www.rfxn.com/projects/linux-malware-detect/), which will allow you to do this provided you have SSH access and enough system privileges to run the script.
Nice
&gt; Intuitive &gt; Unambiguous Pick one.
Personally, `strlen()` returning the number of bytes makes perfect sense to me. It's the length of the string - getting the length of something implies you are using units in your measurement. How annoying would it be to get the length of something with varying units? Getting the *amount* of *characters* in a string should, in my opinion, never be synonymous for the string length. Obviously there are going to be people who disagree because you have differing experiences shaping your view. Neither are wrong, but I think this way is better for consensus.
I disagree, I mean yes your explanation is why things like str_len() work they way they do, but the whole thing is still stupid, it is after all why they wanted to change all this and implement a more sane system in PHP 6 (which of course never happened).
until you realise user agent strings can be easily faked
The average Joe doesn't though, heck, even the people that know how usually don't.
Exactly, it's better to share your original one so you can get browser specific functionality.
If you only need a few browsers and operating systems, without information on versions and stuff like the rendering engine, a few if/else statements tend to do the job. The trick is to check specific browsers \*before\* checking the other ones as some of them include the name of others. Example: [https://developer.mozilla.org/en-US/docs/Web/API/Window/navigator#Example\_1\_Browser\_detect\_and\_return\_a\_string](https://developer.mozilla.org/en-US/docs/Web/API/Window/navigator#Example_1_Browser_detect_and_return_a_string) &amp;#x200B; &amp;#x200B;
^ this is why people don't like PHP, in a nutshell
From the sidebar: /r/PHP is not a support subreddit. Please visit /r/phphelp for help
Woops sorry didn’t see that.
The argument is it's _relatively_ slow. If you check out the benchmarks it's quite compared to a lot of compiled languages. I think it's important to look at/discuss the pros and cons of any language that's how languages/people evolve to be better. Don't kill the messenger, these are the things I hear.
&gt; I tried the get_browser() approach on just one string and it took way too long complete. We are using PHP 5.6.3, I read it is faster on 7.0 though. I can only imagine how slow it would be to resolve maybe 10,000 - 20,000 of them. Also the system admin says that we can not update or add that functionality. This makes me sad.
netbeans in a java,php,javascript and C++ IDE.
We do not agree here. StringUtils is a great example for everything that is terrible about static. DI is not about state, it is all about interfaces. DI pulls out object construction, which in turn makes it easier to service interfaces. Interfaces simply should not control the construction process and they obviously cannot (and neither should) handle static classes. If you use a StringUtil::upper, you cannot replace it without touching the code. If you implement an StringToUpper interface you can replace the implementation and even leave old code alone which relies on buggy behaviour. Of course doing it this way is very unpleasant, static is a midground but it is usually less flexible and more volatile. 
OP wrote: &gt; We log certain events on client websites, when certain events occur (and they occur often and often on many websites with a lot of traffic). We log the user agent string along with other information. If there's scraping or other attacks, UA string will be useless.
&gt; netbeans in a java,php,javascript and C++ IDE. What?
Yeah they contribute nothing.. https://www.jetbrains.com/opensource/. Everything can't be free, people have to eat and I don't mind supporting a company that makes an awesome product. Sorry, but if your editor of choice is so sub-standard that it depends on hand-outs then maybe you should re-evaluate. 
And if you want even more functionality, look at using a library that extends like like [Chronos](https://github.com/cakephp/chronos)
&gt; This is very debatable Not really. https://netbeans.org/bugzilla/show_bug.cgi?id=268317
there were 5 missing features that are now in the status of complete. what's the issue? that a p2 wasn't addressed fast enough? How fast are p1 issues addressed?
I don't know how capable you are, but let's assume, you're a quick learner. Then see this: https://sylius.com/
&gt; there were 5 missing features that are now in the status of complete. what's the issue? that a p2 wasn't addressed fast enough? Given that all this was available in PHPStorm a year earlier, no, it wasn't addressed fast enough. 
this seems like a forest for the trees problem. ..and certainly not a major issue at all
I'm assuming he is referring to how asset checks if a variable is set and not null. Take a look at these tests: [https://imgur.com/4rGoCZq](https://imgur.com/4rGoCZq)
J.F.C.
jetbrains contribute nothing? nearly all developers ive seen in the last 3 years run phpstorm... unless you consider providing the best tool on the market for years on end to amount to nothing...
I don't see a single PHP static analysis tool in that list.
&gt; jetbrains contribute nothing? nearly all developers ive seen in the last 3 years run phpstorm... unless you consider providing the best tool on the market for years on end to amount to nothing... It amounts to nothing if the code is proprietary.
that is utter bullshit.
Oh, so we went from contribute nothing to cherry picking. Nice framing.
Question for the PHPStorm users: Does the trial version work 100% or are some features disabled? I recall trying it at one point but I couldn't actually do everything I was doing with Netbeans (SFTP upload on save). I was taught Netbeans in college and it's all I've used. If PHPStorm trial can handle my normal workflow then I'll give it a try.
Zephir was created by the people who created Phalcon. I am a big supporter of Phalcon and have used it on several projects. The performance is unparalleled in a lot of areas.
To my knowledge there are no limitations other than it's limited to 30 days.
Agreed. That's way too high for a health check. At work, we built a reasonably complex computation API, with configurable business logic, and a performance goal of &lt;100ms even under moderate load. We were able to hit that without too much trouble, utilizing redis caching to avoid excessive database calls and subsequent object hydration. We used Apache, PHP 7, and Symfony framework. Pretty typical stuff. &amp;#x200B;
Yes we do not agree. 
So because PHP has some warts it means we should be fine with shit code and bad patterns and if we're not then we're pretentious tools? lol. K, guy.
I've actually resorted to my own pure-PHP implementation of Unicode parsing, because I favor correctness over performance. That said, it turns out the performance difference is a lot smaller than I would have expected, and, bizarrely, my implementation is actually faster than mb\_\* for certain operations, like backward searching. And yes, I'm properly detecting error conditions like overlong sequences, surrogates, &gt;4-byte sequences, and unexpected-end-of-string, replacing the correct number of bytes with U+FFFD in each case.
So what exactly does PSA stand for in this context? Tried searching. Got a lot of links dealing with the prostate. But I'm guessing it means something different.
More spam from India.
&gt; To the credit of the developers that wrote mbstring, at the time it was written there were no such libraries to build on top of. icu and iconv both pre-date php's mbstring by several years. &gt; mbstring is still your best bet since it has no external dependencies That's bonkers. What do you gain by not utilizing widely used libraries like libiconv?
Awesome, never questioned `isset()` before.
dude, I've seen shit code in practically every programming language on the market. PHP isn't an exception to quality code, nor is it unique but if code works? It works, and uppity assholes that look down on functional code for not being pretty enough, are pretentious tools that should get off their high horses and appreciate code is there to do a job, it's not about art or theory, it's about getting the job done.
It is not like I wanted to.
People don't like PHP because it's a programming language devised and used by *programmers*? That makes absolutely zero sense
iam not sure whether this is active developed anymore but there is also ApiGen https://github.com/ApiGen/ApiGen which you can checkout
Yes. To suggest injecting interface for upper casing a string, you’re really trying hard not to. 
&gt; dude, I've seen shit code in practically every programming language on the market. This has literally nothing to do with my point. &gt; PHP isn't an exception to quality code, nor is it unique but if code works? It works, and uppity assholes that look down on functional code for not being pretty enough, are pretentious tools that should get off their high horses and appreciate code is there to do a job, it's not about art or theory, it's about getting the job done. This is a terrible attitude to have. There is so much more than code being functional to be "an angelic piece of perfection." Testability, maintainability, and readability are all very, very important in maintaining a large codebase across a team. Your attitude might work on a small codebase or as a lone wolf, but your mentality that anything that works is good enough is fundamentally flawed. Encouraging or discouraging certain practices is about maintaining the overall health of the application for the long term, not about being a "pretentious tool on a high horse." Frankly, you sound really naive. 
I assure you I'm not. I'm simply experienced enough to know what happens if "it works" is your only measure of quality. It simply does not result in a healthy team or application over the long run. You will be a better software engineer if you learn this as well, but instead you're digging your heels in. Which is fine - it'll only cost you in the long run. Just recognize that you're willfully accepting mediocrity over getting better.
You're welcome to your opinion, but that's all it is, an opinion and one that I disagree with. So you're welcome to code however you think works, and that's 100% irrelevant to me but I stand by my opinion.
Ooooo. Very interesting. Didn't know this. Thanks.
Deal, and you keep being a pretentious ass. It'll all work out in the end.
Question *everything* lol
Have you not seen https://www.reddit.com/r/PHP/comments/9f62ix/introducing_symfony_panther_a_browser_testing_and/?st=JM9H53CM&amp;sh=9440574a?
ICU doesn't predate it, mbstring shipped in 2001 but work started on it in 98. ICU first shipped in 99, and it didn't get a license that was PHP license compatible until 2001, 10 days prior to mbstring shipping in PHP. Iconv historically was a very strange beast, with wildly varying compatibility across unices, and troublesome support on windows. I wouldn't be surprised there were good reasons for it not being an option for CJK support back in 1998 - 2001. Looking into it, you're right about iconv though. It's bundled with PHP these days, so you can rely on it always being there.
&gt;If you use a StringUtil::upper, you cannot replace it without touching the code. If you implement an StringToUpper interface you can replace the implementation and even leave old code alone which relies on buggy behaviour. &amp;#x200B; You also cannot replace the built in function `strlen`. But nobody in their right mind would suggest injecting a `StrLen` interface everywhere that you'd want to use `strlen`. Static methods are the same thing. As long as the static method is pure and unit tested by itself, then it is perfectly good practice to use it as you'd use another function.
Meh. I don't buy that. If you're a PHP5/WordPress person, maybe. PHP7, while not without some warts still, is a pretty solid language, especially when paired with a modern framework. Most of this idea that PHP is "shit" comes from the old PHP4 days. It's objectively not shit anymore. It just can't shake the stigma.
["and symphony"](https://i.imgur.com/zy4JzVt.png) When will we get pure libraries again? :(
You can use it in other projects, doesn’t have to be Symfony.
It's laravel dusk.
OP doesn't give a shit. They're a spam account.
 "require": { "php": "&gt;=7.1", "facebook/webdriver": "^1.5", "symfony/browser-kit": "^4.0", "symfony/polyfill-php72": "^1.9", "symfony/process": "^4.0" }, You can use it standalone. It just contains some additional wrappers for the integration w/Symfony.
That is what I said.
You have to use json\_last\_error() to get the error.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I used to do that until i started using breakpoints. Being able to see everything the code is doing as it runs, including any variables and data currently in memory has saved me so much more time over writing print and var_dump everywhere.
You'll be able to throw exceptions in 7.3: https://wiki.php.net/rfc/json_throw_on_error
That is good that they recognise it is "sub-optimal". 
another "ad hoc magic stunt" written by someone that did a little too much C and don't know anything else. reminds me that `$http_response_header` variable created out of thin air... modern they say...
Why was Number Format Separator rejected and why does nobody think switch statements need improved?
\[reichwebconsulting/array-filters\]([https://github.com/reichwebconsulting/array-filters](https://github.com/reichwebconsulting/array-filters)) Elevator pitch: reichwebconsulting/array-filters a library for making filtering and mutation of arrays less monotonous. &amp;#x200B; Use case: you have a result set in one format. You need it in another format. Or, you need only a subset of the data in the result set. For example, you're pulling data from database resource whose schema doesn't match the schema you want to present to the public in your API. This library provides simple mechanisms for renaming keys. Let's say your dataset contains sensitive information you don't want to output to users without a certain level of security. This library provides simple mechanisms for filtering arrays a subset of keys. The library also provides filter chaining, so you can build complex array mutations by chaining simple mutations together. &amp;#x200B; \*\*But PHP already has robust array callback functions that let you do these sorts of things!\*\* Yeah, and we use them on the backend! &amp;#x200B; This library is a growing work. It meets my current needs. I don't expect it will meet everyone's.
Pure functions aren't mutative. But how the other commenter is describing it, a deterministic function could still be mutative.
TIL it become a mainstream to come out telling everyone you don't read the manual and then gets surprised with the function's documented behavior.
Does it mean that writing my_json_decode() is way messier than json_decode()?
I would suggest json_last_error_msg()
[removed]
RTFM
I got around it a bit by configuring my IDE to outcomplete "pre" with the following: echo "&lt;pre&gt;" . __FILE_ . ":" . __LINE__; print_r(); echo "&lt;/pre&gt;"; die(); I just type the variable in there is all. It's not perfect, but the last time I tried getting xdebug working with CakePHP and NetBeans it was a joke. It sort of worked. Where as typing pre and it auto outputting all that for me always works.
I appreciate your comment but can you explain how it's unreachable? I don't think it is.
While writing my comment (on mobile, mind you), the indentation was a bit off and I didn't consider the body of the if to be without braces, so your dump looked to be just behind the exception throw. That would make it unreachable, but when looking at it now, I see it would dump if the exception isn't reached.
Either way, "crafty one-liners" always inferior to crafty user-defined functions. 
[@Flipper's latest tweet](https://i.imgur.com/v2RbliV.jpg) [@Flipper on Twitter](https://twitter.com/Flipper) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
I mistakenly attended a Java meetup and discovered Graalvm, and discovered the Java people have gone mad, and made a compiler for many languages that all benefit from things like being able to debug the language in chrome's debugger and use mature monitoring tools, compile to native, intropt with each other i.e. Python inside a JS program or vice versa &amp;#x200B; So far they have python, ruby, R, JavaScript, if PHP was in that list I think it's possible that I'd never have to try and configure xdebug again
I think a good practice is to make all the classes final and to mock only interfaces.
ELI5 please, what a universal virtual machine for running applications is and what is it good for?
You could debug PHP like this: [https://github.com/chrisseaton/graalvm-ten-things/raw/master/fizzbuzz-rb.png](https://github.com/chrisseaton/graalvm-ten-things/raw/master/fizzbuzz-rb.png) You could profile PHP like this: [https://github.com/chrisseaton/graalvm-ten-things/raw/master/visualvm-rb.png](https://github.com/chrisseaton/graalvm-ten-things/raw/master/visualvm-rb.png) So from a PHP prospective, there are big tooling wins, from a runtime prospective, that gets better when they improve graavl, then there's optional interop with other languages, i.e does your PHP application need a specific functionality like a mathematical library? Then import that library from another language For more details read 3 onwards in this list: [https://github.com/chrisseaton/graalvm-ten-things](https://github.com/chrisseaton/graalvm-ten-things)
Because it's documented does not mean it's good behavior. 
If your project depends on Guzzle, you can use their functions: https://github.com/guzzle/guzzle/blob/master/src/functions.php#L300
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [guzzle/guzzle/.../**functions.php#L300** (master → c7faf23)](https://github.com/guzzle/guzzle/blob/c7faf23816251ca3f35463c55f3178a9b60128fc/src/functions.php#L300) ---- 
*What could possibly go wrong with a title like that.*
K. 
Only works on PHP 5.5 and up though...
So when showing an (in)valid value, every character counts because errors can be triggered by a single misplaced space... but when handling a filename, let's get rid of about half of the exact absolute path because it's not pretty enough? I don't think so.
This means PHPStorm-specific hacks like `ArrayObject|string[]` can now be rewritten as `ArrayObject&lt;int, string&gt;`
This is the most exciting news I've heard this month!
I'm not sure if I understand how you would use a library from another language. What if I want to use a class from a library , into a non-OO language? Or is it more like how you use assembler in C++?
'Mistakenly' :-)
^^Shameless ^^self-promotion ^^below If you need to work with not-quite-well-formed JSON, you could try parsing it with the [colinodell/json5](https://github.com/colinodell/json5) library. It'll accept things like single quotes and also throws exceptions if parsing fails.
Like the first one wasn't slow a fuck enough? Having had to replace that garbage in a months long effort was certainly not fun. Has the author ever heard of running a fucking profiler and writing performant code? What a piece of garbage, especially when combined with doctrine 2. It's a nightmare I simply can't wake up from unless I quit my job. 35% faster is nowhere fucking near enough. 
That's not a PhpStorm specific hack, it's been a de facto phpDoc practice for quite some time.
I mean.. doctrine ain't doing you any favors either.. :P
Sort of like what I've been working on: [https://github.com/ellisgl/GeekLab-ArrayTranslation](https://github.com/ellisgl/GeekLab-ArrayTranslation)
Much constructive, such positive 
That's all I want... The weakest part of PHP is that it has to do repeatedly work other platforms do just once on startup. Good job.
Finally! A dream coming true. &lt;3
Stfu up and gtfo 
I made a http client in t-sql that parses json responses, a few months ago. Quite fun.
It’s completely broken on mine (yesterday’s EAP). If you have something like `ArrayCollection&lt;Thing&gt;` PHPStorm doesn’t extrapolate the inner class when you’re iterating. Inspecting one of those results yields that PHPStorm just drops it altogether and says that it’s just an `ArrayCollection`.
If this could be implemented, this would be a fantastic addition. Hell I'd probably just pre-load everything in App and Vendor. Hopefully it would not be an INI directive and could instead be defined in the code for a specific entry point - even if it only picks it up on the second request. if (opcache_defer_loader(__FILE__, __DIR__ . '/../opcache.php')) { header('location: xxx', true, 307); exit(); } With things such as CI/CD pipelines I wonder if we'll ever get a PHP equivalent of composer --dump-autoload / -o where we can just feed it a few thousand files as command line arguments and it will compile and optimise them, and store the bytecode in a binary file, file moving the entire compilation stage to build. ^ Bonus points if I could tell it to "know" all the classes it encountered and skip the autoloader.
That is some hideous code, if statements nested 4 or 5 deep. Anyway, php 7.2 is faster then HHVM. I highly doubt some random fileio operations are going to increase performance. Unless you're writing hideous code, php and the webserver is rarely the bottleneck. Scaling a webserver is trivial, database is the challenge. 
I also have to disagree. There's something called a stacktrace for debugging. And when an unhandled exception is thrown, obviously you have to dive into the code, debug and fix it. So why should I add the whole parameter path, more details about the incorrect value, etc.pp. It just leads to duplicating, actually. And your exception messages will easily get outdated. Business requirements changes all the time - people update the code, but forget to update the exception message. Then you even have wrong information in your exception message. Instead of being helpful, it is not only a duplication of information, but even contains wrong information... I prefer the "KISS" principle. And sure, the exception name should contain the specific problem. E.g. \`FileSystemException()\` is not really useful, when you could break it down to more specific cases, e.g \`FileNotFoundException()\` or "DirectoryNotWritableException()", etc.pp.
Sounds like someone hasn’t done real profiling. In a real-world application with database access, about a third of my request lifetime is just waiting on the autoloader. Incidentally, this is a big part of why ReactPHP and similar tools gain so much performance over PHP-FPM. 
No one loves exceptions.
The other reply to you comment explains the performance benefits, but I’d like to add that having indentation 4-5 levels deep isn’t unusual at all. If you can find a language runtime that *doesn’t* have an unusually high nesting levels and cyclomatic complexity, I’d be amazed.
Oh my god, yes, finally! That's all I ever wanted! I don't even care about runtime checks, I just want to be able to annotate it properly! God yes.
If the debug stacktrace is helpful and helps you to solve the issue in mater of seconds, why not. In my experience, most of such digging into 5th or 6th level could be replaced by the simple message: '"garbage_collertor &gt; allow": can be only "true" or "false", "yes" found. Instead of "invalid parameter type". The more code is read, the more time will such messages save me. Mostly in frameworks like Symfony, Laravel or Nette would save me dozens of hours in stracktrace. Also, many debuggers display only first message and you need to know that `--debug` or `-vvv` parameter displays the stacktrace. Most people reporting issues on my packages don't know how about presence of such parameters.
Of course it's better if it just works :) What about a helpful exception that will save your googling in Github repository?
I'm curious, could you share PHP snippet with format of exception you'd prefer?
I just released \[Twine 3.0.0\]([https://github.com/PHLAK/Twine/releases/tag/3.0.0](https://github.com/PHLAK/Twine/releases/tag/3.0.0)) and the new Twine Docs (linked in OP) and wanted to share.
Question: why use this vs normal json_decode ?
You probably need key and element type. 
Why don't you use class mapping in production?
There are styles of programming where nesting is avoided, typically return statements throughout the method when each case is handled. In loops breaks and continues can be used. Nested if's = spaghetti code. 
Why not just let php handle the opcode caching of what's requested? Isn't this supposed to be automatic? 
What's the difference between: ``` * @param Foo&amp;Bar $var ``` And ``` * @param Foo|Bar $var ``` What's the specific need for `&amp;`?
Things can get more complicated than what json_encocde/decode can do... in that case you need a serializer. You might want some properties to have different name, some to be skipped, some to be taken from external services, some to be taken from inner objects... 
Docker is slow on Windows (and months ago on Mac), on Linux is faaaast!
I use it in production and it has not any drawback for us so far. It actually helps enforcing strict typing, as the scalar handlers will only be called when you use -&gt; on the correct type. For instance, calling "2"-&gt;abs() will fail since "2" is a string, not an int. Scalar Object Handlers will not do type juggling for you, but we see this as a good thing as it improves type safety. It is a little bit slower than using primitive functions, but my analysis shows that this is caused by implementing scalar object handlers in PHP userland. I used to try implementing scalar object handlers as a C extension(on my old PC, the work was lost when it died), it was about as fast as using PHP built-in scalar functions. But anyway, the performance hit with scalar object handlers is never as important as database trips. If it actually becomes an issue, then just write handlers in C. Maybe I will pick up the work for scalar objects handlers as C extension one day when I am less busier. 
Oh, I am full aware of those pains. Mac at home/personal, Windows for work. I do pretty much all my development in a Linux VM for work.
Hmm.. you could be right. This seems like a bug to me. There are certainly cases in which this could be used that there are no keys (eg generators).
The opcode cache isn’t remotely close to as fast as actually having it fully loaded in memory. It lets you skip one step, but there are others that opcache doesn’t solve. 
I do. 
Then is the issue IO? 
Honestly, I have no idea. My data (Xhprof profile dumps) is based out of reading from a warm opcache (so it's still in memory, not hitting the filesystem), but on a request that's taking ~1300ms I see about 360ms in `Composer\Autoload\includeFile`, which is a simple wrapper around `include`. For comparison, there are 18 calls to `PDOStatement::execute()` which _total_ 40ms. That same request, when run with ReactPHP instead of PHP-FPM, I see completing in 1/4 the time - _less than the time just spent in the autoloader under FPM_. Other less-complex requests are over an order of magnitude faster. That's not an entirely fair comparison due to a couple of bugs in my React prototype, but it's pretty close. For what it's worth, there's a point where classmapping becomes counterproductive: loading the classmap takes more time in aggregate than computing the file path. I have no idea what that cutoff is, but it's related to when an average request only needs a sufficiently-small percent of all classes in the project (including vendor classes)
&gt; function \_preload($preload, string $pattern = "/\\.php$/", array $ignore = \[\]) { ... &gt; &gt; if (is\_dir($path)) { &gt; &gt; if ($dh = opendir($path)) { &gt; &gt; while (($file = **readdir**($dh)) !== false) {.... &amp;#x200B; And now, we kill any performance gain. &amp;#x200B;
Interesting issue! I believe the libphp5 (called mod_php on some distros) is tied to a php version. So if you install php 5.5 from a repo, it should also have a libphp5.5 or some equivalent. It's just as if you installed a base php 5.5 and then wanted to add the iconv module. There is an iconv module pegged to php version 5.5. It is my understanding that the libphp creates the bindings between Apache and the system's php (which is in turn 'embedded' into each httpd process). I would advice against having all the php versions in the same docker container. In theory you could have them all installed along with matching libphp versions and swap them out in the Apache config... but I think you're more likely to enter a dependency hell. A lot of the php modules rely on other system libraries and will require certain versions. So now you're looking at not only installing a bunch of php versions, but also other non-php software (like libpng for the gd module). Containers free you from this dependency hell. Make a docker container for each php version and just switch between containers. You could even run them all simultaneously, point them to the same local WP path, and then see how the app runs in each version. 
It might be author's blindness, because from &lt;code&gt;DirectoryNotWritableException&lt;/code&gt;, I have no idea what should I do :). That's what I mean by "you know that feeling when you see an exception and you know to do, but other doesn't". It's really hard to put one's shoes once you know the solution. My post is a call for empathy for those who're not there yet, to make the path easier for them. I'd appreciate clear message at first sight even in a project I'd taken over from you. PS: Thanks for feedback, I'll :) Feel free to comment on some posts, I'd love to know if someone is aling with my opinions.
I only use \Exception and trigger_error(). I don't understand the love to create dozen of classes with limited usability. 
Interesting. So with this I could register Twine as a string handler?
Static PROS performance reduce memory costs **good testability Assert.AreEquals(SomeClass::staticfunction($values));** ...etc CONS stored variable ...etc Fixed. &amp;#x200B;
Java is blazing fast, it's one of the fastest languages around here. However, its bloated. For example even a small hello world in spring boot feels painful slow. 
Could you share real code of using both? I have no idea how would that be clear enought to me.
nice. dumb that it's not been fixed over the decades, but it's cool that you did the work :D
This RFC would have been amazing for this: https://wiki.php.net/rfc/function_autoloading (You know instead of automatically defining everything at run time start even if you won't use 99.9% of the functions)
I'm a big fan of [Stringy](https://github.com/danielstjules/Stringy). What would the pros and cons be between Stringy and Twine? The encrypting and hashing methods seem convenient but it feels like they sit outside the scope of standard string manipulation. 
The way this is implemented is a really really bad idea. For some reason when I looked at it there is a function missing to make it work at all. Even when implementing this functions `eval()`ing code like that to create the function will totally fuck up your error messages. Good luck debugging your code.
I use \\Exception on public libraries and a mix between \\Exception and trigger\_error() with private projects. trigger\_error() is not catch-able (you can't try catch) but the function that call the error can continue the flow with @functionThatCallTriggerError(). 
Through my career I've found that SOLID principle is very expensive for the business due to over engineering. I've written a couple of articles on this subject, may be of use to yourself [http://inevitabletech.uk/blog/why-not-a-solid-kiss/](http://inevitabletech.uk/blog/why-not-a-solid-kiss/). Leave feedback to make it better!
The process of adding the profiling itself will have a noticable effect. Leaving this post here to remind me to post an autoloading profiler later on.
Hey, Sentient\_Blade, just a quick heads-up: **noticable** is actually spelled **noticeable**. You can remember it by **remember the middle e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey CommonMisspellingBot, just a quick heads-up: Fuck off, It's 2 am and I'm tired. Have a nice day!
But, when or where is it called?. Let's say that we have a file called coldstart.php, so we should call it every time we want to cache all the files. However, it's a pita to do it manually. Or we could add and execute in some common code. if ($something) { // it s\*cks to be the user that call this slow function! \_preload(); } I don't know what is the real advantage. Maybe it could be useful if we could disable timestamp validation. However, I don't think that it's safe for production (updated code, evicted cache, etc.) &amp;#x200B; &amp;#x200B; &amp;#x200B;
If you don't do a "timebomb" loop then your code is "lock or die trying". You can't find any database that does that. &amp;#x200B;
It will, but I believe it will increase everything in a fairly uniform manner across the request (for xhprof, at least). I’m more interested in the relative numbers than the absolutes in this case. 
In version 2, can you have it unify the order of parameters?
yeah, the point is that the syntax is now supported. So even if neither you nor I needs the syntax, it's there for some future use-case we haven't thought of yet.
This is pretty neat. I would never use it though, for the same reason I wouldn't ever use aliases in bash. Next time I am on another system I'd start typing invalid functions.
I notice the OP uses sprintf for filling in the variable in the exception message. Is there a reason for this or just preference? Is there a potential security problem with putting unfiltered variables into an exception message. I do stuff like this often: throw new \LogicException("Argument must be either this or that, received: '$variable'");
Drupal
Looks nice. If this is your projectm just a suggestion: the home page animation, it is really slow (i was sat there waiting for it to type out). maybe speed it up double speed or something :) ?
If you're using a recent PHP version and opcache, loading the class map should be free. It lives in SHM and is shared *without* copying it to process memory. The reason why autoloading still takes a lot of time is likely that classes still need to be copied from SHM to process memory (not everything, only certain parts that may be modified at runtime) and then need to bound (including in particular inheritance, which is a quite expensive process).
&gt; many more methods built-in The purpose of the Scalar Objects extension isn't to ship any methods - it's only to make this way of adding them possible. &gt; the added ability of method chaining Scalar Objects enables chaining method calls on...scalar objects. By the look of your demo, it seems many of your methods don't support chaining. Given the methods exist in a class registered with Scalar Objects; you should be able to chain them, and the scalar's value will be unboxed as required in situations that would require a cast. &gt; You also don't need to install a PHP extension for Twine Fair point. I would love an automatic boxing/unboxing solution in userland. Sadly, I think the neatest solution will be with a custom compiler or preprocessing. Now, consider what it would be like if we could add methods on arrays (without the scaffolding that `Iterator`/`IteratorAggregate`/`ArrayObject`, and with unboxing for built-in methods); and if we could add methods on numbers. Imagine we had `__toNumber` and `__toArray` methods, or something like Scalar Objects built in...
You mean after the confirmation of [typed properties for php 7.3](https://wiki.php.net/rfc/typed_properties_v2). Right?
I like the idea, but would rather it be a code generator rather than `eval`
I would address your issues by approaching it thus: [https://3v4l.org/jtdJE](https://3v4l.org/jtdJE)
Would it be reasonable to open and re-use PDO connections in this way? its a huge dump of time for each request to setup a PDO.
[removed]